file_diff,commit_time,file_diff_id
"@@ -18,13 +18,28 @@
 
 package io.undertow.protocols.ssl;
 
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+
 import io.undertow.UndertowLogger;
+import io.undertow.connector.ByteBufferPool;
+import io.undertow.connector.PooledByteBuffer;
+import io.undertow.server.DefaultByteBufferPool;
 import org.xnio.Buffers;
 import org.xnio.ChannelListener;
 import org.xnio.ChannelListeners;
 import org.xnio.IoUtils;
-import io.undertow.connector.ByteBufferPool;
-import io.undertow.connector.PooledByteBuffer;
 import org.xnio.StreamConnection;
 import org.xnio.XnioIoThread;
 import org.xnio.XnioWorker;
@@ -40,25 +55,15 @@
 import org.xnio.conduits.StreamSourceConduit;
 import org.xnio.conduits.WriteReadyHandler;
 
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLEngineResult;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.FileChannel;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
 import static org.xnio.Bits.allAreClear;
 import static org.xnio.Bits.allAreSet;
 import static org.xnio.Bits.anyAreSet;
 
 /**
+ * Conduit for SSL connections.
+ *
  * @author Stuart Douglas
+ * @author Flavia Rainone
  */
 public class SslConduit implements StreamSourceConduit, StreamSinkConduit {
 
@@ -117,6 +122,13 @@ public class SslConduit implements StreamSourceConduit, StreamSinkConduit {
     private static final int FLAG_READ_CLOSED = 1 << 14;
     public static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
 
+    /**
+     * Buffer pool created and used only when large fragments handling is
+     * enabled in the underlying SSL Engine. When this happens, we need
+     * a specific buffer with expanded capacity.
+     */
+    private static ByteBufferPool EXPANDED_BUFFER_POOL;
+
 
     private final UndertowSslConnection connection;
     private final StreamConnection delegate;
@@ -898,21 +910,27 @@ private long doWrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcepti
             wrappedData = bufferPool.allocate();
         }
         try {
-            SSLEngineResult result = null;
-            while (result == null || (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP && result.getStatus() != SSLEngineResult.Status.BUFFER_OVERFLOW)) {
-                if (userBuffers == null) {
-                    result = engine.wrap(EMPTY_BUFFER, wrappedData.getBuffer());
-                } else {
-                    result = engine.wrap(userBuffers, off, len, wrappedData.getBuffer());
-                }
-            }
-            wrappedData.getBuffer().flip();
+            SSLEngineResult result = wrapAndFlip(userBuffers, off, len);
 
             if (result.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
-                throw new IOException(""underflow""); //todo: can this happen?
+                throw new IOException(""underflow""); // unexpected result
             } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
-                if (!wrappedData.getBuffer().hasRemaining()) { //if an earlier wrap suceeded we ignore this
-                    throw new IOException(""overflow""); //todo: handle properly
+                //if an earlier wrap succeeded we ignore this
+                if (!wrappedData.getBuffer().hasRemaining()) {
+                    if (wrappedData.getBuffer().capacity() < engine.getSession().getPacketBufferSize()) {
+                        wrappedData.close();
+                        final int bufferSize = engine.getSession().getPacketBufferSize();
+                        UndertowLogger.REQUEST_IO_LOGGER.tracev(
+                                ""Expanded buffer enabled due to overflow with empty buffer, buffer size is %s"", bufferSize);
+                        if (EXPANDED_BUFFER_POOL == null || EXPANDED_BUFFER_POOL.getBufferSize() < bufferSize)
+                            EXPANDED_BUFFER_POOL = new DefaultByteBufferPool(false, bufferSize, -1, 12);
+                        wrappedData = EXPANDED_BUFFER_POOL.allocate();
+                        result = wrapAndFlip(userBuffers, off, len);
+                        if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW &&
+                                !wrappedData.getBuffer().hasRemaining())
+                            throw new IOException(""overflow""); // unexpected result
+                    }
+                    else throw new IOException(""overflow""); // unexpected result
                 }
             }
             //attempt to write it out, if we fail we just return
@@ -952,6 +970,19 @@ private long doWrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcepti
         }
     }
 
+    private SSLEngineResult wrapAndFlip(ByteBuffer[] userBuffers, int off, int len) throws IOException {
+        SSLEngineResult result = null;
+        while (result == null || (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP && result.getStatus() != SSLEngineResult.Status.BUFFER_OVERFLOW)) {
+            if (userBuffers == null) {
+                result = engine.wrap(EMPTY_BUFFER, wrappedData.getBuffer());
+            } else {
+                result = engine.wrap(userBuffers, off, len, wrappedData.getBuffer());
+            }
+        }
+        wrappedData.getBuffer().flip();
+        return result;
+    }
+
     private boolean handleHandshakeResult(SSLEngineResult result) throws IOException {
         switch (result.getHandshakeStatus()) {
             case NEED_TASK: {",2020-03-10T19:18:10Z,185
"@@ -0,0 +1,60 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers.session;
+
+import java.nio.ByteBuffer;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpOneOnly;
+import io.undertow.testutils.ProxyIgnore;
+import org.junit.BeforeClass;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs {@link SSLSessionTestCase} with an expanded buffer SSLEngine,
+ * and verifies if {@link javax.net.ssl.SSLEngineResult.Status#BUFFER_OVERFLOW}
+ * is handled appropriately.
+ *
+ * @author Flavia Rainone
+ */
+@RunWith(DefaultServer.class)
+@ProxyIgnore
+@HttpOneOnly
+public class SSLSessionWithExpandedBufferTestCase extends SSLSessionTestCase {
+
+    @BeforeClass
+    public static void setup() throws Exception {
+        final SSLContext context = SSLContext.getDefault();
+        final SSLEngine firstEngine = context.createSSLEngine();
+        firstEngine.setUseClientMode(false);
+        final SSLEngine anotherEngine = context.createSSLEngine();
+        anotherEngine.setUseClientMode(false);
+
+        final ByteBuffer expandBufferHandshake = ByteBuffer
+                .wrap(new byte[] { 0x16, 0x3, 0x3, 0x71, 0x41 });
+
+        final ByteBuffer unwrapDest = ByteBuffer.allocate(64 * 1024);
+        // enable large fragment buffers in all engines in the JVM
+        firstEngine.unwrap(expandBufferHandshake, unwrapDest);
+        unwrapDest.clear();
+    }
+}",2020-03-10T19:18:10Z,277
"@@ -0,0 +1,56 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package io.undertow.servlet.test.security.ssl;
+
+import java.nio.ByteBuffer;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+import io.undertow.testutils.DefaultServer;
+import org.junit.BeforeClass;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs {@link SSLMetaDataTestCase} with an expanded buffer SSL Engine,
+ * and verifies if {@link javax.net.ssl.SSLEngineResult.Status#BUFFER_OVERFLOW}
+ * is handled appropriately.
+ *
+ * @author Flavia Rainone
+ */
+@RunWith(DefaultServer.class)
+public class SSLMetaDataWithExpandedBufferTestCase extends SSLMetaDataTestCase {
+
+    @BeforeClass
+    public static void setup() throws Exception {
+        final SSLContext context = SSLContext.getDefault();
+        final SSLEngine firstEngine = context.createSSLEngine();
+        firstEngine.setUseClientMode(false);
+        final SSLEngine anotherEngine = context.createSSLEngine();
+        anotherEngine.setUseClientMode(false);
+
+        final ByteBuffer expandBufferHandshake = ByteBuffer
+                .wrap(new byte[] { 0x16, 0x3, 0x3, 0x71, 0x41 });
+
+        final ByteBuffer unwrapDest = ByteBuffer.allocate(64 * 1024);
+        // enable large fragment buffers in all engines in the JVM
+        firstEngine.unwrap(expandBufferHandshake, unwrapDest);
+        unwrapDest.clear();
+        SSLMetaDataTestCase.setup();
+    }
+}",2020-03-10T19:18:10Z,278
"@@ -576,7 +576,7 @@ public String getParameter(final String name) {
                 final FormData parsedFormData = parseFormData();
                 if (parsedFormData != null) {
                     FormData.FormValue res = parsedFormData.getFirst(name);
-                    if (res == null) {
+                    if (res == null || res.isFile()) {
                         return null;
                     } else {
                         return res.getValue();
@@ -599,7 +599,13 @@ public Enumeration<String> getParameterNames() {
             if (parsedFormData != null) {
                 Iterator<String> it = parsedFormData.iterator();
                 while (it.hasNext()) {
-                    parameterNames.add(it.next());
+                    String name = it.next();
+                    for(FormData.FormValue param : parsedFormData.get(name)) {
+                        if(!param.isFile()) {
+                            parameterNames.add(it.next());
+                            break;
+                        }
+                    }
                 }
             }
         }
@@ -624,7 +630,9 @@ public String[] getParameterValues(final String name) {
                 Deque<FormData.FormValue> res = parsedFormData.get(name);
                 if (res != null) {
                     for (FormData.FormValue value : res) {
-                        ret.add(value.getValue());
+                        if(!value.isFile()) {
+                            ret.add(value.getValue());
+                        }
                     }
                 }
             }
@@ -640,9 +648,9 @@ public Map<String, String[]> getParameterMap() {
         if (queryParameters == null) {
             queryParameters = exchange.getQueryParameters();
         }
-        final Map<String, String[]> ret = new HashMap<String, String[]>();
+        final Map<String, ArrayList<String>> arrayMap = new HashMap<String, ArrayList<String>>();
         for (Map.Entry<String, Deque<String>> entry : queryParameters.entrySet()) {
-            ret.put(entry.getKey(), entry.getValue().toArray(new String[entry.getValue().size()]));
+            arrayMap.put(entry.getKey(), new ArrayList<String>(entry.getValue()));
         }
         if (exchange.getRequestMethod().equals(Methods.POST)) {
 
@@ -652,26 +660,30 @@ public Map<String, String[]> getParameterMap() {
                 while (it.hasNext()) {
                     final String name = it.next();
                     Deque<FormData.FormValue> val = parsedFormData.get(name);
-                    if (ret.containsKey(name)) {
-                        String[] existing = ret.get(name);
-                        String[] array = new String[val.size() + existing.length];
-                        System.arraycopy(existing, 0, array, 0, existing.length);
-                        int i = existing.length;
+                    if (arrayMap.containsKey(name)) {
+                        ArrayList<String> existing = arrayMap.get(name);
                         for (final FormData.FormValue v : val) {
-                            array[i++] = v.getValue();
+                            if(!v.isFile()) {
+                                existing.add(v.getValue());
+                            }
                         }
-                        ret.put(name, array);
                     } else {
-                        String[] array = new String[val.size()];
+                        final ArrayList<String> values = new ArrayList<String>();
                         int i = 0;
                         for (final FormData.FormValue v : val) {
-                            array[i++] = v.getValue();
+                            if(!v.isFile()) {
+                                values.add(v.getValue());
+                            }
                         }
-                        ret.put(name, array);
+                        arrayMap.put(name, values);
                     }
                 }
             }
         }
+        final Map<String, String[]> ret = new HashMap<String, String[]>();
+        for(Map.Entry<String, ArrayList<String>> entry : arrayMap.entrySet()) {
+            ret.put(entry.getKey(), entry.getValue().toArray(new String[entry.getValue().size()]));
+        }
         return ret;
     }
 ",2013-09-17T08:17:36Z,147
"@@ -103,14 +103,6 @@ public void suspendWrites() {
         state &= ~STATE_WRITES_RESUMED;
     }
 
-    protected void suspendWritesInternal() {
-        channel.suspendWrites();
-    }
-
-    protected void resumeWritesInternal() {
-        channel.resumeWrites();
-    }
-
     /**
      * Returns the header for the current frame.
      *
@@ -163,12 +155,24 @@ public boolean isWriteResumed() {
 
     @Override
     public void wakeupWrites() {
-        resumeWrites();
+        resumeWritesInternal(true);
     }
 
     @Override
     public void resumeWrites() {
+        resumeWritesInternal(false);
+    }
+
+    protected void resumeWritesInternal(boolean wakeup) {
+        boolean alreadyResumed = anyAreSet(state, STATE_WRITES_RESUMED);
+        if(!wakeup && alreadyResumed) {
+            return;
+        }
         state |= STATE_WRITES_RESUMED;
+        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+            //we already have data queued to be flushed
+            return;
+        }
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             getIoThread().execute(new Runnable() {
@@ -408,7 +412,7 @@ public void close() throws IOException {
         }
         //we need to wake up/invoke the write listener
         if(isWriteResumed()) {
-            resumeWritesInternal();
+            ChannelListeners.invokeChannelListener(getIoThread(), this, (ChannelListener)getWriteListener());
         }
         wakeupWrites();
     }",2014-07-10T06:55:51Z,234
"@@ -243,6 +243,9 @@ public void shutdownReads() throws IOException {
     protected void lastFrame() {
         state |= STATE_LAST_FRAME;
         waitingForFrame = false;
+        if(data == null && pendingFrameData.isEmpty()) {
+            state |= STATE_DONE | STATE_CLOSED;
+        }
     }
 
     @Override",2014-07-10T06:55:51Z,190
"@@ -183,6 +183,9 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * @return The number of bytes that can be sent
      */
     protected synchronized int grabFlowControlBytes(int toSend) {
+        if(toSend == 0) {
+            return 0;
+        }
         int newWindowSize = this.getChannel().getInitialWindowSize();
         int settingsDelta = newWindowSize - this.initialWindowSize;
         //first adjust for any settings frame updates
@@ -192,9 +195,6 @@ protected synchronized int grabFlowControlBytes(int toSend) {
         int min = Math.min(toSend, this.flowControlWindow);
         int actualBytes = this.getChannel().grabFlowControlBytes(min);
         this.flowControlWindow -= actualBytes;
-        if (actualBytes == 0) {
-            suspendWritesInternal();
-        }
         return actualBytes;
     }
 
@@ -204,7 +204,7 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         if (exhausted) {
             getChannel().notifyFlowControlAllowed();
             if (isWriteResumed()) {
-                resumeWritesInternal();
+                resumeWritesInternal(true);
             }
         }
     }",2014-07-10T06:55:51Z,72
"@@ -134,11 +134,11 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             return;
         }
 
-//        Maybe it's not worth dispatching even registration/removals?
-//        if (exchange.isInIoThread()) {
-//            exchange.dispatch(this);
-//            return;
-//        }
+        if(exchange.isInIoThread()) {
+            //for now just do all the management stuff in a worker, as it uses blocking IO
+            exchange.dispatch(this);
+            return;
+        }
 
         final HttpString method = exchange.getRequestMethod();
         try {",2014-07-18T01:51:56Z,100
"@@ -271,9 +271,9 @@ protected void lastFrame() {
 
     @Override
     public void awaitReadable() throws IOException {
-        if (data == null) {
+        if (data == null && pendingFrameData.isEmpty()) {
             synchronized (lock) {
-                if (data == null) {
+                if (data == null && pendingFrameData.isEmpty()) {
                     try {
                         waiters++;
                         lock.wait();",2014-07-18T01:51:56Z,190
"@@ -18,6 +18,7 @@
 
 package io.undertow.servlet.handlers;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.security.AccessController;
 import java.util.List;
@@ -222,7 +223,11 @@ public boolean displayStackTraces() {
             if(localAddress == null) {
                 return false;
             }
-            if(!localAddress.getAddress().isLoopbackAddress()) {
+            InetAddress address = localAddress.getAddress();
+            if(address == null) {
+                return false;
+            }
+            if(!address.isLoopbackAddress()) {
                 return false;
             }
             return !getExchange().getRequestHeaders().contains(Headers.X_FORWARDED_FOR);",2014-07-18T01:51:56Z,123
"@@ -169,7 +169,7 @@ protected boolean isLastFrameSent() {
         return lastFrameSent;
     }
 
-    protected void lastDataRead() {
+    protected synchronized void lastDataRead() {
         if(!lastFrameSent) {
             markReadsBroken(new ClosedChannelException());
             markWritesBroken(new ClosedChannelException());",2019-12-06T07:40:59Z,279
"@@ -587,17 +587,22 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
     }
 
     protected void lastDataRead() {
-        lastDataRead = true;
-        if(!peerGoneAway) {
+        final boolean peerGoneAway;
+        synchronized (this) {
+            lastDataRead = true;
+            peerGoneAway = this.peerGoneAway;
+            if(peerGoneAway) {
+                if(!thisGoneAway) {
+                    //we send a goaway message, and then close
+                    sendGoAway(ERROR_CONNECT_ERROR);
+                }
+            }
+        }
+        if (!peerGoneAway) {
             //we just close the connection, as the peer has performed an unclean close
             IoUtils.safeClose(this);
-        } else {
-            peerGoneAway = true;
-            if(!thisGoneAway) {
-                //we send a goaway message, and then close
-                sendGoAway(ERROR_CONNECT_ERROR);
-            }
         }
+
     }
 
     @Override",2019-12-06T07:40:59Z,166
"@@ -341,173 +341,185 @@ public InetSocketAddress getDestinationAddress() {
      * existing source channels. In general if you suspend receives or don't have some other way
      * of calling this method then it can prevent frame channels for being fully consumed.
      */
-    public synchronized R receive() throws IOException {
-        if (readChannelDone && receiver == null) {
-            //we have received the last frame, we just shut down and return
-            //it would probably make more sense to have the last channel responsible for this
-            //however it is much simpler just to have it here
-            if(readData != null) {
-                readData.close();
-                readData = null;
-            }
-            channel.getSourceChannel().suspendReads();
-            channel.getSourceChannel().shutdownReads();
-            return null;
-        }
-        partialRead = false;
-        boolean requiresReinvoke = false;
-        int reinvokeDataRemaining = 0;
-        ReferenceCountedPooled pooled = this.readData;
-        boolean hasData = false;
-        if (pooled == null) {
-            pooled = allocateReferenceCountedBuffer();
-            if (pooled == null) {
-                return null;
-            }
-        } else if(pooled.isFreed()) {
-            //we attempt to re-used an existing buffer
-            if(!pooled.tryUnfree()) {
-                pooled = allocateReferenceCountedBuffer();
-                if (pooled == null) {
-                    return null;
-                }
-            }
-            pooled.getBuffer().clear();
-        } else {
-            hasData = pooled.getBuffer().hasRemaining();
-            pooled.getBuffer().compact();
-        }
-        boolean forceFree = false;
-        int read = 0;
+    public R receive() throws IOException {
+        // store in a local variable to prevent invoking lastDataRead twice
+        boolean receivedMinusOne = false;
         try {
-            read = channel.getSourceChannel().read(pooled.getBuffer());
-            if (read == 0 && !hasData) {
-                //no data, we just free the buffer
-                forceFree = true;
-                return null;
-            } else if (read == -1 && !hasData) {
-                forceFree = true;
-                readChannelDone = true;
-                lastDataRead();
-                return null;
-            } else if(isLastFrameReceived() && frameDataRemaining == 0) {
-                //we got data, although we should have received the last frame
-                forceFree = true;
-                markReadsBroken(new ClosedChannelException());
-            }
-            pooled.getBuffer().flip();
-            if(read == -1) {
-                requiresReinvoke = true;
-                reinvokeDataRemaining = pooled.getBuffer().remaining();
-            }
-            if (frameDataRemaining > 0) {
-                if (frameDataRemaining >= pooled.getBuffer().remaining()) {
-                    frameDataRemaining -= pooled.getBuffer().remaining();
-                    if(receiver != null) {
-                        //we still create a pooled view, this means that if the buffer is still active we can re-used it
-                        //which prevents attacks based on sending lots of small fragments
-                        PooledByteBuffer frameData = pooled.createView();
-                        receiver.dataReady(null, frameData);
-                    } else {
-                        //we are dropping a frame
-                        pooled.close();
+            synchronized (this) {
+                if (readChannelDone && receiver == null) {
+                    //we have received the last frame, we just shut down and return
+                    //it would probably make more sense to have the last channel responsible for this
+                    //however it is much simpler just to have it here
+                    if(readData != null) {
+                        readData.close();
                         readData = null;
                     }
-                    if(frameDataRemaining == 0) {
-                        receiver = null;
-                    }
+                    channel.getSourceChannel().suspendReads();
+                    channel.getSourceChannel().shutdownReads();
                     return null;
-                } else {
-                    PooledByteBuffer frameData = pooled.createView((int) frameDataRemaining);
-                    frameDataRemaining = 0;
-                    if(receiver != null) {
-                        receiver.dataReady(null, frameData);
-                    } else{
-                        //we are dropping the frame
-                        frameData.close();
-                    }
-                    receiver = null;
                 }
-                //if we read data into a frame we just return immediately, even if there is more remaining
-                //see https://issues.jboss.org/browse/UNDERTOW-410
-                //basically if we don't do this we loose some message ordering semantics
-                //as the second message may be processed before the first one
-
-                //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
-                //and not by the selector mechanism
-                return null;
-            }
-            FrameHeaderData data = parseFrame(pooled.getBuffer());
-            if (data != null) {
-                PooledByteBuffer frameData;
-                if (data.getFrameLength() >= pooled.getBuffer().remaining()) {
-                    frameDataRemaining = data.getFrameLength() - pooled.getBuffer().remaining();
-                    frameData = pooled.createView();
-                    pooled.getBuffer().position(pooled.getBuffer().limit());
+                partialRead = false;
+                boolean requiresReinvoke = false;
+                int reinvokeDataRemaining = 0;
+                ReferenceCountedPooled pooled = this.readData;
+                boolean hasData = false;
+                if (pooled == null) {
+                    pooled = allocateReferenceCountedBuffer();
+                    if (pooled == null) {
+                        return null;
+                    }
+                } else if(pooled.isFreed()) {
+                    //we attempt to re-used an existing buffer
+                    if(!pooled.tryUnfree()) {
+                        pooled = allocateReferenceCountedBuffer();
+                        if (pooled == null) {
+                            return null;
+                        }
+                    }
+                    pooled.getBuffer().clear();
                 } else {
-                    frameData = pooled.createView((int) data.getFrameLength());
+                    hasData = pooled.getBuffer().hasRemaining();
+                    pooled.getBuffer().compact();
                 }
-                AbstractFramedStreamSourceChannel<?, ?, ?> existing = data.getExistingChannel();
-                if (existing != null) {
-                    if (data.getFrameLength() > frameData.getBuffer().remaining()) {
-                        receiver = (R) existing;
+                boolean forceFree = false;
+                int read = 0;
+                try {
+                    read = channel.getSourceChannel().read(pooled.getBuffer());
+                    if (read == 0 && !hasData) {
+                        //no data, we just free the buffer
+                        forceFree = true;
+                        return null;
+                    } else if (read == -1 && !hasData) {
+                        forceFree = true;
+                        receivedMinusOne = readChannelDone = true;
+                        return null;
+                    } else if(isLastFrameReceived() && frameDataRemaining == 0) {
+                        //we got data, although we should have received the last frame
+                        forceFree = true;
+                        markReadsBroken(new ClosedChannelException());
                     }
-                    existing.dataReady(data, frameData);
-                    if(isLastFrameReceived()) {
-                        handleLastFrame(existing);
+                    pooled.getBuffer().flip();
+                    if(read == -1) {
+                        requiresReinvoke = true;
+                        reinvokeDataRemaining = pooled.getBuffer().remaining();
                     }
-                    return null;
-                } else {
-                    boolean moreData = data.getFrameLength() > frameData.getBuffer().remaining();
-                    R newChannel = createChannel(data, frameData);
-                    if (newChannel != null) {
-                        if (moreData) {
-                            receiver = newChannel;
+                    if (frameDataRemaining > 0) {
+                        if (frameDataRemaining >= pooled.getBuffer().remaining()) {
+                            frameDataRemaining -= pooled.getBuffer().remaining();
+                            if(receiver != null) {
+                                //we still create a pooled view, this means that if the buffer is still active we can re-used it
+                                //which prevents attacks based on sending lots of small fragments
+                                PooledByteBuffer frameData = pooled.createView();
+                                receiver.dataReady(null, frameData);
+                            } else {
+                                //we are dropping a frame
+                                pooled.close();
+                                readData = null;
+                            }
+                            if(frameDataRemaining == 0) {
+                                receiver = null;
+                            }
+                            return null;
+                        } else {
+                            PooledByteBuffer frameData = pooled.createView((int) frameDataRemaining);
+                            frameDataRemaining = 0;
+                            if(receiver != null) {
+                                receiver.dataReady(null, frameData);
+                            } else{
+                                //we are dropping the frame
+                                frameData.close();
+                            }
+                            receiver = null;
                         }
+                        //if we read data into a frame we just return immediately, even if there is more remaining
+                        //see https://issues.jboss.org/browse/UNDERTOW-410
+                        //basically if we don't do this we loose some message ordering semantics
+                        //as the second message may be processed before the first one
+
+                        //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
+                        //and not by the selector mechanism
+                        return null;
+                    }
+                    FrameHeaderData data = parseFrame(pooled.getBuffer());
+                    if (data != null) {
+                        PooledByteBuffer frameData;
+                        if (data.getFrameLength() >= pooled.getBuffer().remaining()) {
+                            frameDataRemaining = data.getFrameLength() - pooled.getBuffer().remaining();
+                            frameData = pooled.createView();
+                            pooled.getBuffer().position(pooled.getBuffer().limit());
+                        } else {
+                            frameData = pooled.createView((int) data.getFrameLength());
+                        }
+                        AbstractFramedStreamSourceChannel<?, ?, ?> existing = data.getExistingChannel();
+                        if (existing != null) {
+                            if (data.getFrameLength() > frameData.getBuffer().remaining()) {
+                                receiver = (R) existing;
+                            }
+                            existing.dataReady(data, frameData);
+                            if (isLastFrameReceived()) {
+                                handleLastFrame(existing);
+                            }
+                            return null;
+                        } else {
+                            boolean moreData = data.getFrameLength() > frameData.getBuffer().remaining();
+                            R newChannel = createChannel(data, frameData);
+                            if (newChannel != null) {
+                                if (moreData) {
+                                    receiver = newChannel;
+                                }
 
-                        if(isLastFrameReceived()) {
-                            handleLastFrame(newChannel);
+                                if(isLastFrameReceived()) {
+                                    handleLastFrame(newChannel);
+                                }
+                            } else {
+                                frameData.close();
+                            }
+                            return newChannel;
                         }
                     } else {
-                        frameData.close();
+                        //we set partial read to true so the read listener knows not to immediately call receive again
+                        partialRead = true;
                     }
-                    return newChannel;
-                }
-            } else {
-                //we set partial read to true so the read listener knows not to immediately call receive again
-                partialRead = true;
-            }
-            return null;
-        } catch (IOException|RuntimeException|Error e) {
-            //something has code wrong with parsing, close the read side
-            //we don't close the write side, as the underlying implementation will most likely want to send an error
-            markReadsBroken(e);
-            forceFree = true;
-            throw e;
-        }finally {
-            //if the receive caused the channel to break the close listener may be have been called
-            //which will make readData null
-            if (readData != null) {
-                if (!pooled.getBuffer().hasRemaining() || forceFree) {
-                    if(pooled.getBuffer().capacity() < 1024 || forceFree) {
-                        //if there is less than 1k left we don't allow it to be re-aquired
-                        readData = null;
-                    }
-                    //even though this is freed we may un-free it if we get a new packet
-                    //this prevents many small reads resulting in a large number of allocated buffers
-                    pooled.close();
+                    return null;
+                } catch (IOException|RuntimeException|Error e) {
+                    //something has code wrong with parsing, close the read side
+                    //we don't close the write side, as the underlying implementation will most likely want to send an error
+                    markReadsBroken(e);
+                    forceFree = true;
+                    throw e;
+                }finally {
+                    //if the receive caused the channel to break the close listener may be have been called
+                    //which will make readData null
+                    if (readData != null) {
+                        if (!pooled.getBuffer().hasRemaining() || forceFree) {
+                            if(pooled.getBuffer().capacity() < 1024 || forceFree) {
+                                //if there is less than 1k left we don't allow it to be re-aquired
+                                readData = null;
+                            }
+                            //even though this is freed we may un-free it if we get a new packet
+                            //this prevents many small reads resulting in a large number of allocated buffers
+                            pooled.close();
 
-                }
-            }
-            if(requiresReinvoke) {
-                if(readData != null && !readData.isFreed()) {
-                    if(readData.getBuffer().remaining() == reinvokeDataRemaining) {
-                        readData.close();
-                        readData = null;
-                        UndertowLogger.REQUEST_IO_LOGGER.debugf(""Partial message read before connection close %s"", this);
+                        }
+                    }
+                    if(requiresReinvoke) {
+                        if(readData != null && !readData.isFreed()) {
+                            if(readData.getBuffer().remaining() == reinvokeDataRemaining) {
+                                readData.close();
+                                readData = null;
+                                UndertowLogger.REQUEST_IO_LOGGER.debugf(""Partial message read before connection close %s"", this);
+                            }
+                        }
+                        channel.getSourceChannel().wakeupReads();
                     }
                 }
-                channel.getSourceChannel().wakeupReads();
+            }
+        } finally {
+            // read receivedMinusOne, and not readChannelDone
+            // to prevent lastDataRead being invoked twice in case of
+            // two concurrent receive invocations
+            if (receivedMinusOne) {
+                lastDataRead();
             }
         }
     }
@@ -813,13 +825,15 @@ public boolean isReceivesResumed() {
      */
     @Override
     public void close() throws IOException {
-        if (UndertowLogger.REQUEST_IO_LOGGER.isTraceEnabled()) {
-            UndertowLogger.REQUEST_IO_LOGGER.tracef(new ClosedChannelException(), ""Channel %s is being closed"", this);
-        }
-        safeClose(channel);
-        if (readData != null) {
-            readData.close();
-            readData = null;
+        synchronized (this) {
+            if (UndertowLogger.REQUEST_IO_LOGGER.isTraceEnabled()) {
+                UndertowLogger.REQUEST_IO_LOGGER.tracef(new ClosedChannelException(), ""Channel %s is being closed"", this);
+            }
+            safeClose(channel);
+            if (readData != null) {
+                readData.close();
+                readData = null;
+            }
         }
         closeSubChannels();
     }",2019-12-06T07:40:59Z,168
"@@ -516,7 +516,7 @@ public boolean isOpen() {
     }
 
     @Override
-    public void close() throws IOException {
+    public synchronized void close() throws IOException {
         if(fullyFlushed || anyAreSet(state, STATE_CLOSED)) {
             return;
         }",2019-12-06T07:40:59Z,234
"@@ -603,7 +603,7 @@ public boolean isOpen() {
     }
 
     @Override
-    public void close() {
+    public synchronized void close() {
         if(anyAreSet(state, STATE_CLOSED)) {
             return;
         }",2019-12-06T07:40:59Z,190
"@@ -147,7 +147,7 @@ protected void markReadsBroken(Throwable cause) {
     }
 
     @Override
-    protected void lastDataRead() {
+    protected synchronized void lastDataRead() {
         if(!closeFrameReceived && !closeFrameSent) {
             //the peer has likely already gone away, but try and send a close frame anyway
             //this will likely just result in the write() failing an immediate connection termination",2019-12-06T07:40:59Z,43
"@@ -134,11 +134,11 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             return;
         }
 
-//        Maybe it's not worth dispatching even registration/removals?
-//        if (exchange.isInIoThread()) {
-//            exchange.dispatch(this);
-//            return;
-//        }
+        if(exchange.isInIoThread()) {
+            //for now just do all the management stuff in a worker, as it uses blocking IO
+            exchange.dispatch(this);
+            return;
+        }
 
         final HttpString method = exchange.getRequestMethod();
         try {",2014-07-18T01:51:56Z,100
"@@ -271,9 +271,9 @@ protected void lastFrame() {
 
     @Override
     public void awaitReadable() throws IOException {
-        if (data == null) {
+        if (data == null && pendingFrameData.isEmpty()) {
             synchronized (lock) {
-                if (data == null) {
+                if (data == null && pendingFrameData.isEmpty()) {
                     try {
                         waiters++;
                         lock.wait();",2014-07-18T01:51:56Z,190
"@@ -18,6 +18,7 @@
 
 package io.undertow.servlet.handlers;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.security.AccessController;
 import java.util.List;
@@ -222,7 +223,11 @@ public boolean displayStackTraces() {
             if(localAddress == null) {
                 return false;
             }
-            if(!localAddress.getAddress().isLoopbackAddress()) {
+            InetAddress address = localAddress.getAddress();
+            if(address == null) {
+                return false;
+            }
+            if(!address.isLoopbackAddress()) {
                 return false;
             }
             return !getExchange().getRequestHeaders().contains(Headers.X_FORWARDED_FOR);",2014-07-18T01:51:56Z,123
"@@ -158,7 +158,7 @@ protected PooledByteBuffer createFrameFooter() {
         return null;
     }
 
-    final void preWrite() {
+    final synchronized void preWrite() {
         if(allAreClear(state, STATE_PRE_WRITE_CALLED)) {
             state |= STATE_PRE_WRITE_CALLED;
             body = preWriteTransform(body);
@@ -233,7 +233,7 @@ public void run() {
     }
 
     @Override
-    public void shutdownWrites() throws IOException {
+    public synchronized void shutdownWrites() throws IOException {
         if(anyAreSet(state, STATE_WRITES_SHUTDOWN) || broken ) {
             return;
         }
@@ -242,7 +242,7 @@ public void shutdownWrites() throws IOException {
         state |= STATE_WRITES_SHUTDOWN;
     }
 
-    private void queueFinalFrame() throws IOException {
+    private synchronized void queueFinalFrame() throws IOException {
         if (!readyForFlush && !fullyFlushed && allAreClear(state, STATE_CLOSED)  && !broken && !finalFrameQueued) {
             if( null == body && null != writeBuffer) {
                 sendWriteBuffer();
@@ -348,9 +348,11 @@ public boolean flush() throws IOException {
         if (readyForFlush) {
             return false;
         }
-        if (fullyFlushed) {
-            state |= STATE_CLOSED;
-            return true;
+        synchronized (this) {
+            if (fullyFlushed) {
+                state |= STATE_CLOSED;
+                return true;
+            }
         }
         if (anyAreSet(state, STATE_WRITES_SHUTDOWN) && !finalFrameQueued) {
             queueFinalFrame();
@@ -459,7 +461,7 @@ public int writeFinal(ByteBuffer src) throws IOException {
         return Channels.writeFinalBasic(this, src);
     }
 
-    private void handleBufferFull() throws IOException {
+    private synchronized void handleBufferFull() throws IOException {
         bufferFull = true;
         if (!readyForFlush) {
             sendWriteBuffer();
@@ -511,7 +513,9 @@ public void close() throws IOException {
             return;
         }
         try {
-            state |= STATE_CLOSED;
+            synchronized (this) {
+                state |= STATE_CLOSED;
+            }
             if(writeBuffer != null) {
                 writeBuffer.close();
                 writeBuffer = null;
@@ -583,7 +587,7 @@ public ByteBuffer getBuffer() {
     /**
      * Method that is invoked when a frame has been fully flushed. This method is only invoked by the IO thread
      */
-    final void flushComplete() throws IOException {
+    final synchronized void flushComplete() throws IOException {
         try {
             bufferFull = false;
             int remaining = header.getRemainingInBuffer();",2016-11-10T23:45:37Z,234
"@@ -22,12 +22,14 @@
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
@@ -50,24 +52,50 @@ public static void main(final String[] args) {
         final Map<String, Class> examples = new HashMap<>();
         //hackz to discover all the example classes on the class path
         ZipInputStream in = null;
+        boolean fromJarFile = false;
         try {
-            String zipPath = url.getPath().substring(0, url.getPath().indexOf(""!"")).replace(""file:"", """");
-            in = new ZipInputStream(new FileInputStream(zipPath));
-            ZipEntry entry = in.getNextEntry();
-            while (entry != null) {
-                if (entry.getName().endsWith("".class"")) {
-                    String className = entry.getName().substring(0, entry.getName().length() - 6).replace(""/"", ""."");
-                    try {
-                        Class<?> clazz = Class.forName(className);
-                        UndertowExample example = clazz.getAnnotation(UndertowExample.class);
-                        if (example != null) {
-                            examples.put(example.value(), clazz);
+            String finalURIString = url.toString();
+            if(url.getPath().contains(""!"")) {
+                fromJarFile = true;
+                finalURIString = url.getPath().substring(0, url.getPath().indexOf(""!""));
+            }
+            if(fromJarFile) {
+                String zipPath = finalURIString.replace(""file:"", """");
+                in = new ZipInputStream(new FileInputStream(zipPath));
+                ZipEntry entry = in.getNextEntry();
+                while (entry != null) {
+                    if (entry.getName().endsWith("".class"")) {
+                        String className = entry.getName().substring(0, entry.getName().length() - 6).replace(""/"", ""."");
+                        try {
+                            Class<?> clazz = Class.forName(className);
+                            UndertowExample example = clazz.getAnnotation(UndertowExample.class);
+                            if (example != null) {
+                                examples.put(example.value(), clazz);
+                            }
+                        } catch (Throwable e) {
+                            //ignore
                         }
-                    } catch (Throwable e) {
-                        //ignore
                     }
+                    entry = in.getNextEntry();
+                }
+            }else  {
+                try {
+                    try (Stream<Path> paths = Files.walk(Paths.get(url.toURI()))) {
+                        Map<String, ? extends Class<?>> annotationMapping = paths
+                                .filter(Files::isRegularFile)
+                                .filter(path -> path.toFile().getName().endsWith("".class""))
+                                .map(Runner::toFileName)
+                                .map(fileName -> fileName.replace(""/"", "".""))
+                                .map(Runner::instance)
+                                .filter(Optional::isPresent)
+                                .filter(clazz -> clazz.get().getAnnotation(UndertowExample.class) != null)
+                                .collect(Collectors.toMap(clazz -> clazz.get().getAnnotation(UndertowExample.class).value(), Optional::get));
+                        examples.putAll(annotationMapping);
+                    }
+
+                } catch (URISyntaxException e) {
+                    e.printStackTrace();
                 }
-                entry = in.getNextEntry();
             }
 
             final List<String> names = new ArrayList<>(examples.keySet());
@@ -91,17 +119,26 @@ public static void main(final String[] args) {
             final Method main = exampleClass.getDeclaredMethod(""main"", String[].class);
             main.invoke(null, (Object)args);
 
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        } catch (InvocationTargetException e) {
-            throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
+        } catch (IOException | NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
             throw new RuntimeException(e);
         } finally {
             IoUtils.safeClose(in);
         }
 
     }
+
+    private static String toFileName(Path path) {
+        String pathName = path.toFile().getAbsolutePath();
+        int index = pathName.indexOf(""target/classes/"") + ""target/classes/"".length();
+        int classIndex = pathName.lastIndexOf("".class"");
+        return pathName.substring(index,classIndex);
+    }
+
+    private static Optional<Class<?>> instance(String clazz) {
+        try {
+            return Optional.ofNullable(Class.forName(clazz));
+        } catch (ClassNotFoundException e) {
+            return Optional.empty();
+        }
+    }
 }",2018-12-26T06:48:19Z,280
"@@ -1083,6 +1083,7 @@ public void run() {
                                                 try {
                                                     doHandshake();
                                                 } catch (IOException | RuntimeException | Error e) {
+                                                    UndertowLogger.REQUEST_LOGGER.error(""Closing SSLConduit after exception on handshake"", e);
                                                     IoUtils.safeClose(connection);
                                                 }
                                                 if (anyAreSet(state, FLAG_READS_RESUMED)) {",2019-08-30T14:39:34Z,185
"@@ -206,7 +206,7 @@ public void run() {
                         if (listener == null || !isWriteResumed()) {
                             return;
                         }
-                        if(loopCount++ == 10) {
+                        if(loopCount++ == 100) {
                             //should never happen
                             UndertowLogger.ROOT_LOGGER.listenerNotProgressing();
                             IoUtils.safeClose(AbstractFramedStreamSinkChannel.this);",2014-07-30T07:55:25Z,234
"@@ -486,7 +486,7 @@ protected AbstractHttp2StreamSourceChannel createChannelImpl(FrameHeaderData fra
                 boolean ack = Bits.anyAreSet(frameParser.flags, PING_FLAG_ACK);
                 channel = new Http2PingStreamSourceChannel(this, pingParser.getData(), ack);
                 if(!ack) { //not an ack from one of our pings, so send it back
-                    sendPing(pingParser.getData(), null, true);
+                    sendPing(pingParser.getData(),  new Http2ControlMessageExceptionHandler(), true);
                 }
                 break;
             }",2019-10-16T00:22:17Z,166
"@@ -129,6 +129,8 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private final List<ChannelListener<C>> closeTasks = new CopyOnWriteArrayList<>();
     private volatile boolean flushingSenders = false;
 
+    private boolean partialRead = false;
+
     @SuppressWarnings(""unused"")
     private volatile int outstandingBuffers;
     private static final AtomicIntegerFieldUpdater<AbstractFramedChannel> outstandingBuffersUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, ""outstandingBuffers"");
@@ -352,6 +354,7 @@ public synchronized R receive() throws IOException {
             channel.getSourceChannel().shutdownReads();
             return null;
         }
+        partialRead = false;
         boolean requiresReinvoke = false;
         int reinvokeDataRemaining = 0;
         ReferenceCountedPooled pooled = this.readData;
@@ -470,6 +473,9 @@ public synchronized R receive() throws IOException {
                     }
                     return newChannel;
                 }
+            } else {
+                //we set partial read to true so the read listener knows not to immediately call receive again
+                partialRead = true;
             }
             return null;
         } catch (IOException|RuntimeException|Error e) {
@@ -943,7 +949,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                 UndertowLogger.REQUEST_IO_LOGGER.tracef(""Invoking receive listener"", receiver);
                 ChannelListeners.invokeChannelListener(AbstractFramedChannel.this, listener);
             }
-            if (readData != null && !readData.isFreed() && channel.isOpen()) {
+            if (readData != null && !readData.isFreed() && channel.isOpen() && !partialRead) {
                 try {
                     runInIoThread(new Runnable() {
                         @Override
@@ -955,6 +961,7 @@ public void run() {
                     IoUtils.safeClose(AbstractFramedChannel.this);
                 }
             }
+            partialRead = false;
         }
     }
 ",2019-10-16T00:22:17Z,168
"@@ -51,7 +51,7 @@
  * Thread safety notes:
  * <p/>
  * The general contract is that this channel is only to be used by a single thread at a time. The only exception to this is
- * during flush. A flush will only happen when {@link #STATE_READY_FOR_FLUSH} is set, and while this bit is set the buffer
+ * during flush. A flush will only happen when {@link #readyForFlush} is set, and while this bit is set the buffer
  * must not be modified.
  *
  * @author Stuart Douglas
@@ -67,18 +67,31 @@ public abstract class AbstractFramedStreamSinkChannel<C extends AbstractFramedCh
 
     private final Object lock = new Object();
 
+    /**
+     * the state variable, this must only be access by the thread that 'owns' the channel
+     */
     private volatile int state = 0;
+    /**
+     * If this channel is ready for flush, updated by multiple threads. In general it will be set by the thread
+     * that 'owns' the channel, and cleared by the IO thread
+     */
+    private volatile boolean readyForFlush;
+
+    /**
+     * If this channel is broken, updated by multiple threads
+     */
+    private volatile boolean broken;
+
     private SendFrameHeader header;
     private Pooled<ByteBuffer> trailer;
 
-    private static final int STATE_BROKEN = 1;
-    private static final int STATE_READY_FOR_FLUSH = 1 << 1;
     private static final int STATE_CLOSED = 1 << 2;
     private static final int STATE_WRITES_RESUMED = 1 << 4;
     private static final int STATE_WRITES_SHUTDOWN = 1 << 5;
     private static final int STATE_IN_LISTENER_LOOP = 1 << 6;
     private static final int STATE_FIRST_DATA_WRITTEN = 1 << 7;
 
+
     /**
      * writes are shutdown, data has been written, but flush has not been called
      */
@@ -170,7 +183,7 @@ protected void resumeWritesInternal(boolean wakeup) {
             return;
         }
         state |= STATE_WRITES_RESUMED;
-        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+        if(readyForFlush && !wakeup) {
             //we already have data queued to be flushed
             return;
         }
@@ -192,7 +205,7 @@ public void run() {
                             //we stop when writes are shutdown because we can't flush until we are active
                             //although we may be flushed as part of a batch
                         }
-                        while (allAreClear(state, STATE_CLOSED | STATE_BROKEN | STATE_READY_FOR_FLUSH) && (anyAreSet(state, STATE_FULLY_FLUSHED) || buffer.getResource().hasRemaining()));
+                        while (allAreClear(state, STATE_CLOSED) && !broken && !readyForFlush && (anyAreSet(state, STATE_FULLY_FLUSHED) || buffer.getResource().hasRemaining()));
                     } finally {
                         state &= ~STATE_IN_LISTENER_LOOP;
                     }
@@ -204,17 +217,18 @@ public void run() {
 
     @Override
     public void shutdownWrites() throws IOException {
-        if(anyAreSet(state, STATE_BROKEN | STATE_WRITES_SHUTDOWN)) {
+        if(anyAreSet(state, STATE_WRITES_SHUTDOWN) || broken ) {
             return;
         }
         state |= STATE_WRITES_SHUTDOWN;
         queueFinalFrame();
     }
 
     private void queueFinalFrame() throws IOException {
-        if (allAreClear(state, STATE_READY_FOR_FLUSH | STATE_FINAL_FRAME_QUEUED | STATE_BROKEN | STATE_FULLY_FLUSHED | STATE_CLOSED)) {
+        if (!readyForFlush && allAreClear(state, STATE_FINAL_FRAME_QUEUED | STATE_FULLY_FLUSHED | STATE_CLOSED)  && !broken ) {
+            readyForFlush = true;
             buffer.getResource().flip();
-            state |= STATE_READY_FOR_FLUSH | STATE_FINAL_FRAME_QUEUED | STATE_FIRST_DATA_WRITTEN;
+            state |= STATE_FINAL_FRAME_QUEUED | STATE_FIRST_DATA_WRITTEN;
             channel.queueFrame((S) this);
         }
     }
@@ -229,10 +243,10 @@ public void awaitWritable() throws IOException {
             throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();
         }
         synchronized (lock) {
-            if (anyAreSet(state, STATE_BROKEN | STATE_CLOSED)) {
+            if (anyAreSet(state, STATE_CLOSED) || broken) {
                 return;
             }
-            if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
+            if (readyForFlush) {
                 try {
                     lock.wait();
                 } catch (InterruptedException e) {
@@ -248,12 +262,12 @@ public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {
             throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();
         }
         synchronized (lock) {
-            if (anyAreSet(state, STATE_BROKEN | STATE_CLOSED)) {
+            if (anyAreSet(state, STATE_CLOSED) || broken) {
                 return;
             }
-            if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
+            if (readyForFlush) {
                 try {
-                    if (anyAreSet(state, STATE_BROKEN | STATE_CLOSED)) {
+                    if (anyAreSet(state, STATE_CLOSED) || broken) {
                         return;
                     }
 
@@ -295,11 +309,11 @@ public boolean flush() throws IOException {
         if(anyAreSet(state, STATE_CLOSED)) {
             return true;
         }
-        if (anyAreSet(state, STATE_BROKEN)) {
+        if (broken) {
             throw UndertowMessages.MESSAGES.channelIsClosed();
         }
 
-        if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
+        if (readyForFlush) {
             return false;
         }
         if (anyAreSet(state, STATE_FULLY_FLUSHED)) {
@@ -308,21 +322,21 @@ public boolean flush() throws IOException {
         }
         if (anyAreSet(state, STATE_WRITES_SHUTDOWN) && anyAreClear(state, STATE_FINAL_FRAME_QUEUED)) {
             queueFinalFrame();
+            return false;
         }
-        return !allAreSet(state, STATE_WRITES_SHUTDOWN);
+        if(anyAreSet(state, STATE_WRITES_SHUTDOWN)) {
+            return false;
+        }
+        return true;
     }
 
     @Override
     public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
         int state = this.state;
-        if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
-            flush();
-            state = this.state;
-        }
-        if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
+        if (readyForFlush) {
             return 0; //we can't do anything, we are waiting for a flush
         }
-        if (anyAreSet(state, STATE_BROKEN | STATE_CLOSED | STATE_WRITES_SHUTDOWN)) {
+        if (anyAreSet(state, STATE_CLOSED | STATE_WRITES_SHUTDOWN) || broken) {
             throw UndertowMessages.MESSAGES.channelIsClosed();
         }
         long copied = Buffers.copy(this.buffer.getResource(), srcs, offset, length);
@@ -340,10 +354,10 @@ public long write(ByteBuffer[] srcs) throws IOException {
     @Override
     public int write(ByteBuffer src) throws IOException {
         int state = this.state;
-        if (anyAreSet(state, STATE_READY_FOR_FLUSH)) {
+        if (readyForFlush) {
             return 0; //we can't do anything, we are waiting for a flush
         }
-        if (anyAreSet(state, STATE_BROKEN | STATE_CLOSED | STATE_WRITES_SHUTDOWN)) {
+        if (anyAreSet(state, STATE_CLOSED | STATE_WRITES_SHUTDOWN) || broken) {
             throw UndertowMessages.MESSAGES.channelIsClosed();
         }
         int copied = Buffers.copy(this.buffer.getResource(), src);
@@ -369,9 +383,10 @@ public int writeFinal(ByteBuffer src) throws IOException {
     }
 
     private void handleBufferFull() throws IOException {
-        if (allAreClear(state, STATE_READY_FOR_FLUSH)) {
+        if (!readyForFlush) {
+            readyForFlush = true;
             getBuffer().flip();
-            state |= STATE_READY_FOR_FLUSH | STATE_FIRST_DATA_WRITTEN;
+            state |= STATE_FIRST_DATA_WRITTEN;
             channel.queueFrame((S) this);
         }
     }
@@ -386,7 +401,7 @@ private void handleBufferFull() throws IOException {
      *         as it may be written out by another thread.
      */
     public boolean isReadyForFlush() {
-        return anyAreSet(state, STATE_READY_FOR_FLUSH);
+        return readyForFlush;
     }
 
     /**
@@ -466,7 +481,6 @@ public ByteBuffer getBuffer() {
      */
     final void flushComplete() throws IOException {
         try {
-            state &= ~STATE_READY_FOR_FLUSH;
             int remaining = header.getReminingInBuffer();
             boolean channelClosed = anyAreSet(state, STATE_FINAL_FRAME_QUEUED) && remaining == 0;
             if(remaining > 0) {
@@ -485,10 +499,8 @@ final void flushComplete() throws IOException {
             trailer.free();
             header = null;
             trailer = null;
-            if(anyAreSet(state, STATE_WRITES_SHUTDOWN) && anyAreClear(state, STATE_FINAL_FRAME_QUEUED)) {
-                queueFinalFrame();
-            }
 
+            readyForFlush = false;
             if (isWriteResumed() && !channelClosed) {
                 wakeupWrites();
             } else if(isWriteResumed()) {
@@ -515,7 +527,7 @@ protected boolean isFirstDataWritten() {
     }
 
     public void markBroken() {
-        this.state |= STATE_BROKEN;
+        this.broken = true;
         try {
             wakeupWrites();
             wakeupWaiters();",2014-07-25T23:53:38Z,234
"@@ -285,7 +285,7 @@ public void run() {
                                     //although we may be flushed as part of a batch
                                     moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);
                                 }
-                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);
+                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);
                             } finally {
                                 state &= ~STATE_IN_LISTENER_LOOP;
                             }",2017-06-12T20:50:00Z,190
"@@ -103,14 +103,6 @@ public void suspendWrites() {
         state &= ~STATE_WRITES_RESUMED;
     }
 
-    protected void suspendWritesInternal() {
-        channel.suspendWrites();
-    }
-
-    protected void resumeWritesInternal() {
-        channel.resumeWrites();
-    }
-
     /**
      * Returns the header for the current frame.
      *
@@ -163,12 +155,24 @@ public boolean isWriteResumed() {
 
     @Override
     public void wakeupWrites() {
-        resumeWrites();
+        resumeWritesInternal(true);
     }
 
     @Override
     public void resumeWrites() {
+        resumeWritesInternal(false);
+    }
+
+    protected void resumeWritesInternal(boolean wakeup) {
+        boolean alreadyResumed = anyAreSet(state, STATE_WRITES_RESUMED);
+        if(!wakeup && alreadyResumed) {
+            return;
+        }
         state |= STATE_WRITES_RESUMED;
+        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+            //we already have data queued to be flushed
+            return;
+        }
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             getIoThread().execute(new Runnable() {
@@ -408,7 +412,7 @@ public void close() throws IOException {
         }
         //we need to wake up/invoke the write listener
         if(isWriteResumed()) {
-            resumeWritesInternal();
+            ChannelListeners.invokeChannelListener(getIoThread(), this, (ChannelListener)getWriteListener());
         }
         wakeupWrites();
     }",2014-07-10T06:55:51Z,234
"@@ -243,6 +243,9 @@ public void shutdownReads() throws IOException {
     protected void lastFrame() {
         state |= STATE_LAST_FRAME;
         waitingForFrame = false;
+        if(data == null && pendingFrameData.isEmpty()) {
+            state |= STATE_DONE | STATE_CLOSED;
+        }
     }
 
     @Override",2014-07-10T06:55:51Z,190
"@@ -183,6 +183,9 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * @return The number of bytes that can be sent
      */
     protected synchronized int grabFlowControlBytes(int toSend) {
+        if(toSend == 0) {
+            return 0;
+        }
         int newWindowSize = this.getChannel().getInitialWindowSize();
         int settingsDelta = newWindowSize - this.initialWindowSize;
         //first adjust for any settings frame updates
@@ -192,9 +195,6 @@ protected synchronized int grabFlowControlBytes(int toSend) {
         int min = Math.min(toSend, this.flowControlWindow);
         int actualBytes = this.getChannel().grabFlowControlBytes(min);
         this.flowControlWindow -= actualBytes;
-        if (actualBytes == 0) {
-            suspendWritesInternal();
-        }
         return actualBytes;
     }
 
@@ -204,7 +204,7 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         if (exhausted) {
             getChannel().notifyFlowControlAllowed();
             if (isWriteResumed()) {
-                resumeWritesInternal();
+                resumeWritesInternal(true);
             }
         }
     }",2014-07-10T06:55:51Z,72
"@@ -130,6 +130,8 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private volatile int outstandingBuffers;
     private volatile AtomicIntegerFieldUpdater<AbstractFramedChannel> outstandingBuffersUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, ""outstandingBuffers"");
 
+    private final LinkedBlockingDeque<Runnable> taskRunQueue = new LinkedBlockingDeque<>();
+
     private final ReferenceCountedPooled.FreeNotifier freeNotifier = new ReferenceCountedPooled.FreeNotifier() {
         @Override
         public void freed() {
@@ -192,6 +194,18 @@ protected IdleTimeoutConduit createIdleTimeoutChannel(StreamConnection connected
         return new IdleTimeoutConduit(connectedStreamChannel.getSinkChannel().getConduit(), connectedStreamChannel.getSourceChannel().getConduit());
     }
 
+    void runInIoThread(Runnable task) {
+        this.taskRunQueue.add(task);
+        getIoThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                while (!taskRunQueue.isEmpty()) {
+                    taskRunQueue.poll().run();
+                }
+            }
+        });
+    }
+
     /**
      * Get the buffer pool for this connection.
      *
@@ -355,7 +369,6 @@ public synchronized R receive() throws IOException {
                     pooled.getResource().position((int) (pooled.getResource().position() + frameDataRemaining));
                     frameDataRemaining = 0;
                     Pooled<ByteBuffer> frameData = pooled.createView(buf);
-                    //note that we don't return here, there may be another frame
                     if(receiver != null) {
                         receiver.dataReady(null, frameData);
                     } else{
@@ -368,6 +381,9 @@ public synchronized R receive() throws IOException {
                 //see https://issues.jboss.org/browse/UNDERTOW-410
                 //basically if we don't do this we loose some message ordering semantics
                 //as the second message may be processed before the first one
+
+                //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
+                //and not by the selector mechanism
                 return null;
             }
             FrameHeaderData data = parseFrame(pooled.getResource());
@@ -592,7 +608,7 @@ protected synchronized void flushSenders() {
         } finally {
             flushingSenders = false;
             if(!newFrames.isEmpty()) {
-                getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -629,7 +645,7 @@ protected synchronized void queueFrame(final S channel) throws IOException {
             if(channel.getIoThread() == Thread.currentThread()) {
                 flushSenders();
             } else {
-                channel.getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -816,6 +832,11 @@ private final class FrameReadListener implements ChannelListener<StreamSourceCha
         @SuppressWarnings({""unchecked"", ""rawtypes""})
         @Override
         public void handleEvent(final StreamSourceChannel channel) {
+            //clear the task queue before reading
+            while (!taskRunQueue.isEmpty()) {
+                taskRunQueue.poll().run();
+            }
+
             final R receiver = AbstractFramedChannel.this.receiver;
             if ((isLastFrameReceived() || receivesSuspended) && receiver == null) {
                 channel.suspendReads();
@@ -831,7 +852,7 @@ public void handleEvent(final StreamSourceChannel channel) {
             }
             if (readData != null  && !readData.isFreed() && channel.isOpen()) {
                 try {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
                             ChannelListeners.invokeChannelListener(channel, FrameReadListener.this);
@@ -872,13 +893,13 @@ public void handleEvent(final CloseableChannel c) {
                 //we make sure there is no data left to receive, if there is then we invoke the receive listener
                 final ChannelListener<? super C> listener = receiveSetter.get();
                 if(listener != null) {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
-                            while (readData != null  && !readData.isFreed()) {
+                            while (readData != null && !readData.isFreed()) {
                                 int rem = readData.getResource().remaining();
                                 ChannelListeners.invokeChannelListener(AbstractFramedChannel.this, (ChannelListener) receiveSetter.get());
-                                if(readData != null && rem == readData.getResource().remaining()) {
+                                if (readData != null && rem == readData.getResource().remaining()) {
                                     break;//make sure we are making progress
                                 }
                             }
@@ -890,7 +911,12 @@ public void run() {
             }
 
             if (Thread.currentThread() != c.getIoThread()) {
-                ChannelListeners.invokeChannelListener(c.getIoThread(), c, this);
+                runInIoThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
+                    }
+                });
                 return;
             }
             R receiver = AbstractFramedChannel.this.receiver;",2015-06-24T14:46:23Z,168
"@@ -196,7 +196,7 @@ protected void resumeWritesInternal(boolean wakeup) {
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             state |= STATE_IN_LISTENER_LOOP;
-            getIoThread().execute(new Runnable() {
+            getChannel().runInIoThread(new Runnable() {
 
                 int loopCount = 0;
 ",2015-06-24T14:46:23Z,234
"@@ -250,7 +250,7 @@ void resumeReadsInternal(boolean wakeup) {
         if(!alreadyResumed || wakeup) {
             if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
                 state |= STATE_IN_LISTENER_LOOP;
-                getIoThread().execute(new Runnable() {
+                getFramedChannel().runInIoThread(new Runnable() {
 
                     @Override
                     public void run() {",2015-06-24T14:46:23Z,190
"@@ -285,7 +285,7 @@ public void run() {
                                     //although we may be flushed as part of a batch
                                     moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);
                                 }
-                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);
+                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);
                             } finally {
                                 state &= ~STATE_IN_LISTENER_LOOP;
                             }",2017-06-12T20:50:00Z,190
"@@ -103,14 +103,6 @@ public void suspendWrites() {
         state &= ~STATE_WRITES_RESUMED;
     }
 
-    protected void suspendWritesInternal() {
-        channel.suspendWrites();
-    }
-
-    protected void resumeWritesInternal() {
-        channel.resumeWrites();
-    }
-
     /**
      * Returns the header for the current frame.
      *
@@ -163,12 +155,24 @@ public boolean isWriteResumed() {
 
     @Override
     public void wakeupWrites() {
-        resumeWrites();
+        resumeWritesInternal(true);
     }
 
     @Override
     public void resumeWrites() {
+        resumeWritesInternal(false);
+    }
+
+    protected void resumeWritesInternal(boolean wakeup) {
+        boolean alreadyResumed = anyAreSet(state, STATE_WRITES_RESUMED);
+        if(!wakeup && alreadyResumed) {
+            return;
+        }
         state |= STATE_WRITES_RESUMED;
+        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+            //we already have data queued to be flushed
+            return;
+        }
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             getIoThread().execute(new Runnable() {
@@ -408,7 +412,7 @@ public void close() throws IOException {
         }
         //we need to wake up/invoke the write listener
         if(isWriteResumed()) {
-            resumeWritesInternal();
+            ChannelListeners.invokeChannelListener(getIoThread(), this, (ChannelListener)getWriteListener());
         }
         wakeupWrites();
     }",2014-07-10T06:55:51Z,234
"@@ -243,6 +243,9 @@ public void shutdownReads() throws IOException {
     protected void lastFrame() {
         state |= STATE_LAST_FRAME;
         waitingForFrame = false;
+        if(data == null && pendingFrameData.isEmpty()) {
+            state |= STATE_DONE | STATE_CLOSED;
+        }
     }
 
     @Override",2014-07-10T06:55:51Z,190
"@@ -183,6 +183,9 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * @return The number of bytes that can be sent
      */
     protected synchronized int grabFlowControlBytes(int toSend) {
+        if(toSend == 0) {
+            return 0;
+        }
         int newWindowSize = this.getChannel().getInitialWindowSize();
         int settingsDelta = newWindowSize - this.initialWindowSize;
         //first adjust for any settings frame updates
@@ -192,9 +195,6 @@ protected synchronized int grabFlowControlBytes(int toSend) {
         int min = Math.min(toSend, this.flowControlWindow);
         int actualBytes = this.getChannel().grabFlowControlBytes(min);
         this.flowControlWindow -= actualBytes;
-        if (actualBytes == 0) {
-            suspendWritesInternal();
-        }
         return actualBytes;
     }
 
@@ -204,7 +204,7 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         if (exhausted) {
             getChannel().notifyFlowControlAllowed();
             if (isWriteResumed()) {
-                resumeWritesInternal();
+                resumeWritesInternal(true);
             }
         }
     }",2014-07-10T06:55:51Z,72
"@@ -130,6 +130,8 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private volatile int outstandingBuffers;
     private volatile AtomicIntegerFieldUpdater<AbstractFramedChannel> outstandingBuffersUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, ""outstandingBuffers"");
 
+    private final LinkedBlockingDeque<Runnable> taskRunQueue = new LinkedBlockingDeque<>();
+
     private final ReferenceCountedPooled.FreeNotifier freeNotifier = new ReferenceCountedPooled.FreeNotifier() {
         @Override
         public void freed() {
@@ -192,6 +194,18 @@ protected IdleTimeoutConduit createIdleTimeoutChannel(StreamConnection connected
         return new IdleTimeoutConduit(connectedStreamChannel.getSinkChannel().getConduit(), connectedStreamChannel.getSourceChannel().getConduit());
     }
 
+    void runInIoThread(Runnable task) {
+        this.taskRunQueue.add(task);
+        getIoThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                while (!taskRunQueue.isEmpty()) {
+                    taskRunQueue.poll().run();
+                }
+            }
+        });
+    }
+
     /**
      * Get the buffer pool for this connection.
      *
@@ -355,7 +369,6 @@ public synchronized R receive() throws IOException {
                     pooled.getResource().position((int) (pooled.getResource().position() + frameDataRemaining));
                     frameDataRemaining = 0;
                     Pooled<ByteBuffer> frameData = pooled.createView(buf);
-                    //note that we don't return here, there may be another frame
                     if(receiver != null) {
                         receiver.dataReady(null, frameData);
                     } else{
@@ -368,6 +381,9 @@ public synchronized R receive() throws IOException {
                 //see https://issues.jboss.org/browse/UNDERTOW-410
                 //basically if we don't do this we loose some message ordering semantics
                 //as the second message may be processed before the first one
+
+                //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
+                //and not by the selector mechanism
                 return null;
             }
             FrameHeaderData data = parseFrame(pooled.getResource());
@@ -592,7 +608,7 @@ protected synchronized void flushSenders() {
         } finally {
             flushingSenders = false;
             if(!newFrames.isEmpty()) {
-                getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -629,7 +645,7 @@ protected synchronized void queueFrame(final S channel) throws IOException {
             if(channel.getIoThread() == Thread.currentThread()) {
                 flushSenders();
             } else {
-                channel.getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -816,6 +832,11 @@ private final class FrameReadListener implements ChannelListener<StreamSourceCha
         @SuppressWarnings({""unchecked"", ""rawtypes""})
         @Override
         public void handleEvent(final StreamSourceChannel channel) {
+            //clear the task queue before reading
+            while (!taskRunQueue.isEmpty()) {
+                taskRunQueue.poll().run();
+            }
+
             final R receiver = AbstractFramedChannel.this.receiver;
             if ((isLastFrameReceived() || receivesSuspended) && receiver == null) {
                 channel.suspendReads();
@@ -831,7 +852,7 @@ public void handleEvent(final StreamSourceChannel channel) {
             }
             if (readData != null  && !readData.isFreed() && channel.isOpen()) {
                 try {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
                             ChannelListeners.invokeChannelListener(channel, FrameReadListener.this);
@@ -872,13 +893,13 @@ public void handleEvent(final CloseableChannel c) {
                 //we make sure there is no data left to receive, if there is then we invoke the receive listener
                 final ChannelListener<? super C> listener = receiveSetter.get();
                 if(listener != null) {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
-                            while (readData != null  && !readData.isFreed()) {
+                            while (readData != null && !readData.isFreed()) {
                                 int rem = readData.getResource().remaining();
                                 ChannelListeners.invokeChannelListener(AbstractFramedChannel.this, (ChannelListener) receiveSetter.get());
-                                if(readData != null && rem == readData.getResource().remaining()) {
+                                if (readData != null && rem == readData.getResource().remaining()) {
                                     break;//make sure we are making progress
                                 }
                             }
@@ -890,7 +911,12 @@ public void run() {
             }
 
             if (Thread.currentThread() != c.getIoThread()) {
-                ChannelListeners.invokeChannelListener(c.getIoThread(), c, this);
+                runInIoThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
+                    }
+                });
                 return;
             }
             R receiver = AbstractFramedChannel.this.receiver;",2015-06-24T14:46:23Z,168
"@@ -196,7 +196,7 @@ protected void resumeWritesInternal(boolean wakeup) {
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             state |= STATE_IN_LISTENER_LOOP;
-            getIoThread().execute(new Runnable() {
+            getChannel().runInIoThread(new Runnable() {
 
                 int loopCount = 0;
 ",2015-06-24T14:46:23Z,234
"@@ -250,7 +250,7 @@ void resumeReadsInternal(boolean wakeup) {
         if(!alreadyResumed || wakeup) {
             if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
                 state |= STATE_IN_LISTENER_LOOP;
-                getIoThread().execute(new Runnable() {
+                getFramedChannel().runInIoThread(new Runnable() {
 
                     @Override
                     public void run() {",2015-06-24T14:46:23Z,190
"@@ -285,7 +285,7 @@ public void run() {
                                     //although we may be flushed as part of a batch
                                     moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);
                                 }
-                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);
+                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);
                             } finally {
                                 state &= ~STATE_IN_LISTENER_LOOP;
                             }",2017-06-12T20:50:00Z,190
"@@ -103,14 +103,6 @@ public void suspendWrites() {
         state &= ~STATE_WRITES_RESUMED;
     }
 
-    protected void suspendWritesInternal() {
-        channel.suspendWrites();
-    }
-
-    protected void resumeWritesInternal() {
-        channel.resumeWrites();
-    }
-
     /**
      * Returns the header for the current frame.
      *
@@ -163,12 +155,24 @@ public boolean isWriteResumed() {
 
     @Override
     public void wakeupWrites() {
-        resumeWrites();
+        resumeWritesInternal(true);
     }
 
     @Override
     public void resumeWrites() {
+        resumeWritesInternal(false);
+    }
+
+    protected void resumeWritesInternal(boolean wakeup) {
+        boolean alreadyResumed = anyAreSet(state, STATE_WRITES_RESUMED);
+        if(!wakeup && alreadyResumed) {
+            return;
+        }
         state |= STATE_WRITES_RESUMED;
+        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+            //we already have data queued to be flushed
+            return;
+        }
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             getIoThread().execute(new Runnable() {
@@ -408,7 +412,7 @@ public void close() throws IOException {
         }
         //we need to wake up/invoke the write listener
         if(isWriteResumed()) {
-            resumeWritesInternal();
+            ChannelListeners.invokeChannelListener(getIoThread(), this, (ChannelListener)getWriteListener());
         }
         wakeupWrites();
     }",2014-07-10T06:55:51Z,234
"@@ -243,6 +243,9 @@ public void shutdownReads() throws IOException {
     protected void lastFrame() {
         state |= STATE_LAST_FRAME;
         waitingForFrame = false;
+        if(data == null && pendingFrameData.isEmpty()) {
+            state |= STATE_DONE | STATE_CLOSED;
+        }
     }
 
     @Override",2014-07-10T06:55:51Z,190
"@@ -183,6 +183,9 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * @return The number of bytes that can be sent
      */
     protected synchronized int grabFlowControlBytes(int toSend) {
+        if(toSend == 0) {
+            return 0;
+        }
         int newWindowSize = this.getChannel().getInitialWindowSize();
         int settingsDelta = newWindowSize - this.initialWindowSize;
         //first adjust for any settings frame updates
@@ -192,9 +195,6 @@ protected synchronized int grabFlowControlBytes(int toSend) {
         int min = Math.min(toSend, this.flowControlWindow);
         int actualBytes = this.getChannel().grabFlowControlBytes(min);
         this.flowControlWindow -= actualBytes;
-        if (actualBytes == 0) {
-            suspendWritesInternal();
-        }
         return actualBytes;
     }
 
@@ -204,7 +204,7 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         if (exhausted) {
             getChannel().notifyFlowControlAllowed();
             if (isWriteResumed()) {
-                resumeWritesInternal();
+                resumeWritesInternal(true);
             }
         }
     }",2014-07-10T06:55:51Z,72
"@@ -130,6 +130,8 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private volatile int outstandingBuffers;
     private volatile AtomicIntegerFieldUpdater<AbstractFramedChannel> outstandingBuffersUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, ""outstandingBuffers"");
 
+    private final LinkedBlockingDeque<Runnable> taskRunQueue = new LinkedBlockingDeque<>();
+
     private final ReferenceCountedPooled.FreeNotifier freeNotifier = new ReferenceCountedPooled.FreeNotifier() {
         @Override
         public void freed() {
@@ -192,6 +194,18 @@ protected IdleTimeoutConduit createIdleTimeoutChannel(StreamConnection connected
         return new IdleTimeoutConduit(connectedStreamChannel.getSinkChannel().getConduit(), connectedStreamChannel.getSourceChannel().getConduit());
     }
 
+    void runInIoThread(Runnable task) {
+        this.taskRunQueue.add(task);
+        getIoThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                while (!taskRunQueue.isEmpty()) {
+                    taskRunQueue.poll().run();
+                }
+            }
+        });
+    }
+
     /**
      * Get the buffer pool for this connection.
      *
@@ -355,7 +369,6 @@ public synchronized R receive() throws IOException {
                     pooled.getResource().position((int) (pooled.getResource().position() + frameDataRemaining));
                     frameDataRemaining = 0;
                     Pooled<ByteBuffer> frameData = pooled.createView(buf);
-                    //note that we don't return here, there may be another frame
                     if(receiver != null) {
                         receiver.dataReady(null, frameData);
                     } else{
@@ -368,6 +381,9 @@ public synchronized R receive() throws IOException {
                 //see https://issues.jboss.org/browse/UNDERTOW-410
                 //basically if we don't do this we loose some message ordering semantics
                 //as the second message may be processed before the first one
+
+                //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
+                //and not by the selector mechanism
                 return null;
             }
             FrameHeaderData data = parseFrame(pooled.getResource());
@@ -592,7 +608,7 @@ protected synchronized void flushSenders() {
         } finally {
             flushingSenders = false;
             if(!newFrames.isEmpty()) {
-                getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -629,7 +645,7 @@ protected synchronized void queueFrame(final S channel) throws IOException {
             if(channel.getIoThread() == Thread.currentThread()) {
                 flushSenders();
             } else {
-                channel.getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -816,6 +832,11 @@ private final class FrameReadListener implements ChannelListener<StreamSourceCha
         @SuppressWarnings({""unchecked"", ""rawtypes""})
         @Override
         public void handleEvent(final StreamSourceChannel channel) {
+            //clear the task queue before reading
+            while (!taskRunQueue.isEmpty()) {
+                taskRunQueue.poll().run();
+            }
+
             final R receiver = AbstractFramedChannel.this.receiver;
             if ((isLastFrameReceived() || receivesSuspended) && receiver == null) {
                 channel.suspendReads();
@@ -831,7 +852,7 @@ public void handleEvent(final StreamSourceChannel channel) {
             }
             if (readData != null  && !readData.isFreed() && channel.isOpen()) {
                 try {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
                             ChannelListeners.invokeChannelListener(channel, FrameReadListener.this);
@@ -872,13 +893,13 @@ public void handleEvent(final CloseableChannel c) {
                 //we make sure there is no data left to receive, if there is then we invoke the receive listener
                 final ChannelListener<? super C> listener = receiveSetter.get();
                 if(listener != null) {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
-                            while (readData != null  && !readData.isFreed()) {
+                            while (readData != null && !readData.isFreed()) {
                                 int rem = readData.getResource().remaining();
                                 ChannelListeners.invokeChannelListener(AbstractFramedChannel.this, (ChannelListener) receiveSetter.get());
-                                if(readData != null && rem == readData.getResource().remaining()) {
+                                if (readData != null && rem == readData.getResource().remaining()) {
                                     break;//make sure we are making progress
                                 }
                             }
@@ -890,7 +911,12 @@ public void run() {
             }
 
             if (Thread.currentThread() != c.getIoThread()) {
-                ChannelListeners.invokeChannelListener(c.getIoThread(), c, this);
+                runInIoThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
+                    }
+                });
                 return;
             }
             R receiver = AbstractFramedChannel.this.receiver;",2015-06-24T14:46:23Z,168
"@@ -196,7 +196,7 @@ protected void resumeWritesInternal(boolean wakeup) {
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             state |= STATE_IN_LISTENER_LOOP;
-            getIoThread().execute(new Runnable() {
+            getChannel().runInIoThread(new Runnable() {
 
                 int loopCount = 0;
 ",2015-06-24T14:46:23Z,234
"@@ -250,7 +250,7 @@ void resumeReadsInternal(boolean wakeup) {
         if(!alreadyResumed || wakeup) {
             if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
                 state |= STATE_IN_LISTENER_LOOP;
-                getIoThread().execute(new Runnable() {
+                getFramedChannel().runInIoThread(new Runnable() {
 
                     @Override
                     public void run() {",2015-06-24T14:46:23Z,190
"@@ -285,7 +285,7 @@ public void run() {
                                     //although we may be flushed as part of a batch
                                     moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);
                                 }
-                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);
+                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);
                             } finally {
                                 state &= ~STATE_IN_LISTENER_LOOP;
                             }",2017-06-12T20:50:00Z,190
"@@ -103,14 +103,6 @@ public void suspendWrites() {
         state &= ~STATE_WRITES_RESUMED;
     }
 
-    protected void suspendWritesInternal() {
-        channel.suspendWrites();
-    }
-
-    protected void resumeWritesInternal() {
-        channel.resumeWrites();
-    }
-
     /**
      * Returns the header for the current frame.
      *
@@ -163,12 +155,24 @@ public boolean isWriteResumed() {
 
     @Override
     public void wakeupWrites() {
-        resumeWrites();
+        resumeWritesInternal(true);
     }
 
     @Override
     public void resumeWrites() {
+        resumeWritesInternal(false);
+    }
+
+    protected void resumeWritesInternal(boolean wakeup) {
+        boolean alreadyResumed = anyAreSet(state, STATE_WRITES_RESUMED);
+        if(!wakeup && alreadyResumed) {
+            return;
+        }
         state |= STATE_WRITES_RESUMED;
+        if(anyAreSet(state, STATE_READY_FOR_FLUSH) && !wakeup) {
+            //we already have data queued to be flushed
+            return;
+        }
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             getIoThread().execute(new Runnable() {
@@ -408,7 +412,7 @@ public void close() throws IOException {
         }
         //we need to wake up/invoke the write listener
         if(isWriteResumed()) {
-            resumeWritesInternal();
+            ChannelListeners.invokeChannelListener(getIoThread(), this, (ChannelListener)getWriteListener());
         }
         wakeupWrites();
     }",2014-07-10T06:55:51Z,234
"@@ -243,6 +243,9 @@ public void shutdownReads() throws IOException {
     protected void lastFrame() {
         state |= STATE_LAST_FRAME;
         waitingForFrame = false;
+        if(data == null && pendingFrameData.isEmpty()) {
+            state |= STATE_DONE | STATE_CLOSED;
+        }
     }
 
     @Override",2014-07-10T06:55:51Z,190
"@@ -183,6 +183,9 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * @return The number of bytes that can be sent
      */
     protected synchronized int grabFlowControlBytes(int toSend) {
+        if(toSend == 0) {
+            return 0;
+        }
         int newWindowSize = this.getChannel().getInitialWindowSize();
         int settingsDelta = newWindowSize - this.initialWindowSize;
         //first adjust for any settings frame updates
@@ -192,9 +195,6 @@ protected synchronized int grabFlowControlBytes(int toSend) {
         int min = Math.min(toSend, this.flowControlWindow);
         int actualBytes = this.getChannel().grabFlowControlBytes(min);
         this.flowControlWindow -= actualBytes;
-        if (actualBytes == 0) {
-            suspendWritesInternal();
-        }
         return actualBytes;
     }
 
@@ -204,7 +204,7 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         if (exhausted) {
             getChannel().notifyFlowControlAllowed();
             if (isWriteResumed()) {
-                resumeWritesInternal();
+                resumeWritesInternal(true);
             }
         }
     }",2014-07-10T06:55:51Z,72
"@@ -130,6 +130,8 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private volatile int outstandingBuffers;
     private volatile AtomicIntegerFieldUpdater<AbstractFramedChannel> outstandingBuffersUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, ""outstandingBuffers"");
 
+    private final LinkedBlockingDeque<Runnable> taskRunQueue = new LinkedBlockingDeque<>();
+
     private final ReferenceCountedPooled.FreeNotifier freeNotifier = new ReferenceCountedPooled.FreeNotifier() {
         @Override
         public void freed() {
@@ -192,6 +194,18 @@ protected IdleTimeoutConduit createIdleTimeoutChannel(StreamConnection connected
         return new IdleTimeoutConduit(connectedStreamChannel.getSinkChannel().getConduit(), connectedStreamChannel.getSourceChannel().getConduit());
     }
 
+    void runInIoThread(Runnable task) {
+        this.taskRunQueue.add(task);
+        getIoThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                while (!taskRunQueue.isEmpty()) {
+                    taskRunQueue.poll().run();
+                }
+            }
+        });
+    }
+
     /**
      * Get the buffer pool for this connection.
      *
@@ -355,7 +369,6 @@ public synchronized R receive() throws IOException {
                     pooled.getResource().position((int) (pooled.getResource().position() + frameDataRemaining));
                     frameDataRemaining = 0;
                     Pooled<ByteBuffer> frameData = pooled.createView(buf);
-                    //note that we don't return here, there may be another frame
                     if(receiver != null) {
                         receiver.dataReady(null, frameData);
                     } else{
@@ -368,6 +381,9 @@ public synchronized R receive() throws IOException {
                 //see https://issues.jboss.org/browse/UNDERTOW-410
                 //basically if we don't do this we loose some message ordering semantics
                 //as the second message may be processed before the first one
+
+                //this is problematic for HTTPS, where the read listener may also be invoked by a queued task
+                //and not by the selector mechanism
                 return null;
             }
             FrameHeaderData data = parseFrame(pooled.getResource());
@@ -592,7 +608,7 @@ protected synchronized void flushSenders() {
         } finally {
             flushingSenders = false;
             if(!newFrames.isEmpty()) {
-                getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -629,7 +645,7 @@ protected synchronized void queueFrame(final S channel) throws IOException {
             if(channel.getIoThread() == Thread.currentThread()) {
                 flushSenders();
             } else {
-                channel.getIoThread().execute(new Runnable() {
+                runInIoThread(new Runnable() {
                     @Override
                     public void run() {
                         flushSenders();
@@ -816,6 +832,11 @@ private final class FrameReadListener implements ChannelListener<StreamSourceCha
         @SuppressWarnings({""unchecked"", ""rawtypes""})
         @Override
         public void handleEvent(final StreamSourceChannel channel) {
+            //clear the task queue before reading
+            while (!taskRunQueue.isEmpty()) {
+                taskRunQueue.poll().run();
+            }
+
             final R receiver = AbstractFramedChannel.this.receiver;
             if ((isLastFrameReceived() || receivesSuspended) && receiver == null) {
                 channel.suspendReads();
@@ -831,7 +852,7 @@ public void handleEvent(final StreamSourceChannel channel) {
             }
             if (readData != null  && !readData.isFreed() && channel.isOpen()) {
                 try {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
                             ChannelListeners.invokeChannelListener(channel, FrameReadListener.this);
@@ -872,13 +893,13 @@ public void handleEvent(final CloseableChannel c) {
                 //we make sure there is no data left to receive, if there is then we invoke the receive listener
                 final ChannelListener<? super C> listener = receiveSetter.get();
                 if(listener != null) {
-                    channel.getIoThread().execute(new Runnable() {
+                    runInIoThread(new Runnable() {
                         @Override
                         public void run() {
-                            while (readData != null  && !readData.isFreed()) {
+                            while (readData != null && !readData.isFreed()) {
                                 int rem = readData.getResource().remaining();
                                 ChannelListeners.invokeChannelListener(AbstractFramedChannel.this, (ChannelListener) receiveSetter.get());
-                                if(readData != null && rem == readData.getResource().remaining()) {
+                                if (readData != null && rem == readData.getResource().remaining()) {
                                     break;//make sure we are making progress
                                 }
                             }
@@ -890,7 +911,12 @@ public void run() {
             }
 
             if (Thread.currentThread() != c.getIoThread()) {
-                ChannelListeners.invokeChannelListener(c.getIoThread(), c, this);
+                runInIoThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
+                    }
+                });
                 return;
             }
             R receiver = AbstractFramedChannel.this.receiver;",2015-06-24T14:46:23Z,168
"@@ -196,7 +196,7 @@ protected void resumeWritesInternal(boolean wakeup) {
 
         if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
             state |= STATE_IN_LISTENER_LOOP;
-            getIoThread().execute(new Runnable() {
+            getChannel().runInIoThread(new Runnable() {
 
                 int loopCount = 0;
 ",2015-06-24T14:46:23Z,234
"@@ -250,7 +250,7 @@ void resumeReadsInternal(boolean wakeup) {
         if(!alreadyResumed || wakeup) {
             if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {
                 state |= STATE_IN_LISTENER_LOOP;
-                getIoThread().execute(new Runnable() {
+                getFramedChannel().runInIoThread(new Runnable() {
 
                     @Override
                     public void run() {",2015-06-24T14:46:23Z,190
"@@ -19,7 +19,6 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -45,16 +44,7 @@ protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxExcept
     }
 
     protected URI getRedirectURI(HttpServerExchange exchange, int port) throws URISyntaxException {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        } else {
-            if (host.startsWith(""["")) {
-                host = host.substring(1, host.indexOf(']'));
-            } else {
-                host = host.substring(0, host.indexOf(':'));
-            }
-        }
+        String host = exchange.getHostName();
 
         String queryString = exchange.getQueryString();
         return new URI(""https"", null, host, port, exchange.getRequestURI(),",2013-05-27T02:00:32Z,281
"@@ -159,12 +159,8 @@ protected Integer servePage(final HttpServerExchange exchange, final String loca
 
 
     static void sendRedirect(final HttpServerExchange exchange, final String location) {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        }
         // TODO - String concatenation to construct URLS is extremely error prone - switch to a URI which will better handle this.
-        String loc = exchange.getRequestScheme() + ""://"" + host + location;
+        String loc = exchange.getRequestScheme() + ""://"" + exchange.getHostAndPort() + location;
         exchange.getResponseHeaders().put(Headers.LOCATION, loc);
     }
 }",2013-05-27T02:00:32Z,148
"@@ -44,6 +44,7 @@
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.NetworkUtils;
 import io.undertow.util.Protocols;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.WrapperConduitFactory;
@@ -453,12 +454,54 @@ public String getRequestURL() {
         if (isHostIncludedInRequestURI()) {
             return getRequestURI();
         } else {
-            String host = getRequestHeaders().getFirst(Headers.HOST);
-            if (host == null) {
-                host = getDestinationAddress().getAddress().getHostAddress();
+            return getRequestScheme() + ""://"" + getHostAndPort() + getRequestURI();
+        }
+    }
+
+    /**
+     * Return the host that this request was sent to, in general this will be the
+     * value of the Host header, minus the port specifier.
+     *
+     * If this resolves to an IPv6 address it will not be enclosed by square brackets.
+     * Care must be taken when constructing URLs based on this method to ensure IPv6 URLs
+     * are handled correctly.
+     *
+     * @return The host part of the destination address
+     */
+    public String getHostName() {
+        String host = requestHeaders.getFirst(Headers.HOST);
+        if (host == null) {
+            host = getDestinationAddress().getAddress().getHostAddress();
+        } else {
+            if (host.startsWith(""["")) {
+                host = host.substring(1, host.indexOf(']'));
+            } else if (host.indexOf(':') != -1) {
+                host = host.substring(0, host.indexOf(':'));
+            }
+        }
+        return host;
+    }
+
+    /**
+     * Return the host, and also the port if this request was sent to a non-standard port. In general
+     * this will just be the value of the Host header.
+     *
+     * If this resolves to an IPv6 address it *will*  be enclosed by square brackets. The return
+     * value of this method is suitable for inclusion in a URL.
+     *
+     * @return The host and port part of the destination address
+     */
+    public String getHostAndPort() {
+        String host = requestHeaders.getFirst(Headers.HOST);
+        if (host == null) {
+            host = NetworkUtils.formatPossibleIpv6Address(getDestinationAddress().getAddress().getHostAddress());
+            int port = getDestinationAddress().getPort();
+            if (!((getRequestScheme().equals(""http"") && port == 80)
+                    || (getRequestScheme().equals(""https"") && port == 8080))) {
+                host = host + "":"" + port;
             }
-            return getRequestScheme() + ""://"" + host + getRequestURI();
         }
+        return host;
     }
 
     /**",2013-05-27T02:00:32Z,132
"@@ -0,0 +1,24 @@
+package io.undertow.util;
+
+/**
+ * @author Stuart Douglas
+ */
+public class NetworkUtils {
+
+    public static String formatPossibleIpv6Address(String address) {
+        if (address == null) {
+            return address;
+        }
+        if (!address.contains("":"")) {
+            return address;
+        }
+        if (address.startsWith(""["") && address.endsWith(""]"")) {
+            return address;
+        }
+        return ""["" + address + ""]"";
+    }
+
+    private NetworkUtils() {
+
+    }
+}",2013-05-27T02:00:32Z,174
"@@ -696,15 +696,7 @@ public String getScheme() {
 
     @Override
     public String getServerName() {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if(host != null) {
-            if(host.contains("":"")) {
-                String[] split = host.split("":"");
-                return split[0];
-            }
-            return host;
-        }
-        return exchange.getDestinationAddress().getHostName();
+        return exchange.getHostName();
     }
 
     @Override",2013-05-27T02:00:32Z,147
"@@ -156,11 +156,7 @@ public void sendRedirect(final String location) throws IOException {
             }
             realPath = servletContext.getContextPath() + CanonicalPathUtils.canonicalize(current + location);
         }
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        }
-        String loc = exchange.getRequestScheme() + ""://"" + host + realPath;
+        String loc = exchange.getRequestScheme() + ""://"" + exchange.getHostAndPort() + realPath;
         exchange.getResponseHeaders().put(Headers.LOCATION, loc);
         responseDone();
     }",2013-05-27T02:00:32Z,170
"@@ -101,6 +101,18 @@ public static void flattenCookies(final HttpServerExchange exchange) {
         }
     }
 
+    /**
+     * Adds the cookie into the response header map. This should be called
+     * before the response is started.
+     *
+     * @param exchange The server exchange
+     * @param cookie   The cookie
+     */
+    public static void addCookie(final HttpServerExchange exchange, Cookie cookie) {
+        boolean enableRfc6265Validation = exchange.getConnection().getUndertowOptions().get(UndertowOptions.ENABLE_RFC6265_COOKIE_VALIDATION, UndertowOptions.DEFAULT_ENABLE_RFC6265_COOKIE_VALIDATION);
+        exchange.getResponseHeaders().add(Headers.SET_COOKIE, getCookieString(cookie, enableRfc6265Validation));
+    }
+
     /**
      * Attached buffered data to the exchange. The will generally be used to allow data to be re-read.
      *",2019-06-17T07:33:25Z,163
"@@ -32,17 +32,20 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeMap;
 import java.util.function.Supplier;
 
 import javax.servlet.ServletException;
 import javax.servlet.ServletOutputStream;
 import javax.servlet.SessionTrackingMode;
-import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
 
 import io.undertow.UndertowLogger;
+import io.undertow.server.Connectors;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.ResponseCommitListener;
+import io.undertow.server.handlers.Cookie;
 import io.undertow.server.protocol.http.HttpAttachments;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.handlers.ServletRequestContext;
@@ -85,6 +88,7 @@ public final class HttpServletResponseImpl implements HttpServletResponse {
     private String contentType;
     private String charset;
     private Supplier<Map<String, String>> trailerSupplier;
+    private Map<String, Map<String, Cookie>> duplicateCookies;
 
     public HttpServletResponseImpl(final HttpServerExchange exchange, final ServletContextImpl servletContext) {
         this.exchange = exchange;
@@ -97,14 +101,41 @@ public HttpServerExchange getExchange() {
     }
 
     @Override
-    public void addCookie(final Cookie cookie) {
+    public void addCookie(final javax.servlet.http.Cookie cookie) {
         if (insideInclude) {
             return;
         }
         final ServletCookieAdaptor servletCookieAdaptor = new ServletCookieAdaptor(cookie);
         if (cookie.getVersion() == 0) {
             servletCookieAdaptor.setVersion(servletContext.getDeployment().getDeploymentInfo().getDefaultCookieVersion());
         }
+        // test for duplicate entry
+        if (exchange.getResponseCookies().containsKey(servletCookieAdaptor.getName())) {
+            final String cookieName = servletCookieAdaptor.getName();
+            final String path = servletCookieAdaptor.getPath();
+            final Cookie otherCookie = exchange.getResponseCookies().get(cookieName);
+            final String otherCookiePath = otherCookie.getPath();
+            // if both cookies have same path and name, overwrite previous cookie
+            if ((path == otherCookiePath) || (path != null && path.equals(otherCookiePath))) {
+                exchange.setResponseCookie(servletCookieAdaptor);
+            }
+            // else, create a duplicate cookie entry
+            else {
+                final Map<String, Cookie> cookiesByPath;
+                if (duplicateCookies == null) {
+                    duplicateCookies = new TreeMap<>();
+                    exchange.addResponseCommitListener(
+                            new DuplicateCookieCommitListener());
+                }
+                if (duplicateCookies.containsKey(cookieName)) {
+                    cookiesByPath = duplicateCookies.get(cookieName);
+                } else {
+                    cookiesByPath = new TreeMap<>();
+                    duplicateCookies.put(cookieName, cookiesByPath);
+                }
+                cookiesByPath.put(otherCookiePath == null ? ""null"" : otherCookiePath, otherCookie);
+            }
+        }
         exchange.setResponseCookie(servletCookieAdaptor);
     }
 
@@ -815,4 +846,17 @@ public void setTrailerFields(Supplier<Map<String, String>> supplier) {
     public Supplier<Map<String, String>> getTrailerFields() {
         return trailerSupplier;
     }
+
+    private class DuplicateCookieCommitListener implements
+            ResponseCommitListener {
+
+        @Override
+        public void beforeCommit(HttpServerExchange exchange) {
+            for (Map.Entry<String, Map<String, Cookie>> duplicateCookiesEntry : duplicateCookies.entrySet()) {
+                for (Map.Entry<String, Cookie> cookiesByPathEntry : duplicateCookiesEntry.getValue().entrySet()) {
+                    Connectors.addCookie(exchange, cookiesByPathEntry.getValue());
+                }
+            }
+        }
+    }
 }",2019-06-17T07:33:25Z,170
"@@ -0,0 +1,48 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.response.cookies;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Simple servlet that adds cookies to response.
+ *
+ * @author Flavia Rainone
+ */
+public class AddCookiesServlet extends HttpServlet {
+
+    @Override
+    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+        Cookie cookie1 = new Cookie(""test1"", ""test1"");
+        cookie1.setPath(""/test"");
+
+        Cookie cookie2 = new Cookie(""test2"", ""test2"");
+
+        resp.addCookie(cookie1);
+        resp.addCookie(cookie2);
+
+        resp.getWriter().append(""Served at: "").append(req.getContextPath());
+    }
+}",2019-06-17T07:33:25Z,282
"@@ -0,0 +1,49 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.response.cookies;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Servlet that adds duplicate cookies (i.e., with the same name) to response.
+ *
+ * @author Flavia Rainone
+ */
+public class DuplicateCookiesServlet extends HttpServlet {
+
+    @Override
+    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+        Cookie cookie1 = new Cookie(""test"", ""test"");
+        cookie1.setPath(""/test"");
+
+        Cookie cookie2 = new Cookie(""test"", ""test"");
+        cookie2.setPath(""/test2"");
+
+        resp.addCookie(cookie1);
+        resp.addCookie(cookie2);
+
+        resp.getWriter().append(""Served at: "").append(req.getContextPath());
+    }
+}",2019-06-17T07:33:25Z,283
"@@ -0,0 +1,64 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.response.cookies;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Servlet that emulates a buggy behavior where JSessionID cookie is added several times with
+ * wrong path, and a few of them with max age limits for cookie expiration.
+ *
+ * @author Flavia Rainone
+ */
+public class JSessionIDCookiesServlet extends HttpServlet {
+
+    @Override
+    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+        javax.servlet.http.Cookie cookie1 = new javax.servlet.http.Cookie(""JSESSIONID"", ""_bug_fix"");
+        cookie1.setPath(""/path1"");
+        cookie1.setMaxAge(0);
+
+        javax.servlet.http.Cookie cookie2 = new javax.servlet.http.Cookie(""JSESSIONID"", ""_bug_fix"");
+        cookie2.setPath(""/path2"");
+        cookie2.setMaxAge(0);
+
+        javax.servlet.http.Cookie cookie3 = new javax.servlet.http.Cookie(""JSESSIONID"", ""_bug_fix"");
+        cookie1.setPath(""/path3"");
+        cookie1.setMaxAge(500);
+
+        javax.servlet.http.Cookie cookie4 = new javax.servlet.http.Cookie(""JSESSIONID"", ""_bug_fix"");
+        cookie2.setPath(""/path4"");
+        cookie2.setMaxAge(1000);
+
+        resp.addCookie(cookie1);
+        resp.addCookie(cookie2);
+        resp.addCookie(cookie3);
+        resp.addCookie(cookie4);
+
+        // creating session -> additional set-cookie
+        req.getSession().setAttribute(""CleanSessions"", true);
+
+        resp.getWriter().append(""Served at: "").append(req.getContextPath());
+    }
+}",2019-06-17T07:33:25Z,284
"@@ -0,0 +1,61 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.response.cookies;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Servlet that adds multiple cookies with same name and a few of which sharing
+ * the same path, to test cookies with same path and name being correctly
+ * overriden.
+ *
+ * @author Flavia Rainone
+ */
+public class OverwriteCookiesServlet extends HttpServlet {
+
+    @Override
+    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+        Cookie cookie1 = new javax.servlet.http.Cookie(""test"", ""test1"");
+        cookie1.setPath(""/test"");
+
+        Cookie cookie2 = new javax.servlet.http.Cookie(""test"", ""test2"");
+        cookie2.setPath(""/test"");
+
+        Cookie cookie3 = new javax.servlet.http.Cookie(""test"", ""test3"");
+        Cookie cookie4 = new javax.servlet.http.Cookie(""test"", ""test4"");
+        Cookie cookie5 = new javax.servlet.http.Cookie(""test"", ""test5"");
+
+        resp.addCookie(cookie1);
+        resp.addCookie(cookie2);
+        resp.addCookie(cookie3);
+        resp.addCookie(cookie4);
+        resp.addCookie(cookie5);
+
+        // creating session -> additional jsessionid set-cookie
+        req.getSession().setAttribute(""CleanSessions"", true);
+
+        resp.getWriter().append(""Served at: "").append(req.getContextPath());
+    }
+}",2019-06-17T07:33:25Z,285
"@@ -0,0 +1,146 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2019 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.servlet.test.response.cookies;
+
+import javax.servlet.ServletException;
+
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.test.util.DeploymentUtils;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.StatusCodes;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test for response.addCookie
+ *
+ * @author Flavia Rainone
+ */
+@RunWith(DefaultServer.class)
+public class ResponseCookiesTestCase {
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+        DeploymentUtils.setupServlet(
+                new ServletInfo(""add-cookies"", AddCookiesServlet.class)
+                        .addMapping(""/add-cookies""),
+                new ServletInfo(""duplicate-cookies"", DuplicateCookiesServlet.class)
+                .addMapping(""/duplicate-cookies""),
+                new ServletInfo(""overwrite-cookies"", OverwriteCookiesServlet.class)
+                        .addMapping(""/overwrite-cookies""),
+                new ServletInfo(""jsessionid-cookies"", JSessionIDCookiesServlet.class)
+                        .addMapping(""/jsessionid-cookies""));
+    }
+
+    @Test
+    public void addCookies() throws Exception {
+        final TestHttpClient client = new TestHttpClient();
+        try {
+            final HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/add-cookies"");
+            final HttpResponse result = client.execute(get);
+            assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+
+            final String response = HttpClientUtils.readResponse(result);
+            assertEquals(""Served at: /servletContext"", response);
+
+            final Header[] setCookieHeaders = result.getHeaders(""Set-Cookie"");
+            assertEquals(2, setCookieHeaders.length);
+            assertEquals(""test1=test1; path=/test"", setCookieHeaders[0].getValue());
+            assertEquals(""test2=test2"", setCookieHeaders[1].getValue());
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void duplicateCookies() throws Exception {
+        final TestHttpClient client = new TestHttpClient();
+        try {
+            final HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/duplicate-cookies"");
+            final HttpResponse result = client.execute(get);
+            assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+
+            final String response = HttpClientUtils.readResponse(result);
+            assertEquals(""Served at: /servletContext"", response);
+
+            final Header[] setCookieHeaders = result.getHeaders(""Set-Cookie"");
+            assertEquals(2, setCookieHeaders.length);
+            assertEquals(""test=test; path=/test"", setCookieHeaders[0].getValue());
+            assertEquals(""test=test; path=/test2"", setCookieHeaders[1].getValue());
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void overwriteCookies() throws Exception {
+        final TestHttpClient client = new TestHttpClient();
+        try {
+            final HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/overwrite-cookies"");
+            final HttpResponse result = client.execute(get);
+            assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+
+            final String response = HttpClientUtils.readResponse(result);
+            assertEquals(""Served at: /servletContext"", response);
+
+            final Header[] setCookieHeaders = result.getHeaders(""Set-Cookie"");
+            assertEquals(3, setCookieHeaders.length);
+            assertEquals(""test=test2; path=/test"", setCookieHeaders[0].getValue());
+            assertTrue(""Header "" + setCookieHeaders[1] + ""didn't match expected regex"",
+                    setCookieHeaders[1].getValue().matches(""JSESSIONID=.*; path=/servletContext""));
+            assertEquals(""test=test5"", setCookieHeaders[2].getValue());
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void jsessionIdCookies() throws Exception {
+        final TestHttpClient client = new TestHttpClient();
+        try {
+            final HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/jsessionid-cookies"");
+            final HttpResponse result = client.execute(get);
+            assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+
+            final String response = HttpClientUtils.readResponse(result);
+            assertEquals(""Served at: /servletContext"", response);
+
+            final Header[] setCookieHeaders = result.getHeaders(""Set-Cookie"");
+            assertEquals(3, setCookieHeaders.length);
+            assertTrue(""Header "" + setCookieHeaders[0] + ""didn't start with expected prefix"",
+                    setCookieHeaders[0].getValue().startsWith(""JSESSIONID=_bug_fix; path=/path3; Max-Age=500; Expires=""));
+            assertTrue(""Header "" + setCookieHeaders[1] + ""didn't start with expected prefix"",
+                    setCookieHeaders[1].getValue().startsWith(""JSESSIONID=_bug_fix; path=/path4; Max-Age=1000; Expires=""));
+           assertTrue(""Header "" + setCookieHeaders[2] + ""didn't match expected regex"",
+                    setCookieHeaders[2].getValue().matches(""JSESSIONID=.*; path=/servletContext""));
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+}",2019-06-17T07:33:25Z,286
"@@ -44,6 +44,7 @@
 import java.util.Deque;
 import java.util.Map;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
@@ -542,13 +543,25 @@ public void connect(ProxyClient.ProxyTarget proxyTarget, HttpServerExchange exch
      *
      */
     void closeCurrentConnections() {
-        for(Map.Entry<XnioIoThread, HostThreadData> data : hostThreadData.entrySet()) {
-            ConnectionHolder d = data.getValue().availableConnections.poll();
-            while (d != null) {
-                IoUtils.safeClose(d.clientConnection);
-                d = data.getValue().availableConnections.poll();
-            }
-            data.getValue().connections = 0;
+        final CountDownLatch latch = new CountDownLatch(hostThreadData.size());
+        for(final Map.Entry<XnioIoThread, HostThreadData> data : hostThreadData.entrySet()) {
+            data.getKey().execute(new Runnable() {
+                @Override
+                public void run() {
+                    ConnectionHolder d = data.getValue().availableConnections.poll();
+                    while (d != null) {
+                        IoUtils.safeClose(d.clientConnection);
+                        d = data.getValue().availableConnections.poll();
+                    }
+                    data.getValue().connections = 0;
+                    latch.countDown();
+                }
+            });
+        }
+        try {
+            latch.await(10, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
         }
     }
 ",2016-12-19T23:53:43Z,6
"@@ -123,7 +123,7 @@ private static RewriteConfig parse(BufferedReader reader) {
      * @param line
      * @return
      */
-    public static Object parse(String line) {
+    private static Object parse(String line) {
         StringTokenizer tokenizer = new StringTokenizer(line);
         if (tokenizer.hasMoreTokens()) {
             String token = tokenizer.nextToken();",2015-11-02T00:29:09Z,287
"@@ -219,7 +219,10 @@ else if (index == urlString.length() - 1) {
                 StringBuilder chunk = new StringBuilder();
                 chunk.append(request.getContextPath());
                 chunk.append(urlString);
-                exchange.setRequestPath(chunk.toString());
+                String requestPath = chunk.toString();
+                exchange.setRequestPath(requestPath);
+                exchange.setRelativePath(urlString);
+
                 // Set the new Query if there is one
                 if (queryString != null) {
                     exchange.setQueryString(queryString);",2015-11-02T00:29:09Z,288
"@@ -41,7 +41,6 @@
 @RunWith(DefaultServer.class)
 public class CharacterEncodingTestCase {
 
-
     @BeforeClass
     public static void setup() throws ServletException {
         DeploymentUtils.setupServlet(",2015-11-02T00:29:09Z,289
"@@ -0,0 +1,90 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.compat.rewrite;
+
+import io.undertow.server.HandlerWrapper;
+import io.undertow.server.HttpHandler;
+import io.undertow.servlet.ServletExtension;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.compat.rewrite.RewriteConfig;
+import io.undertow.servlet.compat.rewrite.RewriteConfigFactory;
+import io.undertow.servlet.compat.rewrite.RewriteHandler;
+import io.undertow.servlet.test.util.DeploymentUtils;
+import io.undertow.servlet.test.util.PathTestServlet;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.StatusCodes;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import java.io.ByteArrayInputStream;
+import java.nio.charset.StandardCharsets;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class RewriteTestCase {
+
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+        DeploymentUtils.setupServlet(new ServletExtension() {
+                                         @Override
+                                         public void handleDeployment(DeploymentInfo deploymentInfo, ServletContext servletContext) {
+                                             deploymentInfo.addOuterHandlerChainWrapper(new HandlerWrapper() {
+                                                 @Override
+                                                 public HttpHandler wrap(HttpHandler handler) {
+
+                                                     byte[] data = ""RewriteRule /foo1 /bar1"".getBytes(StandardCharsets.UTF_8);
+                                                     RewriteConfig config = RewriteConfigFactory.build(new ByteArrayInputStream(data));
+
+                                                     return new RewriteHandler(config, handler);
+                                                 }
+                                             });
+                                         }
+                                     },
+                new ServletInfo(""servlet"", PathTestServlet.class)
+                        .addMapping(""/""));
+    }
+
+    @Test
+    public void testRewrite() throws Exception{
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/foo1"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""pathInfo:null queryString:null servletPath:/bar1 requestUri:/servletContext/foo1"", response);
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+}",2015-11-02T00:29:09Z,290
"@@ -289,8 +289,8 @@ public void serveRange(Sender sender, HttpServerExchange exchange, long start, l
                     b.position((int) (b.position() + startDec));
                     startDec = 0;
                 } else {
-                    b.position(b.limit());
                     startDec -= b.remaining();
+                    b.position(b.limit());
                 }
             }
 ",2019-10-12T03:00:49Z,291
"@@ -85,6 +85,57 @@ public void testCachedResourceHandler() throws IOException, InterruptedException
         }
     }
 
+    @Test
+    public void testLargeCachedResourceHandler() throws IOException, InterruptedException {
+        String path = ""/cachedresource/largerange.txt"";
+        TestHttpClient client = new TestHttpClient();
+        try {
+            for(int i = 0; i < 3; ++i) {
+                HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
+                HttpResponse result = client.execute(get);
+                Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+                client.getConnectionManager().shutdown();
+                client = new TestHttpClient();
+            }
+
+            for(int i = 0; i < 10; ++i) {
+                HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
+                get.addHeader(Headers.RANGE_STRING, ""bytes=10-20"");
+                HttpResponse result = client.execute(get);
+                Assert.assertEquals(StatusCodes.PARTIAL_CONTENT, result.getStatusLine().getStatusCode());
+                String response = EntityUtils.toString(result.getEntity());
+                Assert.assertEquals(""89\n2:012345"", response);
+                Assert.assertEquals( ""bytes 10-20/1034"", result.getFirstHeader(Headers.CONTENT_RANGE_STRING).getValue());
+
+                get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
+                get.addHeader(Headers.RANGE_STRING, ""bytes=1000-1024"");
+                result = client.execute(get);
+                Assert.assertEquals(StatusCodes.PARTIAL_CONTENT, result.getStatusLine().getStatusCode());
+                response = EntityUtils.toString(result.getEntity());
+                Assert.assertEquals(""3:0123456789\n74:012345678"", response);
+                Assert.assertEquals( ""bytes 1000-1024/1034"", result.getFirstHeader(Headers.CONTENT_RANGE_STRING).getValue());
+
+                get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
+                get.addHeader(Headers.RANGE_STRING, ""bytes=1001-1024"");
+                result = client.execute(get);
+                Assert.assertEquals(StatusCodes.PARTIAL_CONTENT, result.getStatusLine().getStatusCode());
+                response = EntityUtils.toString(result.getEntity());
+                Assert.assertEquals("":0123456789\n74:012345678"", response);
+                Assert.assertEquals( ""bytes 1001-1024/1034"", result.getFirstHeader(Headers.CONTENT_RANGE_STRING).getValue());
+
+                get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
+                get.addHeader(Headers.RANGE_STRING, ""bytes=1025-1030"");
+                result = client.execute(get);
+                Assert.assertEquals(StatusCodes.PARTIAL_CONTENT, result.getStatusLine().getStatusCode());
+                response = EntityUtils.toString(result.getEntity());
+                Assert.assertEquals(""9abcde"", response);
+                Assert.assertEquals( ""bytes 1025-1030/1034"", result.getFirstHeader(Headers.CONTENT_RANGE_STRING).getValue());
+            }
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
     public void runTest(String path, boolean etag) throws IOException, InterruptedException {
         TestHttpClient client = new TestHttpClient();
         try {",2019-10-12T03:00:49Z,292
"@@ -0,0 +1,74 @@
+1:0123456789
+2:0123456789
+3:0123456789
+4:0123456789
+5:0123456789
+6:0123456789
+7:0123456789
+8:0123456789
+9:0123456789
+10:0123456789
+11:0123456789
+12:0123456789
+13:0123456789
+14:0123456789
+15:0123456789
+16:0123456789
+17:0123456789
+18:0123456789
+19:0123456789
+20:0123456789
+21:0123456789
+22:0123456789
+23:0123456789
+24:0123456789
+25:0123456789
+26:0123456789
+27:0123456789
+28:0123456789
+29:0123456789
+30:0123456789
+31:0123456789
+32:0123456789
+33:0123456789
+34:0123456789
+35:0123456789
+36:0123456789
+37:0123456789
+38:0123456789
+39:0123456789
+40:0123456789
+41:0123456789
+42:0123456789
+43:0123456789
+44:0123456789
+45:0123456789
+46:0123456789
+47:0123456789
+48:0123456789
+49:0123456789
+50:0123456789
+51:0123456789
+52:0123456789
+53:0123456789
+54:0123456789
+55:0123456789
+56:0123456789
+57:0123456789
+58:0123456789
+59:0123456789
+60:0123456789
+61:0123456789
+62:0123456789
+63:0123456789
+64:0123456789
+65:0123456789
+66:0123456789
+67:0123456789
+68:0123456789
+69:0123456789
+70:0123456789
+71:0123456789
+72:0123456789
+73:0123456789
+74:0123456789abcdefg",2019-10-12T03:00:49Z,293
"@@ -504,4 +504,7 @@ public interface UndertowMessages {
 
     @Message(id = 157, value = ""Invalid GZIP footer"")
     IOException invalidGZIPFooter();
+
+    @Message(id = 158, value = ""Response of length %s is too large to buffer"")
+    IllegalStateException responseTooLargeToBuffer(Long length);
 }",2017-01-02T21:28:19Z,68
"@@ -0,0 +1,99 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.attribute;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.StandardCharsets;
+
+import io.undertow.UndertowLogger;
+import io.undertow.conduits.StoredResponseStreamSinkConduit;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.HeaderMap;
+import io.undertow.util.Headers;
+
+/**
+ * @author Stuart Douglas
+ */
+public class StoredResponse implements ExchangeAttribute {
+
+    public static ExchangeAttribute INSTANCE = new StoredResponse();
+
+    private StoredResponse() {
+
+    }
+
+    @Override
+    public String readAttribute(HttpServerExchange exchange) {
+        byte[] data = exchange.getAttachment(StoredResponseStreamSinkConduit.RESPONSE);
+        if(data == null) {
+            return null;
+        }
+        String charset = extractCharset(exchange.getResponseHeaders());
+        if(charset == null) {
+            return null;
+        }
+        try {
+            return new String(data, charset);
+        } catch (UnsupportedEncodingException e) {
+            UndertowLogger.ROOT_LOGGER.debugf(e,""Could not decode response body using charset %s"", charset);
+            return null;
+        }
+    }
+    private String extractCharset(HeaderMap headers) {
+        String contentType = headers.getFirst(Headers.CONTENT_TYPE);
+        if (contentType != null) {
+            String value = Headers.extractQuotedValueFromHeader(contentType, ""charset"");
+            if (value != null) {
+                return value;
+            }
+            //if it is text we default to ISO_8859_1
+            if(contentType.startsWith(""text/"")) {
+                return StandardCharsets.ISO_8859_1.displayName();
+            }
+            return null;
+        }
+        return null;
+    }
+
+    @Override
+    public void writeAttribute(HttpServerExchange exchange, String newValue) throws ReadOnlyAttributeException {
+        throw new ReadOnlyAttributeException(""Stored Response"", newValue);
+    }
+
+    public static class Builder implements ExchangeAttributeBuilder {
+
+        @Override
+        public String name() {
+            return ""Stored Response"";
+        }
+
+        @Override
+        public ExchangeAttribute build(final String token) {
+            if (token.equals(""%{STORED_RESPONSE}"")) {
+                return INSTANCE;
+            }
+            return null;
+        }
+
+        @Override
+        public int priority() {
+            return 0;
+        }
+    }
+}",2017-01-02T21:28:19Z,180
"@@ -0,0 +1,152 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.conduits;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+
+import org.xnio.IoUtils;
+import org.xnio.channels.StreamSourceChannel;
+import org.xnio.conduits.AbstractStreamSinkConduit;
+import org.xnio.conduits.ConduitWritableByteChannel;
+import org.xnio.conduits.StreamSinkConduit;
+import io.undertow.UndertowMessages;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.AttachmentKey;
+
+/**
+ * @author Stuart Douglas
+ */
+public final class StoredResponseStreamSinkConduit extends AbstractStreamSinkConduit<StreamSinkConduit> {
+
+    public static final AttachmentKey<byte[]> RESPONSE = AttachmentKey.create(byte[].class);
+    private ByteArrayOutputStream outputStream;
+    private final HttpServerExchange exchange;
+
+    /**
+     * Construct a new instance.
+     *
+     * @param next     the delegate conduit to set
+     * @param exchange
+     */
+    public StoredResponseStreamSinkConduit(StreamSinkConduit next, HttpServerExchange exchange) {
+        super(next);
+        this.exchange = exchange;
+        long length = exchange.getResponseContentLength();
+        if (length > 0) {
+            outputStream = new ByteArrayOutputStream();
+        } else {
+            if (length > Integer.MAX_VALUE) {
+                throw UndertowMessages.MESSAGES.responseTooLargeToBuffer(length);
+            }
+            outputStream = new ByteArrayOutputStream((int) length);
+        }
+    }
+
+    @Override
+    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {
+        return IoUtils.transfer(source, count, throughBuffer, new ConduitWritableByteChannel(this));
+    }
+
+    @Override
+    public long transferFrom(FileChannel src, long position, long count) throws IOException {
+        return src.transferTo(position, count, new ConduitWritableByteChannel(this));
+    }
+
+    @Override
+    public int write(ByteBuffer src) throws IOException {
+        int start = src.position();
+        int ret = super.write(src);
+        for (int i = start; i < start + ret; ++i) {
+            outputStream.write(src.get(i));
+        }
+        return ret;
+    }
+
+    @Override
+    public long write(ByteBuffer[] srcs, int offs, int len) throws IOException {
+        int[] starts = new int[len];
+        for (int i = 0; i < len; ++i) {
+            starts[i] = srcs[i + offs].position();
+        }
+        long ret = super.write(srcs, offs, len);
+        long rem = ret;
+
+        for (int i = 0; i < len; ++i) {
+            ByteBuffer buf = srcs[i + offs];
+            int pos = starts[i];
+            while (rem > 0 && pos <= buf.position()) {
+                outputStream.write(buf.get(pos));
+                pos++;
+                rem--;
+            }
+        }
+        return ret;
+    }
+
+    @Override
+    public int writeFinal(ByteBuffer src) throws IOException {
+        int start = src.position();
+        int ret = super.writeFinal(src);
+        for (int i = start; i < start + ret; ++i) {
+            outputStream.write(src.get(i));
+        }
+        if (!src.hasRemaining()) {
+            exchange.putAttachment(RESPONSE, outputStream.toByteArray());
+            outputStream = null;
+        }
+        return ret;
+    }
+
+    @Override
+    public long writeFinal(ByteBuffer[] srcs, int offs, int len) throws IOException {
+        int[] starts = new int[len];
+        long toWrite = 0;
+        for (int i = 0; i < len; ++i) {
+            starts[i] = srcs[i + offs].position();
+            toWrite += srcs[i + offs].remaining();
+        }
+        long ret = super.write(srcs, offs, len);
+        long rem = ret;
+
+        for (int i = 0; i < len; ++i) {
+            ByteBuffer buf = srcs[i + offs];
+            int pos = starts[i];
+            while (rem > 0 && pos <= buf.position()) {
+                outputStream.write(buf.get(pos));
+                pos++;
+                rem--;
+            }
+        }
+        if (toWrite == ret) {
+            exchange.putAttachment(RESPONSE, outputStream.toByteArray());
+            outputStream = null;
+        }
+        return ret;
+    }
+
+    @Override
+    public void terminateWrites() throws IOException {
+        exchange.putAttachment(RESPONSE, outputStream.toByteArray());
+        outputStream = null;
+        super.terminateWrites();
+    }
+}",2017-01-02T21:28:19Z,181
"@@ -0,0 +1,95 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+
+import org.xnio.conduits.StreamSinkConduit;
+import io.undertow.conduits.StoredResponseStreamSinkConduit;
+import io.undertow.server.ConduitWrapper;
+import io.undertow.server.HandlerWrapper;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.builder.HandlerBuilder;
+import io.undertow.util.ConduitFactory;
+
+/**
+ * A handler that buffers the full response and attaches it to the exchange. This makes use of
+ * {@link StoredResponseStreamSinkConduit}
+ * <p>
+ * This will be made available once the response is fully complete, so should generally
+ * be read in an {@link io.undertow.server.ExchangeCompletionListener}
+ *
+ * @author Stuart Douglas
+ */
+public class StoredResponseHandler implements HttpHandler {
+
+    private final HttpHandler next;
+
+    public StoredResponseHandler(HttpHandler next) {
+        this.next = next;
+    }
+
+    @Override
+    public void handleRequest(HttpServerExchange exchange) throws Exception {
+        exchange.addResponseWrapper(new ConduitWrapper<StreamSinkConduit>() {
+            @Override
+            public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpServerExchange exchange) {
+                return new StoredResponseStreamSinkConduit(factory.create(), exchange);
+            }
+        });
+        next.handleRequest(exchange);
+    }
+
+    public static class Builder implements HandlerBuilder {
+
+        @Override
+        public String name() {
+            return ""store-response"";
+        }
+
+        @Override
+        public Map<String, Class<?>> parameters() {
+            return Collections.emptyMap();
+        }
+
+        @Override
+        public Set<String> requiredParameters() {
+            return Collections.emptySet();
+        }
+
+        @Override
+        public String defaultParameter() {
+            return null;
+        }
+
+        @Override
+        public HandlerWrapper build(Map<String, Object> config) {
+            return new HandlerWrapper() {
+                @Override
+                public HttpHandler wrap(HttpHandler handler) {
+                    return new StoredResponseHandler(handler);
+                }
+            };
+        }
+    }
+
+}",2017-01-02T21:28:19Z,182
"@@ -33,3 +33,4 @@ io.undertow.attribute.RemoteHostAttribute$Builder
 io.undertow.attribute.RequestPathAttribute$Builder
 io.undertow.attribute.ResolvedPathAttribute$Builder
 io.undertow.attribute.NullAttribute$Builder
+io.undertow.attribute.StoredResponse$Builder",2017-01-02T21:28:19Z,183
"@@ -35,3 +35,4 @@ io.undertow.server.handlers.StuckThreadDetectionHandler$Builder
 io.undertow.server.handlers.AccessControlListHandler$Builder
 io.undertow.server.handlers.JDBCLogHandler$Builder
 io.undertow.server.handlers.LocalNameResolvingHandler$Builder
+io.undertow.server.handlers.StoredResponseHandler$Builder",2017-01-02T21:28:19Z,175
"@@ -20,6 +20,7 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.StoredResponseHandler;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
@@ -28,6 +29,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
+import io.undertow.util.Headers;
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
@@ -59,23 +61,24 @@ public void logMessage(final String msg) {
     private static final HttpHandler HELLO_HANDLER = new HttpHandler() {
         @Override
         public void handleRequest(final HttpServerExchange exchange) throws Exception {
-            exchange.getResponseSender().send(""Hello"");
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""text/plain"");
+            exchange.getResponseSender().send(""HelloResponse"");
         }
     };
 
     @Test
     public void testRemoteAddress() throws IOException, InterruptedException {
         latch = new CountDownLatch(1);
-        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, RECEIVER, ""Remote address %a Code %s test-header %{i,test-header}"", AccessLogFileTestCase.class.getClassLoader()));
+        DefaultServer.setRootHandler(new StoredResponseHandler(new AccessLogHandler(HELLO_HANDLER, RECEIVER, ""Remote address %a Code %s test-header %{i,test-header} %{STORED_RESPONSE}"", AccessLogFileTestCase.class.getClassLoader())));
         TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
             get.addHeader(""test-header"", ""test-value"");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-            Assert.assertEquals(""Hello"", HttpClientUtils.readResponse(result));
+            Assert.assertEquals(""HelloResponse"", HttpClientUtils.readResponse(result));
             latch.await(10, TimeUnit.SECONDS);
-            Assert.assertEquals(""Remote address "" + DefaultServer.getDefaultServerAddress().getAddress().getHostAddress() + "" Code 200 test-header test-value"", message);
+            Assert.assertEquals(""Remote address "" + DefaultServer.getDefaultServerAddress().getAddress().getHostAddress() + "" Code 200 test-header test-value HelloResponse"", message);
         } finally {
             client.getConnectionManager().shutdown();
         }",2017-01-02T21:28:19Z,184
"@@ -55,8 +55,8 @@ public class ManagedServlet implements Lifecycle {
     private final InstanceStrategy instanceStrategy;
     private volatile boolean permanentlyUnavailable = false;
 
-    private final long maxRequestSize;
-    private final FormParserFactory formParserFactory;
+    private long maxRequestSize;
+    private FormParserFactory formParserFactory;
 
     public ManagedServlet(final ServletInfo servletInfo, final ServletContextImpl servletContext) {
         this.servletInfo = servletInfo;
@@ -66,6 +66,10 @@ public ManagedServlet(final ServletInfo servletInfo, final ServletContextImpl se
         } else {
             instanceStrategy = new DefaultInstanceStrategy(servletInfo.getInstanceFactory(), servletInfo, servletContext);
         }
+        setupMultipart(servletContext);
+    }
+
+    public void setupMultipart(ServletContextImpl servletContext) {
         FormEncodedDataDefinition formDataParser = new FormEncodedDataDefinition()
                 .setDefaultEncoding(servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding());
         if (servletInfo.getMultipartConfig() != null) {
@@ -76,7 +80,7 @@ public ManagedServlet(final ServletInfo servletInfo, final ServletContextImpl se
             } else {
                 maxRequestSize = -1;
             }
-            final  File tempDir;
+            final File tempDir;
             if(config.getLocation() == null || config.getLocation().isEmpty()) {
                 tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDir();
             } else {",2014-07-05T13:45:37Z,113
"@@ -43,7 +43,9 @@
 import io.undertow.servlet.api.TransportGuaranteeType;
 import io.undertow.servlet.core.ApplicationListeners;
 import io.undertow.servlet.core.ManagedListener;
+import io.undertow.servlet.core.ManagedServlet;
 import io.undertow.servlet.handlers.ServletChain;
+import io.undertow.servlet.handlers.ServletHandler;
 import io.undertow.servlet.util.EmptyEnumeration;
 import io.undertow.servlet.util.ImmediateInstanceFactory;
 import io.undertow.servlet.util.IteratorEnumeration;
@@ -408,8 +410,8 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final St
             ServletInfo servlet = new ServletInfo(servletName, (Class<? extends Servlet>) deploymentInfo.getClassLoader().loadClass(className));
             readServletAnnotations(servlet);
             deploymentInfo.addServlet(servlet);
-            deployment.getServlets().addServlet(servlet);
-            return new ServletRegistrationImpl(servlet, deployment);
+            ServletHandler handler = deployment.getServlets().addServlet(servlet);
+            return new ServletRegistrationImpl(servlet, handler.getManagedServlet(), deployment);
         } catch (ClassNotFoundException e) {
             throw UndertowServletMessages.MESSAGES.cannotLoadClass(className, e);
         }
@@ -425,8 +427,8 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final Se
         ServletInfo s = new ServletInfo(servletName, servlet.getClass(), new ImmediateInstanceFactory<>(servlet));
         readServletAnnotations(s);
         deploymentInfo.addServlet(s);
-        deployment.getServlets().addServlet(s);
-        return new ServletRegistrationImpl(s, deployment);
+        ServletHandler handler = deployment.getServlets().addServlet(s);
+        return new ServletRegistrationImpl(s, handler.getManagedServlet(), deployment);
     }
 
     @Override
@@ -439,8 +441,8 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final Cl
         ServletInfo servlet = new ServletInfo(servletName, servletClass);
         readServletAnnotations(servlet);
         deploymentInfo.addServlet(servlet);
-        deployment.getServlets().addServlet(servlet);
-        return new ServletRegistrationImpl(servlet, deployment);
+        ServletHandler handler = deployment.getServlets().addServlet(servlet);
+        return new ServletRegistrationImpl(servlet, handler.getManagedServlet(), deployment);
     }
 
 
@@ -457,19 +459,19 @@ public <T extends Servlet> T createServlet(final Class<T> clazz) throws ServletE
     @Override
     public ServletRegistration getServletRegistration(final String servletName) {
         ensureNotProgramaticListener();
-        final ServletInfo servlet = deploymentInfo.getServlets().get(servletName);
+        final ManagedServlet servlet = deployment.getServlets().getManagedServlet(servletName);
         if (servlet == null) {
             return null;
         }
-        return new ServletRegistrationImpl(servlet, deployment);
+        return new ServletRegistrationImpl(servlet.getServletInfo(), servlet, deployment);
     }
 
     @Override
     public Map<String, ? extends ServletRegistration> getServletRegistrations() {
         ensureNotProgramaticListener();
         final Map<String, ServletRegistration> ret = new HashMap<>();
-        for (Map.Entry<String, ServletInfo> entry : deploymentInfo.getServlets().entrySet()) {
-            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue(), deployment));
+        for (Map.Entry<String, ServletHandler> entry : deployment.getServlets().getServletHandlers().entrySet()) {
+            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue().getManagedServlet().getServletInfo(), entry.getValue().getManagedServlet(), deployment));
         }
         return ret;
     }",2014-07-05T13:45:37Z,146
"@@ -40,6 +40,7 @@
 import io.undertow.servlet.api.ServletSecurityInfo;
 import io.undertow.servlet.api.TransportGuaranteeType;
 import io.undertow.servlet.api.WebResourceCollection;
+import io.undertow.servlet.core.ManagedServlet;
 
 import static javax.servlet.annotation.ServletSecurity.TransportGuarantee.CONFIDENTIAL;
 
@@ -49,10 +50,12 @@
 public class ServletRegistrationImpl implements ServletRegistration, ServletRegistration.Dynamic {
 
     private final ServletInfo servletInfo;
+    private final ManagedServlet managedServlet;
     private final Deployment deployment;
 
-    public ServletRegistrationImpl(final ServletInfo servletInfo, final Deployment deployment) {
+    public ServletRegistrationImpl(final ServletInfo servletInfo, ManagedServlet managedServlet, final Deployment deployment) {
         this.servletInfo = servletInfo;
+        this.managedServlet = managedServlet;
         this.deployment = deployment;
     }
 
@@ -111,6 +114,7 @@ private SecurityInfo.EmptyRoleSemantic emptyRoleSemantic(final ServletSecurity.E
     @Override
     public void setMultipartConfig(final MultipartConfigElement multipartConfig) {
         servletInfo.setMultipartConfig(multipartConfig);
+        managedServlet.setupMultipart(deployment.getServletContext());
     }
 
     @Override",2014-07-05T13:45:37Z,294
"@@ -0,0 +1,22 @@
+package io.undertow.servlet.test.multipart;
+
+import javax.servlet.MultipartConfigElement;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletRegistration;
+
+/**
+ * @author Stuart Douglas
+ */
+public class AddMultipartServetListener implements ServletContextListener {
+    @Override
+    public void contextInitialized(ServletContextEvent sce) {
+        ServletRegistration.Dynamic reg = sce.getServletContext().addServlet(""added"", new MultiPartServlet());
+        reg.addMapping(""/added"");
+        reg.setMultipartConfig(new MultipartConfigElement(System.getProperty(""java.io.tmpdir"")));
+    }
+
+    @Override
+    public void contextDestroyed(ServletContextEvent sce) {
+    }
+}",2014-07-05T13:45:37Z,295
"@@ -22,8 +22,12 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 
+import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 
+import io.undertow.servlet.ServletExtension;
+import io.undertow.servlet.Servlets;
+import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
@@ -51,7 +55,12 @@ public class MultiPartTestCase {
 
     @BeforeClass
     public static void setup() throws ServletException {
-        DeploymentUtils.setupServlet(
+        DeploymentUtils.setupServlet(new ServletExtension() {
+            @Override
+            public void handleDeployment(DeploymentInfo deploymentInfo, ServletContext servletContext) {
+                deploymentInfo.addListener(Servlets.listener(AddMultipartServetListener.class));
+            }
+        },
                 servlet(""mp0"", MultiPartServlet.class)
                         .addMapping(""/0""),
                 servlet(""mp1"", MultiPartServlet.class)
@@ -120,6 +129,41 @@ public void testMultiPartRequest() throws IOException {
         }
     }
 
+
+    @Test
+    public void testMultiPartRequestWithAddedServlet() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            String uri = DefaultServer.getDefaultServerURL() + ""/servletContext/added"";
+            HttpPost post = new HttpPost(uri);
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", Charset.forName(""UTF-8"")));
+            entity.addPart(""file"", new FileBody(new File(MultiPartTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""PARAMS:\n"" +
+                    ""name: formValue\n"" +
+                    ""filename: null\n"" +
+                    ""content-type: null\n"" +
+                    ""Content-Disposition: form-data; name=\""formValue\""\n"" +
+                    ""size: 7\n"" +
+                    ""content: myValue\n"" +
+                    ""name: file\n"" +
+                    ""filename: uploadfile.txt\n"" +
+                    ""content-type: application/octet-stream\n"" +
+                    ""Content-Disposition: form-data; name=\""file\""; filename=\""uploadfile.txt\""\n"" +
+                    ""Content-Type: application/octet-stream\n"" +
+                    ""size: 13\n"" +
+                    ""content: file contents\n"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
     @Test
     public void testMultiPartRequestToLarge() throws IOException {
         TestHttpClient client = new TestHttpClient();",2014-07-05T13:45:37Z,296
"@@ -126,11 +126,15 @@ public void forward(final ServletRequest request, final ServletResponse response
                     requestImpl.setAttribute(FORWARD_QUERY_STRING, requestImpl.getQueryString());
                 }
 
-                String newQueryString = """";
+                String newQueryString = requestImpl.getQueryString() == null ? """" : requestImpl.getQueryString();
                 int qsPos = path.indexOf(""?"");
                 String newServletPath = path;
                 if (qsPos != -1) {
-                    newQueryString = newServletPath.substring(qsPos + 1);
+                    if(newQueryString.isEmpty()) {
+                        newQueryString = newServletPath.substring(qsPos + 1);
+                    } else {
+                        newQueryString = newQueryString + ""&"" + newServletPath.substring(qsPos + 1);
+                    }
                     newServletPath = newServletPath.substring(0, qsPos);
                 }
                 String newRequestUri = servletContext.getContextPath() + newServletPath;
@@ -241,11 +245,15 @@ public void include(final ServletRequest request, final ServletResponse response
                 pathInfo = request.getAttribute(INCLUDE_PATH_INFO);
                 queryString = request.getAttribute(INCLUDE_QUERY_STRING);
 
-                String newQueryString = """";
+                String newQueryString = requestImpl.getQueryString() == null ? """" : requestImpl.getQueryString();
                 int qsPos = path.indexOf(""?"");
                 String newServletPath = path;
                 if (qsPos != -1) {
-                    newQueryString = newServletPath.substring(qsPos + 1);
+                    if(newQueryString.isEmpty()) {
+                        newQueryString = newServletPath.substring(qsPos + 1);
+                    } else {
+                        newQueryString = newQueryString + ""&"" + newServletPath.substring(qsPos + 1);
+                    }
                     newServletPath = newServletPath.substring(0, qsPos);
                 }
                 String newRequestUri = servletContext.getContextPath() + newServletPath;",2013-10-11T08:01:26Z,171
"@@ -17,6 +17,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.path.ServletPathMappingTestCase;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.MessageFilter;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.testutils.DefaultServer;
@@ -60,7 +61,7 @@ public static void setup() throws ServletException {
                 .setDeploymentName(""servletContext.war"")
                 .setResourceManager(new CachingResourceManager(100, 10000, new DirectBufferCache(1000, 10, 1000 * 10 * 1000, BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, METADATA_MAX_AGE), new FileResourceManager(tmpDir, 10485760), METADATA_MAX_AGE));
 
-        builder.addServlet(new ServletInfo(""DefaultTestServlet"", DefaultTestServlet.class)
+        builder.addServlet(new ServletInfo(""DefaultTestServlet"", PathTestServlet.class)
                 .addMapping(""/path/default""))
                 .addFilter(Servlets.filter(""message"", MessageFilter.class).addInitParam(MessageFilter.MESSAGE, ""FILTER_TEXT ""))
                 .addFilterUrlMapping(""message"", ""*.txt"", DispatcherType.REQUEST);",2013-10-11T08:01:26Z,297
"@@ -12,6 +12,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.path.ServletPathMappingTestCase;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.testutils.DefaultServer;
@@ -44,7 +45,7 @@ public static void setup() throws ServletException {
                 .setDeploymentName(""servletContext.war"")
                 .setResourceManager(new TestResourceLoader(DefaultServletTestCase.class));
 
-        builder.addServlet(new ServletInfo(""DefaultTestServlet"", DefaultTestServlet.class)
+        builder.addServlet(new ServletInfo(""DefaultTestServlet"", PathTestServlet.class)
                 .addMapping(""/path/default""));
 
         builder.addFilter(new FilterInfo(""Filter"", HelloFilter.class));",2013-10-11T08:01:26Z,298
"@@ -28,6 +28,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.path.ServletPathMappingTestCase;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.testutils.DefaultServer;
@@ -61,7 +62,7 @@ public static void setup() throws ServletException {
                 .setResourceManager(new TestResourceLoader(ServletAndResourceWelcomeFileTestCase.class))
                 .addWelcomePages(""doesnotexist.html"", ""index.html"", ""default"");
 
-        builder.addServlet(new ServletInfo(""DefaultTestServlet"", DefaultTestServlet.class)
+        builder.addServlet(new ServletInfo(""DefaultTestServlet"", PathTestServlet.class)
                 .addMapping(""*.html""));
 
         DeploymentManager manager = container.addDeployment(builder);",2013-10-11T08:01:26Z,299
"@@ -33,6 +33,7 @@
 import io.undertow.servlet.api.WebResourceCollection;
 import io.undertow.servlet.test.path.ServletPathMappingTestCase;
 import io.undertow.servlet.test.security.constraint.ServletIdentityManager;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.testutils.DefaultServer;
@@ -80,7 +81,7 @@ public static void setup() throws ServletException {
                 .setIdentityManager(identityManager)
                 .setLoginConfig(new LoginConfig(""BASIC"", ""Test Realm""))
                 .addServlet(
-                        new ServletInfo(""DefaultTestServlet"", DefaultTestServlet.class)
+                        new ServletInfo(""DefaultTestServlet"", PathTestServlet.class)
                                 .setServletSecurityInfo(
                                         new ServletSecurityInfo()
                                                 .addRoleAllowed(""role1""))",2013-10-11T08:01:26Z,3
"@@ -12,6 +12,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.path.ServletPathMappingTestCase;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.testutils.DefaultServer;
@@ -45,10 +46,10 @@ public static void setup() throws ServletException {
                 .setResourceManager(new TestResourceLoader(WelcomeFileTestCase.class))
                 .addWelcomePages(""doesnotexist.html"", ""index.html"", ""default"", ""servletPath/servletFile.xhtml"");
 
-        builder.addServlet(new ServletInfo(""DefaultTestServlet"", DefaultTestServlet.class)
+        builder.addServlet(new ServletInfo(""DefaultTestServlet"", PathTestServlet.class)
                 .addMapping(""/path/default""));
 
-        builder.addServlet(new ServletInfo(""ServletPath"", DefaultTestServlet.class)
+        builder.addServlet(new ServletInfo(""ServletPath"", PathTestServlet.class)
                 .addMapping(""/foo/servletPath/*""));
 
         builder.addFilter(new FilterInfo(""Filter"", NoOpFilter.class));",2013-10-11T08:01:26Z,300
"@@ -0,0 +1,181 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.servlet.test.dispatcher;
+
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.FilterInfo;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.test.SimpleServletTestCase;
+import io.undertow.servlet.test.util.MessageFilter;
+import io.undertow.servlet.test.util.MessageServlet;
+import io.undertow.servlet.test.util.PathTestServlet;
+import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.servlet.test.util.TestResourceLoader;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletException;
+import java.io.IOException;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class DispatcherForwardTestCase {
+
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+
+        final PathHandler root = new PathHandler();
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+
+        DeploymentInfo builder = new DeploymentInfo()
+                .setClassLoader(SimpleServletTestCase.class.getClassLoader())
+                .setContextPath(""/servletContext"")
+                .setClassIntrospecter(TestClassIntrospector.INSTANCE)
+                .setDeploymentName(""servletContext.war"")
+                .setResourceManager(new TestResourceLoader(DispatcherForwardTestCase.class))
+                .addServlet(
+                        new ServletInfo(""forward"", MessageServlet.class)
+                                .addInitParam(MessageServlet.MESSAGE, ""forwarded"")
+                                .addMapping(""/forward""))
+                .addServlet(
+                        new ServletInfo(""dispatcher"", ForwardServlet.class)
+                                .addMapping(""/dispatch""))
+                .addServlet(
+                        new ServletInfo(""pathTest"", PathTestServlet.class)
+                                .addMapping(""/path""))
+                .addFilter(
+                        new FilterInfo(""notforwarded"", MessageFilter.class)
+                                .addInitParam(MessageFilter.MESSAGE, ""Not forwarded""))
+                .addFilter(
+                        new FilterInfo(""inc"", MessageFilter.class)
+                                .addInitParam(MessageFilter.MESSAGE, ""Path!""))
+                .addFilter(
+                        new FilterInfo(""nameFilter"", MessageFilter.class)
+                                .addInitParam(MessageFilter.MESSAGE, ""Name!""))
+                .addFilterUrlMapping(""notforwarded"", ""/forward"", DispatcherType.REQUEST)
+                .addFilterUrlMapping(""inc"", ""/forward"", DispatcherType.FORWARD)
+                .addFilterServletNameMapping(""nameFilter"", ""forward"", DispatcherType.FORWARD);
+
+
+        DeploymentManager manager = container.addDeployment(builder);
+        manager.deploy();
+        root.addPath(builder.getContextPath(), manager.start());
+
+        DefaultServer.setRootHandler(root);
+    }
+
+    @Test
+    public void testPathBasedInclude() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch"");
+            get.setHeader(""forward"", ""/forward"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""Path!Name!forwarded"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testNameBasedInclude() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch"");
+            get.setHeader(""forward"", ""forward"");
+            get.setHeader(""name"", ""true"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""Name!forwarded"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testPathBasedStaticInclude() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch"");
+            get.setHeader(""forward"", ""/snippet.html"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""SnippetText"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testPathBasedStaticIncludePost() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch"");
+            post.setHeader(""forward"", ""/snippet.html"");
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""SnippetText"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+
+    @Test
+    public void testIncludeAggregatesQueryString() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch?a=b"");
+            get.setHeader(""forward"", ""/path"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""pathInfo:null queryString:a=b servletPath:/path requestUri:/servletContext/path"", response);
+
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch?a=b"");
+            get.setHeader(""forward"", ""/path?foo=bar"");
+            result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(""pathInfo:null queryString:a=b&foo=bar servletPath:/path requestUri:/servletContext/path"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+}",2013-10-11T08:01:26Z,272
"@@ -32,6 +32,7 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.MessageFilter;
 import io.undertow.servlet.test.util.MessageServlet;
+import io.undertow.servlet.test.util.PathTestServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.testutils.DefaultServer;
@@ -72,6 +73,9 @@ public static void setup() throws ServletException {
                 .addServlet(
                         new ServletInfo(""dispatcher"", IncludeServlet.class)
                                 .addMapping(""/dispatch""))
+                .addServlet(
+                        new ServletInfo(""pathTest"", PathTestServlet.class)
+                                .addMapping(""/path""))
                 .addFilter(
                         new FilterInfo(""notIncluded"", MessageFilter.class)
                                 .addInitParam(MessageFilter.MESSAGE, ""Not Included""))
@@ -155,4 +159,25 @@ public void testPathBasedStaticIncludePost() throws IOException {
     }
 
 
+    @Test
+    public void testIncludeAggregatesQueryString() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch?a=b"");
+            get.setHeader(""include"", ""/path"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(IncludeServlet.MESSAGE + ""pathInfo:null queryString:a=b servletPath:/dispatch requestUri:/servletContext/dispatch"", response);
+
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/dispatch?a=b"");
+            get.setHeader(""include"", ""/path?foo=bar"");
+            result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(IncludeServlet.MESSAGE + ""pathInfo:null queryString:a=b servletPath:/dispatch requestUri:/servletContext/dispatch"", response);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
 }",2013-10-11T08:01:26Z,301
"@@ -0,0 +1,52 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.servlet.test.dispatcher;
+
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+/**
+ * @author Stuart Douglas
+ */
+public class ForwardServlet extends HttpServlet {
+
+    public static final String MESSAGE = ""Hello "";
+
+    @Override
+    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+        resp.getWriter().write(MESSAGE); //this should be ignored
+        RequestDispatcher dispatcher;
+        if (req.getHeader(""name"") != null) {
+            dispatcher = req.getServletContext().getNamedDispatcher(req.getHeader(""forward""));
+        } else {
+            dispatcher = req.getRequestDispatcher(req.getHeader(""forward""));
+        }
+        dispatcher.forward(req, resp);
+    }
+
+    @Override
+    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
+        doGet(req, resp);
+    }
+
+}",2013-10-11T08:01:26Z,302
"@@ -1,4 +1,4 @@
-package io.undertow.servlet.test.defaultservlet;
+package io.undertow.servlet.test.util;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -11,7 +11,7 @@
 /**
  * @author Stuart Douglas
  */
-public class DefaultTestServlet extends HttpServlet {
+public class PathTestServlet extends HttpServlet {
 
     @Override
     protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {",2013-10-11T08:01:26Z,303
"@@ -56,6 +56,7 @@
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.AttachmentKey;
+import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.SameThreadExecutor;
 import org.xnio.XnioExecutor;
 
@@ -166,7 +167,7 @@ public void dispatch() {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
-            String toDispatch = requestImpl.getOriginalRequestURI().substring(requestImpl.getOriginalContextPath().length());
+            String toDispatch = CanonicalPathUtils.canonicalize(requestImpl.getOriginalRequestURI()).substring(requestImpl.getOriginalContextPath().length());
             String qs = requestImpl.getOriginalQueryString();
             if (!qs.isEmpty()) {
                 toDispatch = toDispatch + ""?"" + qs;",2013-06-18T04:23:12Z,244
"@@ -218,6 +218,12 @@ public class UndertowOptions {
     public static final Option<Integer> HTTP2_SETTINGS_MAX_FRAME_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_MAX_FRAME_SIZE"", Integer.class);
     public static final Option<Integer> HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE"", Integer.class);
 
+    /**
+     * Undertow keeps a LRU cache of common huffman encodings. This sets the maximum size, setting this to 0 will disable the caching.
+     *
+     */
+    public static final Option<Integer> HTTP2_HUFFMAN_CACHE_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_HUFFMAN_CACHE_SIZE"", Integer.class);
+
     /**
      * The maximum number of concurrent requests that will be processed at a time. This differs from max concurrent streams in that it is not sent to the remote client.
      *",2015-03-19T03:07:42Z,140
"@@ -418,18 +418,39 @@ public static void decode(ByteBuffer data, int length, StringBuilder target) thr
      *
      * @param buffer   The buffer to encode into
      * @param toEncode The string to encode
+     * @param forceLowercase If the string should be encoded in lower case
      * @return true if encoding succeeded
      */
-    public static boolean encode(ByteBuffer buffer, String toEncode) {
+    public static boolean encode(ByteBuffer buffer, String toEncode, boolean forceLowercase) {
         if (buffer.remaining() <= toEncode.length()) {
             return false;
         }
         int start = buffer.position();
-        buffer.put((byte) 0); //we override this later once we have the length
+        //this sucks, but we need to put the length first
+        //and we don't really have any option but to calculate it in advance to make sure we have left enough room
+        //so we end up iterating twice
+        int length = 0;
+        for (int i = 0; i < toEncode.length(); ++i) {
+            byte c = (byte) toEncode.charAt(i);
+            if(forceLowercase) {
+                c = Hpack.toLower(c);
+            }
+            HuffmanCode code = HUFFMAN_CODES[c];
+            length += code.length;
+        }
+        int byteLength = length / 8 + (length % 8 == 0 ? 0 : 1);
+
+        buffer.put((byte) (1 << 7));
+        Hpack.encodeInteger(buffer, byteLength, 7);
+
+
         int bytePos = 0;
         byte currentBufferByte = 0;
         for (int i = 0; i < toEncode.length(); ++i) {
             byte c = (byte) toEncode.charAt(i);
+            if(forceLowercase) {
+                c = Hpack.toLower(c);
+            }
             HuffmanCode code = HUFFMAN_CODES[c];
             if (code.length + bytePos <= 8) {
                 //it fits in the current byte
@@ -484,7 +505,6 @@ public static boolean encode(ByteBuffer buffer, String toEncode) {
             }
             buffer.put((byte) (currentBufferByte | ((0xFF) >> bytePos)));
         }
-        buffer.put(start, (byte) ((1 << 7) | (buffer.position() - start - 1)));
         return true;
     }
 ",2015-03-19T03:07:42Z,165
"@@ -26,9 +26,10 @@
 /**
  * @author Stuart Douglas
  */
-public class Hpack {
+final class Hpack {
 
-    public static final int DEFAULT_TABLE_SIZE = 4096;
+    private static final byte LOWER_DIFF = 'a' - 'A';
+    static final int DEFAULT_TABLE_SIZE = 4096;
     private static final int MAX_INTEGER_OCTETS = 8; //not sure what a good value for this is, but the spec says we need to provide an upper bound
 
     /**
@@ -39,7 +40,7 @@ public class Hpack {
 
 
     static final HeaderField[] STATIC_TABLE;
-    public static final int STATIC_TABLE_LENGTH;
+    static final int STATIC_TABLE_LENGTH;
 
     static {
         PREFIX_TABLE = new int[32];
@@ -146,7 +147,7 @@ static class HeaderField {
      * @param n      The encoding prefix length
      * @return The encoded integer, or -1 if there was not enough data
      */
-    protected static int decodeInteger(ByteBuffer source, int n) throws HpackException {
+    static int decodeInteger(ByteBuffer source, int n) throws HpackException {
         if (source.remaining() == 0) {
             return -1;
         }
@@ -189,7 +190,7 @@ protected static int decodeInteger(ByteBuffer source, int n) throws HpackExcepti
      * @param value  The integer to encode
      * @param n      The encoding prefix length
      */
-    protected static void encodeInteger(ByteBuffer source, int value, int n) {
+    static void encodeInteger(ByteBuffer source, int value, int n) {
         int twoNminus1 = PREFIX_TABLE[n];
         int pos = source.position() - 1;
         if (value < twoNminus1) {
@@ -206,4 +207,13 @@ protected static void encodeInteger(ByteBuffer source, int value, int n) {
     }
 
 
+    static byte toLower(byte b) {
+        if (b >= 'A' && b <= 'Z') {
+            return (byte) (b + LOWER_DIFF);
+        }
+        return b;
+    }
+
+    private Hpack() {}
+
 }",2015-03-19T03:07:42Z,304
"@@ -23,12 +23,14 @@
 import io.undertow.UndertowMessages;
 import io.undertow.util.HttpString;
 
+import static io.undertow.protocols.http2.Hpack.HeaderField;
+
 /**
  * A decoder for HPACK.
  *
  * @author Stuart Douglas
  */
-public class HpackDecoder extends Hpack {
+public class HpackDecoder {
 
     private static final int DEFAULT_RING_BUFFER_SIZE = 10;
 
@@ -72,7 +74,7 @@ public HpackDecoder(int maxMemorySize) {
     }
 
     public HpackDecoder() {
-        this(DEFAULT_TABLE_SIZE);
+        this(Hpack.DEFAULT_TABLE_SIZE);
     }
 
     /**
@@ -89,7 +91,7 @@ public void decode(ByteBuffer buffer) throws HpackException {
             if ((b & 0b10000000) != 0) {
                 //if the first bit is set it is an indexed header field
                 buffer.position(buffer.position() - 1); //unget the byte
-                int index = decodeInteger(buffer, 7); //prefix is 7
+                int index = Hpack.decodeInteger(buffer, 7); //prefix is 7
                 if (index == -1) {
                     buffer.position(originalPos);
                     return;
@@ -150,7 +152,7 @@ public void decode(ByteBuffer buffer) throws HpackException {
 
     private boolean handleMaxMemorySizeChange(ByteBuffer buffer, int originalPos) throws HpackException {
         buffer.position(buffer.position() - 1); //unget the byte
-        int size = decodeInteger(buffer, 5);
+        int size = Hpack.decodeInteger(buffer, 5);
         if (size == -1) {
             buffer.position(originalPos);
             return false;
@@ -179,7 +181,7 @@ private boolean handleMaxMemorySizeChange(ByteBuffer buffer, int originalPos) th
 
     private HttpString readHeaderName(ByteBuffer buffer, int prefixLength) throws HpackException {
         buffer.position(buffer.position() - 1); //unget the byte
-        int index = decodeInteger(buffer, prefixLength);
+        int index = Hpack.decodeInteger(buffer, prefixLength);
         if (index == -1) {
             return null;
         } else if (index != 0) {
@@ -199,7 +201,7 @@ private String readHpackString(ByteBuffer buffer) throws HpackException {
         }
         byte data = buffer.get(buffer.position());
 
-        int length = decodeInteger(buffer, 7);
+        int length = Hpack.decodeInteger(buffer, 7);
         if (buffer.remaining() < length) {
             return null;
         }
@@ -223,13 +225,13 @@ private String readHuffmanString(int length, ByteBuffer buffer) throws HpackExce
     }
 
     private HttpString handleIndexedHeaderName(int index) throws HpackException {
-        if (index <= STATIC_TABLE_LENGTH) {
-            return STATIC_TABLE[index].name;
+        if (index <= Hpack.STATIC_TABLE_LENGTH) {
+            return Hpack.STATIC_TABLE[index].name;
         } else {
-            if (index >= STATIC_TABLE_LENGTH + filledTableSlots) {
+            if (index >= Hpack.STATIC_TABLE_LENGTH + filledTableSlots) {
                 throw new HpackException();
             }
-            int adjustedIndex = getRealIndex(index - STATIC_TABLE_LENGTH);
+            int adjustedIndex = getRealIndex(index - Hpack.STATIC_TABLE_LENGTH);
             HeaderField res = headerTable[adjustedIndex];
             if (res == null) {
                 throw new HpackException();
@@ -245,10 +247,10 @@ private HttpString handleIndexedHeaderName(int index) throws HpackException {
      * @throws HpackException
      */
     private void handleIndex(int index) throws HpackException {
-        if (index <= STATIC_TABLE_LENGTH) {
+        if (index <= Hpack.STATIC_TABLE_LENGTH) {
             addStaticTableEntry(index);
         } else {
-            int adjustedIndex = getRealIndex(index - STATIC_TABLE_LENGTH);
+            int adjustedIndex = getRealIndex(index - Hpack.STATIC_TABLE_LENGTH);
             HeaderField headerField = headerTable[adjustedIndex];
             headerEmitter.emitHeader(headerField.name, headerField.value, false);
         }
@@ -273,7 +275,7 @@ int getRealIndex(int index) {
     private void addStaticTableEntry(int index) throws HpackException {
         //adds an entry from the static table.
         //this must be an entry with a value as far as I can determine
-        HeaderField entry = STATIC_TABLE[index];
+        HeaderField entry = Hpack.STATIC_TABLE[index];
         if (entry.value == null) {
             throw new HpackException();
         }",2015-03-19T03:07:42Z,137
"@@ -32,22 +32,37 @@
 import java.util.List;
 import java.util.Map;
 
+import static io.undertow.protocols.http2.Hpack.HeaderField;
+import static io.undertow.protocols.http2.Hpack.STATIC_TABLE;
+import static io.undertow.protocols.http2.Hpack.STATIC_TABLE_LENGTH;
+import static io.undertow.protocols.http2.Hpack.encodeInteger;
+
 /**
  * Encoder for HPACK frames.
  *
  * @author Stuart Douglas
  */
-public class HpackEncoder extends Hpack {
-
-    private static final byte LOWER_DIFF = 'a' - 'A';
+public class HpackEncoder {
 
-    public static final IndexFunction DEFAULT_INDEX_FUNCTION = new IndexFunction() {
+    public static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {
         @Override
         public boolean shouldUseIndexing(HttpString headerName, String value) {
             //content length and date change all the time
             //no need to index them, or they will churn the table
             return !headerName.equals(Headers.CONTENT_LENGTH) && !headerName.equals(Headers.DATE);
         }
+
+        @Override
+        public boolean shouldUseHuffman(HttpString header, String value) {
+            return value.length() > 10; //TODO: figure out a good value for this
+        }
+
+        @Override
+        public boolean shouldUseHuffman(HttpString header) {
+            return header.length() > 10; //TODO: figure out a good value for this
+        }
+
+
     };
 
     private long headersIterator = -1;
@@ -92,10 +107,15 @@ public boolean shouldUseIndexing(HttpString headerName, String value) {
      */
     private int currentTableSize;
 
-    private final IndexFunction indexFunction = DEFAULT_INDEX_FUNCTION;
+    private final HpackHeaderFunction hpackHeaderFunction;
 
-    public HpackEncoder(int maxTableSize) {
+    public HpackEncoder(int maxTableSize, HpackHeaderFunction headerFunction) {
         this.maxTableSize = maxTableSize;
+        this.hpackHeaderFunction = headerFunction;
+    }
+
+    public HpackEncoder(int maxTableSize) {
+        this(maxTableSize, DEFAULT_HEADER_FUNCTION);
     }
 
     /**
@@ -143,37 +163,18 @@ public State encode(HeaderMap headers, ByteBuffer target) {
                         this.headersIterator = it;
                         return State.UNDERFLOW;
                     }
-                    boolean canIndex = indexFunction.shouldUseIndexing(headerName, val) && (headerName.length() + val.length() + 32) < maxTableSize; //only index if it will fit
+                    boolean canIndex = hpackHeaderFunction.shouldUseIndexing(headerName, val) && (headerName.length() + val.length() + 32) < maxTableSize; //only index if it will fit
                     if (tableEntry == null && canIndex) {
                         //add the entry to the dynamic table
                         target.put((byte) (1 << 6));
-                        target.put((byte) 0);
-                        encodeInteger(target, headerName.length(), 7);
-                        for (int j = 0; j < headerName.length(); ++j) {
-                            target.put(toLower(headerName.byteAt(j)));
-                        }
-
-                        target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
-                        encodeInteger(target, val.length(), 7);
-                        for (int j = 0; j < val.length(); ++j) {
-                            target.put((byte) val.charAt(j));
-                        }
+                        writeHuffmanEncodableName(target, headerName);
+                        writeHuffmanEncodableValue(target, headerName, val);
                         addToDynamicTable(headerName, val);
                     } else if (tableEntry == null) {
                         //literal never indexed
                         target.put((byte) (1 << 4));
-                        target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
-                        encodeInteger(target, headerName.length(), 7);
-                        for (int j = 0; j < headerName.length(); ++j) {
-                            target.put(toLower(headerName.byteAt(j)));
-                        }
-
-                        target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
-                        encodeInteger(target, val.length(), 7);
-                        for (int j = 0; j < val.length(); ++j) {
-                            target.put((byte) val.charAt(j));
-                        }
-
+                        writeHuffmanEncodableName(target, headerName);
+                        writeHuffmanEncodableValue(target, headerName, val);
                     } else {
                         //so we know something is already in the table
                         if (val.equals(tableEntry.value)) {
@@ -185,23 +186,13 @@ public State encode(HeaderMap headers, ByteBuffer target) {
                                 //add the entry to the dynamic table
                                 target.put((byte) (1 << 6));
                                 encodeInteger(target, tableEntry.getPosition(), 6);
-
-                                target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
-                                encodeInteger(target, val.length(), 7);
-                                for (int j = 0; j < val.length(); ++j) {
-                                    target.put((byte) val.charAt(j));
-                                }
+                                writeHuffmanEncodableValue(target, headerName, val);
                                 addToDynamicTable(headerName, val);
 
                             } else {
                                 target.put((byte) (1 << 4));
                                 encodeInteger(target, tableEntry.getPosition(), 4);
-
-                                target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
-                                encodeInteger(target, val.length(), 7);
-                                for (int j = 0; j < val.length(); ++j) {
-                                    target.put((byte) val.charAt(j));
-                                }
+                                writeHuffmanEncodableValue(target, headerName, val);
                             }
                         }
                     }
@@ -219,18 +210,43 @@ public State encode(HeaderMap headers, ByteBuffer target) {
         return State.COMPLETE;
     }
 
-    private byte toLower(byte b) {
-        if(b >= 'A' && b <= 'Z') {
-            return (byte) (b + LOWER_DIFF);
+    private void writeHuffmanEncodableName(ByteBuffer target, HttpString headerName) {
+        if (hpackHeaderFunction.shouldUseHuffman(headerName)) {
+            if(HPackHuffman.encode(target, headerName.toString(), true)) {
+                return;
+            }
+        }
+        target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
+        encodeInteger(target, headerName.length(), 7);
+        for (int j = 0; j < headerName.length(); ++j) {
+            target.put(Hpack.toLower(headerName.byteAt(j)));
+        }
+
+    }
+
+    private void writeHuffmanEncodableValue(ByteBuffer target, HttpString headerName, String val) {
+        if (hpackHeaderFunction.shouldUseHuffman(headerName, val)) {
+            if (!HPackHuffman.encode(target, val, false)) {
+                writeValueString(target, val);
+            }
+        } else {
+            writeValueString(target, val);
+        }
+    }
+
+    private void writeValueString(ByteBuffer target, String val) {
+        target.put((byte) 0); //to use encodeInteger we need to place the first byte in the buffer.
+        encodeInteger(target, val.length(), 7);
+        for (int j = 0; j < val.length(); ++j) {
+            target.put((byte) val.charAt(j));
         }
-        return b;
     }
 
     private void addToDynamicTable(HttpString headerName, String val) {
         int pos = entryPositionCounter++;
         DynamicTableEntry d = new DynamicTableEntry(headerName, val, -pos);
         List<TableEntry> existing = dynamicTable.get(headerName);
-        if(existing == null) {
+        if (existing == null) {
             dynamicTable.put(headerName, existing = new ArrayList<TableEntry>(1));
         }
         existing.add(d);
@@ -260,13 +276,13 @@ private void runEvictionIfRequired() {
 
         while (currentTableSize > maxTableSize) {
             TableEntry next = evictionQueue.poll();
-            if(next == null) {
+            if (next == null) {
                 return;
             }
             currentTableSize -= next.size;
             List<TableEntry> list = dynamicTable.get(next.name);
             list.remove(next);
-            if(list.isEmpty()) {
+            if (list.isEmpty()) {
                 dynamicTable.remove(next.name);
             }
         }
@@ -297,22 +313,22 @@ private TableEntry findInTable(HttpString headerName, String value) {
 
     public void setMaxTableSize(int newSize) {
         this.newMaxHeaderSize = newSize;
-        if(minNewMaxHeaderSize == -1) {
-           minNewMaxHeaderSize = newSize;
+        if (minNewMaxHeaderSize == -1) {
+            minNewMaxHeaderSize = newSize;
         } else {
             minNewMaxHeaderSize = Math.min(newSize, minNewMaxHeaderSize);
         }
     }
 
     private void handleTableSizeChange(ByteBuffer target) {
-        if(newMaxHeaderSize == -1) {
+        if (newMaxHeaderSize == -1) {
             return;
         }
-        if(minNewMaxHeaderSize != newMaxHeaderSize) {
-            target.put((byte)(1 << 5));
+        if (minNewMaxHeaderSize != newMaxHeaderSize) {
+            target.put((byte) (1 << 5));
             encodeInteger(target, minNewMaxHeaderSize, 5);
         }
-        target.put((byte)(1 << 5));
+        target.put((byte) (1 << 5));
         encodeInteger(target, newMaxHeaderSize, 5);
         maxTableSize = newMaxHeaderSize;
         runEvictionIfRequired();
@@ -360,7 +376,24 @@ public int getPosition() {
         }
     }
 
-    public interface IndexFunction {
+    public interface HpackHeaderFunction {
         boolean shouldUseIndexing(HttpString header, String value);
+
+        /**
+         * Returns true if huffman encoding should be used on the header value
+         *
+         * @param header The header name
+         * @param value  The header value to be encoded
+         * @return <code>true</code> if the value should be encoded
+         */
+        boolean shouldUseHuffman(HttpString header, String value);
+
+        /**
+         * Returns true if huffman encoding should be used on the header name
+         *
+         * @param header The header name to be encoded
+         * @return <code>true</code> if the value should be encoded
+         */
+        boolean shouldUseHuffman(HttpString header);
     }
 }",2015-03-19T03:07:42Z,138
"@@ -34,22 +34,30 @@ public void testHuffmanEncoding() throws HpackException {
         runTest(""Hello World"", ByteBuffer.allocate(3), false);
         runTest(""\\randomSpecialsChars~\u001D"", ByteBuffer.allocate(100), true);
         runTest(""\\~\u001D"", ByteBuffer.allocate(100), false); //encoded form is larger than the original string
-
     }
 
 
+    @Test
+    public void testHuffmanEncodingLargeString() throws HpackException {
+        StringBuilder sb = new StringBuilder();
+        for(int i = 0; i < 100; ++i) {
+            sb.append(""Hello World"");
+        }
+        runTest(sb.toString(), ByteBuffer.allocate(10000), true); //encoded form is larger than the original string
+    }
+
     void runTest(String string, ByteBuffer buffer, boolean bufferBigEnough) throws HpackException {
-        boolean res = HPackHuffman.encode(buffer, string);
+        boolean res = HPackHuffman.encode(buffer, string, false);
         if(!bufferBigEnough) {
             Assert.assertFalse(res);
             return;
         }
         Assert.assertTrue(res);
         buffer.flip();
-        int length = buffer.get() & 0xff;
-        Assert.assertTrue(((1 << 7) & length) != 0);
+        Assert.assertTrue(((1 << 7) & buffer.get(0)) != 0); //make sure the huffman bit is set
+        int length = Hpack.decodeInteger(buffer, 7);
         StringBuilder sb = new StringBuilder();
-        HPackHuffman.decode(buffer, length & ~(1<<7), sb);
+        HPackHuffman.decode(buffer, length, sb);
         Assert.assertEquals(string, sb.toString());
     }
 }",2015-03-19T03:07:42Z,305
"@@ -39,7 +39,7 @@ public void testExample_D_2_1() throws HpackException {
                 0x40, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x2d,
                 0x6b, 0x65, 0x79, 0x0d, 0x63, 0x75, 0x73,
                 0x74, 0x6f, 0x6d, 0x2d, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));
@@ -54,7 +54,7 @@ public void testExample_D_2_1() throws HpackException {
     public void testExample_D_2_2() throws HpackException {
         //:path: /sample/path
         byte[] data = {0x04, 0x0c, 0x2f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2f, 0x70, 0x61, 0x74, 0x68};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));
@@ -68,7 +68,7 @@ public void testExample_D_2_2() throws HpackException {
     public void testExample_D_2_3() throws HpackException {
         //password: secret
         byte[] data = {0x10, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x06, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));
@@ -82,7 +82,7 @@ public void testExample_D_2_3() throws HpackException {
     public void testExample_D_2_4() throws HpackException {
         //:method: GET
         byte[] data = {(byte) 0x82};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));
@@ -96,7 +96,7 @@ public void testExample_D_2_4() throws HpackException {
     public void testExample_D_3() throws HpackException {
         //d 3.1
         byte[] data = {(byte) 0x82, (byte) 0x86, (byte) 0x84, 0x41, 0x0f, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));
@@ -151,7 +151,7 @@ public void testExample_D_4() throws HpackException {
         //d 4.1
         byte[] data = {(byte) 0x82, (byte) 0x86, (byte) 0x84, 0x41, (byte) 0x8c, (byte) 0xf1, (byte) 0xe3,
                 (byte) 0xc2, (byte) 0xe5, (byte) 0xf2, 0x3a, 0x6b, (byte) 0xa0, (byte) 0xab, (byte) 0x90, (byte) 0xf4, (byte) 0xff};
-        HpackDecoder decoder = new HpackDecoder(HpackDecoder.DEFAULT_TABLE_SIZE);
+        HpackDecoder decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         HeaderMapEmitter emitter = new HeaderMapEmitter();
         decoder.setHeaderEmitter(emitter);
         decoder.decode(ByteBuffer.wrap(data));",2015-03-19T03:07:42Z,306
"@@ -43,10 +43,12 @@ protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxExcept
         return getRedirectURI(exchange, redirectPort);
     }
 
-    protected URI getRedirectURI(HttpServerExchange exchange, int port) throws URISyntaxException {
-        String host = exchange.getHostName();
-
-        String queryString = exchange.getQueryString();
+    protected URI getRedirectURI(final HttpServerExchange exchange, final int port) throws URISyntaxException {
+        final StringBuilder uriBuilder = new StringBuilder();
+        uriBuilder.append(""https://"").append(exchange.getHostName());
+        if (port > 0) {
+            uriBuilder.append("":"").append(port);
+        }
         String uri = exchange.getRequestURI();
         if(exchange.isHostIncludedInRequestURI()) {
             int slashCount = 0;
@@ -60,8 +62,12 @@ protected URI getRedirectURI(HttpServerExchange exchange, int port) throws URISy
                 }
             }
         }
-        return new URI(""https"", null, host, port, uri,
-                queryString == null || queryString.length() == 0 ? null : queryString, null);
+        uriBuilder.append(uri);
+        final String queryString = exchange.getQueryString();
+        if (queryString != null && !queryString.isEmpty()) {
+            uriBuilder.append(""?"").append(queryString);
+        }
+        return new URI(uriBuilder.toString());
     }
 
 }",2019-06-25T05:16:13Z,281
"@@ -49,6 +49,8 @@
 public class SimpleConfidentialRedirectTestCase {
 
 
+    private static int redirectPort = -1;
+
     @BeforeClass
     public static void setup() throws IOException {
         DefaultServer.startSSLServer();
@@ -58,11 +60,13 @@ public static void setup() throws IOException {
             public void handleRequest(final HttpServerExchange exchange) throws Exception {
                 exchange.getResponseHeaders().put(HttpString.tryFromString(""scheme""), exchange.getRequestScheme());
                 exchange.getResponseHeaders().put(HttpString.tryFromString(""uri""), exchange.getRequestURI());
+                exchange.getResponseHeaders().put(HttpString.tryFromString(""queryString""), exchange.getQueryString());
+                exchange.getResponseHeaders().put(HttpString.tryFromString(""redirectedToPort""), exchange.getHostPort());
                 exchange.endExchange();
             }
         };
-
-        current = new SinglePortConfidentialityHandler(current, DefaultServer.getHostSSLPort(""default""));
+        redirectPort = DefaultServer.getHostSSLPort(""default"");
+        current = new SinglePortConfidentialityHandler(current, redirectPort);
 
         DefaultServer.setRootHandler(current);
     }
@@ -77,11 +81,11 @@ public void simpleRedirectTestCase() throws IOException, GeneralSecurityExceptio
         TestHttpClient client = new TestHttpClient();
         client.setSSLContext(DefaultServer.getClientSSLContext());
         try {
-            sendRequest(client, ""/foo"");
-            sendRequest(client, ""/foo+bar"");
-            sendRequest(client, ""/foo+bar;aa"");
-
-
+            sendRequest(client, ""/foo"", null);
+            sendRequest(client, ""/foo+bar"", null);
+            sendRequest(client, ""/foo+bar;aa"", null);
+            sendRequest(client, ""/foo+bar;aa"", ""x=y"");
+            sendRequest(client, ""/foo+bar%3Aaa"", ""x=%3Ablah"");
         } finally {
             client.getConnectionManager().shutdown();
         }
@@ -99,12 +103,21 @@ public void testRedirectWithFullURLInPath() throws IOException {
         }
     }
 
-    private void sendRequest(TestHttpClient client, String uri) throws IOException {
-        HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + uri);
+    private void sendRequest(final TestHttpClient client, final String uri, final String queryString) throws IOException {
+        String targetURL = DefaultServer.getDefaultServerURL() + uri;
+        if (queryString != null) {
+            targetURL = targetURL + ""?"" + queryString;
+        }
+        final HttpGet get = new HttpGet(targetURL);
         HttpResponse result = client.execute(get);
         Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-        Assert.assertEquals(""https"", result.getFirstHeader(""scheme"").getValue());
-        Assert.assertEquals(uri, result.getFirstHeader(""uri"").getValue());
+        Assert.assertEquals(""Unexpected scheme in redirected URI"", ""https"", result.getFirstHeader(""scheme"").getValue());
+        Assert.assertEquals(""Unexpected port in redirected URI"", String.valueOf(redirectPort), result.getFirstHeader(""redirectedToPort"").getValue());
+        Assert.assertEquals(""Unexpected path in redirected URI"", uri, result.getFirstHeader(""uri"").getValue());
+        if (queryString != null) {
+            Assert.assertEquals(""Unexpected query string in redirected URI"", queryString,
+                    result.getFirstHeader(""queryString"").getValue());
+        }
         HttpClientUtils.readResponse(result);
     }
 ",2019-06-25T05:16:13Z,57
"@@ -585,10 +585,13 @@ public DeploymentInfo setAsyncExecutor(final Executor asyncExecutor) {
     }
 
     public File getTempDir() {
+        if(tempDir == null) {
+            return null;
+        }
         return tempDir.toFile();
     }
 
-    public Path getTempDirPath() {
+    public Path getTempPath() {
         return tempDir;
     }
 ",2015-06-08T13:28:44Z,142
"@@ -89,14 +89,14 @@ public void setupMultipart(ServletContextImpl servletContext) {
             }
             final Path tempDir;
             if(config.getLocation() == null || config.getLocation().isEmpty()) {
-                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath();
+                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath();
             } else {
                 String location = config.getLocation();
                 Path locFile = Paths.get(location);
                 if(locFile.isAbsolute()) {
                     tempDir = locFile;
                 } else {
-                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(location);
+                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(location);
                 }
             }
 ",2015-06-08T13:28:44Z,113
"@@ -98,7 +98,7 @@ public void write(final String fileName) throws IOException {
         Path target = Paths.get(fileName);
         if(!target.isAbsolute()) {
             if(config.getLocation().isEmpty()) {
-                target = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(fileName);
+                target = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(fileName);
             } else {
                 target = Paths.get(config.getLocation(), fileName);
             }",2015-06-08T13:28:44Z,269
"@@ -23,6 +23,7 @@
 import io.undertow.util.CopyOnWriteMap;
 import io.undertow.util.HttpString;
 import io.undertow.util.Methods;
+import io.undertow.util.PathTemplate;
 import io.undertow.util.PathTemplateMatch;
 import io.undertow.util.PathTemplateMatcher;
 
@@ -39,6 +40,7 @@
 public class RoutingHandler implements HttpHandler {
 
     private final Map<HttpString, PathTemplateMatcher<RoutingMatch>> matches = new CopyOnWriteMap<>();
+    private final PathTemplateMatcher<RoutingMatch> allMethodsMatcher = new PathTemplateMatcher<>();
 
     private volatile HttpHandler fallbackHandler = ResponseCodeHandler.HANDLE_404;
     private volatile HttpHandler invalidMethodHandler = ResponseCodeHandler.HANDLE_405;
@@ -67,13 +69,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         }
         PathTemplateMatcher.PathMatchResult<RoutingMatch> match = matcher.match(exchange.getRelativePath());
         if (match == null) {
-            // Check all PathTemplateMatchers to see if there is a match
-            // with a different HttpMethod
-            for (PathTemplateMatcher<RoutingMatch> value : matches.values()) {
-                if (value.match(exchange.getRelativePath()) != null) {
-                    invalidMethodHandler.handleRequest(exchange);
-                    return;
-                }
+            if (allMethodsMatcher.match(exchange.getRelativePath()) != null) {
+                invalidMethodHandler.handleRequest(exchange);
+                return;
             }
             fallbackHandler.handleRequest(exchange);
             return;
@@ -110,10 +108,15 @@ public synchronized RoutingHandler add(HttpString method, String template, HttpH
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
+        if (allMethodsMatcher.get(template) == null) {
+            allMethodsMatcher.add(template, res);
+        }
         res.defaultHandler = handler;
         return this;
     }
 
+
+
     public synchronized RoutingHandler get(final String template, HttpHandler handler) {
         return add(Methods.GET, template, handler);
     }
@@ -143,6 +146,9 @@ public synchronized RoutingHandler add(HttpString method, String template, Predi
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
+        if (allMethodsMatcher.get(template) == null) {
+            allMethodsMatcher.add(template, res);
+        }
         res.predicatedHandlers.add(new HandlerHolder(predicate, handler));
         return this;
     }
@@ -171,6 +177,13 @@ public synchronized RoutingHandler addAll(RoutingHandler routingHandler) {
                 matches.put(method, matcher = new PathTemplateMatcher<>());
             }
             matcher.addAll(entry.getValue());
+            // If we use allMethodsMatcher.addAll() we can have duplicate
+            // PathTemplates which we want to ignore here so it does not crash.
+            for (PathTemplate template : entry.getValue().getPathTemplates()) {
+                if (allMethodsMatcher.get(template.getTemplateString()) == null) {
+                    allMethodsMatcher.add(template, new RoutingMatch());
+                }
+            }
         }
         return this;
     }",2014-07-30T19:41:39Z,307
"@@ -22,6 +22,7 @@
 
 import java.util.Comparator;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -160,6 +161,16 @@ Map<String, Set<PathTemplateHolder>> getPathTemplateMap() {
         return pathTemplateMap;
     }
 
+    public Set<PathTemplate> getPathTemplates() {
+        Set<PathTemplate> templates = new HashSet<>();
+        for (Set<PathTemplateHolder> holders : pathTemplateMap.values()) {
+            for (PathTemplateHolder holder: holders) {
+                templates.add(holder.template);
+            }
+        }
+        return templates;
+    }
+
     public synchronized PathTemplateMatcher<T> remove(final String pathTemplate) {
         final PathTemplate template = PathTemplate.create(pathTemplate);
         return remove(template);",2014-07-30T19:41:39Z,89
"@@ -28,8 +28,6 @@
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.Methods;
 
-import java.io.IOException;
-
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpDelete;
 import org.apache.http.client.methods.HttpGet;
@@ -40,6 +38,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.io.IOException;
+
 /**
  * @author Stuart Douglas
  */",2014-07-30T19:41:39Z,308
"@@ -39,6 +39,7 @@
 import io.undertow.servlet.spec.ServletContextImpl;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.Methods;
 import io.undertow.util.Protocols;
 import io.undertow.util.RedirectBuilder;
 import io.undertow.util.StatusCodes;
@@ -132,7 +133,11 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         if (info.getType() == ServletPathMatch.Type.REDIRECT && !isUpgradeRequest) {
             //UNDERTOW-89
             //we redirect on GET requests to the root context to add an / to the end
-            exchange.setResponseCode(StatusCodes.TEMPORARY_REDIRECT);
+            if(exchange.getRequestMethod().equals(Methods.GET) || exchange.getRequestMethod().equals(Methods.HEAD)) {
+                exchange.setResponseCode(StatusCodes.FOUND);
+            } else {
+                exchange.setResponseCode(StatusCodes.TEMPORARY_REDIRECT);
+            }
             exchange.getResponseHeaders().put(Headers.LOCATION, RedirectBuilder.redirect(exchange, exchange.getRelativePath() + ""/"", true));
             return;
         } else if (info.getType() == ServletPathMatch.Type.REWRITE) {",2015-03-07T04:39:26Z,145
"@@ -450,15 +450,15 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                     if (encodedPath.charAt(j) == '?') {
                         exchange.setRequestURI(encodedPath.substring(0, j));
                         String pathParams = encodedPath.substring(i + 1, j);
-                        URLUtils.parsePathParms(pathParams, exchange, charset, decode, maxParameters);
+                        URLUtils.parsePathParams(pathParams, exchange, charset, decode, maxParameters);
                         String qs = encodedPath.substring(j + 1);
                         exchange.setQueryString(qs);
                         URLUtils.parseQueryString(qs, exchange, charset, decode, maxParameters);
                         return;
                     }
                 }
                 exchange.setRequestURI(encodedPath);
-                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
+                URLUtils.parsePathParams(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
                 return;
             } else if(c == '%' || c == '+') {
                 requiresDecode = true;",2017-08-02T01:02:46Z,163
"@@ -259,7 +259,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                         exchange.setRequestPath(res);
                         exchange.setRelativePath(res);
                         try {
-                            URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters, maxParameters);
+                            URLUtils.parsePathParams(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters, maxParameters);
                         } catch (ParameterLimitException e) {
                             UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);
                             state.badRequest = true;",2017-08-02T01:02:46Z,54
"@@ -104,12 +104,69 @@ public String rewriteUrl(final String url, final String sessionId) {
         StringBuilder sb = new StringBuilder(path);
         if (sb.length() > 0) { // jsessionid can't be first.
             if(fragmentIndex > 0) {
-                sb.append(fragment);
-                sb.append(""&"");
+                if(fragment.contains(name)) {
+                    //this does not necessarily mean that this parameter is present. It could be part of the value, or the
+                    //name could be a substring of a larger key name
+                    sb.append(';'); //we make sure we append the fragment portion
+                    String key = null;
+                    StringBuilder paramBuilder = new StringBuilder();
+                    for (int i = 1; i < fragment.length(); ++i) {
+                        char c = fragment.charAt(i);
+                        if (key == null) {
+                            if (c == '&' || c == '=') {
+                                key = paramBuilder.toString();
+                                paramBuilder.setLength(0);
+                                if (c == '&') {
+                                    if (!key.equals(name)) { //we don't append if it matches the name
+                                        sb.append(key);
+                                        sb.append('&');
+                                    }
+                                    key = null;
+                                }
+                            } else {
+                                paramBuilder.append(c);
+                            }
+                        } else {
+                            if (c == '&') {
+                                String value = paramBuilder.toString();
+                                paramBuilder.setLength(0);
+                                if (!key.equals(name)) { //we don't append if it matches the name
+                                    sb.append(key);
+                                    sb.append('=');
+                                    sb.append(value);
+                                    sb.append('&');
+                                }
+                                key = null;
+                            } else {
+                                paramBuilder.append(c);
+                            }
+                        }
+                    }
+                    if(paramBuilder.length() > 0) {
+                        if(key == null) {
+                            key = paramBuilder.toString();
+                            if (!key.equals(name)) { //we don't append if it matches the name
+                                sb.append(key);
+                                sb.append('&');
+                            }
+                        } else {
+                            String value = paramBuilder.toString();
+                            if (!key.equals(name)) { //we don't append if it matches the name
+                                sb.append(key);
+                                sb.append('=');
+                                sb.append(value);
+                                sb.append('&');
+                            }
+                        }
+                    }
+                } else {
+                    sb.append(fragment);
+                    sb.append(""&"");
+                }
             } else {
                 sb.append(';');
             }
-            sb.append(name.toLowerCase(Locale.ENGLISH));
+            sb.append(name);
             sb.append('=');
             sb.append(sessionId);
         }",2017-08-02T01:02:46Z,253
"@@ -53,7 +53,12 @@ public static void parseQueryString(final String string, final HttpServerExchang
         QUERY_STRING_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 
+    @Deprecated
     public static void parsePathParms(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) throws ParameterLimitException {
+        parsePathParams(string, exchange, charset, doDecode, maxParameters);
+    }
+
+    public static void parsePathParams(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) throws ParameterLimitException {
         PATH_PARAM_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 ",2017-08-02T01:02:46Z,276
"@@ -0,0 +1,232 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.session;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.BasicCookieStore;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import io.undertow.servlet.ServletExtension;
+import io.undertow.servlet.Servlets;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.ServletSessionConfig;
+import io.undertow.servlet.test.util.DeploymentUtils;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.StatusCodes;
+
+/**
+ * basic test of in memory session functionality
+ *
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class ServletURLRewritingSessionTestCase {
+
+    public static final String COUNT = ""count"";
+
+    @BeforeClass
+    public static void setup() {
+        DeploymentUtils.setupServlet(new ServletExtension() {
+            @Override
+            public void handleDeployment(DeploymentInfo deploymentInfo, ServletContext servletContext) {
+                deploymentInfo.setServletSessionConfig(new ServletSessionConfig().setSessionTrackingModes(Collections.singleton(SessionTrackingMode.URL)));
+            }
+        }, Servlets.servlet(URLRewritingServlet.class).addMapping(""/foo""));
+    }
+
+    @Test
+    public void testURLRewriting() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        client.setCookieStore(new BasicCookieStore());
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/foo;foo=bar"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String url = HttpClientUtils.readResponse(result);
+            Header[] header = result.getHeaders(COUNT);
+            Assert.assertEquals(""0"", header[0].getValue());
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""1"", header[0].getValue());
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""2"", header[0].getValue());
+
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testURLRewritingWithQueryParameters() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        client.setCookieStore(new BasicCookieStore());
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/foo?a=b;c"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String url = HttpClientUtils.readResponse(result);
+            Header[] header = result.getHeaders(COUNT);
+            Assert.assertEquals(""0"", header[0].getValue());
+            Assert.assertEquals(""b;c"", result.getHeaders(""a"")[0].getValue());
+
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""1"", header[0].getValue());
+            Assert.assertEquals(""b;c"", result.getHeaders(""a"")[0].getValue());
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""2"", header[0].getValue());
+            Assert.assertEquals(""b;c"", result.getHeaders(""a"")[0].getValue());
+
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+
+    @Test
+    public void testURLRewritingWithExistingOldSessionId() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        client.setCookieStore(new BasicCookieStore());
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/foo;jsessionid=foobar"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String url = HttpClientUtils.readResponse(result);
+            Header[] header = result.getHeaders(COUNT);
+            Assert.assertEquals(""0"", header[0].getValue());
+
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""1"", header[0].getValue());
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""2"", header[0].getValue());
+
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        client.setCookieStore(new BasicCookieStore());
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/foo;jsessionid=foobar&a=b"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String url = HttpClientUtils.readResponse(result);
+            Header[] header = result.getHeaders(COUNT);
+            Assert.assertEquals(""0"", header[0].getValue());
+
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""1"", header[0].getValue());
+
+            get = new HttpGet(url);
+            result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            url = HttpClientUtils.readResponse(result);
+            header = result.getHeaders(COUNT);
+            Assert.assertEquals(""2"", header[0].getValue());
+
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    public static class URLRewritingServlet extends HttpServlet {
+
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
+            HttpSession session = req.getSession(true);
+            Object existing = session.getAttribute(COUNT);
+            if (existing == null) {
+                session.setAttribute(COUNT, 0);
+            } else {
+                Assert.assertTrue(req.getRequestURI().startsWith(""/servletContext/foo;""));
+                Assert.assertTrue(req.getRequestURI().contains(""jsessionid="" + session.getId()));
+            }
+            Integer count = (Integer) session.getAttribute(COUNT);
+            resp.addHeader(COUNT, count.toString());
+            session.setAttribute(COUNT, ++count);
+
+            for (Map.Entry<String, String[]> qp : req.getParameterMap().entrySet()) {
+                resp.addHeader(qp.getKey(), qp.getValue()[0]);
+            }
+            if (req.getQueryString() == null) {
+                resp.getWriter().write(resp.encodeURL(DefaultServer.getDefaultServerURL() + req.getRequestURI()));
+            } else {
+                resp.getWriter().write(resp.encodeURL(DefaultServer.getDefaultServerURL() + req.getRequestURI() + ""?"" + req.getQueryString()));
+            }
+        }
+    }
+
+}",2017-08-02T01:02:46Z,309
"@@ -19,6 +19,7 @@
 package io.undertow.attribute;
 
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.HeaderValues;
 import io.undertow.util.HttpString;
 
 /**
@@ -37,7 +38,22 @@ public RequestHeaderAttribute(final HttpString requestHeader) {
 
     @Override
     public String readAttribute(final HttpServerExchange exchange) {
-        return exchange.getRequestHeaders().getFirst(requestHeader);
+        HeaderValues header = exchange.getRequestHeaders().get(requestHeader);
+        if (header == null) {
+            return null;
+        } else if(header.size() == 1) {
+            return header.getFirst();
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(""["");
+        for (int i = 0; i < header.size(); ++i) {
+            if (i != 0) {
+                sb.append("", "");
+            }
+            sb.append(header.get(i));
+        }
+        sb.append(""]"");
+        return sb.toString();
     }
 
     @Override",2017-12-06T23:54:56Z,310
"@@ -19,6 +19,7 @@
 package io.undertow.attribute;
 
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.HeaderValues;
 import io.undertow.util.HttpString;
 
 /**
@@ -37,7 +38,22 @@ public ResponseHeaderAttribute(final HttpString responseHeader) {
 
     @Override
     public String readAttribute(final HttpServerExchange exchange) {
-        return exchange.getResponseHeaders().getFirst(responseHeader);
+        HeaderValues header = exchange.getResponseHeaders().get(responseHeader);
+        if (header == null) {
+            return null;
+        } else if(header.size() == 1) {
+            return header.getFirst();
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(""["");
+        for (int i = 0; i < header.size(); ++i) {
+            if (i != 0) {
+                sb.append("", "");
+            }
+            sb.append(header.get(i));
+        }
+        sb.append(""]"");
+        return sb.toString();
     }
 
     @Override",2017-12-06T23:54:56Z,311
"@@ -97,17 +97,19 @@ public void testSingleLogMessageToFileWithSuffix() throws IOException, Interrupt
     private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogReceiver logReceiver) throws IOException, InterruptedException {
 
         CompletionLatchHandler latchHandler;
-        DefaultServer.setRootHandler(latchHandler = new CompletionLatchHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, ""Remote address %a Code %s test-header %{i,test-header} %{i,non-existent}"", AccessLogFileTestCase.class.getClassLoader())));
+        DefaultServer.setRootHandler(latchHandler = new CompletionLatchHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, ""Remote address %a Code %s test-header %{i,test-header} %{i,non-existent} %{i,dup}"", AccessLogFileTestCase.class.getClassLoader())));
         TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
             get.addHeader(""test-header"", ""single-val"");
+            get.addHeader(""dup"", ""d""); //we can't rely on ordering, so we just send the same thing twice to make the comparison easy
+            get.addHeader(""dup"", ""d"");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             Assert.assertEquals(""Hello"", HttpClientUtils.readResponse(result));
             latchHandler.await();
             logReceiver.awaitWrittenForTest();
-            Assert.assertEquals(""Remote address "" + DefaultServer.getDefaultServerAddress().getAddress().getHostAddress() + "" Code 200 test-header single-val -\n"", new String(Files.readAllBytes(logFileName)));
+            Assert.assertEquals(""Remote address "" + DefaultServer.getDefaultServerAddress().getAddress().getHostAddress() + "" Code 200 test-header single-val - [d, d]\n"", new String(Files.readAllBytes(logFileName)));
         } finally {
             client.getConnectionManager().shutdown();
         }",2017-12-06T23:54:56Z,312
"@@ -64,6 +64,7 @@
         <version.easymock>3.2</version.easymock>        
         <version.io.undertow.jastow>2.0.0.Beta2</version.io.undertow.jastow>
         <version.junit>4.12</version.junit>
+        <version.javax.servlet.api>4.0.0-b01</version.javax.servlet.api>
         <version.netty>4.1.0.Beta5</version.netty>
         <version.org.apache.directory.server>2.0.0-M15</version.org.apache.directory.server>
         <version.org.apache.httpmime>4.2.6</version.org.apache.httpmime>
@@ -74,7 +75,6 @@
         <version.org.jboss.logging.processor>2.0.0.Final</version.org.jboss.logging.processor>
         <version.org.jboss.logmanager>2.0.0.Final</version.org.jboss.logmanager>
         <version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>1.0.0.Final</version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>
-        <version.org.jboss.spec.javax.servlet.jboss-servlet-api_3.1_spec>1.0.0.Final</version.org.jboss.spec.javax.servlet.jboss-servlet-api_3.1_spec>
         <version.org.jboss.spec.javax.servlet.jsp>1.0.0.Final</version.org.jboss.spec.javax.servlet.jsp>
         <version.org.jboss.spec.javax.websockets>1.1.0.Final</version.org.jboss.spec.javax.websockets>
         <version.xnio>3.3.4.Final</version.xnio>
@@ -97,7 +97,9 @@
         <version.org.eclipse.jetty.alpn>1.0.0</version.org.eclipse.jetty.alpn>
         <alpn-boot-string></alpn-boot-string>
 
-        <jdk.min.version>1.7</jdk.min.version>
+        <jdk.min.version>1.8</jdk.min.version>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <maven.compiler.source>1.8</maven.compiler.source>
         <version.com.twitter.hpack>0.10.1</version.com.twitter.hpack>
     </properties>
 
@@ -346,11 +348,12 @@
             </dependency>
 
             <dependency>
-                <groupId>org.jboss.spec.javax.servlet</groupId>
-                <artifactId>jboss-servlet-api_3.1_spec</artifactId>
-                <version>${version.org.jboss.spec.javax.servlet.jboss-servlet-api_3.1_spec}</version>
+                <groupId>javax.servlet</groupId>
+                <artifactId>javax.servlet-api</artifactId>
+                <version>${version.javax.servlet.api}</version>
             </dependency>
 
+
             <dependency>
                 <groupId>org.jboss.spec.javax.servlet.jsp</groupId>
                 <artifactId>jboss-jsp-api_2.3_spec</artifactId>",2016-01-06T06:22:10Z,265
"@@ -57,8 +57,9 @@
         </dependency>
 
         <dependency>
-            <groupId>org.jboss.spec.javax.servlet</groupId>
-            <artifactId>jboss-servlet-api_3.1_spec</artifactId>
+            <groupId>javax.servlet</groupId>
+            <artifactId>javax.servlet-api</artifactId>
+            <version>${version.javax.servlet.api}</version>
         </dependency>
 
         <dependency>",2016-01-06T06:22:10Z,313
"@@ -211,4 +211,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10055, value = ""Listener is not started"")
     IllegalStateException listenerIsNotStarted();
+
+    @Message(id = 10056, value = ""path was not set"")
+    IllegalStateException pathWasNotSet();
 }",2016-01-06T06:22:10Z,141
"@@ -63,6 +63,7 @@
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.HttpUpgradeHandler;
 import javax.servlet.http.Part;
+import javax.servlet.http.PushBuilder;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
@@ -1108,4 +1109,9 @@ public void clearAttributes() {
             this.attributes.clear();
         }
     }
+
+    @Override
+    public PushBuilder getPushBuilder() {
+        return new PushBuilderImpl(this);
+    }
 }",2016-01-06T06:22:10Z,147
"@@ -0,0 +1,257 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.spec;
+
+import io.undertow.server.ServerConnection;
+import io.undertow.server.handlers.Cookie;
+import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.util.HeaderMap;
+import io.undertow.util.HeaderValues;
+import io.undertow.util.Headers;
+import io.undertow.util.HttpString;
+
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.PushBuilder;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+/**
+ * @author Stuart Douglas
+ */
+public class PushBuilderImpl implements PushBuilder {
+
+    private static final Set<HttpString> IGNORE;
+    static {
+        final Set<HttpString> ignore = new HashSet<>();
+        ignore.add(Headers.IF_MATCH);
+        ignore.add(Headers.IF_NONE_MATCH);
+        ignore.add(Headers.IF_MODIFIED_SINCE);
+        ignore.add(Headers.IF_UNMODIFIED_SINCE);
+        ignore.add(Headers.IF_RANGE);
+        ignore.add(Headers.RANGE);
+        ignore.add(Headers.ACCEPT_RANGES);
+        ignore.add(Headers.EXPECT);
+        ignore.add(Headers.AUTHORIZATION);
+        ignore.add(Headers.REFERER);
+        IGNORE = Collections.unmodifiableSet(ignore);
+    }
+
+    private final HttpServletRequestImpl servletRequest;
+    private String method;
+    private String queryString;
+    private String sessionId;
+    private boolean conditional;
+    private final HeaderMap headers = new HeaderMap();
+    private String path;
+    private String etag;
+    private String lastModified;
+
+    public PushBuilderImpl(HttpServletRequestImpl servletRequest) {
+        //TODO: auth
+        this.servletRequest = servletRequest;
+        this.method = ""GET"";
+        this.queryString = servletRequest.getQueryString();
+        HttpSession session = servletRequest.getSession(false);
+        if(session != null) {
+            this.sessionId = session.getId();
+        } else {
+            this.sessionId = servletRequest.getRequestedSessionId();
+        }
+
+        this.conditional = servletRequest.getHeader(Headers.IF_NONE_MATCH_STRING) != null || servletRequest.getHeader(Headers.IF_MODIFIED_SINCE_STRING) != null;
+        for(HeaderValues header : servletRequest.getExchange().getRequestHeaders()) {
+            if(!IGNORE.contains(header.getHeaderName())) {
+                headers.addAll(header.getHeaderName(), header);
+            }
+        }
+        if(servletRequest.getQueryString() == null) {
+            this.headers.add(Headers.REFERER, servletRequest.getRequestURL().toString());
+        } else {
+            this.headers.add(Headers.REFERER, servletRequest.getRequestURL()  + ""?"" + servletRequest.getQueryString());
+        }
+        this.path = null;
+        this.etag = servletRequest.getHeader(Headers.ETAG_STRING);
+        for(Map.Entry<String, Cookie> cookie : servletRequest.getExchange().getResponseCookies().entrySet()) {
+            if(Objects.equals(0, cookie.getValue().getMaxAge())) {
+                //remove cookie
+                HeaderValues existing = headers.get(Headers.COOKIE);
+                if(existing != null) {
+                    Iterator<String> it = existing.iterator();
+                    while (it.hasNext()) {
+                        String val = it.next();
+                        if(val.startsWith(cookie.getKey() + ""="")) {
+                            it.remove();
+                        }
+                    }
+                }
+            } else {
+                headers.add(Headers.COOKIE, cookie.getKey() + ""="" + cookie.getValue());
+            }
+        }
+        this.lastModified = null;
+        this.etag = null;
+
+    }
+
+
+    @Override
+    public PushBuilder method(String method) {
+        this.method = method;
+        return this;
+    }
+
+    @Override
+    public PushBuilder queryString(String queryString) {
+        this.queryString = queryString;
+        return this;
+    }
+
+    @Override
+    public PushBuilder sessionId(String sessionId) {
+        this.sessionId = sessionId;
+        return this;
+    }
+
+    @Override
+    public PushBuilder conditional(boolean conditional) {
+        this.conditional = conditional;
+        return this;
+    }
+
+    @Override
+    public PushBuilder setHeader(String name, String value) {
+        headers.put(new HttpString(name), value);
+        return this;
+    }
+
+    @Override
+    public PushBuilder addHeader(String name, String value) {
+        headers.add(new HttpString(name), value);
+        return this;
+    }
+
+    @Override
+    public PushBuilder removeHeader(String name) {
+        headers.remove(name);
+        return this;
+    }
+
+    @Override
+    public PushBuilder path(String path) {
+        this.path = path;
+        return this;
+    }
+
+    @Override
+    public PushBuilder etag(String etag) {
+        this.etag = etag;
+        return this;
+    }
+
+    @Override
+    public PushBuilder lastModified(String lastModified) {
+        this.lastModified = lastModified;
+        return this;
+    }
+
+    @Override
+    public void push() {
+        if(path == null) {
+            throw UndertowServletMessages.MESSAGES.pathWasNotSet();
+        }
+        ServerConnection con = servletRequest.getExchange().getConnection();
+        if(con.isPushSupported()) {
+            HeaderMap newHeaders = new HeaderMap();
+            for(HeaderValues entry : headers) {
+                newHeaders.addAll(entry.getHeaderName(), entry);
+            }
+            if(conditional) {
+                if(etag != null) {
+                    newHeaders.put(Headers.IF_NONE_MATCH, etag);
+                } else if(lastModified != null) {
+                    newHeaders.put(Headers.IF_MODIFIED_SINCE, lastModified);
+                }
+            }
+            if(sessionId != null) {
+                newHeaders.put(Headers.COOKIE, ""JSESSIONID="" + sessionId); //TODO: do this properly, may be a different tracking method or a different cookie name
+            }
+            String path = this.path;
+            if(queryString != null && !queryString.isEmpty()) {
+                path += ""?"" + queryString;
+            }
+            con.pushResource(path, new HttpString(method), newHeaders);
+        }
+        path = null;
+        etag = null;
+        lastModified = null;
+    }
+
+    @Override
+    public String getMethod() {
+        return method;
+    }
+
+    @Override
+    public String getQueryString() {
+        return queryString;
+    }
+
+    @Override
+    public String getSessionId() {
+        return sessionId;
+    }
+
+    @Override
+    public boolean isConditional() {
+        return conditional;
+    }
+
+    @Override
+    public Set<String> getHeaderNames() {
+        Set<String> names = new HashSet<>();
+        for(HeaderValues name : headers) {
+            names.add(name.getHeaderName().toString());
+        }
+        return names;
+    }
+
+    @Override
+    public String getHeader(String name) {
+        return headers.getFirst(name);
+    }
+
+    @Override
+    public String getPath() {
+        return path;
+    }
+
+    @Override
+    public String getEtag() {
+        return etag;
+    }
+
+    @Override
+    public String getLastModified() {
+        return lastModified;
+    }
+}",2016-01-06T06:22:10Z,270
"@@ -22,6 +22,7 @@
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.charset.StandardCharsets;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Implementation of version 1 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
@@ -30,6 +31,7 @@
  * fragmentation of
  *
  * @author Stuart Douglas
+ * @author Ulrich Herberg
  */
 class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel> {
 
@@ -38,7 +40,9 @@ class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel>
     private static final byte[] NAME = ""PROXY "".getBytes(StandardCharsets.US_ASCII);
     private static final String UNKNOWN = ""UNKNOWN"";
     private static final String TCP4 = ""TCP4"";
-    private static final String TCP_6 = ""TCP6"";
+    private static final String TCP6 = ""TCP6"";
+
+    private static final byte[] SIG = new byte[] {0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A};
 
     private final StreamConnection streamConnection;
     private final OpenListener openListener;
@@ -71,115 +75,29 @@ class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel>
     @Override
     public void handleEvent(StreamSourceChannel streamSourceChannel) {
         PooledByteBuffer buffer = bufferPool.allocate();
-        boolean freeBuffer = true;
+        AtomicBoolean freeBuffer = new AtomicBoolean(true);
         try {
-            for (; ; ) {
-                int res = streamSourceChannel.read(buffer.getBuffer());
-                if (res == -1) {
-                    IoUtils.safeClose(streamConnection);
-                    return;
-                } else if (res == 0) {
-                    return;
-                } else {
-                    buffer.getBuffer().flip();
-                    while (buffer.getBuffer().hasRemaining()) {
-                        char c = (char) buffer.getBuffer().get();
-                        if (byteCount < NAME.length) {
-                            //first we verify that we have the correct protocol
-                            if (c != NAME[byteCount]) {
-                                throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                            }
-                        } else {
-                            if (parsingUnknown) {
-                                //we are parsing the UNKNOWN protocol
-                                //we just ignore everything till \r\n
-                                if (c == '\r') {
-                                    carriageReturnSeen = true;
-                                } else if (c == '\n') {
-                                    if (!carriageReturnSeen) {
-                                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                    }
-                                    //we are done
-                                    if (buffer.getBuffer().hasRemaining()) {
-                                        freeBuffer = false;
-                                        proxyAccept(null, null, buffer);
-                                    } else {
-                                        proxyAccept(null, null, null);
-                                    }
-                                    return;
-                                } else if (carriageReturnSeen) {
-                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                }
-                            } else if (carriageReturnSeen) {
-                                if (c == '\n') {
-                                    //we are done
-                                    SocketAddress s = new InetSocketAddress(sourceAddress, sourcePort);
-                                    SocketAddress d = new InetSocketAddress(destAddress, destPort);
-                                    if (buffer.getBuffer().hasRemaining()) {
-                                        freeBuffer = false;
-                                        proxyAccept(s, d, buffer);
-                                    } else {
-                                        proxyAccept(s, d, null);
-                                    }
-                                    return;
-                                } else {
-                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                }
-                            } else switch (c) {
-                                case ' ':
-                                    //we have a space
-                                    if (sourcePort != -1 || stringBuilder.length() == 0) {
-                                        //header was invalid, either we are expecting a \r or a \n, or the previous character was a space
-                                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                    } else if (protocol == null) {
-                                        protocol = stringBuilder.toString();
-                                        stringBuilder.setLength(0);
-                                        if (protocol.equals(UNKNOWN)) {
-                                            parsingUnknown = true;
-                                        } else if (!protocol.equals(TCP4) && !protocol.equals(TCP_6)) {
-                                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                        }
-                                    } else if (sourceAddress == null) {
-                                        sourceAddress = parseAddress(stringBuilder.toString(), protocol);
-                                        stringBuilder.setLength(0);
-                                    } else if (destAddress == null) {
-                                        destAddress = parseAddress(stringBuilder.toString(), protocol);
-                                        stringBuilder.setLength(0);
-                                    } else {
-                                        sourcePort = Integer.parseInt(stringBuilder.toString());
-                                        stringBuilder.setLength(0);
-                                    }
-                                    break;
-                                case '\r':
-                                    if (destPort == -1 && sourcePort != -1 && !carriageReturnSeen && stringBuilder.length() > 0) {
-                                        destPort = Integer.parseInt(stringBuilder.toString());
-                                        stringBuilder.setLength(0);
-                                        carriageReturnSeen = true;
-                                    } else if (protocol == null) {
-                                        if (UNKNOWN.equals(stringBuilder.toString())) {
-                                            parsingUnknown = true;
-                                            carriageReturnSeen = true;
-                                        }
-                                    } else {
-                                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                    }
-                                    break;
-                                case '\n':
-                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
-                                default:
-                                    stringBuilder.append(c);
-                            }
-
-                        }
-                        byteCount++;
-                        if (byteCount == MAX_HEADER_LENGTH) {
-                            throw UndertowMessages.MESSAGES.headerSizeToLarge();
-                        }
+            int res = streamSourceChannel.read(buffer.getBuffer());
+            if (res == -1) {
+                IoUtils.safeClose(streamConnection);
+                return;
+            } else if (res == 0) {
+                return;
+            } else {
+                buffer.getBuffer().flip();
 
+                if (buffer.getBuffer().hasRemaining()) {
+                    byte firstByte = buffer.getBuffer().get(); // get first byte to determine whether Proxy Protocol V1 or V2 is used
+                    byteCount++;
+                    if (firstByte == SIG[0]) {  // Could be Proxy Protocol V2
+                        parseProxyProtocolV2(buffer, freeBuffer);
+                    } else if ((char) firstByte == NAME[0]){ // Could be Proxy Protocol V1
+                        parseProxyProtocolV1(buffer, freeBuffer);
+                    } else {
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
                     }
-
-
                 }
+                return;
             }
 
         } catch (IOException e) {
@@ -189,13 +107,221 @@ public void handleEvent(StreamSourceChannel streamSourceChannel) {
             UndertowLogger.REQUEST_IO_LOGGER.ioException(new IOException(e));
             IoUtils.safeClose(streamConnection);
         } finally {
-            if (freeBuffer) {
+            if (freeBuffer.get()) {
                 buffer.close();
             }
         }
+    }
+
+
+
+    private void parseProxyProtocolV2(PooledByteBuffer buffer, AtomicBoolean freeBuffer) throws Exception {
+        while (byteCount < SIG.length) {
+            byte c = buffer.getBuffer().get();
+
+            //first we verify that we have the correct protocol
+            if (c != SIG[byteCount]) {
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+            }
+            byteCount++;
+        }
+
+        byte ver_cmd = buffer.getBuffer().get();
+        byte fam = buffer.getBuffer().get();
+        int len = (buffer.getBuffer().getShort() & 0xffff);
+
+        if ((ver_cmd & 0xF0) != 0x20) {  // expect version 2
+            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+        }
+
+        switch (ver_cmd & 0x0F) {
+            case 0x01:  // PROXY command
+                switch (fam) {
+                    case 0x11: { // TCP over IPv4
+                        if (len < 12) {
+                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                        }
+
+                        byte[] sourceAddressBytes = new byte[4];
+                        buffer.getBuffer().get(sourceAddressBytes);
+                        sourceAddress = InetAddress.getByAddress(sourceAddressBytes);
+
+                        byte[] dstAddressBytes = new byte[4];
+                        buffer.getBuffer().get(dstAddressBytes);
+                        destAddress = InetAddress.getByAddress(dstAddressBytes);
+
+                        sourcePort = buffer.getBuffer().getShort() & 0xffff;
+                        destPort = buffer.getBuffer().getShort() & 0xffff;
+
+                        if (len > 12) {
+                            int skipAhead = len - 12;
+                            int currentPosition = buffer.getBuffer().position();
+                            buffer.getBuffer().position(currentPosition + skipAhead);
+                        }
+
+                        break;
+                    }
+
+                    case 0x21: { // TCP over IPv6
+                        if (len < 36) {
+                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                        }
+
+                        byte[] sourceAddressBytes = new byte[16];
+                        buffer.getBuffer().get(sourceAddressBytes);
+                        sourceAddress = InetAddress.getByAddress(sourceAddressBytes);
+
+                        byte[] dstAddressBytes = new byte[16];
+                        buffer.getBuffer().get(dstAddressBytes);
+                        destAddress = InetAddress.getByAddress(dstAddressBytes);
+
+                        sourcePort = buffer.getBuffer().getShort() & 0xffff;
+                        destPort = buffer.getBuffer().getShort() & 0xffff;
+
+                        if (len > 36) {
+                            int skipAhead = len - 36;
+                            int currentPosition = buffer.getBuffer().position();
+                            buffer.getBuffer().position(currentPosition + skipAhead);
+                        }
+
+                        break;
+                    }
+
+                    default: // AF_UNIX sockets not supported
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+
+                }
+                break;
+            case 0x00: // LOCAL command
+                if (len > 0) {
+                    int skipAhead = len;
+                    int currentPosition = buffer.getBuffer().position();
+                    buffer.getBuffer().position(currentPosition + skipAhead);
+                }
+
+                if (buffer.getBuffer().hasRemaining()) {
+                    freeBuffer.set(false);
+                    proxyAccept(null, null, buffer);
+                } else {
+                    proxyAccept(null, null, null);
+                }
+                return;
+            default:
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+        }
+
+
+        SocketAddress s = new InetSocketAddress(sourceAddress, sourcePort);
+        SocketAddress d = new InetSocketAddress(destAddress, destPort);
+        if (buffer.getBuffer().hasRemaining()) {
+            freeBuffer.set(false);
+            proxyAccept(s, d, buffer);
+        } else {
+            proxyAccept(s, d, null);
+        }
+        return;
+    }
+
+    private void parseProxyProtocolV1(PooledByteBuffer buffer, AtomicBoolean freeBuffer) throws Exception {
+        while (buffer.getBuffer().hasRemaining()) {
+            char c = (char) buffer.getBuffer().get();
+            if (byteCount < NAME.length) {
+                //first we verify that we have the correct protocol
+                if (c != NAME[byteCount]) {
+                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                }
+            } else {
+                if (parsingUnknown) {
+                    //we are parsing the UNKNOWN protocol
+                    //we just ignore everything till \r\n
+                    if (c == '\r') {
+                        carriageReturnSeen = true;
+                    } else if (c == '\n') {
+                        if (!carriageReturnSeen) {
+                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                        }
+                        //we are done
+                        if (buffer.getBuffer().hasRemaining()) {
+                            freeBuffer.set(false);
+                            proxyAccept(null, null, buffer);
+                        } else {
+                            proxyAccept(null, null, null);
+                        }
+                        return;
+                    } else if (carriageReturnSeen) {
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                    }
+                } else if (carriageReturnSeen) {
+                    if (c == '\n') {
+                        //we are done
+                        SocketAddress s = new InetSocketAddress(sourceAddress, sourcePort);
+                        SocketAddress d = new InetSocketAddress(destAddress, destPort);
+                        if (buffer.getBuffer().hasRemaining()) {
+                            freeBuffer.set(false);
+                            proxyAccept(s, d, buffer);
+                        } else {
+                            proxyAccept(s, d, null);
+                        }
+                        return;
+                    } else {
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                    }
+                } else switch (c) {
+                    case ' ':
+                        //we have a space
+                        if (sourcePort != -1 || stringBuilder.length() == 0) {
+                            //header was invalid, either we are expecting a \r or a \n, or the previous character was a space
+                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                        } else if (protocol == null) {
+                            protocol = stringBuilder.toString();
+                            stringBuilder.setLength(0);
+                            if (protocol.equals(UNKNOWN)) {
+                                parsingUnknown = true;
+                            } else if (!protocol.equals(TCP4) && !protocol.equals(TCP6)) {
+                                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                            }
+                        } else if (sourceAddress == null) {
+                            sourceAddress = parseAddress(stringBuilder.toString(), protocol);
+                            stringBuilder.setLength(0);
+                        } else if (destAddress == null) {
+                            destAddress = parseAddress(stringBuilder.toString(), protocol);
+                            stringBuilder.setLength(0);
+                        } else {
+                            sourcePort = Integer.parseInt(stringBuilder.toString());
+                            stringBuilder.setLength(0);
+                        }
+                        break;
+                    case '\r':
+                        if (destPort == -1 && sourcePort != -1 && !carriageReturnSeen && stringBuilder.length() > 0) {
+                            destPort = Integer.parseInt(stringBuilder.toString());
+                            stringBuilder.setLength(0);
+                            carriageReturnSeen = true;
+                        } else if (protocol == null) {
+                            if (UNKNOWN.equals(stringBuilder.toString())) {
+                                parsingUnknown = true;
+                                carriageReturnSeen = true;
+                            }
+                        } else {
+                            throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                        }
+                        break;
+                    case '\n':
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                    default:
+                        stringBuilder.append(c);
+                }
 
+            }
+
+            byteCount++;
+            if (byteCount == MAX_HEADER_LENGTH) {
+                throw UndertowMessages.MESSAGES.headerSizeToLarge();
+            }
+
+        }
     }
 
+
     private void proxyAccept(SocketAddress source, SocketAddress dest, PooledByteBuffer additionalData) {
         StreamConnection streamConnection = this.streamConnection;
         if (source != null) {
@@ -275,5 +401,4 @@ public SocketAddress getLocalAddress() {
             return dest;
         }
     }
-
 }",2018-12-17T04:38:16Z,173
"@@ -1,7 +1,9 @@
 package io.undertow.server.protocol.proxy;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 
 import io.undertow.Undertow;
@@ -18,8 +20,15 @@
  *
  * @author Stuart Douglas
  * @author Jan Stourac
+ * @author Ulrich Herberg
  */
 public class ProxyProtocolTestCase {
+    private static final byte[] SIG = new byte[] {0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A};
+    private static final byte[] NAME = ""PROXY "".getBytes(StandardCharsets.US_ASCII);
+    private static final byte PROXY = 0x21;
+    private static final byte LOCAL = 0x20;
+    private static final byte TCPv4 = 0x11;
+    private static final byte TCPv6 = 0x21;
 
     // Undertow with HTTP listener and proxy-protocol enabled
     private Undertow undertow = Undertow.builder().addListener(
@@ -315,6 +324,179 @@ public void testProxyProtocolSSl() throws Exception {
         proxyProtocolRequestResponseCheck(request, requestHttp, """");
     }
 
+    @Test
+    public void testProxyProtocolV2Tcp4() throws Exception {
+        // simple valid request
+        byte[] header = createProxyHeaderV2(PROXY, TCPv4, 12, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,555);
+
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        String expectedResponse = ""result: /1.2.3.4:444 /5.6.7.8:555"";
+
+        proxyProtocolRequestResponseCheck(header, requestHttp, expectedResponse);
+
+        // check port range
+        header = createProxyHeaderV2(PROXY, TCPv4, 12, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),0,65535);
+        expectedResponse = ""result: /1.2.3.4:0 /5.6.7.8:65535"";
+        proxyProtocolRequestResponseCheck(header, requestHttp, expectedResponse);
+
+        // check extra len
+        header = createProxyHeaderV2(PROXY, TCPv4, 100, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,555);
+        expectedResponse = ""result: /1.2.3.4:444 /5.6.7.8:555"";
+        proxyProtocolRequestResponseCheck(header, requestHttp, expectedResponse);
+    }
+
+
+
+
+    /**
+     * Main cases are covered in plain-text HTTP connection tests. So here is just simple check that connection can
+     * be established also via HTTPS.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testProxyProtocolV2SSl() throws Exception {
+        // simple valid request
+        byte[] header = createProxyHeaderV2(PROXY, TCPv4, 12, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,555);
+
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        String expectedResponse = ""result: /1.2.3.4:444 /5.6.7.8:555"";
+
+
+        proxyProtocolRequestResponseCheck(header, requestHttp, expectedResponse);
+    }
+
+
+
+    @Test
+    public void testProxyProtocolV2Tcp4Negative() throws Exception {
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        byte[] request;
+
+        // missing destination port
+        request = createProxyHeaderV2(PROXY, TCPv4, 10, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,null);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // missing destination address
+        request = createProxyHeaderV2(PROXY, TCPv4, 8, InetAddress.getByName(""1.2.3.4""), null,444,555);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // invalid family
+        request = createProxyHeaderV2(PROXY, (byte) 0x42, 12, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,555);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // len too low
+        request = createProxyHeaderV2(PROXY, TCPv4, 4, InetAddress.getByName(""1.2.3.4""), null,null,null);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+    }
+
+    @Test
+    public void testProxyProtocolV2Tcp6() throws Exception {
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        byte[] request;
+
+        // simple valid request
+        request = createProxyHeaderV2(PROXY, TCPv6, 36, InetAddress.getByName(""fe80::56ee:75ff:fe44:85bc""), InetAddress.getByName(""fe80::5ec5:d4ff:fede:66d8""),444,555);
+        String expectedResponse = ""result: /fe80:0:0:0:56ee:75ff:fe44:85bc:444 /fe80:0:0:0:5ec5:d4ff:fede:66d8:555"";
+        proxyProtocolRequestResponseCheck(request, requestHttp, expectedResponse);
+
+        // check port range
+        request = createProxyHeaderV2(PROXY, TCPv6, 36, InetAddress.getByName(""fe80::56ee:75ff:fe44:85bc""), InetAddress.getByName(""fe80::5ec5:d4ff:fede:66d8""),0,65535);
+        expectedResponse = ""result: /fe80:0:0:0:56ee:75ff:fe44:85bc:0 /fe80:0:0:0:5ec5:d4ff:fede:66d8:65535"";
+        proxyProtocolRequestResponseCheck(request, requestHttp, expectedResponse);
+    }
+
+    @Test
+    public void testProxyProtocolV2Tcp6Negative() throws Exception {
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        byte[] request;
+
+        // missing destination port
+        request = createProxyHeaderV2(PROXY, TCPv6, 34, InetAddress.getByName(""fe80::56ee:75ff:fe44:85bc""), InetAddress.getByName(""fe80::5ec5:d4ff:fede:66d8""),444,null);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // missing destination address
+        request = createProxyHeaderV2(PROXY, TCPv6, 20, InetAddress.getByName(""1.2.3.4""), null,444,555);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // invalid family
+        request = createProxyHeaderV2(PROXY, (byte) 0x42, 36, InetAddress.getByName(""fe80::56ee:75ff:fe44:85bc""), InetAddress.getByName(""fe80::5ec5:d4ff:fede:66d8""),444,555);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // len too low
+        request = createProxyHeaderV2(PROXY, TCPv6, 16, InetAddress.getByName(""fe80::56ee:75ff:fe44:85bc""), null,null,null);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+    }
+
+    @Test
+    public void testProxyProtocolV2Local() throws Exception {
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        byte[] request;
+
+        // simple valid request
+        request = createProxyHeaderV2(LOCAL, (byte) 0, 0, null, null,null,null);
+        String expectedResponse = ""result: /127.0.0.1"";
+        proxyProtocolRequestResponseCheck(request, requestHttp, expectedResponse);
+    }
+
+    /**
+     * General negative tests for proxy-protocol. We expect that server closes connection sending no data.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testProxyProtocolV2Negative() throws Exception {
+        String requestHttp = ""GET / HTTP/1.0\r\n\r\n"";
+        byte[] request;
+
+        // wrong version
+        request = createProxyHeaderV2((byte) 0, TCPv4, 12, InetAddress.getByName(""1.2.3.4""), InetAddress.getByName(""5.6.7.8""),444,555);
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // wrong signature (starting with NAME)
+        request = new byte[]{NAME[0], 0x0, 0x0, 0x0};
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // wrong signature (starting with SIG)
+        request = new byte[]{SIG[0], 0x0, 0x0, 0x0};
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+
+        // wrong signature (starting with 0x0)
+        request = new byte[]{0x0, 0x0, 0x0, 0x0};
+        proxyProtocolRequestResponseCheck(request, requestHttp, """");
+    }
+
+
+
+    private static byte[] createProxyHeaderV2(Byte ver_cmd, Byte family, Integer len, InetAddress sourceAddress, InetAddress destAddress, Integer sourcePort, Integer destPort) {
+        ByteBuffer buffer = ByteBuffer.allocate(16 + len);
+        buffer.put(SIG);
+
+        if (ver_cmd != null) {
+            buffer.put((byte) (ver_cmd & 0xff)); // ver=2: V2, cmd=1: PROXY / 2: LOCAL
+        }
+        if (family != null) {
+            buffer.put((byte) (family & 0xff)); // 0x11: TCPv4 / 0x21: TCPv6
+        }
+        if (len != null) {
+            buffer.putShort((short) (len & 0xffff)); // len=12
+        }
+        if (sourceAddress != null) {
+            buffer.put(sourceAddress.getAddress());
+        }
+        if (destAddress != null) {
+            buffer.put(destAddress.getAddress());
+        }
+        if (sourcePort != null) {
+            buffer.putShort((short) (sourcePort & 0xffff));
+        }
+        if (destPort != null) {
+            buffer.putShort((short) (destPort & 0xffff));
+        }
+
+        return buffer.array();
+    }
+
     /**
      * Starts an undertow server with HTTPS listener and performs request to the server with given request proxy
      * string and HTTP request. Then response from the server is checked with given expected response string.
@@ -327,21 +509,31 @@ public void testProxyProtocolSSl() throws Exception {
      */
     private void proxyProtocolRequestResponseCheck(String requestProxy, String requestHttp, String expectedResponse)
             throws Exception {
+        proxyProtocolRequestResponseCheck(requestProxy.getBytes(StandardCharsets.US_ASCII), requestHttp, expectedResponse);
+    }
+
+    /**
+     * Starts an undertow server with HTTP listener and performs request to the server with given request string.
+     * Then response from the server is checked with given expected response string. Undertow is stopped in the end.
+     *
+     * @param request          request string that is send to server
+     * @param expectedResponse expected response string that we expect from the server
+     * @throws Exception
+     */
+    private void proxyProtocolRequestResponseCheck(byte[] request, String requestHttp, String expectedResponse) throws Exception {
         try {
-            undertowSsl.start();
-            int port = ((InetSocketAddress) undertowSsl.getListenerInfo().get(0).getAddress()).getPort();
+            undertow.start();
+            int port = ((InetSocketAddress) undertow.getListenerInfo().get(0).getAddress()).getPort();
             Socket s = new Socket(DefaultServer.getHostAddress(), port);
-            s.getOutputStream().write(requestProxy.getBytes(StandardCharsets.US_ASCII));
+            s.getOutputStream().write(request);
             // if expectedResponse is empty, we expect server to close connection due to bad request
             if (!expectedResponse.isEmpty()) {
-                s = DefaultServer.getClientSSLContext().getSocketFactory().createSocket(s, DefaultServer
-                        .getHostAddress(), port, true);
                 s.getOutputStream().write(requestHttp.getBytes(StandardCharsets.US_ASCII));
             }
             String result = FileUtils.readFile(s.getInputStream());
             Assert.assertTrue(result, result.contains(expectedResponse));
         } finally {
-            undertowSsl.stop();
+            undertow.stop();
         }
     }
 ",2018-12-17T04:38:16Z,314
"@@ -26,7 +26,7 @@
 /**
  * @author Stuart Douglas
  */
-public class ConfiguredClientEndpoint {
+public class ConfiguredClientEndpoint extends SessionContainer {
 
     private final ClientEndpointConfig config;
     private final AnnotatedEndpointFactory factory;
@@ -40,6 +40,10 @@ public ConfiguredClientEndpoint(final ClientEndpointConfig config, final Annotat
         this.instanceFactory = instanceFactory;
     }
 
+    public ConfiguredClientEndpoint() {
+        this(null, null, null, null);
+    }
+
     public ClientEndpointConfig getConfig() {
         return config;
     }",2015-07-09T14:12:16Z,315
"@@ -22,25 +22,19 @@
 import io.undertow.util.PathTemplate;
 import io.undertow.websockets.jsr.annotated.AnnotatedEndpointFactory;
 
-import javax.websocket.Session;
 import javax.websocket.server.ServerEndpointConfig;
-import java.util.Collections;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * @author Stuart Douglas
  */
-public class ConfiguredServerEndpoint {
+public class ConfiguredServerEndpoint extends SessionContainer {
 
     private final ServerEndpointConfig endpointConfiguration;
     private final AnnotatedEndpointFactory annotatedEndpointFactory;
     private final InstanceFactory<?> endpointFactory;
     private final PathTemplate pathTemplate;
     private final EncodingFactory encodingFactory;
-    private final Set<Session> openSessions = Collections.newSetFromMap(new ConcurrentHashMap<Session, Boolean>());
 
-    private volatile int waiterCount;
 
     public ConfiguredServerEndpoint(final ServerEndpointConfig endpointConfiguration, final InstanceFactory<?> endpointFactory, final PathTemplate pathTemplate, final EncodingFactory encodingFactory, AnnotatedEndpointFactory annotatedEndpointFactory) {
         this.endpointConfiguration = endpointConfiguration;
@@ -66,44 +60,9 @@ public EncodingFactory getEncodingFactory() {
         return encodingFactory;
     }
 
-    public Set<Session> getOpenSessions() {
-        return openSessions;
-    }
-
-    public void addOpenSession(Session session) {
-        openSessions.add(session);
-    }
-
-    public void removeOpenSession(Session session) {
-        synchronized (this) {
-            openSessions.remove(session);
-            if (waiterCount > 0 && openSessions.isEmpty()) {
-                notifyAll();
-            }
-        }
-    }
-
-    public void awaitClose(long timeout) {
-        waiterCount++;
-        long end = System.currentTimeMillis() + timeout;
-        synchronized (this) {
-            if(openSessions.isEmpty()) {
-                return;
-            }
-            try {
-                while (System.currentTimeMillis() < end) {
-                    wait(end - System.currentTimeMillis());
-                }
-            } catch (InterruptedException e) {
-                //ignore
-                return;
-            } finally {
-                waiterCount--;
-            }
-        }
-    }
 
     public AnnotatedEndpointFactory getAnnotatedEndpointFactory() {
         return annotatedEndpointFactory;
     }
+
 }",2015-07-09T14:12:16Z,316
"@@ -116,8 +116,8 @@ public void release() {
                 endpointInstance = (InstanceHandle<Endpoint>) instance;
             }
 
-            UndertowSession session = new UndertowSession(channel, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), exchange.getRequestParameters(), this, principal, endpointInstance, config.getEndpointConfiguration(), exchange.getQueryString(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()), config.getOpenSessions(), channel.getSubProtocol(), Collections.<Extension>emptyList(), null);
-            config.getOpenSessions().add(session);
+            UndertowSession session = new UndertowSession(channel, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), exchange.getRequestParameters(), this, principal, endpointInstance, config.getEndpointConfiguration(), exchange.getQueryString(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()), config, channel.getSubProtocol(), Collections.<Extension>emptyList(), null);
+            config.addOpenSession(session);
 
             session.setMaxBinaryMessageBufferSize(getContainer().getDefaultMaxBinaryMessageBufferSize());
             session.setMaxTextMessageBufferSize(getContainer().getDefaultMaxTextMessageBufferSize());",2015-07-09T14:12:16Z,317
"@@ -70,7 +70,15 @@ enum FrameType {
     protected FrameHandler(UndertowSession session, Endpoint endpoint) {
         this.session = session;
         this.endpoint = endpoint;
-        this.executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());
+
+        final Executor executor;
+        if (session.getContainer().isDispatchToWorker()) {
+            executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());
+        } else {
+            executor = session.getWebSocketChannel().getIoThread();
+        }
+
+        this.executor = executor;
     }
 
     @Override
@@ -466,6 +474,10 @@ boolean isPartialHandler() {
 
     }
 
+    public Executor getExecutor() {
+        return executor;
+    }
+
     UndertowSession getSession() {
         return session;
     }",2015-07-09T14:12:16Z,318
"@@ -23,6 +23,7 @@
 import io.undertow.servlet.websockets.ServletWebSocketHttpExchange;
 import io.undertow.util.Headers;
 import io.undertow.util.PathTemplateMatcher;
+import io.undertow.util.StatusCodes;
 import io.undertow.websockets.WebSocketConnectionCallback;
 import io.undertow.websockets.core.WebSocketChannel;
 import io.undertow.websockets.core.protocol.Handshake;
@@ -55,7 +56,6 @@
  * The use of a filter rather than a servlet allows for normal HTTP requests to be served from the same location
  * as a web socket endpoint if no upgrade header is found.
  * <p>
- * TODO: this needs a lot of work
  *
  * @author Stuart Douglas
  */
@@ -64,6 +64,7 @@ public class JsrWebSocketFilter implements Filter {
     private WebSocketConnectionCallback callback;
     private PathTemplateMatcher<WebSocketHandshakeHolder> pathTemplateMatcher;
     private Set<WebSocketChannel> peerConnections;
+    private ServerWebSocketContainer container;
 
     protected WebSocketHandshakeHolder handshakes(ConfiguredServerEndpoint config) {
         List<Handshake> handshakes = new ArrayList<>();
@@ -92,7 +93,7 @@ protected WebSocketHandshakeHolder handshakes(ConfiguredServerEndpoint config, L
     @Override
     public void init(final FilterConfig filterConfig) throws ServletException {
         peerConnections = Collections.newSetFromMap(new ConcurrentHashMap<WebSocketChannel, Boolean>());
-        ServerWebSocketContainer container = (ServerWebSocketContainer) filterConfig.getServletContext().getAttribute(ServerContainer.class.getName());
+        container = (ServerWebSocketContainer) filterConfig.getServletContext().getAttribute(ServerContainer.class.getName());
         container.deploymentComplete();
         pathTemplateMatcher = new PathTemplateMatcher<>();
         WebSocketDeploymentInfo info = (WebSocketDeploymentInfo)filterConfig.getServletContext().getAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME);
@@ -133,6 +134,10 @@ public void doFilter(final ServletRequest request, final ServletResponse respons
                 }
 
                 if (handshaker != null) {
+                    if(container.isClosed()) {
+                        resp.sendError(StatusCodes.SERVICE_UNAVAILABLE);
+                        return;
+                    }
                     facade.putAttachment(HandshakeUtil.PATH_PARAMS, matchResult.getParameters());
                     final Handshake selected = handshaker;
                     facade.upgradeChannel(new HttpUpgradeListener() {",2015-07-09T14:12:16Z,21
"@@ -24,6 +24,7 @@
 import io.undertow.servlet.spec.ServletContextImpl;
 import io.undertow.servlet.util.ConstructorInstanceFactory;
 import io.undertow.servlet.util.ImmediateInstanceHandle;
+import io.undertow.util.CopyOnWriteMap;
 import io.undertow.util.PathTemplate;
 import io.undertow.websockets.WebSocketExtension;
 import io.undertow.websockets.client.WebSocketClient;
@@ -59,7 +60,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
@@ -84,7 +84,7 @@ public class ServerWebSocketContainer implements ServerContainer, Closeable {
 
     private final ClassIntrospecter classIntrospecter;
 
-    private final Map<Class<?>, ConfiguredClientEndpoint> clientEndpoints = new HashMap<>();
+    private final Map<Class<?>, ConfiguredClientEndpoint> clientEndpoints = new CopyOnWriteMap<>();
 
     private final List<ConfiguredServerEndpoint> configuredServerEndpoints = new ArrayList<>();
 
@@ -110,9 +110,12 @@ public class ServerWebSocketContainer implements ServerContainer, Closeable {
     private ServletContextImpl contextToAddFilter = null;
 
     private final List<WebsocketClientSslProvider> clientSslProviders;
+    private final List<PauseListener> pauseListeners = new ArrayList<>();
 
     private volatile boolean closed = false;
 
+
+
     public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final XnioWorker xnioWorker, Pool<ByteBuffer> bufferPool, ThreadSetupAction threadSetupAction, boolean dispatchToWorker, boolean clientMode) {
         this(classIntrospecter, ServerWebSocketContainer.class.getClassLoader(), xnioWorker, bufferPool, threadSetupAction, dispatchToWorker, null, null);
     }
@@ -290,9 +293,18 @@ public void handleDone(WebSocketChannel data, Object attachment) {
             }
             extensions.add(ExtensionImpl.create(e));
         }
+        ConfiguredClientEndpoint configured = clientEndpoints.get(endpointInstance.getClass());
+        if(configured == null) {
+            synchronized (clientEndpoints) {
+                configured = clientEndpoints.get(endpointInstance.getClass());
+                if(configured == null) {
+                    clientEndpoints.put(endpointInstance.getClass(), configured = new ConfiguredClientEndpoint());
+                }
+            }
+        }
 
         EncodingFactory encodingFactory = EncodingFactory.createFactory(classIntrospecter, cec.getDecoders(), cec.getEncoders());
-        UndertowSession undertowSession = new UndertowSession(channel, connectionBuilder.getUri(), Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec, connectionBuilder.getUri().getQuery(), encodingFactory.createEncoding(cec), new HashSet<Session>(), clientNegotiation.getSelectedSubProtocol(), extensions, connectionBuilder);
+        UndertowSession undertowSession = new UndertowSession(channel, connectionBuilder.getUri(), Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec, connectionBuilder.getUri().getQuery(), encodingFactory.createEncoding(cec), configured, clientNegotiation.getSelectedSubProtocol(), extensions, connectionBuilder);
         endpointInstance.onOpen(undertowSession, cec);
         channel.resumeReceives();
 
@@ -369,7 +381,7 @@ public void handleDone(WebSocketChannel data, Object attachment) {
             subProtocol = connectionBuilder.getClientNegotiation().getSelectedSubProtocol();
         }
 
-        UndertowSession undertowSession = new UndertowSession(channel, connectionBuilder.getUri(), Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec.getConfig(), connectionBuilder.getUri().getQuery(), cec.getEncodingFactory().createEncoding(cec.getConfig()), new HashSet<Session>(), subProtocol, extensions, connectionBuilder);
+        UndertowSession undertowSession = new UndertowSession(channel, connectionBuilder.getUri(), Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec.getConfig(), connectionBuilder.getUri().getQuery(), cec.getEncodingFactory().createEncoding(cec.getConfig()), cec, subProtocol, extensions, connectionBuilder);
         endpointInstance.onOpen(undertowSession, cec.getConfig());
         channel.resumeReceives();
 
@@ -455,7 +467,7 @@ public void addEndpoint(final Class<?> endpoint) throws DeploymentException {
         addEndpointInternal(endpoint, true);
     }
 
-    private void addEndpointInternal(final Class<?> endpoint, boolean requiresCreation) throws DeploymentException {
+    private synchronized void addEndpointInternal(final Class<?> endpoint, boolean requiresCreation) throws DeploymentException {
         ServerEndpoint serverEndpoint = endpoint.getAnnotation(ServerEndpoint.class);
         ClientEndpoint clientEndpoint = endpoint.getAnnotation(ClientEndpoint.class);
         if (serverEndpoint != null) {
@@ -631,16 +643,7 @@ public void setContextToAddFilter(ServletContextImpl contextToAddFilter) {
 
     @Override
     public synchronized void close() {
-        closed = true;
-        for (ConfiguredServerEndpoint endpoint : configuredServerEndpoints) {
-            for (Session session : endpoint.getOpenSessions()) {
-                try {
-                    session.close(new CloseReason(CloseReason.CloseCodes.GOING_AWAY, """"));
-                } catch (Exception e) {
-                    JsrWebSocketLogger.ROOT_LOGGER.couldNotCloseOnUndeploy(e);
-                }
-            }
-        }
+        doClose();
         //wait up to 10 seconds for them to close
         long end = currentTimeMillis() + 10000;
         for (ConfiguredServerEndpoint endpoint : configuredServerEndpoints) {
@@ -718,11 +721,92 @@ public void beforeRequest(Map<String, List<String>> headers) {
         }
     }
 
+    /**
+     * Pauses the container
+     * @param listener
+     */
+    public synchronized void pause(PauseListener listener) {
+        closed = true;
+        if(listener != null) {
+            pauseListeners.add(listener);
+        }
+        for (ConfiguredServerEndpoint endpoint : configuredServerEndpoints) {
+            for (final Session session : endpoint.getOpenSessions()) {
+                ((UndertowSession)session).getExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            session.close(new CloseReason(CloseReason.CloseCodes.GOING_AWAY, """"));
+                        } catch (Exception e) {
+                            JsrWebSocketLogger.ROOT_LOGGER.couldNotCloseOnUndeploy(e);
+                        }
+                    }
+                });
+            }
+        }
+
+        Runnable done = new Runnable() {
+
+            int count = configuredServerEndpoints.size();
+
+            @Override
+            public synchronized void run() {
+                synchronized (ServerWebSocketContainer.this) {
+                    count--;
+                    if (count == 0) {
+                        for(PauseListener p : pauseListeners) {
+                            p.paused();
+                        }
+                        pauseListeners.clear();
+                    }
+                }
+            }
+        };
+
+        for (ConfiguredServerEndpoint endpoint : configuredServerEndpoints) {
+            endpoint.notifyClosed(done);
+        }
+    }
+
+    private void doClose() {
+        closed = true;
+        for (ConfiguredServerEndpoint endpoint : configuredServerEndpoints) {
+            for (Session session : endpoint.getOpenSessions()) {
+                try {
+                    session.close(new CloseReason(CloseReason.CloseCodes.GOING_AWAY, """"));
+                } catch (Exception e) {
+                    JsrWebSocketLogger.ROOT_LOGGER.couldNotCloseOnUndeploy(e);
+                }
+            }
+        }
+    }
+
+    /**
+     * resumes a paused container
+     */
+    public synchronized void resume() {
+        closed = false;
+        for(PauseListener p : pauseListeners) {
+            p.resumed();
+        }
+        pauseListeners.clear();
+    }
+
     public WebSocketReconnectHandler getWebSocketReconnectHandler() {
         return webSocketReconnectHandler;
     }
 
     public boolean isClosed() {
         return closed;
     }
+
+    public interface PauseListener {
+        void paused();
+
+        void resumed();
+    }
+
+    public boolean isDispatchToWorker() {
+        return dispatchToWorker;
+    }
 }",2015-07-09T14:12:16Z,319
"@@ -0,0 +1,87 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.websockets.jsr;
+
+import javax.websocket.Session;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * @author Stuart Douglas
+ */
+public class SessionContainer {
+
+    private Runnable doneTask;
+    private volatile int waiterCount;
+    private final Set<Session> openSessions = Collections.newSetFromMap(new ConcurrentHashMap<Session, Boolean>());
+
+    public Set<Session> getOpenSessions() {
+        return Collections.unmodifiableSet(openSessions);
+    }
+
+    public void addOpenSession(Session session) {
+        synchronized (this) {
+            openSessions.add(session);
+        }
+    }
+
+    public void removeOpenSession(Session session) {
+        synchronized (this) {
+            openSessions.remove(session);
+            if (waiterCount > 0 && openSessions.isEmpty()) {
+                notifyAll();
+                if(doneTask != null) {
+                    doneTask.run();
+                    doneTask = null;
+                }
+            }
+        }
+    }
+
+    public void awaitClose(long timeout) {
+        waiterCount++;
+        long end = System.currentTimeMillis() + timeout;
+        synchronized (this) {
+            if(openSessions.isEmpty()) {
+                return;
+            }
+            try {
+                while (System.currentTimeMillis() < end) {
+                    wait(end - System.currentTimeMillis());
+                }
+            } catch (InterruptedException e) {
+                //ignore
+                return;
+            } finally {
+                waiterCount--;
+            }
+        }
+    }
+
+    public void notifyClosed(Runnable done) {
+        synchronized (this) {
+            if(openSessions.isEmpty()) {
+                done.run();
+            } else {
+                this.doneTask = done;
+            }
+        }
+    }
+}",2015-07-09T14:12:16Z,320
"@@ -43,6 +43,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -67,7 +68,7 @@ public final class UndertowSession implements Session {
     private final InstanceHandle<Endpoint> endpoint;
     private final Encoding encoding;
     private final AtomicBoolean closed = new AtomicBoolean();
-    private final Set<Session> openSessions;
+    private final SessionContainer openSessions;
     private final String subProtocol;
     private final List<Extension> extensions;
     private final WebSocketClient.ConnectionBuilder clientConnectionBuilder;
@@ -81,8 +82,9 @@ public final class UndertowSession implements Session {
     UndertowSession(WebSocketChannel webSocketChannel, URI requestUri, Map<String, String> pathParameters,
                     Map<String, List<String>> requestParameterMap, EndpointSessionHandler handler, Principal user,
                     InstanceHandle<Endpoint> endpoint, EndpointConfig config, final String queryString,
-                    final Encoding encoding, final Set<Session> openSessions, final String subProtocol,
+                    final Encoding encoding, final SessionContainer openSessions, final String subProtocol,
                     final List<Extension> extensions, WebSocketClient.ConnectionBuilder clientConnectionBuilder) {
+        assert openSessions != null;
         this.webSocketChannel = webSocketChannel;
         this.queryString = queryString;
         this.encoding = encoding;
@@ -345,7 +347,7 @@ public RemoteEndpoint.Basic getBasicRemote() {
 
     @Override
     public Set<Session> getOpenSessions() {
-        return new HashSet<>(openSessions);
+        return new HashSet<>(openSessions.getOpenSessions());
     }
 
     @Override
@@ -354,12 +356,18 @@ public List<Extension> getNegotiatedExtensions() {
     }
 
     void close0() {
-        openSessions.remove(this);
-        try {
-            endpoint.release();
-        } finally {
-            encoding.close();
-        }
+        //we use the executor to preserve ordering
+        getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                openSessions.removeOpenSession(UndertowSession.this);
+                try {
+                    endpoint.release();
+                } finally {
+                    encoding.close();
+                }
+            }
+        });
     }
 
     public Encoding getEncoding() {
@@ -395,4 +403,8 @@ public void run() {
             }
         });
     }
+
+    public Executor getExecutor() {
+        return frameHandler.getExecutor();
+    }
 }",2015-07-09T14:12:16Z,321
"@@ -21,7 +21,6 @@
 import io.undertow.UndertowLogger;
 import io.undertow.servlet.api.InstanceHandle;
 import io.undertow.websockets.core.WebSocketLogger;
-import io.undertow.websockets.jsr.OrderedExecutor;
 import io.undertow.websockets.jsr.UndertowSession;
 
 import javax.websocket.CloseReason;
@@ -35,15 +34,13 @@
 import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.Executor;
 
 /**
  * @author Stuart Douglas
  */
 public class AnnotatedEndpoint extends Endpoint {
 
     private final InstanceHandle<?> instance;
-    private Executor executor;
 
     private final BoundMethod webSocketOpen;
     private final BoundMethod webSocketClose;
@@ -67,7 +64,6 @@ public class AnnotatedEndpoint extends Endpoint {
     @Override
     public void onOpen(final Session session, final EndpointConfig endpointConfiguration) {
         this.released = false;
-        this.executor = new OrderedExecutor(((UndertowSession)session).getWebSocketChannel().getWorker());
 
 
         final UndertowSession s = (UndertowSession) session;
@@ -164,7 +160,7 @@ public void run() {
     }
 
     private void invokeMethod(final Map<Class<?>, Object> params, final BoundMethod method, final UndertowSession session) {
-        session.getContainer().invokeEndpointMethod(executor, new Runnable() {
+        session.getContainer().invokeEndpointMethod(session.getExecutor(), new Runnable() {
             @Override
             public void run() {
                 if(!released) {
@@ -200,7 +196,7 @@ public void onClose(final Session session, final CloseReason closeReason) {
             params.put(Session.class, session);
             params.put(Map.class, session.getPathParameters());
             params.put(CloseReason.class, closeReason);
-            ((UndertowSession) session).getContainer().invokeEndpointMethod(executor, new Runnable() {
+            ((UndertowSession) session).getContainer().invokeEndpointMethod(((UndertowSession)session).getExecutor(), new Runnable() {
                         @Override
                         public void run() {
                             if(!released) {
@@ -228,7 +224,7 @@ public void onError(final Session session, final Throwable thr) {
             params.put(Session.class, session);
             params.put(Throwable.class, thr);
             params.put(Map.class, session.getPathParameters());
-            ((UndertowSession) session).getContainer().invokeEndpointMethod(executor, new Runnable() {
+            ((UndertowSession) session).getContainer().invokeEndpointMethod(((UndertowSession)session).getExecutor(), new Runnable() {
                 @Override
                 public void run() {
                     if(!released) {",2015-07-09T14:12:16Z,322
"@@ -0,0 +1,36 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.websockets.jsr.test.suspendresume;
+
+import javax.websocket.OnMessage;
+import javax.websocket.server.ServerEndpoint;
+
+/**
+ * @author Stuart Douglas
+ */
+@ServerEndpoint(value = ""/"")
+public class SuspendResumeEndpoint {
+
+    @OnMessage
+    public String handleMessage(final String message) throws InterruptedException {
+        Thread.sleep(2000);
+        return message;
+    }
+
+}",2015-07-09T14:12:16Z,323
"@@ -0,0 +1,191 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.websockets.jsr.test.suspendresume;
+
+import io.undertow.Handlers;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.servlet.test.util.TestResourceLoader;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpOneOnly;
+import io.undertow.websockets.client.WebSocketClient;
+import io.undertow.websockets.core.AbstractReceiveListener;
+import io.undertow.websockets.core.BufferedBinaryMessage;
+import io.undertow.websockets.core.BufferedTextMessage;
+import io.undertow.websockets.core.StreamSourceFrameChannel;
+import io.undertow.websockets.core.WebSocketChannel;
+import io.undertow.websockets.core.WebSocketFrameType;
+import io.undertow.websockets.core.WebSockets;
+import io.undertow.websockets.jsr.ServerWebSocketContainer;
+import io.undertow.websockets.jsr.WebSocketDeploymentInfo;
+import io.undertow.websockets.jsr.test.TestMessagesReceivedInOrder;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.xnio.ByteBufferSlicePool;
+import org.xnio.ChannelListener;
+import org.xnio.IoUtils;
+import org.xnio.channels.Channels;
+import org.xnio.http.UpgradeFailedException;
+
+import javax.servlet.ServletException;
+import java.io.IOException;
+import java.net.URI;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+@HttpOneOnly
+public class SuspendResumeTestCase {
+
+    private static volatile ServerWebSocketContainer serverContainer;
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+
+        DeploymentInfo builder = new DeploymentInfo()
+                .setClassLoader(TestMessagesReceivedInOrder.class.getClassLoader())
+                .setContextPath(""/"")
+                .setResourceManager(new TestResourceLoader(TestMessagesReceivedInOrder.class))
+                .setClassIntrospecter(TestClassIntrospector.INSTANCE)
+                .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME,
+                        new WebSocketDeploymentInfo()
+                                .setBuffers(new ByteBufferSlicePool(100, 1000))
+                                .setWorker(DefaultServer.getWorker())
+                                .addListener(new WebSocketDeploymentInfo.ContainerReadyListener() {
+                                    @Override
+                                    public void ready(ServerWebSocketContainer c) {
+                                        serverContainer = c;
+                                    }
+                                })
+                                .addEndpoint(SuspendResumeEndpoint.class)
+                )
+                .setDeploymentName(""servletContext.war"");
+
+
+        DeploymentManager manager = container.addDeployment(builder);
+        manager.deploy();
+
+
+        DefaultServer.setRootHandler(Handlers.path().addPrefixPath(""/"", manager.start()));
+    }
+
+
+    @Test
+    public void testConnectionWaitsForMessageEnd() throws Exception {
+        final CountDownLatch done = new CountDownLatch(1);
+        final AtomicReference<String> message = new AtomicReference<>();
+        WebSocketChannel channel = WebSocketClient.connectionBuilder(DefaultServer.getWorker(), DefaultServer.getBufferPool(), new URI(DefaultServer.getDefaultServerURL() + ""/""))
+                .connect().get();
+        channel.getReceiveSetter().set(new AbstractReceiveListener() {
+            @Override
+            protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage msg) throws IOException {
+                message.set(msg.getData());
+                done.countDown();
+            }
+
+            @Override
+            protected void onError(WebSocketChannel channel, Throwable error) {
+                error.printStackTrace();
+                message.set(""error"");
+                done.countDown();
+            }
+
+            @Override
+            protected void onFullCloseMessage(WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {
+                message.getData().free();
+                done.countDown();
+            }
+        });
+        channel.resumeReceives();
+        Assert.assertTrue(channel.isOpen());
+        WebSockets.sendText(""Hello World"", channel, null);
+        Thread.sleep(500);
+        serverContainer.pause(null);
+        try {
+            Assert.assertTrue(done.await(10, TimeUnit.SECONDS));
+            Assert.assertEquals(""Hello World"", message.get());
+        } finally {
+            serverContainer.resume();
+        }
+    }
+
+    @Test
+    public void testConnectionClosedOnPause() throws Exception {
+        final CountDownLatch done = new CountDownLatch(1);
+        final AtomicReference<String> message = new AtomicReference<>();
+        WebSocketChannel channel = WebSocketClient.connectionBuilder(DefaultServer.getWorker(), DefaultServer.getBufferPool(), new URI(DefaultServer.getDefaultServerURL() + ""/""))
+                .connect().get();
+        channel.getReceiveSetter().set(new ChannelListener<WebSocketChannel>() {
+            @Override
+            public void handleEvent(WebSocketChannel channel) {
+                try {
+                    StreamSourceFrameChannel res = channel.receive();
+                    if(res == null) {
+                        return;
+                    }
+                    if (res.getType() == WebSocketFrameType.CLOSE) {
+                        message.set(""closed"");
+                        done.countDown();
+                    }
+                    Channels.drain(res, Long.MAX_VALUE);
+                } catch (IOException e) {
+                    message.set(""error"");
+                    done.countDown();
+                }
+            }
+        });
+        channel.resumeReceives();
+        Assert.assertTrue(channel.isOpen());
+        Thread.sleep(500);
+        serverContainer.pause(null);
+        try {
+            Assert.assertTrue(done.await(10, TimeUnit.SECONDS));
+            Assert.assertEquals(""closed"", message.get());
+        } finally {
+            serverContainer.resume();
+        }
+    }
+
+
+    @Test
+    public void testRejectWhenSuspended() throws Exception {
+        try {
+            serverContainer.pause(null);
+            WebSocketChannel channel = WebSocketClient.connectionBuilder(DefaultServer.getWorker(), DefaultServer.getBufferPool(), new URI(DefaultServer.getDefaultServerURL() + ""/""))
+                    .connect().get();
+            IoUtils.safeClose(channel);
+            Assert.fail();
+        } catch (UpgradeFailedException e) {
+            //expected
+        } finally {
+            serverContainer.resume();
+        }
+
+    }
+}",2015-07-09T14:12:16Z,324
"@@ -586,7 +586,7 @@ private String extractCharset(HeaderMap headers) {
     public String getHostName() {
         String host = requestHeaders.getFirst(Headers.HOST);
         if (host == null) {
-            host = getDestinationAddress().getAddress().getHostAddress();
+            host = getDestinationAddress().getHostString();
         } else {
             if (host.startsWith(""["")) {
                 host = host.substring(1, host.indexOf(']'));
@@ -609,8 +609,9 @@ public String getHostName() {
     public String getHostAndPort() {
         String host = requestHeaders.getFirst(Headers.HOST);
         if (host == null) {
-            host = NetworkUtils.formatPossibleIpv6Address(getDestinationAddress().getAddress().getHostAddress());
-            int port = getDestinationAddress().getPort();
+            InetSocketAddress address = getDestinationAddress();
+            host = NetworkUtils.formatPossibleIpv6Address(address.getHostString());
+            int port = address.getPort();
             if (!((getRequestScheme().equals(""http"") && port == 80)
                     || (getRequestScheme().equals(""https"") && port == 8080))) {
                 host = host + "":"" + port;",2015-01-05T20:58:54Z,132
"@@ -899,7 +899,7 @@ public int getRemotePort() {
 
     @Override
     public String getLocalName() {
-        return exchange.getDestinationAddress().getHostName();
+        return exchange.getDestinationAddress().getHostString();
     }
 
     @Override",2015-01-05T20:58:54Z,147
"@@ -1016,7 +1016,7 @@ public void addCloseTask(final ChannelListener<C> task) {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + ""[ "" + (receiver == null ? ""No Receiver"" : receiver.toString()) + "" "" + pendingFrames.toString() + "" -- "" + heldFrames.toString() + "" -- "" + newFrames.toString() + ""]"";
+        return getClass().getSimpleName() + "" peer "" + channel.getPeerAddress() + "" local "" + channel.getLocalAddress() + ""[ "" + (receiver == null ? ""No Receiver"" : receiver.toString()) + "" "" + pendingFrames.toString() + "" -- "" + heldFrames.toString() + "" -- "" + newFrames.toString() + ""]"";
     }
 
     protected StreamConnection getUnderlyingConnection() {",2016-01-21T04:42:32Z,168
"@@ -18,15 +18,18 @@
 
 package io.undertow.util;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+
 import io.undertow.UndertowMessages;
 import io.undertow.server.HttpServerExchange;
 
-import java.io.UnsupportedEncodingException;
-
 /**
  * Utilities for dealing with URLs
  *
  * @author Stuart Douglas
+ * @author Andre Schaefer
  */
 public class URLUtils {
 
@@ -310,4 +313,23 @@ public static String normalizeSlashes(final String path) {
 
         return path;
     }
+
+
+	/**
+	 * Test if provided location is an absolute URI or not.
+	 *
+	 * @param location location to check, null = relative, having scheme = absolute
+	 * @return true if location is considered absolute
+	 */
+	public static boolean isAbsoluteUrl(String location) {
+		if (location != null && location.length() > 0 && location.contains("":"")){
+			try {
+				URI uri = new URI(location);
+				return uri.getScheme() != null;
+			} catch (URISyntaxException e) {
+				// ignore invalid locations and consider not absolute
+			}
+		}
+		return false;
+	}
 }",2018-03-14T18:52:11Z,276
"@@ -26,9 +26,10 @@
 
 import java.nio.charset.Charset;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 /**
  * @author Oleksandr Radchykov
+ * @author Andre Schaefer
  */
 @RunWith(Parameterized.class)
 @Category(UnitTest.class)
@@ -58,4 +59,35 @@ public void testDecodingURLMustNotMutateSpaceSymbolsCaseIfSpaceDecodingDisabled(
         assertEquals(url, result);
     }
 
+	@Test
+	public void testIsAbsoluteUrlRecognizingAbsolutUrls() {
+		assertTrue(URLUtils.isAbsoluteUrl(""https://some.valid.url:8080/path?query=val""));
+		assertTrue(URLUtils.isAbsoluteUrl(""http://some.valid.url:8080/path?query=val""));
+		assertTrue(URLUtils.isAbsoluteUrl(""http://some.valid.url""));
+	}
+
+	@Test
+	public void testIsAbsoluteUrlRecognizingAppUrls() {
+		assertTrue(URLUtils.isAbsoluteUrl(""com.example.app:/oauth2redirect/example-provider""));
+		assertTrue(URLUtils.isAbsoluteUrl(""com.example.app:/oauth2redirect/example-provider?query=val""));
+	}
+
+	@Test
+	public void testIsAbsoluteUrlRecognizingRelativeUrls() {
+		assertFalse(URLUtils.isAbsoluteUrl(""relative""));
+		assertFalse(URLUtils.isAbsoluteUrl(""relative/path""));
+		assertFalse(URLUtils.isAbsoluteUrl(""relative/path?query=val""));
+		assertFalse(URLUtils.isAbsoluteUrl(""/root/relative/path""));
+	}
+
+	@Test
+	public void testIsAbsoluteUrlRecognizingEmptyOrNullAsRelative() {
+		assertFalse(URLUtils.isAbsoluteUrl(null));
+		assertFalse(URLUtils.isAbsoluteUrl(""""));
+	}
+
+	@Test
+	public void testIsAbsoluteUrlIgnoresSyntaxErrorsAreNotAbsolute() {
+		assertFalse(URLUtils.isAbsoluteUrl("":""));
+	}
 }",2018-03-14T18:52:11Z,325
"@@ -55,6 +55,8 @@
 import io.undertow.util.RedirectBuilder;
 import io.undertow.util.StatusCodes;
 
+import static io.undertow.util.URLUtils.isAbsoluteUrl;
+
 
 /**
  * @author Stuart Douglas
@@ -189,7 +191,7 @@ public void sendRedirect(final String location) throws IOException {
         resetBuffer();
         setStatus(StatusCodes.FOUND);
         String realPath;
-        if (location.contains(""://"")) {//absolute url
+        if (isAbsoluteUrl(location)) {//absolute url
             exchange.getResponseHeaders().put(Headers.LOCATION, location);
         } else {
             if (location.startsWith(""/"")) {",2018-03-14T18:52:11Z,170
"@@ -25,13 +25,15 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.junit.Assert;
+import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import io.undertow.security.handlers.SinglePortConfidentialityHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.ProxyIgnore;
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.FileUtils;
 import io.undertow.util.HttpString;
@@ -45,8 +47,9 @@
 @RunWith(DefaultServer.class)
 public class SimpleConfidentialRedirectTestCase {
 
-    @Test
-    public void simpleRedirectTestCase() throws IOException, GeneralSecurityException {
+
+    @BeforeClass
+    public static void setup() throws IOException {
         DefaultServer.startSSLServer();
 
         HttpHandler current = new HttpHandler() {
@@ -61,23 +64,36 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         current = new SinglePortConfidentialityHandler(current, DefaultServer.getHostSSLPort(""default""));
 
         DefaultServer.setRootHandler(current);
+    }
+
+    public static void stop() throws IOException {
+        DefaultServer.stopSSLServer();
+    }
+
+    @Test
+    public void simpleRedirectTestCase() throws IOException, GeneralSecurityException {
         TestHttpClient client = new TestHttpClient();
         client.setSSLContext(DefaultServer.getClientSSLContext());
         try {
             sendRequest(client, ""/foo"");
             sendRequest(client, ""/foo+bar"");
             sendRequest(client, ""/foo+bar;aa"");
 
-            //now we need to test what happens if the client send a full URI
-            //see UNDERTOW-874
-            Socket socket = new Socket(DefaultServer.getHostAddress(), DefaultServer.getHostPort());
-            socket.getOutputStream().write((""GET "" + DefaultServer.getDefaultServerURL() + ""/foo HTTP/1.0\r\n\r\n"").getBytes(StandardCharsets.UTF_8));
-            String result = FileUtils.readFile(socket.getInputStream());
-            Assert.assertTrue(result.contains(""Location: https://127.0.0.1:7778/foo""));
 
         } finally {
             client.getConnectionManager().shutdown();
-            DefaultServer.stopSSLServer();
+        }
+    }
+
+    @ProxyIgnore
+    public void testRedirectWithFullURLInPath() throws IOException {
+        DefaultServer.isProxy();
+        //now we need to test what happens if the client send a full URI
+        //see UNDERTOW-874
+        try (Socket socket = new Socket(DefaultServer.getHostAddress(), DefaultServer.getHostPort())) {
+            socket.getOutputStream().write((""GET "" + DefaultServer.getDefaultServerURL() + ""/foo HTTP/1.0\r\n\r\n"").getBytes(StandardCharsets.UTF_8));
+            String result = FileUtils.readFile(socket.getInputStream());
+            Assert.assertTrue(result.contains(""Location: "" + DefaultServer.getDefaultServerSSLAddress() + ""/foo""));
         }
     }
 ",2016-10-25T01:51:08Z,57
"@@ -23,6 +23,7 @@
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.net.URI;
 import java.security.KeyManagementException;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
@@ -203,6 +204,16 @@ public SslConnection wrapExistingConnection(StreamConnection connection, OptionM
         return new UndertowSslConnection(connection, createSSLEngine(sslContext, optionMap, (InetSocketAddress) connection.getPeerAddress(), clientMode), bufferPool);
     }
 
+    public SslConnection wrapExistingConnection(StreamConnection connection, OptionMap optionMap, URI destinationURI) {
+        SSLEngine sslEngine = createSSLEngine(sslContext, optionMap, (InetSocketAddress) connection.getPeerAddress(), true);
+        SSLParameters sslParameters = sslEngine.getSSLParameters();
+        if (sslParameters.getServerNames() == null || sslParameters.getServerNames().isEmpty()) {
+            sslParameters.setServerNames(Collections.singletonList(new SNIHostName(destinationURI.getHost())));
+            sslEngine.setSSLParameters(sslParameters);
+        }
+        return new UndertowSslConnection(connection, sslEngine, bufferPool);
+    }
+
     /**
      * Create a new  SSL engine, configured from an option map.
      *",2019-05-03T10:07:50Z,228
"@@ -258,7 +258,7 @@ public void completed(ClientExchange response) {
                                                     StreamConnection targetConnection = connection.performUpgrade();
                                                     WebSocketLogger.REQUEST_LOGGER.debugf(""Established websocket connection to %s"", uri);
                                                     if (uri.getScheme().equals(""wss"") || uri.getScheme().equals(""https"")) {
-                                                        handleConnectionWithExistingConnection(((UndertowXnioSsl) ssl).wrapExistingConnection(targetConnection, optionMap));
+                                                        handleConnectionWithExistingConnection(((UndertowXnioSsl) ssl).wrapExistingConnection(targetConnection, optionMap, uri));
                                                     } else {
                                                         handleConnectionWithExistingConnection(targetConnection);
                                                     }",2019-05-03T10:07:50Z,326
"@@ -416,4 +416,12 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String
     @LogMessage(level = ERROR)
     @Message(id = 5090, value = ""Unexpected failure"")
     void handleUnexpectedFailure(@Cause Throwable t);
+
+    @LogMessage(level = ERROR)
+    @Message(id = 5091, value = ""Failed to initialize DirectByteBufferDeallocator"")
+    void directBufferDeallocatorInitializationFailed(@Cause Throwable t);
+
+    @LogMessage(level = DEBUG)
+    @Message(id = 5092, value = ""Failed to free direct buffer"")
+    void directBufferDeallocationFailed(@Cause Throwable t);
 }",2017-08-30T23:28:30Z,65
"@@ -183,6 +183,7 @@ private void cleanupThreadLocalData() {
 
     private void freeInternal(ByteBuffer buffer) {
         if (closed) {
+            DirectByteBufferDeallocator.free(buffer);
             return; //GC will take care of it
         }
         ThreadLocalData local = threadLocalCache.get();
@@ -203,6 +204,7 @@ private void queueIfUnderMax(ByteBuffer buffer) {
         do {
             size = currentQueueLength;
             if(size > maximumPoolSize) {
+                DirectByteBufferDeallocator.free(buffer);
                 return;
             }
         } while (!currentQueueLengthUpdater.compareAndSet(this, size, currentQueueLength + 1));",2017-08-30T23:28:30Z,327
"@@ -0,0 +1,55 @@
+package io.undertow.server;
+
+import io.undertow.UndertowLogger;
+
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+
+/**
+ * {@link DirectByteBufferDeallocator} Utility class used to free direct buffer memory.
+ */
+public final class DirectByteBufferDeallocator {
+    private static final boolean SUPPORTED;
+    private static final Method cleaner;
+    private static final Method cleanerClean;
+
+    static {
+        Method tmpCleaner = null;
+        Method tmpCleanerClean = null;
+        boolean supported;
+        try {
+            tmpCleaner = Class.forName(""java.nio.DirectByteBuffer"").getMethod(""cleaner"");
+            tmpCleaner.setAccessible(true);
+            tmpCleanerClean = Class.forName(""sun.misc.Cleaner"").getMethod(""clean"");
+            tmpCleanerClean.setAccessible(true);
+            supported = true;
+        } catch (Throwable t) {
+            UndertowLogger.ROOT_LOGGER.directBufferDeallocatorInitializationFailed(t);
+            supported = false;
+        }
+        SUPPORTED = supported;
+        cleaner = tmpCleaner;
+        cleanerClean = tmpCleanerClean;
+    }
+
+    private DirectByteBufferDeallocator() {
+        // Utility Class
+    }
+
+    /**
+     * Attempts to deallocate the underlying direct memory.
+     * This is a no-op for buffers where {@link ByteBuffer#isDirect()} returns false.
+     *
+     * @param buffer to deallocate
+     */
+    public static void free(ByteBuffer buffer) {
+        if (SUPPORTED && buffer != null && buffer.isDirect()) {
+            try {
+                Object cleaner = DirectByteBufferDeallocator.cleaner.invoke(buffer);
+                cleanerClean.invoke(cleaner);
+            } catch (Throwable t) {
+                UndertowLogger.ROOT_LOGGER.directBufferDeallocationFailed(t);
+            }
+        }
+    }
+}",2017-08-30T23:28:30Z,328
"@@ -22,7 +22,9 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.session.SessionManager;
+import io.undertow.servlet.core.Filters;
 import io.undertow.servlet.core.ApplicationListeners;
+import io.undertow.servlet.core.Servlets;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
 import io.undertow.servlet.core.ErrorPages;
 import io.undertow.servlet.handlers.ServletPathMatches;
@@ -37,6 +39,10 @@ public interface Deployment {
 
     ApplicationListeners getApplicationListeners();
 
+    Servlets getServlets();
+
+    Filters getFilters();
+
     ServletContextImpl getServletContext();
 
     HttpHandler getHandler();
@@ -52,4 +58,5 @@ public interface Deployment {
     ServletDispatcher getServletDispatcher();
 
     SessionManager getSessionManager();
+
 }",2013-05-23T23:40:57Z,266
"@@ -47,18 +47,31 @@ public class DeploymentImpl implements Deployment {
 
     private final DeploymentInfo deploymentInfo;
     private final List<Lifecycle> lifecycleObjects = new ArrayList<Lifecycle>();
+    private final ServletPathMatches servletPaths;
+    private final Servlets servlets;
+    private final Filters filters;
     private volatile ApplicationListeners applicationListeners;
     private volatile ServletContextImpl servletContext;
     private volatile ServletInitialHandler servletHandler;
     private volatile HttpHandler initialHandler;
-    private volatile ServletPathMatches servletPaths;
     private volatile CompositeThreadSetupAction threadSetupAction;
     private volatile ErrorPages errorPages;
     private volatile Map<String, String> mimeExtensionMappings;
     private volatile SessionManager sessionManager;
 
     public DeploymentImpl(final DeploymentInfo deploymentInfo) {
         this.deploymentInfo = deploymentInfo;
+        servletPaths = new ServletPathMatches(this);
+        servlets = new Servlets(this, servletPaths);
+        filters = new Filters(this, servletPaths);
+    }
+
+    public Servlets getServlets() {
+        return servlets;
+    }
+
+    public Filters getFilters() {
+        return filters;
     }
 
     void setApplicationListeners(final ApplicationListeners applicationListeners) {
@@ -118,10 +131,6 @@ public ServletPathMatches getServletPaths() {
         return servletPaths;
     }
 
-    void setServletPaths(final ServletPathMatches servletPaths) {
-        this.servletPaths = servletPaths;
-    }
-
     public CompositeThreadSetupAction getThreadSetupAction() {
         return threadSetupAction;
     }",2013-05-23T23:40:57Z,267
"@@ -40,13 +40,11 @@
 import io.undertow.server.handlers.PredicateHandler;
 import io.undertow.servlet.ServletExtension;
 import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.api.DefaultServletConfig;
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.ErrorPage;
 import io.undertow.servlet.api.FilterInfo;
-import io.undertow.servlet.api.FilterMappingInfo;
 import io.undertow.servlet.api.HttpMethodSecurityInfo;
 import io.undertow.servlet.api.InstanceHandle;
 import io.undertow.servlet.api.ListenerInfo;
@@ -60,41 +58,31 @@
 import io.undertow.servlet.api.ServletSecurityInfo;
 import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.api.WebResourceCollection;
-import io.undertow.servlet.handlers.DefaultServlet;
 import io.undertow.servlet.handlers.DispatcherTypePredicate;
-import io.undertow.servlet.handlers.FilterHandler;
-import io.undertow.servlet.handlers.ServletChain;
 import io.undertow.servlet.handlers.ServletDispatchingHandler;
-import io.undertow.servlet.handlers.ServletHandler;
 import io.undertow.servlet.handlers.ServletInitialHandler;
-import io.undertow.servlet.handlers.ServletPathMatches;
 import io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler;
 import io.undertow.servlet.handlers.security.SSLInformationAssociationHandler;
 import io.undertow.servlet.handlers.security.SecurityPathMatches;
 import io.undertow.servlet.handlers.security.ServletAuthenticationConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletFormAuthenticationMechanism;
 import io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler;
-import io.undertow.servlet.handlers.security.ServletSecurityRoleHandler;
 import io.undertow.servlet.spec.AsyncContextImpl;
 import io.undertow.servlet.spec.ServletContextImpl;
-import io.undertow.servlet.util.ImmediateInstanceFactory;
 import io.undertow.util.MimeMappings;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
 import java.util.Set;
 import java.util.concurrent.Executor;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.Servlet;
 import javax.servlet.ServletContainerInitializer;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
@@ -134,7 +122,6 @@ public void deploy() {
         final DeploymentImpl deployment = new DeploymentImpl(deploymentInfo);
         this.deployment = deployment;
 
-
         final ServletContextImpl servletContext = new ServletContextImpl(servletContainer, deployment);
 
         handleExtensions(deploymentInfo, servletContext);
@@ -154,6 +141,10 @@ public void deploy() {
 
             final ApplicationListeners listeners = createListeners();
             deployment.setApplicationListeners(listeners);
+
+            //now create the servlets and filters that we know about. We can still get more later
+            createServletsAndFilters(deployment, deploymentInfo);
+
             //first run the SCI's
             for (final ServletContainerInitializerInfo sci : deploymentInfo.getServletContainerInitializers()) {
                 final InstanceHandle<? extends ServletContainerInitializer> instance = sci.getInstanceFactory().createInstance();
@@ -172,9 +163,6 @@ public void deploy() {
             listeners.contextInitialized();
             //run
 
-            ServletPathMatches matches = setupServletChains(servletContext, threadSetupAction, listeners);
-            deployment.setServletPaths(matches);
-
             HttpHandler wrappedHandlers = ServletDispatchingHandler.INSTANCE;
             wrappedHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getInnerHandlerChainWrappers());
             HttpHandler securityHandler  = setupSecurityHandlers(wrappedHandlers);
@@ -183,13 +171,14 @@ public void deploy() {
             HttpHandler outerHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getOuterHandlerChainWrappers());
             wrappedHandlers = new PredicateHandler(Predicates.or(DispatcherTypePredicate.REQUEST, DispatcherTypePredicate.ASYNC), outerHandlers, wrappedHandlers);
 
-            final ServletInitialHandler servletInitialHandler = new ServletInitialHandler(matches, wrappedHandlers, deployment.getThreadSetupAction(), servletContext);
+            final ServletInitialHandler servletInitialHandler = new ServletInitialHandler(deployment.getServletPaths(), wrappedHandlers, deployment.getThreadSetupAction(), servletContext);
 
 
             HttpHandler initialHandler = wrapHandlers(servletInitialHandler, deployment.getDeploymentInfo().getInitialHandlerChainWrappers());
 
             deployment.setInitialHandler(initialHandler);
             deployment.setServletHandler(servletInitialHandler);
+            deployment.getServletPaths().invalidate(); //make sure we have a fresh set of servlet paths
         } catch (Exception e) {
             throw new RuntimeException(e);
         } finally {
@@ -198,6 +187,15 @@ public void deploy() {
         state = State.DEPLOYED;
     }
 
+    private void createServletsAndFilters(final DeploymentImpl deployment, final DeploymentInfo deploymentInfo) {
+        for(Map.Entry<String, ServletInfo> servlet : deploymentInfo.getServlets().entrySet()) {
+            deployment.getServlets().addServlet(servlet.getValue());
+        }
+        for(Map.Entry<String, FilterInfo> filter : deploymentInfo.getFilters().entrySet()) {
+            deployment.getFilters().addFilter(filter.getValue());
+        }
+    }
+
     private void handleExtensions(final DeploymentInfo deploymentInfo, final ServletContextImpl servletContext) {
         for(ServletExtension extension : ServiceLoader.load(ServletExtension.class, deploymentInfo.getClassLoader())) {
             extension.handleDeployment(deploymentInfo, servletContext);
@@ -216,6 +214,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
         final LoginConfig loginConfig = deploymentInfo.getLoginConfig();
 
         HttpHandler current = initialHandler;
+        current = new SSLInformationAssociationHandler(current);
 
         final SecurityPathMatches securityPathMatches = buildSecurityConstraints();
         current = new AuthenticationCallHandler(current);
@@ -350,195 +349,6 @@ private void initializeErrorPages(final DeploymentImpl deployment, final Deploym
         deployment.setErrorPages(new ErrorPages(codes, exceptions, defaultErrorPage));
     }
 
-    /**
-     * Sets up the handlers in the servlet chain. We setup a chain for every path + extension match possibility.
-     * (i.e. if there a m path mappings and n extension mappings we have n*m chains).
-     * <p/>
-     * If a chain consists of only the default servlet then we add it as an async handler, so that resources can be
-     * served up directly without using blocking operations.
-     * <p/>
-     * TODO: this logic is a bit convoluted at the moment, we should look at simplifying it
-     *
-     * @param servletContext
-     * @param threadSetupAction
-     * @param listeners
-     */
-    private ServletPathMatches setupServletChains(final ServletContextImpl servletContext, final CompositeThreadSetupAction threadSetupAction, final ApplicationListeners listeners) {
-        final List<Lifecycle> lifecycles = new ArrayList<Lifecycle>();
-        //create the default servlet
-        ServletChain defaultHandler = null;
-        ServletHandler defaultServlet = null;
-
-        final Map<String, ManagedFilter> managedFilterMap = new LinkedHashMap<String, ManagedFilter>();
-        final Map<String, ServletHandler> allServlets = new HashMap<String, ServletHandler>();
-        final Map<String, ServletHandler> extensionServlets = new HashMap<String, ServletHandler>();
-        final Map<String, ServletHandler> pathServlets = new HashMap<String, ServletHandler>();
-
-
-        final Set<String> pathMatches = new HashSet<String>();
-        final Set<String> extensionMatches = new HashSet<String>();
-
-        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
-        for (Map.Entry<String, FilterInfo> entry : deploymentInfo.getFilters().entrySet()) {
-            final ManagedFilter mf = new ManagedFilter(entry.getValue(), servletContext);
-            managedFilterMap.put(entry.getValue().getName(), mf);
-            lifecycles.add(mf);
-        }
-
-        for (FilterMappingInfo mapping : deploymentInfo.getFilterMappings()) {
-            if (mapping.getMappingType() == FilterMappingInfo.MappingType.URL) {
-                String path = mapping.getMapping();
-                if (!path.startsWith(""*."")) {
-                    pathMatches.add(path);
-                } else {
-                    extensionMatches.add(path.substring(2));
-                }
-            }
-        }
-
-        for (Map.Entry<String, ServletInfo> entry : deploymentInfo.getServlets().entrySet()) {
-            ServletInfo servlet = entry.getValue();
-            final ManagedServlet managedServlet = new ManagedServlet(servlet, servletContext);
-            lifecycles.add(managedServlet);
-            final ServletHandler handler = new ServletHandler(managedServlet);
-            allServlets.put(entry.getKey(), handler);
-            for (String path : entry.getValue().getMappings()) {
-                if (path.equals(""/"")) {
-                    //the default servlet
-                    pathMatches.add(""/*"");
-                    if (pathServlets.containsKey(""/*"")) {
-                        throw UndertowServletMessages.MESSAGES.twoServletsWithSameMapping(path);
-                    }
-                    defaultServlet = handler;
-                    defaultHandler = servletChain(handler, managedServlet);
-                } else if (!path.startsWith(""*."")) {
-                    pathMatches.add(path);
-                    if (pathServlets.containsKey(path)) {
-                        throw UndertowServletMessages.MESSAGES.twoServletsWithSameMapping(path);
-                    }
-                    pathServlets.put(path, handler);
-                } else {
-                    String ext = path.substring(2);
-                    extensionMatches.add(ext);
-                    extensionServlets.put(ext, handler);
-                }
-            }
-        }
-
-        if (defaultServlet == null) {
-            final DefaultServletConfig config = deploymentInfo.getDefaultServletConfig() == null ? new DefaultServletConfig() : deploymentInfo.getDefaultServletConfig();
-            DefaultServlet defaultInstance = new DefaultServlet(deployment, config, deploymentInfo.getWelcomePages());
-            final ManagedServlet managedDefaultServlet = new ManagedServlet(new ServletInfo(""io.undertow.DefaultServlet"", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance)), servletContext);
-            lifecycles.add(managedDefaultServlet);
-            pathMatches.add(""/*"");
-            defaultServlet = new ServletHandler(managedDefaultServlet);
-            defaultHandler = new ServletChain(defaultServlet, managedDefaultServlet);
-        }
-
-        final ServletPathMatches.Builder builder = ServletPathMatches.builder();
-
-        for (final String path : pathMatches) {
-            ServletHandler targetServlet = resolveServletForPath(path, pathServlets);
-
-            final Map<DispatcherType, List<ManagedFilter>> noExtension = new HashMap<DispatcherType, List<ManagedFilter>>();
-            final Map<String, Map<DispatcherType, List<ManagedFilter>>> extension = new HashMap<String, Map<DispatcherType, List<ManagedFilter>>>();
-            for (String ext : extensionMatches) {
-                extension.put(ext, new HashMap<DispatcherType, List<ManagedFilter>>());
-            }
-
-            for (final FilterMappingInfo filterMapping : deploymentInfo.getFilterMappings()) {
-                ManagedFilter filter = managedFilterMap.get(filterMapping.getFilterName());
-                if (filterMapping.getMappingType() == FilterMappingInfo.MappingType.SERVLET) {
-                    if (targetServlet != null) {
-                        if (filterMapping.getMapping().equals(targetServlet.getManagedServlet().getServletInfo().getName())) {
-                            addToListMap(noExtension, filterMapping.getDispatcher(), filter);
-                            for (Map<DispatcherType, List<ManagedFilter>> l : extension.values()) {
-                                addToListMap(l, filterMapping.getDispatcher(), filter);
-                            }
-                        }
-                    }
-                } else {
-                    if (filterMapping.getMapping().isEmpty() || !filterMapping.getMapping().startsWith(""*."")) {
-                        if (isFilterApplicable(path, filterMapping.getMapping())) {
-                            addToListMap(noExtension, filterMapping.getDispatcher(), filter);
-                            for (Map<DispatcherType, List<ManagedFilter>> l : extension.values()) {
-                                addToListMap(l, filterMapping.getDispatcher(), filter);
-                            }
-                        }
-                    } else {
-                        addToListMap(extension.get(filterMapping.getMapping().substring(2)), filterMapping.getDispatcher(), filter);
-                    }
-                }
-            }
-
-            final ServletChain initialHandler;
-            if (noExtension.isEmpty()) {
-                if (targetServlet != null) {
-                    initialHandler = servletChain(targetServlet, targetServlet.getManagedServlet());
-                } else {
-                    initialHandler = defaultHandler;
-                }
-            } else {
-                FilterHandler handler;
-                if (targetServlet != null) {
-                    handler = new FilterHandler(noExtension, deploymentInfo.isAllowNonStandardWrappers(), targetServlet);
-                } else {
-                    handler = new FilterHandler(noExtension, deploymentInfo.isAllowNonStandardWrappers(), defaultServlet);
-                }
-                initialHandler = servletChain(handler, targetServlet == null ? defaultServlet.getManagedServlet() : targetServlet.getManagedServlet());
-            }
-
-            if (path.endsWith(""/*"")) {
-                String prefix = path.substring(0, path.length() - 2);
-                builder.addPrefixMatch(prefix, initialHandler);
-
-                for (Map.Entry<String, Map<DispatcherType, List<ManagedFilter>>> entry : extension.entrySet()) {
-                    ServletHandler pathServlet = targetServlet;
-                    if (pathServlet == null) {
-                        pathServlet = extensionServlets.get(entry.getKey());
-                    }
-                    if (pathServlet == null) {
-                        pathServlet = defaultServlet;
-                    }
-                    HttpHandler handler = pathServlet;
-                    if (!entry.getValue().isEmpty()) {
-                        handler = new FilterHandler(entry.getValue(), deploymentInfo.isAllowNonStandardWrappers(), handler);
-                    }
-                    builder.addExtensionMatch(prefix, entry.getKey(), servletChain(handler, pathServlet.getManagedServlet()));
-                }
-            } else if (path.isEmpty()) {
-                builder.addExactMatch(""/"", initialHandler);
-            } else {
-                builder.addExactMatch(path, initialHandler);
-            }
-        }
-
-        //now setup name based mappings
-        //these are used for name based dispatch
-        for (Map.Entry<String, ServletHandler> entry : allServlets.entrySet()) {
-            final Map<DispatcherType, List<ManagedFilter>> filters = new HashMap<DispatcherType, List<ManagedFilter>>();
-            for (final FilterMappingInfo filterMapping : deploymentInfo.getFilterMappings()) {
-                ManagedFilter filter = managedFilterMap.get(filterMapping.getFilterName());
-                if (filterMapping.getMappingType() == FilterMappingInfo.MappingType.SERVLET) {
-                    if (filterMapping.getMapping().equals(entry.getKey())) {
-                        addToListMap(filters, filterMapping.getDispatcher(), filter);
-                    }
-                }
-            }
-            if (filters.isEmpty()) {
-                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), entry.getValue().getManagedServlet()));
-            } else {
-                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filters, deploymentInfo.isAllowNonStandardWrappers(), entry.getValue()), entry.getValue().getManagedServlet()));
-            }
-        }
-
-
-        builder.setDefaultServlet(defaultHandler);
-
-        deployment.addLifecycleObjects(lifecycles);
-        return builder.build();
-    }
-
 
     private ApplicationListeners createListeners() {
         final List<ManagedListener> managedListeners = new ArrayList<ManagedListener>();
@@ -548,54 +358,15 @@ private ApplicationListeners createListeners() {
         return new ApplicationListeners(managedListeners, deployment.getServletContext());
     }
 
-    private ServletChain servletChain(HttpHandler next, final ManagedServlet managedServlet) {
-        HttpHandler servletHandler = new ServletSecurityRoleHandler(next);
-        servletHandler = new SSLInformationAssociationHandler(servletHandler);
-        servletHandler = wrapHandlers(servletHandler, managedServlet.getServletInfo().getHandlerChainWrappers());
-        return new ServletChain(servletHandler, managedServlet);
-    }
 
-    private HttpHandler wrapHandlers(final HttpHandler wrapee, final List<HandlerWrapper> wrappers) {
+    private static HttpHandler wrapHandlers(final HttpHandler wrapee, final List<HandlerWrapper> wrappers) {
         HttpHandler current = wrapee;
         for (HandlerWrapper wrapper : wrappers) {
             current = wrapper.wrap(current);
         }
         return current;
     }
 
-    private ServletHandler resolveServletForPath(final String path, final Map<String, ServletHandler> pathServlets) {
-        if (pathServlets.containsKey(path)) {
-            return pathServlets.get(path);
-        }
-        String match = null;
-        ServletHandler servlet = null;
-        for (final Map.Entry<String, ServletHandler> entry : pathServlets.entrySet()) {
-            String key = entry.getKey();
-            if (key.endsWith(""/*"")) {
-                final String base = key.substring(0, key.length() - 2);
-                if (match == null || base.length() > match.length()) {
-                    if (path.startsWith(base)) {
-                        match = base;
-                        servlet = entry.getValue();
-                    }
-                }
-            }
-        }
-        return servlet;
-    }
-
-    private boolean isFilterApplicable(final String path, final String filterPath) {
-        if (path.isEmpty()) {
-            return filterPath.equals(""/*"") || filterPath.equals(""/"");
-        }
-        if (filterPath.endsWith(""/*"")) {
-            String baseFilterPath = filterPath.substring(0, filterPath.length() - 1);
-            return path.startsWith(baseFilterPath);
-        } else {
-            return filterPath.equals(path);
-        }
-    }
-
     @Override
     public HttpHandler start() throws ServletException {
         ThreadSetupAction.Handle handle = deployment.getThreadSetupAction().setup(null);
@@ -689,11 +460,4 @@ public Deployment getDeployment() {
         return deployment;
     }
 
-    private static <K, V> void addToListMap(final Map<K, List<V>> map, final K key, final V value) {
-        List<V> list = map.get(key);
-        if (list == null) {
-            map.put(key, list = new ArrayList<V>());
-        }
-        list.add(value);
-    }
 }",2013-05-23T23:40:57Z,80
"@@ -0,0 +1,42 @@
+package io.undertow.servlet.core;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.undertow.servlet.api.FilterInfo;
+import io.undertow.servlet.handlers.ServletPathMatches;
+import io.undertow.util.CopyOnWriteMap;
+
+/**
+ * Runtime representation of filters. Basically a container for {@link io.undertow.servlet.core.ManagedFilter} instances
+ *
+ * @author Stuart Douglas
+ */
+public class Filters {
+
+    private final Map<String, ManagedFilter> managedFilterMap = new CopyOnWriteMap<>();
+    private final DeploymentImpl deployment;
+    private final ServletPathMatches servletPathMatches;
+
+    public Filters(final DeploymentImpl deployment, final ServletPathMatches servletPathMatches) {
+        this.deployment = deployment;
+        this.servletPathMatches = servletPathMatches;
+    }
+
+    public ManagedFilter addFilter(final FilterInfo filterInfo) {
+        ManagedFilter managedFilter = new ManagedFilter(filterInfo, deployment.getServletContext());
+        managedFilterMap.put(filterInfo.getName(),managedFilter);
+        deployment.addLifecycleObjects(managedFilter);
+        servletPathMatches.invalidate();
+        return managedFilter;
+    }
+
+    public ManagedFilter getManagedFilter(final String name) {
+        return managedFilterMap.get(name);
+    }
+
+    public Map<String, ManagedFilter> getFilters() {
+        return new HashMap<>(managedFilterMap);
+    }
+
+}",2013-05-23T23:40:57Z,18
"@@ -0,0 +1,52 @@
+package io.undertow.servlet.core;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.handlers.ServletHandler;
+import io.undertow.servlet.handlers.ServletPathMatches;
+import io.undertow.util.CopyOnWriteMap;
+
+/**
+ * Runtime representation of servlets. Basically a container for {@link ManagedServlet} instances
+ *
+ * @author Stuart Douglas
+ */
+public class Servlets {
+
+    private final Map<String, ServletHandler> managedServletMap = new CopyOnWriteMap<>();
+    private final DeploymentImpl deployment;
+    private final ServletPathMatches servletPaths;
+
+    public Servlets(final DeploymentImpl deployment, final ServletPathMatches servletPaths) {
+        this.deployment = deployment;
+        this.servletPaths = servletPaths;
+    }
+
+    public ServletHandler addServlet(final ServletInfo servletInfo) {
+        ManagedServlet managedServlet = new ManagedServlet(servletInfo, deployment.getServletContext());
+        ServletHandler servletHandler = new ServletHandler(managedServlet);
+        managedServletMap.put(servletInfo.getName(), servletHandler);
+        deployment.addLifecycleObjects(managedServlet);
+        this.servletPaths.invalidate();
+        return servletHandler;
+    }
+
+    public ManagedServlet getManagedServlet(final String name) {
+        ServletHandler servletHandler = managedServletMap.get(name);
+        if(servletHandler == null) {
+            return null;
+        }
+        return servletHandler.getManagedServlet();
+    }
+
+    public ServletHandler getServletHandler(final String name) {
+        return managedServletMap.get(name);
+    }
+
+    public Map<String, ServletHandler> getServletHandlers() {
+        return new HashMap<>(managedServletMap);
+    }
+
+}",2013-05-23T23:40:57Z,101
"@@ -18,177 +18,303 @@
 
 package io.undertow.servlet.handlers;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.Servlet;
+
+import io.undertow.server.HandlerWrapper;
+import io.undertow.server.HttpHandler;
+import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.servlet.api.DefaultServletConfig;
+import io.undertow.servlet.api.Deployment;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.FilterMappingInfo;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.core.Filters;
+import io.undertow.servlet.core.ManagedFilter;
+import io.undertow.servlet.core.ManagedServlet;
+import io.undertow.servlet.core.Servlets;
+import io.undertow.servlet.handlers.security.ServletSecurityRoleHandler;
+import io.undertow.servlet.util.ImmediateInstanceFactory;
 
 /**
- * Class that maintains the complete set of servlet path matches
+ * Facade around {@link ServletPathMatchesData}. This facade is responsible for re-generating the matches if anything changes.
  *
  * @author Stuart Douglas
  */
 public class ServletPathMatches {
 
-    private final Map<String, ServletPathMatch> exactPathMatches;
+    private final Deployment deployment;
 
-    private final Map<String, PathMatch> prefixMatches;
-
-    private final Map<String, ServletChain> nameMatches;
-
-    private final ServletChain defaultServlet;
-
-    public ServletPathMatches(final Map<String, ServletChain> exactPathMatches, final Map<String, PathMatch> prefixMatches, final Map<String, ServletChain> nameMatches, final ServletChain defaultServlet) {
-        this.prefixMatches = prefixMatches;
-        this.nameMatches = nameMatches;
-        this.defaultServlet = defaultServlet;
-        Map<String, ServletPathMatch> newExactPathMatches = new HashMap<>();
-        for (Map.Entry<String, ServletChain> entry : exactPathMatches.entrySet()) {
-            newExactPathMatches.put(entry.getKey(), new ServletPathMatch(entry.getValue().getHandler(), entry.getValue().getManagedServlet(), entry.getKey(), null));
-        }
-        this.exactPathMatches = newExactPathMatches;
+    private volatile ServletPathMatchesData data;
 
+    public ServletPathMatches(final Deployment deployment) {
+        this.deployment = deployment;
     }
 
+
     public ServletChain getServletHandlerByName(final String name) {
-        return nameMatches.get(name);
+       return getData().getServletHandlerByName(name);
     }
 
     public ServletPathMatch getServletHandlerByExactPath(final String path) {
-        return exactPathMatches.get(path);
+        return getData().getServletHandlerByExactPath(path);
     }
 
     public ServletPathMatch getServletHandlerByPath(final String path) {
-        ServletPathMatch exact = exactPathMatches.get(path);
-        if (exact != null) {
-            return exact;
-        }
-        PathMatch match = prefixMatches.get(path);
-        if (match != null) {
-            return handleMatch(path, match, path, null, -1, path.lastIndexOf('.'));
+        return getData().getServletHandlerByPath(path);
+    }
+
+    public void invalidate() {
+        this.data = null;
+    }
+
+    private ServletPathMatchesData getData() {
+        ServletPathMatchesData data = this.data;
+        if(data != null) {
+            return data;
         }
-        int qsPos = -1;
-        int extensionPos = -1;
-        for (int i = path.length() - 1; i >= 0; --i) {
-            final char c = path.charAt(i);
-            if (c == '?') {
-                //there was a query string, check the exact matches again
-                final String part = path.substring(0, i);
-                exact = exactPathMatches.get(part);
-                if (exact != null) {
-                    return exact;
-                }
-                qsPos = i;
-                extensionPos = -1;
-            } else if (c == '/') {
-                final String part = path.substring(0, i);
-                match = prefixMatches.get(part);
-                if (match != null) {
-                    return handleMatch(path, match, part, path.substring(i), qsPos, extensionPos);
-                }
-            } else if (c == '.') {
-                if (extensionPos == -1) {
-                    extensionPos = i;
-                }
+        synchronized (this) {
+            if(this.data != null) {
+                return this.data;
             }
+            return this.data = setupServletChains();
         }
-        return new ServletPathMatch(defaultServlet.getHandler(), defaultServlet.getManagedServlet(), """", path);
     }
 
-    private ServletPathMatch handleMatch(final String path, final PathMatch match, String matched, String remaining, final int qsPos, final int extensionPos) {
-        if (match.extensionMatches.isEmpty()) {
-            return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
-        } else {
-            if (extensionPos == -1) {
-                return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
-            } else {
-                final String ext;
-                if (qsPos == -1) {
-                    ext = path.substring(extensionPos + 1, path.length());
+
+    /**
+     * Sets up the handlers in the servlet chain. We setup a chain for every path + extension match possibility.
+     * (i.e. if there a m path mappings and n extension mappings we have n*m chains).
+     * <p/>
+     * If a chain consists of only the default servlet then we add it as an async handler, so that resources can be
+     * served up directly without using blocking operations.
+     * <p/>
+     * TODO: this logic is a bit convoluted at the moment, we should look at simplifying it
+     *
+     */
+    private ServletPathMatchesData setupServletChains() {
+        //create the default servlet
+        ServletChain defaultHandler = null;
+        ServletHandler defaultServlet = null;
+        final Servlets servlets = deployment.getServlets();
+        final Filters filters = deployment.getFilters();
+
+        final Map<String, ServletHandler> extensionServlets = new HashMap<>();
+        final Map<String, ServletHandler> pathServlets = new HashMap<>();
+
+        final Set<String> pathMatches = new HashSet<String>();
+        final Set<String> extensionMatches = new HashSet<String>();
+
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
+
+        for (FilterMappingInfo mapping : deploymentInfo.getFilterMappings()) {
+            if (mapping.getMappingType() == FilterMappingInfo.MappingType.URL) {
+                String path = mapping.getMapping();
+                if (!path.startsWith(""*."")) {
+                    pathMatches.add(path);
                 } else {
-                    ext = path.substring(extensionPos + 1, qsPos);
+                    extensionMatches.add(path.substring(2));
                 }
-                ServletChain handler = match.extensionMatches.get(ext);
-                if (handler != null) {
-                    //if this is an extension only mapping then the matched will be empty,
-                    //and we do not add the remaining to the match
-                    //as the path info should be null
-                    if (matched.isEmpty()) {
-                        if (qsPos == -1) {
-                            return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), path, null);
-                        } else {
-                            return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), path.substring(0, qsPos), null);
-                        }
-                    } else {
-                        return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), matched, remaining);
+            }
+        }
+
+        for (Map.Entry<String, ServletInfo> entry : deploymentInfo.getServlets().entrySet()) {
+            ServletInfo servlet = entry.getValue();
+            final ServletHandler handler = servlets.addServlet(servlet);
+            for (String path : entry.getValue().getMappings()) {
+                if (path.equals(""/"")) {
+                    //the default servlet
+                    pathMatches.add(""/*"");
+                    if (pathServlets.containsKey(""/*"")) {
+                        throw UndertowServletMessages.MESSAGES.twoServletsWithSameMapping(path);
+                    }
+                    defaultServlet = handler;
+                    defaultHandler = servletChain(handler, handler.getManagedServlet());
+                } else if (!path.startsWith(""*."")) {
+                    pathMatches.add(path);
+                    if (pathServlets.containsKey(path)) {
+                        throw UndertowServletMessages.MESSAGES.twoServletsWithSameMapping(path);
                     }
+                    pathServlets.put(path, handler);
                 } else {
-                    return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
+                    String ext = path.substring(2);
+                    extensionMatches.add(ext);
+                    extensionServlets.put(ext, handler);
                 }
             }
         }
-    }
 
-    public static Builder builder() {
-        return new Builder();
-    }
+        if (defaultServlet == null) {
+            final DefaultServletConfig config = deploymentInfo.getDefaultServletConfig() == null ? new DefaultServletConfig() : deploymentInfo.getDefaultServletConfig();
+            DefaultServlet defaultInstance = new DefaultServlet(deployment, config, deploymentInfo.getWelcomePages());
+            final ServletHandler managedDefaultServlet = servlets.addServlet(new ServletInfo(""io.undertow.DefaultServlet"", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance)));
+            pathMatches.add(""/*"");
+            defaultServlet = managedDefaultServlet;
+            defaultHandler = new ServletChain(defaultServlet, managedDefaultServlet.getManagedServlet());
+        }
 
-    public static final class Builder {
+        final ServletPathMatchesData.Builder builder = ServletPathMatchesData.builder();
 
-        private final Map<String, ServletChain> exactPathMatches = new HashMap<String, ServletChain>();
+        for (final String path : pathMatches) {
+            ServletHandler targetServlet = resolveServletForPath(path, pathServlets);
 
-        private final Map<String, PathMatch> prefixMatches = new HashMap<String, PathMatch>();
+            final Map<DispatcherType, List<ManagedFilter>> noExtension = new HashMap<DispatcherType, List<ManagedFilter>>();
+            final Map<String, Map<DispatcherType, List<ManagedFilter>>> extension = new HashMap<String, Map<DispatcherType, List<ManagedFilter>>>();
+            for (String ext : extensionMatches) {
+                extension.put(ext, new HashMap<DispatcherType, List<ManagedFilter>>());
+            }
 
-        private final Map<String, ServletChain> nameMatches = new HashMap<String, ServletChain>();
+            for (final FilterMappingInfo filterMapping : deploymentInfo.getFilterMappings()) {
+                ManagedFilter filter = filters.getManagedFilter(filterMapping.getFilterName());
+                if (filterMapping.getMappingType() == FilterMappingInfo.MappingType.SERVLET) {
+                    if (targetServlet != null) {
+                        if (filterMapping.getMapping().equals(targetServlet.getManagedServlet().getServletInfo().getName())) {
+                            addToListMap(noExtension, filterMapping.getDispatcher(), filter);
+                            for (Map<DispatcherType, List<ManagedFilter>> l : extension.values()) {
+                                addToListMap(l, filterMapping.getDispatcher(), filter);
+                            }
+                        }
+                    }
+                } else {
+                    if (filterMapping.getMapping().isEmpty() || !filterMapping.getMapping().startsWith(""*."")) {
+                        if (isFilterApplicable(path, filterMapping.getMapping())) {
+                            addToListMap(noExtension, filterMapping.getDispatcher(), filter);
+                            for (Map<DispatcherType, List<ManagedFilter>> l : extension.values()) {
+                                addToListMap(l, filterMapping.getDispatcher(), filter);
+                            }
+                        }
+                    } else {
+                        addToListMap(extension.get(filterMapping.getMapping().substring(2)), filterMapping.getDispatcher(), filter);
+                    }
+                }
+            }
 
-        private ServletChain defaultServlet;
+            final ServletChain initialHandler;
+            if (noExtension.isEmpty()) {
+                if (targetServlet != null) {
+                    initialHandler = servletChain(targetServlet, targetServlet.getManagedServlet());
+                } else {
+                    initialHandler = defaultHandler;
+                }
+            } else {
+                FilterHandler handler;
+                if (targetServlet != null) {
+                    handler = new FilterHandler(noExtension, deploymentInfo.isAllowNonStandardWrappers(), targetServlet);
+                } else {
+                    handler = new FilterHandler(noExtension, deploymentInfo.isAllowNonStandardWrappers(), defaultServlet);
+                }
+                initialHandler = servletChain(handler, targetServlet == null ? defaultServlet.getManagedServlet() : targetServlet.getManagedServlet());
+            }
 
-        public void addExactMatch(final String exactMatch, final ServletChain match) {
-            exactPathMatches.put(exactMatch, match);
-        }
+            if (path.endsWith(""/*"")) {
+                String prefix = path.substring(0, path.length() - 2);
+                builder.addPrefixMatch(prefix, initialHandler);
 
-        public void addPrefixMatch(final String prefix, final ServletChain match) {
-            PathMatch m = prefixMatches.get(prefix);
-            if (m == null) {
-                prefixMatches.put(prefix, m = new PathMatch(match));
+                for (Map.Entry<String, Map<DispatcherType, List<ManagedFilter>>> entry : extension.entrySet()) {
+                    ServletHandler pathServlet = targetServlet;
+                    if (pathServlet == null) {
+                        pathServlet = extensionServlets.get(entry.getKey());
+                    }
+                    if (pathServlet == null) {
+                        pathServlet = defaultServlet;
+                    }
+                    HttpHandler handler = pathServlet;
+                    if (!entry.getValue().isEmpty()) {
+                        handler = new FilterHandler(entry.getValue(), deploymentInfo.isAllowNonStandardWrappers(), handler);
+                    }
+                    builder.addExtensionMatch(prefix, entry.getKey(), servletChain(handler, pathServlet.getManagedServlet()));
+                }
+            } else if (path.isEmpty()) {
+                builder.addExactMatch(""/"", initialHandler);
+            } else {
+                builder.addExactMatch(path, initialHandler);
             }
-            m.defaultHandler = match;
         }
 
-        public void addExtensionMatch(final String prefix, final String extension, final ServletChain match) {
-            PathMatch m = prefixMatches.get(prefix);
-            if (m == null) {
-                prefixMatches.put(prefix, m = new PathMatch(null));
+        //now setup name based mappings
+        //these are used for name based dispatch
+        for (Map.Entry<String, ServletHandler> entry : servlets.getServletHandlers().entrySet()) {
+            final Map<DispatcherType, List<ManagedFilter>> filtersByDispatcher = new HashMap<DispatcherType, List<ManagedFilter>>();
+            for (final FilterMappingInfo filterMapping : deploymentInfo.getFilterMappings()) {
+                ManagedFilter filter = filters.getManagedFilter(filterMapping.getFilterName());
+                if (filterMapping.getMappingType() == FilterMappingInfo.MappingType.SERVLET) {
+                    if (filterMapping.getMapping().equals(entry.getKey())) {
+                        addToListMap(filtersByDispatcher, filterMapping.getDispatcher(), filter);
+                    }
+                }
+            }
+            if (filtersByDispatcher.isEmpty()) {
+                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), entry.getValue().getManagedServlet()));
+            } else {
+                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filtersByDispatcher, deploymentInfo.isAllowNonStandardWrappers(), entry.getValue()), entry.getValue().getManagedServlet()));
             }
-            m.extensionMatches.put(extension, match);
         }
 
-        public void addNameMatch(final String name, final ServletChain match) {
-            nameMatches.put(name, match);
-        }
 
-        public ServletChain getDefaultServlet() {
-            return defaultServlet;
-        }
+        builder.setDefaultServlet(defaultHandler);
 
-        public void setDefaultServlet(final ServletChain defaultServlet) {
-            this.defaultServlet = defaultServlet;
-        }
+        return builder.build();
+    }
 
-        public ServletPathMatches build() {
-            return new ServletPathMatches(exactPathMatches, prefixMatches, nameMatches, defaultServlet);
+    private static ServletHandler resolveServletForPath(final String path, final Map<String, ServletHandler> pathServlets) {
+        if (pathServlets.containsKey(path)) {
+            return pathServlets.get(path);
         }
-
+        String match = null;
+        ServletHandler servlet = null;
+        for (final Map.Entry<String, ServletHandler> entry : pathServlets.entrySet()) {
+            String key = entry.getKey();
+            if (key.endsWith(""/*"")) {
+                final String base = key.substring(0, key.length() - 2);
+                if (match == null || base.length() > match.length()) {
+                    if (path.startsWith(base)) {
+                        match = base;
+                        servlet = entry.getValue();
+                    }
+                }
+            }
+        }
+        return servlet;
     }
 
+    private static boolean isFilterApplicable(final String path, final String filterPath) {
+        if (path.isEmpty()) {
+            return filterPath.equals(""/*"") || filterPath.equals(""/"");
+        }
+        if (filterPath.endsWith(""/*"")) {
+            String baseFilterPath = filterPath.substring(0, filterPath.length() - 1);
+            return path.startsWith(baseFilterPath);
+        } else {
+            return filterPath.equals(path);
+        }
+    }
 
-    private static class PathMatch {
-
-        private final Map<String, ServletChain> extensionMatches = new HashMap<>();
-        private volatile ServletChain defaultHandler;
-
-        public PathMatch(final ServletChain defaultHandler) {
-            this.defaultHandler = defaultHandler;
+    private static <K, V> void addToListMap(final Map<K, List<V>> map, final K key, final V value) {
+        List<V> list = map.get(key);
+        if (list == null) {
+            map.put(key, list = new ArrayList<V>());
         }
+        list.add(value);
     }
 
+    private static ServletChain servletChain(HttpHandler next, final ManagedServlet managedServlet) {
+        HttpHandler servletHandler = new ServletSecurityRoleHandler(next);
+        servletHandler = wrapHandlers(servletHandler, managedServlet.getServletInfo().getHandlerChainWrappers());
+        return new ServletChain(servletHandler, managedServlet);
+    }
 
+    private static HttpHandler wrapHandlers(final HttpHandler wrapee, final List<HandlerWrapper> wrappers) {
+        HttpHandler current = wrapee;
+        for (HandlerWrapper wrapper : wrappers) {
+            current = wrapper.wrap(current);
+        }
+        return current;
+    }
 }",2013-05-23T23:40:57Z,169
"@@ -0,0 +1,195 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.servlet.handlers;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Class that maintains the complete set of servlet path matches.
+ *
+ *
+ * @author Stuart Douglas
+ */
+class ServletPathMatchesData {
+
+    private final Map<String, ServletPathMatch> exactPathMatches;
+
+    private final Map<String, PathMatch> prefixMatches;
+
+    private final Map<String, ServletChain> nameMatches;
+
+    private final ServletChain defaultServlet;
+
+    public ServletPathMatchesData(final Map<String, ServletChain> exactPathMatches, final Map<String, PathMatch> prefixMatches, final Map<String, ServletChain> nameMatches, final ServletChain defaultServlet) {
+        this.prefixMatches = prefixMatches;
+        this.nameMatches = nameMatches;
+        this.defaultServlet = defaultServlet;
+        Map<String, ServletPathMatch> newExactPathMatches = new HashMap<>();
+        for (Map.Entry<String, ServletChain> entry : exactPathMatches.entrySet()) {
+            newExactPathMatches.put(entry.getKey(), new ServletPathMatch(entry.getValue().getHandler(), entry.getValue().getManagedServlet(), entry.getKey(), null));
+        }
+        this.exactPathMatches = newExactPathMatches;
+
+    }
+
+    public ServletChain getServletHandlerByName(final String name) {
+        return nameMatches.get(name);
+    }
+
+    public ServletPathMatch getServletHandlerByExactPath(final String path) {
+        return exactPathMatches.get(path);
+    }
+
+    public ServletPathMatch getServletHandlerByPath(final String path) {
+        ServletPathMatch exact = exactPathMatches.get(path);
+        if (exact != null) {
+            return exact;
+        }
+        PathMatch match = prefixMatches.get(path);
+        if (match != null) {
+            return handleMatch(path, match, path, null, -1, path.lastIndexOf('.'));
+        }
+        int qsPos = -1;
+        int extensionPos = -1;
+        for (int i = path.length() - 1; i >= 0; --i) {
+            final char c = path.charAt(i);
+            if (c == '?') {
+                //there was a query string, check the exact matches again
+                final String part = path.substring(0, i);
+                exact = exactPathMatches.get(part);
+                if (exact != null) {
+                    return exact;
+                }
+                qsPos = i;
+                extensionPos = -1;
+            } else if (c == '/') {
+                final String part = path.substring(0, i);
+                match = prefixMatches.get(part);
+                if (match != null) {
+                    return handleMatch(path, match, part, path.substring(i), qsPos, extensionPos);
+                }
+            } else if (c == '.') {
+                if (extensionPos == -1) {
+                    extensionPos = i;
+                }
+            }
+        }
+        return new ServletPathMatch(defaultServlet.getHandler(), defaultServlet.getManagedServlet(), """", path);
+    }
+
+    private ServletPathMatch handleMatch(final String path, final PathMatch match, String matched, String remaining, final int qsPos, final int extensionPos) {
+        if (match.extensionMatches.isEmpty()) {
+            return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
+        } else {
+            if (extensionPos == -1) {
+                return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
+            } else {
+                final String ext;
+                if (qsPos == -1) {
+                    ext = path.substring(extensionPos + 1, path.length());
+                } else {
+                    ext = path.substring(extensionPos + 1, qsPos);
+                }
+                ServletChain handler = match.extensionMatches.get(ext);
+                if (handler != null) {
+                    //if this is an extension only mapping then the matched will be empty,
+                    //and we do not add the remaining to the match
+                    //as the path info should be null
+                    if (matched.isEmpty()) {
+                        if (qsPos == -1) {
+                            return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), path, null);
+                        } else {
+                            return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), path.substring(0, qsPos), null);
+                        }
+                    } else {
+                        return new ServletPathMatch(handler.getHandler(), handler.getManagedServlet(), matched, remaining);
+                    }
+                } else {
+                    return new ServletPathMatch(match.defaultHandler.getHandler(), match.defaultHandler.getManagedServlet(), matched, remaining);
+                }
+            }
+        }
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+
+        private final Map<String, ServletChain> exactPathMatches = new HashMap<>();
+
+        private final Map<String, PathMatch> prefixMatches = new HashMap<>();
+
+        private final Map<String, ServletChain> nameMatches = new HashMap<>();
+
+        private ServletChain defaultServlet;
+
+        public void addExactMatch(final String exactMatch, final ServletChain match) {
+            exactPathMatches.put(exactMatch, match);
+        }
+
+        public void addPrefixMatch(final String prefix, final ServletChain match) {
+            PathMatch m = prefixMatches.get(prefix);
+            if (m == null) {
+                prefixMatches.put(prefix, m = new PathMatch(match));
+            }
+            m.defaultHandler = match;
+        }
+
+        public void addExtensionMatch(final String prefix, final String extension, final ServletChain match) {
+            PathMatch m = prefixMatches.get(prefix);
+            if (m == null) {
+                prefixMatches.put(prefix, m = new PathMatch(null));
+            }
+            m.extensionMatches.put(extension, match);
+        }
+
+        public void addNameMatch(final String name, final ServletChain match) {
+            nameMatches.put(name, match);
+        }
+
+        public ServletChain getDefaultServlet() {
+            return defaultServlet;
+        }
+
+        public void setDefaultServlet(final ServletChain defaultServlet) {
+            this.defaultServlet = defaultServlet;
+        }
+
+        public ServletPathMatchesData build() {
+            return new ServletPathMatchesData(exactPathMatches, prefixMatches, nameMatches, defaultServlet);
+        }
+
+    }
+
+
+    private static class PathMatch {
+
+        private final Map<String, ServletChain> extensionMatches = new HashMap<>();
+        private volatile ServletChain defaultHandler;
+
+        public PathMatch(final ServletChain defaultHandler) {
+            this.defaultHandler = defaultHandler;
+        }
+    }
+
+
+}",2013-05-23T23:40:57Z,188
"@@ -29,6 +29,7 @@
 import javax.servlet.DispatcherType;
 import javax.servlet.FilterRegistration;
 
+import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.FilterInfo;
 import io.undertow.servlet.api.FilterMappingInfo;
@@ -39,15 +40,17 @@
 public class FilterRegistrationImpl implements FilterRegistration, FilterRegistration.Dynamic {
 
     private final FilterInfo filterInfo;
-    private final DeploymentInfo deploymentInfo;
+    private final Deployment deployment;
 
-    public FilterRegistrationImpl(final FilterInfo filterInfo, final DeploymentInfo deploymentInfo) {
+    public FilterRegistrationImpl(final FilterInfo filterInfo, final Deployment deployment) {
         this.filterInfo = filterInfo;
-        this.deploymentInfo = deploymentInfo;
+        this.deployment = deployment;
     }
 
     @Override
     public void addMappingForServletNames(final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... servletNames) {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
+
         for(final String servlet : servletNames){
             if(isMatchAfter) {
                 if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
@@ -67,10 +70,12 @@ public void addMappingForServletNames(final EnumSet<DispatcherType> dispatcherTy
                 }
             }
         }
+        deployment.getServletPaths().invalidate();
     }
 
     @Override
     public Collection<String> getServletNameMappings() {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
         final List<String> ret = new ArrayList<String>();
         for(final FilterMappingInfo mapping : deploymentInfo.getFilterMappings()) {
             if(mapping.getMappingType() == FilterMappingInfo.MappingType.SERVLET) {
@@ -84,6 +89,7 @@ public Collection<String> getServletNameMappings() {
 
     @Override
     public void addMappingForUrlPatterns(final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... urlPatterns) {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
         for(final String url : urlPatterns){
             if(isMatchAfter) {
                 if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
@@ -103,10 +109,12 @@ public void addMappingForUrlPatterns(final EnumSet<DispatcherType> dispatcherTyp
                 }
             }
         }
+        deployment.getServletPaths().invalidate();
     }
 
     @Override
     public Collection<String> getUrlPatternMappings() {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
         final List<String> ret = new ArrayList<String>();
         for(final FilterMappingInfo mapping : deploymentInfo.getFilterMappings()) {
             if(mapping.getMappingType() == FilterMappingInfo.MappingType.URL) {",2013-05-23T23:40:57Z,329
"@@ -195,14 +195,14 @@ public InputStream getResourceAsStream(final String path) {
 
     @Override
     public RequestDispatcher getRequestDispatcher(final String path) {
-        return new RequestDispatcherImpl(path, deployment.getServletContext());
+        return new RequestDispatcherImpl(path, this);
     }
 
     @Override
     public RequestDispatcher getNamedDispatcher(final String name) {
         ServletChain chain = deployment.getServletPaths().getServletHandlerByName(name);
         if (chain != null) {
-            return new RequestDispatcherImpl(chain, deployment.getServletContext());
+            return new RequestDispatcherImpl(chain, this);
         } else {
             return null;
         }
@@ -327,7 +327,8 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final St
         try {
             ServletInfo servlet = new ServletInfo(servletName, (Class<? extends Servlet>) deploymentInfo.getClassLoader().loadClass(className));
             deploymentInfo.addServlet(servlet);
-            return new ServletRegistrationImpl(servlet, deploymentInfo);
+            deployment.getServlets().addServlet(servlet);
+            return new ServletRegistrationImpl(servlet, deployment);
         } catch (ClassNotFoundException e) {
             throw UndertowServletMessages.MESSAGES.cannotLoadClass(className, e);
         }
@@ -337,14 +338,16 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final St
     public ServletRegistration.Dynamic addServlet(final String servletName, final Servlet servlet) {
         ServletInfo s = new ServletInfo(servletName, servlet.getClass(), new ImmediateInstanceFactory<Servlet>(servlet));
         deploymentInfo.addServlet(s);
-        return new ServletRegistrationImpl(s, deploymentInfo);
+        deployment.getServlets().addServlet(s);
+        return new ServletRegistrationImpl(s, deployment);
     }
 
     @Override
     public ServletRegistration.Dynamic addServlet(final String servletName, final Class<? extends Servlet> servletClass) {
         ServletInfo servlet = new ServletInfo(servletName, servletClass);
         deploymentInfo.addServlet(servlet);
-        return new ServletRegistrationImpl(servlet, deploymentInfo);
+        deployment.getServlets().addServlet(servlet);
+        return new ServletRegistrationImpl(servlet, deployment);
     }
 
     @Override
@@ -361,14 +364,14 @@ public <T extends Servlet> T createServlet(final Class<T> clazz) throws ServletE
     @Override
     public ServletRegistration getServletRegistration(final String servletName) {
         final ServletInfo servlet = deploymentInfo.getServlets().get(servletName);
-        return new ServletRegistrationImpl(servlet, deploymentInfo);
+        return new ServletRegistrationImpl(servlet, deployment);
     }
 
     @Override
     public Map<String, ? extends ServletRegistration> getServletRegistrations() {
         final Map<String, ServletRegistration> ret = new HashMap<String, ServletRegistration>();
         for (Map.Entry<String, ServletInfo> entry : deploymentInfo.getServlets().entrySet()) {
-            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue(), deploymentInfo));
+            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue(), deployment));
         }
         return ret;
     }
@@ -378,7 +381,8 @@ public FilterRegistration.Dynamic addFilter(final String filterName, final Strin
         try {
             FilterInfo filter = new FilterInfo(filterName, (Class<? extends Filter>) deploymentInfo.getClassLoader().loadClass(className));
             deploymentInfo.addFilter(filter);
-            return new FilterRegistrationImpl(filter, deploymentInfo);
+            deployment.getFilters().addFilter(filter);
+            return new FilterRegistrationImpl(filter, deployment);
         } catch (ClassNotFoundException e) {
             throw UndertowServletMessages.MESSAGES.cannotLoadClass(className, e);
         }
@@ -388,15 +392,17 @@ public FilterRegistration.Dynamic addFilter(final String filterName, final Strin
     public FilterRegistration.Dynamic addFilter(final String filterName, final Filter filter) {
         FilterInfo f = new FilterInfo(filterName, filter.getClass(), new ImmediateInstanceFactory<Filter>(filter));
         deploymentInfo.addFilter(f);
-        return new FilterRegistrationImpl(f, deploymentInfo);
+        deployment.getFilters().addFilter(f);
+        return new FilterRegistrationImpl(f, deployment);
 
     }
 
     @Override
     public FilterRegistration.Dynamic addFilter(final String filterName, final Class<? extends Filter> filterClass) {
         FilterInfo filter = new FilterInfo(filterName, filterClass);
         deploymentInfo.addFilter(filter);
-        return new FilterRegistrationImpl(filter, deploymentInfo);
+        deployment.getFilters().addFilter(filter);
+        return new FilterRegistrationImpl(filter, deployment);
     }
 
     @Override
@@ -416,14 +422,14 @@ public FilterRegistration getFilterRegistration(final String filterName) {
         if (filterInfo == null) {
             return null;
         }
-        return new FilterRegistrationImpl(filterInfo, deploymentInfo);
+        return new FilterRegistrationImpl(filterInfo, deployment);
     }
 
     @Override
     public Map<String, ? extends FilterRegistration> getFilterRegistrations() {
         final Map<String, FilterRegistration> ret = new HashMap<String, FilterRegistration>();
         for (Map.Entry<String, FilterInfo> entry : deploymentInfo.getFilters().entrySet()) {
-            ret.put(entry.getKey(), new FilterRegistrationImpl(entry.getValue(), deploymentInfo));
+            ret.put(entry.getKey(), new FilterRegistrationImpl(entry.getValue(), deployment));
         }
         return ret;
     }",2013-05-23T23:40:57Z,146
"@@ -30,6 +30,7 @@
 import javax.servlet.annotation.ServletSecurity;
 
 import io.undertow.UndertowMessages;
+import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.HttpMethodSecurityInfo;
 import io.undertow.servlet.api.SecurityConstraint;
@@ -48,11 +49,11 @@
 public class ServletRegistrationImpl implements ServletRegistration, ServletRegistration.Dynamic {
 
     private final ServletInfo servletInfo;
-    private final DeploymentInfo deploymentInfo;
+    private final Deployment deployment;
 
-    public ServletRegistrationImpl(final ServletInfo servletInfo, final DeploymentInfo deploymentInfo) {
+    public ServletRegistrationImpl(final ServletInfo servletInfo, final Deployment deployment) {
         this.servletInfo = servletInfo;
-        this.deploymentInfo = deploymentInfo;
+        this.deployment = deployment;
     }
 
     @Override
@@ -65,6 +66,7 @@ public Set<String> setServletSecurity(final ServletSecurityElement constraint) {
         if (constraint == null) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""constraint"");
         }
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
 
         //this is not super efficient, but it does not really matter
         final Set<String> urlPatterns = new HashSet<String>();
@@ -123,6 +125,7 @@ public void setAsyncSupported(final boolean isAsyncSupported) {
 
     @Override
     public Set<String> addMapping(final String... urlPatterns) {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
         final Set<String> ret = new HashSet<String>();
         final Set<String> existing = new HashSet<String>();
         for (ServletInfo s : deploymentInfo.getServlets().values()) {
@@ -143,6 +146,7 @@ public Set<String> addMapping(final String... urlPatterns) {
                 }
             }
         }
+        deployment.getServletPaths().invalidate();
         return ret;
     }
 ",2013-05-23T23:40:57Z,294
"@@ -807,7 +807,7 @@ public String getRequestCharacterEncoding() {
     public void setRequestCharacterEncoding(String encoding) {
         ensureNotInitialized();
         ensureNotProgramaticListener();
-        deploymentInfo.setDefaultRequestEncoding(getContextPath());
+        deploymentInfo.setDefaultRequestEncoding(encoding);
     }
 
     @Override",2019-05-16T13:38:08Z,146
"@@ -35,6 +35,7 @@
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -76,6 +77,35 @@ private void testDefaultEncoding(String defaultCharacterEncoding,
         }
     }
 
+    private void testServletContextCharacterEncoding(final String requestCharacterEncoding, final String responseCharacterEncoding)
+            throws IOException, ServletException {
+        DeploymentUtils.setupServlet(new ServletExtension() {
+                                         @Override
+                                         public void handleDeployment(final DeploymentInfo deploymentInfo, final ServletContext servletContext) {
+                                             servletContext.setRequestCharacterEncoding(requestCharacterEncoding);
+                                             servletContext.setResponseCharacterEncoding(responseCharacterEncoding);
+                                         }
+                                     },
+                Servlets.servlet(""servlet"", DefaultCharacterEncodingServlet.class).addMapping(""/""));
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String response = HttpClientUtils.readResponse(result);
+            final String expectedRequestCharEncoding = requestCharacterEncoding == null ? ""null"" : requestCharacterEncoding;
+            Assert.assertEquals(""Unexpected request character encoding"",
+                    expectedRequestCharEncoding, readParameter(response, ""requestCharacterEncoding""));
+            // spec mandates ""ISO-8859-1"" as the default (see javadoc of ServletResponse#getCharacterEncoding())
+            final String expectedResponseCharEncoding = responseCharacterEncoding == null ? ""ISO-8859-1"" : responseCharacterEncoding;
+            Assert.assertEquals(""Unexpected response character encoding"",
+                    expectedResponseCharEncoding, readParameter(response, ""responseCharacterEncoding""));
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+
+    }
+
     private String readParameter(String response, String parameter) {
         Pattern pattern = Pattern.compile(parameter + ""=(.*?);"");
         Matcher matcher = pattern.matcher(response);
@@ -100,4 +130,19 @@ public void testDefaultEncodingSetEqualDefault() throws IOException, ServletExce
     public void testDefaultEncodingSetNotEqualDefault() throws IOException, ServletException {
         testDefaultEncoding(""UTF-8"", ""UTF-8"", ""UTF-8"");
     }
+
+    /**
+     * Tests that the character encoding set on the servlet context using {@link ServletContext#setRequestCharacterEncoding(String)}
+     * and {@link ServletContext#setResponseCharacterEncoding(String)} is honoured at runtime during request/response processing
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testServletContextCharEncoding() throws Exception {
+        testServletContextCharacterEncoding(null, null);
+        testServletContextCharacterEncoding(""UTF-8"", null);
+        testServletContextCharacterEncoding(""UTF-8"", ""UTF-8"");
+        testServletContextCharacterEncoding(null, ""UTF-8"");
+        testServletContextCharacterEncoding(StandardCharsets.UTF_16BE.name(), ""UTF-8"");
+    }
 }",2019-05-16T13:38:08Z,330
"@@ -531,4 +531,20 @@ public interface UndertowMessages {
 
     @Message(id = 167, value = ""More than one host header in request"")
     IOException moreThanOneHostHeader();
+
+    @Message(id = 168, value = ""An invalid character [ASCII code: %s] was present in the cookie value"")
+    IllegalArgumentException invalidCookieValue(String value);
+
+    @Message(id = 169, value = ""An invalid domain [%s] was specified for this cookie"")
+    IllegalArgumentException invalidCookieDomain(String value);
+
+    @Message(id = 170, value = ""An invalid path [%s] was specified for this cookie"")
+    IllegalArgumentException invalidCookiePath(String value);
+
+    @Message(id = 173, value = ""An invalid control character [%s] was present in the cookie value or attribute"")
+    IllegalArgumentException invalidControlCharacter(String value);
+
+    @Message(id = 174, value = ""An invalid escape character in cookie value"")
+    IllegalArgumentException invalidEscapeCharacter();
+
 }",2017-06-23T23:11:28Z,68
"@@ -181,6 +181,15 @@ public class UndertowOptions {
      */
     public static final Option<Boolean> ALLOW_EQUALS_IN_COOKIE_VALUE = Option.simple(UndertowOptions.class, ""ALLOW_EQUALS_IN_COOKIE_VALUE"", Boolean.class);
 
+    /**
+     * If this is true then Undertow will enable RFC6265 compliant cookie validation for Set-Cookie header instead of legacy backward compatible behavior.
+     *
+     * default is false
+     */
+    public static final Option<Boolean> ENABLE_RFC6265_COOKIE_VALIDATION = Option.simple(UndertowOptions.class, ""ENABLE_RFC6265_COOKIE_VALIDATION"", Boolean.class);
+
+    public static final boolean DEFAULT_ENABLE_RFC6265_COOKIE_VALIDATION = false;
+
     /**
      * If we should attempt to use SPDY for HTTPS connections.
      *",2017-06-23T23:11:28Z,140
"@@ -27,6 +27,7 @@
 import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.LegacyCookieSupport;
 import io.undertow.util.ParameterLimitException;
 import io.undertow.util.StatusCodes;
 import io.undertow.util.URLUtils;
@@ -92,9 +93,10 @@ public class Connectors {
      */
     public static void flattenCookies(final HttpServerExchange exchange) {
         Map<String, Cookie> cookies = exchange.getResponseCookiesInternal();
+        boolean enableRfc6265Validation = exchange.getConnection().getUndertowOptions().get(UndertowOptions.ENABLE_RFC6265_COOKIE_VALIDATION, UndertowOptions.DEFAULT_ENABLE_RFC6265_COOKIE_VALIDATION);
         if (cookies != null) {
             for (Map.Entry<String, Cookie> entry : cookies.entrySet()) {
-                exchange.getResponseHeaders().add(Headers.SET_COOKIE, getCookieString(entry.getValue()));
+                exchange.getResponseHeaders().add(Headers.SET_COOKIE, getCookieString(entry.getValue(), enableRfc6265Validation));
             }
         }
     }
@@ -145,32 +147,99 @@ public static void resetRequestChannel(final HttpServerExchange exchange) {
         exchange.resetRequestChannel();
     }
 
-    private static String getCookieString(final Cookie cookie) {
-        switch (cookie.getVersion()) {
-            case 0:
-                return addVersion0ResponseCookieToExchange(cookie);
-            case 1:
-            default:
-                return addVersion1ResponseCookieToExchange(cookie);
+    private static String getCookieString(final Cookie cookie, boolean enableRfc6265Validation) {
+        if(enableRfc6265Validation) {
+            return addRfc6265ResponseCookieToExchange(cookie);
+        } else {
+            switch (LegacyCookieSupport.adjustedCookieVersion(cookie)) {
+                case 0:
+                    return addVersion0ResponseCookieToExchange(cookie);
+                case 1:
+                default:
+                    return addVersion1ResponseCookieToExchange(cookie);
+            }
         }
     }
 
     public static void setRequestStartTime(HttpServerExchange exchange) {
         exchange.setRequestStartTime(System.nanoTime());
     }
 
-    private static String addVersion0ResponseCookieToExchange(final Cookie cookie) {
+    private static String addRfc6265ResponseCookieToExchange(final Cookie cookie) {
         final StringBuilder header = new StringBuilder(cookie.getName());
         header.append(""="");
         header.append(cookie.getValue());
+        if (cookie.getPath() != null) {
+            header.append(""; Path="");
+            header.append(cookie.getPath());
+        }
+        if (cookie.getDomain() != null) {
+            header.append(""; Domain="");
+            header.append(cookie.getDomain());
+        }
+        if (cookie.isDiscard()) {
+            header.append(""; Discard"");
+        }
+        if (cookie.isSecure()) {
+            header.append(""; Secure"");
+        }
+        if (cookie.isHttpOnly()) {
+            header.append(""; HttpOnly"");
+        }
+        if (cookie.getMaxAge() != null) {
+            if (cookie.getMaxAge() >= 0) {
+                header.append(""; Max-Age="");
+                header.append(cookie.getMaxAge());
+            }
+            // Microsoft IE and Microsoft Edge don't understand Max-Age so send
+            // expires as well. Without this, persistent cookies fail with those
+            // browsers. They do understand Expires, even with V1 cookies.
+            // So, we add Expires header when Expires is not explicitly specified.
+            if (cookie.getExpires() == null) {
+                if (cookie.getMaxAge() == 0) {
+                    Date expires = new Date();
+                    expires.setTime(0);
+                    header.append(""; Expires="");
+                    header.append(DateUtils.toOldCookieDateString(expires));
+                } else if (cookie.getMaxAge() > 0) {
+                    Date expires = new Date();
+                    expires.setTime(expires.getTime() + cookie.getMaxAge() * 1000L);
+                    header.append(""; Expires="");
+                    header.append(DateUtils.toOldCookieDateString(expires));
+                }
+            }
+        }
+        if (cookie.getExpires() != null) {
+            header.append(""; Expires="");
+            header.append(DateUtils.toDateString(cookie.getExpires()));
+        }
+        if (cookie.getComment() != null && !cookie.getComment().isEmpty()) {
+            header.append(""; Comment="");
+            header.append(cookie.getComment());
+        }
+        if (cookie.isSameSite()) {
+            if (cookie.getSameSiteMode() != null && !cookie.getSameSiteMode().isEmpty()) {
+                header.append(""; SameSite="");
+                header.append(cookie.getSameSiteMode());
+            } else {
+                header.append(""; SameSite"");
+            }
+        }
+        return header.toString();
+    }
+
+    private static String addVersion0ResponseCookieToExchange(final Cookie cookie) {
+        final StringBuilder header = new StringBuilder(cookie.getName());
+        header.append(""="");
+        LegacyCookieSupport.maybeQuote(header, cookie.getValue());
 
         if (cookie.getPath() != null) {
             header.append(""; path="");
-            header.append(cookie.getPath());
+            LegacyCookieSupport.maybeQuote(header, cookie.getPath());
         }
         if (cookie.getDomain() != null) {
             header.append(""; domain="");
-            header.append(cookie.getDomain());
+            LegacyCookieSupport.maybeQuote(header, cookie.getDomain());
         }
         if (cookie.isSecure()) {
             header.append(""; secure"");
@@ -214,15 +283,15 @@ private static String addVersion1ResponseCookieToExchange(final Cookie cookie) {
 
         final StringBuilder header = new StringBuilder(cookie.getName());
         header.append(""="");
-        header.append(cookie.getValue());
+        LegacyCookieSupport.maybeQuote(header, cookie.getValue());
         header.append(""; Version=1"");
         if (cookie.getPath() != null) {
             header.append(""; Path="");
-            header.append(cookie.getPath());
+            LegacyCookieSupport.maybeQuote(header, cookie.getPath());
         }
         if (cookie.getDomain() != null) {
             header.append(""; Domain="");
-            header.append(cookie.getDomain());
+            LegacyCookieSupport.maybeQuote(header, cookie.getDomain());
         }
         if (cookie.isDiscard()) {
             header.append(""; Discard"");
@@ -238,14 +307,31 @@ private static String addVersion1ResponseCookieToExchange(final Cookie cookie) {
                 header.append(""; Max-Age="");
                 header.append(cookie.getMaxAge());
             }
+            // Microsoft IE and Microsoft Edge don't understand Max-Age so send
+            // expires as well. Without this, persistent cookies fail with those
+            // browsers. They do understand Expires, even with V1 cookies.
+            // So, we add Expires header when Expires is not explicitly specified.
+            if (cookie.getExpires() == null) {
+                if (cookie.getMaxAge() == 0) {
+                    Date expires = new Date();
+                    expires.setTime(0);
+                    header.append(""; Expires="");
+                    header.append(DateUtils.toOldCookieDateString(expires));
+                } else if (cookie.getMaxAge() > 0) {
+                    Date expires = new Date();
+                    expires.setTime(expires.getTime() + cookie.getMaxAge() * 1000L);
+                    header.append(""; Expires="");
+                    header.append(DateUtils.toOldCookieDateString(expires));
+                }
+            }
         }
         if (cookie.getExpires() != null) {
             header.append(""; Expires="");
             header.append(DateUtils.toDateString(cookie.getExpires()));
         }
         if (cookie.getComment() != null && !cookie.getComment().isEmpty()) {
             header.append(""; Comment="");
-            header.append(cookie.getComment());
+            LegacyCookieSupport.maybeQuote(header, cookie.getComment());
         }
         if (cookie.isSameSite()) {
             if (cookie.getSameSiteMode() != null && !cookie.getSameSiteMode().isEmpty()) {",2017-06-23T23:11:28Z,163
"@@ -45,6 +45,7 @@
 import io.undertow.util.Methods;
 import io.undertow.util.NetworkUtils;
 import io.undertow.util.Protocols;
+import io.undertow.util.Rfc6265CookieSupport;
 import io.undertow.util.StatusCodes;
 import org.jboss.logging.Logger;
 import org.xnio.Buffers;
@@ -1120,6 +1121,17 @@ public Map<String, Cookie> getRequestCookies() {
      * @param cookie The cookie
      */
     public HttpServerExchange setResponseCookie(final Cookie cookie) {
+        if(getConnection().getUndertowOptions().get(UndertowOptions.ENABLE_RFC6265_COOKIE_VALIDATION, UndertowOptions.DEFAULT_ENABLE_RFC6265_COOKIE_VALIDATION)) {
+            if (cookie.getValue() != null && !cookie.getValue().isEmpty()) {
+                Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+            }
+            if (cookie.getPath() != null && !cookie.getPath().isEmpty()) {
+                Rfc6265CookieSupport.validatePath(cookie.getPath());
+            }
+            if (cookie.getDomain() != null && !cookie.getDomain().isEmpty()) {
+                Rfc6265CookieSupport.validateDomain(cookie.getDomain());
+            }
+        }
         if (responseCookies == null) {
             responseCookies = new TreeMap<>(); //hashmap is slow to allocate in JDK7
         }",2017-06-23T23:11:28Z,132
"@@ -74,10 +74,8 @@ public void run() {
 
     private static final String OLD_COOKIE_PATTERN = ""EEE, dd-MMM-yyyy HH:mm:ss z"";
 
-
     private static final String COMMON_LOG_PATTERN = ""[dd/MMM/yyyy:HH:mm:ss Z]"";
 
-
     private static final ThreadLocal<SimpleDateFormat> COMMON_LOG_PATTERN_FORMAT = new ThreadLocal<SimpleDateFormat>() {
         @Override
         protected SimpleDateFormat initialValue() {
@@ -86,6 +84,15 @@ protected SimpleDateFormat initialValue() {
         }
     };
 
+    private static final ThreadLocal<SimpleDateFormat> OLD_COOKIE_FORMAT = new ThreadLocal<SimpleDateFormat>() {
+        @Override
+        protected SimpleDateFormat initialValue() {
+            SimpleDateFormat df = new SimpleDateFormat(OLD_COOKIE_PATTERN, LOCALE_US);
+            df.setTimeZone(GMT_ZONE);
+            return df;
+        }
+    };
+
     /**
      * Converts a date to a format suitable for use in a HTTP request
      *
@@ -103,9 +110,7 @@ public static String toDateString(final Date date) {
 
 
     public static String toOldCookieDateString(final Date date) {
-        SimpleDateFormat dateFormat = new SimpleDateFormat(OLD_COOKIE_PATTERN, LOCALE_US);
-        dateFormat.setTimeZone(GMT_ZONE);
-        return dateFormat.format(date);
+        return OLD_COOKIE_FORMAT.get().format(date);
     }
 
     public static String toCommonLogFormat(final Date date) {",2017-06-23T23:11:28Z,331
"@@ -0,0 +1,280 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package io.undertow.util;
+
+import io.undertow.UndertowMessages;
+import io.undertow.server.handlers.Cookie;
+
+/**
+ * Class that contains static constants and utility methods for legacy Set-Cookie format.
+ * Porting from JBossWeb and Tomcat code.
+ *
+ * Note that in general we do not use system properties for configuration, however as these are
+ * legacy options that are not widely used an exception has been made in this case.
+ *
+ */
+public final class LegacyCookieSupport {
+
+    // --------------------------------------------------------------- Constants
+
+
+    /**
+     * If true, separators that are not explicitly dis-allowed by the v0 cookie
+     * spec but are disallowed by the HTTP spec will be allowed in v0 cookie
+     * names and values. These characters are: \""()/:<=>?@[\\]{} Note that the
+     * inclusion of / depend on the value of {@link #FWD_SLASH_IS_SEPARATOR}.
+     *
+     * Defaults to false.
+     */
+    private static final boolean ALLOW_HTTP_SEPARATORS_IN_V0 = Boolean.getBoolean(""io.undertow.legacy.cookie.ALLOW_HTTP_SEPARATORS_IN_V0"");
+
+
+    /**
+     * If set to true, the <code>/</code> character will be treated as a
+     * separator. Default is false.
+     */
+    private static final boolean FWD_SLASH_IS_SEPARATOR = Boolean.getBoolean(""io.undertow.legacy.cookie.FWD_SLASH_IS_SEPARATOR"");
+
+    /**
+     * The list of separators that apply to version 0 cookies. To quote the
+     * spec, these are comma, semi-colon and white-space. The HTTP spec
+     * definition of linear white space is [CRLF] 1*( SP | HT )
+     */
+    private static final char[] V0_SEPARATORS = {',', ';', ' ', '\t'};
+    private static final boolean[] V0_SEPARATOR_FLAGS = new boolean[128];
+
+    /**
+     * The list of separators that apply to version 1 cookies. This may or may
+     * not include '/' depending on the setting of
+     * {@link #FWD_SLASH_IS_SEPARATOR}.
+     */
+    private static final char[] HTTP_SEPARATORS;
+    private static final boolean[] HTTP_SEPARATOR_FLAGS = new boolean[128];
+
+    static {
+        /*
+        Excluding the '/' char by default violates the RFC, but
+        it looks like a lot of people put '/'
+        in unquoted values: '/': ; //47
+        '\t':9 ' ':32 '\""':34 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60
+        '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
+        */
+        if (FWD_SLASH_IS_SEPARATOR) {
+            HTTP_SEPARATORS = new char[]{'\t', ' ', '\""', '(', ')', ',', '/',
+                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}'};
+        } else {
+            HTTP_SEPARATORS = new char[]{'\t', ' ', '\""', '(', ')', ',',
+                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}'};
+        }
+        for (int i = 0; i < 128; i++) {
+            V0_SEPARATOR_FLAGS[i] = false;
+            HTTP_SEPARATOR_FLAGS[i] = false;
+        }
+        for (char V0_SEPARATOR : V0_SEPARATORS) {
+            V0_SEPARATOR_FLAGS[V0_SEPARATOR] = true;
+        }
+        for (char HTTP_SEPARATOR : HTTP_SEPARATORS) {
+            HTTP_SEPARATOR_FLAGS[HTTP_SEPARATOR] = true;
+        }
+    }
+
+    // ----------------------------------------------------------------- Methods
+
+    /**
+     * Returns true if the byte is a separator as defined by V0 of the cookie
+     * spec.
+     */
+    private static boolean isV0Separator(final char c) {
+        if (c < 0x20 || c >= 0x7f) {
+            if (c != 0x09) {
+                throw UndertowMessages.MESSAGES.invalidControlCharacter(Integer.toString(c));
+            }
+        }
+
+        return V0_SEPARATOR_FLAGS[c];
+    }
+
+    private static boolean isV0Token(String value) {
+        if( value==null) return false;
+
+        int i = 0;
+        int len = value.length();
+
+        if (alreadyQuoted(value)) {
+            i++;
+            len--;
+        }
+
+        for (; i < len; i++) {
+            char c = value.charAt(i);
+
+            if (isV0Separator(c))
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the byte is a separator as defined by V1 of the cookie
+     * spec, RFC2109.
+     * @throws IllegalArgumentException if a control character was supplied as
+     *         input
+     */
+    private static boolean isHttpSeparator(final char c) {
+        if (c < 0x20 || c >= 0x7f) {
+            if (c != 0x09) {
+                throw UndertowMessages.MESSAGES.invalidControlCharacter(Integer.toString(c));
+            }
+        }
+
+        return HTTP_SEPARATOR_FLAGS[c];
+    }
+
+    private static boolean isHttpToken(String value) {
+        if( value==null) return false;
+
+        int i = 0;
+        int len = value.length();
+
+        if (alreadyQuoted(value)) {
+            i++;
+            len--;
+        }
+
+        for (; i < len; i++) {
+            char c = value.charAt(i);
+
+            if (isHttpSeparator(c))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean alreadyQuoted(String value) {
+        if (value==null || value.length() < 2) return false;
+        return (value.charAt(0)=='\""' && value.charAt(value.length()-1)=='\""');
+    }
+
+    /**
+     * Quotes values if required.
+     * @param buf
+     * @param value
+     */
+    public static void maybeQuote(StringBuilder buf, String value) {
+        if (value==null || value.length()==0) {
+            buf.append(""\""\"""");
+        } else if (alreadyQuoted(value)) {
+            buf.append('""');
+            buf.append(escapeDoubleQuotes(value,1,value.length()-1));
+            buf.append('""');
+        } else if ((isHttpToken(value) && !ALLOW_HTTP_SEPARATORS_IN_V0) ||
+                (isV0Token(value) && ALLOW_HTTP_SEPARATORS_IN_V0)) {
+            buf.append('""');
+            buf.append(escapeDoubleQuotes(value,0,value.length()));
+            buf.append('""');
+        } else {
+            buf.append(value);
+        }
+    }
+
+    /**
+     * Escapes any double quotes in the given string.
+     *
+     * @param s the input string
+     * @param beginIndex start index inclusive
+     * @param endIndex exclusive
+     * @return The (possibly) escaped string
+     */
+    private static String escapeDoubleQuotes(String s, int beginIndex, int endIndex) {
+
+        if (s == null || s.length() == 0 || s.indexOf('""') == -1) {
+            return s;
+        }
+
+        StringBuilder b = new StringBuilder();
+        for (int i = beginIndex; i < endIndex; i++) {
+            char c = s.charAt(i);
+            if (c == '\\' ) {
+                b.append(c);
+                //ignore the character after an escape, just append it
+                if (++i>=endIndex) throw UndertowMessages.MESSAGES.invalidEscapeCharacter();
+                b.append(s.charAt(i));
+            } else if (c == '""')
+                b.append('\\').append('""');
+            else
+                b.append(c);
+        }
+
+        return b.toString();
+    }
+
+    public static int adjustedCookieVersion(Cookie cookie) {
+
+        /*
+         * The spec allows some latitude on when to send the version attribute
+         * with a Set-Cookie header. To be nice to clients, we'll make sure the
+         * version attribute is first. That means checking the various things
+         * that can cause us to switch to a v1 cookie first.
+         *_
+         * Note that by checking for tokens we will also throw an exception if a
+         * control character is encountered.
+         */
+
+        int version = cookie.getVersion();
+
+        String value = cookie.getValue();
+        String path = cookie.getPath();
+        String domain = cookie.getDomain();
+        String comment = cookie.getComment();
+
+        // If it is v0, check if we need to switch
+        if (version == 0 &&
+                (!ALLOW_HTTP_SEPARATORS_IN_V0 && isHttpToken(value) ||
+                        ALLOW_HTTP_SEPARATORS_IN_V0 && isV0Token(value))) {
+            // HTTP token in value - need to use v1
+            version = 1;
+        }
+
+        if (version == 0 && comment != null) {
+            // Using a comment makes it a v1 cookie
+            version = 1;
+        }
+
+        if (version == 0 &&
+                (!ALLOW_HTTP_SEPARATORS_IN_V0 && isHttpToken(path) ||
+                        ALLOW_HTTP_SEPARATORS_IN_V0 && isV0Token(path))) {
+            // HTTP token in path - need to use v1
+            version = 1;
+        }
+
+        if (version == 0 &&
+                (!ALLOW_HTTP_SEPARATORS_IN_V0 && isHttpToken(domain) ||
+                        ALLOW_HTTP_SEPARATORS_IN_V0 && isV0Token(domain))) {
+            // HTTP token in domain - need to use v1
+            version = 1;
+        }
+
+        return version;
+    }
+
+    // ------------------------------------------------------------- Constructor
+    private LegacyCookieSupport() {
+        // Utility class. Don't allow instances to be created.
+    }
+}",2017-06-23T23:11:28Z,255
"@@ -0,0 +1,99 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the ""License""); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package io.undertow.util;
+
+import io.undertow.UndertowMessages;
+import java.util.BitSet;
+
+/**
+ * Class that contains utility methods for dealing with RFC6265 Cookies.
+ *
+ */
+public final class Rfc6265CookieSupport {
+
+    private static final BitSet domainValid = new BitSet(128);
+
+    static {
+        for (char c = '0'; c <= '9'; c++) {
+            domainValid.set(c);
+        }
+        for (char c = 'a'; c <= 'z'; c++) {
+            domainValid.set(c);
+        }
+        for (char c = 'A'; c <= 'Z'; c++) {
+            domainValid.set(c);
+        }
+        domainValid.set('.');
+        domainValid.set('-');
+    }
+
+    public static void validateCookieValue(String value) {
+        int start = 0;
+        int end = value.length();
+
+        if (end > 1 && value.charAt(0) == '""' && value.charAt(end - 1) == '""') {
+            start = 1;
+            end--;
+        }
+
+        char[] chars = value.toCharArray();
+        for (int i = start; i < end; i++) {
+            char c = chars[i];
+            if (c < 0x21 || c == 0x22 || c == 0x2c || c == 0x3b || c == 0x5c || c == 0x7f) {
+                throw UndertowMessages.MESSAGES.invalidCookieValue(Integer.toString(c));
+            }
+        }
+    }
+
+    public static void validateDomain(String domain) {
+        int i = 0;
+        int prev = -1;
+        int cur = -1;
+        char[] chars = domain.toCharArray();
+        while (i < chars.length) {
+            prev = cur;
+            cur = chars[i];
+            if (!domainValid.get(cur)) {
+                throw UndertowMessages.MESSAGES.invalidCookieDomain(domain);
+            }
+            // labels must start with a letter or number
+            if ((prev == '.' || prev == -1) && (cur == '.' || cur == '-')) {
+                throw UndertowMessages.MESSAGES.invalidCookieDomain(domain);
+            }
+            // labels must end with a letter or number
+            if (prev == '-' && cur == '.') {
+                throw UndertowMessages.MESSAGES.invalidCookieDomain(domain);
+            }
+            i++;
+        }
+        // domain must end with a label
+        if (cur == '.' || cur == '-') {
+            throw UndertowMessages.MESSAGES.invalidCookieDomain(domain);
+        }
+    }
+
+    public static void validatePath(String path) {
+        char[] chars = path.toCharArray();
+
+        for (int i = 0; i < chars.length; i++) {
+            char ch = chars[i];
+            if (ch < 0x20 || ch > 0x7E || ch == ';') {
+                throw UndertowMessages.MESSAGES.invalidCookiePath(path);
+            }
+        }
+    }
+}",2017-06-23T23:11:28Z,332
"@@ -278,4 +278,62 @@ public void testSameSiteCookie() {
     public void testInvalidSameSiteCookie() {
         Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=WILE_E_COYOTE; path=/; SameSite=test"");
     }
+
+    // RFC6265 allows US-ASCII characters excluding CTLs, whitespace,
+    // double quote, comma, semicolon and backslash as cookie value.
+    // This does not change even if value is quoted.
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue() {
+        // whitespace is not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=WILE_ E_COYOTE; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue1() {
+        // whitespace is not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=\""WILE_ E_COYOTE\""; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue2() {
+        // double quote si not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=\""WILE_\\\""E_COYOTE\""; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue3() {
+        // comma is not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=\""WILE_,E_COYOTE\""; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue4() {
+        // semicolon is not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=\""WILE_;E_COYOTE\""; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInValue5() {
+        /// backslash is not allowed
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=\""WILE_\\E_COYOTE\""; path=/example; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+    }
+
+    // RFC6265 allows any CHAR except CTLs or "";"" as cookie path
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInPath() {
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=WILE_E_COYOTE; path=\""/ex;ample\""; domain=example.com"");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+        Rfc6265CookieSupport.validatePath(cookie.getPath());
+        Rfc6265CookieSupport.validateDomain(cookie.getDomain());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidRfc6265CookieInDomain() {
+        Cookie cookie = Cookies.parseSetCookieHeader(""CUSTOMER=WILE_E_COYOTE; path=/example; domain=\""ex;ample.com\"""");
+        Rfc6265CookieSupport.validateCookieValue(cookie.getValue());
+        Rfc6265CookieSupport.validatePath(cookie.getPath());
+        Rfc6265CookieSupport.validateDomain(cookie.getDomain());
+    }
+
 }",2017-06-23T23:11:28Z,215
"@@ -169,6 +169,29 @@
         </testResources>
 
         <plugins>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    org.eclipse.jetty.*;resolution:=optional;version=""[1,2)"",
+                                    !., !sun.*, !org.xnio._private, *
+                                </Import-Package>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
@@ -183,6 +206,11 @@
                         </configuration>
                     </execution>
                 </executions>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
             </plugin>
             <plugin>
                 <groupId>org.bitstrings.maven.plugins</groupId>",2017-06-21T03:54:32Z,333
"@@ -409,4 +409,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String
     @LogMessage(level = ERROR)
     @Message(id = 5088, value = ""Failed to execute ServletOutputStream.closeAsync() on IO thread"")
     void closeAsyncFailed(@Cause IOException e);
+
+    @Message(id = 5089, value = ""Method parameter '%s' cannot be null"")
+    IllegalArgumentException nullParameter(String name);
 }",2017-06-21T03:54:32Z,65
"@@ -54,8 +54,6 @@
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLParameters;
 
-import static org.xnio._private.Messages.msg;
-
 /**
  * @author Stuart Douglas
  */
@@ -144,7 +142,7 @@ public <T> T setOption(final Option<T> option, final T value) throws IllegalArgu
         } else {
             return tcpServer.setOption(option, value);
         }
-        throw msg.nullParameter(""value"");
+        throw UndertowLogger.ROOT_LOGGER.nullParameter(""value"");
     }
 
     public XnioWorker getWorker() {",2017-06-21T03:54:32Z,232
"@@ -0,0 +1,196 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ JBoss, Home of Professional Open Source.
+  ~ Copyright 2012 Red Hat, Inc., and individual contributors
+  ~ as indicated by the @author tags.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>io.undertow</groupId>
+        <artifactId>undertow-parent</artifactId>
+        <version>2.0.0.Alpha2-SNAPSHOT</version>
+    </parent>
+
+    <groupId>io.undertow</groupId>
+    <artifactId>karaf</artifactId>
+    <version>2.0.0.Alpha2-SNAPSHOT</version>
+    <packaging>pom</packaging>
+
+    <name>Undertow Karaf Features</name>
+
+    <properties>
+        <test.level>INFO</test.level>
+        <ajp>false</ajp>
+        <proxy>false</proxy>
+        <dump>false</dump>
+        <https>false</https>
+        <openssl>false</openssl>
+        <test.ipv6>false</test.ipv6>
+        <bufferSize>8192</bufferSize>
+        <libraryPath></libraryPath>
+        <java.library.path></java.library.path>
+        <org.wildfly.openssl.path></org.wildfly.openssl.path>
+        <dependency.karaf.version>4.0.7</dependency.karaf.version>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.karaf.features</groupId>
+            <artifactId>framework</artifactId>
+            <version>${dependency.karaf.version}</version>
+            <type>kar</type>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-core</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-servlet</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-websockets-jsr</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging-processor</artifactId>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.xnio</groupId>
+            <artifactId>xnio-api</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.xnio</groupId>
+            <artifactId>xnio-nio</artifactId>
+            <scope>runtime</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.eclipse.jetty.alpn</groupId>
+            <artifactId>alpn-api</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+
+    <build>
+        <resources>
+            <resource>
+                <directory>src/main/resources</directory>
+                <filtering>true</filtering>
+            </resource>
+        </resources>
+
+        <plugins>
+            <plugin>
+                <groupId>io.reformanda.semper</groupId>
+                <artifactId>dependencyversion-maven-plugin</artifactId>
+                <version>1.0.0</version>
+                <executions>
+                    <execution>
+                        <id>set-all</id>
+                        <goals>
+                            <goal>set-version</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>filter</id>
+                        <phase>generate-resources</phase>
+                        <goals>
+                            <goal>resources</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.karaf.tooling</groupId>
+                <artifactId>karaf-maven-plugin</artifactId>
+                <version>${dependency.karaf.version}</version>
+                <executions>
+                    <execution>
+                        <id>verify</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>verify</goal>
+                        </goals>
+                        <configuration>
+                            <descriptors>
+                                <descriptor>mvn:org.apache.karaf.features/framework/${dependency.karaf.version}/xml/features</descriptor>
+                                <descriptor>file:${project.build.directory}/classes/features.xml</descriptor>
+                            </descriptors>
+                            <distribution>org.apache.karaf.features:framework</distribution>
+                            <javase>1.8</javase>
+                            <framework>
+                                <feature>framework</feature>
+                            </framework>
+                            <features>
+                                <feature>undertow</feature>
+                            </features>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>build-helper-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>attach-artifacts</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>attach-artifact</goal>
+                        </goals>
+                        <configuration>
+                            <artifacts>
+                                <artifact>
+                                    <file>target/classes/features.xml</file>
+                                    <type>xml</type>
+                                    <classifier>features</classifier>
+                                </artifact>
+                            </artifacts>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2017-06-21T03:54:32Z,334
"@@ -0,0 +1,34 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- 
+
+    Licensed under the Apache License, Version 2.0 (the ""License"");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+
+<features name=""io.undertow-${project.version}"" xmlns=""http://karaf.apache.org/xmlns/features/v1.0.0"">
+
+    <feature name=""undertow"" version=""${project.version}"">
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.annotation/jboss-annotations-api_1.2_spec/${version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.servlet/jboss-servlet-api_4.0_spec/${version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.websocket/jboss-websocket-api_1.1_spec/${version.org.jboss.spec.javax.websockets}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.logging/jboss-logging/${version.org.jboss.logging}</bundle>
+        <bundle dependency=""true"">mvn:org.wildfly.common/wildfly-common/${org.wildfly.common:wildfly-common:jar.version}</bundle>
+        <bundle dependency=""true"">mvn:org.wildfly.client/wildfly-client-config/${org.wildfly.client:wildfly-client-config:jar.version}</bundle>
+        <bundle>mvn:org.jboss.xnio/xnio-api/${version.xnio}</bundle>
+        <bundle>mvn:org.jboss.xnio/xnio-nio/${version.xnio}</bundle>
+        <bundle>mvn:io.undertow/undertow-core/${project.version}</bundle>
+        <bundle>mvn:io.undertow/undertow-servlet/${project.version}</bundle>
+        <bundle>mvn:io.undertow/undertow-websockets-jsr/${project.version}</bundle>
+    </feature>
+
+</features>",2017-06-21T03:54:32Z,335
"@@ -70,14 +70,16 @@
         <version.org.apache.httpcomponents>4.2.6</version.org.apache.httpcomponents>
         <version.org.glassfish.el>3.0.1-b08</version.org.glassfish.el>
         <version.org.jboss.classfilewriter>1.0.5.Final</version.org.jboss.classfilewriter>
-        <version.org.jboss.logging>3.2.1.Final</version.org.jboss.logging>
+        <version.org.jboss.logging>3.3.0.Final</version.org.jboss.logging>
         <version.org.jboss.logging.processor>2.0.0.Final</version.org.jboss.logging.processor>
         <version.org.jboss.logmanager>2.0.0.Final</version.org.jboss.logmanager>
         <version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>1.0.0.Alpha3</version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>
         <version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>1.0.0.Final</version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>
         <version.org.jboss.spec.javax.servlet.jsp>1.0.0.Final</version.org.jboss.spec.javax.servlet.jsp>
         <version.org.jboss.spec.javax.websockets>1.1.0.Final</version.org.jboss.spec.javax.websockets>
-        <version.xnio>3.3.6.Final</version.xnio>
+        <version.xnio>3.5.0.Beta7</version.xnio>
+        <version.org.wildfly.client.config>1.0.0.Beta5</version.org.wildfly.client.config> <!-- TODO: remove this once XNIO has been updated to include this version -->
+        <version.org.osgi.core>6.0.0</version.org.osgi.core>
 
         <!-- jacoco -->
         <version.org.jacoco>0.7.9</version.org.jacoco>
@@ -117,6 +119,7 @@
         <module>servlet</module>
         <module>examples</module>
         <module>websockets-jsr</module>
+        <module>karaf</module>
     </modules>
 
     <build>
@@ -239,6 +242,11 @@
                         </lifecycleMappingMetadata>
                     </configuration>
                 </plugin>
+                <plugin>
+                    <groupId>org.apache.felix</groupId>
+                    <artifactId>maven-bundle-plugin</artifactId>
+                    <version>3.2.0</version>
+                </plugin>
             </plugins>
         </pluginManagement>
     </build>
@@ -413,6 +421,18 @@
                 <version>${version.xnio}</version>
             </dependency>
 
+            <dependency>
+                <groupId>org.wildfly.client</groupId>
+                <artifactId>wildfly-client-config</artifactId>
+                <version>${version.org.wildfly.client.config}</version>
+            </dependency>
+
+            <dependency>
+                <groupId>org.osgi</groupId>
+                <artifactId>org.osgi.core</artifactId>
+                <version>${version.org.osgi.core}</version>
+            </dependency>
+
             <dependency>
                 <groupId>com.h2database</groupId>
                 <artifactId>h2</artifactId>",2017-06-21T03:54:32Z,265
"@@ -65,6 +65,14 @@
             <groupId>org.jboss.spec.javax.annotation</groupId>
             <artifactId>jboss-annotations-api_1.2_spec</artifactId>
         </dependency>
+
+        <dependency>
+            <groupId>org.osgi</groupId>
+            <artifactId>org.osgi.core</artifactId>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
+
         <!-- Test dependencies -->
 
         <dependency>
@@ -153,6 +161,31 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.servlet*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    !sun.*, *
+                                </Import-Package>
+                                <Bundle-Activator>
+                                    io.undertow.servlet.osgi.Activator
+                                </Bundle-Activator>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
@@ -167,6 +200,11 @@
                         </configuration>
                     </execution>
                 </executions>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>",2017-06-21T03:54:32Z,313
"@@ -284,6 +284,13 @@ private void handleExtensions(final DeploymentInfo deploymentInfo, final Servlet
                 }
             }
         }
+
+        for (ServletExtension extension : ServletExtensionHolder.getServletExtensions()) {
+            if (!loadedExtensions.contains(extension.getClass())) {
+                extension.handleDeployment(deploymentInfo, servletContext);
+            }
+        }
+
         for(ServletExtension extension : deploymentInfo.getServletExtensions()) {
             extension.handleDeployment(deploymentInfo, servletContext);
         }",2017-06-21T03:54:32Z,80
"@@ -0,0 +1,39 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.core;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.undertow.servlet.ServletExtension;
+
+/**
+ * Holder for global ServletExtension services.
+ * This is particularly useful in an OSGi environment where classloader constraints
+ * lead to the ServiceLoader not able to see ServletExtension implementations.
+ */
+public class ServletExtensionHolder {
+
+    private static List<ServletExtension> extensions = new CopyOnWriteArrayList<>();
+
+    public static List<ServletExtension> getServletExtensions() {
+        return extensions;
+    }
+
+}",2017-06-21T03:54:32Z,336
"@@ -0,0 +1,67 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.osgi;
+
+import io.undertow.servlet.ServletExtension;
+import io.undertow.servlet.core.ServletExtensionHolder;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.util.tracker.ServiceTracker;
+import org.osgi.util.tracker.ServiceTrackerCustomizer;
+
+/**
+ * OSGi Activator.
+ * The activator is called when the bundle is started.
+ * It tracks ServletExtension services registered in the OSGi registry
+ * and will update the {@link ServletExtensionHolder#getServletExtensions()}
+ * list accordingly.
+ */
+public class Activator implements BundleActivator, ServiceTrackerCustomizer<ServletExtension, ServletExtension> {
+
+    BundleContext bundleContext;
+    ServiceTracker<ServletExtension, ServletExtension> tracker;
+
+    @Override
+    public void start(BundleContext context) throws Exception {
+        bundleContext = context;
+        tracker = new ServiceTracker<>(context, ServletExtension.class, this);
+        tracker.open();
+    }
+
+    @Override
+    public void stop(BundleContext context) throws Exception {
+        tracker.close();
+    }
+
+    @Override
+    public ServletExtension addingService(ServiceReference<ServletExtension> reference) {
+        return null;
+    }
+
+    @Override
+    public void modifiedService(ServiceReference<ServletExtension> reference, ServletExtension service) {
+        ServletExtensionHolder.getServletExtensions().add(service);
+    }
+
+    @Override
+    public void removedService(ServiceReference<ServletExtension> reference, ServletExtension service) {
+        ServletExtensionHolder.getServletExtensions().remove(service);
+    }
+}",2017-06-21T03:54:32Z,337
"@@ -60,6 +60,12 @@
             <artifactId>jboss-logging-processor</artifactId>
             <scope>provided</scope>
         </dependency>
+        <dependency>
+            <groupId>org.osgi</groupId>
+            <artifactId>org.osgi.core</artifactId>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
 
         <!-- Test dependencies -->
 
@@ -128,6 +134,31 @@
         </testResources>
 
         <plugins>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.websockets.jsr.*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    !sun.*, *
+                                </Import-Package>
+                                <Bundle-Activator>
+                                    io.undertow.websockets.jsr.osgi.Activator
+                                </Bundle-Activator>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
@@ -149,6 +180,15 @@
                     <argLine>${surefire.system.args} ${jacoco.agent.argLine}</argLine>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2017-06-21T03:54:32Z,236
"@@ -0,0 +1,46 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.websockets.jsr.osgi;
+
+import io.undertow.servlet.ServletExtension;
+import io.undertow.websockets.jsr.Bootstrap;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+
+/**
+ * OSGi Activator.  This activator will be called when the bundle is started.
+ * Its purpose is to register the ServletExtension to support websockets.
+ */
+public class Activator implements BundleActivator {
+
+    ServiceRegistration<ServletExtension> registration;
+
+    @Override
+    public void start(BundleContext context) throws Exception {
+        // Register the service in the OSGi registry.
+        registration = context.registerService(ServletExtension.class, new Bootstrap(), null);
+    }
+
+    @Override
+    public void stop(BundleContext context) throws Exception {
+        // Now, unregister the service.
+        registration.unregister();
+    }
+}",2017-06-21T03:54:32Z,338
"@@ -40,6 +40,8 @@ public class Cookies {
     public static final String VERSION = ""$Version"";
     public static final String PATH = ""$Path"";
 
+
+
     /**
      * Parses a ""Set-Cookie:"" response header value into its cookie representation. The header value is parsed according to the
      * syntax that's defined in RFC2109:
@@ -197,19 +199,22 @@ private static void handleValue(CookieImpl cookie, String key, String value) {
      * @see <a href=""http://tools.ietf.org/search/rfc2109"">rfc2109</a>
      */
     public static Map<String, Cookie> parseRequestCookies(int maxCookies, boolean allowEqualInValue, List<String> cookies) {
+        return parseRequestCookies(maxCookies, allowEqualInValue, cookies, LegacyCookieSupport.COMMA_IS_SEPERATOR);
+    }
 
+    static Map<String, Cookie> parseRequestCookies(int maxCookies, boolean allowEqualInValue, List<String> cookies, boolean commaIsSeperator) {
         if (cookies == null) {
             return new TreeMap<>();
         }
         final Map<String, Cookie> parsedCookies = new TreeMap<>();
 
         for (String cookie : cookies) {
-            parseCookie(cookie, parsedCookies, maxCookies, allowEqualInValue);
+            parseCookie(cookie, parsedCookies, maxCookies, allowEqualInValue, commaIsSeperator);
         }
         return parsedCookies;
     }
 
-    private static void parseCookie(final String cookie, final Map<String, Cookie> parsedCookies, int maxCookies, boolean allowEqualInValue) {
+    private static void parseCookie(final String cookie, final Map<String, Cookie> parsedCookies, int maxCookies, boolean allowEqualInValue, boolean commaIsSeperator) {
         int state = 0;
         String name = null;
         int start = 0;
@@ -234,7 +239,7 @@ private static void parseCookie(final String cookie, final Map<String, Cookie> p
                         name = cookie.substring(start, i);
                         start = i + 1;
                         state = 2;
-                    } else if (c == ';') {
+                    } else if (c == ';' || (commaIsSeperator && c == ',')) {
                         if(name != null) {
                             cookieCount = createCookie(name, cookie.substring(start, i), maxCookies, cookieCount, cookies, additional);
                         } else if(UndertowLogger.REQUEST_LOGGER.isTraceEnabled()) {
@@ -247,7 +252,7 @@ private static void parseCookie(final String cookie, final Map<String, Cookie> p
                 }
                 case 2: {
                     //extract value
-                    if (c == ';') {
+                    if (c == ';' || (commaIsSeperator && c == ',')) {
                         cookieCount = createCookie(name, cookie.substring(start, i), maxCookies, cookieCount, cookies, additional);
                         state = 0;
                         start = i + 1;
@@ -272,7 +277,7 @@ private static void parseCookie(final String cookie, final Map<String, Cookie> p
                 }
                 case 4: {
                     //skip value portion behind '='
-                    if (c == ';') {
+                    if (c == ';' || (commaIsSeperator && c == ',')) {
                         state = 0;
                     }
                     start = i + 1;",2017-08-23T02:11:09Z,212
"@@ -51,6 +51,13 @@ public final class LegacyCookieSupport {
      */
     private static final boolean FWD_SLASH_IS_SEPARATOR = Boolean.getBoolean(""io.undertow.legacy.cookie.FWD_SLASH_IS_SEPARATOR"");
 
+
+    /**
+     * If set to true, the <code,</code> character will be treated as a
+     * separator in Cookie: headers.
+     */
+    static final boolean COMMA_IS_SEPERATOR = Boolean.getBoolean(""io.undertow.legacy.cookie.COMMA_IS_SEPARATOR"");
+
     /**
      * The list of separators that apply to version 0 cookies. To quote the
      * spec, these are comma, semi-colon and white-space. The HTTP spec",2017-08-23T02:11:09Z,255
"@@ -199,6 +199,27 @@ public void testEqualsInValueNotAllowedInQuotedValue() {
         Assert.assertNotNull(cookie);
         Assert.assertEquals(""FEDEX"", cookie.getValue());
     }
+    @Test
+    public void testCommaSeparatedCookies() {
+        Map<String, Cookie> cookies = Cookies.parseRequestCookies(2, false, Arrays.asList(""CUSTOMER=\""WILE_E_COYOTE\"", SHIPPING=FEDEX"" ), true);
+        Assert.assertEquals(2, cookies.size());
+        Cookie cookie = cookies.get(""CUSTOMER"");
+        Assert.assertNotNull(cookie);
+        Assert.assertEquals(""WILE_E_COYOTE"", cookie.getValue());
+        cookie = cookies.get(""SHIPPING"");
+        Assert.assertNotNull(cookie);
+        Assert.assertEquals(""FEDEX"", cookie.getValue());
+
+        //also make sure semi colon works as normal
+        cookies = Cookies.parseRequestCookies(2, false, Arrays.asList(""CUSTOMER=\""WILE_E_COYOTE\""; SHIPPING=FEDEX"" ), true);
+        Assert.assertEquals(2, cookies.size());
+        cookie = cookies.get(""CUSTOMER"");
+        Assert.assertNotNull(cookie);
+        Assert.assertEquals(""WILE_E_COYOTE"", cookie.getValue());
+        cookie = cookies.get(""SHIPPING"");
+        Assert.assertNotNull(cookie);
+        Assert.assertEquals(""FEDEX"", cookie.getValue());
+    }
 
     @Test
     public void testSimpleJSONObjectInRequestCookies() {",2017-08-23T02:11:09Z,215
"@@ -117,4 +117,16 @@ public interface UndertowLogger extends BasicLogger {
     @Message(id = 5018, value = ""Exception occurred during authentication using handler %s"")
     void exceptionWhileAuthenticating(final AuthenticationMechanism handler, @Cause IOException exception);
 
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5019, value = ""An invalid token '%s' with value '%s' has been received."")
+    void invalidTokenReceived(final String tokenName, final String tokenValue);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5020, value = ""A mandatory token %s is missing from the request."")
+    void missingAuthorizationToken(final String tokenName);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5021, value = ""Verification of authentication tokens for user '%s' has failed using mechanism '%s'."")
+    void authenticationFailed(final String userName, final String mechanism);
+
 }",2012-10-31T04:56:32Z,65
"@@ -17,6 +17,12 @@
  */
 package io.undertow.server.handlers.security;
 
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
 /**
  * Enumeration of the supported digest algorithms.
  *
@@ -26,6 +32,19 @@ public enum DigestAlgorithm {
 
     MD5(""MD5"", ""MD5"", false), MD5_SESS(""MD5-sess"", ""MD5"", true);
 
+    private static final Map<String, DigestAlgorithm> BY_TOKEN;
+
+    static {
+        DigestAlgorithm[] algorithms = DigestAlgorithm.values();
+
+        Map<String, DigestAlgorithm> byToken = new HashMap<String, DigestAlgorithm>(algorithms.length);
+        for (DigestAlgorithm current : algorithms) {
+            byToken.put(current.token, current);
+        }
+
+        BY_TOKEN = Collections.unmodifiableMap(byToken);
+    }
+
     private final String token;
     private final String digestAlgorithm;
     private final boolean session;
@@ -48,4 +67,13 @@ public boolean isSession() {
         return session;
     }
 
+    public MessageDigest getMessageDigest() throws NoSuchAlgorithmException {
+        // TODO - If we end up always Hex based then may use a wrapper here.
+        return MessageDigest.getInstance(digestAlgorithm);
+    }
+
+    public static DigestAlgorithm forName(final String name) {
+        return BY_TOKEN.get(name);
+    }
+
 }",2012-10-31T04:56:32Z,130
"@@ -1,225 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.undertow.server.handlers.security;
-
-import static io.undertow.server.handlers.security.DigestAuthorizationToken.parseHeader;
-import static io.undertow.util.Headers.AUTHORIZATION;
-import static io.undertow.util.Headers.DIGEST;
-import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
-import static io.undertow.util.WorkerDispatcher.dispatch;
-import io.undertow.server.HttpCompletionHandler;
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.util.HeaderMap;
-import io.undertow.util.Headers;
-
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import javax.security.auth.callback.CallbackHandler;
-
-/**
- * {@link HttpHandler} to handle HTTP Digest authentication, both according to RFC-2617 and draft update to allow additional
- * algorithms to be used.
- *
- * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
- */
-public class DigestAuthenticationHandler implements HttpHandler {
-
-    private static final String DIGEST_PREFIX = DIGEST + "" "";
-    private static final int PREFIX_LENGTH = DIGEST_PREFIX.length();
-
-    private final HttpHandler next;
-    /**
-     * The {@link List} of supported algorithms, this is assumed to be in priority order.
-     */
-    private final List<DigestAlgorithm> supportedAlgorithms;
-    private final List<DigestQop> supportedQops;
-    private final String qopString;
-    private final String realmName; // TODO - Will offer choice once backing store API/SPI is in.
-    private final CallbackHandler callbackHandler;
-    private final NonceManager nonceManager;
-
-    // Some form of nonce factory.
-
-    // Where do session keys fit? Do we just hang onto a session key or keep visiting the user store to check if the password
-    // has changed?
-    // Maybe even support registration of a session so it can be invalidated?
-
-    public DigestAuthenticationHandler(final HttpHandler next, final List<DigestAlgorithm> supportedAlgorithms,
-            final List<DigestQop> supportedQops, final String realmName, final CallbackHandler callbackHandler,
-            final NonceManager nonceManager) {
-        this.next = next;
-        this.supportedAlgorithms = supportedAlgorithms;
-        this.supportedQops = supportedQops;
-        this.realmName = realmName;
-        this.callbackHandler = callbackHandler;
-        this.nonceManager = nonceManager;
-
-        if (supportedQops.size() > 0) {
-            StringBuilder sb = new StringBuilder();
-            Iterator<DigestQop> it = supportedQops.iterator();
-            sb.append(it.next().getToken());
-            while (it.hasNext()) {
-                sb.append("","").append(it.next().getToken());
-            }
-            qopString = sb.toString();
-        } else {
-            qopString = null;
-        }
-    }
-
-    /**
-     *
-     * @see io.undertow.server.HttpHandler#handleRequest(io.undertow.server.HttpServerExchange,
-     *      io.undertow.server.HttpCompletionHandler)
-     */
-    @Override
-    public void handleRequest(HttpServerExchange exchange, HttpCompletionHandler completionHandler) {
-        HttpCompletionHandler wrapperCompletionHandler = new DigestCompletionHandler(exchange, completionHandler);
-        SecurityContext context = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
-        AuthenticationState authState = context.getAuthenticationState();
-
-        if (false /*authState == AuthenticationState.REQUIRED || authState == AuthenticationState.NOT_REQUIRED*/) {
-            Deque<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);
-            if (authHeaders != null) {
-                for (String current : authHeaders) {
-                    if (current.startsWith(DIGEST_PREFIX)) {
-                        String digestChallenge = current.substring(PREFIX_LENGTH);
-
-                        try {
-                            Map<DigestAuthorizationToken, String> parsedHeader = parseHeader(digestChallenge);
-
-                            dispatch(exchange, new DigestRunnable(exchange, wrapperCompletionHandler, parsedHeader));
-
-                            // The request has now potentially been dispatched to a different worker thread, the run method
-                            // within BasicRunnable is now responsible for ensuring the request continues.
-                            return;
-                        } catch (Exception e) {
-                            e.printStackTrace();
-                        }
-                    }
-
-                    // By this point we had a header we should have been able to verify but for some reason
-                    // it was not correctly structured.
-                    /*context.setAuthenticationState(AuthenticationState.FAILED);*/
-                }
-            }
-
-        }
-
-        // Either an authentication attempt has already occurred or no suitable header has been found in this request,
-        // either way let the call continue for the final decision to be made in the SecurityEndHandler.
-        next.handleRequest(exchange, wrapperCompletionHandler);
-
-    }
-
-    private final class DigestRunnable implements Runnable {
-
-        private final HttpServerExchange exchange;
-        private final HttpCompletionHandler completionHandler;
-        private final Map<DigestAuthorizationToken, String> parsedHeader;
-
-        private DigestRunnable(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler,
-                Map<DigestAuthorizationToken, String> parsedHeader) {
-            this.exchange = exchange;
-            this.completionHandler = completionHandler;
-            this.parsedHeader = parsedHeader;
-        }
-
-        public void run() {
-
-        }
-    }
-
-    private final class DigestCompletionHandler implements HttpCompletionHandler {
-
-        private final HttpServerExchange exchange;
-        private final HttpCompletionHandler next;
-
-        private DigestCompletionHandler(final HttpServerExchange exchange, final HttpCompletionHandler next) {
-            this.exchange = exchange;
-            this.next = next;
-        }
-
-        public void handleComplete() {
-
-            SecurityContext context = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
-            AuthenticationState authenticationState = context.getAuthenticationState();
-
-            if (false /*&& authenticationState == AuthenticationState.REQUIRED || authenticationState == AuthenticationState.FAILED*/) {
-                // Need to dispatch to a Runnable here in-case the nonce management is blocking and we
-                // don't know if we were already dispatched to a different worker thread.
-                dispatch(exchange, new SendChallengeRunnable());
-
-                return;
-            } else if (authenticationState == AuthenticationState.AUTHENTICATED) {
-                // In this case we may be sending an Authentication-Info header.
-                // Depending on the chosen QOP we may need to be providing a hash
-                // including the message body - also if the nonce has change we may
-                // need to send an alternative.
-
-                // Need to check if the AUTHENTICATED state was due to this handler but if so
-                // we know it has already been dispatched.
-
-            }
-
-            next.handleComplete();
-        }
-
-        private class SendChallengeRunnable implements Runnable {
-
-            public void run() {
-                StringBuilder rb = new StringBuilder(DIGEST_PREFIX);
-                rb.append(Headers.REALM.toString()).append(""=\"""").append(realmName).append(""\"","");
-                rb.append(Headers.DOMAIN.toString()).append(""=\""/\"",""); // TODO - This will need to be generated
-                                                                        // based on security constraints.
-                rb.append(Headers.NONCE.toString()).append(""=\"""").append(nonceManager.nextNonce(null)).append(""\"","");
-                // Not currently using OPAQUE as it offers no integrity, used for session data leaves it vulnerable to
-                // session fixation type issues as well.
-                rb.append(Headers.OPAQUE.toString()).append(""=\""00000000000000000000000000000000\"""");
-                // No stale in the initial challenge, will optionally enable stale for a failed authentication.
-                if (supportedAlgorithms.size() > 0) {
-                    // This header will need to be repeated once for each algorithm.
-                    rb.append("","").append(Headers.ALGORITHM.toString()).append(""=%s"");
-                }
-                if (qopString != null) {
-                    rb.append("","").append(Headers.QOP.toString()).append(""=\"""").append(qopString).append(""\"""");
-                }
-
-                String theChallenge = rb.toString();
-                HeaderMap responseHeader = exchange.getResponseHeaders();
-                if (supportedAlgorithms.size() > 0) {
-                    for (DigestAlgorithm current : supportedAlgorithms) {
-                        responseHeader.add(WWW_AUTHENTICATE, String.format(theChallenge, current.getToken()));
-                    }
-                } else {
-                    responseHeader.add(WWW_AUTHENTICATE, theChallenge);
-                }
-                exchange.setResponseCode(CODE_401.getCode());
-
-                next.handleComplete();
-            }
-        }
-
-    }
-
-}",2012-10-31T04:56:32Z,339
"@@ -0,0 +1,529 @@
+/*
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.server.handlers.security;
+
+import static io.undertow.UndertowLogger.REQUEST_LOGGER;
+import static io.undertow.server.handlers.security.DigestAuthorizationToken.parseHeader;
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.DIGEST;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static io.undertow.util.StatusCodes.CODE_401;
+import static io.undertow.util.WorkerDispatcher.dispatch;
+import io.undertow.server.HttpCompletionHandler;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.AttachmentKey;
+import io.undertow.util.ConcreteIoFuture;
+import io.undertow.util.HeaderMap;
+import io.undertow.util.Headers;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.security.Principal;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+
+import org.xnio.IoFuture;
+
+/**
+ * {@link HttpHandler} to handle HTTP Digest authentication, both according to RFC-2617 and draft update to allow additional
+ * algorithms to be used.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public class DigestAuthenticationMechanism implements AuthenticationMechanism {
+
+    private static final String DIGEST_PREFIX = DIGEST + "" "";
+    private static final int PREFIX_LENGTH = DIGEST_PREFIX.length();
+    private static final String OPAQUE_VALUE = ""00000000000000000000000000000000"";
+    private static final byte COLON = ':';
+    private static final Charset UTF_8 = Charset.forName(""UTF-8"");
+
+    private static final Set<DigestAuthorizationToken> MANDATORY_REQUEST_TOKENS;
+
+    static {
+        Set<DigestAuthorizationToken> mandatoryTokens = new HashSet<DigestAuthorizationToken>();
+        mandatoryTokens.add(DigestAuthorizationToken.USERNAME);
+        mandatoryTokens.add(DigestAuthorizationToken.REALM);
+        mandatoryTokens.add(DigestAuthorizationToken.NONCE);
+        mandatoryTokens.add(DigestAuthorizationToken.DIGEST_URI);
+        mandatoryTokens.add(DigestAuthorizationToken.RESPONSE);
+
+        MANDATORY_REQUEST_TOKENS = Collections.unmodifiableSet(mandatoryTokens);
+    }
+
+    /**
+     * The {@link List} of supported algorithms, this is assumed to be in priority order.
+     */
+    private final List<DigestAlgorithm> supportedAlgorithms;
+    private final List<DigestQop> supportedQops;
+    private final String qopString;
+    private final String realmName; // TODO - Will offer choice once backing store API/SPI is in.
+    private final byte[] realmBytes;
+    private final CallbackHandler callbackHandler;
+    private final NonceManager nonceManager;
+
+    // Where do session keys fit? Do we just hang onto a session key or keep visiting the user store to check if the password
+    // has changed?
+    // Maybe even support registration of a session so it can be invalidated?
+
+    public DigestAuthenticationMechanism(final List<DigestAlgorithm> supportedAlgorithms, final List<DigestQop> supportedQops,
+            final String realmName, final CallbackHandler callbackHandler, final NonceManager nonceManager) {
+        this.supportedAlgorithms = supportedAlgorithms;
+        this.supportedQops = supportedQops;
+        this.realmName = realmName;
+        this.realmBytes = realmName.getBytes(UTF_8);
+        this.callbackHandler = callbackHandler;
+        this.nonceManager = nonceManager;
+
+        if (supportedQops.size() > 0) {
+            StringBuilder sb = new StringBuilder();
+            Iterator<DigestQop> it = supportedQops.iterator();
+            sb.append(it.next().getToken());
+            while (it.hasNext()) {
+                sb.append("","").append(it.next().getToken());
+            }
+            qopString = sb.toString();
+        } else {
+            qopString = null;
+        }
+    }
+
+    public IoFuture<AuthenticationResult> authenticate(HttpServerExchange exchange) {
+        ConcreteIoFuture<AuthenticationResult> result = new ConcreteIoFuture<AuthenticationResult>();
+        Deque<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);
+        if (authHeaders != null) {
+            for (String current : authHeaders) {
+                if (current.startsWith(DIGEST_PREFIX)) {
+                    String digestChallenge = current.substring(PREFIX_LENGTH);
+
+                    try {
+                        Map<DigestAuthorizationToken, String> parsedHeader = parseHeader(digestChallenge);
+                        // Some form of Digest authentication is going to occur so get the DigestContext set on the exchange.
+                        exchange.putAttachment(DigestContext.ATTACHMENT_KEY, new DigestContext());
+
+                        dispatch(exchange, new DigestRunnable(result, exchange, parsedHeader));
+
+                        // The request has now potentially been dispatched to a different worker thread, the run method
+                        // within BasicRunnable is now responsible for ensuring the request continues.
+                        return result;
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+
+                // By this point we had a header we should have been able to verify but for some reason
+                // it was not correctly structured.
+                // By this point we had a header we should have been able to verify but for some reason
+                // it was not correctly structured.
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return result;
+            }
+        }
+
+        // No suitable header has been found in this request,
+        result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_ATTEMPTED));
+        return result;
+    }
+
+    @Override
+    public void handleComplete(HttpServerExchange exchange, HttpCompletionHandler completionHandler) {
+        if (Util.shouldChallenge(exchange)) {
+            dispatch(exchange, new SendChallengeRunnable(exchange, completionHandler));
+        } else {
+            // In this case we may be sending an Authentication-Info header.
+            // Depending on the chosen QOP we may need to be providing a hash
+            // including the message body - also if the nonce has change we may
+            // need to send an alternative.
+
+            // TODO - Implement else.
+        }
+
+    }
+
+    private final class DigestRunnable implements Runnable {
+
+        private final ConcreteIoFuture<AuthenticationResult> result;
+        private final HttpServerExchange exchange;
+        private final DigestContext context;
+        private final Map<DigestAuthorizationToken, String> parsedHeader;
+        private MessageDigest digest;
+
+        private DigestRunnable(final ConcreteIoFuture<AuthenticationResult> result, HttpServerExchange exchange,
+                Map<DigestAuthorizationToken, String> parsedHeader) {
+            this.result = result;
+            this.exchange = exchange;
+            context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);
+            this.parsedHeader = parsedHeader;
+        }
+
+        public void run() {
+            // Step 1 - Verify the set of tokens received to ensure valid values.
+            Set<DigestAuthorizationToken> mandatoryTokens = new HashSet<DigestAuthorizationToken>(MANDATORY_REQUEST_TOKENS);
+            if (supportedAlgorithms.contains(DigestAlgorithm.MD5) == false) {
+                // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.
+                mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);
+            }
+            if (supportedQops.isEmpty() == false && supportedQops.contains(DigestQop.AUTH) == false) {
+                // If we do not support auth then we are mandating auth-int so force the client to send a QOP
+                mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);
+            }
+
+            DigestQop qop = null;
+            // This check is early as is increases the list of mandatory tokens.
+            if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {
+                qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
+                if (qop == null || supportedQops.contains(qop) == false) {
+                    // We are also ensuring the client is not trying to force a qop that has been disabled.
+                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),
+                            parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
+                    // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+                    result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                    return;
+                }
+                mandatoryTokens.add(DigestAuthorizationToken.CNONCE);
+                mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);
+            }
+
+            // Check all mandatory tokens are present.
+            mandatoryTokens.removeAll(parsedHeader.keySet());
+            if (mandatoryTokens.size() > 0) {
+                for (DigestAuthorizationToken currentToken : mandatoryTokens) {
+                    // TODO - Need a better check and possible concatenate the list of tokens - however
+                    // even having one missing token is not something we should routinely expect.
+                    REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());
+                }
+                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            // Perform some validation of the remaining tokens.
+            if (realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM)) == false) {
+                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),
+                        parsedHeader.get(DigestAuthorizationToken.REALM));
+                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            // TODO - Validate the URI
+
+            if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {
+                if (OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE)) == false) {
+                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),
+                            parsedHeader.get(DigestAuthorizationToken.OPAQUE));
+                    result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                    return;
+                }
+            }
+
+            DigestAlgorithm algorithm;
+            if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {
+                algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
+                if (algorithm == null || supportedAlgorithms.contains(algorithm) == false) {
+                    // We are also ensuring the client is not trying to force an algorithm that has been disabled.
+                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),
+                            parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
+                    // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+                    result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                    return;
+                }
+            } else {
+                // We know this is safe as the algorithm token was made mandatory
+                // if MD5 is not supported.
+                algorithm = DigestAlgorithm.MD5;
+            }
+
+            // Step 2 - Based on the headers received verify that in theory the response is valid.
+            try {
+                digest = algorithm.getMessageDigest();
+            } catch (NoSuchAlgorithmException e) {
+                // This is really not expected but the API makes us consider it.
+                REQUEST_LOGGER.exceptionProcessingRequest(e);
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            byte[] ha1;
+            // Step 2.1 Calculate H(A1)
+            try {
+                if (algorithm.isSession()) {
+                    ha1 = lookupOrCreateSessionHA1(parsedHeader);
+                } else {
+                    // This is the most simple form of a hash involving the username, realm and password.
+                    ha1 = createHA1();
+                }
+            } catch (AuthenticationException e) {
+                // Most likely the user does not exist.
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            byte[] ha2;
+            // Step 2.2 Calculate H(A2)
+            if (qop == null || qop.equals(DigestQop.AUTH)) {
+                ha2 = createHA2Auth();
+            } else {
+                ha2 = createHA2AuthInt();
+            }
+
+            byte[] requestDigest;
+            if (qop == null) {
+                requestDigest = createRFC2069RequestDigest(ha1, ha2);
+            } else {
+                requestDigest = createRFC2617RequestDigest(ha1, ha2);
+            }
+
+            byte[] providedResponse = parsedHeader.get(DigestAuthorizationToken.RESPONSE).getBytes(UTF_8);
+            if (MessageDigest.isEqual(requestDigest, providedResponse) == false) {
+                // TODO - We should look at still marking the nonce as used, a failure in authentication due to say a failure
+                // looking up the users password would leave it open to the packet being replayed.
+                REQUEST_LOGGER.authenticationFailed(parsedHeader.get(DigestAuthorizationToken.USERNAME), DIGEST.toString());
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            // Step 3 - Verify that the nonce was eligible to be used.
+            if (validateNonceUse() == false) {
+                // The username and password verification passed but for some reason we do not like the nonce.
+                context.markStale();
+                result.setResult(new AuthenticationResult(null, AuthenticationOutcome.NOT_AUTHENTICATED));
+                return;
+            }
+
+            // We have authenticated the remote user.
+            final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);
+            Principal principal = (new Principal() {
+
+                @Override
+                public String getName() {
+                    return userName;
+                }
+            });
+            result.setResult(new AuthenticationResult(principal, AuthenticationOutcome.AUTHENTICATED));
+
+            // Step 4 - Set up any QOP related requirements.
+
+            // TODO - Do QOP
+        }
+
+        private boolean validateNonceUse() {
+            String suppliedNonce = parsedHeader.get(DigestAuthorizationToken.NONCE);
+            int nonceCount = -1;
+            if (parsedHeader.containsKey(DigestAuthorizationToken.NONCE_COUNT)) {
+                String nonceCountHex = parsedHeader.get(DigestAuthorizationToken.NONCE_COUNT);
+
+                throw new IllegalStateException(""Nonce count not yet supported."");
+            }
+
+            context.setNonce(suppliedNonce);
+            // TODO - A replay attempt will need an exception.
+            return (nonceManager.validateNonce(suppliedNonce, nonceCount));
+        }
+
+        private byte[] getExpectedPassword() throws AuthenticationException {
+            NameCallback ncb = new NameCallback(""Username"", parsedHeader.get(DigestAuthorizationToken.USERNAME));
+            PasswordCallback pcp = new PasswordCallback(""Password"", false);
+
+            try {
+                callbackHandler.handle(new Callback[] { ncb, pcp });
+            } catch (IOException e) {
+                throw new AuthenticationException(e);
+            } catch (UnsupportedCallbackException e) {
+                throw new AuthenticationException(e);
+            }
+
+            return new String(pcp.getPassword()).getBytes(UTF_8);
+        }
+
+        private byte[] createHA1() throws AuthenticationException {
+            byte[] userName = parsedHeader.get(DigestAuthorizationToken.USERNAME).getBytes(UTF_8);
+            byte[] password = getExpectedPassword();
+
+            try {
+                digest.update(userName);
+                digest.update(COLON);
+                digest.update(realmBytes);
+                digest.update(COLON);
+                digest.update(password);
+
+                return HexConverter.convertToHexBytes(digest.digest());
+            } finally {
+                digest.reset();
+            }
+        }
+
+        private byte[] lookupOrCreateSessionHA1(final Map<DigestAuthorizationToken, String> parsedHeader) {
+            // TODO - Implement method.
+            throw new IllegalStateException(""Method not implemented."");
+        }
+
+        private byte[] createHA2Auth() {
+            byte[] method = exchange.getRequestMethod().toString().getBytes(UTF_8);
+            byte[] digestUri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI).getBytes(UTF_8);
+
+            try {
+                digest.update(method);
+                digest.update(COLON);
+                digest.update(digestUri);
+
+                return HexConverter.convertToHexBytes(digest.digest());
+            } finally {
+                digest.reset();
+            }
+        }
+
+        private byte[] createHA2AuthInt() {
+            // TODO - Implement method.
+            throw new IllegalStateException(""Method not implemented."");
+        }
+
+        private byte[] createRFC2069RequestDigest(final byte[] ha1, final byte[] ha2) {
+            byte[] nonce = parsedHeader.get(DigestAuthorizationToken.NONCE).getBytes(UTF_8);
+
+            try {
+                digest.update(ha1);
+                digest.update(COLON);
+                digest.update(nonce);
+                digest.update(COLON);
+                digest.update(ha2);
+
+                return HexConverter.convertToHexBytes(digest.digest());
+            } finally {
+                digest.reset();
+            }
+        }
+
+        private byte[] createRFC2617RequestDigest(final byte[] ha1, final byte[] ha2) {
+            // TODO - Implement method.
+            throw new IllegalStateException(""Method not implemented."");
+        }
+
+    }
+
+    private class SendChallengeRunnable implements Runnable {
+
+        private final HttpServerExchange exchange;
+        private final HttpCompletionHandler next;
+
+        private SendChallengeRunnable(final HttpServerExchange exchange, final HttpCompletionHandler next) {
+            this.exchange = exchange;
+            this.next = next;
+        }
+
+        public void run() {
+            DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);
+            boolean stale = context == null ? false : context.isStale();
+
+            StringBuilder rb = new StringBuilder(DIGEST_PREFIX);
+            rb.append(Headers.REALM.toString()).append(""=\"""").append(realmName).append(""\"","");
+            rb.append(Headers.DOMAIN.toString()).append(""=\""/\"",""); // TODO - This will need to be generated
+                                                                    // based on security constraints.
+            rb.append(Headers.NONCE.toString()).append(""=\"""").append(nonceManager.nextNonce(null)).append(""\"","");
+            // Not currently using OPAQUE as it offers no integrity, used for session data leaves it vulnerable to
+            // session fixation type issues as well.
+            rb.append(Headers.OPAQUE.toString()).append(""=\""00000000000000000000000000000000\"""");
+            if (stale) {
+                rb.append("",stale=true"");
+            }
+            if (supportedAlgorithms.size() > 0) {
+                // This header will need to be repeated once for each algorithm.
+                rb.append("","").append(Headers.ALGORITHM.toString()).append(""=%s"");
+            }
+            if (qopString != null) {
+                rb.append("","").append(Headers.QOP.toString()).append(""=\"""").append(qopString).append(""\"""");
+            }
+
+            String theChallenge = rb.toString();
+            HeaderMap responseHeader = exchange.getResponseHeaders();
+            if (supportedAlgorithms.size() > 0) {
+                for (DigestAlgorithm current : supportedAlgorithms) {
+                    responseHeader.add(WWW_AUTHENTICATE, String.format(theChallenge, current.getToken()));
+                }
+            } else {
+                responseHeader.add(WWW_AUTHENTICATE, theChallenge);
+            }
+            exchange.setResponseCode(CODE_401.getCode());
+
+            next.handleComplete();
+        }
+    }
+
+    private static class DigestContext {
+
+        static AttachmentKey<DigestContext> ATTACHMENT_KEY = AttachmentKey.create(DigestContext.class);
+
+        private String nonce;
+        private boolean stale = false;
+
+        public boolean isStale() {
+            return stale;
+        }
+
+        public void markStale() {
+            this.stale = true;
+        }
+
+        public String getNonce() {
+            return nonce;
+        }
+
+        public void setNonce(String nonce) {
+            this.nonce = nonce;
+        }
+
+    }
+
+    private class AuthenticationException extends Exception {
+
+        private static final long serialVersionUID = 4123187263595319747L;
+
+        // TODO - Remove unused constrcutors and maybe even move exception to higher level.
+
+        public AuthenticationException() {
+            super();
+        }
+
+        public AuthenticationException(String message, Throwable cause) {
+            super(message, cause);
+        }
+
+        public AuthenticationException(String message) {
+            super(message);
+        }
+
+        public AuthenticationException(Throwable cause) {
+            super(cause);
+        }
+
+    }
+
+}",2012-10-31T04:56:32Z,59
"@@ -34,7 +34,7 @@ public enum DigestAuthorizationToken implements HeaderToken {
     USERNAME(Headers.USERNAME, true),
     REALM(Headers.REALM, true),
     NONCE(Headers.NONCE, true),
-    DIGEST_URI(Headers.URI, false),
+    DIGEST_URI(Headers.URI, true),
     RESPONSE(Headers.RESPONSE, true),
     ALGORITHM(Headers.ALGORITHM, true),
     CNONCE(Headers.CNONCE, true),",2012-10-31T04:56:32Z,73
"@@ -17,15 +17,31 @@
  */
 package io.undertow.server.handlers.security;
 
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
 /**
  * Enumeration to represent the Digest quality of protection options.
  *
  * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
  */
 public enum DigestQop {
 
-    AUTH(""auth"", false),
-    AUTH_INT(""auth-int"", true);
+    AUTH(""auth"", false), AUTH_INT(""auth-int"", true);
+
+    private static final Map<String, DigestQop> BY_TOKEN;
+
+    static {
+        DigestQop[] qops = DigestQop.values();
+
+        Map<String, DigestQop> byToken = new HashMap<String, DigestQop>(qops.length);
+        for (DigestQop current : qops) {
+            byToken.put(current.token, current);
+        }
+
+        BY_TOKEN = Collections.unmodifiableMap(byToken);
+    }
 
     private final String token;
     private final boolean integrity;
@@ -43,4 +59,8 @@ public boolean isMessageIntegrity() {
         return integrity;
     }
 
+    public static DigestQop forName(final String name) {
+        return BY_TOKEN.get(name);
+    }
+
 }",2012-10-31T04:56:32Z,31
"@@ -32,6 +32,9 @@ public interface NonceManager {
     /**
      * Select the next nonce to be sent from the server taking into account the last valid nonce.
      *
+     * It is both possible and likely that the nonce last used by the client will still be valid, in that case the same nonce
+     * will be returned.
+     *
      * @param lastNonce - The last valid nonce received from the client or null if we don't already have a nonce.
      * @return The next nonce to be sent in a challenge to the client.
      */
@@ -43,6 +46,12 @@ public interface NonceManager {
      * If the nonce can not be used but the related digest was correct then a new nonce should be returned to the client
      * indicating that the nonce was stale.
      *
+     * For implementations of this interface this method is not expected by be idempotent, i.e. once a nonce is validated with a
+     * specific nonceCount it is not expected that this method will return true again if the same combination is presented.
+     *
+     * This method is expected to ONLY be called if the users credentials are valid as a storage overhead could be incurred
+     * this overhead must not be accessible to unauthenticated clients.
+     *
      * @param nonce - The nonce receieved from the client.
      * @param nonceCount - The nonce count from the client or -1 of none specified.
      * @return true if the nonce can be used otherwise return false.",2012-10-31T04:56:32Z,108
"@@ -46,6 +46,13 @@ public class SecurityContext {
 
     private final List<AuthenticationMechanism> authMechanisms = new ArrayList<AuthenticationMechanism>();
 
+    // TODO - We also need to supply a login method that allows app to supply a username and password.
+    // Maybe this will need to be a custom mechanism that doesn't exchange tokens with the client but will then
+    // be configured to either associate with the connection, the session or some other arbitrary whatever.
+    //
+    // Do we want multiple to be supported or just one?  Maybe extend the AuthenticationMechanism to allow
+    // it to be identified and called.
+
     private AuthenticationState authenticationState = AuthenticationState.NOT_REQUIRED;
     private Principal authenticatedPrincipal;
 ",2012-10-31T04:56:32Z,56
"@@ -0,0 +1,49 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.server.handlers.security;
+
+/**
+ * An extension to the {@link NonceManager} interface for Nonce managers that also support the association of a pre-prepared
+ * hash against a currently valid nonce.
+ *
+ * If the nonce manager replaces in-use nonces as old ones expire then the associated session hash should be migrated to the
+ * replacment nonce.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public interface SessionNonceManager extends NonceManager {
+
+    /**
+     * Associate the supplied hash with the nonce specified.
+     *
+     * @param nonce - The nonce the hash is to be associated with.
+     * @param hash - The hash to associate.
+     */
+    void associateHash(final String nonce, final byte[] hash);
+
+    /**
+     * Retrieve the existing hash associated with the nonce specified.
+     *
+     * If there is no association then null should be returned.
+     *
+     * @param nonce - The nonce the hash is required for.
+     * @return The associated hash or null if there is no association.
+     */
+    byte[] lookupHash(final String nonce);
+
+}",2012-10-31T04:56:32Z,112
"@@ -24,7 +24,14 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
 import java.util.Random;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.WeakHashMap;
 
 /**
  * A default {@link NonceManager} implementation to provide reasonable single host management of nonces.
@@ -42,13 +49,46 @@
  *
  * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
  */
-public class SimpleNonceManager implements NonceManager {
+public class SimpleNonceManager implements SessionNonceManager {
 
     private static final String DEFAULT_HASH_ALG = ""MD5"";
     private static final Charset UTF_8 = Charset.forName(""UTF-8"");
 
+    /**
+     * List of invalid nonces, this list contains the nonces that have been used without a nonce count.
+     *
+     * In that situation they are considered single use and must not be used again.
+     */
+    private final List<NonceKey> invalidNonces = new LinkedList<NonceKey>();
+
+    /**
+     * Map of known currently valid nonces, a SortedMap is used to order the nonces by their creation time stamp allowing a
+     * simple iteration over the keys to identify expired nonces.
+     */
+    private final SortedMap<NonceKey, NonceValue> knownNonces = new TreeMap<NonceKey, NonceValue>();
+
+    /**
+     * A WeakHashMap to map expired nonces to their replacement nonce. For an item to be added to this Collection the key will
+     * have been removed from the knownNonces map.
+     *
+     * A replacement nonce will have been added to knownNonces that references the key used here - once the replacement nonce is
+     * removed from knownNonces then the key will be eligible for garbage collection allowing it to be removed from this map as
+     * well.
+     *
+     * The value in this Map is a plain String, this is to avoid inadvertantly creating a long term reference to the key we
+     * expect to be garbage collected at some point in the future.
+     */
+    private final Map<NonceKey, String> forwardMapping = new WeakHashMap<SimpleNonceManager.NonceKey, String>();
+
+    /**
+     * A pseudo-random generator for creating the nonces, a secure random is not required here as this is used purely to
+     * minimise the chance of colisions should two nonces be generated at exactly the same time.
+     */
+    private final Random random = new Random();
+
     private final String secret;
     private final String hashAlg;
+    private final int hashLength;
 
     /**
      * After a nonce is issued the first authentication response MUST be received within 5 minutes.
@@ -75,6 +115,7 @@ public SimpleNonceManager(final String hashAlg) {
         MessageDigest digest = getDigest(hashAlg);
 
         this.hashAlg = hashAlg;
+        this.hashLength = digest.getDigestLength();
 
         // Create a new secret only valid within this NonceManager instance.
         Random rand = new SecureRandom();
@@ -91,8 +132,7 @@ private MessageDigest getDigest(final String hashAlg) {
         }
     }
 
-    /*
-     * (non-Javadoc)
+    /**
      *
      * @see io.undertow.server.handlers.security.NonceManager#nextNonce(java.lang.String)
      */
@@ -102,88 +142,256 @@ public String nextNonce(String lastNonce) {
             return createNewNonce();
         }
 
+        // TODO - Add timestamp checking and forwarding to a new nonce.
         return lastNonce;
     }
 
     private String createNewNonce() {
-        String now = Long.toString(System.currentTimeMillis());
-
-        MessageDigest digest = getDigest(hashAlg);
-        digest.update(now.getBytes());
-        byte[] hashedPart = digest.digest(secret.getBytes(UTF_8));
-        byte[] timeStampPart = now.getBytes(UTF_8);
-        byte[] complete = new byte[1 + timeStampPart.length + hashedPart.length];
-        complete[0] = (byte) timeStampPart.length;
-        System.arraycopy(timeStampPart, 0, complete, 1, timeStampPart.length);
-        System.arraycopy(hashedPart, 0, complete, 1 + timeStampPart.length, hashedPart.length);
+        byte[] prefix = new byte[8];
+        random.nextBytes(prefix);
+        byte[] now = Long.toString(System.currentTimeMillis()).getBytes(UTF_8);
 
-        return Base64.encodeBytes(complete);
+        return createNonce(prefix, now);
     }
 
-    // TODO - Should the nonce manager also be responsible for storing the session key or do we also need a session manager?
-    //        Maybe actually a session manager, once a replacement nonce is issued we could still update the session manager.
-
     /**
-     *
      *
      * @see io.undertow.server.handlers.security.NonceManager#validateNonce(java.lang.String, int)
      */
     @Override
     public boolean validateNonce(String nonce, int nonceCount) {
-        // We only need to perform the verification involving the secret if this is a nonce we
-        // don't already know about - if we do know about it then it must have passed through this
-        // verification once already.
+        NonceKey key = new NonceKey(nonce);
+        if (nonceCount < 0) {
+            if (invalidNonces.contains(key)) {
+                // Without a nonce count the nonce is only useable once.
+                return false;
+            }
+            // Not already known so will drop into first use validation.
+        } else if (knownNonces.containsKey(key)) {
+            // At this point we need to validate that the nonce is still within it's time limits,
+            // If a new nonce had been selected then a known nonce would not have been found.
+            // The nonce will also have it's key sequence checked - we are not mandating the order
+            // of the count but we are mandating a count can only be used once.
+
+        } else if (forwardMapping.containsKey(key)) {
+            // We could have let this drop through as the next validation would fail anyway but
+            // why waste the time if we already know a replacement nonce has been issued.
+            return false;
+        }
+
+        // This is not a nonce currently known to us so start the validation process.
+        NonceKey nonceKey = verifyUnknownNonce(nonce);
+        if (nonceKey == null) {
+            return false;
+        }
+
+        long now = System.currentTimeMillis();
+        long earliestAccepted = now - firstUseTimeOut;
+        if (nonceKey.timeStamp < earliestAccepted || nonceKey.timeStamp > now) {
+            // The embedded timestamp is either expired or somehow is after now.
+            return false;
+        }
+
+        if (nonceCount < 0) {
+            // Allow a single use but reject all further uses.
+            addInvalidNonce(nonceKey);
+            return true;
+        }
+
+        // TODO - Implement nonceCount support.
+        return false;
+
+        // Should this also be tied to a user? i.e. a different user can not use someone elses nonce or is the count enough to
+        // pick up abuse?
+    }
+
+    private void addInvalidNonce(final NonceKey nonce) {
+        synchronized (invalidNonces) {
+            // TODO - We really need a recurring task to clean these up but for now clean on each addition.
+            long earliestAccepted = System.currentTimeMillis() - firstUseTimeOut;
+            Iterator<NonceKey> it = invalidNonces.iterator();
+            while (it.hasNext()) {
+                NonceKey current = it.next();
+                if (current.timeStamp < earliestAccepted) {
+                    it.remove();
+                } else {
+                    break;
+                }
+            }
+
+            invalidNonces.add(invalidNonces.size(), nonce);
+        }
+    }
+
+    /**
+     * Verify a previously unknown nonce and return the {@link NonceKey} representation for the nonce.
+     *
+     * Later when a nonce is re-used we can match based on the String alone - the information embedded within the nonce will be
+     * cached with it.
+     *
+     * This stage of the verification simply extracts the prefix and the embedded timestamp and recreates a new hashed and
+     * Base64 nonce based on the local secret - if the newly generated nonce matches the supplied one we accept it was created
+     * by this nonce manager.
+     *
+     * This verification does not validate that the timestamp is within a valid time period.
+     *
+     * @param nonce -
+     * @return
+     */
+    private NonceKey verifyUnknownNonce(final String nonce) {
         byte[] complete;
         try {
             complete = Base64.decode(nonce.getBytes(UTF_8));
         } catch (IOException e) {
             throw MESSAGES.invalidBase64Token(e);
         }
-        MessageDigest digest = getDigest(hashAlg);
-        int timeStampLength = complete[0];
-        int predictedDigestLength = digest.getDigestLength();
+
+        int timeStampLength = complete[8];
         // A sanity check to try and verify the sizes we expect from the arrays are correct.
-        if (predictedDigestLength > 0) {
-            int expectedLength = 1 + timeStampLength + predictedDigestLength;
+        if (hashLength > 0) {
+            int expectedLength = 9 + timeStampLength + hashLength;
             if (complete.length != expectedLength) {
                 throw MESSAGES.invalidNonceReceived();
             } else if (timeStampLength + 1 >= complete.length)
                 throw MESSAGES.invalidNonceReceived();
         }
 
+        byte[] prefix = new byte[8];
+        System.arraycopy(complete, 0, prefix, 0, 8);
         byte[] timeStampBytes = new byte[timeStampLength];
-        byte[] providedHashedPart = new byte[complete.length - 1 - timeStampBytes.length];
-        System.arraycopy(complete, timeStampBytes.length + 1, providedHashedPart, 0, providedHashedPart.length);
-        System.arraycopy(complete, 1, timeStampBytes, 0, timeStampBytes.length);
+        System.arraycopy(complete, 9, timeStampBytes, 0, timeStampBytes.length);
 
-        digest.update(timeStampBytes);
-        byte[] calculatedHashedPart = digest.digest(secret.getBytes(UTF_8));
+        String expectedNonce = createNonce(prefix, timeStampBytes);
 
-        //
-        System.out.println(""Extracted Time Stampe "" + new String(timeStampBytes, UTF_8));
-        //
+        if (expectedNonce.equals(nonce)) {
+            try {
+                long timeStamp = Long.parseLong(new String(timeStampBytes, UTF_8));
 
-        return MessageDigest.isEqual(providedHashedPart, calculatedHashedPart);
+                return new NonceKey(expectedNonce, timeStamp);
+            } catch (NumberFormatException dropped) {
+            }
+        }
 
-        // Should this also be tied to a user? i.e. a different user can not use someone elses nonce or is the count enough to
-        // pick up abuse?
+        return null;
+    }
+
+    private String createNonce(final byte[] prefix, final byte[] timeStamp) {
+        byte[] hashedPart = generateHash(prefix, timeStamp);
+        byte[] complete = new byte[9 + timeStamp.length + hashedPart.length];
+        System.arraycopy(prefix, 0, complete, 0, 8);
+        complete[8] = (byte) timeStamp.length;
+        System.arraycopy(timeStamp, 0, complete, 9, timeStamp.length);
+        System.arraycopy(hashedPart, 0, complete, 9 + timeStamp.length, hashedPart.length);
+
+        return Base64.encodeBytes(complete);
+    }
+
+    private byte[] generateHash(final byte[] prefix, final byte[] timeStamp) {
+        MessageDigest digest = getDigest(hashAlg);
+
+        digest.update(prefix);
+        digest.update(timeStamp);
+
+        return digest.digest(secret.getBytes(UTF_8));
+    }
+
+    public void associateHash(String nonce, byte[] hash) {
+        // TODO Auto-generated method stub
+
+    }
+
+    public byte[] lookupHash(String nonce) {
+        // TODO Auto-generated method stub
+        return null;
     }
 
     /**
-     * Class to hold information about the use of a nonce.
+     * Key used to reference known nonces.
      *
+     * This key serves two purposes, firstly it is used for looking up information about a known nonce from the SortedMap, for
+     * this purpose hashCode and equals only take the nonce into account.
+     *
+     * The second purpose is to allow ordering based on the time the nonce was created, in this case comparison is only based on
+     * the created timestamp.
+     *
+     * Note: this class has a natural ordering that is inconsistent with equals.
      */
-    private class NonceRecord {
-        /**
-         * The nonce this record relates to.
-         */
-        private String nonce;
-        private long timestamp;
-
-        /**
-         * The next nonce issued to replace this nonce.
-         */
-        private String nextNonce;
+    private class NonceKey implements Comparable<NonceKey> {
+
+        private final String nonce;
+        private final long timeStamp;
+
+        NonceKey(final String nonce) {
+            this(nonce, -1);
+        }
+
+        NonceKey(final String nonce, final long timeStamp) {
+            this.nonce = nonce;
+            this.timeStamp = timeStamp;
+        }
+
+        public int compareTo(NonceKey other) {
+            if (timeStamp == other.timeStamp) {
+                return 0;
+            } else if (timeStamp < other.timeStamp) {
+                return -1;
+            }
+
+            return 1;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + getOuterType().hashCode();
+            result = prime * result + ((nonce == null) ? 0 : nonce.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            NonceKey other = (NonceKey) obj;
+            if (!getOuterType().equals(other.getOuterType()))
+                return false;
+            if (nonce == null) {
+                if (other.nonce != null)
+                    return false;
+            } else if (!nonce.equals(other.nonce))
+                return false;
+            return true;
+        }
+
+        private SimpleNonceManager getOuterType() {
+            return SimpleNonceManager.this;
+        }
+
+    }
+
+    /**
+     * The state associated with a nonce.
+     *
+     * A NonceKey for a preciously valid nonce is also referenced, this is so that a WeakHashMap can be used to maintain a
+     * mapping from the original NonceKey to the new nonce value.
+     */
+    private class NonceValue {
+
+        private NonceKey previousKey;
+        private byte[] sessionKey;
+
+        byte[] getSessionKey() {
+            return sessionKey;
+        }
+
+        void setSessionKey(final byte[] sessionKey) {
+            this.sessionKey = sessionKey;
+        }
 
     }
 
@@ -192,7 +400,7 @@ public static void main(String[] args) throws Exception {
         String nonce = nm.nextNonce(null);
         System.out.println(""Nonce = "" + nonce);
         System.out.println(""Is Valid = "" + nm.validateNonce(nonce, -1));
-        System.out.println(""Is Valid = "" + nm.validateNonce(nonce + ""AAAAAA"", -1));
+        System.out.println(""Is Valid = "" + nm.validateNonce(nonce.substring(0, nonce.length() - 2) + ""A="", -1));
     }
 
 }",2012-10-31T04:56:32Z,70
"@@ -89,7 +89,7 @@ public interface UndertowMessages {
 //    @Message(id = 16, value = ""Could not add cookie as cookie handler was not present in the handler chain"")
 //    IllegalStateException cookieHandlerNotPresent();
 
-    @Message(id = 17, value = ""Form value is a file, use getFile() instead"")
+    @Message(id = 17, value = ""Form value is a file, use getFileItem() instead"")
     IllegalStateException formValueIsAFile();
 
     @Message(id = 18, value = ""Form value is a String, use getValue() instead"")
@@ -594,4 +594,7 @@ public interface UndertowMessages {
 
     @Message(id = 191, value = ""Default context cannot be null"")
     IllegalStateException defaultContextCannotBeNull();
+
+    @Message(id = 192, value = ""Form value is a in-memory file, use getFileItem() instead"")
+    IllegalStateException formValueIsInMemoryFile();
 }",2018-08-29T05:36:11Z,68
"@@ -174,7 +174,7 @@ private void dumpRequestBody(HttpServerExchange exchange, StringBuilder sb) {
                     sb.append(formField)
                             .append(""="");
                     for (FormData.FormValue formValue : formValues) {
-                        sb.append(formValue.isFile() ? ""[file-content]"" : formValue.getValue());
+                        sb.append(formValue.isFileItem() ? ""[file-content]"" : formValue.getValue());
                         sb.append(""\n"");
 
                         if (formValue.getHeaders() != null) {",2018-08-29T05:36:11Z,35
"@@ -18,7 +18,13 @@
 
 package io.undertow.server.handlers.form;
 
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -64,6 +70,17 @@ public Deque<FormValue> get(String name) {
         return values.get(name);
     }
 
+    public void add(String name, byte[] value, String fileName, HeaderMap headers) {
+        Deque<FormValue> values = this.values.get(name);
+        if (values == null) {
+            this.values.put(name, values = new ArrayDeque<>(1));
+        }
+        values.add(new FormValueImpl(value, fileName, headers));
+        if (++valueCount > maxValues) {
+            throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(maxValues));
+        }
+    }
+
     public void add(String name, String value) {
         add(name, value, null);
     }
@@ -157,17 +174,24 @@ public interface FormValue {
          *
          * @return
          */
+        @Deprecated
         boolean isFile();
 
         /**
          * @return The temp file that the file data was saved to
+         *
          * @throws IllegalStateException if this is not a file
          */
+        @Deprecated
         Path getPath();
 
         @Deprecated
         File getFile();
 
+        FileItem getFileItem();
+
+        boolean isFileItem();
+
         /**
          * @return The filename specified in the disposition header.
          */
@@ -181,28 +205,95 @@ public interface FormValue {
 
     }
 
+    public static class FileItem {
+        private final Path file;
+        private final byte[] content;
+
+        public FileItem(Path file) {
+            this.file = file;
+            this.content = null;
+        }
+
+        public FileItem(byte[] content) {
+            this.file = null;
+            this.content = content;
+        }
+
+        public boolean isInMemory() {
+            return file == null;
+        }
+
+        public Path getFile() {
+            return file;
+        }
+
+        public long getFileSize() throws IOException {
+            if (isInMemory()) {
+                return content.length;
+            } else {
+                return Files.size(file);
+            }
+        }
+
+        public InputStream getInputStream() throws IOException {
+            if (file != null) {
+                return new BufferedInputStream(Files.newInputStream(file));
+            } else {
+                return new ByteArrayInputStream(content);
+            }
+        }
+
+        public void delete() throws IOException {
+            if (file != null) {
+                try {
+                    Files.delete(file);
+                } catch (NoSuchFileException e) { //already deleted
+                }
+            }
+        }
+
+        public void write(Path target) throws IOException {
+            if (file != null) {
+                try {
+                    Files.move(file, target);
+                } catch (IOException e) {
+                    Files.copy(getInputStream(), target);
+                }
+            } else {
+                Files.copy(getInputStream(), target);
+            }
+        }
+    }
+
 
     static class FormValueImpl implements FormValue {
 
         private final String value;
         private final String fileName;
-        private final Path file;
         private final HeaderMap headers;
+        private final FileItem fileItem;
 
         FormValueImpl(String value, HeaderMap headers) {
             this.value = value;
             this.headers = headers;
-            this.file = null;
             this.fileName = null;
+            this.fileItem = null;
         }
 
         FormValueImpl(Path file, final String fileName, HeaderMap headers) {
-            this.file = file;
+            this.fileItem = new FileItem(file);
             this.headers = headers;
             this.fileName = fileName;
             this.value = null;
         }
 
+        FormValueImpl(byte[] data, String fileName, HeaderMap headers) {
+            this.fileItem = new FileItem(data);
+            this.fileName = fileName;
+            this.headers = headers;
+            this.value = null;
+        }
+
 
         @Override
         public String getValue() {
@@ -214,22 +305,38 @@ public String getValue() {
 
         @Override
         public boolean isFile() {
-            return file != null;
+            return fileItem != null && !fileItem.isInMemory();
         }
 
         @Override
         public Path getPath() {
-            if (file == null) {
+            if (fileItem == null) {
                 throw UndertowMessages.MESSAGES.formValueIsAString();
             }
-            return file;
+            if (fileItem.isInMemory()) {
+                throw UndertowMessages.MESSAGES.formValueIsInMemoryFile();
+            }
+            return fileItem.getFile();
         }
 
         @Override
         public File getFile() {
             return getPath().toFile();
         }
 
+        @Override
+        public FileItem getFileItem() {
+            if (fileItem == null) {
+                throw UndertowMessages.MESSAGES.formValueIsAString();
+            }
+            return fileItem;
+        }
+
+        @Override
+        public boolean isFileItem() {
+            return fileItem != null;
+        }
+
         @Override
         public HeaderMap getHeaders() {
             return headers;",2018-08-29T05:36:11Z,340
"@@ -36,6 +36,7 @@
 import org.xnio.channels.StreamSourceChannel;
 
 import java.io.ByteArrayOutputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
@@ -48,6 +49,7 @@
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Executor;
 
@@ -66,6 +68,8 @@ public class MultiPartParserDefinition implements FormParserFactory.ParserDefini
 
     private long maxIndividualFileSize = -1;
 
+    private long fileSizeThreshold;
+
     public MultiPartParserDefinition() {
         tempFileLocation = Paths.get(System.getProperty(""java.io.tmpdir""));
     }
@@ -83,7 +87,7 @@ public FormDataParser create(final HttpServerExchange exchange) {
                 UndertowLogger.REQUEST_LOGGER.debugf(""Could not find boundary in multipart request with ContentType: %s, multipart data will not be available"", mimeType);
                 return null;
             }
-            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, defaultEncoding);
+            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, fileSizeThreshold, defaultEncoding);
             exchange.addExchangeCompleteListener(new ExchangeCompletionListener() {
                 @Override
                 public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
@@ -138,12 +142,17 @@ public void setMaxIndividualFileSize(final long maxIndividualFileSize) {
         this.maxIndividualFileSize = maxIndividualFileSize;
     }
 
+    public void setFileSizeThreshold(long fileSizeThreshold) {
+        this.fileSizeThreshold = fileSizeThreshold;
+    }
+
     private final class MultiPartUploadHandler implements FormDataParser, MultipartParser.PartHandler {
 
         private final HttpServerExchange exchange;
         private final FormData data;
         private final List<Path> createdFiles = new ArrayList<>();
         private final long maxIndividualFileSize;
+        private final long fileSizeThreshold;
         private String defaultEncoding;
 
         private final ByteArrayOutputStream contentBytes = new ByteArrayOutputStream();
@@ -157,10 +166,11 @@ private final class MultiPartUploadHandler implements FormDataParser, MultipartP
         private final MultipartParser.ParseState parser;
 
 
-        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final String defaultEncoding) {
+        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final long fileSizeThreshold, final String defaultEncoding) {
             this.exchange = exchange;
             this.maxIndividualFileSize = maxIndividualFileSize;
             this.defaultEncoding = defaultEncoding;
+            this.fileSizeThreshold = fileSizeThreshold;
             this.data = new FormData(exchange.getConnection().getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, 1000));
             String charset = defaultEncoding;
             String contentType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
@@ -238,7 +248,7 @@ public void beginPart(final HeaderMap headers) {
                 if (disposition.startsWith(""form-data"")) {
                     currentName = Headers.extractQuotedValueFromHeader(disposition, ""name"");
                     fileName = Headers.extractQuotedValueFromHeaderWithEncoding(disposition, ""filename"");
-                    if (fileName != null) {
+                    if (fileName != null && fileSizeThreshold == 0) {
                         try {
                             if (tempFileLocation != null) {
                                 file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
@@ -261,6 +271,24 @@ public void data(final ByteBuffer buffer) throws IOException {
             if (this.maxIndividualFileSize > 0 && this.currentFileSize > this.maxIndividualFileSize) {
                 throw UndertowMessages.MESSAGES.maxFileSizeExceeded(this.maxIndividualFileSize);
             }
+            if (file == null && fileName != null && fileSizeThreshold < this.currentFileSize) {
+                try {
+                    if (tempFileLocation != null) {
+                        file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
+                    } else {
+                        file = Files.createTempFile(""undertow"", ""upload"");
+                    }
+                    createdFiles.add(file);
+
+                    FileOutputStream fileOutputStream = new FileOutputStream(file.toFile());
+                    contentBytes.writeTo(fileOutputStream);
+
+                    fileChannel = fileOutputStream.getChannel();
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
             if (file == null) {
                 while (buffer.hasRemaining()) {
                     contentBytes.write(buffer.get());
@@ -275,12 +303,16 @@ public void endPart() {
             if (file != null) {
                 data.add(currentName, file, fileName, headers);
                 file = null;
+                contentBytes.reset();
                 try {
                     fileChannel.close();
                     fileChannel = null;
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
+            } else if (fileName != null) {
+                data.add(currentName, Arrays.copyOf(contentBytes.toByteArray(), contentBytes.size()), fileName, headers);
+                contentBytes.reset();
             } else {
 
 ",2018-08-29T05:36:11Z,119
"@@ -18,15 +18,21 @@
 
 package io.undertow.server.handlers.form;
 
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.BlockingHandler;
-import io.undertow.testutils.DefaultServer;
-import io.undertow.testutils.HttpClientUtils;
-import io.undertow.testutils.TestHttpClient;
-import io.undertow.util.Headers;
-import io.undertow.util.StatusCodes;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
@@ -40,9 +46,15 @@
 import org.junit.runner.RunWith;
 import org.xnio.IoUtils;
 
-import java.io.File;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.HeaderValues;
+import io.undertow.util.Headers;
+import io.undertow.util.StatusCodes;
 
 /**
  * @author Stuart Douglas
@@ -54,12 +66,9 @@ private static HttpHandler createHandler() {
         return new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {
-                System.out.println(""In handler"");
                 final FormDataParser parser = FormParserFactory.builder().build().createParser(exchange);
-                System.out.println(""Created parser"");
                 try {
                     FormData data = parser.parseBlocking();
-                    System.out.println(""done parsing"");
                     exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
                     if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
                         FormData.FormValue file = data.getFirst(""file"");
@@ -189,4 +198,172 @@ public void testFileUploadWithEagerParsingAndNonASCIIFilename() throws Exception
             client.getConnectionManager().shutdown();
         }
     }
+
+    private static HttpHandler createInMemoryReadingHandler(final long fileSizeThreshold) {
+        return new HttpHandler() {
+            @Override
+            public void handleRequest(final HttpServerExchange exchange) throws Exception {
+                MultiPartParserDefinition multiPartParserDefinition = new MultiPartParserDefinition();
+                multiPartParserDefinition.setFileSizeThreshold(fileSizeThreshold);
+                final FormDataParser parser = FormParserFactory.builder(false)
+                        .addParsers(new FormEncodedDataDefinition(), multiPartParserDefinition)
+                        .build().createParser(exchange);
+                try {
+                    FormData data = parser.parseBlocking();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
+                        FormData.FormValue file = data.getFirst(""file"");
+                        if (file.isFileItem()) {
+                            exchange.setStatusCode(StatusCodes.OK);
+                            logResult(exchange, file.getFileItem().isInMemory(), file.getFileName(), stream2String(file));
+                        }
+                    }
+                    exchange.endExchange();
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    exchange.endExchange();
+                } finally {
+                    IoUtils.safeClose(parser);
+                }
+            }
+
+            private String stream2String(FormData.FormValue file) throws IOException {
+                try (InputStream is = file.getFileItem().getInputStream()) {
+                    StringWriter sw = new StringWriter();
+                    IOUtils.copy(is, sw, ""UTF-8"");
+                    return sw.toString();
+                }
+            }
+
+            private String getFileName(FormData.FormValue data) {
+                HeaderValues cdHeaders = data.getHeaders().get(""content-disposition"");
+                for (String cdHeader : cdHeaders) {
+                    if (cdHeader.startsWith(""form-data"")) {
+                        return cdHeader.substring(cdHeader.indexOf(""filename="") + ""filename="".length()).replace(""\"""", """");
+                    }
+                }
+                return null;
+            }
+
+            private void logResult(HttpServerExchange exchange, boolean inMemory, String fileName, String content) throws IOException {
+                String res = String.format(""in_memory:%s;file_name:%s;hash:%s"", inMemory, fileName, DigestUtils.md5Hex(content));
+                final OutputStream outputStream = exchange.getOutputStream();
+                outputStream.write(res.getBytes());
+                outputStream.close();
+            }
+        };
+    }
+
+    @Test
+    public void testFileUploadWithSmallFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithLargeFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10_000)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""true"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithMediumFileSizeThresholdAndLargeFile() throws Exception {
+        int fileSizeThreshold = 1000;
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(fileSizeThreshold)));
+
+        TestHttpClient client = new TestHttpClient();
+        File file = new File(""tmp_upload_file.txt"");
+        file.createNewFile();
+        try {
+            writeLargeFileContent(file, fileSizeThreshold * 2);
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(file));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""tmp_upload_file.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(file)), parsedResponse.get(""hash""));
+
+        } finally {
+            file.delete();
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    private void writeLargeFileContent(File file, int size) throws IOException {
+        int textLength = ""content"".getBytes().length;
+        FileOutputStream fos = new FileOutputStream(file);
+        for (int i = 0; i < size / textLength; i++) {
+            fos.write(""content"".getBytes());
+        }
+        fos.flush();
+        fos.close();
+    }
+
+    private Map<String, String> parse(String resp) {
+        Map<String, String> parsed = new HashMap<>();
+
+        String[] split = resp.split("";"");
+        for (String s : split) {
+            String[] pair = s.split("":"");
+            parsed.put(pair[0], pair[1]);
+        }
+
+        return parsed;
+    }
 }",2018-08-29T05:36:11Z,19
"@@ -112,6 +112,9 @@ public void setupMultipart(ServletContextImpl servletContext) {
             if(config.getMaxFileSize() > 0) {
                 multiPartParserDefinition.setMaxIndividualFileSize(config.getMaxFileSize());
             }
+            if (config.getFileSizeThreshold() > 0) {
+                multiPartParserDefinition.setFileSizeThreshold(config.getFileSizeThreshold());
+            }
             multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultRequestCharset().name());
 
             formParserFactory = FormParserFactory.builder(false)",2018-08-29T05:36:11Z,113
"@@ -705,7 +705,7 @@ public String getParameter(final String name) {
             final FormData parsedFormData = parseFormData();
             if (parsedFormData != null) {
                 FormData.FormValue res = parsedFormData.getFirst(name);
-                if (res == null || res.isFile()) {
+                if (res == null || res.isFileItem()) {
                     return null;
                 } else {
                     return res.getValue();
@@ -729,7 +729,7 @@ public Enumeration<String> getParameterNames() {
                 while (it.hasNext()) {
                     String name = it.next();
                     for(FormData.FormValue param : parsedFormData.get(name)) {
-                        if(!param.isFile()) {
+                        if(!param.isFileItem()) {
                             parameterNames.add(name);
                             break;
                         }
@@ -758,7 +758,7 @@ public String[] getParameterValues(final String name) {
                 Deque<FormData.FormValue> res = parsedFormData.get(name);
                 if (res != null) {
                     for (FormData.FormValue value : res) {
-                        if(!value.isFile()) {
+                        if(!value.isFileItem()) {
                             ret.add(value.getValue());
                         }
                     }
@@ -791,14 +791,14 @@ public Map<String, String[]> getParameterMap() {
                     if (arrayMap.containsKey(name)) {
                         ArrayList<String> existing = arrayMap.get(name);
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 existing.add(v.getValue());
                             }
                         }
                     } else {
                         final ArrayList<String> values = new ArrayList<>();
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 values.add(v.getValue());
                             }
                         }",2018-08-29T05:36:11Z,147
"@@ -24,12 +24,9 @@
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 
-import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.file.Files;
-import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Collection;
@@ -62,8 +59,8 @@ public PartImpl(final String name, final FormData.FormValue formValue, Multipart
 
     @Override
     public InputStream getInputStream() throws IOException {
-        if (formValue.isFile()) {
-            return new BufferedInputStream(Files.newInputStream(formValue.getPath()));
+        if (formValue.isFileItem()) {
+            return formValue.getFileItem().getInputStream();
         } else {
             String requestedCharset = servletRequest.getCharacterEncoding();
             String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultRequestCharset().name();
@@ -89,8 +86,8 @@ public String getSubmittedFileName() {
     @Override
     public long getSize() {
         try {
-            if (formValue.isFile()) {
-                return Files.size(formValue.getPath());
+            if (formValue.isFileItem()) {
+                return formValue.getFileItem().getFileSize();
             } else {
                 return formValue.getValue().length();
             }
@@ -109,20 +106,19 @@ public void write(final String fileName) throws IOException {
                 target = Paths.get(config.getLocation(), fileName);
             }
         }
-        try {
-            Files.move(formValue.getPath(), target);
-        } catch (IOException e) {
-            Files.copy(formValue.getPath(), target);
+        if (formValue.isFileItem()) {
+            formValue.getFileItem().write(target);
         }
     }
 
     @Override
     public void delete() throws IOException {
-        try {
-            Files.delete(formValue.getPath());
-        } catch (NoSuchFileException e) { //already deleted
-        } catch (IOException e) {
-            throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+        if (formValue.isFileItem()) {
+            try {
+                formValue.getFileItem().delete();
+            } catch (IOException e) {
+                throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+            }
         }
     }
 ",2018-08-29T05:36:11Z,269
"@@ -73,7 +73,7 @@
         <version.org.jboss.logging>3.2.1.Final</version.org.jboss.logging>
         <version.org.jboss.logging.processor>2.0.0.Final</version.org.jboss.logging.processor>
         <version.org.jboss.logmanager>2.0.0.Final</version.org.jboss.logmanager>
-        <version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>1.0.0.Alpha1</version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>
+        <version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>1.0.0.Alpha2</version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>
         <version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>1.0.0.Final</version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>
         <version.org.jboss.spec.javax.servlet.jsp>1.0.0.Final</version.org.jboss.spec.javax.servlet.jsp>
         <version.org.jboss.spec.javax.websockets>1.1.0.Final</version.org.jboss.spec.javax.websockets>",2017-04-20T00:13:14Z,265
"@@ -82,8 +82,14 @@ public interface Deployment {
      */
     Executor getAsyncExecutor();
 
+
+    @Deprecated
     Charset getDefaultCharset();
 
+    Charset getDefaultRequestCharset();
+
+    Charset getDefaultResponseCharset();
+
     /**
      *
      * @return The list of authentication mechanisms configured for this deployment",2017-04-20T00:13:14Z,266
"@@ -90,6 +90,8 @@ public class DeploymentInfo implements Cloneable {
     private int defaultCookieVersion = 0;
     private SessionPersistenceManager sessionPersistenceManager;
     private String defaultEncoding;
+    private String defaultRequestEncoding;
+    private String defaultResponseEncoding;
     private String urlEncoding = null;
     private boolean ignoreFlush = false;
     private AuthorizationManager authorizationManager = DefaultAuthorizationManager.INSTANCE;
@@ -1286,6 +1288,24 @@ public DeploymentInfo setCheckOtherSessionManagers(boolean checkOtherSessionMana
         return this;
     }
 
+    public String getDefaultRequestEncoding() {
+        return defaultRequestEncoding;
+    }
+
+    public DeploymentInfo setDefaultRequestEncoding(String defaultRequestEncoding) {
+        this.defaultRequestEncoding = defaultRequestEncoding;
+        return this;
+    }
+
+    public String getDefaultResponseEncoding() {
+        return defaultResponseEncoding;
+    }
+
+    public DeploymentInfo setDefaultResponseEncoding(String defaultResponseEncoding) {
+        this.defaultResponseEncoding = defaultResponseEncoding;
+        return this;
+    }
+
     @Override
     public DeploymentInfo clone() {
         final DeploymentInfo info = new DeploymentInfo()
@@ -1373,6 +1393,8 @@ public DeploymentInfo clone() {
         info.securityDisabled = securityDisabled;
         info.useCachedAuthenticationMechanism = useCachedAuthenticationMechanism;
         info.checkOtherSessionManagers = checkOtherSessionManagers;
+        info.defaultRequestEncoding = defaultRequestEncoding;
+        info.defaultResponseEncoding = defaultResponseEncoding;
         return info;
     }
 ",2017-04-20T00:13:14Z,142
"@@ -68,7 +68,9 @@ public class DeploymentImpl implements Deployment {
     private volatile ErrorPages errorPages;
     private volatile Map<String, String> mimeExtensionMappings;
     private volatile SessionManager sessionManager;
+    @Deprecated
     private volatile Charset defaultCharset = StandardCharsets.ISO_8859_1;
+
     private volatile List<AuthenticationMechanism> authenticationMechanisms;
     private volatile List<ThreadSetupHandler> threadSetupActions;
 
@@ -200,6 +202,7 @@ public Executor getAsyncExecutor() {
         return deploymentInfo.getAsyncExecutor();
     }
 
+    @Deprecated
     public Charset getDefaultCharset() {
         return defaultCharset;
     }
@@ -218,6 +221,7 @@ public DeploymentManager.State getDeploymentState() {
         return deploymentManager.getState();
     }
 
+    @Deprecated
     public void setDefaultCharset(Charset defaultCharset) {
         this.defaultCharset = defaultCharset;
     }",2017-04-20T00:13:14Z,267
"@@ -345,8 +345,12 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
 
                 //we don't allow multipart requests, and use the default encoding when it's set
                 FormEncodedDataDefinition formEncodedDataDefinition = new FormEncodedDataDefinition();
-                if (deploymentInfo.getDefaultEncoding() != null) {
-                    formEncodedDataDefinition.setDefaultEncoding(deploymentInfo.getDefaultEncoding());
+                String reqEncoding = deploymentInfo.getDefaultRequestEncoding();
+                if(reqEncoding == null) {
+                    deploymentInfo.getDefaultEncoding();
+                }
+                if (reqEncoding != null) {
+                    formEncodedDataDefinition.setDefaultEncoding(reqEncoding);
                 }
                 FormParserFactory parser = FormParserFactory.builder(false)
                         .addParser(formEncodedDataDefinition)",2017-04-20T00:13:14Z,80
"@@ -74,7 +74,7 @@ public ManagedServlet(final ServletInfo servletInfo, final ServletContextImpl se
 
     public void setupMultipart(ServletContextImpl servletContext) {
         FormEncodedDataDefinition formDataParser = new FormEncodedDataDefinition()
-                .setDefaultEncoding(servletContext.getDeployment().getDefaultCharset().name());
+                .setDefaultEncoding(servletContext.getDeployment().getDefaultRequestCharset().name());
         MultipartConfigElement multipartConfig = servletInfo.getMultipartConfig();
         if(multipartConfig == null) {
             multipartConfig = servletContext.getDeployment().getDeploymentInfo().getDefaultMultipartConfig();
@@ -105,7 +105,7 @@ public void setupMultipart(ServletContextImpl servletContext) {
             if(config.getMaxFileSize() > 0) {
                 multiPartParserDefinition.setMaxIndividualFileSize(config.getMaxFileSize());
             }
-            multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultCharset().name());
+            multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultRequestCharset().name());
 
             formParserFactory = FormParserFactory.builder(false)
                     .addParser(formDataParser)",2017-04-20T00:13:14Z,113
"@@ -382,9 +382,9 @@ private ServletPathMatchesData setupServletChains() {
                 }
             }
             if (filtersByDispatcher.isEmpty()) {
-                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), entry.getValue().getManagedServlet(), null, deploymentInfo, false, MappingMatch.UNKNOWN, """"));
+                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), entry.getValue().getManagedServlet(), null, deploymentInfo, false, MappingMatch.EXACT, """"));
             } else {
-                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filtersByDispatcher, deploymentInfo.isAllowNonStandardWrappers(), entry.getValue()), entry.getValue().getManagedServlet(), null, deploymentInfo, false, MappingMatch.UNKNOWN, """"));
+                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filtersByDispatcher, deploymentInfo.isAllowNonStandardWrappers(), entry.getValue()), entry.getValue().getManagedServlet(), null, deploymentInfo, false, MappingMatch.EXACT, """"));
             }
         }
 ",2017-04-20T00:13:14Z,169
"@@ -24,6 +24,7 @@
 import io.undertow.server.handlers.form.FormData;
 import io.undertow.server.handlers.form.FormDataParser;
 import io.undertow.server.handlers.form.MultiPartParserDefinition;
+import io.undertow.server.protocol.http.HttpAttachments;
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionConfig;
 import io.undertow.servlet.UndertowServletMessages;
@@ -42,6 +43,7 @@
 import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.DateUtils;
 import io.undertow.util.HeaderMap;
+import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 import io.undertow.util.LocaleUtils;
@@ -86,9 +88,9 @@
 import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.HttpUpgradeHandler;
-import javax.servlet.http.Mapping;
 import javax.servlet.http.Part;
 import javax.servlet.http.PushBuilder;
+import javax.servlet.http.ServletMapping;
 
 /**
  * The http servlet request implementation. This class is not thread safe
@@ -222,7 +224,7 @@ public Enumeration<String> getHeaderNames() {
     }
 
     @Override
-    public Mapping getMapping() {
+    public ServletMapping getServletMapping() {
         ServletRequestContext src = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         ServletPathMatch match = src.getOriginalServletPathMatch();
         String matchValue;
@@ -245,7 +247,7 @@ public Mapping getMapping() {
             default:
                 matchValue = match.getRemaining();
         }
-        return new MappingImpl(matchValue, match.getMatchString(), match.getMappingMatch());
+        return new MappingImpl(matchValue, match.getMatchString(), match.getMappingMatch(), match.getServletChain().getManagedServlet().getServletInfo().getName());
     }
 
     @Override
@@ -580,8 +582,9 @@ public String getCharacterEncoding() {
             return characterEncodingFromHeader;
         }
 
-        if (servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding() != null) {
-            return servletContext.getDeployment().getDefaultCharset().name();
+        if (servletContext.getDeployment().getDeploymentInfo().getDefaultRequestEncoding() != null ||
+                servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding() != null) {
+            return servletContext.getDeployment().getDefaultRequestCharset().name();
         }
 
         return null;
@@ -837,7 +840,7 @@ public BufferedReader getReader() throws IOException {
             if (servletInputStream != null) {
                 throw UndertowServletMessages.MESSAGES.getInputStreamAlreadyCalled();
             }
-            Charset charSet = servletContext.getDeployment().getDefaultCharset();
+            Charset charSet = servletContext.getDeployment().getDefaultRequestCharset();
             if (characterEncoding != null) {
                 charSet = characterEncoding;
             } else {
@@ -1151,7 +1154,23 @@ public void clearAttributes() {
     }
 
     @Override
-    public PushBuilder getPushBuilder() {
-        return new PushBuilderImpl(this);
+    public PushBuilder newPushBuilder() {
+        if(exchange.getConnection().isPushSupported()) {
+            return new PushBuilderImpl(this);
+        }
+        return null;
+    }
+
+    @Override
+    public Map<String, String> getTrailers() {
+        HeaderMap trailers = exchange.getAttachment(HttpAttachments.REQUEST_TRAILERS);
+        if(trailers == null) {
+            return null;
+        }
+        Map<String, String> ret = new HashMap<>();
+        for(HeaderValues entry : trailers) {
+            ret.put(entry.getHeaderName().toString(), entry.getFirst());
+        }
+        return ret;
     }
 }",2017-04-20T00:13:14Z,147
"@@ -318,7 +318,7 @@ public Collection<String> getHeaderNames() {
     @Override
     public String getCharacterEncoding() {
         if (charset == null) {
-            return servletContext.getDeployment().getDefaultCharset().name();
+            return servletContext.getDeployment().getDefaultResponseCharset().name();
         }
         return charset;
     }",2017-04-20T00:13:14Z,170
"@@ -18,22 +18,24 @@
 
 package io.undertow.servlet.spec;
 
-import javax.servlet.http.Mapping;
 import javax.servlet.http.MappingMatch;
+import javax.servlet.http.ServletMapping;
 
 /**
  * @author Stuart Douglas
  */
-public class MappingImpl implements Mapping {
+public class MappingImpl implements ServletMapping {
 
     private final String matchValue;
     private final String pattern;
     private final MappingMatch matchType;
+    private final String servletName;
 
-    public MappingImpl(String matchValue, String pattern, MappingMatch matchType) {
+    public MappingImpl(String matchValue, String pattern, MappingMatch matchType, String servletName) {
         this.matchValue = matchValue;
         this.pattern = pattern;
         this.matchType = matchType;
+        this.servletName = servletName;
     }
 
     @Override
@@ -47,7 +49,12 @@ public String getPattern() {
     }
 
     @Override
-    public MappingMatch getMatchType() {
+    public String getServletName() {
+        return servletName;
+    }
+
+    @Override
+    public MappingMatch getMappingMatch() {
         return matchType;
     }
 }",2017-04-20T00:13:14Z,268
"@@ -66,7 +66,7 @@ public InputStream getInputStream() throws IOException {
             return new BufferedInputStream(Files.newInputStream(formValue.getPath()));
         } else {
             String requestedCharset = servletRequest.getCharacterEncoding();
-            String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultCharset().name();
+            String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultRequestCharset().name();
             return new ByteArrayInputStream(formValue.getValue().getBytes(charset));
         }
     }",2017-04-20T00:13:14Z,269
"@@ -60,11 +60,8 @@ public class PushBuilderImpl implements PushBuilder {
     private String method;
     private String queryString;
     private String sessionId;
-    private boolean conditional;
     private final HeaderMap headers = new HeaderMap();
     private String path;
-    private String etag;
-    private String lastModified;
 
     public PushBuilderImpl(HttpServletRequestImpl servletRequest) {
         //TODO: auth
@@ -78,7 +75,6 @@ public PushBuilderImpl(HttpServletRequestImpl servletRequest) {
             this.sessionId = servletRequest.getRequestedSessionId();
         }
 
-        this.conditional = servletRequest.getHeader(Headers.IF_NONE_MATCH_STRING) != null || servletRequest.getHeader(Headers.IF_MODIFIED_SINCE_STRING) != null;
         for(HeaderValues header : servletRequest.getExchange().getRequestHeaders()) {
             if(!IGNORE.contains(header.getHeaderName())) {
                 headers.addAll(header.getHeaderName(), header);
@@ -90,7 +86,6 @@ public PushBuilderImpl(HttpServletRequestImpl servletRequest) {
             this.headers.add(Headers.REFERER, servletRequest.getRequestURL()  + ""?"" + servletRequest.getQueryString());
         }
         this.path = null;
-        this.etag = servletRequest.getHeader(Headers.ETAG_STRING);
         for(Map.Entry<String, Cookie> cookie : servletRequest.getExchange().getResponseCookies().entrySet()) {
             if(Objects.equals(0, cookie.getValue().getMaxAge())) {
                 //remove cookie
@@ -108,8 +103,6 @@ public PushBuilderImpl(HttpServletRequestImpl servletRequest) {
                 headers.add(Headers.COOKIE, cookie.getKey() + ""="" + cookie.getValue());
             }
         }
-        this.lastModified = null;
-        this.etag = null;
 
     }
 
@@ -132,12 +125,6 @@ public PushBuilder sessionId(String sessionId) {
         return this;
     }
 
-    @Override
-    public PushBuilder conditional(boolean conditional) {
-        this.conditional = conditional;
-        return this;
-    }
-
     @Override
     public PushBuilder setHeader(String name, String value) {
         headers.put(new HttpString(name), value);
@@ -162,18 +149,6 @@ public PushBuilder path(String path) {
         return this;
     }
 
-    @Override
-    public PushBuilder etag(String etag) {
-        this.etag = etag;
-        return this;
-    }
-
-    @Override
-    public PushBuilder lastModified(String lastModified) {
-        this.lastModified = lastModified;
-        return this;
-    }
-
     @Override
     public void push() {
         if(path == null) {
@@ -185,13 +160,6 @@ public void push() {
             for (HeaderValues entry : headers) {
                 newHeaders.addAll(entry.getHeaderName(), entry);
             }
-            if (conditional) {
-                if (etag != null) {
-                    newHeaders.put(Headers.IF_NONE_MATCH, etag);
-                } else if (lastModified != null) {
-                    newHeaders.put(Headers.IF_MODIFIED_SINCE, lastModified);
-                }
-            }
             if (sessionId != null) {
                 newHeaders.put(Headers.COOKIE, ""JSESSIONID="" + sessionId); //TODO: do this properly, may be a different tracking method or a different cookie name
             }
@@ -202,8 +170,6 @@ public void push() {
             con.pushResource(path, new HttpString(method), newHeaders);
         }
         path = null;
-        etag = null;
-        lastModified = null;
     }
 
     @Override
@@ -221,11 +187,6 @@ public String getSessionId() {
         return sessionId;
     }
 
-    @Override
-    public boolean isConditional() {
-        return conditional;
-    }
-
     @Override
     public Set<String> getHeaderNames() {
         Set<String> names = new HashSet<>();
@@ -245,13 +206,4 @@ public String getPath() {
         return path;
     }
 
-    @Override
-    public String getEtag() {
-        return etag;
-    }
-
-    @Override
-    public String getLastModified() {
-        return lastModified;
-    }
 }",2017-04-20T00:13:14Z,270
"@@ -746,6 +746,53 @@ public ClassLoader getClassLoader() {
     public void declareRoles(final String... roleNames) {
     }
 
+    @Override
+    public ServletRegistration.Dynamic addJspFile(String servletName, String jspFile) {
+        return null;
+    }
+
+    @Override
+    public int getSessionTimeout() {
+        return 0;
+    }
+
+    @Override
+    public void setSessionTimeout(int sessionTimeout) {
+
+    }
+
+    @Override
+    public String getRequestCharacterEncoding() {
+        String enconding = deploymentInfo.getDefaultRequestEncoding();
+        if(enconding != null) {
+            return enconding;
+        }
+        return deploymentInfo.getDefaultEncoding();
+    }
+
+    @Override
+    public void setRequestCharacterEncoding(String encoding) {
+        ensureNotInitialized();
+        ensureNotProgramaticListener();
+        deploymentInfo.setDefaultRequestEncoding(getContextPath());
+    }
+
+    @Override
+    public String getResponseCharacterEncoding() {
+        String enconding = deploymentInfo.getDefaultResponseEncoding();
+        if(enconding != null) {
+            return enconding;
+        }
+        return deploymentInfo.getDefaultEncoding();
+    }
+
+    @Override
+    public void setResponseCharacterEncoding(String encoding) {
+        ensureNotInitialized();
+        ensureNotProgramaticListener();
+        deploymentInfo.setDefaultResponseEncoding(encoding);
+    }
+
     @Override
     public String getVirtualServerName() {
         return deployment.getDeploymentInfo().getHostName();",2017-04-20T00:13:14Z,146
"@@ -21,7 +21,7 @@
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.Mapping;
+import javax.servlet.http.ServletMapping;
 import java.io.IOException;
 
 /**
@@ -30,10 +30,10 @@
 public class GetMappingServlet extends HttpServlet {
 
     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
-        Mapping mapping = request.getMapping();
+        ServletMapping mapping = request.getServletMapping();
         response.getWriter()
                 .append(""Mapping match:"")
-                .append(mapping.getMatchType().name())
+                .append(mapping.getMappingMatch().name())
                 .append(""\n"")
                 .append(""Match value:"")
                 .append(mapping.getMatchValue())",2017-04-20T00:13:14Z,271
"@@ -68,6 +68,7 @@ public void exchangeEvent(final HttpServerExchange exchange, final NextListener
             try {
                 final SuspendedRequest task = queue.poll();
                 if (task != null) {
+                    task.exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
                     task.exchange.dispatch(task.next);
                 } else {
                     decrementRequests();
@@ -99,7 +100,6 @@ public RequestLimit(int maximumConcurrentRequests, int queueSize) {
     }
 
     public void handleRequest(final HttpServerExchange exchange, final HttpHandler next) throws Exception {
-        exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
         long oldVal, newVal;
         do {
             oldVal = state;
@@ -118,6 +118,7 @@ public void run() {
             }
             newVal = oldVal + 1;
         } while (!stateUpdater.compareAndSet(this, oldVal, newVal));
+        exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
         next.handleRequest(exchange);
     }
 ",2014-12-04T02:03:55Z,341
"@@ -0,0 +1,182 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers;
+
+import io.undertow.Handlers;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.StatusCodes;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class RequestLimitingHandlerTestCase {
+
+    public static final int N_THREADS = 10;
+    private static volatile CountDownLatch latch = new CountDownLatch(1);
+
+    static final AtomicInteger count = new AtomicInteger();
+
+    @BeforeClass
+    public static void setup() {
+        DefaultServer.setRootHandler(new BlockingHandler(Handlers.requestLimitingHandler(2, N_THREADS, new HttpHandler() {
+            @Override
+            public void handleRequest(HttpServerExchange exchange) throws Exception {
+                int res = count.incrementAndGet();
+                try {
+                    if (!latch.await(20, TimeUnit.SECONDS)) {
+                        exchange.setResponseCode(500);
+                    } else {
+                        exchange.getOutputStream().write(("""" + res).getBytes(""US-ASCII""));
+                    }
+                } finally {
+                    count.decrementAndGet();
+                }
+            }
+        })));
+
+    }
+
+
+    @Test
+    public void testRateLimitingHandler() throws ExecutionException, InterruptedException {
+        latch.countDown();
+        latch = new CountDownLatch(1);
+        ExecutorService executor = Executors.newFixedThreadPool(N_THREADS);
+        try {
+            final List<Future<?>> futures = new ArrayList<>();
+            for (int i = 0; i < N_THREADS; ++i) {
+                futures.add(executor.submit(new Callable<String>() {
+                    @Override
+                    public String call() {
+                        TestHttpClient client = new TestHttpClient();
+                        try {
+                            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
+                            HttpResponse result = client.execute(get);
+                            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+                            return HttpClientUtils.readResponse(result);
+                        } catch (IOException e) {
+                            throw new RuntimeException(e);
+                        } finally {
+                            client.getConnectionManager().shutdown();
+                        }
+                    }
+                }));
+            }
+            Thread.sleep(300);
+            latch.countDown();
+            for (Future<?> future : futures) {
+                String res = (String) future.get();
+                Assert.assertTrue(res, res.equals(""1"") || res.equals(""2""));
+            }
+        } finally {
+            executor.shutdown();
+        }
+
+    }
+
+
+    @Test
+    public void testRateLimitingHandlerQueueFull() throws ExecutionException, InterruptedException {
+        latch.countDown();
+        latch = new CountDownLatch(1);
+        ExecutorService executor = Executors.newFixedThreadPool(N_THREADS * 2);
+        try {
+            final List<Future<?>> futures = new ArrayList<>();
+            for (int i = 0; i < N_THREADS * 2; ++i) {
+                futures.add(executor.submit(new Callable<String>() {
+                    @Override
+                    public String call() {
+                        TestHttpClient client = new TestHttpClient();
+                        try {
+                            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
+                            HttpResponse result = client.execute(get);
+                            if(result.getStatusLine().getStatusCode() == 513) {
+                                return ""513"";
+                            }
+                            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+                            return HttpClientUtils.readResponse(result);
+                        } catch (IOException e) {
+                            throw new RuntimeException(e);
+                        } finally {
+                            client.getConnectionManager().shutdown();
+                        }
+                    }
+                }));
+            }
+            Thread.sleep(300);
+            latch.countDown();
+            for (Future<?> future : futures) {
+                String res = (String) future.get();
+                Assert.assertTrue(res, res.equals(""1"") || res.equals(""2"") || res.equals(""513""));
+            }
+            futures.clear();
+            for (int i = 0; i < 2; ++i) {
+                futures.add(executor.submit(new Callable<String>() {
+                    @Override
+                    public String call() {
+                        TestHttpClient client = new TestHttpClient();
+                        try {
+                            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
+                            HttpResponse result = client.execute(get);
+                            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+                            return HttpClientUtils.readResponse(result);
+                        } catch (IOException e) {
+                            throw new RuntimeException(e);
+                        } finally {
+                            client.getConnectionManager().shutdown();
+                        }
+                    }
+                }));
+            }
+
+            for (Future<?> future : futures) {
+                String res = (String) future.get();
+                Assert.assertTrue(res, res.equals(""1"") || res.equals(""2""));
+            }
+
+        } finally {
+            executor.shutdown();
+        }
+
+    }
+
+}",2014-12-04T02:03:55Z,135
"@@ -952,6 +952,18 @@ private class FrameCloseListener implements ChannelListener<CloseableChannel> {
 
         @Override
         public void handleEvent(final CloseableChannel c) {
+
+            if (Thread.currentThread() != c.getIoThread() && !c.getWorker().isShutdown()) {
+                runInIoThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
+                    }
+                });
+                return;
+            }
+
+
             if(c instanceof  StreamSinkChannel) {
                 sinkClosed = true;
             } else if(c instanceof StreamSourceChannel) {
@@ -984,16 +996,6 @@ public void run() {
 
                 return;
             }
-
-            if (Thread.currentThread() != c.getIoThread()) {
-                runInIoThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        ChannelListeners.invokeChannelListener(c, FrameCloseListener.this);
-                    }
-                });
-                return;
-            }
             R receiver = AbstractFramedChannel.this.receiver;
             try {
                 if (receiver != null && receiver.isOpen() && receiver.isReadResumed()) {",2016-08-03T02:59:44Z,168
"@@ -174,6 +174,9 @@ public void testAsyncReceiveWholeBytes() {
 
     @Test
     public void testAsyncReceiveWholeBytesFailed() throws Exception {
+        // TODO un-@Ignore - https://issues.jboss.org/browse/UNDERTOW-1531 - ReceiverTestCase#testAsyncReceiveWholeBytesFailed[proxy][http2] fails intermittently on Windows
+        org.junit.Assume.assumeFalse(DefaultServer.isH2() && org.apache.commons.lang.SystemUtils.IS_OS_WINDOWS);
+
         EXCEPTIONS.clear();
         Socket socket = new Socket();
         socket.connect(DefaultServer.getDefaultServerAddress());",2019-04-25T23:24:33Z,342
"@@ -181,6 +181,10 @@ public IoFuture<SslConnection> openSslConnection(final XnioIoThread ioThread, fi
         return setupSslConnection(futureResult, connection);
     }
 
+    public SslConnection wrapExistingConnection(StreamConnection connection, OptionMap optionMap) {
+        return new UndertowSslConnection(connection, JsseSslUtils.createSSLEngine(sslContext, optionMap, (InetSocketAddress) connection.getPeerAddress()), bufferPool);
+    }
+
     private IoFuture<SslConnection> setupSslConnection(FutureResult<SslConnection> futureResult, IoFuture<StreamConnection> connection) {
         connection.addNotifier(new IoFuture.HandlingNotifier<StreamConnection, FutureResult<SslConnection>>() {
             public void handleCancelled(final FutureResult<SslConnection> attachment) {",2015-03-16T03:24:03Z,228
"@@ -24,6 +24,7 @@
 import io.undertow.client.ClientExchange;
 import io.undertow.client.ClientRequest;
 import io.undertow.client.UndertowClient;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 import io.undertow.util.Protocols;
@@ -249,9 +250,8 @@ public void completed(ClientExchange response) {
                                         if (response.getResponse().getResponseCode() == 200) {
                                             try {
                                                 StreamConnection targetConnection = connection.performUpgrade();
-                                                if(uri.getScheme().equals(""wss"") && uri.getScheme().equals(""https"")) {
-
-                                                    ioFuture.setException(new IOException(""SSL connection over proxies not yet implemented""));
+                                                if(uri.getScheme().equals(""wss"") || uri.getScheme().equals(""https"")) {
+                                                    handleConnectionWithExistingConnection(((UndertowXnioSsl)ssl).wrapExistingConnection(targetConnection, optionMap));
                                                 } else {
                                                     handleConnectionWithExistingConnection(targetConnection);
                                                 }",2015-03-16T03:24:03Z,326
"@@ -28,6 +28,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.undertow.Undertow;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.ConnectHandler;
@@ -89,7 +90,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             }
         });
 
-        server = Undertow.builder().addHttpListener(DefaultServer.getHostPort(""default"") + 1, DefaultServer.getHostAddress(""default""))
+        DefaultServer.startSSLServer();
+
+        server = Undertow.builder().addHttpListener(DefaultServer.getHostPort(""default"") + 10, DefaultServer.getHostAddress(""default""))
                 .setHandler(new HttpHandler() {
                     @Override
                     public void handleRequest(HttpServerExchange exchange) throws Exception {
@@ -102,9 +105,10 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
     }
 
     @AfterClass
-    public static void stop() {
+    public static void stop() throws IOException {
         server.stop();
         server = null;
+        DefaultServer.stopSSLServer();
     }
 
 
@@ -153,7 +157,46 @@ protected void onError(WebSocketChannel channel, Throwable error) {
     public void testMessageViaProxy() throws Exception {
 
         final WebSocketChannel webSocketChannel = WebSocketClient.connectionBuilder(worker, buffer, new URI(DefaultServer.getDefaultServerURL()))
-                .setProxyUri(new URI(""http"", null, DefaultServer.getHostAddress(""default""), DefaultServer.getHostPort(""default"")  + 1, ""/proxy"", null, null))
+                .setProxyUri(new URI(""http"", null, DefaultServer.getHostAddress(""default""), DefaultServer.getHostPort(""default"")  + 10, ""/proxy"", null, null))
+                .connect().get();
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<String> result = new AtomicReference<>();
+        webSocketChannel.getReceiveSetter().set(new AbstractReceiveListener() {
+            @Override
+            protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) throws IOException {
+                String data = message.getData();
+                result.set(data);
+                latch.countDown();
+            }
+
+            @Override
+            protected void onError(WebSocketChannel channel, Throwable error) {
+                super.onError(channel, error);
+                error.printStackTrace();
+                latch.countDown();
+            }
+        });
+        webSocketChannel.resumeReceives();
+
+
+        StreamSinkFrameChannel sendChannel = webSocketChannel.send(WebSocketFrameType.TEXT, 11);
+        new StringWriteChannelListener(""Hello World"").setup(sendChannel);
+
+        latch.await(10, TimeUnit.SECONDS);
+        Assert.assertEquals(""Hello World"", result.get());
+        webSocketChannel.sendClose();
+        Assert.assertEquals(""CONNECT "" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default""), connectLog.poll());
+    }
+
+
+    @Test
+    @ProxyIgnore
+    public void testMessageViaWssProxy() throws Exception {
+
+        final WebSocketChannel webSocketChannel = WebSocketClient.connectionBuilder(worker, buffer, new URI(DefaultServer.getDefaultServerSSLAddress()))
+                .setSsl(new UndertowXnioSsl(Xnio.getInstance(), OptionMap.EMPTY, DefaultServer.getClientSSLContext()))
+                .setProxyUri(new URI(""http"", null, DefaultServer.getHostAddress(""default""), DefaultServer.getHostPort(""default"") + 10, ""/proxy"", null, null))
                 .connect().get();
 
         final CountDownLatch latch = new CountDownLatch(1);
@@ -182,6 +225,6 @@ protected void onError(WebSocketChannel channel, Throwable error) {
         latch.await(10, TimeUnit.SECONDS);
         Assert.assertEquals(""Hello World"", result.get());
         webSocketChannel.sendClose();
-        Assert.assertEquals(""CONNECT localhost:7777"", connectLog.poll());
+        Assert.assertEquals(""CONNECT "" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostSSLPort(""default""), connectLog.poll());
     }
 }",2015-03-16T03:24:03Z,343
"@@ -35,12 +35,18 @@ public class PathResource implements RangeAwareResource {
 
     private final Path file;
     private final String path;
+    private final ETag eTag;
     private final PathResourceManager manager;
 
-    public PathResource(final Path file, final PathResourceManager manager, String path) {
+    public PathResource(final Path file, final PathResourceManager manager, String path, ETag eTag) {
         this.file = file;
         this.path = path;
         this.manager = manager;
+        this.eTag = eTag;
+    }
+
+    public PathResource(final Path file, final PathResourceManager manager, String path) {
+        this(file, manager, path, null);
     }
 
     @Override
@@ -64,7 +70,7 @@ public String getLastModifiedString() {
 
     @Override
     public ETag getETag() {
-        return null;
+        return eTag;
     }
 
     @Override",2017-03-04T19:29:12Z,344
"@@ -3,6 +3,7 @@
 
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowMessages;
+import io.undertow.util.ETag;
 import org.xnio.FileChangeCallback;
 import org.xnio.FileChangeEvent;
 import org.xnio.FileSystemWatcher;
@@ -26,6 +27,13 @@
 public class PathResourceManager implements ResourceManager  {
 
     private static final boolean DEFAULT_CHANGE_LISTENERS_ALLOWED = !Boolean.getBoolean(""io.undertow.disable-file-system-watcher"");
+    private static final long DEFAULT_TRANSFER_MIN_SIZE = 1024;
+    private static final ETagFunction NULL_ETAG_FUNCTION = new ETagFunction() {
+        @Override
+        public ETag generate(Path path) {
+            return null;
+        }
+    };
 
     private final List<ResourceChangeListener> listeners = new ArrayList<>();
 
@@ -55,10 +63,12 @@ public class PathResourceManager implements ResourceManager  {
      */
     private final TreeSet<String> safePaths = new TreeSet<>();
 
+    private final ETagFunction eTagFunction;
+
     private final boolean allowResourceChangeListeners;
 
     public PathResourceManager(final Path base) {
-        this(base, 1024, true, false, null);
+        this(base, DEFAULT_TRANSFER_MIN_SIZE, true, false, null);
     }
 
     public PathResourceManager(final Path base, long transferMinSize) {
@@ -93,36 +103,48 @@ protected PathResourceManager(long transferMinSize, boolean caseSensitive, boole
             }
             this.safePaths.addAll(Arrays.asList(safePaths));
         }
+        this.eTagFunction = NULL_ETAG_FUNCTION;
     }
 
     public PathResourceManager(final Path base, long transferMinSize, boolean caseSensitive, boolean followLinks, final String... safePaths) {
         this(base, transferMinSize, caseSensitive, followLinks, DEFAULT_CHANGE_LISTENERS_ALLOWED, safePaths);
     }
 
     public PathResourceManager(final Path base, long transferMinSize, boolean caseSensitive, boolean followLinks, boolean allowResourceChangeListeners, final String... safePaths) {
-        this.allowResourceChangeListeners = allowResourceChangeListeners;
-        if (base == null) {
+        this(builder()
+                .setBase(base)
+                .setTransferMinSize(transferMinSize)
+                .setCaseSensitive(caseSensitive)
+                .setFollowLinks(followLinks)
+                .setAllowResourceChangeListeners(allowResourceChangeListeners)
+                .setSafePaths(safePaths));
+    }
+
+    private PathResourceManager(Builder builder) {
+        this.allowResourceChangeListeners = builder.allowResourceChangeListeners;
+        if (builder.base == null) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
         }
-        String basePath = base.normalize().toAbsolutePath().toString();
+        String basePath = builder.base.normalize().toAbsolutePath().toString();
         if (!basePath.endsWith(File.separator)) {
             basePath = basePath + File.separatorChar;
         }
         this.base = basePath;
-        this.transferMinSize = transferMinSize;
-        this.caseSensitive = caseSensitive;
-        this.followLinks = followLinks;
+        this.transferMinSize = builder.transferMinSize;
+        this.caseSensitive = builder.caseSensitive;
+        this.followLinks = builder.followLinks;
         if (this.followLinks) {
-            if (safePaths == null) {
+            if (builder.safePaths == null) {
                 throw UndertowMessages.MESSAGES.argumentCannotBeNull(""safePaths"");
             }
-            for (final String safePath : safePaths) {
+            for (final String safePath : builder.safePaths) {
                 if (safePath == null) {
                     throw UndertowMessages.MESSAGES.argumentCannotBeNull(""safePaths"");
                 }
             }
-            this.safePaths.addAll(Arrays.asList(safePaths));
+            this.safePaths.addAll(Arrays.asList(builder.safePaths));
         }
+        this.eTagFunction = builder.eTagFunction;
     }
 
     public Path getBasePath() {
@@ -340,16 +362,16 @@ protected PathResource getFileResource(final Path file, final String path, final
                     relative = relative.substring(1);
                 }
                 if (relative.equals(compare)) {
-                    return new PathResource(file, this, path);
+                    return new PathResource(file, this, path, eTagFunction.generate(file));
                 }
                 return null;
             } else if (isFileSameCase(file, normalizedFile)) {
-                return new PathResource(file, this, path);
+                return new PathResource(file, this, path, eTagFunction.generate(file));
             } else {
                 return null;
             }
         } else {
-            return new PathResource(file, this, path);
+            return new PathResource(file, this, path, eTagFunction.generate(file));
         }
     }
 
@@ -362,4 +384,72 @@ private SymlinkResult(boolean requiresCheck, Path path) {
             this.path = path;
         }
     }
+
+    public interface ETagFunction {
+
+        /**
+         * Generates an {@link ETag} for the provided {@link Path}.
+         *
+         * @param path Path for which to generate an ETag
+         * @return ETag representing the provided path, or null
+         */
+        ETag generate(Path path);
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+
+        private Path base;
+        private long transferMinSize = DEFAULT_TRANSFER_MIN_SIZE;
+        private boolean caseSensitive = true;
+        private boolean followLinks = false;
+        private boolean allowResourceChangeListeners = DEFAULT_CHANGE_LISTENERS_ALLOWED;
+        private ETagFunction eTagFunction = NULL_ETAG_FUNCTION;
+        private String[] safePaths;
+
+        private Builder() {
+        }
+
+        public Builder setBase(Path base) {
+            this.base = base;
+            return this;
+        }
+
+        public Builder setTransferMinSize(long transferMinSize) {
+            this.transferMinSize = transferMinSize;
+            return this;
+        }
+
+        public Builder setCaseSensitive(boolean caseSensitive) {
+            this.caseSensitive = caseSensitive;
+            return this;
+        }
+
+        public Builder setFollowLinks(boolean followLinks) {
+            this.followLinks = followLinks;
+            return this;
+        }
+
+        public Builder setAllowResourceChangeListeners(boolean allowResourceChangeListeners) {
+            this.allowResourceChangeListeners = allowResourceChangeListeners;
+            return this;
+        }
+
+        public Builder setETagFunction(ETagFunction eTagFunction) {
+            this.eTagFunction = eTagFunction;
+            return this;
+        }
+
+        public Builder setSafePaths(String[] safePaths) {
+            this.safePaths = safePaths;
+            return this;
+        }
+
+        public ResourceManager build() {
+            return new PathResourceManager(this);
+        }
+    }
 }",2017-03-04T19:29:12Z,345
"@@ -2,6 +2,8 @@
 
 import io.undertow.testutils.category.UnitTest;
 import io.undertow.server.handlers.resource.PathResourceManager;
+import io.undertow.server.handlers.resource.ResourceManager;
+import io.undertow.util.ETag;
 import org.junit.Assert;
 import org.junit.Assume;
 import org.junit.Test;
@@ -68,4 +70,22 @@ public void testBaseDirInSymlink() throws Exception {
         }
 
     }
+
+    @Test
+    public void testETagFunction() throws Exception {
+        final String fileName = ""page.html"";
+        final Path rootPath = Paths.get(getClass().getResource(fileName).toURI()).getParent();
+        final ResourceManager resourceManager = PathResourceManager.builder()
+                .setBase(rootPath)
+                .setETagFunction(new PathResourceManager.ETagFunction() {
+                    @Override
+                    public ETag generate(Path path) {
+                        return new ETag(true, path.getFileName().toString());
+                    }
+                })
+                .build();
+        ETag expected = new ETag(true, fileName);
+        ETag actual = resourceManager.getResource(""page.html"").getETag();
+        Assert.assertEquals(expected, actual);
+    }
 }",2017-03-04T19:29:12Z,346
"@@ -25,7 +25,7 @@ public class StatusCodes {
 
     //chosen simply because it gives no collisions
     //if more codes are added this will need to be re-evaluated
-    private static final int SIZE = 64;
+    private static final int SIZE = 0x3f;
     private static final Entry[] TABLE = new Entry[SIZE];
 
     public static final int CONTINUE = 100;
@@ -156,7 +156,7 @@ public class StatusCodes {
 
     private static void putCode(int code, String reason) {
         Entry e = new Entry(reason, code);
-        int h = code % SIZE;
+        int h = code & SIZE;
         if(TABLE[h] != null) {
             throw new IllegalArgumentException(""hash collision"");
         }
@@ -167,7 +167,7 @@ private StatusCodes() {
     }
 
     public static final String getReason(final int code) {
-        final Entry result = TABLE[code % SIZE];
+        final Entry result = TABLE[code & SIZE];
         if (result == null || result.code != code) {
             return ""Unknown"";
         } else {",2014-01-06T15:09:24Z,11
"@@ -18,263 +18,53 @@
 
 package io.undertow.util;
 
-import java.util.AbstractCollection;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.Iterator;
-import java.util.NoSuchElementException;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import io.netty.handler.codec.http.HttpHeaders;
 
 /**
  * An optimized array-backed header map.
  *
  * @author <a href=""mailto:david.lloyd@redhat.com"">David M. Lloyd</a>
  */
+@Deprecated
 public final class HeaderMap implements Iterable<HeaderValues> {
 
-    private Object[] table;
-    private int size;
-    private Collection<HttpString> headerNames;
+    private final HttpHeaders headers;
 
-    public HeaderMap() {
-        table = new Object[16];
+    public HeaderMap(HttpHeaders headers) {
+        this.headers = headers;
     }
 
     private HeaderValues getEntry(final HttpString headerName) {
-        if (headerName == null) {
-            return null;
-        }
-        final int hc = headerName.hashCode();
-        final int idx = hc & (table.length - 1);
-        final Object o = table[idx];
-        if (o == null) {
-            return null;
-        }
-        HeaderValues headerValues;
-        if (o instanceof HeaderValues) {
-            headerValues = (HeaderValues) o;
-            if (! headerName.equals(headerValues.key)) {
-                return null;
-            }
-            return headerValues;
-        } else {
-            final HeaderValues[] row = (HeaderValues[]) o;
-            for (int i = 0; i < row.length; i++) {
-                headerValues = row[i];
-                if (headerValues != null && headerName.equals(headerValues.key)) {
-                    return headerValues;
-                }
-            }
+        List<String> res = headers.getAll(headerName.toString());
+        if (res.isEmpty()) {
             return null;
         }
+        return new HeaderValues(headers, headerName.toString(), res);
     }
 
 
     private HeaderValues getEntry(final String headerName) {
-        if (headerName == null) {
-            return null;
-        }
-        final int hc = HttpString.hashCodeOf(headerName);
-        final int idx = hc & (table.length - 1);
-        final Object o = table[idx];
-        if (o == null) {
-            return null;
-        }
-        HeaderValues headerValues;
-        if (o instanceof HeaderValues) {
-            headerValues = (HeaderValues) o;
-            if (! headerValues.key.equalToString(headerName)) {
-                return null;
-            }
-            return headerValues;
-        } else {
-            final HeaderValues[] row = (HeaderValues[]) o;
-            for (int i = 0; i < row.length; i++) {
-                headerValues = row[i];
-                if (headerValues != null && headerValues.key.equalToString(headerName)) {
-                    return headerValues;
-                }
-            }
+        List<String> res = headers.getAll(headerName);
+        if (res.isEmpty()) {
             return null;
         }
+        return new HeaderValues(headers, headerName, res);
     }
 
     private HeaderValues removeEntry(final HttpString headerName) {
-        if (headerName == null) {
-            return null;
-        }
-        final int hc = headerName.hashCode();
-        final Object[] table = this.table;
-        final int idx = hc & (table.length - 1);
-        final Object o = table[idx];
-        if (o == null) {
-            return null;
-        }
-        HeaderValues headerValues;
-        if (o instanceof HeaderValues) {
-            headerValues = (HeaderValues) o;
-            if (! headerName.equals(headerValues.key)) {
-                return null;
-            }
-            table[idx] = null;
-            size --;
-            return headerValues;
-        } else {
-            final HeaderValues[] row = (HeaderValues[]) o;
-            for (int i = 0; i < row.length; i++) {
-                headerValues = row[i];
-                if (headerValues != null && headerName.equals(headerValues.key)) {
-                    row[i] = null;
-                    size --;
-                    return headerValues;
-                }
-            }
-            return null;
-        }
-    }
-
-
-    private HeaderValues removeEntry(final String headerName) {
-        if (headerName == null) {
-            return null;
-        }
-        final int hc = HttpString.hashCodeOf(headerName);
-        final Object[] table = this.table;
-        final int idx = hc & (table.length - 1);
-        final Object o = table[idx];
-        if (o == null) {
+        List<String> res = headers.getAll(headerName.toString());
+        headers.remove(headerName.toString());
+        if (res.isEmpty()) {
             return null;
         }
-        HeaderValues headerValues;
-        if (o instanceof HeaderValues) {
-            headerValues = (HeaderValues) o;
-            if (! headerValues.key.equalToString(headerName)) {
-                return null;
-            }
-            table[idx] = null;
-            size --;
-            return headerValues;
-        } else {
-            final HeaderValues[] row = (HeaderValues[]) o;
-            for (int i = 0; i < row.length; i++) {
-                headerValues = row[i];
-                if (headerValues != null && headerValues.key.equalToString(headerName)) {
-                    row[i] = null;
-                    size --;
-                    return headerValues;
-                }
-            }
-            return null;
-        }
-    }
-
-    private void resize() {
-        final int oldLen = table.length;
-        if (oldLen == 0x40000000) {
-            return;
-        }
-        assert Integer.bitCount(oldLen) == 1;
-        Object[] newTable = Arrays.copyOf(table, oldLen << 1);
-        table = newTable;
-        for (int i = 0; i < oldLen; i ++) {
-            if (newTable[i] == null) {
-                continue;
-            }
-            if (newTable[i] instanceof HeaderValues) {
-                HeaderValues e = (HeaderValues) newTable[i];
-                if ((e.key.hashCode() & oldLen) != 0) {
-                    newTable[i] = null;
-                    newTable[i + oldLen] = e;
-                }
-                continue;
-            }
-            HeaderValues[] oldRow = (HeaderValues[]) newTable[i];
-            HeaderValues[] newRow = oldRow.clone();
-            int rowLen = oldRow.length;
-            newTable[i + oldLen] = newRow;
-            HeaderValues item;
-            for (int j = 0; j < rowLen; j ++) {
-                item = oldRow[j];
-                if (item != null) {
-                    if ((item.key.hashCode() & oldLen) != 0) {
-                        oldRow[j] = null;
-                    } else {
-                        newRow[j] = null;
-                    }
-                }
-            }
-        }
-    }
-
-    private HeaderValues getOrCreateEntry(final HttpString headerName) {
-        if (headerName == null) {
-            return null;
-        }
-        final int hc = headerName.hashCode();
-        final Object[] table = this.table;
-        final int length = table.length;
-        final int idx = hc & (length - 1);
-        final Object o = table[idx];
-        HeaderValues headerValues;
-        if (o == null) {
-            if (size >= length >> 1) {
-                resize();
-                return getOrCreateEntry(headerName);
-            }
-            headerValues = new HeaderValues(headerName);
-            table[idx] = headerValues;
-            size++;
-            return headerValues;
-        }
-        return getOrCreateNonEmpty(headerName, table, length, idx, o);
-    }
-
-    private HeaderValues getOrCreateNonEmpty(HttpString headerName, Object[] table, int length, int idx, Object o) {
-        HeaderValues headerValues;
-        if (o instanceof HeaderValues) {
-            headerValues = (HeaderValues) o;
-            if (! headerName.equals(headerValues.key)) {
-                if (size >= length >> 1) {
-                    resize();
-                    return getOrCreateEntry(headerName);
-                }
-                size++;
-                final HeaderValues[] row = { headerValues, new HeaderValues(headerName), null, null };
-                table[idx] = row;
-                return row[1];
-            }
-            return headerValues;
-        } else {
-            final HeaderValues[] row = (HeaderValues[]) o;
-            int empty = -1;
-            for (int i = 0; i < row.length; i++) {
-                headerValues = row[i];
-                if (headerValues != null) {
-                    if (headerName.equals(headerValues.key)) {
-                        return headerValues;
-                    }
-                } else if (empty == -1) {
-                    empty = i;
-                }
-            }
-            if (size >= length >> 1) {
-                resize();
-                return getOrCreateEntry(headerName);
-            }
-            size++;
-            headerValues = new HeaderValues(headerName);
-            if (empty != -1) {
-                row[empty] = headerValues;
-            } else {
-                if (row.length >= 16) {
-                    throw new SecurityException(""Excessive collisions"");
-                }
-                final HeaderValues[] newRow = Arrays.copyOf(row, row.length + 3);
-                newRow[row.length] = headerValues;
-                table[idx] = newRow;
-            }
-            return headerValues;
-        }
+        return new HeaderValues(headers, headerName.toString(), res);
     }
 
     // get
@@ -364,191 +154,7 @@ public int count(String headerName) {
     }
 
     public int size() {
-        return size;
-    }
-
-    // iterate
-
-    /**
-     * Do a fast iteration of this header map without creating any objects.
-     *
-     * @return an opaque iterating cookie, or -1 if no iteration is possible
-     *
-     * @see #fiNext(long)
-     * @see #fiCurrent(long)
-     */
-    public long fastIterate() {
-        final Object[] table = this.table;
-        final int len = table.length;
-        int ri = 0;
-        int ci;
-        while (ri < len) {
-            final Object item = table[ri];
-            if (item != null) {
-                if (item instanceof HeaderValues) {
-                    return (long)ri << 32L;
-                } else {
-                    final HeaderValues[] row = (HeaderValues[]) item;
-                    ci = 0;
-                    final int rowLen = row.length;
-                    while (ci < rowLen) {
-                        if (row[ci] != null) {
-                            return (long)ri << 32L | (ci & 0xffffffffL);
-                        }
-                        ci ++;
-                    }
-                }
-            }
-            ri++;
-        }
-        return -1L;
-    }
-
-    /**
-     * Do a fast iteration of this header map without creating any objects, only considering non-empty header values.
-     *
-     * @return an opaque iterating cookie, or -1 if no iteration is possible
-     */
-    public long fastIterateNonEmpty() {
-        final Object[] table = this.table;
-        final int len = table.length;
-        int ri = 0;
-        int ci;
-        while (ri < len) {
-            final Object item = table[ri];
-            if (item != null) {
-                if (item instanceof HeaderValues) {
-                    if(!((HeaderValues) item).isEmpty()) {
-                        return (long) ri << 32L;
-                    }
-                } else {
-                    final HeaderValues[] row = (HeaderValues[]) item;
-                    ci = 0;
-                    final int rowLen = row.length;
-                    while (ci < rowLen) {
-                        if (row[ci] != null && !row[ci].isEmpty()) {
-                            return (long)ri << 32L | (ci & 0xffffffffL);
-                        }
-                        ci ++;
-                    }
-                }
-            }
-            ri++;
-        }
-        return -1L;
-    }
-
-    /**
-     * Find the next index in a fast iteration.
-     *
-     * @param cookie the previous cookie value
-     * @return the next cookie value, or -1L if iteration is done
-     */
-    public long fiNext(long cookie) {
-        if (cookie == -1L) return -1L;
-        final Object[] table = this.table;
-        final int len = table.length;
-        int ri = (int) (cookie >> 32);
-        int ci = (int) cookie;
-        Object item = table[ri];
-        if (item instanceof HeaderValues[]) {
-            final HeaderValues[] row = (HeaderValues[]) item;
-            final int rowLen = row.length;
-            if (++ci >= rowLen) {
-                ri ++; ci = 0;
-            } else if (row[ci] != null) {
-                return (long)ri << 32L | (ci & 0xffffffffL);
-            }
-        } else {
-            ri ++; ci = 0;
-        }
-        while (ri < len) {
-            item = table[ri];
-            if (item instanceof HeaderValues) {
-                return (long)ri << 32L;
-            } else if (item instanceof HeaderValues[]) {
-                final HeaderValues[] row = (HeaderValues[]) item;
-                final int rowLen = row.length;
-                while (ci < rowLen) {
-                    if (row[ci] != null) {
-                        return (long)ri << 32L | (ci & 0xffffffffL);
-                    }
-                    ci ++;
-                }
-            }
-            ci = 0;
-            ri ++;
-        }
-        return -1L;
-    }
-
-    /**
-     * Find the next non-empty index in a fast iteration.
-     *
-     * @param cookie the previous cookie value
-     * @return the next cookie value, or -1L if iteration is done
-     */
-    public long fiNextNonEmpty(long cookie) {
-        if (cookie == -1L) return -1L;
-        final Object[] table = this.table;
-        final int len = table.length;
-        int ri = (int) (cookie >> 32);
-        int ci = (int) cookie;
-        Object item = table[ri];
-        if (item instanceof HeaderValues[]) {
-            final HeaderValues[] row = (HeaderValues[]) item;
-            final int rowLen = row.length;
-            if (++ci >= rowLen) {
-                ri ++; ci = 0;
-            } else if (row[ci] != null && !row[ci].isEmpty()) {
-                return (long)ri << 32L | (ci & 0xffffffffL);
-            }
-        } else {
-            ri ++; ci = 0;
-        }
-        while (ri < len) {
-            item = table[ri];
-            if (item instanceof HeaderValues && !((HeaderValues) item).isEmpty()) {
-                return (long)ri << 32L;
-            } else if (item instanceof HeaderValues[]) {
-                final HeaderValues[] row = (HeaderValues[]) item;
-                final int rowLen = row.length;
-                while (ci < rowLen) {
-                    if (row[ci] != null && !row[ci].isEmpty()) {
-                        return (long)ri << 32L | (ci & 0xffffffffL);
-                    }
-                    ci ++;
-                }
-            }
-            ci = 0;
-            ri ++;
-        }
-        return -1L;
-    }
-
-    /**
-     * Return the value at the current index in a fast iteration.
-     *
-     * @param cookie the iteration cookie value
-     * @return the values object at this position
-     * @throws NoSuchElementException if the cookie value is invalid
-     */
-    public HeaderValues fiCurrent(long cookie) {
-        try {
-            final Object[] table = this.table;
-            int ri = (int) (cookie >> 32);
-            int ci = (int) cookie;
-            final Object item = table[ri];
-            if (item instanceof HeaderValues[]) {
-                return ((HeaderValues[])item)[ci];
-            } else if (ci == 0) {
-                return (HeaderValues) item;
-            } else {
-                throw new NoSuchElementException();
-            }
-        } catch (RuntimeException e) {
-            throw new NoSuchElementException();
-        }
+        return headers.size();
     }
 
     public Iterable<String> eachValue(final HttpString headerName) {
@@ -563,124 +169,11 @@ public Iterable<String> eachValue(final HttpString headerName) {
     }
 
     public Iterator<HeaderValues> iterator() {
-        return new Iterator<HeaderValues>() {
-            final Object[] table = HeaderMap.this.table;
-            boolean consumed;
-            int ri, ci;
-
-            private HeaderValues _next() {
-                for (;;) {
-                    if (ri >= table.length) {
-                        return null;
-                    }
-                    final Object o = table[ri];
-                    if (o == null) {
-                        // zero-entry row
-                        ri++;
-                        ci = 0;
-                        consumed = false;
-                        continue;
-                    }
-                    if (o instanceof HeaderValues) {
-                        // one-entry row
-                        if (ci > 0 || consumed) {
-                            ri++;
-                            ci = 0;
-                            consumed = false;
-                            continue;
-                        }
-                        return (HeaderValues) o;
-                    }
-                    final HeaderValues[] row = (HeaderValues[]) o;
-                    final int len = row.length;
-                    if (ci >= len) {
-                        ri ++;
-                        ci = 0;
-                        consumed = false;
-                        continue;
-                    }
-                    if (consumed) {
-                        ci++;
-                        consumed = false;
-                        continue;
-                    }
-                    final HeaderValues headerValues = row[ci];
-                    if (headerValues == null) {
-                        ci ++;
-                        continue;
-                    }
-                    return headerValues;
-                }
-            }
-
-            public boolean hasNext() {
-                return _next() != null;
-            }
-
-            public HeaderValues next() {
-                final HeaderValues next = _next();
-                if (next == null) {
-                    throw new NoSuchElementException();
-                }
-                consumed = true;
-                return next;
-            }
-
-            public void remove() {
-            }
-        };
+        return headers.names().stream().map((s) -> new HeaderValues(headers, s, headers.getAll(s))).collect(Collectors.toCollection(HashSet::new)).iterator();
     }
 
     public Collection<HttpString> getHeaderNames() {
-        if (headerNames != null) {
-            return headerNames;
-        }
-        return headerNames = new AbstractCollection<HttpString>() {
-            public boolean contains(final Object o) {
-                return o instanceof HttpString && getEntry((HttpString) o) != null;
-            }
-
-            public boolean add(final HttpString httpString) {
-                getOrCreateEntry(httpString);
-                return true;
-            }
-
-            public boolean remove(final Object o) {
-                if (! (o instanceof HttpString)) return false;
-                HttpString s = (HttpString) o;
-                HeaderValues entry = getEntry(s);
-                if (entry == null) {
-                    return false;
-                }
-                entry.clear();
-                return true;
-            }
-
-            public void clear() {
-                HeaderMap.this.clear();
-            }
-
-            public Iterator<HttpString> iterator() {
-                final Iterator<HeaderValues> iterator = HeaderMap.this.iterator();
-                return new Iterator<HttpString>() {
-                    public boolean hasNext() {
-                        return iterator.hasNext();
-                    }
-
-                    public HttpString next() {
-                        return iterator.next().getHeaderName();
-                    }
-
-                    public void remove() {
-                        iterator.remove();
-                    }
-                };
-            }
-
-            public int size() {
-                return HeaderMap.this.size();
-            }
-        };
+        return headers.names().stream().map(HttpString::new).collect(Collectors.toCollection(HashSet::new));
     }
 
     // add
@@ -697,19 +190,13 @@ public HeaderMap addFirst(final HttpString headerName, final String headerValue)
         if (headerValue == null) {
             return this;
         }
-        getOrCreateEntry(headerName).addFirst(headerValue);
+        //todo: order does not matter for headers
+        headers.add(headerName.toString(), headerValue);
         return this;
     }
 
     public HeaderMap addLast(final HttpString headerName, final String headerValue) {
-        if (headerName == null) {
-            throw new IllegalArgumentException(""headerName is null"");
-        }
-        if (headerValue == null) {
-            return this;
-        }
-        getOrCreateEntry(headerName).addLast(headerValue);
-        return this;
+        return add(headerName, headerValue);
     }
 
     public HeaderMap add(HttpString headerName, long headerValue) {
@@ -725,7 +212,7 @@ public HeaderMap addAll(HttpString headerName, Collection<String> headerValues)
         if (headerValues == null || headerValues.isEmpty()) {
             return this;
         }
-        getOrCreateEntry(headerName).addAll(headerValues);
+        headers.add(headerName.toString(), headerValues);
         return this;
     }
 
@@ -739,19 +226,15 @@ public HeaderMap put(HttpString headerName, String headerValue) {
             remove(headerName);
             return this;
         }
-        final HeaderValues headerValues = getOrCreateEntry(headerName);
-        headerValues.clear();
-        headerValues.add(headerValue);
+        headers.set(headerName.toString(), headerValue);
         return this;
     }
 
     public HeaderMap put(HttpString headerName, long headerValue) {
         if (headerName == null) {
             throw new IllegalArgumentException(""headerName is null"");
         }
-        final HeaderValues entry = getOrCreateEntry(headerName);
-        entry.clear();
-        entry.add(Long.toString(headerValue));
+        headers.set(headerName.toString(), Long.toString(headerValue));
         return this;
     }
 
@@ -763,17 +246,14 @@ public HeaderMap putAll(HttpString headerName, Collection<String> headerValues)
             remove(headerName);
             return this;
         }
-        final HeaderValues entry = getOrCreateEntry(headerName);
-        entry.clear();
-        entry.addAll(headerValues);
+        headers.set(headerName.toString(), headerValues);
         return this;
     }
 
     // clear
 
     public HeaderMap clear() {
-        Arrays.fill(table, null);
-        size = 0;
+        headers.clear();
         return this;
     }
 
@@ -791,46 +271,19 @@ public Collection<String> remove(String headerName) {
         if (headerName == null) {
             return Collections.emptyList();
         }
-        final Collection<String> values = removeEntry(headerName);
-        return values != null ? values : Collections.<String>emptyList();
+        List<String> res = headers.getAll(headerName);
+        headers.remove(headerName);
+        return res;
     }
 
     // contains
 
     public boolean contains(HttpString headerName) {
-        final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
-            return false;
-        }
-        final Object v = headerValues.value;
-        if (v instanceof String) {
-            return true;
-        }
-        final String[] list = (String[]) v;
-        for (int i = 0; i < list.length; i++) {
-            if (list[i] != null) {
-                return true;
-            }
-        }
-        return false;
+        return headers.contains(headerName.toString());
     }
 
     public boolean contains(String headerName) {
-        final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
-            return false;
-        }
-        final Object v = headerValues.value;
-        if (v instanceof String) {
-            return true;
-        }
-        final String[] list = (String[]) v;
-        for (int i = 0; i < list.length; i++) {
-            if (list[i] != null) {
-                return true;
-            }
-        }
-        return false;
+        return headers.contains(headerName);
     }
 
     // compare
@@ -849,17 +302,17 @@ public int hashCode() {
     public String toString() {
         StringBuilder sb = new StringBuilder(""{"");
         boolean first = true;
-        for(HttpString name : getHeaderNames()) {
-            if(first) {
+        for (HttpString name : getHeaderNames()) {
+            if (first) {
                 first = false;
             } else {
                 sb.append("", "");
             }
             sb.append(name);
             sb.append(""=["");
             boolean f = true;
-            for(String val : get(name)) {
-                if(f) {
+            for (String val : get(name)) {
+                if (f) {
                     f = false;
                 } else {
                     sb.append("", "");",2019-04-02T22:55:44Z,48
"@@ -19,6 +19,7 @@
 package io.undertow.util;
 
 import java.util.AbstractCollection;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
@@ -28,60 +29,41 @@
 import java.util.NoSuchElementException;
 import java.util.RandomAccess;
 
+import io.netty.handler.codec.http.HttpHeaders;
+
 /**
  * An array-backed list/deque for header string values.
  *
  * @author <a href=""mailto:david.lloyd@redhat.com"">David M. Lloyd</a>
  */
+@Deprecated
 public final class HeaderValues extends AbstractCollection<String> implements Deque<String>, List<String>, RandomAccess {
 
-    private static final String[] NO_STRINGS = new String[0];
-    final HttpString key;
-    byte size;
-    Object value;
+    final HttpHeaders headers;
+    final String headerName;
+    final List<String> currentValues;
 
-    HeaderValues(final HttpString key) {
-        this.key = key;
+    public HeaderValues(HttpHeaders headers, String headerName, List<String> currentValues) {
+        this.headers = headers;
+        this.headerName = headerName;
+        this.currentValues = new ArrayList<>(currentValues);
     }
 
     public HttpString getHeaderName() {
-        return key;
+        return new HttpString(headerName);
     }
 
     public int size() {
-        return size;
+        return currentValues.size();
     }
 
     public boolean isEmpty() {
-        return size == 0;
+        return currentValues.size() == 0;
     }
 
     public void clear() {
-        final byte size = this.size;
-        if (size == 0) return;
-        clearInternal();
-    }
-
-    private void clearInternal() {
-        final Object value = this.value;
-        if (value instanceof String[]) {
-            final String[] strings = (String[]) value;
-            final int len = strings.length;
-            Arrays.fill(strings, 0, len, null);
-        } else {
-            this.value = null;
-        }
-        this.size = 0;
-    }
-
-    private int index(int idx) {
-        assert idx >= 0;
-        assert idx < size;
-        final int len = ((String[]) value).length;
-        if (idx > len) {
-            idx -= len;
-        }
-        return idx;
+        currentValues.clear();
+        headers.remove(headerName);
     }
 
     public ListIterator<String> listIterator() {
@@ -106,7 +88,7 @@ private ListIterator<String> iterator(final int start, final boolean forwards) {
             int returned = -1;
 
             public boolean hasNext() {
-                return idx < size;
+                return idx < size();
             }
 
             public boolean hasPrevious() {
@@ -189,276 +171,77 @@ public void add(final String headerValue) {
     }
 
     public boolean offerFirst(final String headerValue) {
-        int size = this.size;
-        if (headerValue == null || size == Byte.MAX_VALUE) return false;
-        final Object value = this.value;
-        if (value instanceof String[]) {
-            final String[] strings = (String[]) value;
-            final int len = strings.length;
-            if (size == len) {
-                final String[] newStrings = new String[len + 2];
-                System.arraycopy(strings, 0, newStrings, 1, len);
-                newStrings[0] = headerValue;
-                this.value = newStrings;
-            } else {
-                System.arraycopy(strings, 0, strings, 1, strings.length - 1);
-                strings[0] = headerValue;
-            }
-            this.size = (byte) (size + 1);
-        } else {
-            if (size == 0) {
-                this.value = headerValue;
-                this.size = (byte) 1;
-            } else {
-                this.value = new String[] { headerValue, (String) value, null, null };
-                this.size = (byte) 2;
-            }
-        }
+        currentValues.add(0, headerValue);
+        update();
         return true;
     }
 
     public boolean offerLast(final String headerValue) {
-        int size = this.size;
-        if (headerValue == null || size == Byte.MAX_VALUE) return false;
-        final Object value = this.value;
-        if (value instanceof String[]) {
-            offerLastMultiValue(headerValue, size, (String[]) value);
-        } else {
-            if (size == 0) {
-                this.value = headerValue;
-                this.size = (byte) 1;
-            } else {
-                this.value = new String[] { (String) value, headerValue, null, null };
-                this.size = (byte) 2;
-            }
-        }
-        return true;
-    }
-
-    private void offerLastMultiValue(String headerValue, int size, String[] value) {
-        final String[] strings = value;
-        final int len = strings.length;
-        if (size == len) {
-            final String[] newStrings = new String[len + 2];
-            System.arraycopy(strings, 0, newStrings, 0, len);
-            newStrings[len] = headerValue;
-            this.value = newStrings;
-        } else {
-            strings[size] = headerValue;
-        }
-        this.size = (byte) (size + 1);
-    }
-
-    private boolean offer(int idx, final String headerValue) {
-        int size = this.size;
-        if (idx < 0 || idx > size || size == Byte.MAX_VALUE || headerValue == null) return false;
-        if (idx == 0) return offerFirst(headerValue);
-        if (idx == size) return offerLast(headerValue);
-        assert size >= 2; // must be >= 2 to pass the last two checks
-        final Object value = this.value;
-        assert value instanceof String[];
-        final String[] strings = (String[]) value;
-        final int len = strings.length;
-        // This stuff is all algebraically derived.
-        if (size == len) {
-            // Grow the list, copy each segment into new spots so that head = 0
-            final int newLen = len + 2;
-            final String[] newStrings = new String[newLen];
-            System.arraycopy(value, 0, newStrings, 0, idx);
-            System.arraycopy(value, idx, newStrings, idx + 1, len - idx);
-
-            // finally fill in the new value
-            newStrings[idx] = headerValue;
-            this.value = newStrings;
-        } else{
-            System.arraycopy(value, idx, value, idx + 1, len - idx);
-
-            // finally fill in the new value
-            strings[idx] = headerValue;
-        }
-        this.size = (byte) (size + 1);
+        currentValues.add(headerValue);
+        update();
         return true;
     }
 
     public String pollFirst() {
-        final byte size = this.size;
-        if (size == 0) return null;
-
-        final Object value = this.value;
-        if (value instanceof String) {
-            this.size = 0;
-            this.value = null;
-            return (String) value;
-        } else {
-            final String[] strings = (String[]) value;
-            String ret = strings[0];
-            System.arraycopy(strings, 1, strings, 0, strings.length - 1);
-            this.size = (byte) (size - 1);
-            return ret;
+        if(currentValues.isEmpty()) {
+            return null;
         }
+        return currentValues.remove(0);
     }
 
     public String pollLast() {
-        final byte size = this.size;
-        if (size == 0) return null;
-
-        final Object value = this.value;
-        if (value instanceof String) {
-            this.size = 0;
-            this.value = null;
-            return (String) value;
-        } else {
-            final String[] strings = (String[]) value;
-            int idx = (this.size = (byte) (size - 1));
-            final int len = strings.length;
-            if (idx > len) idx -= len;
-            try {
-                return strings[idx];
-            } finally {
-                strings[idx] = null;
-            }
+        if(currentValues.isEmpty()) {
+            return null;
         }
+        return currentValues.remove(currentValues.size() - 1);
     }
 
     public String remove(int idx) {
-        final int size = this.size;
-        if (idx < 0 || idx >= size) throw new IndexOutOfBoundsException();
-        if (idx == 0) return removeFirst();
-        if (idx == size - 1) return removeLast();
-        assert size > 2; // must be > 2 to pass the last two checks
-        // value must be an array since size > 2
-        final String[] value = (String[]) this.value;
-        final int len = value.length;
-        String ret = value[idx];
-        System.arraycopy(value, idx + 1, value, idx, len - idx - 1);
-        value[len - 1] = null;
-        this.size = (byte) (size - 1);
-        return ret;
+        String res = currentValues.remove(idx);
+        update();
+        return res;
     }
 
     public String get(int idx) {
-        if (idx > size) {
-            throw new IndexOutOfBoundsException();
-        }
-        Object value = this.value;
-        assert value != null;
-        if (value instanceof String) {
-            assert size == 1;
-            return (String) value;
-        }
-        final String[] a = (String[]) value;
-        return a[index(idx)];
+        return currentValues.get(idx);
     }
 
     public int indexOf(final Object o) {
-        if (o == null || size == 0) return -1;
-        if (value instanceof String[]) {
-            final String[] list = (String[]) value;
-            final int len = list.length;
-            for (int i = 0; i < size; i ++) {
-                if ((i > len ? list[i - len] : list[i]).equals(o)) {
-                    return i;
-                }
-            }
-        } else if (o.equals(value)) {
-            return 0;
-        }
-        return -1;
+        return currentValues.indexOf(o);
     }
 
     public int lastIndexOf(final Object o) {
-        if (o == null || size == 0) return -1;
-        if (value instanceof String[]) {
-            final String[] list = (String[]) value;
-            final int len = list.length;
-            int idx;
-            for (int i = size - 1; i >= 0; i --) {
-                idx = i;
-                if ((idx > len ? list[idx - len] : list[idx]).equals(o)) {
-                    return i;
-                }
-            }
-        } else if (o.equals(value)) {
-            return 0;
-        }
-        return -1;
+        return currentValues.lastIndexOf(o);
     }
 
     public String set(final int index, final String element) {
-        if (element == null) throw new IllegalArgumentException();
-
-        final byte size = this.size;
-        if (index < 0 || index >= size) throw new IndexOutOfBoundsException();
-
-        final Object value = this.value;
-        if (size == 1 && value instanceof String) try {
-            return (String) value;
-        } finally {
-            this.value = element;
-        } else {
-            final String[] list = (String[]) value;
-            final int i = index(index);
-            try {
-                return list[i];
-            } finally {
-                list[i] = element;
-            }
-        }
+        String ret = currentValues.set(index, element);
+        update();
+        return ret;
+    }
+
+    private void update() {
+        headers.set(headerName, currentValues);
     }
 
     public boolean addAll(int index, final Collection<? extends String> c) {
-        final int size = this.size;
-        if (index < 0 || index > size) throw new IndexOutOfBoundsException();
-        final Iterator<? extends String> iterator = c.iterator();
-        boolean result = false;
-        while (iterator.hasNext()) {
-            result |= offer(index, iterator.next());
-        }
+        boolean result = currentValues.addAll(index, c);
+        update();
         return result;
     }
 
     public List<String> subList(final int fromIndex, final int toIndex) {
-        // todo - this is about 75% correct, by spec...
-        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) throw new IndexOutOfBoundsException();
-        final int len = toIndex - fromIndex;
-        final String[] strings = new String[len];
-        for (int i = 0; i < len; i ++) {
-            strings[i] = get(i + fromIndex);
-        }
-        return Arrays.asList(strings);
+        List<String> result = currentValues.subList(fromIndex, toIndex);
+        update();
+        return result;
     }
 
     public String[] toArray() {
-        int size = this.size;
-        if (size == 0) {
-            return NO_STRINGS;
-        }
-        final Object v = this.value;
-        if (v instanceof String) return new String[] { (String) v };
-        final String[] list = (String[]) v;
-        final int len = list.length;
-        final int copyEnd =  size;
-        if (copyEnd < len) {
-            return Arrays.copyOfRange(list, 0, copyEnd);
-        } else {
-            String[] ret = Arrays.copyOfRange(list, 0, copyEnd);
-            System.arraycopy(list, 0, ret, len, copyEnd - len);
-            return ret;
-        }
+        return (String[]) currentValues.toArray();
     }
 
     public <T> T[] toArray(final T[] a) {
-        int size = this.size;
-        if (size == 0) return a;
-        final int inLen = a.length;
-        final Object[] target = inLen < size ? Arrays.copyOfRange(a, inLen, inLen + size) : a;
-        final Object v = this.value;
-        if (v instanceof String) {
-            target[0] = v;
-        } else {
-            System.arraycopy(v, 0, target, 0, size);
-        }
-        return (T[]) target;
+        return currentValues.toArray(a);
     }
 
     //======================================
@@ -478,20 +261,20 @@ public void addLast(final String s) {
     }
 
     public void add(final int index, final String s) {
-        if (s == null) return;
-        if (! offer(index, s)) throw new IllegalStateException();
+        currentValues.add(index, s);
+        update();
     }
 
     public boolean contains(final Object o) {
         return indexOf(o) != -1;
     }
 
     public String peekFirst() {
-        return size == 0 ? null : get(0);
+        return currentValues.size() == 0 ? null : get(0);
     }
 
     public String peekLast() {
-        return size == 0 ? null : get(size - 1);
+        return size() == 0 ? null : get(size() - 1);
     }
 
     public boolean removeFirstOccurrence(final Object o) {",2019-04-02T22:55:44Z,347
"@@ -26,6 +26,7 @@
 
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowMessages;
+
 import org.xnio.FileChangeCallback;
 import org.xnio.FileChangeEvent;
 import org.xnio.FileSystemWatcher;
@@ -91,8 +92,17 @@ public Resource getResource(final String p) {
                 //security check for case insensitive file systems
                 //we make sure the case of the filename matches the case of the request
                 //TODO: we should be able to avoid this if we can tell a FS is case sensitive
-                if (file.getCanonicalFile().getName().equals(file.getName())) {
+                //this is only a check for case sensitivity, not for . and ../ which are allowed
+                String canonical = file.getCanonicalFile().getName();
+                if (canonical.equals(file.getName())) {
                     return new FileResource(file, this, path);
+                } else {
+                    //ok, so there may be a caase sensitivity issue here, or it could be caused
+                    //by a non-canonical representation, i.e. ../ or .
+                    //so we test to see if it is a case sensitvity issue
+                    if(!canonical.equalsIgnoreCase(file.getName())) {
+                        return new FileResource(file, this, path);
+                    }
                 }
             }
             return null;",2014-06-26T16:19:37Z,116
"@@ -44,7 +44,7 @@ public class FileHandlerIndexTestCase {
 
 
     @Test
-    public void testFileIsServed() throws IOException, URISyntaxException {
+    public void testWelcomeFile() throws IOException, URISyntaxException {
         TestHttpClient client = new TestHttpClient();
         File rootPath = new File(getClass().getResource(""page.html"").toURI()).getParentFile();
         try {
@@ -68,4 +68,34 @@ public void testFileIsServed() throws IOException, URISyntaxException {
         }
     }
 
+    @Test
+    public void testDirectoryIndex() throws IOException, URISyntaxException {
+        TestHttpClient client = new TestHttpClient();
+        File rootPath = new File(getClass().getResource(""page.html"").toURI()).getParentFile();
+        try {
+            DefaultServer.setRootHandler(new PathHandler()
+                            .addPrefixPath(""/path"", new ResourceHandler()
+                                    .setResourceManager(new FileResourceManager(rootPath, 10485760))
+                                    .setDirectoryListingEnabled(true)));
+
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            String response = HttpClientUtils.readResponse(result);
+            Header[] headers = result.getHeaders(""Content-Type"");
+            Assert.assertEquals(""text/html"", headers[0].getValue());
+            Assert.assertTrue(response, response.contains(""page.html""));
+
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path/."");
+            result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            response = HttpClientUtils.readResponse(result);
+            headers = result.getHeaders(""Content-Type"");
+            Assert.assertEquals(""text/html"", headers[0].getValue());
+            Assert.assertTrue(response, response.contains(""page.html""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
 }",2014-06-26T16:19:37Z,126
"@@ -67,7 +67,7 @@ public void awaitClose(long timeout) {
             waiterCount++;
             long end = System.currentTimeMillis() + timeout;
             try {
-                while (System.currentTimeMillis() < end) {
+                while (System.currentTimeMillis() < end && !openSessions.isEmpty()) {
                     wait(end - System.currentTimeMillis());
                 }
             } catch (InterruptedException e) {",2019-02-14T02:45:33Z,320
"@@ -26,9 +26,7 @@
 
 import java.util.Queue;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-
-import static org.xnio.Bits.longBitMask;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 /**
  * Represents a limit on a number of running requests.
@@ -47,12 +45,11 @@
  */
 public class RequestLimit {
     @SuppressWarnings(""unused"")
-    private volatile long state;
+    private volatile int requests;
+    private volatile int max;
 
-    private static final AtomicLongFieldUpdater<RequestLimit> stateUpdater = AtomicLongFieldUpdater.newUpdater(RequestLimit.class, ""state"");
+    private static final AtomicIntegerFieldUpdater<RequestLimit> requestsUpdater = AtomicIntegerFieldUpdater.newUpdater(RequestLimit.class, ""requests"");
 
-    private static final long MASK_MAX = longBitMask(32, 63);
-    private static final long MASK_CURRENT = longBitMask(0, 30);
 
     /**
      * The handler that will be invoked if the queue is full.
@@ -66,12 +63,14 @@ public class RequestLimit {
         @Override
         public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
             try {
-                final SuspendedRequest task = queue.poll();
-                if (task != null) {
-                    task.exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
-                    task.exchange.dispatch(task.next);
-                } else {
-                    decrementRequests();
+                synchronized (RequestLimit.this) {
+                    final SuspendedRequest task = queue.poll();
+                    if (task != null) {
+                        task.exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
+                        task.exchange.dispatch(task.next);
+                    } else {
+                        decrementRequests();
+                    }
                 }
             } finally {
                 nextListener.proceed();
@@ -94,30 +93,42 @@ public RequestLimit(int maximumConcurrentRequests, int queueSize) {
         if (maximumConcurrentRequests < 1) {
             throw new IllegalArgumentException(""Maximum concurrent requests must be at least 1"");
         }
-        state = (maximumConcurrentRequests & 0xFFFFFFFFL) << 32;
+        max = maximumConcurrentRequests;
 
         this.queue = new LinkedBlockingQueue<>(queueSize <= 0 ? Integer.MAX_VALUE : queueSize);
     }
 
     public void handleRequest(final HttpServerExchange exchange, final HttpHandler next) throws Exception {
-        long oldVal, newVal;
+        int oldVal, newVal;
         do {
-            oldVal = state;
-            final long current = oldVal & MASK_CURRENT;
-            final long max = (oldVal & MASK_MAX) >> 32L;
-            if (current >= max) {
+            oldVal = requests;
+            if (oldVal >= max) {
                 exchange.dispatch(SameThreadExecutor.INSTANCE, new Runnable() {
                     @Override
                     public void run() {
-                        if (!queue.offer(new SuspendedRequest(exchange, next))) {
-                            Connectors.executeRootHandler(failureHandler, exchange);
+                        //we have to try again in the sync block
+                        //we need to have already dispatched for thread safety reasons
+                        synchronized (RequestLimit.this) {
+                            int oldVal, newVal;
+                            do {
+                                oldVal = requests;
+                                if (oldVal >= max) {
+                                    if (!queue.offer(new SuspendedRequest(exchange, next))) {
+                                        Connectors.executeRootHandler(failureHandler, exchange);
+                                    }
+                                    return;
+                                }
+                                newVal = oldVal + 1;
+                            } while (!requestsUpdater.compareAndSet(RequestLimit.this, oldVal, newVal));
+                            exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
+                            exchange.dispatch(next);
                         }
                     }
                 });
                 return;
             }
             newVal = oldVal + 1;
-        } while (!stateUpdater.compareAndSet(this, oldVal, newVal));
+        } while (!requestsUpdater.compareAndSet(this, oldVal, newVal));
         exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
         next.handleRequest(exchange);
     }
@@ -128,7 +139,7 @@ public void run() {
      * @return the maximum concurrent requests
      */
     public int getMaximumConcurrentRequests() {
-        return (int) (state >> 32L);
+        return max;
     }
 
     /**
@@ -140,29 +151,29 @@ public int setMaximumConcurrentRequests(int newMax) {
         if (newMax < 1) {
             throw new IllegalArgumentException(""Maximum concurrent requests must be at least 1"");
         }
-        long oldVal, newVal;
-        int current, oldMax;
-        do {
-            oldVal = state;
-            current = (int) (oldVal & MASK_CURRENT);
-            oldMax = (int) ((oldVal & MASK_MAX) >> 32L);
-            newVal = current | newMax & 0xFFFFFFFFL << 32L;
-        } while (!stateUpdater.compareAndSet(this, oldVal, newVal));
-        while (current < newMax) {
-            // more space opened up!  Process queue entries for a while
-            final SuspendedRequest request = queue.poll();
-            if (request != null) {
-                // now bump up the counter by one; this *could* put us over the max if it changed in the meantime but that's OK
-                newVal = stateUpdater.getAndIncrement(this);
-                current = (int) (newVal & MASK_CURRENT);
-                request.exchange.dispatch(request.next);
+        int oldMax = this.max;
+        this.max = newMax;
+        if(newMax > oldMax) {
+            synchronized (this) {
+                while (!queue.isEmpty()) {
+                    int oldVal, newVal;
+                    do {
+                        oldVal = requests;
+                        if (oldVal >= max) {
+                            return oldMax;
+                        }
+                        newVal = oldVal + 1;
+                    } while (!requestsUpdater.compareAndSet(this, oldVal, newVal));
+                    SuspendedRequest res = queue.poll();
+                    res.exchange.dispatch(res.next);
+                }
             }
         }
         return oldMax;
     }
 
     private void decrementRequests() {
-        stateUpdater.decrementAndGet(this);
+        requestsUpdater.decrementAndGet(this);
     }
 
     public HttpHandler getFailureHandler() {",2016-08-30T03:54:53Z,341
"@@ -199,7 +199,7 @@ private static SSLContext createSSLContext(final KeyStore keyStore, final KeySto
             if (openssl && !client) {
                 sslContext = SSLContext.getInstance(""openssl.TLS"");
             } else {
-                sslContext = SSLContext.getInstance(""TLS"");
+                sslContext = SSLContext.getInstance(""TLSv1.2"");
             }
             sslContext.init(keyManagers, trustManagers, null);
         } catch (NoSuchAlgorithmException | KeyManagementException e) {",2018-10-06T01:26:12Z,76
"@@ -29,6 +29,7 @@
 import io.undertow.conduits.ChunkedStreamSourceConduit;
 import io.undertow.conduits.ConduitListener;
 import io.undertow.conduits.FixedLengthStreamSourceConduit;
+import io.undertow.server.protocol.http.HttpContinue;
 import io.undertow.util.AbstractAttachable;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
@@ -99,6 +100,7 @@ public void handleEvent(StreamSourceConduit channel) {
     private final ClientReadListener clientReadListener = new ClientReadListener();
 
     private final Pool<ByteBuffer> bufferPool;
+    private Pooled<ByteBuffer> pooledBuffer;
     private final StreamSinkConduit originalSinkConduit;
 
     private static final int UPGRADED = 1 << 28;
@@ -124,6 +126,11 @@ public void handleEvent(StreamSourceConduit channel) {
             public void handleEvent(StreamConnection channel) {
                 HttpClientConnection.this.state |= CLOSED;
                 ChannelListeners.invokeChannelListener(HttpClientConnection.this, closeSetter.get());
+                try {
+                    if (pooledBuffer != null) {
+                        pooledBuffer.free();
+                    }
+                } catch (Throwable ignored){}
             }
         });
     }
@@ -444,6 +451,11 @@ public void handleEvent(StreamSourceChannel channel) {
                     channel.suspendReads();
                     pendingResponse = null;
                     currentRequest.setResponse(response);
+                    if(response.getResponseCode() == StatusCodes.EXPECTATION_FAILED) {
+                        if(HttpContinue.requiresContinueResponse(currentRequest.getRequest().getRequestHeaders())) {
+                            HttpClientConnection.this.state |= CLOSE_REQ;
+                        }
+                    }
                 }
 
 
@@ -452,7 +464,12 @@ public void handleEvent(StreamSourceChannel channel) {
                 safeClose(connection);
                 currentRequest.setFailed(new IOException(e));
             } finally {
-                if (free) pooled.free();
+                if (free) {
+                    pooled.free();
+                    pooledBuffer = null;
+                } else {
+                    pooledBuffer = pooled;
+                }
             }
 
 ",2014-11-28T02:35:20Z,229
"@@ -29,6 +29,8 @@
 import java.util.List;
 import java.util.Set;
 import javax.net.ssl.SSLEngine;
+
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import org.eclipse.jetty.alpn.ALPN;
 import org.xnio.ChannelListener;
 import org.xnio.IoFuture;
@@ -40,7 +42,6 @@
 import org.xnio.XnioWorker;
 import org.xnio.channels.StreamSourceChannel;
 import org.xnio.conduits.PushBackStreamSourceConduit;
-import org.xnio.ssl.JsseXnioSsl;
 import org.xnio.ssl.SslConnection;
 import org.xnio.ssl.XnioSsl;
 
@@ -173,11 +174,11 @@ public static boolean isEnabled() {
     public static void handlePotentialHttp2Connection(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final ChannelListener<SslConnection> http2FailedListener) {
 
         final SslConnection sslConnection = (SslConnection) connection;
-        final SSLEngine sslEngine = JsseXnioSsl.getSslEngine(sslConnection);
+        final SSLEngine sslEngine = UndertowXnioSsl.getSslEngine(sslConnection);
 
-        final SpdySelectionProvider spdySelectionProvider = new SpdySelectionProvider(sslEngine);
+        final Http2SelectionProvider http2SelectionProvider = new Http2SelectionProvider(sslEngine);
         try {
-            ALPN_PUT_METHOD.invoke(null, sslEngine, spdySelectionProvider);
+            ALPN_PUT_METHOD.invoke(null, sslEngine, http2SelectionProvider);
         } catch (Exception e) {
             http2FailedListener.handleEvent(sslConnection);
             return;
@@ -189,12 +190,12 @@ public static void handlePotentialHttp2Connection(final StreamConnection connect
                 @Override
                 public void handleEvent(StreamSourceChannel channel) {
 
-                    if (spdySelectionProvider.selected != null) {
-                        if (spdySelectionProvider.selected.equals(HTTP_1_1)) {
+                    if (http2SelectionProvider.selected != null) {
+                        if (http2SelectionProvider.selected.equals(HTTP_1_1)) {
                             sslConnection.getSourceChannel().suspendReads();
                             http2FailedListener.handleEvent(sslConnection);
                             return;
-                        } else if (spdySelectionProvider.selected.equals(HTTP2)) {
+                        } else if (http2SelectionProvider.selected.equals(HTTP2)) {
                             listener.completed(createHttp2Channel(connection, bufferPool, options));
                         }
                     } else {
@@ -206,16 +207,16 @@ public void handleEvent(StreamSourceChannel channel) {
                                 pb.pushBack(new ImmediatePooled<>(buf));
                                 connection.getSourceChannel().setConduit(pb);
                             }
-                            if (spdySelectionProvider.selected == null) {
-                                spdySelectionProvider.selected = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
+                            if (http2SelectionProvider.selected == null) {
+                                http2SelectionProvider.selected = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
                             }
-                            if ((spdySelectionProvider.selected == null && read > 0) || HTTP_1_1.equals(spdySelectionProvider.selected)) {
+                            if ((http2SelectionProvider.selected == null && read > 0) || HTTP_1_1.equals(http2SelectionProvider.selected)) {
                                 sslConnection.getSourceChannel().suspendReads();
                                 http2FailedListener.handleEvent(sslConnection);
                                 return;
-                            } else if (spdySelectionProvider.selected != null) {
+                            } else if (http2SelectionProvider.selected != null) {
                                 //we have spdy
-                                if (spdySelectionProvider.selected.equals(HTTP2)) {
+                                if (http2SelectionProvider.selected.equals(HTTP2)) {
                                     listener.completed(createHttp2Channel(connection, bufferPool, options));
                                 }
                             }
@@ -241,11 +242,11 @@ private static Http2ClientConnection createHttp2Channel(StreamConnection connect
         return new Http2ClientConnection(http2Channel, false);
     }
 
-    private static class SpdySelectionProvider implements ALPN.ClientProvider {
+    private static class Http2SelectionProvider implements ALPN.ClientProvider {
         private String selected;
         private final SSLEngine sslEngine;
 
-        private SpdySelectionProvider(SSLEngine sslEngine) {
+        private Http2SelectionProvider(SSLEngine sslEngine) {
             this.sslEngine = sslEngine;
         }
 ",2014-11-28T02:35:20Z,230
"@@ -29,6 +29,8 @@
 import java.util.List;
 import java.util.Set;
 import javax.net.ssl.SSLEngine;
+
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import org.eclipse.jetty.alpn.ALPN;
 import org.xnio.BufferAllocator;
 import org.xnio.ByteBufferSlicePool;
@@ -42,7 +44,6 @@
 import org.xnio.XnioWorker;
 import org.xnio.channels.StreamSourceChannel;
 import org.xnio.conduits.PushBackStreamSourceConduit;
-import org.xnio.ssl.JsseXnioSsl;
 import org.xnio.ssl.SslConnection;
 import org.xnio.ssl.XnioSsl;
 
@@ -201,7 +202,7 @@ public static boolean isEnabled() {
     public static void handlePotentialSpdyConnection(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final ChannelListener<SslConnection> spdyFailedListener) {
 
         final SslConnection sslConnection = (SslConnection) connection;
-        final SSLEngine sslEngine = JsseXnioSsl.getSslEngine(sslConnection);
+        final SSLEngine sslEngine = UndertowXnioSsl.getSslEngine(sslConnection);
 
         final SpdySelectionProvider spdySelectionProvider = new SpdySelectionProvider(sslEngine);
         try {",2014-11-28T02:35:20Z,231
"@@ -262,6 +262,15 @@ public void terminateWrites() throws IOException {
 
     }
 
+    @Override
+    public void truncateWrites() throws IOException {
+        if (!anyAreSet(state, FLAG_FINISHED_CALLED)) {
+            state |= FLAG_FINISHED_CALLED;
+            channelFinished();
+        }
+        super.truncateWrites();
+    }
+
     public void awaitWritable() throws IOException {
         next.awaitWritable();
     }",2014-11-28T02:35:20Z,96
"@@ -140,6 +140,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     private boolean thisGoneAway = false;
     private boolean peerGoneAway = false;
+    private boolean lastDataRead = false;
 
     private int streamIdCounter;
     private int lastGoodStreamId;
@@ -348,6 +349,7 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
     }
 
     protected void lastDataRead() {
+        lastDataRead = true;
         if(!peerGoneAway && !thisGoneAway) {
             //the peer has performed an unclean close
             //if they have streams that are still expecting data then this is an error condition
@@ -368,7 +370,7 @@ public boolean isOpen() {
 
     @Override
     protected boolean isLastFrameReceived() {
-        return peerGoneAway;
+        return lastDataRead;
     }
 
     @Override",2014-11-28T02:35:20Z,166
"@@ -110,6 +110,7 @@ public class SpdyChannel extends AbstractFramedChannel<SpdyChannel, SpdyStreamSo
 
     private boolean thisGoneAway = false;
     private boolean peerGoneAway = false;
+    private boolean lastDataRead = false;
 
     private int streamIdCounter;
     private int lastGoodStreamId;
@@ -207,6 +208,7 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
     }
 
     protected void lastDataRead() {
+        lastDataRead = true;
         if(!peerGoneAway && !thisGoneAway) {
             //the peer has performed an unclean close
             //if they have streams that are still expecting data then this is an error condition
@@ -227,7 +229,7 @@ public boolean isOpen() {
 
     @Override
     protected boolean isLastFrameReceived() {
-        return peerGoneAway;
+        return lastDataRead;
     }
 
     @Override",2014-11-28T02:35:20Z,109
"@@ -0,0 +1,1040 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.protocols.ssl;
+
+import io.undertow.UndertowLogger;
+import org.xnio.Buffers;
+import org.xnio.ChannelListener;
+import org.xnio.ChannelListeners;
+import org.xnio.IoUtils;
+import org.xnio.Pool;
+import org.xnio.Pooled;
+import org.xnio.StreamConnection;
+import org.xnio.XnioIoThread;
+import org.xnio.XnioWorker;
+import org.xnio.channels.StreamSinkChannel;
+import org.xnio.channels.StreamSourceChannel;
+import org.xnio.conduits.ConduitReadableByteChannel;
+import org.xnio.conduits.ConduitStreamSinkChannel;
+import org.xnio.conduits.ConduitStreamSourceChannel;
+import org.xnio.conduits.ConduitWritableByteChannel;
+import org.xnio.conduits.Conduits;
+import org.xnio.conduits.ReadReadyHandler;
+import org.xnio.conduits.StreamSinkConduit;
+import org.xnio.conduits.StreamSourceConduit;
+import org.xnio.conduits.WriteReadyHandler;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.util.concurrent.TimeUnit;
+
+import static org.xnio.Bits.allAreClear;
+import static org.xnio.Bits.allAreSet;
+import static org.xnio.Bits.anyAreSet;
+
+/**
+ * @author Stuart Douglas
+ */
+class SslConduit implements StreamSourceConduit, StreamSinkConduit {
+
+    /**
+     * If this is set we are in the middle of a handshake, and we cannot
+     * read any more data until we have written out our wrap result
+     */
+    private static final int FLAG_READ_REQUIRES_WRITE = 1;
+    /**
+     * If this is set we are in the process of handshaking and we cannot write any
+     * more data until we have read unwrapped data from the remote peer
+     */
+    private static final int FLAG_WRITE_REQUIRES_READ = 1 << 1;
+    /**
+     * If reads are resumed. The underlying delegate may not be resumed if a write is required
+     * to make progress.
+     */
+    private static final int FLAG_READS_RESUMED = 1 << 2;
+    /**
+     * If writes are resumed, the underlying delegate may not be resumed if a read is required
+     */
+    private static final int FLAG_WRITES_RESUMED = 1 << 3;
+
+    /**
+     * If there is data in the {@link #dataToUnwrap} buffer, and the last unwrap attempt did not result
+     * in a buffer underflow
+     */
+    private static final int FLAG_DATA_TO_UNWRAP = 1 << 4;
+    /**
+     * If the user has shutdown reads
+     */
+    private static final int FLAG_READ_SHUTDOWN = 1 << 5;
+    /**
+     * If the user has shutdown writes
+     */
+    private static final int FLAG_WRITE_SHUTDOWN = 1 << 6;
+
+    /**
+     * If the engine has been shut down
+     */
+    private static final int FLAG_ENGINE_INBOUND_SHUTDOWN = 1 << 7;
+    /**
+     * If the engine has been shut down
+     */
+    private static final int FLAG_ENGINE_OUTBOUND_SHUTDOWN = 1 << 8;
+
+    private static final int FLAG_DELEGATE_SINK_SHUTDOWN = 1 << 9;
+
+    private static final int FLAG_DELEGATE_SOURCE_SHUTDOWN = 1 << 10;
+
+    private static final int FLAG_IN_HANDSHAKE = 1 << 11;
+    private static final int FLAG_CLOSED = 1 << 12;
+    private static final int FLAG_WRITE_CLOSED = 1 << 13;
+    private static final int FLAG_READ_CLOSED = 1 << 14;
+
+
+    private final UndertowSslConnection connection;
+    private final StreamConnection delegate;
+    private final SSLEngine engine;
+    private final StreamSinkConduit sink;
+    private final StreamSourceConduit source;
+    private final Pool<ByteBuffer> bufferPool;
+    private final Runnable handshakeCallback;
+
+    private int state = 0;
+
+    private int outstandingTasks = 0;
+
+    /**
+     * Data that has been wrapped and is ready to be sent to the underlying channel.
+     *
+     * This will be null if there is no data
+     */
+    private Pooled<ByteBuffer> wrappedData;
+    /**
+     * Data that has been read from the underlying channel, and needs to be unwrapped.
+     *
+     * This will be null if there is no data. If there is data the {@link #FLAG_DATA_TO_UNWRAP}
+     * flag must still be checked, otherwise there may be situations where even though some data
+     * has been read there is not enough to unwrap (i.e. the engine returned buffer underflow).
+     */
+    private Pooled<ByteBuffer> dataToUnwrap;
+
+    /**
+     * Unwrapped data, ready to be delivered to the application. Will be null if there is no data.
+     *
+     * If possible we avoid allocating this buffer, and instead unwrap directly into the end users buffer.
+     */
+    private Pooled<ByteBuffer> unwrappedData;
+
+    private SslWriteReadyHandler writeReadyHandler;
+    private SslReadReadyHandler readReadyHandler;
+
+
+    SslConduit(UndertowSslConnection connection, StreamConnection delegate, SSLEngine engine, Pool<ByteBuffer> bufferPool, Runnable handshakeCallback) {
+        this.connection = connection;
+        this.delegate = delegate;
+        this.handshakeCallback = handshakeCallback;
+        this.sink = delegate.getSinkChannel().getConduit();
+        this.source = delegate.getSourceChannel().getConduit();
+        this.engine = engine;
+        this.bufferPool = bufferPool;
+        delegate.getSourceChannel().getConduit().setReadReadyHandler(readReadyHandler = new SslReadReadyHandler(null));
+        delegate.getSinkChannel().getConduit().setWriteReadyHandler(writeReadyHandler = new SslWriteReadyHandler(null));
+        if(engine.getUseClientMode()) {
+            state = FLAG_IN_HANDSHAKE | FLAG_READ_REQUIRES_WRITE;
+        } else {
+            state = FLAG_IN_HANDSHAKE | FLAG_WRITE_REQUIRES_READ;
+        }
+    }
+
+    @Override
+    public void terminateReads() throws IOException {
+        state |= FLAG_READ_SHUTDOWN;
+        notifyReadClosed();
+    }
+
+    @Override
+    public boolean isReadShutdown() {
+        return anyAreSet(state, FLAG_READ_SHUTDOWN);
+    }
+
+    @Override
+    public void resumeReads() {
+        resumeReads(false);
+    }
+    @Override
+    public void suspendReads() {
+        state &= ~FLAG_READS_RESUMED;
+        if(!allAreSet(state, FLAG_WRITES_RESUMED | FLAG_WRITE_REQUIRES_READ)) {
+            delegate.getSourceChannel().suspendReads();
+        }
+    }
+
+    @Override
+    public void wakeupReads() {
+        resumeReads(true);
+    }
+
+    private  void resumeReads(boolean wakeup) {
+        state |= FLAG_READS_RESUMED;
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            delegate.getSinkChannel().resumeWrites();
+        } else {
+            delegate.getSourceChannel().resumeReads();
+            if(anyAreSet(state, FLAG_DATA_TO_UNWRAP) || wakeup) {
+                runReadListener(wakeup);
+            }
+        }
+    }
+
+
+    private void runReadListener(final boolean force) {
+        delegate.getIoThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                readReadyHandler.readReady(force);
+            }
+        });
+    }
+
+    @Override
+    public boolean isReadResumed() {
+        return anyAreSet(state, FLAG_READS_RESUMED);
+    }
+
+    @Override
+    public void awaitReadable() throws IOException {
+        synchronized (this) {
+            if(outstandingTasks > 0) {
+                try {
+                    wait();
+                    return;
+                } catch (InterruptedException e) {
+                    throw new InterruptedIOException();
+                }
+            }
+        }
+        if(unwrappedData != null) {
+            return;
+        }
+        if(anyAreSet(state, FLAG_DATA_TO_UNWRAP)) {
+            return;
+        }
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            awaitWritable();
+            return;
+        }
+        source.awaitReadable();
+    }
+
+    @Override
+    public void awaitReadable(long time, TimeUnit timeUnit) throws IOException {
+        synchronized (this) {
+            if(outstandingTasks > 0) {
+                try {
+                    wait(timeUnit.toMillis(time));
+                    return;
+                } catch (InterruptedException e) {
+                    throw new InterruptedIOException();
+                }
+            }
+        }
+        if(unwrappedData != null) {
+            return;
+        }
+        if(anyAreSet(state, FLAG_DATA_TO_UNWRAP)) {
+            return;
+        }
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            awaitWritable(time, timeUnit);
+            return;
+        }
+        source.awaitReadable(time, timeUnit);
+    }
+
+    @Override
+    public XnioIoThread getReadThread() {
+        return delegate.getIoThread();
+    }
+
+    @Override
+    public void setReadReadyHandler(ReadReadyHandler handler) {
+        delegate.getSourceChannel().getConduit().setReadReadyHandler(readReadyHandler = new SslReadReadyHandler(handler));
+    }
+
+    @Override
+    public long transferFrom(FileChannel src, long position, long count) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return src.transferTo(position, count, new ConduitWritableByteChannel(this));
+    }
+
+    @Override
+    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return IoUtils.transfer(source, count, throughBuffer, new ConduitWritableByteChannel(this));
+    }
+
+    @Override
+    public int write(ByteBuffer src) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return (int) doWrap(new ByteBuffer[]{src}, 0, 1);
+    }
+
+    @Override
+    public long write(ByteBuffer[] srcs, int offs, int len) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return doWrap(srcs, offs, len);
+    }
+
+    @Override
+    public int writeFinal(ByteBuffer src) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return Conduits.writeFinalBasic(this, src);
+    }
+
+    @Override
+    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {
+        return Conduits.writeFinalBasic(this, srcs, offset, length);
+    }
+
+    @Override
+    public void terminateWrites() throws IOException {
+        state |= FLAG_WRITE_SHUTDOWN;
+    }
+
+    @Override
+    public boolean isWriteShutdown() {
+        return false; //todo
+    }
+
+    @Override
+    public void resumeWrites() {
+        state |= FLAG_WRITES_RESUMED;
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            delegate.getSourceChannel().resumeReads();
+        } else {
+            delegate.getSinkChannel().resumeWrites();
+        }
+    }
+
+    @Override
+    public void suspendWrites() {
+        state &= ~FLAG_WRITES_RESUMED;
+        if(!allAreSet(state, FLAG_READS_RESUMED | FLAG_READ_REQUIRES_WRITE)) {
+            delegate.getSinkChannel().suspendWrites();
+        }
+    }
+
+    @Override
+    public void wakeupWrites() {
+        resumeWrites();
+        getWriteThread().execute(new Runnable() {
+            @Override
+            public void run() {
+                writeReadyHandler.writeReady();
+            }
+        });
+    }
+
+    @Override
+    public boolean isWriteResumed() {
+        return anyAreSet(state, FLAG_WRITES_RESUMED);
+    }
+
+    @Override
+    public void awaitWritable() throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            return;
+        }
+        if(outstandingTasks > 0) {
+            synchronized (this) {
+                if(outstandingTasks > 0) {
+                    try {
+                        this.wait();
+                        return;
+                    } catch (InterruptedException e) {
+                        throw new InterruptedIOException();
+                    }
+                }
+            }
+        }
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            awaitReadable();
+            return;
+        }
+        sink.awaitWritable();
+    }
+
+    @Override
+    public void awaitWritable(long time, TimeUnit timeUnit) throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            return;
+        }
+        if(outstandingTasks > 0) {
+            synchronized (this) {
+                if(outstandingTasks > 0) {
+                    try {
+                        this.wait(timeUnit.toMillis(time));
+                        return;
+                    } catch (InterruptedException e) {
+                        throw new InterruptedIOException();
+                    }
+                }
+            }
+        }
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            awaitReadable(time, timeUnit);
+            return;
+        }
+        sink.awaitWritable();
+    }
+
+    @Override
+    public XnioIoThread getWriteThread() {
+        return delegate.getIoThread();
+    }
+
+    @Override
+    public void setWriteReadyHandler(WriteReadyHandler handler) {
+        delegate.getSinkChannel().getConduit().setWriteReadyHandler(writeReadyHandler = new SslWriteReadyHandler(handler));
+    }
+
+    @Override
+    public void truncateWrites() throws IOException {
+        notifyWriteClosed();
+    }
+
+    @Override
+    public boolean flush() throws IOException {
+        if(anyAreSet(state, FLAG_DELEGATE_SINK_SHUTDOWN)) {
+            return sink.flush();
+        }
+        if(wrappedData != null) {
+            doWrap(null, 0, 0);
+            if(wrappedData != null) {
+                return false;
+            }
+        }
+        if(allAreSet(state, FLAG_WRITE_SHUTDOWN)) {
+            if(allAreClear(state, FLAG_ENGINE_OUTBOUND_SHUTDOWN)) {
+                state |= FLAG_ENGINE_OUTBOUND_SHUTDOWN;
+                engine.closeOutbound();
+                doWrap(null, 0, 0);
+                if(wrappedData != null) {
+                    return false;
+                }
+            } else if(wrappedData != null && allAreClear(state, FLAG_DELEGATE_SINK_SHUTDOWN)) {
+                doWrap(null, 0, 0);
+                if(wrappedData != null) {
+                    return false;
+                }
+            }
+            if(allAreClear(state, FLAG_DELEGATE_SINK_SHUTDOWN)) {
+                sink.terminateWrites();
+                state |= FLAG_DELEGATE_SINK_SHUTDOWN;
+            }
+        }
+        return sink.flush();
+    }
+
+    @Override
+    public long transferTo(long position, long count, FileChannel target) throws IOException {
+        if(anyAreSet(state, FLAG_READ_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return target.transferFrom(new ConduitReadableByteChannel(this), position, count);
+    }
+
+    @Override
+    public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel target) throws IOException {
+        if(anyAreSet(state, FLAG_READ_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return IoUtils.transfer(new ConduitReadableByteChannel(this), count, throughBuffer, target);
+    }
+
+    @Override
+    public int read(ByteBuffer dst) throws IOException {
+        if(anyAreSet(state, FLAG_READ_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return (int) doUnwrap(new ByteBuffer[]{dst}, 0, 1);
+    }
+
+    @Override
+    public long read(ByteBuffer[] dsts, int offs, int len) throws IOException {
+        if(anyAreSet(state, FLAG_READ_SHUTDOWN)) {
+            throw new ClosedChannelException();
+        }
+        return doUnwrap(dsts, offs, len);
+    }
+
+    @Override
+    public XnioWorker getWorker() {
+        return delegate.getWorker();
+    }
+
+    void notifyWriteClosed() {
+        if(anyAreSet(state, FLAG_WRITE_CLOSED)) {
+            return;
+        }
+        connection.writeClosed();
+        state |= FLAG_WRITE_CLOSED;
+        if(anyAreSet(state, FLAG_READ_CLOSED)) {
+            closed();
+        }
+    }
+
+    void notifyReadClosed() {
+        if(anyAreSet(state, FLAG_READ_CLOSED)) {
+            return;
+        }
+        connection.readClosed();
+
+        state |= FLAG_READ_CLOSED;
+        if(anyAreSet(state, FLAG_WRITE_CLOSED)) {
+            closed();
+        }
+    }
+
+    public void startHandshake() throws SSLException {
+        engine.beginHandshake();
+    }
+
+    public SSLSession getSslSession() {
+        return engine.getSession();
+    }
+
+
+    /**
+     * Force the handshake to continue
+     *
+     * @throws IOException
+     */
+    private void doHandshake() throws IOException {
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            doUnwrap(null, 0, 0);
+        }
+        doWrap(null, 0, 0);
+    }
+
+
+    /**
+     * Unwrap channel data into the user buffers. If no user buffer is supplied (e.g. during handshaking) then the
+     * unwrap will happen into the channels unwrap buffer.
+     *
+     * If some data has already been unwrapped it will simply be copied into the user buffers
+     * and no unwrap will actually take place.
+     *
+     * @return true if the unwrap operation made progress, false otherwise
+     * @throws SSLException
+     */
+    private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOException {
+        if(anyAreSet(state, FLAG_CLOSED)) {
+            throw new ClosedChannelException();
+        }
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            doWrap(null, 0, 0);
+            if(allAreClear(state, FLAG_WRITE_REQUIRES_READ)) { //unless a wrap is immediatly required we just return
+                return 0;
+            }
+        }
+
+        Pooled<ByteBuffer> unwrappedData = this.unwrappedData;
+        //copy any exiting data
+        if(unwrappedData != null && userBuffers != null) {
+            long copied = Buffers.copy(userBuffers, off, len, unwrappedData.getResource());
+            if(!unwrappedData.getResource().hasRemaining()) {
+                unwrappedData.free();
+                this.unwrappedData = null;
+            }
+            return copied;
+        }
+        try {
+            //try and read some data if we don't already have some
+            if(allAreClear(state, FLAG_DATA_TO_UNWRAP)) {
+                if(dataToUnwrap == null) {
+                    dataToUnwrap = bufferPool.allocate();
+                }
+                int res;
+                try {
+                    res = source.read(dataToUnwrap.getResource());
+                } catch (IOException e) {
+                    dataToUnwrap.free();
+                    dataToUnwrap = null;
+                    throw e;
+                }
+                dataToUnwrap.getResource().flip();
+                if(res == -1) {
+                    notifyReadClosed();
+                    return -1;
+                } else if(res == 0 && engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
+                    return 0;
+                }
+            }
+            long original = 0;
+            if(userBuffers != null) {
+                original = Buffers.remaining(userBuffers);
+            }
+            //perform the actual unwrap operation
+            //if possible this is done into the the user buffers, however
+            //if none are supplied or this results in a buffer overflow then we allocate our own
+            SSLEngineResult result;
+            if (userBuffers != null) {
+                result = engine.unwrap(dataToUnwrap.getResource(), userBuffers, off, len);
+                if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
+                    //not enough space in the user buffers
+                    //we use our own
+                    unwrappedData = bufferPool.allocate();
+                    ByteBuffer[] d = new ByteBuffer[len + 1];
+                    System.arraycopy(userBuffers, off, d, 0, len);
+                    d[len] = unwrappedData.getResource();
+                    result = engine.unwrap(dataToUnwrap.getResource(), d);
+                }
+            } else {
+                if (unwrappedData == null) {
+                    unwrappedData = bufferPool.allocate();
+                } else {
+                    unwrappedData.getResource().compact();
+                }
+                result = engine.unwrap(dataToUnwrap.getResource(), unwrappedData.getResource());
+            }
+
+
+            if (!handleHandshakeResult(result)) {
+                if(dataToUnwrap.getResource().hasRemaining()) {
+                    state |= FLAG_DATA_TO_UNWRAP;
+                }
+                return 0;
+            }
+            if (result.getStatus() == SSLEngineResult.Status.CLOSED) {
+                notifyReadClosed();
+                return -1;
+            }
+            if(result.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
+                state &= ~FLAG_DATA_TO_UNWRAP;
+            } else if(result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
+                throw new IOException(""overflow""); //todo: handle properly
+            } else if(dataToUnwrap.getResource().hasRemaining()) {
+                state |= FLAG_DATA_TO_UNWRAP;
+            }
+            if(userBuffers == null) {
+                return 0;
+            } else {
+                return original - Buffers.remaining(userBuffers);
+            }
+        } finally {
+            boolean requiresListenerInvocation = false; //if there is data in the buffer and reads are resumed we should re-run the listener
+            try {
+                if (unwrappedData != null && unwrappedData.getResource().position() == 0) {
+                    unwrappedData.free();
+                } else if (unwrappedData != null) {
+                    this.unwrappedData = unwrappedData;
+                    unwrappedData.getResource().flip();
+                    requiresListenerInvocation = true;
+                } else {
+                    this.unwrappedData = null;
+                }
+            } catch (Throwable e) {
+                System.out.print(e);
+            }
+            if(dataToUnwrap != null) {
+                //if there is no data in the buffer we just free it
+                if(!dataToUnwrap.getResource().hasRemaining()) {
+                    dataToUnwrap.free();
+                    dataToUnwrap = null;
+                    state &= ~FLAG_DATA_TO_UNWRAP;
+                } else if(allAreClear(state, FLAG_DATA_TO_UNWRAP)) {
+                    //if there is not enough data in the buffer we compact it to make room for more
+                    dataToUnwrap.getResource().compact();
+                } else {
+                    //there is more data, make sure we trigger a read listener invocation
+                    requiresListenerInvocation = true;
+                }
+            }
+            if(requiresListenerInvocation && anyAreSet(state, FLAG_READS_RESUMED)) {
+                runReadListener(false);
+            }
+        }
+    }
+
+    /**
+     * Wraps the user data and attempts to send it to the remote client. If data has already been buffered then
+     * this is attempted to be sent first.
+     *
+     * If the supplied buffers are null then a wrap operation is still attempted, which will happen during the
+     * handshaking process.
+     * @param userBuffers The buffers
+     * @param off         The offset
+     * @param len         The length
+     * @return
+     * @throws IOException
+     */
+    private long doWrap(ByteBuffer[] userBuffers, int off, int len) throws IOException {
+        if(anyAreSet(state, FLAG_CLOSED)) {
+            throw new ClosedChannelException();
+        }
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            doUnwrap(null, 0, 0);
+            if(allAreClear(state, FLAG_READ_REQUIRES_WRITE)) { //unless a wrap is immediatly required we just return
+                return 0;
+            }
+        }
+        if(wrappedData != null) {
+            int res = sink.write(wrappedData.getResource());
+            if(res == 0 || wrappedData.getResource().hasRemaining()) {
+                return 0;
+            }
+            wrappedData.getResource().clear();
+        } else {
+            wrappedData = bufferPool.allocate();
+        }
+        try {
+            SSLEngineResult result;
+            if(userBuffers == null) {
+                result = engine.wrap(ByteBuffer.allocate(0), wrappedData.getResource());
+            } else {
+                result = engine.wrap(userBuffers, off, len, wrappedData.getResource());
+            }
+            wrappedData.getResource().flip();
+
+            if (result.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
+                throw new IOException(""underflow""); //todo: can this happen?
+            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
+                throw new IOException(""overflow""); //todo: handle properly
+            }
+            //attempt to write it out, if we fail we just return
+            //we ignore the handshake status, as wrap will get called again
+            int res = sink.write(wrappedData.getResource());
+            if(wrappedData.getResource().hasRemaining()) {
+                return result.bytesConsumed();
+            }
+
+            if (!handleHandshakeResult(result)) {
+                return 0;
+            }
+            if (result.getStatus() == SSLEngineResult.Status.CLOSED && userBuffers != null) {
+                notifyWriteClosed();
+                throw new ClosedChannelException();
+            }
+
+            return result.bytesConsumed();
+        } finally {
+            //this can be cleared if the channel is fully closed
+            if(wrappedData != null) {
+                if (!wrappedData.getResource().hasRemaining()) {
+                    wrappedData.free();
+                    wrappedData = null;
+                }
+            }
+        }
+    }
+
+    private boolean handleHandshakeResult(SSLEngineResult result) throws IOException {
+        switch (result.getHandshakeStatus()) {
+            case NEED_TASK: {
+                state |= FLAG_IN_HANDSHAKE;
+                clearReadRequiresWrite();
+                clearWriteRequiresRead();
+                runTasks();
+                return false;
+            }
+            case NEED_UNWRAP: {
+                clearReadRequiresWrite();
+                state |= FLAG_WRITE_REQUIRES_READ | FLAG_IN_HANDSHAKE;
+                sink.suspendWrites();
+                if(anyAreSet(state, FLAG_WRITES_RESUMED)) {
+                    source.resumeReads();
+                }
+                if (anyAreSet(state, FLAG_DATA_TO_UNWRAP) && anyAreSet(state, FLAG_WRITES_RESUMED | FLAG_READS_RESUMED)) {
+                    runReadListener(false);
+                }
+
+                return false;
+            }
+            case NEED_WRAP: {
+                clearWriteRequiresRead();
+                state |= FLAG_READ_REQUIRES_WRITE | FLAG_IN_HANDSHAKE;
+                source.suspendReads();
+                if(anyAreSet(state, FLAG_READS_RESUMED)) {
+                    sink.resumeWrites();
+                }
+                return false;
+            }
+            case FINISHED: {
+                if(anyAreSet(state, FLAG_IN_HANDSHAKE)) {
+                    state &= ~FLAG_IN_HANDSHAKE;
+                    handshakeCallback.run();
+                }
+            }
+        }
+        clearReadRequiresWrite();
+        clearWriteRequiresRead();
+        return true;
+    }
+
+    private void clearReadRequiresWrite() {
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            state &= ~FLAG_READ_REQUIRES_WRITE;
+            if(anyAreSet(state, FLAG_READS_RESUMED)) {
+                resumeReads();
+            }
+            if(allAreClear(state, FLAG_WRITES_RESUMED)) {
+                sink.suspendWrites();
+            }
+        }
+    }
+
+    private void clearWriteRequiresRead() {
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            state &= ~FLAG_WRITE_REQUIRES_READ;
+            if(anyAreSet(state, FLAG_WRITES_RESUMED)) {
+                wakeupWrites();
+            }
+            if(allAreClear(state, FLAG_READS_RESUMED)) {
+                source.suspendReads();
+            }
+        }
+    }
+
+    private void closed() {
+        if(anyAreSet(state, FLAG_CLOSED)) {
+            return;
+        }
+        state |= FLAG_CLOSED | FLAG_DELEGATE_SINK_SHUTDOWN | FLAG_DELEGATE_SOURCE_SHUTDOWN | FLAG_WRITE_SHUTDOWN | FLAG_READ_SHUTDOWN;
+        notifyReadClosed();
+        notifyWriteClosed();
+        if(dataToUnwrap != null) {
+            dataToUnwrap.free();
+            dataToUnwrap = null;
+        }
+        if(unwrappedData != null) {
+            unwrappedData.free();
+            unwrappedData = null;
+        }
+        if(wrappedData != null) {
+            wrappedData.free();
+            wrappedData = null;
+        }
+        if(allAreClear(state, FLAG_ENGINE_OUTBOUND_SHUTDOWN)) {
+            engine.closeOutbound();
+        }
+        if(allAreClear(state, FLAG_ENGINE_INBOUND_SHUTDOWN)) {
+            try {
+                engine.closeInbound();
+            } catch (SSLException e) {
+                UndertowLogger.REQUEST_LOGGER.ioException(e);
+            }
+        }
+        IoUtils.safeClose(delegate);
+    }
+
+    /**
+     * Execute all the tasks in the worker
+     *
+     * Once they are complete we notify any waiting threads and wakeup reads/writes as appropriate
+     */
+    private void runTasks() {
+        //don't run anything in the IO thread till the tasks are done
+        delegate.getSinkChannel().suspendWrites();
+        delegate.getSourceChannel().suspendReads();
+        synchronized (this) {
+            Runnable task = engine.getDelegatedTask();
+            while (task != null) {
+                outstandingTasks++;
+                final Runnable fTask = task;
+                getWorker().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                            try {
+                                fTask.run();
+                            } finally {
+                                synchronized (SslConduit.this) {
+                                    if(--outstandingTasks == 0) {
+                                        SslConduit.this.notifyAll();
+                                        getWriteThread().execute(new Runnable() {
+                                            @Override
+                                            public void run() {
+                                                if(anyAreSet(state, FLAG_READS_RESUMED)) {
+                                                    wakeupReads(); //wakeup, because we need to run an unwrap even if there is no data to be read
+                                                }
+                                                if(anyAreSet(state, FLAG_WRITES_RESUMED)) {
+                                                    resumeWrites(); //we don't need to wakeup, as the channel should be writable
+                                                }
+                                            }
+                                        });
+                                    }
+                                }
+                            }
+
+                    }
+                });
+                task = engine.getDelegatedTask();
+            }
+        }
+    }
+
+    public SSLEngine getSSLEngine() {
+        return engine;
+    }
+
+    /**
+     * Read ready handler that deals with read-requires-write semantics
+     */
+    private class SslReadReadyHandler implements ReadReadyHandler {
+
+        private final ReadReadyHandler delegateHandler;
+
+        private SslReadReadyHandler(ReadReadyHandler delegateHandler) {
+            this.delegateHandler = delegateHandler;
+        }
+
+        public void readReady(boolean wakeup) {
+            if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+                try {
+                    doHandshake();
+                } catch (IOException e) {
+                    UndertowLogger.REQUEST_LOGGER.ioException(e);
+                    IoUtils.safeClose(delegate);
+                }
+            }
+            if (anyAreSet(state, FLAG_READS_RESUMED)) {
+                if (delegateHandler == null) {
+                    final ChannelListener<? super ConduitStreamSourceChannel> readListener = connection.getSourceChannel().getReadListener();
+                    if (readListener == null) {
+                        suspendReads();
+                    } else {
+                        ChannelListeners.invokeChannelListener(connection.getSourceChannel(), readListener);
+                    }
+                } else {
+                    delegateHandler.readReady();
+                }
+            }
+            if(!anyAreSet(state, FLAG_READS_RESUMED | FLAG_WRITE_REQUIRES_READ)) {
+                delegate.getSourceChannel().suspendReads();
+            } else if(anyAreSet(state, FLAG_READS_RESUMED) && (unwrappedData != null || anyAreSet(state, FLAG_DATA_TO_UNWRAP))) {
+                if(anyAreSet(state, FLAG_READ_CLOSED)) {
+                    if(unwrappedData != null) {
+                        unwrappedData.free();
+                    }
+                    if(dataToUnwrap != null) {
+                        dataToUnwrap.free();
+                    }
+                    unwrappedData = null;
+                    dataToUnwrap = null;
+                } else {
+                    //there is data in the buffers so we do a wakeup
+                    //as we may not get an actual read notification
+                    runReadListener(false);
+                }
+            }
+        }
+
+        @Override
+        public void forceTermination() {
+            try {
+                if (delegateHandler != null) {
+                    delegateHandler.forceTermination();
+                }
+            } finally {
+                IoUtils.safeClose(delegate);
+            }
+        }
+
+        @Override
+        public void terminated() {
+            ChannelListeners.invokeChannelListener(connection.getSourceChannel(), connection.getSourceChannel().getCloseListener());
+        }
+
+        @Override
+        public void readReady() {
+            readReady(false);
+        }
+    }
+
+    /**
+     * write read handler that deals with write-requires-read semantics
+     */
+    private class SslWriteReadyHandler implements WriteReadyHandler {
+
+        private final WriteReadyHandler delegateHandler;
+
+        private SslWriteReadyHandler(WriteReadyHandler delegateHandler) {
+            this.delegateHandler = delegateHandler;
+        }
+
+        @Override
+        public void forceTermination() {
+            try {
+                if (delegateHandler != null) {
+                    delegateHandler.forceTermination();
+                }
+            } finally {
+                IoUtils.safeClose(delegate);
+            }
+        }
+
+        @Override
+        public void terminated() {
+            ChannelListeners.invokeChannelListener(connection.getSinkChannel(), connection.getSinkChannel().getCloseListener());
+        }
+
+        @Override
+        public void writeReady() {
+            if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+                try {
+                    doHandshake();
+                } catch (IOException e) {
+                    UndertowLogger.REQUEST_LOGGER.ioException(e);
+                    IoUtils.safeClose(delegate);
+                }
+            }
+            if (anyAreSet(state, FLAG_WRITES_RESUMED)) {
+                if(delegateHandler == null) {
+                        final ChannelListener<? super ConduitStreamSinkChannel> writeListener = connection.getSinkChannel().getWriteListener();
+                        if (writeListener == null) {
+                            suspendWrites();
+                        } else {
+                            ChannelListeners.invokeChannelListener(connection.getSinkChannel(), writeListener);
+                        }
+                } else {
+                    delegateHandler.writeReady();
+                }
+            }
+            if(!anyAreSet(state, FLAG_WRITES_RESUMED | FLAG_READ_REQUIRES_WRITE)) {
+                delegate.getSinkChannel().suspendWrites();
+            }
+        }
+    }
+}",2014-11-28T02:35:20Z,185
"@@ -0,0 +1,294 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.protocols.ssl;
+
+import org.xnio.ChannelListener;
+import org.xnio.ChannelListeners;
+import org.xnio.Option;
+import org.xnio.OptionMap;
+import org.xnio.Options;
+import org.xnio.Pool;
+import org.xnio.Sequence;
+import org.xnio.SslClientAuthMode;
+import org.xnio.StreamConnection;
+import org.xnio.Xnio;
+import org.xnio.XnioExecutor;
+import org.xnio.XnioIoThread;
+import org.xnio.XnioWorker;
+import org.xnio.channels.AcceptingChannel;
+import org.xnio.ssl.SslConnection;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+import static org.xnio._private.Messages.msg;
+
+/**
+ * @author Stuart Douglas
+ */
+class UndertowAcceptingSslChannel implements AcceptingChannel<SslConnection> {
+    private final SSLContext sslContext;
+    private final AcceptingChannel<? extends StreamConnection> tcpServer;
+
+    private volatile SslClientAuthMode clientAuthMode;
+    private volatile int useClientMode;
+    private volatile int enableSessionCreation;
+    private volatile String[] cipherSuites;
+    private volatile String[] protocols;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<UndertowAcceptingSslChannel, SslClientAuthMode> clientAuthModeUpdater = AtomicReferenceFieldUpdater.newUpdater(UndertowAcceptingSslChannel.class, SslClientAuthMode.class, ""clientAuthMode"");
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicIntegerFieldUpdater<UndertowAcceptingSslChannel> useClientModeUpdater = AtomicIntegerFieldUpdater.newUpdater(UndertowAcceptingSslChannel.class, ""useClientMode"");
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicIntegerFieldUpdater<UndertowAcceptingSslChannel> enableSessionCreationUpdater = AtomicIntegerFieldUpdater.newUpdater(UndertowAcceptingSslChannel.class, ""enableSessionCreation"");
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<UndertowAcceptingSslChannel, String[]> cipherSuitesUpdater = AtomicReferenceFieldUpdater.newUpdater(UndertowAcceptingSslChannel.class, String[].class, ""cipherSuites"");
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<UndertowAcceptingSslChannel, String[]> protocolsUpdater = AtomicReferenceFieldUpdater.newUpdater(UndertowAcceptingSslChannel.class, String[].class, ""protocols"");
+
+    private final ChannelListener.Setter<AcceptingChannel<SslConnection>> closeSetter;
+    private final ChannelListener.Setter<AcceptingChannel<SslConnection>> acceptSetter;
+    protected final boolean startTls;
+    protected final Pool<ByteBuffer> applicationBufferPool;
+
+
+    public UndertowAcceptingSslChannel(final SSLContext sslContext, final AcceptingChannel<? extends StreamConnection> tcpServer, final OptionMap optionMap, final Pool<ByteBuffer> applicationBufferPool, final boolean startTls) {
+        this.tcpServer = tcpServer;
+        this.sslContext = sslContext;
+        this.applicationBufferPool = applicationBufferPool;
+        this.startTls = startTls;
+        clientAuthMode = optionMap.get(Options.SSL_CLIENT_AUTH_MODE);
+        useClientMode = optionMap.get(Options.SSL_USE_CLIENT_MODE, false) ? 1 : 0;
+        enableSessionCreation = optionMap.get(Options.SSL_ENABLE_SESSION_CREATION, true) ? 1 : 0;
+        final Sequence<String> enabledCipherSuites = optionMap.get(Options.SSL_ENABLED_CIPHER_SUITES);
+        cipherSuites = enabledCipherSuites != null ? enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]) : null;
+        final Sequence<String> enabledProtocols = optionMap.get(Options.SSL_ENABLED_PROTOCOLS);
+        protocols = enabledProtocols != null ? enabledProtocols.toArray(new String[enabledProtocols.size()]) : null;
+        //noinspection ThisEscapedInObjectConstruction
+        closeSetter = ChannelListeners.<AcceptingChannel<SslConnection>>getDelegatingSetter(tcpServer.getCloseSetter(), this);
+        //noinspection ThisEscapedInObjectConstruction
+        acceptSetter = ChannelListeners.<AcceptingChannel<SslConnection>>getDelegatingSetter(tcpServer.getAcceptSetter(), this);
+    }
+
+    private static final Set<Option<?>> SUPPORTED_OPTIONS = Option.setBuilder()
+            .add(Options.SSL_CLIENT_AUTH_MODE)
+            .add(Options.SSL_USE_CLIENT_MODE)
+            .add(Options.SSL_ENABLE_SESSION_CREATION)
+            .add(Options.SSL_ENABLED_CIPHER_SUITES)
+            .add(Options.SSL_ENABLED_PROTOCOLS)
+            .create();
+
+    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {
+        if (option == Options.SSL_CLIENT_AUTH_MODE) {
+            return option.cast(clientAuthModeUpdater.getAndSet(this, Options.SSL_CLIENT_AUTH_MODE.cast(value)));
+        } else if (option == Options.SSL_USE_CLIENT_MODE) {
+            final Boolean valueObject = Options.SSL_USE_CLIENT_MODE.cast(value);
+            if (valueObject != null) return option.cast(Boolean.valueOf(useClientModeUpdater.getAndSet(this, valueObject.booleanValue() ? 1 : 0) != 0));
+        } else if (option == Options.SSL_ENABLE_SESSION_CREATION) {
+            final Boolean valueObject = Options.SSL_ENABLE_SESSION_CREATION.cast(value);
+            if (valueObject != null) return option.cast(Boolean.valueOf(enableSessionCreationUpdater.getAndSet(this, valueObject.booleanValue() ? 1 : 0) != 0));
+        } else if (option == Options.SSL_ENABLED_CIPHER_SUITES) {
+            final Sequence<String> seq = Options.SSL_ENABLED_CIPHER_SUITES.cast(value);
+            return option.cast(cipherSuitesUpdater.getAndSet(this, seq == null ? null : seq.toArray(new String[seq.size()])));
+        } else if (option == Options.SSL_ENABLED_PROTOCOLS) {
+            final Sequence<String> seq = Options.SSL_ENABLED_PROTOCOLS.cast(value);
+            return option.cast(protocolsUpdater.getAndSet(this, seq == null ? null : seq.toArray(new String[seq.size()])));
+        } else {
+            return tcpServer.setOption(option, value);
+        }
+        throw msg.nullParameter(""value"");
+    }
+
+    public XnioWorker getWorker() {
+        return tcpServer.getWorker();
+    }
+
+    public UndertowSslConnection accept() throws IOException {
+        final StreamConnection tcpConnection = tcpServer.accept();
+        if (tcpConnection == null) {
+            return null;
+        }
+        final InetSocketAddress peerAddress = tcpConnection.getPeerAddress(InetSocketAddress.class);
+        final SSLEngine engine = sslContext.createSSLEngine(getHostNameNoResolve(peerAddress), peerAddress.getPort());
+        final boolean clientMode = useClientMode != 0;
+        engine.setUseClientMode(clientMode);
+        if (! clientMode) {
+            final SslClientAuthMode clientAuthMode = UndertowAcceptingSslChannel.this.clientAuthMode;
+            if (clientAuthMode != null) switch (clientAuthMode) {
+                case NOT_REQUESTED:
+                    engine.setNeedClientAuth(false);
+                    engine.setWantClientAuth(false);
+                    break;
+                case REQUESTED:
+                    engine.setWantClientAuth(true);
+                    break;
+                case REQUIRED:
+                    engine.setNeedClientAuth(true);
+                    break;
+                default: throw new IllegalStateException();
+            }
+        }
+        engine.setEnableSessionCreation(enableSessionCreation != 0);
+        final String[] cipherSuites = UndertowAcceptingSslChannel.this.cipherSuites;
+        if (cipherSuites != null) {
+            final Set<String> supported = new HashSet<String>(Arrays.asList(engine.getSupportedCipherSuites()));
+            final List<String> finalList = new ArrayList<String>();
+            for (String name : cipherSuites) {
+                if (supported.contains(name)) {
+                    finalList.add(name);
+                }
+            }
+            engine.setEnabledCipherSuites(finalList.toArray(new String[finalList.size()]));
+        }
+        final String[] protocols = UndertowAcceptingSslChannel.this.protocols;
+        if (protocols != null) {
+            final Set<String> supported = new HashSet<String>(Arrays.asList(engine.getSupportedProtocols()));
+            final List<String> finalList = new ArrayList<String>();
+            for (String name : protocols) {
+                if (supported.contains(name)) {
+                    finalList.add(name);
+                }
+            }
+            engine.setEnabledProtocols(finalList.toArray(new String[finalList.size()]));
+        }
+        return accept(tcpConnection, engine);
+    }
+
+    protected UndertowSslConnection accept(StreamConnection tcpServer, SSLEngine sslEngine) throws IOException {
+        return new UndertowSslConnection(tcpServer, sslEngine, applicationBufferPool);
+    }
+
+    public ChannelListener.Setter<? extends AcceptingChannel<SslConnection>> getCloseSetter() {
+        return closeSetter;
+    }
+
+    public boolean isOpen() {
+        return tcpServer.isOpen();
+    }
+
+    public void close() throws IOException {
+        tcpServer.close();
+    }
+
+    public boolean supportsOption(final Option<?> option) {
+        return SUPPORTED_OPTIONS.contains(option) || tcpServer.supportsOption(option);
+    }
+
+    public <T> T getOption(final Option<T> option) throws IOException {
+        if (option == Options.SSL_CLIENT_AUTH_MODE) {
+            return option.cast(clientAuthMode);
+        } else if (option == Options.SSL_USE_CLIENT_MODE) {
+            return option.cast(Boolean.valueOf(useClientMode != 0));
+        } else if (option == Options.SSL_ENABLE_SESSION_CREATION) {
+            return option.cast(Boolean.valueOf(enableSessionCreation != 0));
+        } else if (option == Options.SSL_ENABLED_CIPHER_SUITES) {
+            final String[] cipherSuites = this.cipherSuites;
+            return cipherSuites == null ? null : option.cast(Sequence.of(cipherSuites));
+        } else if (option == Options.SSL_ENABLED_PROTOCOLS) {
+            final String[] protocols = this.protocols;
+            return protocols == null ? null : option.cast(Sequence.of(protocols));
+        } else {
+            return tcpServer.getOption(option);
+        }
+    }
+
+    public ChannelListener.Setter<? extends AcceptingChannel<SslConnection>> getAcceptSetter() {
+        return acceptSetter;
+    }
+
+    public SocketAddress getLocalAddress() {
+        return tcpServer.getLocalAddress();
+    }
+
+    public <A extends SocketAddress> A getLocalAddress(final Class<A> type) {
+        return tcpServer.getLocalAddress(type);
+    }
+
+    public void suspendAccepts() {
+        tcpServer.suspendAccepts();
+    }
+
+    public void resumeAccepts() {
+        tcpServer.resumeAccepts();
+    }
+
+    @Override
+    public boolean isAcceptResumed() {
+        return tcpServer.isAcceptResumed();
+    }
+
+    public void wakeupAccepts() {
+        tcpServer.wakeupAccepts();
+    }
+
+    public void awaitAcceptable() throws IOException {
+        tcpServer.awaitAcceptable();
+    }
+
+    public void awaitAcceptable(final long time, final TimeUnit timeUnit) throws IOException {
+        tcpServer.awaitAcceptable(time, timeUnit);
+    }
+
+    @Deprecated
+    public XnioExecutor getAcceptThread() {
+        return tcpServer.getAcceptThread();
+    }
+
+    public XnioIoThread getIoThread() {
+        return tcpServer.getIoThread();
+    }
+
+
+    private static String getHostNameNoResolve(InetSocketAddress socketAddress) {
+        if (Xnio.NIO2) {
+            return socketAddress.getHostString();
+        } else {
+            String hostName;
+            if (socketAddress.isUnresolved()) {
+                hostName = socketAddress.getHostName();
+            } else {
+                final InetAddress address = socketAddress.getAddress();
+                final String string = address.toString();
+                final int slash = string.indexOf('/');
+                if (slash == -1 || slash == 0) {
+                    // unresolved both ways
+                    hostName = string.substring(slash + 1);
+                } else {
+                    // has a cached host name
+                    hostName = string.substring(0, slash);
+                }
+            }
+            return hostName;
+        }
+    }
+}",2014-11-28T02:35:20Z,232
"@@ -0,0 +1,157 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.protocols.ssl;
+
+import org.xnio.ChannelListener;
+import org.xnio.ChannelListeners;
+import org.xnio.Option;
+import org.xnio.Options;
+import org.xnio.Pool;
+import org.xnio.SslClientAuthMode;
+import org.xnio.StreamConnection;
+import org.xnio.ssl.SslConnection;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.util.Set;
+
+/**
+ * @author Stuart Douglas
+ */
+class UndertowSslConnection extends SslConnection {
+
+    private static final Set<Option<?>> SUPPORTED_OPTIONS = Option.setBuilder().add(Options.SECURE, Options.SSL_CLIENT_AUTH_MODE).create();
+
+    private final StreamConnection delegate;
+    private final SslConduit sslConduit;
+    private final ChannelListener.SimpleSetter<SslConnection> handshakeSetter = new ChannelListener.SimpleSetter<SslConnection>();
+    private final SSLEngine engine;
+
+    /**
+     * Construct a new instance.
+     *
+     * @param delegate the underlying connection
+     */
+    UndertowSslConnection(StreamConnection delegate, SSLEngine engine, Pool<ByteBuffer> bufferPool) {
+        super(delegate.getIoThread());
+        this.delegate = delegate;
+        this.engine = engine;
+        sslConduit = new SslConduit(this, delegate, engine, bufferPool, new HandshakeCallback());
+        setSourceConduit(sslConduit);
+        setSinkConduit(sslConduit);
+    }
+
+    @Override
+    public void startHandshake() throws IOException {
+        sslConduit.startHandshake();
+    }
+
+    @Override
+    public SSLSession getSslSession() {
+        return sslConduit.getSslSession();
+    }
+
+    @Override
+    public ChannelListener.Setter<? extends SslConnection> getHandshakeSetter() {
+        return handshakeSetter;
+    }
+
+    @Override
+    protected void notifyWriteClosed() {
+        sslConduit.notifyWriteClosed();
+    }
+
+    @Override
+    protected void notifyReadClosed() {
+        sslConduit.notifyReadClosed();
+    }
+
+    @Override
+    public SocketAddress getPeerAddress() {
+        return delegate.getPeerAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return delegate.getLocalAddress();
+    }
+
+    public SSLEngine getSSLEngine() {
+        return sslConduit.getSSLEngine();
+    }
+
+
+    /** {@inheritDoc} */
+    @Override
+    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {
+        if (option == Options.SSL_CLIENT_AUTH_MODE) {
+            try {
+                return option.cast(engine.getNeedClientAuth() ? SslClientAuthMode.REQUIRED : engine.getWantClientAuth() ? SslClientAuthMode.REQUESTED : SslClientAuthMode.NOT_REQUESTED);
+            } finally {
+                engine.setNeedClientAuth(value == SslClientAuthMode.REQUIRED);
+                engine.setWantClientAuth(value == SslClientAuthMode.REQUESTED);
+            }
+        } else if (option == Options.SECURE) {
+            throw new IllegalArgumentException();
+        } else {
+            return delegate.setOption(option, value);
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public <T> T getOption(final Option<T> option) throws IOException {
+        if (option == Options.SSL_CLIENT_AUTH_MODE) {
+            return option.cast(engine.getNeedClientAuth() ? SslClientAuthMode.REQUIRED : engine.getWantClientAuth() ? SslClientAuthMode.REQUESTED : SslClientAuthMode.NOT_REQUESTED);
+        } else {
+            return option == Options.SECURE ? (T)Boolean.TRUE : delegate.getOption(option);
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean supportsOption(final Option<?> option) {
+        return SUPPORTED_OPTIONS.contains(option) || delegate.supportsOption(option);
+    }
+
+    @Override
+    protected boolean readClosed() {
+        return super.readClosed();
+    }
+
+    @Override
+    protected boolean writeClosed() {
+        return super.writeClosed();
+    }
+
+    private final class HandshakeCallback implements Runnable {
+
+        @Override
+        public void run() {
+            final ChannelListener<? super SslConnection> listener = handshakeSetter.get();
+            if (listener == null) {
+                return;
+            }
+            ChannelListeners.<SslConnection>invokeChannelListener(UndertowSslConnection.this, listener);
+        }
+    }
+}",2014-11-28T02:35:20Z,233
"@@ -0,0 +1,285 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.protocols.ssl;
+
+import org.xnio.ChannelListener;
+import org.xnio.ChannelListeners;
+import org.xnio.FutureResult;
+import org.xnio.IoFuture;
+import org.xnio.IoUtils;
+import org.xnio.Option;
+import org.xnio.OptionMap;
+import org.xnio.Pool;
+import org.xnio.StreamConnection;
+import org.xnio.Xnio;
+import org.xnio.XnioExecutor;
+import org.xnio.XnioIoThread;
+import org.xnio.XnioWorker;
+import org.xnio.channels.AcceptingChannel;
+import org.xnio.channels.AssembledConnectedSslStreamChannel;
+import org.xnio.channels.BoundChannel;
+import org.xnio.channels.ConnectedSslStreamChannel;
+import org.xnio.channels.ConnectedStreamChannel;
+import org.xnio.ssl.JsseSslUtils;
+import org.xnio.ssl.JsseXnioSsl;
+import org.xnio.ssl.SslConnection;
+import org.xnio.ssl.XnioSsl;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.util.concurrent.TimeUnit;
+
+import static org.xnio.IoUtils.safeClose;
+
+/**
+ * @author Stuart Douglas
+ */
+public class UndertowXnioSsl extends XnioSsl {
+
+    private final Pool<ByteBuffer> bufferPool;
+    private final SSLContext sslContext;
+
+    /**
+     * Construct a new instance.
+     *
+     * @param xnio the XNIO instance to associate with
+     * @param optionMap the options for this provider
+     * @param bufferPool
+     * @throws java.security.NoSuchProviderException if the given SSL provider is not found
+     * @throws java.security.NoSuchAlgorithmException if the given SSL algorithm is not supported
+     * @throws java.security.KeyManagementException if the SSL context could not be initialized
+     */
+    public UndertowXnioSsl(final Xnio xnio, final OptionMap optionMap, Pool<ByteBuffer> bufferPool) throws NoSuchProviderException, NoSuchAlgorithmException, KeyManagementException {
+        this(xnio, optionMap, bufferPool, JsseSslUtils.createSSLContext(optionMap));
+    }
+
+    /**
+     * Construct a new instance.
+     *  @param xnio the XNIO instance to associate with
+     * @param optionMap the options for this provider
+     * @param bufferPool
+     * @param sslContext the SSL context to use for this instance
+     */
+    public UndertowXnioSsl(final Xnio xnio, final OptionMap optionMap, Pool<ByteBuffer> bufferPool, final SSLContext sslContext) {
+        super(xnio, sslContext, optionMap);
+        this.bufferPool = bufferPool;
+        this.sslContext = sslContext;
+    }
+
+    /**
+     * Get the JSSE SSL context for this provider instance.
+     *
+     * @return the SSL context
+     */
+    @SuppressWarnings(""unused"")
+    public SSLContext getSslContext() {
+        return sslContext;
+    }
+
+    /**
+     * Get the SSL engine for a given connection.
+     *
+     * @return the SSL engine
+     */
+    public static SSLEngine getSslEngine(SslConnection connection) {
+        if (connection instanceof UndertowSslConnection) {
+            return ((UndertowSslConnection) connection).getSSLEngine();
+        } else {
+            return JsseXnioSsl.getSslEngine(connection);
+        }
+    }
+
+    @SuppressWarnings(""deprecation"")
+    public IoFuture<ConnectedSslStreamChannel> connectSsl(final XnioWorker worker, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super ConnectedSslStreamChannel> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
+        final FutureResult<ConnectedSslStreamChannel> futureResult = new FutureResult<ConnectedSslStreamChannel>(IoUtils.directExecutor());
+        final IoFuture<SslConnection> futureSslConnection = openSslConnection(worker, bindAddress, destination, new ChannelListener<SslConnection>() {
+            public void handleEvent(final SslConnection sslConnection) {
+                final ConnectedSslStreamChannel assembledChannel = new AssembledConnectedSslStreamChannel(sslConnection, sslConnection.getSourceChannel(), sslConnection.getSinkChannel());
+                if (!futureResult.setResult(assembledChannel)) {
+                    safeClose(assembledChannel);
+                } else {
+                    ChannelListeners.invokeChannelListener(assembledChannel, openListener);
+                }
+            }
+        }, bindListener, optionMap).addNotifier(new IoFuture.HandlingNotifier<SslConnection, FutureResult<ConnectedSslStreamChannel>>() {
+            public void handleCancelled(final FutureResult<ConnectedSslStreamChannel> result) {
+                result.setCancelled();
+            }
+
+            public void handleFailed(final IOException exception, final FutureResult<ConnectedSslStreamChannel> result) {
+                result.setException(exception);
+            }
+        }, futureResult);
+        futureResult.getIoFuture().addNotifier(new IoFuture.HandlingNotifier<ConnectedStreamChannel, IoFuture<SslConnection>>() {
+            public void handleCancelled(final IoFuture<SslConnection> result) {
+                result.cancel();
+            }
+        }, futureSslConnection);
+        futureResult.addCancelHandler(futureSslConnection);
+        return futureResult.getIoFuture();
+    }
+
+    public IoFuture<SslConnection> openSslConnection(final XnioWorker worker, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super SslConnection> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
+        final FutureResult<SslConnection> futureResult = new FutureResult<SslConnection>(worker);
+        final IoFuture<StreamConnection> connection = worker.openStreamConnection(bindAddress, destination, new StreamConnectionChannelListener(optionMap, destination, futureResult, openListener), bindListener, optionMap);
+        return setupSslConnection(futureResult, connection);
+    }
+    @Override
+    public IoFuture<SslConnection> openSslConnection(final XnioIoThread ioThread, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super SslConnection> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
+        final FutureResult<SslConnection> futureResult = new FutureResult<SslConnection>(ioThread);
+        final IoFuture<StreamConnection> connection = ioThread.openStreamConnection(bindAddress, destination, new StreamConnectionChannelListener(optionMap, destination, futureResult, openListener), bindListener, optionMap);
+        return setupSslConnection(futureResult, connection);
+    }
+
+    private IoFuture<SslConnection> setupSslConnection(FutureResult<SslConnection> futureResult, IoFuture<StreamConnection> connection) {
+        connection.addNotifier(new IoFuture.HandlingNotifier<StreamConnection, FutureResult<SslConnection>>() {
+            public void handleCancelled(final FutureResult<SslConnection> attachment) {
+                attachment.setCancelled();
+            }
+
+            public void handleFailed(final IOException exception, final FutureResult<SslConnection> attachment) {
+                attachment.setException(exception);
+            }
+        }, futureResult);
+        futureResult.addCancelHandler(connection);
+        return futureResult.getIoFuture();
+    }
+
+    @SuppressWarnings(""deprecation"")
+    public AcceptingChannel<ConnectedSslStreamChannel> createSslTcpServer(final XnioWorker worker, final InetSocketAddress bindAddress, final ChannelListener<? super AcceptingChannel<ConnectedSslStreamChannel>> acceptListener, final OptionMap optionMap) throws IOException {
+        final AcceptingChannel<SslConnection> server = createSslConnectionServer(worker, bindAddress, null, optionMap);
+        final AcceptingChannel<ConnectedSslStreamChannel> acceptingChannel = new AcceptingChannel<ConnectedSslStreamChannel>() {
+            public ConnectedSslStreamChannel accept() throws IOException {
+                final SslConnection connection = server.accept();
+                return connection == null ? null : new AssembledConnectedSslStreamChannel(connection, connection.getSourceChannel(), connection.getSinkChannel());
+            }
+
+            public ChannelListener.Setter<? extends AcceptingChannel<ConnectedSslStreamChannel>> getAcceptSetter() {
+                return ChannelListeners.getDelegatingSetter(server.getAcceptSetter(), this);
+            }
+
+            public ChannelListener.Setter<? extends AcceptingChannel<ConnectedSslStreamChannel>> getCloseSetter() {
+                return ChannelListeners.getDelegatingSetter(server.getCloseSetter(), this);
+            }
+
+            public SocketAddress getLocalAddress() {
+                return server.getLocalAddress();
+            }
+
+            public <A extends SocketAddress> A getLocalAddress(final Class<A> type) {
+                return server.getLocalAddress(type);
+            }
+
+            public void suspendAccepts() {
+                server.suspendAccepts();
+            }
+
+            public void resumeAccepts() {
+                server.resumeAccepts();
+            }
+
+            public boolean isAcceptResumed() {
+                return server.isAcceptResumed();
+            }
+
+            public void wakeupAccepts() {
+                server.wakeupAccepts();
+            }
+
+            public void awaitAcceptable() throws IOException {
+                server.awaitAcceptable();
+            }
+
+            public void awaitAcceptable(final long time, final TimeUnit timeUnit) throws IOException {
+                server.awaitAcceptable(time, timeUnit);
+            }
+
+            public XnioWorker getWorker() {
+                return server.getWorker();
+            }
+
+            @Deprecated
+            public XnioExecutor getAcceptThread() {
+                return server.getAcceptThread();
+            }
+
+            public XnioIoThread getIoThread() {
+                return server.getIoThread();
+            }
+
+            public void close() throws IOException {
+                server.close();
+            }
+
+            public boolean isOpen() {
+                return server.isOpen();
+            }
+
+            public boolean supportsOption(final Option<?> option) {
+                return server.supportsOption(option);
+            }
+
+            public <T> T getOption(final Option<T> option) throws IOException {
+                return server.getOption(option);
+            }
+
+            public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {
+                return server.setOption(option, value);
+            }
+        };
+        acceptingChannel.getAcceptSetter().set(acceptListener);
+        return acceptingChannel;
+    }
+
+    public AcceptingChannel<SslConnection> createSslConnectionServer(final XnioWorker worker, final InetSocketAddress bindAddress, final ChannelListener<? super AcceptingChannel<SslConnection>> acceptListener, final OptionMap optionMap) throws IOException {
+        final UndertowAcceptingSslChannel server = new UndertowAcceptingSslChannel(sslContext, worker.createStreamConnectionServer(bindAddress,  null,  optionMap), optionMap, bufferPool, false);
+        if (acceptListener != null) server.getAcceptSetter().set(acceptListener);
+        return server;
+    }
+
+    private class StreamConnectionChannelListener implements ChannelListener<StreamConnection> {
+        private final OptionMap optionMap;
+        private final InetSocketAddress destination;
+        private final FutureResult<SslConnection> futureResult;
+        private final ChannelListener<? super SslConnection> openListener;
+
+        public StreamConnectionChannelListener(OptionMap optionMap, InetSocketAddress destination, FutureResult<SslConnection> futureResult, ChannelListener<? super SslConnection> openListener) {
+            this.optionMap = optionMap;
+            this.destination = destination;
+            this.futureResult = futureResult;
+            this.openListener = openListener;
+        }
+
+        public void handleEvent(final StreamConnection connection) {
+            final SslConnection wrappedConnection = new UndertowSslConnection(connection, JsseSslUtils.createSSLEngine(sslContext, optionMap, destination), bufferPool);
+            if (! futureResult.setResult(wrappedConnection)) {
+                IoUtils.safeClose(connection);
+            } else {
+                ChannelListeners.invokeChannelListener(wrappedConnection, openListener);
+            }
+        }
+    }
+}",2014-11-28T02:35:20Z,228
"@@ -479,6 +479,7 @@ public void onComplete(final HttpServerExchange exchange, final Sender sender) {
                                     @Override
                                     public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {
                                         IoUtils.safeClose(clientConnection.getConnection());
+                                        exchange.endExchange();
                                     }
                                 });
                             }
@@ -535,7 +536,6 @@ private ResponseCallback(HttpServerExchange exchange) {
 
         @Override
         public void completed(final ClientExchange result) {
-            HttpServerExchange exchange = result.getAttachment(EXCHANGE);
             final ClientResponse response = result.getResponse();
             final HeaderMap inboundResponseHeaders = response.getResponseHeaders();
             final HeaderMap outboundResponseHeaders = exchange.getResponseHeaders();
@@ -559,7 +559,7 @@ public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange
                     }
                 });
             }
-            IoExceptionHandler handler = new IoExceptionHandler(exchange, result.getConnection());
+            final IoExceptionHandler handler = new IoExceptionHandler(exchange, result.getConnection());
             ChannelListeners.initiateTransfer(Long.MAX_VALUE, result.getResponseChannel(), exchange.getResponseChannel(), ChannelListeners.closingChannelListener(), new HTTPTrailerChannelListener(result, exchange), handler, handler, exchange.getConnection().getBufferPool());
 
         }",2014-11-28T02:35:20Z,92
"@@ -452,8 +452,10 @@ public void close() throws IOException {
         }
         try {
             state |= STATE_CLOSED;
-            buffer.free();
-            buffer = null;
+            if(buffer != null) {
+                buffer.free();
+                buffer = null;
+            }
             if (header != null && header.getByteBuffer() != null) {
                 header.getByteBuffer().free();
             }",2014-11-28T02:35:20Z,234
"@@ -27,6 +27,7 @@
 import javax.net.ssl.SSLEngine;
 
 import io.undertow.UndertowLogger;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import io.undertow.server.DelegateOpenListener;
 import org.eclipse.jetty.alpn.ALPN;
 import org.xnio.ChannelListener;
@@ -35,7 +36,6 @@
 import org.xnio.Pooled;
 import org.xnio.StreamConnection;
 import org.xnio.channels.StreamSourceChannel;
-import org.xnio.ssl.JsseXnioSsl;
 import org.xnio.ssl.SslConnection;
 
 /**
@@ -92,7 +92,7 @@ public void handleEvent(final StreamConnection channel) {
         }
         final AlpnConnectionListener potentialConnection = new AlpnConnectionListener(channel);
         channel.getSourceChannel().setReadListener(potentialConnection);
-        final SSLEngine sslEngine = JsseXnioSsl.getSslEngine((SslConnection) channel);
+        final SSLEngine sslEngine = UndertowXnioSsl.getSslEngine((SslConnection) channel);
         ALPN.put(sslEngine, new ALPN.ServerProvider() {
             @Override
             public void unsupported() {",2014-11-28T02:35:20Z,191
"@@ -22,6 +22,7 @@
 import io.undertow.io.IoCallback;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
 import io.undertow.util.StatusCodes;
 import org.xnio.ChannelExceptionHandler;
@@ -63,7 +64,12 @@ public static boolean requiresContinueResponse(final HttpServerExchange exchange
                 return false;
             }
         }
-        List<String> expect = exchange.getRequestHeaders().get(Headers.EXPECT);
+        HeaderMap requestHeaders = exchange.getRequestHeaders();
+        return requiresContinueResponse(requestHeaders);
+    }
+
+    public static boolean requiresContinueResponse(HeaderMap requestHeaders) {
+        List<String> expect = requestHeaders.get(Headers.EXPECT);
         if (expect != null) {
             for (String header : expect) {
                 if (header.equalsIgnoreCase(CONTINUE)) {
@@ -74,6 +80,7 @@ public static boolean requiresContinueResponse(final HttpServerExchange exchange
         return false;
     }
 
+
     /**
      * Sends a continuation using async IO, and calls back when it is complete.
      *",2014-11-28T02:35:20Z,87
"@@ -118,12 +118,15 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 }
                 exchange.startBlocking();
                 ByteArrayOutputStream out = new ByteArrayOutputStream();
+                StringBuilder sb = new StringBuilder();
                 byte[] buf = new byte[100];
                 int res = 0;
                 while ((res = exchange.getInputStream().read(buf)) > 0) {
+                    sb.append(new String(buf, 0, res));
                     out.write(buf, 0, res);
                 }
                 System.out.println(""WRITE "" + out.size());
+                Assert.assertEquals(message, sb.toString());
                 exchange.getOutputStream().write(out.toByteArray());
                 System.out.println(""DONE "" + out.size());
             }
@@ -148,6 +151,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             resultList = client.execute(post);
             Assert.assertEquals(StatusCodes.OK, resultList.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(resultList);
+            Assert.assertEquals(message.length(), response.length());
             Assert.assertEquals(message, response);
 
 ",2014-11-28T02:35:20Z,133
"@@ -19,6 +19,7 @@
 package io.undertow.testutils;
 
 import io.undertow.UndertowOptions;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
 import io.undertow.security.impl.GSSAPIAuthenticationMechanism;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -64,7 +65,6 @@
 import org.xnio.Xnio;
 import org.xnio.XnioWorker;
 import org.xnio.channels.AcceptingChannel;
-import org.xnio.ssl.JsseXnioSsl;
 import org.xnio.ssl.XnioSsl;
 
 import javax.net.ssl.KeyManager;
@@ -101,7 +101,7 @@ public class DefaultServer extends BlockJUnit4ClassRunner {
     private static final int PROXY_OFFSET = 1111;
     public static final int APACHE_PORT = 9080;
     public static final int APACHE_SSL_PORT = 9443;
-    public static final int BUFFER_SIZE = Integer.getInteger(""test.bufferSize"", 8192);
+    public static final int BUFFER_SIZE = Integer.getInteger(""test.bufferSize"", 8192 * 3);
 
     private static boolean first = true;
     private static OptionMap serverOptions;
@@ -137,6 +137,8 @@ public class DefaultServer extends BlockJUnit4ClassRunner {
 
     private static final Logger log = Logger.getLogger(DefaultServer.class);
 
+    private static final DebuggingSlicePool pool = new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, BUFFER_SIZE, 100 * BUFFER_SIZE));
+
     private static KeyStore loadKeyStore(final String name) throws IOException {
         final InputStream stream = DefaultServer.class.getClassLoader().getResourceAsStream(name);
         try {
@@ -222,7 +224,7 @@ public static void setupProxyHandlerForSSL(ProxyHandler proxyHandler) {
     }
 
     public static Pool<ByteBuffer> getBufferPool() {
-        return openListener.getBufferPool();
+        return pool;
     }
 
     @Override
@@ -285,7 +287,8 @@ private static void runInternal(final RunNotifier notifier) {
                         .set(Options.BALANCING_TOKENS, 1)
                         .set(Options.BALANCING_CONNECTIONS, 2)
                         .getMap();
-                DebuggingSlicePool pool = new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, BUFFER_SIZE, 100 * BUFFER_SIZE));
+                final SSLContext serverContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE));
+                UndertowXnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, getBufferPool(), serverContext);
                 if (ajp) {
                     openListener = new AjpOpenListener(pool);
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
@@ -306,16 +309,16 @@ private static void runInternal(final RunNotifier notifier) {
                     openListener = new SpdyOpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, BUFFER_SIZE, BUFFER_SIZE), OptionMap.create(UndertowOptions.ENABLE_SPDY, true));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(new AlpnOpenListener(pool).addProtocol(SpdyOpenListener.SPDY_3_1, (io.undertow.server.DelegateOpenListener) openListener, 5)));
 
-                    SSLContext serverContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE));
                     SSLContext clientContext = createSSLContext(loadKeyStore(CLIENT_KEY_STORE), loadKeyStore(CLIENT_TRUST_STORE));
-                    XnioSsl xnioSsl = new JsseXnioSsl(xnio, OptionMap.EMPTY, serverContext);
-                    server = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), 7777 + PROXY_OFFSET), acceptListener, OptionMap.EMPTY);
+
+                    server = ssl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), 7777 + PROXY_OFFSET), acceptListener, serverOptions);
+                    server.getAcceptSetter().set(acceptListener);
                     server.resumeAccepts();
 
                     proxyOpenListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true));
                     proxyAcceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(proxyOpenListener));
                     proxyServer = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT)), proxyAcceptListener, serverOptions);
-                    ProxyHandler proxyHandler = new ProxyHandler(new LoadBalancingProxyClient(GSSAPIAuthenticationMechanism.EXCLUSIVITY_CHECKER).addHost(new URI(""spdy"", null, getHostAddress(DEFAULT), getHostPort(DEFAULT) + PROXY_OFFSET, ""/"", null, null), null, new JsseXnioSsl(xnio, OptionMap.EMPTY, clientContext), OptionMap.create(UndertowOptions.ENABLE_SPDY, true)), 120000, HANDLE_404);
+                    ProxyHandler proxyHandler = new ProxyHandler(new LoadBalancingProxyClient(GSSAPIAuthenticationMechanism.EXCLUSIVITY_CHECKER).addHost(new URI(""spdy"", null, getHostAddress(DEFAULT), getHostPort(DEFAULT) + PROXY_OFFSET, ""/"", null, null), null, new UndertowXnioSsl(xnio, OptionMap.EMPTY, pool, clientContext), OptionMap.create(UndertowOptions.ENABLE_SPDY, true)), 120000, HANDLE_404);
                     setupProxyHandlerForSSL(proxyHandler);
                     proxyOpenListener.setRootHandler(proxyHandler);
                     proxyServer.resumeAccepts();
@@ -325,16 +328,14 @@ private static void runInternal(final RunNotifier notifier) {
                     openListener = new Http2OpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(new AlpnOpenListener(pool).addProtocol(Http2OpenListener.HTTP2, (io.undertow.server.DelegateOpenListener) openListener, 10)));
 
-                    SSLContext serverContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE));
                     SSLContext clientContext = createSSLContext(loadKeyStore(CLIENT_KEY_STORE), loadKeyStore(CLIENT_TRUST_STORE));
-                    XnioSsl xnioSsl = new JsseXnioSsl(xnio, OptionMap.EMPTY, serverContext);
-                    server = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), 7777 + PROXY_OFFSET), acceptListener, OptionMap.EMPTY);
+                    server = ssl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), 7777 + PROXY_OFFSET), acceptListener, serverOptions);
                     server.resumeAccepts();
 
                     proxyOpenListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true));
                     proxyAcceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(proxyOpenListener));
                     proxyServer = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT)), proxyAcceptListener, serverOptions);
-                    ProxyHandler proxyHandler = new ProxyHandler(new LoadBalancingProxyClient(GSSAPIAuthenticationMechanism.EXCLUSIVITY_CHECKER).addHost(new URI(""h2"", null, getHostAddress(DEFAULT), getHostPort(DEFAULT) + PROXY_OFFSET, ""/"", null, null), null, new JsseXnioSsl(xnio, OptionMap.EMPTY, clientContext), OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)), 120000, HANDLE_404);
+                    ProxyHandler proxyHandler = new ProxyHandler(new LoadBalancingProxyClient(GSSAPIAuthenticationMechanism.EXCLUSIVITY_CHECKER).addHost(new URI(""h2"", null, getHostAddress(DEFAULT), getHostPort(DEFAULT) + PROXY_OFFSET, ""/"", null, null), null, new UndertowXnioSsl(xnio, OptionMap.EMPTY, pool, clientContext), OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)), 120000, HANDLE_404);
                     setupProxyHandlerForSSL(proxyHandler);
                     proxyOpenListener.setRootHandler(proxyHandler);
                     proxyServer.resumeAccepts();
@@ -373,13 +374,12 @@ private static void runInternal(final RunNotifier notifier) {
 
                 } else if (https) {
 
-                    XnioSsl xnioSsl = new JsseXnioSsl(xnio, OptionMap.EMPTY, getServerSslContext());
-                    XnioSsl clientSsl = new JsseXnioSsl(xnio, OptionMap.EMPTY, createClientSslContext());
+                    XnioSsl clientSsl = new UndertowXnioSsl(xnio, OptionMap.EMPTY, pool, createClientSslContext());
                     openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
-
-                    InetSocketAddress targetAddress = new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT) + PROXY_OFFSET);
-                    server = xnioSsl.createSslConnectionServer(worker, targetAddress, acceptListener, serverOptions);
+                    server = ssl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), 7777 + PROXY_OFFSET), acceptListener, serverOptions);
+                    server.getAcceptSetter().set(acceptListener);
+                    server.resumeAccepts();
 
                     proxyOpenListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true));
                     proxyAcceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(proxyOpenListener));
@@ -697,9 +697,9 @@ public static void startSSLServer(final SSLContext context, final OptionMap opti
                 .set(Options.USE_DIRECT_BUFFERS, true)
                 .getMap();
 
-        XnioSsl xnioSsl = new JsseXnioSsl(xnio, combined, context);
-        sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)),
-                port), openListener, combined);
+        UndertowXnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, getBufferPool(), context);
+        sslServer = ssl.createSslConnectionServer(worker, new InetSocketAddress(getHostAddress(""default""), port), openListener, options);
+        sslServer.getAcceptSetter().set(openListener);
         sslServer.resumeAccepts();
     }
 ",2014-11-28T02:35:20Z,76
"@@ -159,8 +159,9 @@ void closeBlocking() throws IOException {
             }
             channel.shutdownWrites();
             Channels.flushBlocking(channel);
-        } finally {
+        } catch (IOException e){
             channel.close();
+            throw e;
         }
     }
 ",2014-11-28T02:35:20Z,235
"@@ -129,6 +129,7 @@
                     <enableAssertions>true</enableAssertions>
                     <runOrder>reversealphabetical</runOrder>
                     <skip>${test.spdy}</skip>
+                    <redirectTestOutputToFile>true</redirectTestOutputToFile>
                     <systemPropertyVariables>
                         <proxy>${proxy}</proxy>
                         <default.server.address>localhost</default.server.address>",2014-11-28T02:35:20Z,236
"@@ -163,7 +163,7 @@ private String createSettingsFrame(OptionMap options, Pool<ByteBuffer> bufferPoo
                 pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE));
             }
             currentBuffer.flip();
-            return FlexBase64.encodeString(currentBuffer, false);
+            return FlexBase64.encodeStringURL(currentBuffer, false);
         } finally {
             b.free();
         }",2015-07-17T08:00:36Z,348
"@@ -53,7 +53,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             String settings = exchange.getRequestHeaders().getFirst(""HTTP2-Settings"");
             if(settings != null) {
                 //required by spec
-                final ByteBuffer settingsFrame = FlexBase64.decode(settings);
+                final ByteBuffer settingsFrame = FlexBase64.decodeURL(settings);
                 exchange.upgradeChannel(new HttpUpgradeListener() {
                     @Override
                     public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange exchange) {",2015-07-17T08:00:36Z,349
"@@ -20,14 +20,16 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
 import java.security.AccessController;
 import java.security.PrivilegedExceptionAction;
 
 /**
- * An efficient and flexible MIME Base64 implementation.
+ * An efficient and flexible Base64 implementation.
+ *
+ * This class can deal with both MIME Base64 and Base64url.
  *
  * @author Jason T. Greene
  */
@@ -36,22 +38,27 @@ public class FlexBase64 {
      * Note that this code heavily favors performance over reuse and clean style.
      */
 
-    private static final byte[] ENCODING_TABLE;
-    private static final byte[] DECODING_TABLE = new byte[80];
+    private static final byte[] STANDARD_ENCODING_TABLE;
+    private static final byte[] STANDARD_DECODING_TABLE = new byte[80];
+    private static final byte[] URL_ENCODING_TABLE;
+    private static final byte[] URL_DECODING_TABLE = new byte[80];
     private static final Constructor<String> STRING_CONSTRUCTOR;
 
     static {
-        try {
-            ENCODING_TABLE = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"".getBytes(""ASCII"");
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException();
+        STANDARD_ENCODING_TABLE = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"".getBytes(StandardCharsets.US_ASCII);
+        URL_ENCODING_TABLE = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"".getBytes(StandardCharsets.US_ASCII);
+
+        for (int i = 0; i < STANDARD_ENCODING_TABLE.length; i++) {
+            int v = (STANDARD_ENCODING_TABLE[i] & 0xFF) - 43;
+            STANDARD_DECODING_TABLE[v] = (byte)(i + 1);  // zero = illegal
         }
 
-        for (int i = 0; i < ENCODING_TABLE.length; i++) {
-            int v = (ENCODING_TABLE[i] & 0xFF) - 43;
-            DECODING_TABLE[v] = (byte)(i + 1);  // zero = illegal
+        for (int i = 0; i < URL_ENCODING_TABLE.length; i++) {
+            int v = (URL_ENCODING_TABLE[i] & 0xFF) - 43;
+            URL_DECODING_TABLE[v] = (byte)(i + 1);  // zero = illegal
         }
 
+
         Constructor<String> c = null;
         try {
             PrivilegedExceptionAction<Constructor<String>> runnable = new PrivilegedExceptionAction<Constructor<String>>() {
@@ -84,7 +91,21 @@ public Constructor<String> run() throws Exception {
      * @return an createEncoder instance
      */
     public static Encoder createEncoder(boolean wrap) {
-        return new Encoder(wrap);
+        return new Encoder(wrap, false);
+    }
+
+
+    /**
+     * Creates a state driven base64url encoder.
+     *
+     * <p>The Encoder instance is not thread-safe, and must not be shared between threads without establishing a
+     * happens-before relationship.</p>
+     *
+     * @param wrap whether or not to wrap at 76 characters with CRLF
+     * @return an createEncoder instance
+     */
+    public static Encoder createURLEncoder(boolean wrap) {
+        return new Encoder(wrap, true);
     }
 
     /**
@@ -96,7 +117,19 @@ public static Encoder createEncoder(boolean wrap) {
      * @return a new createDecoder instance
      */
     public static Decoder createDecoder() {
-        return new Decoder();
+        return new Decoder(false);
+    }
+
+    /**
+     * Creates a state driven base64url decoder.
+     *
+     * <p>The Decoder instance is not thread-safe, and must not be shared between threads without establishing a
+     * happens-before relationship.</p>
+     *
+     * @return a new createDecoder instance
+     */
+    public static Decoder createURLDecoder() {
+        return new Decoder(true);
     }
 
     /**
@@ -113,7 +146,25 @@ public static Decoder createDecoder() {
      * @return a new String representing the Base64 output
      */
     public static String encodeString(byte[] source, boolean wrap) {
-        return Encoder.encodeString(source, 0, source.length, wrap);
+        return Encoder.encodeString(source, 0, source.length, wrap, false);
+    }
+
+
+    /**
+     * Encodes a fixed and complete byte array into a Base64url String.
+     *
+     * <p>This method is only useful for applications which require a String and have all data to be encoded up-front.
+     * Note that byte arrays or buffers are almost always a better storage choice. They consume half the memory and
+     * can be reused (modified). In other words, it is almost always better to use {@link #encodeBytes},
+     * {@link #createEncoder}, or {@link #createEncoderOutputStream} instead.
+     * instead.
+     *
+     * @param source the byte array to encode from
+     * @param wrap whether or not to wrap the output at 76 chars with CRLFs
+     * @return a new String representing the Base64url output
+     */
+    public static String encodeStringURL(byte[] source, boolean wrap) {
+        return Encoder.encodeString(source, 0, source.length, wrap, true);
     }
 
     /**
@@ -136,9 +187,31 @@ public static String encodeString(byte[] source, boolean wrap) {
      * @return a new String representing the Base64 output
      */
     public static String encodeString(byte[] source, int pos, int limit, boolean wrap) {
-        return Encoder.encodeString(source, pos, limit, wrap);
+        return Encoder.encodeString(source, pos, limit, wrap, false);
     }
 
+    /**
+     * Encodes a fixed and complete byte array into a Base64url String.
+     *
+     * <p>This method is only useful for applications which require a String and have all data to be encoded up-front.
+     * Note that byte arrays or buffers are almost always a better storage choice. They consume half the memory and
+     * can be reused (modified). In other words, it is almost always better to use {@link #encodeBytes},
+     * {@link #createEncoder}, or {@link #createEncoderOutputStream} instead.</p>
+     *
+     * <pre><code>
+     *    // Encodes ""ell""
+     *    FlexBase64.encodeStringURL(""hello"".getBytes(""US-ASCII""), 1, 4);
+     * </code></pre>
+     *
+     * @param source the byte array to encode from
+     * @param pos the position to start encoding from
+     * @param limit the position to halt encoding at (exclusive)
+     * @param wrap whether or not to wrap the output at 76 chars with CRLFs
+     * @return a new String representing the Base64url output
+     */
+    public static String encodeStringURL(byte[] source, int pos, int limit, boolean wrap) {
+        return Encoder.encodeString(source, pos, limit, wrap, true);
+    }
     /**
      * Encodes a fixed and complete byte buffer into a Base64 String.
      *
@@ -157,7 +230,28 @@ public static String encodeString(byte[] source, int pos, int limit, boolean wra
      * @return a new String representing the Base64 output
      */
     public static String encodeString(ByteBuffer source, boolean wrap) {
-        return Encoder.encodeString(source, wrap);
+        return Encoder.encodeString(source, wrap, false);
+    }
+
+    /**
+     * Encodes a fixed and complete byte buffer into a Base64url String.
+     *
+     * <p>This method is only useful for applications which require a String and have all data to be encoded up-front.
+     * Note that byte arrays or buffers are almost always a better storage choice. They consume half the memory and
+     * can be reused (modified). In other words, it is almost always better to use {@link #encodeBytes},
+     * {@link #createEncoder}, or {@link #createEncoderOutputStream} instead.</p>
+     *
+     * <pre><code>
+     *    // Encodes ""ell""
+     *    FlexBase64.ecncodeStringURL(""hello"".getBytes(""US-ASCII""), 1, 4);
+     * </code></pre>
+     *
+     * @param source the byte buffer to encode from
+     * @param wrap whether or not to wrap the output at 76 chars with CRLFs
+     * @return a new String representing the Base64url output
+     */
+    public static String encodeStringURL(ByteBuffer source, boolean wrap) {
+        return Encoder.encodeString(source, wrap, false);
     }
 
     /**
@@ -175,7 +269,25 @@ public static String encodeString(ByteBuffer source, boolean wrap) {
      * @return a new byte array containing the encoded ASCII values
      */
     public static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wrap) {
-        return Encoder.encodeBytes(source, pos, limit, wrap);
+        return Encoder.encodeBytes(source, pos, limit, wrap, false);
+    }
+
+    /**
+     * Encodes a fixed and complete byte buffer into a Base64url byte array.
+     *
+     * <pre><code>
+     *    // Encodes ""ell""
+     *    FlexBase64.ecncodeStringURL(""hello"".getBytes(""US-ASCII""), 1, 4);
+     * </code></pre>
+     *
+     * @param source the byte array to encode from
+     * @param pos the position to start encoding at
+     * @param limit the position to halt encoding at (exclusive)
+     * @param wrap whether or not to wrap at 76 characters with CRLFs
+     * @return a new byte array containing the encoded ASCII values
+     */
+    public static byte[] encodeBytesURL(byte[] source, int pos, int limit, boolean wrap) {
+        return Encoder.encodeBytes(source, pos, limit, wrap, true);
     }
 
     /**
@@ -190,7 +302,22 @@ public static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wrap
      * @throws IOException if the encoding is invalid or corrupted
      */
     public static ByteBuffer decode(String source) throws IOException {
-        return Decoder.decode(source);
+        return Decoder.decode(source, false);
+    }
+
+    /**
+     * Decodes a Base64url encoded string into a new byte buffer. The returned byte buffer is a heap buffer,
+     * and it is therefor possible to retrieve the backing array using {@link java.nio.ByteBuffer#array()},
+     * {@link java.nio.ByteBuffer#arrayOffset()} and {@link java.nio.ByteBuffer#limit()}. The latter is very
+     * important since the decoded array may be larger than the decoded data. This is due to length estimation which
+     * avoids an unnecessary array copy.
+     *
+     * @param source the Base64 string to decode
+     * @return a byte buffer containing the decoded output
+     * @throws IOException if the encoding is invalid or corrupted
+     */
+    public static ByteBuffer decodeURL(String source) throws IOException {
+        return Decoder.decode(source, true);
     }
 
     /**
@@ -205,7 +332,23 @@ public static ByteBuffer decode(String source) throws IOException {
      * @throws IOException if the encoding is invalid or corrupted
      */
     public static ByteBuffer decode(ByteBuffer source) throws IOException {
-        return Decoder.decode(source);
+        return Decoder.decode(source, false);
+    }
+
+
+    /**
+     * Decodes a Base64url encoded byte buffer into a new byte buffer. The returned byte buffer is a heap buffer,
+     * and it is therefor possible to retrieve the backing array using {@link java.nio.ByteBuffer#array()},
+     * {@link java.nio.ByteBuffer#arrayOffset()} and {@link java.nio.ByteBuffer#limit()}. The latter is very
+     * important since the decoded array may be larger than the decoded data. This is due to length estimation which
+     * avoids an unnecessary array copy.
+     *
+     * @param source the Base64 content to decode
+     * @return a byte buffer containing the decoded output
+     * @throws IOException if the encoding is invalid or corrupted
+     */
+    public static ByteBuffer decodeURL(ByteBuffer source) throws IOException {
+        return Decoder.decode(source, true);
     }
 
 
@@ -223,9 +366,25 @@ public static ByteBuffer decode(ByteBuffer source) throws IOException {
      * @throws IOException if the encoding is invalid or corrupted
      */
     public static ByteBuffer decode(byte[] source, int off, int limit) throws IOException {
-        return Decoder.decode(source, off, limit);
+        return Decoder.decode(source, off, limit, false);
     }
 
+    /**
+     * Decodes a Base64url encoded byte array into a new byte buffer.  The returned byte buffer is a heap buffer,
+     * and it is therefor possible to retrieve the backing array using {@link java.nio.ByteBuffer#array()},
+     * {@link java.nio.ByteBuffer#arrayOffset()} and {@link java.nio.ByteBuffer#limit()}. The latter is very
+     * important since the decoded array may be larger than the decoded data. This is due to length estimation which
+     * avoids an unnecessary array copy.
+     *
+     * @param source the Base64url content to decode
+     * @param off position to start decoding from in source
+     * @param limit position to stop decoding in source (exclusive)
+     * @return a byte buffer containing the decoded output
+     * @throws IOException if the encoding is invalid or corrupted
+     */
+    public static ByteBuffer decodeURL(byte[] source, int off, int limit) throws IOException {
+        return Decoder.decode(source, off, limit, true);
+    }
 
     /**
      * Creates an InputStream wrapper which encodes a source into base64 as it is read, until the source hits EOF.
@@ -243,7 +402,7 @@ public static ByteBuffer decode(byte[] source, int off, int limit) throws IOExce
      * @return an encoded input stream instance.
      */
     public static EncoderInputStream createEncoderInputStream(InputStream source, int bufferSize, boolean wrap) {
-        return new EncoderInputStream(source, bufferSize, wrap);
+        return new EncoderInputStream(source, bufferSize, wrap, false);
     }
 
 
@@ -386,9 +545,12 @@ public static final class Encoder {
         private int count;
         private final boolean wrap;
         private int lastPos;
+        private final byte[] encodingTable;
+
 
-        private Encoder(boolean wrap) {
+        private Encoder(boolean wrap, boolean url) {
             this.wrap = wrap;
+            this.encodingTable = url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE;
         }
 
         /**
@@ -409,7 +571,7 @@ public void encode(ByteBuffer source, ByteBuffer target) {
             int state = this.state;
             boolean wrap = this.wrap;
             int count = this.count;
-            final byte[] ENCODING_TABLE = FlexBase64.ENCODING_TABLE;
+            final byte[] ENCODING_TABLE = encodingTable;
 
             int remaining = source.remaining();
             while (remaining > 0) {
@@ -496,7 +658,7 @@ public int encode(byte[] source, int pos, int limit, byte[] target, int opos, in
             int state = this.state;
             int count = this.count;
             boolean wrap = this.wrap;
-            final byte[] ENCODING_TABLE = FlexBase64.ENCODING_TABLE;
+            final byte[] ENCODING_TABLE = encodingTable;
 
 
             while (limit > pos) {
@@ -551,7 +713,7 @@ public int encode(byte[] source, int pos, int limit, byte[] target, int opos, in
         }
 
 
-        private static String encodeString(byte[] source, int pos, int limit, boolean wrap) {
+        private static String encodeString(byte[] source, int pos, int limit, boolean wrap, boolean url) {
             int olimit = (limit - pos);
             int remainder = olimit % 3;
             olimit = (olimit + (remainder == 0 ? 0 : 3 - remainder)) / 3 * 4;
@@ -561,7 +723,7 @@ private static String encodeString(byte[] source, int pos, int limit, boolean wr
             int last = 0;
             int count = 0;
             int state = 0;
-            final byte[] ENCODING_TABLE = FlexBase64.ENCODING_TABLE;
+            final byte[] ENCODING_TABLE = url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE;
 
             while (limit > pos) {
                 //  ( 6 | 2) (4 | 4) (2 | 6)
@@ -593,7 +755,7 @@ private static String encodeString(byte[] source, int pos, int limit, boolean wr
                 }
             }
 
-            complete(target, opos, state, last, wrap);
+            complete(target, opos, state, last, wrap, url);
 
             try {
                 // Eliminate copying on Open/Oracle JDK
@@ -606,7 +768,7 @@ private static String encodeString(byte[] source, int pos, int limit, boolean wr
             return new String(target);
         }
 
-        private static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wrap) {
+        private static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wrap, boolean url) {
             int olimit = (limit - pos);
             int remainder = olimit % 3;
             olimit = (olimit + (remainder == 0 ? 0 : 3 - remainder)) / 3 * 4;
@@ -616,7 +778,7 @@ private static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wra
             int count = 0;
             int last = 0;
             int state = 0;
-            final byte[] ENCODING_TABLE = FlexBase64.ENCODING_TABLE;
+            final byte[] ENCODING_TABLE = url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE;
 
             while (limit > pos) {
                 //  ( 6 | 2) (4 | 4) (2 | 6)
@@ -648,12 +810,12 @@ private static byte[] encodeBytes(byte[] source, int pos, int limit, boolean wra
                 }
             }
 
-            complete(target, opos, state, last, wrap);
+            complete(target, opos, state, last, wrap, url);
 
             return target;
         }
 
-        private static String encodeString(ByteBuffer source, boolean wrap) {
+        private static String encodeString(ByteBuffer source, boolean wrap, boolean url) {
             int remaining = source.remaining();
             int remainder = remaining % 3;
             int olimit = (remaining + (remainder == 0 ? 0 : 3 - remainder)) / 3 * 4;
@@ -663,7 +825,7 @@ private static String encodeString(ByteBuffer source, boolean wrap) {
             int last = 0;
             int state = 0;
             int count = 0;
-            final byte[] ENCODING_TABLE = FlexBase64.ENCODING_TABLE;
+            final byte[] ENCODING_TABLE = url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE;
 
 
             while (remaining > 0) {
@@ -697,7 +859,7 @@ private static String encodeString(ByteBuffer source, boolean wrap) {
                 }
             }
 
-            complete(target, opos, state, last, wrap);
+            complete(target, opos, state, last, wrap, url);
 
             try {
                 // Eliminate copying on Open/Oracle JDK
@@ -744,7 +906,7 @@ public int getLastInputPosition() {
          */
         public int complete(byte[] target, int pos) {
             if (state > 0) {
-                target[pos++] = ENCODING_TABLE[last];
+                target[pos++] = encodingTable[last];
                 for (int i = state; i < 3; i++) {
                     target[pos++] = (byte)'=';
                 }
@@ -759,9 +921,9 @@ public int complete(byte[] target, int pos) {
             return pos;
         }
 
-        private static int complete(char[] target, int pos, int state, int last, boolean wrap) {
+        private static int complete(char[] target, int pos, int state, int last, boolean wrap, boolean url) {
             if (state > 0) {
-                target[pos++] = (char) ENCODING_TABLE[last];
+                target[pos++] = (char) (url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE)[last];
                 for (int i = state; i < 3; i++) {
                     target[pos++] = '=';
                 }
@@ -774,9 +936,9 @@ private static int complete(char[] target, int pos, int state, int last, boolean
             return pos;
         }
 
-        private static int complete(byte[] target, int pos, int state, int last, boolean wrap) {
+        private static int complete(byte[] target, int pos, int state, int last, boolean wrap, boolean url) {
             if (state > 0) {
-                target[pos++] = ENCODING_TABLE[last];
+                target[pos++] = (url ? URL_ENCODING_TABLE : STANDARD_ENCODING_TABLE)[last];
                 for (int i = state; i < 3; i++) {
                     target[pos++] = '=';
                 }
@@ -798,7 +960,7 @@ private static int complete(byte[] target, int pos, int state, int last, boolean
          */
         public void complete(ByteBuffer target) {
             if (state > 0) {
-                target.put(ENCODING_TABLE[last]);
+                target.put(encodingTable[last]);
                 for (int i = state; i < 3; i++) {
                     target.put((byte)'=');
                 }
@@ -820,22 +982,25 @@ public static final class Decoder {
         private int state;
         private int last;
         private int lastPos;
+        private final byte[] decodingTable;
+
         private static final int SKIP = 0x0FD00;
         private static final int MARK = 0x0FE00;
         private static final int DONE = 0x0FF00;
         private static final int ERROR = 0xF0000;
 
 
 
-        private Decoder() {
+        private Decoder(boolean url) {
+            this.decodingTable = url ? URL_DECODING_TABLE : STANDARD_DECODING_TABLE;
         }
 
 
-        private static int nextByte(ByteBuffer buffer, int state, int last, boolean ignoreErrors) throws IOException {
+        private int nextByte(ByteBuffer buffer, int state, int last, boolean ignoreErrors) throws IOException {
             return nextByte(buffer.get() & 0xFF, state, last, ignoreErrors);
         }
 
-        private static int nextByte(Object source, int pos, int state, int last, boolean ignoreErrors) throws IOException {
+        private int nextByte(Object source, int pos, int state, int last, boolean ignoreErrors) throws IOException {
             int c;
             if (source instanceof byte[]) {
                 c = ((byte[])source)[pos] & 0xFF;
@@ -848,7 +1013,7 @@ private static int nextByte(Object source, int pos, int state, int last, boolean
             return nextByte(c, state, last, ignoreErrors);
         }
 
-        private static int nextByte(int c, int state, int last, boolean ignoreErrors) throws IOException {
+        private int nextByte(int c, int state, int last, boolean ignoreErrors) throws IOException {
             if (last == MARK) {
                 if (c != '=') {
                     throw new IOException(""Expected padding character"");
@@ -873,7 +1038,7 @@ private static int nextByte(int c, int state, int last, boolean ignoreErrors) th
                 }
                 throw new IOException(""Invalid base64 character encountered: "" + c);
             }
-            int b = (DECODING_TABLE[c - 43] & 0xFF) - 1;
+            int b = (decodingTable[c - 43] & 0xFF) - 1;
             if (b < 0) {
                 if (ignoreErrors) {
                     return ERROR;
@@ -976,7 +1141,7 @@ public void decode(ByteBuffer source, ByteBuffer target) throws IOException {
             this.lastPos = source.position();
         }
 
-        private static void drain(ByteBuffer source, int b, int state, int last) {
+        private void drain(ByteBuffer source, int b, int state, int last) {
             while (b != DONE && source.remaining() > 0) {
                 try {
                     b = nextByte(source, state, last, true);
@@ -1011,7 +1176,7 @@ private static void drain(ByteBuffer source, int b, int state, int last) {
             }
         }
 
-        private static int drain(Object source, int pos, int limit, int b, int state, int last) {
+        private int drain(Object source, int pos, int limit, int b, int state, int last) {
             while (b != DONE && limit > pos) {
                 try {
                     b = nextByte(source, pos++, state, last, true);
@@ -1239,29 +1404,29 @@ public int decode(byte[] source, int sourcePos, int sourceLimit, byte[] target,
             return decode((Object)source, sourcePos, sourceLimit, target, targetPos, targetLimit);
         }
 
-        private static ByteBuffer decode(String source) throws IOException {
+        private static ByteBuffer decode(String source, boolean url) throws IOException {
             int remainder = source.length() % 4;
             int size = ((source.length() / 4) + (remainder == 0 ? 0 : 4 - remainder)) * 3;
             byte[] buffer = new byte[size];
-            int actual = createDecoder().decode(source, 0, source.length(), buffer, 0, size);
+            int actual = new Decoder(url).decode(source, 0, source.length(), buffer, 0, size);
             return ByteBuffer.wrap(buffer, 0, actual);
         }
 
-        private static ByteBuffer decode(byte[] source, int off, int limit) throws IOException {
+        private static ByteBuffer decode(byte[] source, int off, int limit, boolean url) throws IOException {
             int len = limit - off;
             int remainder = len % 4;
             int size = ((len / 4) + (remainder == 0 ? 0 : 4 - remainder)) * 3;
             byte[] buffer = new byte[size];
-            int actual = createDecoder().decode(source, off, limit, buffer, 0, size);
+            int actual = new Decoder(url).decode(source, off, limit, buffer, 0, size);
             return ByteBuffer.wrap(buffer, 0, actual);
         }
 
-        private static ByteBuffer decode(ByteBuffer source) throws IOException {
+        private static ByteBuffer decode(ByteBuffer source, boolean url) throws IOException {
             int len = source.remaining();
             int remainder = len % 4;
             int size = ((len / 4) + (remainder == 0 ? 0 : 4 - remainder)) * 3;
             ByteBuffer buffer = ByteBuffer.allocate(size);
-            createDecoder().decode(source, buffer);
+            new Decoder(url).decode(source, buffer);
             buffer.flip();
             return buffer;
         }
@@ -1376,13 +1541,13 @@ public static class EncoderInputStream extends InputStream {
         private boolean complete;
 
         private EncoderInputStream(InputStream input) {
-            this(input, 8192, true);
+            this(input, 8192, true, false);
         }
 
-        private EncoderInputStream(InputStream input, int bufferSize, boolean wrap) {
+        private EncoderInputStream(InputStream input, int bufferSize, boolean wrap, boolean url) {
             this.input = input;
             buffer = new byte[bufferSize];
-            this.encoder = new Encoder(wrap);
+            this.encoder = new Encoder(wrap, url);
         }
 
         private int fill() throws IOException {",2015-07-17T08:00:36Z,350
"@@ -22,12 +22,14 @@
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
@@ -50,24 +52,50 @@ public static void main(final String[] args) {
         final Map<String, Class> examples = new HashMap<>();
         //hackz to discover all the example classes on the class path
         ZipInputStream in = null;
+        boolean fromJarFile = false;
         try {
-            String zipPath = url.getPath().substring(0, url.getPath().indexOf(""!"")).replace(""file:"", """");
-            in = new ZipInputStream(new FileInputStream(zipPath));
-            ZipEntry entry = in.getNextEntry();
-            while (entry != null) {
-                if (entry.getName().endsWith("".class"")) {
-                    String className = entry.getName().substring(0, entry.getName().length() - 6).replace(""/"", ""."");
-                    try {
-                        Class<?> clazz = Class.forName(className);
-                        UndertowExample example = clazz.getAnnotation(UndertowExample.class);
-                        if (example != null) {
-                            examples.put(example.value(), clazz);
+            String finalURIString = url.toString();
+            if(url.getPath().contains(""!"")) {
+                fromJarFile = true;
+                finalURIString = url.getPath().substring(0, url.getPath().indexOf(""!""));
+            }
+            if(fromJarFile) {
+                String zipPath = finalURIString.replace(""file:"", """");
+                in = new ZipInputStream(new FileInputStream(zipPath));
+                ZipEntry entry = in.getNextEntry();
+                while (entry != null) {
+                    if (entry.getName().endsWith("".class"")) {
+                        String className = entry.getName().substring(0, entry.getName().length() - 6).replace(""/"", ""."");
+                        try {
+                            Class<?> clazz = Class.forName(className);
+                            UndertowExample example = clazz.getAnnotation(UndertowExample.class);
+                            if (example != null) {
+                                examples.put(example.value(), clazz);
+                            }
+                        } catch (Throwable e) {
+                            //ignore
                         }
-                    } catch (Throwable e) {
-                        //ignore
                     }
+                    entry = in.getNextEntry();
+                }
+            }else  {
+                try {
+                    try (Stream<Path> paths = Files.walk(Paths.get(url.toURI()))) {
+                        Map<String, ? extends Class<?>> annotationMapping = paths
+                                .filter(Files::isRegularFile)
+                                .filter(path -> path.toFile().getName().endsWith("".class""))
+                                .map(Runner::toFileName)
+                                .map(fileName -> fileName.replace(""/"", "".""))
+                                .map(Runner::instance)
+                                .filter(Optional::isPresent)
+                                .filter(clazz -> clazz.get().getAnnotation(UndertowExample.class) != null)
+                                .collect(Collectors.toMap(clazz -> clazz.get().getAnnotation(UndertowExample.class).value(), Optional::get));
+                        examples.putAll(annotationMapping);
+                    }
+
+                } catch (URISyntaxException e) {
+                    e.printStackTrace();
                 }
-                entry = in.getNextEntry();
             }
 
             final List<String> names = new ArrayList<>(examples.keySet());
@@ -91,17 +119,26 @@ public static void main(final String[] args) {
             final Method main = exampleClass.getDeclaredMethod(""main"", String[].class);
             main.invoke(null, (Object)args);
 
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        } catch (InvocationTargetException e) {
-            throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
+        } catch (IOException | NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
             throw new RuntimeException(e);
         } finally {
             IoUtils.safeClose(in);
         }
 
     }
+
+    private static String toFileName(Path path) {
+        String pathName = path.toFile().getAbsolutePath();
+        int index = pathName.indexOf(""target/classes/"") + ""target/classes/"".length();
+        int classIndex = pathName.lastIndexOf("".class"");
+        return pathName.substring(index,classIndex);
+    }
+
+    private static Optional<Class<?>> instance(String clazz) {
+        try {
+            return Optional.ofNullable(Class.forName(clazz));
+        } catch (ClassNotFoundException e) {
+            return Optional.empty();
+        }
+    }
 }",2018-12-26T06:48:19Z,280
"@@ -24,7 +24,6 @@
 import io.undertow.security.api.AuthenticationMode;
 import io.undertow.security.api.NotificationReceiver;
 import io.undertow.security.api.SecurityContextFactory;
-import io.undertow.security.handlers.AuthenticationCallHandler;
 import io.undertow.security.handlers.AuthenticationMechanismsHandler;
 import io.undertow.security.handlers.NotificationReceiverHandler;
 import io.undertow.security.handlers.SecurityInitialHandler;
@@ -74,6 +73,7 @@
 import io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler;
 import io.undertow.servlet.handlers.security.SSLInformationAssociationHandler;
 import io.undertow.servlet.handlers.security.SecurityPathMatches;
+import io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler;
 import io.undertow.servlet.handlers.security.ServletAuthenticationConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletFormAuthenticationMechanism;
@@ -286,7 +286,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
         current = new SSLInformationAssociationHandler(current);
 
         final SecurityPathMatches securityPathMatches = buildSecurityConstraints();
-        current = new AuthenticationCallHandler(current);
+        current = new ServletAuthenticationCallHandler(current);
         if (!securityPathMatches.isEmpty()) {
             current = new ServletAuthenticationConstraintHandler(current);
         }",2014-03-09T20:41:41Z,80
"@@ -0,0 +1,68 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.servlet.handlers.security;
+
+import io.undertow.security.api.SecurityContext;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.servlet.handlers.ServletRequestContext;
+
+/**
+ * This is the final {@link io.undertow.server.HttpHandler} in the security chain, it's purpose is to act as a barrier at the end of the chain to
+ * ensure authenticate is called after the mechanisms have been associated with the context and the constraint checked.
+ *
+ * This handler uses the Servlet {@link javax.servlet.http.HttpServletResponse#sendError(int)} method to make
+ * sure the correct error page is displayed.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public class ServletAuthenticationCallHandler implements HttpHandler {
+
+    private final HttpHandler next;
+
+    public ServletAuthenticationCallHandler(final HttpHandler next) {
+        this.next = next;
+    }
+
+    /**
+     * Only allow the request through if successfully authenticated or if authentication is not required.
+     *
+     * @see io.undertow.server.HttpHandler#handleRequest(io.undertow.server.HttpServerExchange)
+     */
+    @Override
+    public void handleRequest(final HttpServerExchange exchange) throws Exception {
+        if(exchange.isInIoThread()) {
+            exchange.dispatch(this);
+            return;
+        }
+        SecurityContext context = exchange.getSecurityContext();
+        if (context.authenticate()) {
+            if(!exchange.isComplete()) {
+               next.handleRequest(exchange);
+            }
+        } else {
+            if(exchange.getResponseCode() >= 400 && !exchange.isComplete()) {
+                ServletRequestContext src = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
+                src.getOriginalResponse().sendError(exchange.getResponseCode());
+            } else {
+                exchange.endExchange();
+            }
+        }
+    }
+
+}",2014-03-09T20:41:41Z,351
"@@ -0,0 +1,9 @@
+package io.undertow.servlet.test.errorpage;
+
+import javax.servlet.http.HttpServlet;
+
+/**
+ * @author Stuart Douglas
+ */
+public class SecureServlet extends HttpServlet {
+}",2014-03-09T20:41:41Z,352
"@@ -0,0 +1,89 @@
+package io.undertow.servlet.test.errorpage;
+
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.servlet.Servlets;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.ErrorPage;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.api.ServletStackTraces;
+import io.undertow.servlet.test.security.constraint.ServletIdentityManager;
+import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.servlet.ServletException;
+import java.io.IOException;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class SecurityErrorPageTestCase {
+
+
+    @BeforeClass
+    public static void setup() throws IOException, ServletException {
+
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+        final PathHandler root = new PathHandler();
+        DefaultServer.setRootHandler(root);
+
+        DeploymentInfo builder = new DeploymentInfo();
+
+        builder.addServlet(new ServletInfo(""secure"", SecureServlet.class)
+                .addMapping(""/secure""))
+                .addSecurityConstraint(Servlets.securityConstraint().addRoleAllowed(""user"").addWebResourceCollection(Servlets.webResourceCollection().addUrlPattern(""/*"")));
+
+        builder.addServlet(new ServletInfo(""path"", PathServlet.class)
+                .addMapping(""/*""));
+
+        builder.addErrorPage(new ErrorPage(""/401"", 401));
+
+        ServletIdentityManager identityManager = new ServletIdentityManager();
+        identityManager.addUser(""user1"", ""password1""); // Just one role less user.
+
+        builder.setClassIntrospecter(TestClassIntrospector.INSTANCE)
+                .setClassLoader(ErrorPageTestCase.class.getClassLoader())
+                .setContextPath(""/servletContext"")
+                .setServletStackTraces(ServletStackTraces.NONE)
+                .setIdentityManager(identityManager)
+                .setLoginConfig(Servlets.loginConfig(""BASIC"", ""Test Realm""))
+                .setDeploymentName(""servletContext.war"");
+
+        final DeploymentManager manager1 = container.addDeployment(builder);
+        manager1.deploy();
+        root.addPrefixPath(builder.getContextPath(), manager1.start());
+
+    }
+
+
+    @Test
+    public void testErrorPages() throws IOException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            runTest(client, 401, ""/401"");
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    private void runTest(final TestHttpClient client, int statusCode, String expected) throws IOException {
+        final HttpGet get;
+        final HttpResponse result;
+        final String response;
+        get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/secure"");
+        result = client.execute(get);
+        Assert.assertEquals(statusCode, result.getStatusLine().getStatusCode());
+        response = HttpClientUtils.readResponse(result);
+        Assert.assertEquals(expected, response);
+    }
+}",2014-03-09T20:41:41Z,207
"@@ -89,7 +89,7 @@ public interface UndertowMessages {
 //    @Message(id = 16, value = ""Could not add cookie as cookie handler was not present in the handler chain"")
 //    IllegalStateException cookieHandlerNotPresent();
 
-    @Message(id = 17, value = ""Form value is a file, use getFile() instead"")
+    @Message(id = 17, value = ""Form value is a file, use getFileItem() instead"")
     IllegalStateException formValueIsAFile();
 
     @Message(id = 18, value = ""Form value is a String, use getValue() instead"")
@@ -594,4 +594,7 @@ public interface UndertowMessages {
 
     @Message(id = 191, value = ""Default context cannot be null"")
     IllegalStateException defaultContextCannotBeNull();
+
+    @Message(id = 192, value = ""Form value is a in-memory file, use getFileItem() instead"")
+    IllegalStateException formValueIsInMemoryFile();
 }",2018-08-29T05:36:11Z,68
"@@ -174,7 +174,7 @@ private void dumpRequestBody(HttpServerExchange exchange, StringBuilder sb) {
                     sb.append(formField)
                             .append(""="");
                     for (FormData.FormValue formValue : formValues) {
-                        sb.append(formValue.isFile() ? ""[file-content]"" : formValue.getValue());
+                        sb.append(formValue.isFileItem() ? ""[file-content]"" : formValue.getValue());
                         sb.append(""\n"");
 
                         if (formValue.getHeaders() != null) {",2018-08-29T05:36:11Z,35
"@@ -18,7 +18,13 @@
 
 package io.undertow.server.handlers.form;
 
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -64,6 +70,17 @@ public Deque<FormValue> get(String name) {
         return values.get(name);
     }
 
+    public void add(String name, byte[] value, String fileName, HeaderMap headers) {
+        Deque<FormValue> values = this.values.get(name);
+        if (values == null) {
+            this.values.put(name, values = new ArrayDeque<>(1));
+        }
+        values.add(new FormValueImpl(value, fileName, headers));
+        if (++valueCount > maxValues) {
+            throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(maxValues));
+        }
+    }
+
     public void add(String name, String value) {
         add(name, value, null);
     }
@@ -157,17 +174,24 @@ public interface FormValue {
          *
          * @return
          */
+        @Deprecated
         boolean isFile();
 
         /**
          * @return The temp file that the file data was saved to
+         *
          * @throws IllegalStateException if this is not a file
          */
+        @Deprecated
         Path getPath();
 
         @Deprecated
         File getFile();
 
+        FileItem getFileItem();
+
+        boolean isFileItem();
+
         /**
          * @return The filename specified in the disposition header.
          */
@@ -181,28 +205,95 @@ public interface FormValue {
 
     }
 
+    public static class FileItem {
+        private final Path file;
+        private final byte[] content;
+
+        public FileItem(Path file) {
+            this.file = file;
+            this.content = null;
+        }
+
+        public FileItem(byte[] content) {
+            this.file = null;
+            this.content = content;
+        }
+
+        public boolean isInMemory() {
+            return file == null;
+        }
+
+        public Path getFile() {
+            return file;
+        }
+
+        public long getFileSize() throws IOException {
+            if (isInMemory()) {
+                return content.length;
+            } else {
+                return Files.size(file);
+            }
+        }
+
+        public InputStream getInputStream() throws IOException {
+            if (file != null) {
+                return new BufferedInputStream(Files.newInputStream(file));
+            } else {
+                return new ByteArrayInputStream(content);
+            }
+        }
+
+        public void delete() throws IOException {
+            if (file != null) {
+                try {
+                    Files.delete(file);
+                } catch (NoSuchFileException e) { //already deleted
+                }
+            }
+        }
+
+        public void write(Path target) throws IOException {
+            if (file != null) {
+                try {
+                    Files.move(file, target);
+                } catch (IOException e) {
+                    Files.copy(getInputStream(), target);
+                }
+            } else {
+                Files.copy(getInputStream(), target);
+            }
+        }
+    }
+
 
     static class FormValueImpl implements FormValue {
 
         private final String value;
         private final String fileName;
-        private final Path file;
         private final HeaderMap headers;
+        private final FileItem fileItem;
 
         FormValueImpl(String value, HeaderMap headers) {
             this.value = value;
             this.headers = headers;
-            this.file = null;
             this.fileName = null;
+            this.fileItem = null;
         }
 
         FormValueImpl(Path file, final String fileName, HeaderMap headers) {
-            this.file = file;
+            this.fileItem = new FileItem(file);
             this.headers = headers;
             this.fileName = fileName;
             this.value = null;
         }
 
+        FormValueImpl(byte[] data, String fileName, HeaderMap headers) {
+            this.fileItem = new FileItem(data);
+            this.fileName = fileName;
+            this.headers = headers;
+            this.value = null;
+        }
+
 
         @Override
         public String getValue() {
@@ -214,22 +305,38 @@ public String getValue() {
 
         @Override
         public boolean isFile() {
-            return file != null;
+            return fileItem != null && !fileItem.isInMemory();
         }
 
         @Override
         public Path getPath() {
-            if (file == null) {
+            if (fileItem == null) {
                 throw UndertowMessages.MESSAGES.formValueIsAString();
             }
-            return file;
+            if (fileItem.isInMemory()) {
+                throw UndertowMessages.MESSAGES.formValueIsInMemoryFile();
+            }
+            return fileItem.getFile();
         }
 
         @Override
         public File getFile() {
             return getPath().toFile();
         }
 
+        @Override
+        public FileItem getFileItem() {
+            if (fileItem == null) {
+                throw UndertowMessages.MESSAGES.formValueIsAString();
+            }
+            return fileItem;
+        }
+
+        @Override
+        public boolean isFileItem() {
+            return fileItem != null;
+        }
+
         @Override
         public HeaderMap getHeaders() {
             return headers;",2018-08-29T05:36:11Z,340
"@@ -36,6 +36,7 @@
 import org.xnio.channels.StreamSourceChannel;
 
 import java.io.ByteArrayOutputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
@@ -48,6 +49,7 @@
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Executor;
 
@@ -66,6 +68,8 @@ public class MultiPartParserDefinition implements FormParserFactory.ParserDefini
 
     private long maxIndividualFileSize = -1;
 
+    private long fileSizeThreshold;
+
     public MultiPartParserDefinition() {
         tempFileLocation = Paths.get(System.getProperty(""java.io.tmpdir""));
     }
@@ -83,7 +87,7 @@ public FormDataParser create(final HttpServerExchange exchange) {
                 UndertowLogger.REQUEST_LOGGER.debugf(""Could not find boundary in multipart request with ContentType: %s, multipart data will not be available"", mimeType);
                 return null;
             }
-            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, defaultEncoding);
+            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, fileSizeThreshold, defaultEncoding);
             exchange.addExchangeCompleteListener(new ExchangeCompletionListener() {
                 @Override
                 public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
@@ -138,12 +142,17 @@ public void setMaxIndividualFileSize(final long maxIndividualFileSize) {
         this.maxIndividualFileSize = maxIndividualFileSize;
     }
 
+    public void setFileSizeThreshold(long fileSizeThreshold) {
+        this.fileSizeThreshold = fileSizeThreshold;
+    }
+
     private final class MultiPartUploadHandler implements FormDataParser, MultipartParser.PartHandler {
 
         private final HttpServerExchange exchange;
         private final FormData data;
         private final List<Path> createdFiles = new ArrayList<>();
         private final long maxIndividualFileSize;
+        private final long fileSizeThreshold;
         private String defaultEncoding;
 
         private final ByteArrayOutputStream contentBytes = new ByteArrayOutputStream();
@@ -157,10 +166,11 @@ private final class MultiPartUploadHandler implements FormDataParser, MultipartP
         private final MultipartParser.ParseState parser;
 
 
-        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final String defaultEncoding) {
+        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final long fileSizeThreshold, final String defaultEncoding) {
             this.exchange = exchange;
             this.maxIndividualFileSize = maxIndividualFileSize;
             this.defaultEncoding = defaultEncoding;
+            this.fileSizeThreshold = fileSizeThreshold;
             this.data = new FormData(exchange.getConnection().getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, 1000));
             String charset = defaultEncoding;
             String contentType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
@@ -238,7 +248,7 @@ public void beginPart(final HeaderMap headers) {
                 if (disposition.startsWith(""form-data"")) {
                     currentName = Headers.extractQuotedValueFromHeader(disposition, ""name"");
                     fileName = Headers.extractQuotedValueFromHeaderWithEncoding(disposition, ""filename"");
-                    if (fileName != null) {
+                    if (fileName != null && fileSizeThreshold == 0) {
                         try {
                             if (tempFileLocation != null) {
                                 file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
@@ -261,6 +271,24 @@ public void data(final ByteBuffer buffer) throws IOException {
             if (this.maxIndividualFileSize > 0 && this.currentFileSize > this.maxIndividualFileSize) {
                 throw UndertowMessages.MESSAGES.maxFileSizeExceeded(this.maxIndividualFileSize);
             }
+            if (file == null && fileName != null && fileSizeThreshold < this.currentFileSize) {
+                try {
+                    if (tempFileLocation != null) {
+                        file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
+                    } else {
+                        file = Files.createTempFile(""undertow"", ""upload"");
+                    }
+                    createdFiles.add(file);
+
+                    FileOutputStream fileOutputStream = new FileOutputStream(file.toFile());
+                    contentBytes.writeTo(fileOutputStream);
+
+                    fileChannel = fileOutputStream.getChannel();
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
             if (file == null) {
                 while (buffer.hasRemaining()) {
                     contentBytes.write(buffer.get());
@@ -275,12 +303,16 @@ public void endPart() {
             if (file != null) {
                 data.add(currentName, file, fileName, headers);
                 file = null;
+                contentBytes.reset();
                 try {
                     fileChannel.close();
                     fileChannel = null;
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
+            } else if (fileName != null) {
+                data.add(currentName, Arrays.copyOf(contentBytes.toByteArray(), contentBytes.size()), fileName, headers);
+                contentBytes.reset();
             } else {
 
 ",2018-08-29T05:36:11Z,119
"@@ -18,15 +18,21 @@
 
 package io.undertow.server.handlers.form;
 
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.BlockingHandler;
-import io.undertow.testutils.DefaultServer;
-import io.undertow.testutils.HttpClientUtils;
-import io.undertow.testutils.TestHttpClient;
-import io.undertow.util.Headers;
-import io.undertow.util.StatusCodes;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
@@ -40,9 +46,15 @@
 import org.junit.runner.RunWith;
 import org.xnio.IoUtils;
 
-import java.io.File;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.HeaderValues;
+import io.undertow.util.Headers;
+import io.undertow.util.StatusCodes;
 
 /**
  * @author Stuart Douglas
@@ -54,12 +66,9 @@ private static HttpHandler createHandler() {
         return new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {
-                System.out.println(""In handler"");
                 final FormDataParser parser = FormParserFactory.builder().build().createParser(exchange);
-                System.out.println(""Created parser"");
                 try {
                     FormData data = parser.parseBlocking();
-                    System.out.println(""done parsing"");
                     exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
                     if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
                         FormData.FormValue file = data.getFirst(""file"");
@@ -189,4 +198,172 @@ public void testFileUploadWithEagerParsingAndNonASCIIFilename() throws Exception
             client.getConnectionManager().shutdown();
         }
     }
+
+    private static HttpHandler createInMemoryReadingHandler(final long fileSizeThreshold) {
+        return new HttpHandler() {
+            @Override
+            public void handleRequest(final HttpServerExchange exchange) throws Exception {
+                MultiPartParserDefinition multiPartParserDefinition = new MultiPartParserDefinition();
+                multiPartParserDefinition.setFileSizeThreshold(fileSizeThreshold);
+                final FormDataParser parser = FormParserFactory.builder(false)
+                        .addParsers(new FormEncodedDataDefinition(), multiPartParserDefinition)
+                        .build().createParser(exchange);
+                try {
+                    FormData data = parser.parseBlocking();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
+                        FormData.FormValue file = data.getFirst(""file"");
+                        if (file.isFileItem()) {
+                            exchange.setStatusCode(StatusCodes.OK);
+                            logResult(exchange, file.getFileItem().isInMemory(), file.getFileName(), stream2String(file));
+                        }
+                    }
+                    exchange.endExchange();
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    exchange.endExchange();
+                } finally {
+                    IoUtils.safeClose(parser);
+                }
+            }
+
+            private String stream2String(FormData.FormValue file) throws IOException {
+                try (InputStream is = file.getFileItem().getInputStream()) {
+                    StringWriter sw = new StringWriter();
+                    IOUtils.copy(is, sw, ""UTF-8"");
+                    return sw.toString();
+                }
+            }
+
+            private String getFileName(FormData.FormValue data) {
+                HeaderValues cdHeaders = data.getHeaders().get(""content-disposition"");
+                for (String cdHeader : cdHeaders) {
+                    if (cdHeader.startsWith(""form-data"")) {
+                        return cdHeader.substring(cdHeader.indexOf(""filename="") + ""filename="".length()).replace(""\"""", """");
+                    }
+                }
+                return null;
+            }
+
+            private void logResult(HttpServerExchange exchange, boolean inMemory, String fileName, String content) throws IOException {
+                String res = String.format(""in_memory:%s;file_name:%s;hash:%s"", inMemory, fileName, DigestUtils.md5Hex(content));
+                final OutputStream outputStream = exchange.getOutputStream();
+                outputStream.write(res.getBytes());
+                outputStream.close();
+            }
+        };
+    }
+
+    @Test
+    public void testFileUploadWithSmallFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithLargeFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10_000)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""true"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithMediumFileSizeThresholdAndLargeFile() throws Exception {
+        int fileSizeThreshold = 1000;
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(fileSizeThreshold)));
+
+        TestHttpClient client = new TestHttpClient();
+        File file = new File(""tmp_upload_file.txt"");
+        file.createNewFile();
+        try {
+            writeLargeFileContent(file, fileSizeThreshold * 2);
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(file));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""tmp_upload_file.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(file)), parsedResponse.get(""hash""));
+
+        } finally {
+            file.delete();
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    private void writeLargeFileContent(File file, int size) throws IOException {
+        int textLength = ""content"".getBytes().length;
+        FileOutputStream fos = new FileOutputStream(file);
+        for (int i = 0; i < size / textLength; i++) {
+            fos.write(""content"".getBytes());
+        }
+        fos.flush();
+        fos.close();
+    }
+
+    private Map<String, String> parse(String resp) {
+        Map<String, String> parsed = new HashMap<>();
+
+        String[] split = resp.split("";"");
+        for (String s : split) {
+            String[] pair = s.split("":"");
+            parsed.put(pair[0], pair[1]);
+        }
+
+        return parsed;
+    }
 }",2018-08-29T05:36:11Z,19
"@@ -112,6 +112,9 @@ public void setupMultipart(ServletContextImpl servletContext) {
             if(config.getMaxFileSize() > 0) {
                 multiPartParserDefinition.setMaxIndividualFileSize(config.getMaxFileSize());
             }
+            if (config.getFileSizeThreshold() > 0) {
+                multiPartParserDefinition.setFileSizeThreshold(config.getFileSizeThreshold());
+            }
             multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultRequestCharset().name());
 
             formParserFactory = FormParserFactory.builder(false)",2018-08-29T05:36:11Z,113
"@@ -705,7 +705,7 @@ public String getParameter(final String name) {
             final FormData parsedFormData = parseFormData();
             if (parsedFormData != null) {
                 FormData.FormValue res = parsedFormData.getFirst(name);
-                if (res == null || res.isFile()) {
+                if (res == null || res.isFileItem()) {
                     return null;
                 } else {
                     return res.getValue();
@@ -729,7 +729,7 @@ public Enumeration<String> getParameterNames() {
                 while (it.hasNext()) {
                     String name = it.next();
                     for(FormData.FormValue param : parsedFormData.get(name)) {
-                        if(!param.isFile()) {
+                        if(!param.isFileItem()) {
                             parameterNames.add(name);
                             break;
                         }
@@ -758,7 +758,7 @@ public String[] getParameterValues(final String name) {
                 Deque<FormData.FormValue> res = parsedFormData.get(name);
                 if (res != null) {
                     for (FormData.FormValue value : res) {
-                        if(!value.isFile()) {
+                        if(!value.isFileItem()) {
                             ret.add(value.getValue());
                         }
                     }
@@ -791,14 +791,14 @@ public Map<String, String[]> getParameterMap() {
                     if (arrayMap.containsKey(name)) {
                         ArrayList<String> existing = arrayMap.get(name);
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 existing.add(v.getValue());
                             }
                         }
                     } else {
                         final ArrayList<String> values = new ArrayList<>();
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 values.add(v.getValue());
                             }
                         }",2018-08-29T05:36:11Z,147
"@@ -24,12 +24,9 @@
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 
-import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.file.Files;
-import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Collection;
@@ -62,8 +59,8 @@ public PartImpl(final String name, final FormData.FormValue formValue, Multipart
 
     @Override
     public InputStream getInputStream() throws IOException {
-        if (formValue.isFile()) {
-            return new BufferedInputStream(Files.newInputStream(formValue.getPath()));
+        if (formValue.isFileItem()) {
+            return formValue.getFileItem().getInputStream();
         } else {
             String requestedCharset = servletRequest.getCharacterEncoding();
             String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultRequestCharset().name();
@@ -89,8 +86,8 @@ public String getSubmittedFileName() {
     @Override
     public long getSize() {
         try {
-            if (formValue.isFile()) {
-                return Files.size(formValue.getPath());
+            if (formValue.isFileItem()) {
+                return formValue.getFileItem().getFileSize();
             } else {
                 return formValue.getValue().length();
             }
@@ -109,20 +106,19 @@ public void write(final String fileName) throws IOException {
                 target = Paths.get(config.getLocation(), fileName);
             }
         }
-        try {
-            Files.move(formValue.getPath(), target);
-        } catch (IOException e) {
-            Files.copy(formValue.getPath(), target);
+        if (formValue.isFileItem()) {
+            formValue.getFileItem().write(target);
         }
     }
 
     @Override
     public void delete() throws IOException {
-        try {
-            Files.delete(formValue.getPath());
-        } catch (NoSuchFileException e) { //already deleted
-        } catch (IOException e) {
-            throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+        if (formValue.isFileItem()) {
+            try {
+                formValue.getFileItem().delete();
+            } catch (IOException e) {
+                throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+            }
         }
     }
 ",2018-08-29T05:36:11Z,269
"@@ -231,6 +231,21 @@ public void run() {
         }
     }
 
+    private void runWriteListener() {
+        try {
+            delegate.getIoThread().execute(new Runnable() {
+                @Override
+                public void run() {
+                    writeReadyHandler.writeReady();
+                }
+            });
+        } catch (Exception e) {
+            //will only happen on shutdown
+            IoUtils.safeClose(connection, delegate);
+            UndertowLogger.REQUEST_IO_LOGGER.debugf(e, ""Failed to queue read listener invocation"");
+        }
+    }
+
     @Override
     public boolean isReadResumed() {
         return anyAreSet(state, FLAG_READS_RESUMED);
@@ -522,23 +537,39 @@ void notifyWriteClosed() {
         if(anyAreSet(state, FLAG_WRITE_CLOSED)) {
             return;
         }
+        boolean runListener = isWriteResumed() && anyAreSet(state, FLAG_CLOSED);
         connection.writeClosed();
         state |= FLAG_WRITE_CLOSED;
         if(anyAreSet(state, FLAG_READ_CLOSED)) {
             closed();
         }
+        if(anyAreSet(state, FLAG_READ_REQUIRES_WRITE)) {
+            notifyReadClosed();
+        }
+        state &= ~FLAG_WRITE_REQUIRES_READ;
+        //unclean shutdown, run the listener
+        if(runListener) {
+            runWriteListener();
+        }
     }
 
     void notifyReadClosed() {
         if(anyAreSet(state, FLAG_READ_CLOSED)) {
             return;
         }
+        boolean runListener = isReadResumed() && anyAreSet(state, FLAG_CLOSED);
         connection.readClosed();
 
         state |= FLAG_READ_CLOSED;
         if(anyAreSet(state, FLAG_WRITE_CLOSED)) {
             closed();
         }
+        if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ)) {
+            notifyWriteClosed();
+        }
+        if(runListener) {
+            runReadListener();
+        }
     }
 
     public void startHandshake() throws SSLException {
@@ -597,22 +628,25 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
         }
         try {
             //try and read some data if we don't already have some
-            if(allAreClear(state, FLAG_DATA_TO_UNWRAP)) {
-                if(dataToUnwrap == null) {
-                    dataToUnwrap = bufferPool.allocate();
+            final boolean noData = allAreClear(state, FLAG_DATA_TO_UNWRAP);
+            if(noData || this.dataToUnwrap.getResource().limit() < this.dataToUnwrap.getResource().capacity()) {
+                if(!noData) {
+                    this.dataToUnwrap.getResource().compact();
+                } else if(this.dataToUnwrap == null) {
+                    this.dataToUnwrap = bufferPool.allocate();
                 }
                 int res;
                 try {
-                    res = source.read(dataToUnwrap.getResource());
+                    res = source.read(this.dataToUnwrap.getResource());
                 } catch (IOException e) {
-                    dataToUnwrap.free();
-                    dataToUnwrap = null;
+                    this.dataToUnwrap.free();
+                    this.dataToUnwrap = null;
                     throw e;
                 }
-                dataToUnwrap.getResource().flip();
+                this.dataToUnwrap.getResource().flip();
                 if(res == -1) {
-                    dataToUnwrap.free();
-                    dataToUnwrap = null;
+                    this.dataToUnwrap.free();
+                    this.dataToUnwrap = null;
                     notifyReadClosed();
                     return -1;
                 } else if(res == 0 && engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
@@ -630,15 +664,15 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
             boolean unwrapBufferUsed = false;
             try {
                 if (userBuffers != null) {
-                    result = engine.unwrap(dataToUnwrap.getResource(), userBuffers, off, len);
+                    result = engine.unwrap(this.dataToUnwrap.getResource(), userBuffers, off, len);
                     if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                         //not enough space in the user buffers
                         //we use our own
                         unwrappedData = bufferPool.allocate();
                         ByteBuffer[] d = new ByteBuffer[len + 1];
                         System.arraycopy(userBuffers, off, d, 0, len);
                         d[len] = unwrappedData.getResource();
-                        result = engine.unwrap(dataToUnwrap.getResource(), d);
+                        result = engine.unwrap(this.dataToUnwrap.getResource(), d);
                         unwrapBufferUsed = true;
                     }
                 } else {
@@ -648,7 +682,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                     } else {
                         unwrappedData.getResource().compact();
                     }
-                    result = engine.unwrap(dataToUnwrap.getResource(), unwrappedData.getResource());
+                    result = engine.unwrap(this.dataToUnwrap.getResource(), unwrappedData.getResource());
                 }
             } finally {
                 if(unwrapBufferUsed) {
@@ -662,7 +696,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
             }
 
             if (!handleHandshakeResult(result)) {
-                if(dataToUnwrap.getResource().hasRemaining()) {
+                if(this.dataToUnwrap.getResource().hasRemaining()) {
                     state |= FLAG_DATA_TO_UNWRAP;
                 }
                 return 0;
@@ -675,7 +709,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                 state &= ~FLAG_DATA_TO_UNWRAP;
             } else if(result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                 throw new IOException(""overflow""); //todo: handle properly
-            } else if(dataToUnwrap.getResource().hasRemaining()) {
+            } else if(this.dataToUnwrap.getResource().hasRemaining()) {
                 state |= FLAG_DATA_TO_UNWRAP;
             }
             if(userBuffers == null) {",2015-06-04T14:32:31Z,185
"@@ -40,6 +40,7 @@
 import org.junit.runner.RunWith;
 import org.xnio.BufferAllocator;
 import org.xnio.ByteBufferSlicePool;
+import org.xnio.IoFuture;
 import org.xnio.OptionMap;
 import org.xnio.Options;
 import org.xnio.Pool;
@@ -57,6 +58,7 @@
 import io.undertow.websockets.core.WebSocketFrameType;
 import io.undertow.websockets.core.protocol.server.AutobahnWebSocketServer;
 
+
 /**
  * @author Stuart Douglas
  */
@@ -152,6 +154,44 @@ protected void onError(WebSocketChannel channel, Throwable error) {
         webSocketChannel.sendClose();
     }
 
+    @Test
+    public void testTextMessageWss() throws Exception {
+
+        UndertowXnioSsl ssl = new UndertowXnioSsl(Xnio.getInstance(), OptionMap.EMPTY, DefaultServer.getClientSSLContext());
+        final WebSocketClient.ConnectionBuilder connectionBuilder = WebSocketClient.connectionBuilder(worker, buffer, new URI(""wss://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostSSLPort(""default"")))
+                .setSsl(ssl);
+        IoFuture<WebSocketChannel> future = connectionBuilder.connect();
+        future.await(4, TimeUnit.SECONDS);
+        final WebSocketChannel webSocketChannel = future.get();
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<String> result = new AtomicReference<>();
+        webSocketChannel.getReceiveSetter().set(new AbstractReceiveListener() {
+            @Override
+            protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) throws IOException {
+                String data = message.getData();
+                result.set(data);
+                latch.countDown();
+            }
+
+            @Override
+            protected void onError(WebSocketChannel channel, Throwable error) {
+                super.onError(channel, error);
+                error.printStackTrace();
+                latch.countDown();
+            }
+        });
+        webSocketChannel.resumeReceives();
+
+
+        StreamSinkFrameChannel sendChannel = webSocketChannel.send(WebSocketFrameType.TEXT, 11);
+        new StringWriteChannelListener(""Hello World"").setup(sendChannel);
+
+        latch.await(10, TimeUnit.SECONDS);
+        Assert.assertEquals(""Hello World"", result.get());
+        webSocketChannel.sendClose();
+    }
+
     @Test
     @ProxyIgnore
     public void testMessageViaProxy() throws Exception {
@@ -194,6 +234,7 @@ protected void onError(WebSocketChannel channel, Throwable error) {
     @ProxyIgnore
     public void testMessageViaWssProxy() throws Exception {
 
+
         final WebSocketChannel webSocketChannel = WebSocketClient.connectionBuilder(worker, buffer, new URI(DefaultServer.getDefaultServerSSLAddress()))
                 .setSsl(new UndertowXnioSsl(Xnio.getInstance(), OptionMap.EMPTY, DefaultServer.getClientSSLContext()))
                 .setProxyUri(new URI(""http"", null, DefaultServer.getHostAddress(""default""), DefaultServer.getHostPort(""default"") + 10, ""/proxy"", null, null))",2015-06-04T14:32:31Z,343
"@@ -379,4 +379,7 @@ public interface UndertowMessages {
 
     @Message(id = 117, value = ""Request was not a CONNECT request"")
     IllegalStateException notAConnectRequest();
+
+    @Message(id = 118, value = ""Cannot reset buffer, response has already been commited"")
+    IllegalStateException cannotResetBuffer();
 }",2014-12-30T07:43:33Z,68
"@@ -68,6 +68,26 @@ public UndertowOutputStream(HttpServerExchange exchange) {
         this.contentLength = exchange.getResponseContentLength();
     }
 
+
+    /**
+     * If the response has not yet been written to the client this method will clear the streams buffer,
+     * invalidating any content that has already been written. If any content has already been sent to the client then
+     * this method will throw and IllegalStateException
+     *
+     * @throws java.lang.IllegalStateException If the response has been commited
+     */
+    public void resetBuffer() {
+        if(anyAreSet(state, FLAG_WRITE_STARTED)) {
+            throw UndertowMessages.MESSAGES.cannotResetBuffer();
+        }
+        if(pooledBuffer != null) {
+            pooledBuffer.free();
+            pooledBuffer = null;
+        }
+
+    }
+
+
     /**
      * {@inheritDoc}
      */",2014-12-30T07:43:33Z,353
"@@ -89,7 +89,7 @@ public interface UndertowMessages {
 //    @Message(id = 16, value = ""Could not add cookie as cookie handler was not present in the handler chain"")
 //    IllegalStateException cookieHandlerNotPresent();
 
-    @Message(id = 17, value = ""Form value is a file, use getFile() instead"")
+    @Message(id = 17, value = ""Form value is a file, use getFileItem() instead"")
     IllegalStateException formValueIsAFile();
 
     @Message(id = 18, value = ""Form value is a String, use getValue() instead"")
@@ -594,4 +594,7 @@ public interface UndertowMessages {
 
     @Message(id = 191, value = ""Default context cannot be null"")
     IllegalStateException defaultContextCannotBeNull();
+
+    @Message(id = 192, value = ""Form value is a in-memory file, use getFileItem() instead"")
+    IllegalStateException formValueIsInMemoryFile();
 }",2018-08-29T05:36:11Z,68
"@@ -174,7 +174,7 @@ private void dumpRequestBody(HttpServerExchange exchange, StringBuilder sb) {
                     sb.append(formField)
                             .append(""="");
                     for (FormData.FormValue formValue : formValues) {
-                        sb.append(formValue.isFile() ? ""[file-content]"" : formValue.getValue());
+                        sb.append(formValue.isFileItem() ? ""[file-content]"" : formValue.getValue());
                         sb.append(""\n"");
 
                         if (formValue.getHeaders() != null) {",2018-08-29T05:36:11Z,35
"@@ -18,7 +18,13 @@
 
 package io.undertow.server.handlers.form;
 
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -64,6 +70,17 @@ public Deque<FormValue> get(String name) {
         return values.get(name);
     }
 
+    public void add(String name, byte[] value, String fileName, HeaderMap headers) {
+        Deque<FormValue> values = this.values.get(name);
+        if (values == null) {
+            this.values.put(name, values = new ArrayDeque<>(1));
+        }
+        values.add(new FormValueImpl(value, fileName, headers));
+        if (++valueCount > maxValues) {
+            throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(maxValues));
+        }
+    }
+
     public void add(String name, String value) {
         add(name, value, null);
     }
@@ -157,17 +174,24 @@ public interface FormValue {
          *
          * @return
          */
+        @Deprecated
         boolean isFile();
 
         /**
          * @return The temp file that the file data was saved to
+         *
          * @throws IllegalStateException if this is not a file
          */
+        @Deprecated
         Path getPath();
 
         @Deprecated
         File getFile();
 
+        FileItem getFileItem();
+
+        boolean isFileItem();
+
         /**
          * @return The filename specified in the disposition header.
          */
@@ -181,28 +205,95 @@ public interface FormValue {
 
     }
 
+    public static class FileItem {
+        private final Path file;
+        private final byte[] content;
+
+        public FileItem(Path file) {
+            this.file = file;
+            this.content = null;
+        }
+
+        public FileItem(byte[] content) {
+            this.file = null;
+            this.content = content;
+        }
+
+        public boolean isInMemory() {
+            return file == null;
+        }
+
+        public Path getFile() {
+            return file;
+        }
+
+        public long getFileSize() throws IOException {
+            if (isInMemory()) {
+                return content.length;
+            } else {
+                return Files.size(file);
+            }
+        }
+
+        public InputStream getInputStream() throws IOException {
+            if (file != null) {
+                return new BufferedInputStream(Files.newInputStream(file));
+            } else {
+                return new ByteArrayInputStream(content);
+            }
+        }
+
+        public void delete() throws IOException {
+            if (file != null) {
+                try {
+                    Files.delete(file);
+                } catch (NoSuchFileException e) { //already deleted
+                }
+            }
+        }
+
+        public void write(Path target) throws IOException {
+            if (file != null) {
+                try {
+                    Files.move(file, target);
+                } catch (IOException e) {
+                    Files.copy(getInputStream(), target);
+                }
+            } else {
+                Files.copy(getInputStream(), target);
+            }
+        }
+    }
+
 
     static class FormValueImpl implements FormValue {
 
         private final String value;
         private final String fileName;
-        private final Path file;
         private final HeaderMap headers;
+        private final FileItem fileItem;
 
         FormValueImpl(String value, HeaderMap headers) {
             this.value = value;
             this.headers = headers;
-            this.file = null;
             this.fileName = null;
+            this.fileItem = null;
         }
 
         FormValueImpl(Path file, final String fileName, HeaderMap headers) {
-            this.file = file;
+            this.fileItem = new FileItem(file);
             this.headers = headers;
             this.fileName = fileName;
             this.value = null;
         }
 
+        FormValueImpl(byte[] data, String fileName, HeaderMap headers) {
+            this.fileItem = new FileItem(data);
+            this.fileName = fileName;
+            this.headers = headers;
+            this.value = null;
+        }
+
 
         @Override
         public String getValue() {
@@ -214,22 +305,38 @@ public String getValue() {
 
         @Override
         public boolean isFile() {
-            return file != null;
+            return fileItem != null && !fileItem.isInMemory();
         }
 
         @Override
         public Path getPath() {
-            if (file == null) {
+            if (fileItem == null) {
                 throw UndertowMessages.MESSAGES.formValueIsAString();
             }
-            return file;
+            if (fileItem.isInMemory()) {
+                throw UndertowMessages.MESSAGES.formValueIsInMemoryFile();
+            }
+            return fileItem.getFile();
         }
 
         @Override
         public File getFile() {
             return getPath().toFile();
         }
 
+        @Override
+        public FileItem getFileItem() {
+            if (fileItem == null) {
+                throw UndertowMessages.MESSAGES.formValueIsAString();
+            }
+            return fileItem;
+        }
+
+        @Override
+        public boolean isFileItem() {
+            return fileItem != null;
+        }
+
         @Override
         public HeaderMap getHeaders() {
             return headers;",2018-08-29T05:36:11Z,340
"@@ -36,6 +36,7 @@
 import org.xnio.channels.StreamSourceChannel;
 
 import java.io.ByteArrayOutputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
@@ -48,6 +49,7 @@
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Executor;
 
@@ -66,6 +68,8 @@ public class MultiPartParserDefinition implements FormParserFactory.ParserDefini
 
     private long maxIndividualFileSize = -1;
 
+    private long fileSizeThreshold;
+
     public MultiPartParserDefinition() {
         tempFileLocation = Paths.get(System.getProperty(""java.io.tmpdir""));
     }
@@ -83,7 +87,7 @@ public FormDataParser create(final HttpServerExchange exchange) {
                 UndertowLogger.REQUEST_LOGGER.debugf(""Could not find boundary in multipart request with ContentType: %s, multipart data will not be available"", mimeType);
                 return null;
             }
-            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, defaultEncoding);
+            final MultiPartUploadHandler parser = new MultiPartUploadHandler(exchange, boundary, maxIndividualFileSize, fileSizeThreshold, defaultEncoding);
             exchange.addExchangeCompleteListener(new ExchangeCompletionListener() {
                 @Override
                 public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
@@ -138,12 +142,17 @@ public void setMaxIndividualFileSize(final long maxIndividualFileSize) {
         this.maxIndividualFileSize = maxIndividualFileSize;
     }
 
+    public void setFileSizeThreshold(long fileSizeThreshold) {
+        this.fileSizeThreshold = fileSizeThreshold;
+    }
+
     private final class MultiPartUploadHandler implements FormDataParser, MultipartParser.PartHandler {
 
         private final HttpServerExchange exchange;
         private final FormData data;
         private final List<Path> createdFiles = new ArrayList<>();
         private final long maxIndividualFileSize;
+        private final long fileSizeThreshold;
         private String defaultEncoding;
 
         private final ByteArrayOutputStream contentBytes = new ByteArrayOutputStream();
@@ -157,10 +166,11 @@ private final class MultiPartUploadHandler implements FormDataParser, MultipartP
         private final MultipartParser.ParseState parser;
 
 
-        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final String defaultEncoding) {
+        private MultiPartUploadHandler(final HttpServerExchange exchange, final String boundary, final long maxIndividualFileSize, final long fileSizeThreshold, final String defaultEncoding) {
             this.exchange = exchange;
             this.maxIndividualFileSize = maxIndividualFileSize;
             this.defaultEncoding = defaultEncoding;
+            this.fileSizeThreshold = fileSizeThreshold;
             this.data = new FormData(exchange.getConnection().getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, 1000));
             String charset = defaultEncoding;
             String contentType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
@@ -238,7 +248,7 @@ public void beginPart(final HeaderMap headers) {
                 if (disposition.startsWith(""form-data"")) {
                     currentName = Headers.extractQuotedValueFromHeader(disposition, ""name"");
                     fileName = Headers.extractQuotedValueFromHeaderWithEncoding(disposition, ""filename"");
-                    if (fileName != null) {
+                    if (fileName != null && fileSizeThreshold == 0) {
                         try {
                             if (tempFileLocation != null) {
                                 file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
@@ -261,6 +271,24 @@ public void data(final ByteBuffer buffer) throws IOException {
             if (this.maxIndividualFileSize > 0 && this.currentFileSize > this.maxIndividualFileSize) {
                 throw UndertowMessages.MESSAGES.maxFileSizeExceeded(this.maxIndividualFileSize);
             }
+            if (file == null && fileName != null && fileSizeThreshold < this.currentFileSize) {
+                try {
+                    if (tempFileLocation != null) {
+                        file = Files.createTempFile(tempFileLocation, ""undertow"", ""upload"");
+                    } else {
+                        file = Files.createTempFile(""undertow"", ""upload"");
+                    }
+                    createdFiles.add(file);
+
+                    FileOutputStream fileOutputStream = new FileOutputStream(file.toFile());
+                    contentBytes.writeTo(fileOutputStream);
+
+                    fileChannel = fileOutputStream.getChannel();
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
             if (file == null) {
                 while (buffer.hasRemaining()) {
                     contentBytes.write(buffer.get());
@@ -275,12 +303,16 @@ public void endPart() {
             if (file != null) {
                 data.add(currentName, file, fileName, headers);
                 file = null;
+                contentBytes.reset();
                 try {
                     fileChannel.close();
                     fileChannel = null;
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
+            } else if (fileName != null) {
+                data.add(currentName, Arrays.copyOf(contentBytes.toByteArray(), contentBytes.size()), fileName, headers);
+                contentBytes.reset();
             } else {
 
 ",2018-08-29T05:36:11Z,119
"@@ -18,15 +18,21 @@
 
 package io.undertow.server.handlers.form;
 
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.BlockingHandler;
-import io.undertow.testutils.DefaultServer;
-import io.undertow.testutils.HttpClientUtils;
-import io.undertow.testutils.TestHttpClient;
-import io.undertow.util.Headers;
-import io.undertow.util.StatusCodes;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
@@ -40,9 +46,15 @@
 import org.junit.runner.RunWith;
 import org.xnio.IoUtils;
 
-import java.io.File;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.HeaderValues;
+import io.undertow.util.Headers;
+import io.undertow.util.StatusCodes;
 
 /**
  * @author Stuart Douglas
@@ -54,12 +66,9 @@ private static HttpHandler createHandler() {
         return new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {
-                System.out.println(""In handler"");
                 final FormDataParser parser = FormParserFactory.builder().build().createParser(exchange);
-                System.out.println(""Created parser"");
                 try {
                     FormData data = parser.parseBlocking();
-                    System.out.println(""done parsing"");
                     exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
                     if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
                         FormData.FormValue file = data.getFirst(""file"");
@@ -189,4 +198,172 @@ public void testFileUploadWithEagerParsingAndNonASCIIFilename() throws Exception
             client.getConnectionManager().shutdown();
         }
     }
+
+    private static HttpHandler createInMemoryReadingHandler(final long fileSizeThreshold) {
+        return new HttpHandler() {
+            @Override
+            public void handleRequest(final HttpServerExchange exchange) throws Exception {
+                MultiPartParserDefinition multiPartParserDefinition = new MultiPartParserDefinition();
+                multiPartParserDefinition.setFileSizeThreshold(fileSizeThreshold);
+                final FormDataParser parser = FormParserFactory.builder(false)
+                        .addParsers(new FormEncodedDataDefinition(), multiPartParserDefinition)
+                        .build().createParser(exchange);
+                try {
+                    FormData data = parser.parseBlocking();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    if (data.getFirst(""formValue"").getValue().equals(""myValue"")) {
+                        FormData.FormValue file = data.getFirst(""file"");
+                        if (file.isFileItem()) {
+                            exchange.setStatusCode(StatusCodes.OK);
+                            logResult(exchange, file.getFileItem().isInMemory(), file.getFileName(), stream2String(file));
+                        }
+                    }
+                    exchange.endExchange();
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+                    exchange.endExchange();
+                } finally {
+                    IoUtils.safeClose(parser);
+                }
+            }
+
+            private String stream2String(FormData.FormValue file) throws IOException {
+                try (InputStream is = file.getFileItem().getInputStream()) {
+                    StringWriter sw = new StringWriter();
+                    IOUtils.copy(is, sw, ""UTF-8"");
+                    return sw.toString();
+                }
+            }
+
+            private String getFileName(FormData.FormValue data) {
+                HeaderValues cdHeaders = data.getHeaders().get(""content-disposition"");
+                for (String cdHeader : cdHeaders) {
+                    if (cdHeader.startsWith(""form-data"")) {
+                        return cdHeader.substring(cdHeader.indexOf(""filename="") + ""filename="".length()).replace(""\"""", """");
+                    }
+                }
+                return null;
+            }
+
+            private void logResult(HttpServerExchange exchange, boolean inMemory, String fileName, String content) throws IOException {
+                String res = String.format(""in_memory:%s;file_name:%s;hash:%s"", inMemory, fileName, DigestUtils.md5Hex(content));
+                final OutputStream outputStream = exchange.getOutputStream();
+                outputStream.write(res.getBytes());
+                outputStream.close();
+            }
+        };
+    }
+
+    @Test
+    public void testFileUploadWithSmallFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithLargeFileSizeThreshold() throws Exception {
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(10_000)));
+
+        TestHttpClient client = new TestHttpClient();
+        try {
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile())));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""true"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""uploadfile.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(new File(MultipartFormDataParserTestCase.class.getResource(""uploadfile.txt"").getFile()))), parsedResponse.get(""hash""));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    @Test
+    public void testFileUploadWithMediumFileSizeThresholdAndLargeFile() throws Exception {
+        int fileSizeThreshold = 1000;
+        DefaultServer.setRootHandler(new BlockingHandler(createInMemoryReadingHandler(fileSizeThreshold)));
+
+        TestHttpClient client = new TestHttpClient();
+        File file = new File(""tmp_upload_file.txt"");
+        file.createNewFile();
+        try {
+            writeLargeFileContent(file, fileSizeThreshold * 2);
+
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + ""/path"");
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            entity.addPart(""formValue"", new StringBody(""myValue"", ""text/plain"", StandardCharsets.UTF_8));
+            entity.addPart(""file"", new FileBody(file));
+
+            post.setEntity(entity);
+            HttpResponse result = client.execute(post);
+            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
+            String resp = HttpClientUtils.readResponse(result);
+
+            Map<String, String> parsedResponse = parse(resp);
+            Assert.assertEquals(""false"", parsedResponse.get(""in_memory""));
+            Assert.assertEquals(""tmp_upload_file.txt"", parsedResponse.get(""file_name""));
+            Assert.assertEquals(DigestUtils.md5Hex(new FileInputStream(file)), parsedResponse.get(""hash""));
+
+        } finally {
+            file.delete();
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    private void writeLargeFileContent(File file, int size) throws IOException {
+        int textLength = ""content"".getBytes().length;
+        FileOutputStream fos = new FileOutputStream(file);
+        for (int i = 0; i < size / textLength; i++) {
+            fos.write(""content"".getBytes());
+        }
+        fos.flush();
+        fos.close();
+    }
+
+    private Map<String, String> parse(String resp) {
+        Map<String, String> parsed = new HashMap<>();
+
+        String[] split = resp.split("";"");
+        for (String s : split) {
+            String[] pair = s.split("":"");
+            parsed.put(pair[0], pair[1]);
+        }
+
+        return parsed;
+    }
 }",2018-08-29T05:36:11Z,19
"@@ -112,6 +112,9 @@ public void setupMultipart(ServletContextImpl servletContext) {
             if(config.getMaxFileSize() > 0) {
                 multiPartParserDefinition.setMaxIndividualFileSize(config.getMaxFileSize());
             }
+            if (config.getFileSizeThreshold() > 0) {
+                multiPartParserDefinition.setFileSizeThreshold(config.getFileSizeThreshold());
+            }
             multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultRequestCharset().name());
 
             formParserFactory = FormParserFactory.builder(false)",2018-08-29T05:36:11Z,113
"@@ -705,7 +705,7 @@ public String getParameter(final String name) {
             final FormData parsedFormData = parseFormData();
             if (parsedFormData != null) {
                 FormData.FormValue res = parsedFormData.getFirst(name);
-                if (res == null || res.isFile()) {
+                if (res == null || res.isFileItem()) {
                     return null;
                 } else {
                     return res.getValue();
@@ -729,7 +729,7 @@ public Enumeration<String> getParameterNames() {
                 while (it.hasNext()) {
                     String name = it.next();
                     for(FormData.FormValue param : parsedFormData.get(name)) {
-                        if(!param.isFile()) {
+                        if(!param.isFileItem()) {
                             parameterNames.add(name);
                             break;
                         }
@@ -758,7 +758,7 @@ public String[] getParameterValues(final String name) {
                 Deque<FormData.FormValue> res = parsedFormData.get(name);
                 if (res != null) {
                     for (FormData.FormValue value : res) {
-                        if(!value.isFile()) {
+                        if(!value.isFileItem()) {
                             ret.add(value.getValue());
                         }
                     }
@@ -791,14 +791,14 @@ public Map<String, String[]> getParameterMap() {
                     if (arrayMap.containsKey(name)) {
                         ArrayList<String> existing = arrayMap.get(name);
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 existing.add(v.getValue());
                             }
                         }
                     } else {
                         final ArrayList<String> values = new ArrayList<>();
                         for (final FormData.FormValue v : val) {
-                            if(!v.isFile()) {
+                            if(!v.isFileItem()) {
                                 values.add(v.getValue());
                             }
                         }",2018-08-29T05:36:11Z,147
"@@ -24,12 +24,9 @@
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 
-import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.file.Files;
-import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Collection;
@@ -62,8 +59,8 @@ public PartImpl(final String name, final FormData.FormValue formValue, Multipart
 
     @Override
     public InputStream getInputStream() throws IOException {
-        if (formValue.isFile()) {
-            return new BufferedInputStream(Files.newInputStream(formValue.getPath()));
+        if (formValue.isFileItem()) {
+            return formValue.getFileItem().getInputStream();
         } else {
             String requestedCharset = servletRequest.getCharacterEncoding();
             String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultRequestCharset().name();
@@ -89,8 +86,8 @@ public String getSubmittedFileName() {
     @Override
     public long getSize() {
         try {
-            if (formValue.isFile()) {
-                return Files.size(formValue.getPath());
+            if (formValue.isFileItem()) {
+                return formValue.getFileItem().getFileSize();
             } else {
                 return formValue.getValue().length();
             }
@@ -109,20 +106,19 @@ public void write(final String fileName) throws IOException {
                 target = Paths.get(config.getLocation(), fileName);
             }
         }
-        try {
-            Files.move(formValue.getPath(), target);
-        } catch (IOException e) {
-            Files.copy(formValue.getPath(), target);
+        if (formValue.isFileItem()) {
+            formValue.getFileItem().write(target);
         }
     }
 
     @Override
     public void delete() throws IOException {
-        try {
-            Files.delete(formValue.getPath());
-        } catch (NoSuchFileException e) { //already deleted
-        } catch (IOException e) {
-            throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+        if (formValue.isFileItem()) {
+            try {
+                formValue.getFileItem().delete();
+            } catch (IOException e) {
+                throw UndertowServletMessages.MESSAGES.deleteFailed(formValue.getPath());
+            }
         }
     }
 ",2018-08-29T05:36:11Z,269
"@@ -34,7 +34,11 @@ public ClassPathResourceManager(final ClassLoader classLoader, final String pref
 
     @Override
     public Resource getResource(final String path) throws IOException {
-        final String realPath = prefix + path;
+        String modPath = path;
+        if(modPath.startsWith(""/"")) {
+            modPath = path.substring(1);
+        }
+        final String realPath = prefix + modPath;
         final URL resource = classLoader.getResource(realPath);
         if(resource == null) {
             return null;",2013-03-05T03:55:49Z,354
"@@ -0,0 +1,13 @@
+Undertow Examples
+
+These provide some simple examples of how to run an embedded Undertow server.
+
+To run the examples simply run
+
+java -jar target/undertow-examples.jar
+
+or alternatively:
+
+mvn exec:exec
+
+And select the example you wish to run from the menu
\ No newline at end of file",2013-03-05T03:55:49Z,355
"@@ -70,7 +70,7 @@
     </dependencies>
 
     <build>
-
+        <finalName>undertow-examples</finalName>
         <resources>
             <resource>
                 <directory>src/main/java</directory>
@@ -81,24 +81,38 @@
         </resources>
 
         <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-shade-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>shade</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <archive>
+                        <manifest>
+                            <mainClass>io.undertow.examples.Runner</mainClass>
+                        </manifest>
+                    </archive>
+                </configuration>
+            </plugin>
             <plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>exec-maven-plugin</artifactId>
                 <version>1.2.1</version>
                 <configuration>
                     <executable>java</executable>
                     <arguments>
-                        <!--
-                        <argument>-Xdebug</argument>
-                        <argument>-Xnoagent</argument>
-                        <argument>-Djava.compiler=NONE</argument>
-                        <argument>-Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=n</argument>
-                        -->
-                        <argument>-Djava.util.logging.manager=org.jboss.logmanager.LogManager</argument>
-                        <argument>-Dtest.level=${test.level}</argument>
-                        <argument>-classpath</argument>
-                        <classpath/>
-                        <argument>${example}</argument>
+                        <argument>-jar</argument>
+                        <argument>target/${project.build.finalName}.jar</argument>
                     </arguments>
                 </configuration>
             </plugin>",2013-03-05T03:55:49Z,356
"@@ -0,0 +1,87 @@
+package io.undertow.examples;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import org.xnio.IoUtils;
+
+/**
+ * Simple utility to make it easy to run the examples
+ *
+ * @author Stuart Douglas
+ */
+public class Runner {
+
+
+    public static void main(final String[] args) {
+        System.setProperty(""java.util.logging.manager"", ""org.jboss.logmanager.LogManager"");
+        URL url = Runner.class.getClassLoader().getResource(Runner.class.getPackage().getName().replace(""."", ""/""));
+        if (url == null) {
+            throw new RuntimeException(""Could not locate examples package"");
+        }
+        final Map<String, Class> examples = new HashMap<>();
+        //hackz to discover all the example classes on the class path
+        ZipInputStream in = null;
+        try {
+            String zipPath = url.getPath().substring(0, url.getPath().indexOf(""!"")).replace(""file:"", """");
+            in = new ZipInputStream(new FileInputStream(zipPath));
+            ZipEntry entry = in.getNextEntry();
+            while (entry != null) {
+                if (entry.getName().endsWith("".class"")) {
+                    String className = entry.getName().substring(0, entry.getName().length() - 6).replace(""/"", ""."");
+                    try {
+                        Class<?> clazz = Class.forName(className);
+                        UndertowExample example = clazz.getAnnotation(UndertowExample.class);
+                        if (example != null) {
+                            examples.put(example.value(), clazz);
+                        }
+                    } catch (Throwable e) {
+                        //ignore
+                    }
+                }
+                entry = in.getNextEntry();
+            }
+
+            final List<String> names = new ArrayList<>(examples.keySet());
+            Collections.sort(names);
+            System.out.println(""Welcome to the Undertow Examples"");
+            System.out.println(""Please select an example:"");
+
+            for (int i = 0; i < names.size(); ++i) {
+                System.out.print((char) ('a' + i));
+                System.out.println("") "" + names.get(i));
+            }
+            byte[] data = new byte[1];
+            System.in.read(data);
+
+            String example = names.get(data[0] - 'a');
+            System.out.println(""Running example "" + example);
+            System.out.println(""Please point your web browser at http://localhost:8080"");
+
+            final Method main = examples.get(example).getDeclaredMethod(""main"", String[].class);
+            main.invoke(null, (Object)args);
+
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        } finally {
+            IoUtils.safeClose(in);
+        }
+
+    }
+}",2013-03-05T03:55:49Z,280
"@@ -0,0 +1,15 @@
+package io.undertow.examples;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * @author Stuart Douglas
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface UndertowExample {
+    String value();
+}",2013-03-05T03:55:49Z,357
"@@ -1,6 +1,7 @@
 package io.undertow.examples.helloworld;
 
 import io.undertow.Undertow;
+import io.undertow.examples.UndertowExample;
 import io.undertow.io.IoCallback;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -9,6 +10,7 @@
 /**
  * @author Stuart Douglas
  */
+@UndertowExample(""Hello World"")
 public class HelloWorldServer {
 
     public static void main(final String[] args) {",2013-03-05T03:55:49Z,358
"@@ -4,22 +4,26 @@
 import java.util.Map;
 
 import io.undertow.Undertow;
+import io.undertow.examples.UndertowExample;
 import io.undertow.io.IoCallback;
+import io.undertow.security.api.SecurityContext;
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
 
 /**
  * Example of HTTP Basic auth
  *
- *
  * @author Stuart Douglas
  */
+@UndertowExample(""Basic Authentication"")
 public class BasicAuthServer {
 
     public static void main(final String[] args) {
 
+        System.out.println(""You can login with the following credentials:"");
+        System.out.println(""User: userOne Password: passwordOne"");
+        System.out.println(""User: userTwo Password: passwordTwo"");
 
         final Map<String, char[]> users = new HashMap<>(2);
         users.put(""userOne"", ""passwordOne"".toCharArray());
@@ -32,8 +36,8 @@ public static void main(final String[] args) {
                 .setDefaultHandler(new HttpHandler() {
                     @Override
                     public void handleRequest(final HttpServerExchange exchange) {
-                        exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, ""11"");
-                        exchange.getResponseSender().send(""Hello World"", IoCallback.END_EXCHANGE);
+                        final SecurityContext context = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+                        exchange.getResponseSender().send(""Hello "" + context.getAuthenticatedAccount().getPrincipal().getName(), IoCallback.END_EXCHANGE);
                     }
                 })
                 .setLoginConfig(",2013-03-05T03:55:49Z,359
"@@ -3,6 +3,7 @@
 import javax.servlet.ServletException;
 
 import io.undertow.Undertow;
+import io.undertow.examples.UndertowExample;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.ServletContainer;
@@ -11,6 +12,7 @@
 /**
  * @author Stuart Douglas
  */
+@UndertowExample(""Servlet"")
 public class ServletServer {
 
 ",2013-03-05T03:55:49Z,360
"@@ -1,6 +1,7 @@
 package io.undertow.examples.websockets;
 
 import io.undertow.Undertow;
+import io.undertow.examples.UndertowExample;
 import io.undertow.predicate.PathMatchPredicate;
 import io.undertow.server.handlers.PredicateHandler;
 import io.undertow.server.handlers.RedirectHandler;
@@ -15,6 +16,7 @@
 /**
  * @author Stuart Douglas
  */
+@UndertowExample(""Web Sockets"")
 public class WebSocketServer {
 
     public static void main(final String[] args) {",2013-03-05T03:55:49Z,361
"@@ -0,0 +1,46 @@
+
+#
+# JBoss, Home of Professional Open Source.
+# Copyright 2012 Red Hat, Inc., and individual contributors
+# as indicated by the @author tags.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# Additional logger names to configure (root logger is always configured)
+loggers=org.xnio.listener,org.xnio.ssl,org.apache,io.undertow.util.TestHttpClient
+
+# Root logger configuration
+logger.level=${test.level:ERROR}
+logger.handlers=CONSOLE
+
+# Console handler configuration
+handler.CONSOLE=org.jboss.logmanager.handlers.ConsoleHandler
+handler.CONSOLE.properties=autoFlush,target
+handler.CONSOLE.target=SYSTEM_ERR
+handler.CONSOLE.level=ALL
+handler.CONSOLE.autoFlush=true
+handler.CONSOLE.formatter=PATTERN
+
+# The log format pattern
+formatter.PATTERN=org.jboss.logmanager.formatters.PatternFormatter
+formatter.PATTERN.properties=pattern
+formatter.PATTERN.pattern=%d{HH:mm:ss,SSS} %-5p (%t) [%c] <%F:%L> %m%n
+
+logger.org.xnio.listener.level=DEBUG
+
+logger.org.xnio.ssl.level=DEBUG
+
+logger.org.apache.level=WARN
+logger.org.apache.useParentHandlers=false
+logger.io.undertow.util.TestHttpClient.level=WARN",2013-03-05T03:55:49Z,362
"@@ -18,27 +18,13 @@
 
 package io.undertow.server.handlers.proxy;
 
-import io.undertow.server.HttpServerExchange;
-
 /**
  * Manager that controls the behaviour of a {@link ProxyConnectionPool}
  *
  * @author Stuart Douglas
  */
 public interface ConnectionPoolManager extends ProxyConnectionPoolConfig, ConnectionPoolErrorHandler {
 
-    /**
-     * This is invoked when the target thread pool transitions to problem status. It will be called once for each queued request
-     * that has not yet been allocated a connection. The manager can redistribute these requests to other hosts, or can end the
-     * exchange with an error status.
-     *
-     * @param proxyTarget The proxy target
-     * @param exchange The exchange
-     * @param callback The callback
-     * @param timeoutMills The remaining timeout in milliseconds, or -1 if no timeout has been specified
-     */
-    void queuedConnectionFailed(ProxyClient.ProxyTarget proxyTarget, HttpServerExchange exchange, ProxyCallback<ProxyConnection> callback, long timeoutMills);
-
     /**
      *
      * @return The amount of time that we should wait before re-testing a problem server",2014-08-29T00:20:10Z,363
"@@ -217,19 +217,13 @@ public void getConnection(ProxyTarget target, HttpServerExchange exchange, final
 
         final Host host = selectHost(exchange);
         if (host == null) {
-            callback.failed(exchange);
+            callback.couldNotResolveBackend(exchange);
         } else {
             if (holder != null || (exclusivityChecker != null && exclusivityChecker.isExclusivityRequired(exchange))) {
                 // If we have a holder, even if the connection was closed we now exclusivity was already requested so our client
                 // may be assuming it still exists.
                 host.connectionPool.connect(target, exchange, new ProxyCallback<ProxyConnection>() {
 
-                    @Override
-                    public void failed(HttpServerExchange exchange) {
-                        UndertowLogger.PROXY_REQUEST_LOGGER.proxyFailedToConnectToBackend(exchange.getRequestURI(), host.uri);
-                        callback.failed(exchange);
-                    }
-
                     @Override
                     public void completed(HttpServerExchange exchange, ProxyConnection result) {
                         if (holder != null) {
@@ -252,6 +246,22 @@ public void closed(ServerConnection connection) {
                         }
                         callback.completed(exchange, result);
                     }
+
+                    @Override
+                    public void queuedRequestFailed(HttpServerExchange exchange) {
+                        callback.queuedRequestFailed(exchange);
+                    }
+
+                    @Override
+                    public void failed(HttpServerExchange exchange) {
+                        UndertowLogger.PROXY_REQUEST_LOGGER.proxyFailedToConnectToBackend(exchange.getRequestURI(), host.uri);
+                        callback.failed(exchange);
+                    }
+
+                    @Override
+                    public void couldNotResolveBackend(HttpServerExchange exchange) {
+                        callback.couldNotResolveBackend(exchange);
+                    }
                 }, timeout, timeUnit, true);
             } else {
                 host.connectionPool.connect(target, exchange, callback, timeout, timeUnit, false);
@@ -329,7 +339,7 @@ private Host(String jvmRoute, InetSocketAddress bindAddress, URI uri, XnioSsl ss
             this.ssl = ssl;
         }
 
-        @Override
+        // @Override
         public void queuedConnectionFailed(ProxyTarget proxyTarget, HttpServerExchange exchange, ProxyCallback<ProxyConnection> callback, long timeoutMills) {
             getConnection(proxyTarget, exchange, callback, timeoutMills, TimeUnit.MILLISECONDS);
         }",2014-08-29T00:20:10Z,364
"@@ -29,6 +29,27 @@ public interface ProxyCallback<T> {
 
     void completed(final HttpServerExchange exchange, T result);
 
-    void failed(HttpServerExchange exchange);
+    /**
+     * Callback if establishing the connection to a backend server fails.
+     *
+     * @param exchange    the http server exchange
+     */
+    void failed(final HttpServerExchange exchange);
+
+    /**
+     * Callback if no backend server could be found.
+     *
+     * @param exchange    the http server exchange
+     */
+    void couldNotResolveBackend(final HttpServerExchange exchange);
+
+    /**
+     * This is invoked when the target connection pool transitions to problem status. It will be called once for each queued request
+     * that has not yet been allocated a connection. The manager can redistribute these requests to other hosts, or can end the
+     * exchange with an error status.
+     *
+     * @param exchange The exchange
+     */
+    void queuedRequestFailed(HttpServerExchange exchange);
 
 }",2014-08-29T00:20:10Z,365
"@@ -242,7 +242,7 @@ private void redistributeQueued(HostThreadData hostData) {
                 if (callback.getExpireTime() > 0 && callback.getExpireTime() < time) {
                     callback.getCallback().failed(callback.getExchange());
                 } else {
-                    connectionPoolManager.queuedConnectionFailed(callback.getProxyTarget(), callback.getExchange(), callback.getCallback(), callback.getExpireTime() > 0 ? time - callback.getExpireTime() : -1);
+                    callback.getCallback().queuedRequestFailed(callback.getExchange());
                 }
             }
             callback = hostData.awaitingConnections.poll();
@@ -291,7 +291,7 @@ public AvailabilityType available() {
     private void scheduleFailedHostRetry(final HttpServerExchange exchange) {
         final int retry = connectionPoolManager.getProblemServerRetry();
         // only schedule a retry task if the node is not available
-        if (!connectionPoolManager.isAvailable() && retry > 0) {
+        if (retry > 0 && !connectionPoolManager.isAvailable()) {
             exchange.getIoThread().executeAfter(new Runnable() {
                 @Override
                 public void run() {
@@ -314,6 +314,7 @@ public void handleEvent(ClientConnection channel) {
                                         handleClosedConnection(data, connectionHolder);
                                     }
                                 });
+                                data.connections++;
                                 returnConnection(connectionHolder);
                             } else {
                                 // Otherwise reschedule the retry task
@@ -419,7 +420,7 @@ public void connect(ProxyClient.ProxyTarget proxyTarget, HttpServerExchange exch
         } else {
             // Reject the request directly if we reached the max request queue size
             if (data.awaitingConnections.size() >= maxRequestQueueSize) {
-                connectionPoolManager.queuedConnectionFailed(proxyTarget, exchange, callback, timeout);
+                callback.queuedRequestFailed(exchange);
                 return;
             }
             CallbackHolder holder;",2014-08-29T00:20:10Z,6
"@@ -18,6 +18,25 @@
 
 package io.undertow.server.handlers.proxy;
 
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.security.cert.CertificateEncodingException;
+import javax.security.cert.X509Certificate;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URLEncoder;
+import java.nio.channels.Channel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
 import io.undertow.UndertowLogger;
 import io.undertow.attribute.ExchangeAttribute;
 import io.undertow.attribute.ExchangeAttributes;
@@ -58,25 +77,6 @@
 import org.xnio.XnioExecutor;
 import org.xnio.channels.StreamSinkChannel;
 
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.security.cert.CertificateEncodingException;
-import javax.security.cert.X509Certificate;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URLEncoder;
-import java.nio.channels.Channel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-
 /**
  * An HTTP handler which proxies content to a remote server.
  * <p/>
@@ -99,8 +99,6 @@ public final class ProxyHandler implements HttpHandler {
     private static final AttachmentKey<HttpServerExchange> EXCHANGE = AttachmentKey.create(HttpServerExchange.class);
     private static final AttachmentKey<XnioExecutor.Key> TIMEOUT_KEY = AttachmentKey.create(XnioExecutor.Key.class);
 
-    private final ProxyClientHandler proxyClientHandler = new ProxyClientHandler();
-
     /**
      * Map of additional headers to add to the request.
      */
@@ -143,26 +141,13 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             next.handleRequest(exchange);
             return;
         }
-        if (maxRequestTime > 0) {
+        final long timeout = maxRequestTime > 0 ? System.currentTimeMillis() + maxRequestTime : 0;
+        final ProxyClientHandler clientHandler = new ProxyClientHandler(exchange, target, timeout, 1);
+        if (timeout > 0) {
             final XnioExecutor.Key key = exchange.getIoThread().executeAfter(new Runnable() {
                 @Override
                 public void run() {
-
-
-                    ProxyConnection connectionAttachment = exchange.getAttachment(CONNECTION);
-                    if (connectionAttachment != null) {
-                        ClientConnection clientConnection = connectionAttachment.getConnection();
-                        UndertowLogger.REQUEST_LOGGER.timingOutRequest(clientConnection.getPeerAddress() + """" + exchange.getRequestURI());
-                        IoUtils.safeClose(clientConnection);
-                    } else {
-                        UndertowLogger.REQUEST_LOGGER.timingOutRequest(exchange.getRequestURI());
-                    }
-                    if (exchange.isResponseStarted()) {
-                        IoUtils.safeClose(exchange.getConnection());
-                    } else {
-                        exchange.setResponseCode(503);
-                        exchange.endExchange();
-                    }
+                    clientHandler.cancel(exchange);
                 }
             }, maxRequestTime, TimeUnit.MILLISECONDS);
             exchange.putAttachment(TIMEOUT_KEY, key);
@@ -174,13 +159,7 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
                 }
             });
         }
-        exchange.dispatch(exchange.isInIoThread() ? SameThreadExecutor.INSTANCE : exchange.getIoThread(), new Runnable() {
-            @Override
-            public void run() {
-                log.debugf(""Proxying request %s, opening connection"", exchange.getRequestURL());
-                proxyClient.getConnection(target, exchange, proxyClientHandler, -1, TimeUnit.MILLISECONDS);
-            }
-        });
+        exchange.dispatch(exchange.isInIoThread() ? SameThreadExecutor.INSTANCE : exchange.getIoThread(), clientHandler);
     }
 
     /**
@@ -251,24 +230,83 @@ public ProxyClient getProxyClient() {
         return proxyClient;
     }
 
-    private final class ProxyClientHandler implements ProxyCallback<ProxyConnection> {
+    private final class ProxyClientHandler implements ProxyCallback<ProxyConnection>, Runnable {
+
+        private int tries;
+
+        private final long timeout;
+        private final int maxAttempts;
+        private final HttpServerExchange exchange;
+        private ProxyClient.ProxyTarget target;
+
+        ProxyClientHandler(HttpServerExchange exchange, ProxyClient.ProxyTarget target, long timeout, int maxAttempts) {
+            this.exchange = exchange;
+            this.timeout = timeout;
+            this.maxAttempts = maxAttempts;
+            this.target = target;
+        }
 
         @Override
-        public void completed(HttpServerExchange exchange, ProxyConnection result) {
-            exchange.putAttachment(CONNECTION, result);
-            exchange.dispatch(SameThreadExecutor.INSTANCE, new ProxyAction(result, exchange, requestHeaders, rewriteHostHeader, reuseXForwarded));
+        public void run() {
+            proxyClient.getConnection(target, exchange, this, -1, TimeUnit.MILLISECONDS);
         }
 
         @Override
-        public void failed(HttpServerExchange exchange) {
-            UndertowLogger.PROXY_REQUEST_LOGGER.proxyRequestFailedToResolveBackend(exchange.getRequestURI());
-            if (!exchange.isResponseStarted()) {
+        public void completed(final HttpServerExchange exchange, final ProxyConnection connection) {
+            exchange.putAttachment(CONNECTION, connection);
+            exchange.dispatch(SameThreadExecutor.INSTANCE, new ProxyAction(connection, exchange, requestHeaders, rewriteHostHeader, reuseXForwarded));
+        }
+
+        @Override
+        public void failed(final HttpServerExchange exchange) {
+            final long time = System.currentTimeMillis();
+            if (timeout > 0 && timeout > time) {
+                cancel(exchange);
+            } else if (tries++ < maxAttempts) {
+                target = proxyClient.findTarget(exchange);
+                if (target != null) {
+                    final long remaining = timeout > 0 ? timeout - time : -1;
+                    proxyClient.getConnection(target, exchange, this, remaining, TimeUnit.MILLISECONDS);
+                } else {
+                    couldNotResolveBackend(exchange); // The context was registered when we started, so return 503
+                }
+            } else {
+                couldNotResolveBackend(exchange);
+            }
+        }
+
+        @Override
+        public void queuedRequestFailed(HttpServerExchange exchange) {
+            failed(exchange);
+        }
+
+        @Override
+        public void couldNotResolveBackend(HttpServerExchange exchange) {
+            if (exchange.isResponseStarted()) {
+                IoUtils.safeClose(exchange.getConnection());
+            } else {
                 exchange.setResponseCode(503);
                 exchange.endExchange();
+            }
+        }
+
+        void cancel(final HttpServerExchange exchange) {
+            final ProxyConnection connectionAttachment = exchange.getAttachment(CONNECTION);
+            if (connectionAttachment != null) {
+                ClientConnection clientConnection = connectionAttachment.getConnection();
+                UndertowLogger.REQUEST_LOGGER.timingOutRequest(clientConnection.getPeerAddress() + """" + exchange.getRequestURI());
+                IoUtils.safeClose(clientConnection);
             } else {
+                UndertowLogger.REQUEST_LOGGER.timingOutRequest(exchange.getRequestURI());
+            }
+            if (exchange.isResponseStarted()) {
                 IoUtils.safeClose(exchange.getConnection());
+            } else {
+                exchange.setResponseCode(503);
+                exchange.endExchange();
             }
         }
+
     }
 
     private static class ProxyAction implements Runnable {",2014-08-29T00:20:10Z,92
"@@ -64,26 +64,21 @@ public void getConnection(final ProxyTarget target, final HttpServerExchange exc
             return;
         }
         if (! (target instanceof ModClusterProxyTarget)) {
-            callback.failed(exchange);
+            callback.couldNotResolveBackend(exchange);
         }
 
         // Resolve the node
         final ModClusterProxyTarget proxyTarget = (ModClusterProxyTarget) target;
         final Context context = proxyTarget.resolveContext(exchange);
         if (context == null) {
-            callback.failed(exchange);
+            callback.couldNotResolveBackend(exchange);
         } else {
             if (holder != null || (exclusivityChecker != null && exclusivityChecker.isExclusivityRequired(exchange))) {
                 // If we have a holder, even if the connection was closed we now
                 // exclusivity was already requested so our client
                 // may be assuming it still exists.
                 final ProxyCallback<ProxyConnection> wrappedCallback = new ProxyCallback<ProxyConnection>() {
 
-                    @Override
-                    public void failed(HttpServerExchange exchange) {
-                        callback.failed(exchange);
-                    }
-
                     @Override
                     public void completed(HttpServerExchange exchange, ProxyConnection result) {
                         if (holder != null) {
@@ -106,6 +101,21 @@ public void closed(ServerConnection connection) {
                         }
                         callback.completed(exchange, result);
                     }
+
+                    @Override
+                    public void queuedRequestFailed(HttpServerExchange exchange) {
+                        callback.queuedRequestFailed(exchange);
+                    }
+
+                    @Override
+                    public void failed(HttpServerExchange exchange) {
+                        callback.failed(exchange);
+                    }
+
+                    @Override
+                    public void couldNotResolveBackend(HttpServerExchange exchange) {
+                        callback.couldNotResolveBackend(exchange);
+                    }
                 };
 
                 context.handleRequest(proxyTarget, exchange, wrappedCallback, timeout, timeUnit, true);",2014-08-29T00:20:10Z,129
"@@ -488,12 +488,12 @@ public int getMaxQueueSize() {
             return nodeConfig.getRequestQueueSize();
         }
 
-        @Override
+        // @Override
         public void queuedConnectionFailed(ProxyClient.ProxyTarget proxyTarget, HttpServerExchange exchange, ProxyCallback<ProxyConnection> callback, long timeoutMills) {
             final ModClusterProxyTarget target = (ModClusterProxyTarget) proxyTarget;
             final Context context = target.resolveContext(exchange);
             if(context == null || context.getNode() == Node.this) {
-                callback.failed(exchange);
+                callback.queuedRequestFailed(exchange);
                 return;
             }
             context.handleRequest(target, exchange, callback, timeoutMills, TimeUnit.MILLISECONDS, false);",2014-08-29T00:20:10Z,262
"@@ -150,6 +150,16 @@ public void failed(HttpServerExchange exchange) {
                         callback.failed();
                     }
 
+                    @Override
+                    public void queuedRequestFailed(HttpServerExchange exchange) {
+                        callback.failed();
+                    }
+
+                    @Override
+                    public void couldNotResolveBackend(HttpServerExchange exchange) {
+                        callback.failed();
+                    }
+
                 }, timeout, TimeUnit.SECONDS, false);
             }
         });",2014-08-29T00:20:10Z,264
"@@ -18,10 +18,13 @@
 
 package io.undertow.websockets.jsr;
 
+import java.util.List;
+
 import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.util.PathTemplate;
 import io.undertow.websockets.jsr.annotated.AnnotatedEndpointFactory;
 
+import javax.websocket.Extension;
 import javax.websocket.server.ServerEndpointConfig;
 
 /**
@@ -34,16 +37,25 @@ public class ConfiguredServerEndpoint extends SessionContainer {
     private final InstanceFactory<?> endpointFactory;
     private final PathTemplate pathTemplate;
     private final EncodingFactory encodingFactory;
+    private final List<Extension> extensions;
 
-
-    public ConfiguredServerEndpoint(final ServerEndpointConfig endpointConfiguration, final InstanceFactory<?> endpointFactory, final PathTemplate pathTemplate, final EncodingFactory encodingFactory, AnnotatedEndpointFactory annotatedEndpointFactory) {
+    public ConfiguredServerEndpoint(final ServerEndpointConfig endpointConfiguration, final InstanceFactory<?> endpointFactory, final PathTemplate pathTemplate, final EncodingFactory encodingFactory, AnnotatedEndpointFactory annotatedEndpointFactory, List<Extension> installed) {
         this.endpointConfiguration = endpointConfiguration;
         this.endpointFactory = endpointFactory;
         this.pathTemplate = pathTemplate;
         this.encodingFactory = encodingFactory;
         this.annotatedEndpointFactory = annotatedEndpointFactory;
+        this.extensions = installed;
     }
 
+    public ConfiguredServerEndpoint(final ServerEndpointConfig endpointConfiguration, final InstanceFactory<?> endpointFactory, final PathTemplate pathTemplate, final EncodingFactory encodingFactory) {
+        this.endpointConfiguration = endpointConfiguration;
+        this.endpointFactory = endpointFactory;
+        this.pathTemplate = pathTemplate;
+        this.encodingFactory = encodingFactory;
+        this.annotatedEndpointFactory = null;
+        this.extensions = endpointConfiguration.getExtensions();
+    }
     public ServerEndpointConfig getEndpointConfiguration() {
         return endpointConfiguration;
     }
@@ -65,4 +77,13 @@ public AnnotatedEndpointFactory getAnnotatedEndpointFactory() {
         return annotatedEndpointFactory;
     }
 
+    /**
+     * Return the websocket extensions configured.
+     *
+     * @return the list of extensions, the empty list if none.
+     */
+    public List<Extension> getExtensions() {
+        return extensions;
+    }
+
 }",2016-07-14T01:20:45Z,316
"@@ -377,6 +377,7 @@ public InstanceHandle<Object> createInstance() throws InstantiationException {
                     .decoders(sec.getDecoders())
                     .encoders(sec.getEncoders())
                     .subprotocols(sec.getSubprotocols())
+                    .extensions(sec.getExtensions())
                     .configurator(configurator)
                     .build();
 
@@ -387,7 +388,12 @@ public InstanceHandle<Object> createInstance() throws InstantiationException {
             }
 
 
-            ConfiguredServerEndpoint confguredServerEndpoint = new ConfiguredServerEndpoint(config, instanceFactory, null, encodingFactory, annotatedEndpointFactory);
+            ConfiguredServerEndpoint confguredServerEndpoint;
+            if(annotatedEndpointFactory == null) {
+                confguredServerEndpoint = new ConfiguredServerEndpoint(config, instanceFactory, null, encodingFactory);
+            } else {
+                confguredServerEndpoint = new ConfiguredServerEndpoint(config, instanceFactory, null, encodingFactory, annotatedEndpointFactory, installedExtensions);
+            }
             WebSocketHandshakeHolder hand;
 
             WebSocketDeploymentInfo info = (WebSocketDeploymentInfo)request.getServletContext().getAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME);
@@ -622,12 +628,12 @@ public InstanceHandle<Object> createInstance() throws InstantiationException {
                     .decoders(Arrays.asList(serverEndpoint.decoders()))
                     .encoders(Arrays.asList(serverEndpoint.encoders()))
                     .subprotocols(Arrays.asList(serverEndpoint.subprotocols()))
-                    .extensions(installedExtensions)
+                    .extensions(Collections.<Extension>emptyList())
                     .configurator(configurator)
                     .build();
 
 
-            ConfiguredServerEndpoint confguredServerEndpoint = new ConfiguredServerEndpoint(config, instanceFactory, template, encodingFactory, annotatedEndpointFactory);
+            ConfiguredServerEndpoint confguredServerEndpoint = new ConfiguredServerEndpoint(config, instanceFactory, template, encodingFactory, annotatedEndpointFactory, installedExtensions);
             configuredServerEndpoints.add(confguredServerEndpoint);
             handleAddingFilterMapping();
         } else if (clientEndpoint != null) {
@@ -702,7 +708,7 @@ public void addEndpoint(final ServerEndpointConfig endpoint) throws DeploymentEx
         }
         seenPaths.add(template);
         EncodingFactory encodingFactory = EncodingFactory.createFactory(classIntrospecter, endpoint.getDecoders(), endpoint.getEncoders());
-        ConfiguredServerEndpoint confguredServerEndpoint = new ConfiguredServerEndpoint(endpoint, null, template, encodingFactory, null);
+        ConfiguredServerEndpoint confguredServerEndpoint = new ConfiguredServerEndpoint(endpoint, null, template, encodingFactory);
         configuredServerEndpoints.add(confguredServerEndpoint);
         handleAddingFilterMapping();
     }",2016-07-14T01:20:45Z,319
"@@ -98,7 +98,7 @@ static String selectSubProtocol(final ConfiguredServerEndpoint config, final Str
 
     static List<Extension> selectExtensions(final ConfiguredServerEndpoint config, final List<Extension> requestedExtensions) {
         if (config.getEndpointConfiguration().getConfigurator() != null) {
-            return config.getEndpointConfiguration().getConfigurator().getNegotiatedExtensions(config.getEndpointConfiguration().getExtensions(), requestedExtensions);
+            return config.getEndpointConfiguration().getConfigurator().getNegotiatedExtensions(config.getExtensions(), requestedExtensions);
         } else {
             return Collections.emptyList();
         }",2016-07-14T01:20:45Z,9
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-core</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow Core</name>
 ",2018-05-24T23:21:52Z,333
"@@ -3,7 +3,7 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
     <artifactId>undertow-coverage-report</artifactId>
     <name>Undertow Test Coverage Report</name>",2018-05-24T23:21:52Z,366
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-dist</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow: Distribution</name>
 ",2018-05-24T23:21:52Z,367
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-examples</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow Examples</name>
 ",2018-05-24T23:21:52Z,356
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>karaf</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
     <packaging>pom</packaging>
 
     <name>Undertow Karaf Features</name>",2018-05-24T23:21:52Z,334
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-parser-generator</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow Parser Generator</name>
     <description>An annotation processor that is used to generate the HTTP parser</description>",2018-05-24T23:21:52Z,368
"@@ -28,7 +28,7 @@
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-parent</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow</name>
     <description>Undertow</description>
@@ -62,7 +62,7 @@
          -->
         <version.com.h2database>1.3.175</version.com.h2database>
         <version.easymock>3.2</version.easymock>
-        <version.io.undertow.jastow>2.0.8.Final-SNAPSHOT</version.io.undertow.jastow>
+        <version.io.undertow.jastow>2.0.8.Final</version.io.undertow.jastow>
         <version.junit>4.12</version.junit>
         <version.netty>4.1.8.Final</version.netty>
         <version.org.apache.directory.server>2.0.0-M15</version.org.apache.directory.server>",2018-05-24T23:21:52Z,265
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-servlet</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow Servlet</name>
 ",2018-05-24T23:21:52Z,313
"@@ -25,12 +25,12 @@
     <parent>
         <groupId>io.undertow</groupId>
         <artifactId>undertow-parent</artifactId>
-        <version>2.0.8.Final-SNAPSHOT</version>
+        <version>2.0.8.Final</version>
     </parent>
 
     <groupId>io.undertow</groupId>
     <artifactId>undertow-websockets-jsr</artifactId>
-    <version>2.0.8.Final-SNAPSHOT</version>
+    <version>2.0.8.Final</version>
 
     <name>Undertow WebSockets JSR356 implementations</name>
 ",2018-05-24T23:21:52Z,236
"@@ -94,7 +94,7 @@
         <!-- Checkstyle configuration -->
         <linkXRef>false</linkXRef>
         <version.io.undertow.build.checkstyle-config>1.0.1.Final</version.io.undertow.build.checkstyle-config>
-        <version.com.github.spotbugs-maven-plugin>3.1.2</version.com.github.spotbugs-maven-plugin>
+        <version.com.github.spotbugs-maven-plugin>3.1.5</version.com.github.spotbugs-maven-plugin>
         <version.org.eclipse.jetty.alpn>1.1.3.v20160715</version.org.eclipse.jetty.alpn>
 
         <version.com.twitter.hpack>1.0.2</version.com.twitter.hpack>",2018-07-12T08:00:28Z,265
"@@ -268,4 +268,10 @@
         <Bug pattern=""RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT""/>
     </Match>
 
+    <Match>
+        <Bug pattern=""DLS_DEAD_LOCAL_STORE""/>
+        <Class name=""io.undertow.predicate.PredicatesHandler$RestartHandlerBuilder$1$1""/>
+        <Method name=""handleRequest""/>
+    </Match>
+
 </FindBugsFilter>",2018-07-12T08:00:28Z,369
"@@ -320,7 +320,7 @@ public interface UndertowMessages {
     IllegalStateException ajpRequestAlreadyInProgress();
 
     @Message(id = 98, value = ""HTTP ping data must be 8 bytes in length"")
-    IllegalArgumentException httpPingDataMustBeLength8();
+    String httpPingDataMustBeLength8();
 
     @Message(id = 99, value = ""Received a ping of size other than 8"")
     String invalidPingSize();
@@ -364,4 +364,7 @@ public interface UndertowMessages {
 
     @Message(id = 112, value = ""Only client side can call createStream, if you wish to send a PUSH_PROMISE frame use createPushPromiseStream instead"")
     IOException headersStreamCanOnlyBeCreatedByClient();
+
+    @Message(id = 113, value = ""Only the server side can send a push promise stream"")
+    IOException pushPromiseCanOnlyBeCreatedByServer();
 }",2014-09-25T23:38:30Z,68
"@@ -18,17 +18,15 @@
 
 package io.undertow.protocols.http2;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.Channel;
-import java.nio.channels.ClosedChannelException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import javax.net.ssl.SSLSession;
+import io.undertow.UndertowLogger;
+import io.undertow.UndertowMessages;
+import io.undertow.UndertowOptions;
+import io.undertow.server.protocol.framed.AbstractFramedChannel;
+import io.undertow.server.protocol.framed.FrameHeaderData;
+import io.undertow.util.Attachable;
+import io.undertow.util.AttachmentKey;
+import io.undertow.util.AttachmentList;
+import io.undertow.util.HeaderMap;
 import org.xnio.Bits;
 import org.xnio.ChannelExceptionHandler;
 import org.xnio.ChannelListener;
@@ -41,15 +39,17 @@
 import org.xnio.channels.StreamSinkChannel;
 import org.xnio.ssl.SslConnection;
 
-import io.undertow.UndertowLogger;
-import io.undertow.UndertowMessages;
-import io.undertow.UndertowOptions;
-import io.undertow.server.protocol.framed.AbstractFramedChannel;
-import io.undertow.server.protocol.framed.FrameHeaderData;
-import io.undertow.util.Attachable;
-import io.undertow.util.AttachmentKey;
-import io.undertow.util.AttachmentList;
-import io.undertow.util.HeaderMap;
+import javax.net.ssl.SSLSession;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
+import java.nio.channels.ClosedChannelException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * SPDY channel.
@@ -120,7 +120,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     //local
     private int encoderHeaderTableSize;
-    private boolean enablePush = true;
+    private boolean pushEnabled;
     private volatile int initialSendWindowSize = DEFAULT_INITIAL_WINDOW_SIZE;
     private volatile int initialReceiveWindowSize = DEFAULT_INITIAL_WINDOW_SIZE;
     private int maxConcurrentStreams = -1;
@@ -155,13 +155,14 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
 
     public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bufferPool, Pooled<ByteBuffer> data, boolean clientSide, boolean fromUpgrade, OptionMap settings) {
-        this(connectedStreamChannel, bufferPool, data, clientSide, fromUpgrade,  null, settings);
+        this(connectedStreamChannel, bufferPool, data, clientSide, fromUpgrade, null, settings);
     }
 
     public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bufferPool, Pooled<ByteBuffer> data, boolean clientSide, boolean fromUpgrade, ByteBuffer initialOtherSideSettings, OptionMap settings) {
         super(connectedStreamChannel, bufferPool, Http2FramePriority.INSTANCE, data);
         streamIdCounter = clientSide ? (fromUpgrade ? 3 : 1) : 2;
-        if(initialOtherSideSettings != null) {
+        pushEnabled = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);
+        if (initialOtherSideSettings != null) {
             Http2SettingsParser parser = new Http2SettingsParser(initialOtherSideSettings.remaining());
             try {
                 parser.parse(initialOtherSideSettings, new Http2FrameHeaderParser(this, null));
@@ -173,13 +174,12 @@ public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bu
             }
         }
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
-        enablePush = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);
         receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);
 
         this.decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         this.encoder = new HpackEncoder(encoderHeaderTableSize);
 
-        if(clientSide) {
+        if (clientSide) {
             sendPreface();
             prefaceCount = PREFACE_BYTES.length;
         }
@@ -189,7 +189,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bu
     private void sendSettings() {
         List<Http2Setting> settings = new ArrayList<>();
         settings.add(new Http2Setting(Http2Setting.SETTINGS_HEADER_TABLE_SIZE, encoderHeaderTableSize));
-        settings.add(new Http2Setting(Http2Setting.SETTINGS_ENABLE_PUSH, enablePush ? 1 : 0));
+        settings.add(new Http2Setting(Http2Setting.SETTINGS_ENABLE_PUSH, pushEnabled ? 1 : 0));
         settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_FRAME_SIZE, receiveMaxFrameSize));
         Http2SettingsStreamSinkChannel stream = new Http2SettingsStreamSinkChannel(this, settings);
         flushChannel(stream);
@@ -259,7 +259,7 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
                 break;
             }
             case FRAME_TYPE_SETTINGS: {
-                    if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {
+                if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {
                     updateSettings(((Http2SettingsParser) frameParser.parser).getSettings());
                     sendSettingsAck();
                 }
@@ -269,7 +269,11 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
             case FRAME_TYPE_PING: {
                 Http2PingParser pingParser = (Http2PingParser) frameParser.parser;
                 frameData.free();
-                channel = new Http2PingStreamSourceChannel(this, pingParser.getData(), Bits.anyAreSet(frameParser.flags, PING_FLAG_ACK));
+                boolean ack = Bits.anyAreSet(frameParser.flags, PING_FLAG_ACK);
+                channel = new Http2PingStreamSourceChannel(this, pingParser.getData(), ack);
+                if(!ack) { //not an ack from one of our pings, so send it back
+                    sendPing(pingParser.getData(), null, true);
+                }
                 break;
             }
             case FRAME_TYPE_GOAWAY: {
@@ -321,11 +325,11 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
             }
         }
         this.frameParser = null;
-        if(frameParser.getFrameLength() > receiveMaxFrameSize) {
+        if (frameParser.getFrameLength() > receiveMaxFrameSize) {
             sendGoAway(ERROR_FRAME_SIZE_ERROR);
             throw UndertowMessages.MESSAGES.http2FrameTooLarge();
         }
-        if(frameParser.getContinuationParser() != null) {
+        if (frameParser.getContinuationParser() != null) {
             this.continuationParser = frameParser.getContinuationParser();
             return null;
         }
@@ -411,9 +415,23 @@ synchronized void updateSettings(List<Http2Setting> settings) {
                 initialSendWindowSize = setting.getValue();
                 int difference = old - initialSendWindowSize;
                 sendWindowSize += difference;
-            } else if(setting.getId() == Http2Setting.SETTINGS_MAX_FRAME_SIZE) {
+            } else if (setting.getId() == Http2Setting.SETTINGS_MAX_FRAME_SIZE) {
                 sendMaxFrameSize = setting.getValue();
-            } else if(setting.getId() == Http2Setting.SETTINGS_HEADER_TABLE_SIZE) {
+            } else if (setting.getId() == Http2Setting.SETTINGS_HEADER_TABLE_SIZE) {
+                encoder.setMaxTableSize(setting.getValue());
+            } else if (setting.getId() == Http2Setting.SETTINGS_ENABLE_PUSH) {
+
+                int result = setting.getValue();
+                //we allow the remote endpoint to disable push
+                //but not enable it if it has been explictly disabled on this side
+                if(result == 0) {
+                    pushEnabled = false;
+                } else if(result != 1) {
+                    //invalid value
+                    UndertowLogger.REQUEST_IO_LOGGER.debug(""Invalid value received for SETTINGS_ENABLE_PUSH "" + result);
+                    sendGoAway(ERROR_PROTOCOL_ERROR);
+                    return;
+                }
                 encoder.setMaxTableSize(setting.getValue());
             }
             //ignore the rest for now
@@ -504,15 +522,7 @@ public void handleEvent(Channel channel) {
 
     public void sendUpdateWindowSize(int streamId, int delta) {
         Http2WindowUpdateStreamSinkChannel windowUpdateStreamSinkChannel = new Http2WindowUpdateStreamSinkChannel(this, streamId, delta);
-        try {
-            windowUpdateStreamSinkChannel.shutdownWrites();
-            if (!windowUpdateStreamSinkChannel.flush()) {
-                windowUpdateStreamSinkChannel.getWriteSetter().set(ChannelListeners.flushingChannelListener(null, new Http2ControlMessageExceptionHandler()));
-                windowUpdateStreamSinkChannel.resumeWrites();
-            }
-        } catch (IOException e) {
-            handleBrokenSinkChannel(e);
-        }
+        flushChannel(windowUpdateStreamSinkChannel);
 
     }
 
@@ -538,7 +548,17 @@ public synchronized void updateReceiveFlowControlWindow(int read) {
         }
     }
 
+    /**
+     * Creates a strema using a HEADERS frame
+     *
+     * @param requestHeaders
+     * @return
+     * @throws IOException
+     */
     public synchronized Http2HeadersStreamSinkChannel createStream(HeaderMap requestHeaders) throws IOException {
+        if (!isClient()) {
+            throw UndertowMessages.MESSAGES.headersStreamCanOnlyBeCreatedByClient();
+        }
         if (!isOpen()) {
             throw UndertowMessages.MESSAGES.channelIsClosed();
         }
@@ -547,7 +567,23 @@ public synchronized Http2HeadersStreamSinkChannel createStream(HeaderMap request
         Http2HeadersStreamSinkChannel spdySynStreamStreamSinkChannel = new Http2HeadersStreamSinkChannel(this, streamId, requestHeaders);
         outgoingStreams.put(streamId, spdySynStreamStreamSinkChannel);
         return spdySynStreamStreamSinkChannel;
+    }
 
+    public synchronized Http2HeadersStreamSinkChannel sendPushPromise(int associatedStreamId, HeaderMap requestHeaders, HeaderMap responseHeaders) throws IOException {
+        if (!isOpen()) {
+            throw UndertowMessages.MESSAGES.channelIsClosed();
+        }
+        if (isClient()) {
+            throw UndertowMessages.MESSAGES.pushPromiseCanOnlyBeCreatedByServer();
+        }
+        int streamId = streamIdCounter;
+        streamIdCounter += 2;
+        Http2PushPromiseStreamSinkChannel pushPromise = new Http2PushPromiseStreamSinkChannel(this, requestHeaders, associatedStreamId, streamId);
+        flushChannel(pushPromise);
+
+        Http2HeadersStreamSinkChannel spdySynStreamStreamSinkChannel = new Http2HeadersStreamSinkChannel(this, streamId, responseHeaders);
+        outgoingStreams.put(streamId, spdySynStreamStreamSinkChannel);
+        return spdySynStreamStreamSinkChannel;
     }
 
     /**
@@ -642,16 +678,8 @@ public <T> void addToAttachmentList(AttachmentKey<AttachmentList<T>> key, T valu
 
     public void sendRstStream(int streamId, int statusCode) {
         handleRstStream(streamId);
-        try {
-            Http2RstStreamSinkChannel channel = new Http2RstStreamSinkChannel(this, streamId, statusCode);
-            channel.shutdownWrites();
-            if (!channel.flush()) {
-                channel.getWriteSetter().set(ChannelListeners.flushingChannelListener(null, writeExceptionHandler()));
-                channel.resumeWrites();
-            }
-        } catch (IOException e) {
-            markWritesBroken(e);
-        }
+        Http2RstStreamSinkChannel channel = new Http2RstStreamSinkChannel(this, streamId, statusCode);
+        flushChannel(channel);
     }
 
     private void handleRstStream(int streamId) {
@@ -667,19 +695,24 @@ private void handleRstStream(int streamId) {
 
     /**
      * Creates a response stream to respond to the initial HTTP upgrade
+     *
      * @return
      */
     public Http2HeadersStreamSinkChannel createInitialUpgradeResponseStream() {
-        if(lastGoodStreamId != 0) {
+        if (lastGoodStreamId != 0) {
             throw new IllegalStateException();
         }
         lastGoodStreamId = 1;
-        Http2HeadersStreamSinkChannel stream =  new Http2HeadersStreamSinkChannel(this, 1);
+        Http2HeadersStreamSinkChannel stream = new Http2HeadersStreamSinkChannel(this, 1);
         outgoingStreams.put(1, stream);
         return stream;
 
     }
 
+    public boolean isPushEnabled() {
+        return pushEnabled;
+    }
+
 
     private class Http2ControlMessageExceptionHandler implements ChannelExceptionHandler<AbstractHttp2StreamSinkChannel> {
         @Override",2014-09-25T23:38:30Z,166
"@@ -55,6 +55,7 @@ public class Http2DataStreamSinkChannel extends Http2StreamSinkChannel {
 
     @Override
     protected SendFrameHeader createFrameHeaderImpl() {
+        //TODO: this is a mess WRT re-using between headers and push_promise, sort out a more reasonable abstraction
         final int fcWindow = grabFlowControlBytes(getBuffer().remaining());
         if (fcWindow == 0 && getBuffer().hasRemaining()) {
             //flow control window is exhausted
@@ -75,14 +76,15 @@ protected SendFrameHeader createFrameHeaderImpl() {
             firstBuffer.put((byte) frameType); //type
             firstBuffer.put((byte) 0); //back fill the flags
             Http2ProtocolUtils.putInt(firstBuffer, getStreamId());
+            writeBeforeHeaderBlock(firstBuffer);
 
             HpackEncoder.State result = encoder.encode(headers, firstBuffer);
             Pooled<ByteBuffer> current = firstHeaderBuffer;
             int headerFrameLength = firstBuffer.position() - 9;
             firstBuffer.put(0, (byte) ((headerFrameLength >> 16) & 0xFF));
             firstBuffer.put(1, (byte) ((headerFrameLength >> 8) & 0xFF));
             firstBuffer.put(2, (byte) (headerFrameLength & 0xFF));
-            firstBuffer.put(4, (byte) ((isWritesShutdown() && !getBuffer().hasRemaining() ? Http2Channel.HEADERS_FLAG_END_STREAM : 0) | (result == HpackEncoder.State.COMPLETE ? Http2Channel.HEADERS_FLAG_END_HEADERS : 0 ))); //flags
+            firstBuffer.put(4, (byte) ((isWritesShutdown() && !getBuffer().hasRemaining() && frameType == Http2Channel.FRAME_TYPE_HEADERS ? Http2Channel.HEADERS_FLAG_END_STREAM : 0) | (result == HpackEncoder.State.COMPLETE ? Http2Channel.HEADERS_FLAG_END_HEADERS : 0 ))); //flags
             while (result != HpackEncoder.State.COMPLETE) {
                 //todo: add some kind of limit here
 
@@ -170,6 +172,9 @@ protected SendFrameHeader createFrameHeaderImpl() {
 
     }
 
+    protected void writeBeforeHeaderBlock(ByteBuffer buffer) {
+
+    }
 
     public HeaderMap getHeaders() {
         return headers;",2014-09-25T23:38:30Z,194
"@@ -38,6 +38,9 @@ class Http2FramePriority implements FramePriority<Http2Channel, AbstractHttp2Str
     public boolean insertFrame(AbstractHttp2StreamSinkChannel newFrame, List<AbstractHttp2StreamSinkChannel> pendingFrames) {
         //first deal with flow control
         if (newFrame instanceof Http2StreamSinkChannel) {
+            if(newFrame.isBroken()) {
+                return true; //just quietly drop the frame
+            }
             SendFrameHeader header = ((Http2StreamSinkChannel) newFrame).generateSendFrameHeader();
             //if no header is generated then flow control means we can't send anything
             if (header.getByteBuffer() == null) {",2014-09-25T23:38:30Z,197
"@@ -18,8 +18,11 @@
 
 package io.undertow.protocols.http2;
 
+import io.undertow.UndertowMessages;
+
 import static io.undertow.protocols.http2.Http2Channel.PING_FRAME_LENGTH;
 
+import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
@@ -36,7 +39,13 @@ public Http2PingParser(int frameLength) {
     }
 
     @Override
-    protected void handleData(ByteBuffer resource, Http2FrameHeaderParser parser) {
+    protected void handleData(ByteBuffer resource, Http2FrameHeaderParser parser) throws IOException {
+        if(parser.length != PING_FRAME_LENGTH) {
+            throw new IOException(UndertowMessages.MESSAGES.httpPingDataMustBeLength8());
+        }
+        if(parser.streamId != 0) {
+            throw new IOException(UndertowMessages.MESSAGES.streamIdMustBeZeroForFrameType(Http2Channel.FRAME_TYPE_PING));
+        }
         if (resource.remaining() < PING_FRAME_LENGTH) {
             return;
         }",2014-09-25T23:38:30Z,370
"@@ -31,8 +31,7 @@
  */
 class Http2PingStreamSinkChannel extends Http2NoDataStreamSinkChannel {
 
-    public static final int HEADER_NO_ACK = (PING_FRAME_LENGTH << 8) | (Http2Channel.FRAME_TYPE_PING);
-    public static final int HEADER_ACK = (PING_FRAME_LENGTH << 16) | (Http2Channel.FRAME_TYPE_PING << 8) | Http2Channel.PING_FLAG_ACK;
+    public static final int HEADER = (PING_FRAME_LENGTH << 8) | (Http2Channel.FRAME_TYPE_PING);
     private final byte[] data;
     private final boolean ack;
 
@@ -47,14 +46,14 @@ protected Http2PingStreamSinkChannel(Http2Channel channel, byte[] data, boolean
 
     @Override
     protected SendFrameHeader createFrameHeader() {
-        ByteBuffer buf = ByteBuffer.allocate(16);
-        int firstInt = ack ? HEADER_ACK : HEADER_NO_ACK;
-        Http2ProtocolUtils.putInt(buf, firstInt);
-        buf.put((byte) 0);
+        ByteBuffer buf = ByteBuffer.allocate(17);
+        Http2ProtocolUtils.putInt(buf, HEADER);
+        buf.put((byte) (ack ? Http2Channel.PING_FLAG_ACK : 0));
         Http2ProtocolUtils.putInt(buf, 0); //stream id, must be zero
         for (int i = 0; i < PING_FRAME_LENGTH; ++i) {
             buf.put(data[i]);
         }
+        buf.flip();
         return new SendFrameHeader(new ImmediatePooled<>(buf));
     }
 ",2014-09-25T23:38:30Z,371
"@@ -0,0 +1,56 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.protocols.http2;
+
+import io.undertow.util.HeaderMap;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Push promise channel
+ *
+ * @author Stuart Douglas
+ */
+public class Http2PushPromiseStreamSinkChannel extends Http2DataStreamSinkChannel {
+
+    private final int pushedStreamId;
+
+    Http2PushPromiseStreamSinkChannel(Http2Channel channel,  HeaderMap requestHeaders, int associatedStreamId, int pushedStreamId) {
+        super(channel, associatedStreamId, requestHeaders, Http2Channel.FRAME_TYPE_PUSH_PROMISE);
+        this.pushedStreamId = pushedStreamId;
+    }
+
+
+    protected void writeBeforeHeaderBlock(ByteBuffer buffer) {
+        buffer.put((byte) ((pushedStreamId >> 24) & 0xFF));
+        buffer.put((byte) ((pushedStreamId >> 16) & 0xFF));
+        buffer.put((byte) ((pushedStreamId >> 8) & 0xFF));
+        buffer.put((byte) (pushedStreamId & 0xFF));
+    }
+
+    /**
+     * this stream is not flow controlled
+     * @param bytes
+     * @return
+     */
+    protected int grabFlowControlBytes(int bytes) {
+        return bytes;
+    }
+
+}",2014-09-25T23:38:30Z,372
"@@ -22,6 +22,7 @@
 import io.undertow.server.handlers.Cookie;
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
+import io.undertow.util.URLUtils;
 import org.xnio.Pooled;
 import org.xnio.channels.StreamSourceChannel;
 
@@ -222,6 +223,73 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
         }
     }
 
+
+    /**
+     * Sets the request path and query parameters, decoding to the requested charset.
+     *
+     * @param exchange    The exchange
+     * @param encodedPath        The encoded path
+     * @param charset     The charset
+     */
+    public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer) {
+        boolean requiresDecode = false;
+        for (int i = 0; i < encodedPath.length(); ++i) {
+            char c = encodedPath.charAt(i);
+            if (c == '?') {
+                String part;
+                String encodedPart = encodedPath.substring(0, i);
+                if (requiresDecode) {
+                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
+                } else {
+                    part = encodedPart;
+                }
+                exchange.setRequestPath(part);
+                exchange.setRelativePath(part);
+                exchange.setRequestURI(encodedPart);
+                final String qs = encodedPath.substring(i + 1);
+                exchange.setQueryString(qs);
+                URLUtils.parseQueryString(qs, exchange, charset, decode);
+                return;
+            } else if(c == ';') {
+                String part;
+                String encodedPart = encodedPath.substring(0, i);
+                if (requiresDecode) {
+                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
+                } else {
+                    part = encodedPart;
+                }
+                exchange.setRequestPath(part);
+                exchange.setRelativePath(part);
+                exchange.setRequestURI(encodedPart);
+                for(int j = i; j < encodedPath.length(); ++j) {
+                    if (encodedPath.charAt(j) == '?') {
+                        String pathParams = encodedPath.substring(i + 1, j);
+                        URLUtils.parsePathParms(pathParams, exchange, charset, decode);
+                        String qs = encodedPath.substring(j + 1);
+                        exchange.setQueryString(qs);
+                        URLUtils.parseQueryString(qs, exchange, charset, decode);
+                        return;
+                    }
+                }
+                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode);
+                return;
+            } else if(c == '%' || c == '+') {
+                requiresDecode = true;
+            }
+        }
+
+        String part;
+        if (requiresDecode) {
+            part = URLUtils.decode(encodedPath, charset, allowEncodedSlash, decodeBuffer);
+        } else {
+            part = encodedPath;
+        }
+        exchange.setRequestPath(part);
+        exchange.setRelativePath(part);
+        exchange.setRequestURI(encodedPath);
+    }
+
+
     /**
      * Returns the existing request channel, if it exists. Otherwise returns null
      *",2014-09-25T23:38:30Z,163
"@@ -20,6 +20,8 @@
 
 import io.undertow.util.AbstractAttachable;
 
+import io.undertow.util.HeaderMap;
+import io.undertow.util.HttpString;
 import org.xnio.Option;
 import org.xnio.OptionMap;
 import org.xnio.Pool;
@@ -197,6 +199,27 @@ public abstract class ServerConnection extends AbstractAttachable implements Con
      */
     protected abstract void maxEntitySizeUpdated(HttpServerExchange exchange);
 
+    /**
+     * Attempts to push a resource if this connection supports server push. Otherwise the request is ignored.
+     *
+     * Note that push is always done on a best effort basis, even if this method returns true it is possible that
+     * the remote endpoint will reset the stream
+     *
+     *
+     * @param path The path of the resource
+     * @param method The request method
+     * @param requestHeaders The request headers
+     * @param associatedRequest The associated request that initiated the push
+     * @return <code>true</code> if the server attempted the push, false otherwise
+     */
+    public boolean pushResource(final String path, final HttpString method, final HeaderMap requestHeaders, HttpServerExchange associatedRequest) {
+        return false;
+    }
+
+    public boolean isPushSupported() {
+        return false;
+    }
+
     public interface CloseListener {
 
         void closed(final ServerConnection connection);",2014-09-25T23:38:30Z,373
"@@ -25,6 +25,7 @@
 
 import io.undertow.UndertowLogger;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 import io.undertow.util.RedirectBuilder;
@@ -122,6 +123,11 @@ public static StringBuilder renderDirectoryListing(String path, Resource resourc
     }
 
     public static void renderDirectoryListing(HttpServerExchange exchange, Resource resource) {
+        if(exchange.getConnection().isPushSupported()) {
+            //try and push our resources to the remote endpoint
+            exchange.getConnection().pushResource(exchange.getRequestURI() + ""?js"", Methods.GET, new HeaderMap(), exchange);
+            exchange.getConnection().pushResource(exchange.getRequestURI() + ""?css"", Methods.GET, new HeaderMap(), exchange);
+        }
         String requestPath = exchange.getRequestPath();
         if (! requestPath.endsWith(""/"")) {
             exchange.setResponseCode(302);",2014-09-25T23:38:30Z,374
"@@ -589,6 +589,7 @@ public void markBroken() {
             }
             if(buffer != null) {
                 buffer.free();
+                buffer = null;
             }
         }
     }
@@ -608,4 +609,8 @@ private void wakeupWaiters() {
     public C getChannel() {
         return channel;
     }
+
+    public boolean isBroken() {
+        return broken;
+    }
 }",2014-09-25T23:38:30Z,234
"@@ -89,7 +89,7 @@ public void handleEvent(final StreamConnection channel) {
         final PotentialHttp2Connection potentialConnection = new PotentialHttp2Connection(channel);
         channel.getSourceChannel().setReadListener(potentialConnection);
         final SSLEngine sslEngine = JsseXnioSsl.getSslEngine((SslConnection) channel);
-        String existing = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
+        String existing = null;// (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
         //resuming an existing session, no need for ALPN
         if (existing != null) {
             UndertowLogger.REQUEST_LOGGER.debug(""Resuming existing session, not doing NPN negotiation"");",2014-09-25T23:38:30Z,375
"@@ -40,7 +40,6 @@
 import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
-import io.undertow.util.URLUtils;
 
 /**
  * The recieve listener for a Http2 connection.
@@ -51,10 +50,10 @@
  */
 public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
 
-    private static final HttpString METHOD = new HttpString("":method"");
-    private static final HttpString PATH = new HttpString("":path"");
-    private static final HttpString SCHEME = new HttpString("":scheme"");
-    private static final HttpString AUTHORITY = new HttpString("":authority"");
+    static final HttpString METHOD = new HttpString("":method"");
+    static final HttpString PATH = new HttpString("":path"");
+    static final HttpString SCHEME = new HttpString("":scheme"");
+    static final HttpString AUTHORITY = new HttpString("":authority"");
 
     private final HttpHandler rootHandler;
     private final long maxEntitySize;
@@ -91,7 +90,7 @@ public void handleEvent(Http2Channel channel) {
             if (frame instanceof Http2StreamSourceChannel) {
                 //we have a request
                 final Http2StreamSourceChannel dataChannel = (Http2StreamSourceChannel) frame;
-                final Http2ServerConnection connection = new Http2ServerConnection(channel, dataChannel, undertowOptions, bufferSize);
+                final Http2ServerConnection connection = new Http2ServerConnection(channel, dataChannel, undertowOptions, bufferSize, rootHandler);
 
 
                 final HttpServerExchange exchange = new HttpServerExchange(connection, dataChannel.getHeaders(), dataChannel.getResponseChannel().getHeaders(), maxEntitySize);
@@ -101,8 +100,7 @@ public void handleEvent(Http2Channel channel) {
                 exchange.setRequestMethod(new HttpString(exchange.getRequestHeaders().getFirst(METHOD)));
                 exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(AUTHORITY));
                 final String path = exchange.getRequestHeaders().getFirst(PATH);
-                setRequestPath(exchange, path, encoding, allowEncodingSlash, decodeBuffer);
-
+                Connectors.setExchangeRequestPath(exchange, path, encoding,decode, allowEncodingSlash, decodeBuffer);
                 SSLSession session = channel.getSslSession();
                 if(session != null) {
                     connection.setSslSessionInfo(new Http2SslSessionInfo(channel));
@@ -143,7 +141,7 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel) {
 
         //we have a request
         Http2HeadersStreamSinkChannel sink = channel.createInitialUpgradeResponseStream();
-        final Http2ServerConnection connection = new Http2ServerConnection(channel, sink, undertowOptions, bufferSize);
+        final Http2ServerConnection connection = new Http2ServerConnection(channel, sink, undertowOptions, bufferSize, rootHandler);
 
         HeaderMap requestHeaders = new HeaderMap();
         for(HeaderValues hv : initial.getRequestHeaders()) {
@@ -153,7 +151,7 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel) {
         exchange.setRequestScheme(initial.getRequestScheme());
         exchange.setProtocol(initial.getProtocol());
         exchange.setRequestMethod(initial.getRequestMethod());
-        setRequestPath(exchange, initial.getRequestURI(), encoding, allowEncodingSlash, decodeBuffer);
+        Connectors.setExchangeRequestPath(exchange, initial.getRequestURI(), encoding, decode, allowEncodingSlash, decodeBuffer);
 
         SSLSession session = channel.getSslSession();
         if(session != null) {
@@ -169,69 +167,4 @@ public void handleEvent(Http2DataStreamSinkChannel channel) {
         Connectors.executeRootHandler(rootHandler, exchange);
     }
 
-    /**
-     * Sets the request path and query parameters, decoding to the requested charset.
-     *
-     * @param exchange    The exchange
-     * @param encodedPath        The encoded path
-     * @param charset     The charset
-     */
-    private void setRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, final boolean allowEncodedSlash, StringBuilder decodeBuffer) {
-        boolean requiresDecode = false;
-        for (int i = 0; i < encodedPath.length(); ++i) {
-            char c = encodedPath.charAt(i);
-            if (c == '?') {
-                String part;
-                String encodedPart = encodedPath.substring(0, i);
-                if (requiresDecode) {
-                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
-                } else {
-                    part = encodedPart;
-                }
-                exchange.setRequestPath(part);
-                exchange.setRelativePath(part);
-                exchange.setRequestURI(encodedPart);
-                final String qs = encodedPath.substring(i + 1);
-                exchange.setQueryString(qs);
-                URLUtils.parseQueryString(qs, exchange, encoding, decode);
-                return;
-            } else if(c == ';') {
-                String part;
-                String encodedPart = encodedPath.substring(0, i);
-                if (requiresDecode) {
-                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
-                } else {
-                    part = encodedPart;
-                }
-                exchange.setRequestPath(part);
-                exchange.setRelativePath(part);
-                exchange.setRequestURI(encodedPart);
-                for(int j = i; j < encodedPath.length(); ++j) {
-                    if (encodedPath.charAt(j) == '?') {
-                        String pathParams = encodedPath.substring(i + 1, j);
-                        URLUtils.parsePathParms(pathParams, exchange, encoding, decode);
-                        String qs = encodedPath.substring(j + 1);
-                        exchange.setQueryString(qs);
-                        URLUtils.parseQueryString(qs, exchange, encoding, decode);
-                        return;
-                    }
-                }
-                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, encoding, decode);
-                return;
-            } else if(c == '%' || c == '+') {
-                requiresDecode = true;
-            }
-        }
-
-        String part;
-        if (requiresDecode) {
-            part = URLUtils.decode(encodedPath, charset, allowEncodedSlash, decodeBuffer);
-        } else {
-            part = encodedPath;
-        }
-        exchange.setRequestPath(part);
-        exchange.setRelativePath(part);
-        exchange.setRequestURI(encodedPath);
-    }
-
 }",2014-09-25T23:38:30Z,164
"@@ -22,6 +22,12 @@
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.util.List;
+
+import io.undertow.UndertowLogger;
+import io.undertow.UndertowOptions;
+import io.undertow.protocols.http2.Http2HeadersStreamSinkChannel;
+import io.undertow.server.HttpHandler;
+import io.undertow.util.Protocols;
 import org.xnio.ChannelListener;
 import org.xnio.Option;
 import org.xnio.OptionMap;
@@ -72,12 +78,14 @@ public class Http2ServerConnection extends ServerConnection {
     private final OptionMap undertowOptions;
     private final int bufferSize;
     private SSLSessionInfo sessionInfo;
+    private final HttpHandler rootHandler;
 
-    public Http2ServerConnection(Http2Channel channel, Http2StreamSourceChannel requestChannel, OptionMap undertowOptions, int bufferSize) {
+    public Http2ServerConnection(Http2Channel channel, Http2StreamSourceChannel requestChannel, OptionMap undertowOptions, int bufferSize, HttpHandler rootHandler) {
         this.channel = channel;
         this.requestChannel = requestChannel;
         this.undertowOptions = undertowOptions;
         this.bufferSize = bufferSize;
+        this.rootHandler = rootHandler;
         responseChannel = requestChannel.getResponseChannel();
         originalSinkConduit = new StreamSinkChannelWrappingConduit(responseChannel);
         originalSourceConduit = new StreamSourceChannelWrappingConduit(requestChannel);
@@ -90,9 +98,11 @@ public Http2ServerConnection(Http2Channel channel, Http2StreamSourceChannel requ
      * @param channel
      * @param undertowOptions
      * @param bufferSize
+     * @param rootHandler
      */
-    public Http2ServerConnection(Http2Channel channel, Http2DataStreamSinkChannel sinkChannel, OptionMap undertowOptions, int bufferSize) {
+    public Http2ServerConnection(Http2Channel channel, Http2DataStreamSinkChannel sinkChannel, OptionMap undertowOptions, int bufferSize, HttpHandler rootHandler) {
         this.channel = channel;
+        this.rootHandler = rootHandler;
         this.requestChannel = null;
         this.undertowOptions = undertowOptions;
         this.bufferSize = bufferSize;
@@ -278,4 +288,39 @@ public <T> List<T> getAttachmentList(AttachmentKey<? extends List<T>> key) {
     public <T> T getAttachment(AttachmentKey<T> key) {
         return channel.getAttachment(key);
     }
+
+    @Override
+    public boolean isPushSupported() {
+        return channel.isPushEnabled();
+    }
+
+    @Override
+    public boolean pushResource(String path, HttpString method, HeaderMap requestHeaders, HttpServerExchange associatedRequest) {
+        HeaderMap responseHeaders = new HeaderMap();
+        try {
+            requestHeaders.put(Http2ReceiveListener.METHOD, method.toString());
+            requestHeaders.put(Http2ReceiveListener.PATH, path.toString());
+            requestHeaders.put(Http2ReceiveListener.AUTHORITY, associatedRequest.getHostAndPort());
+            requestHeaders.put(Http2ReceiveListener.SCHEME, associatedRequest.getRequestScheme());
+
+            Http2HeadersStreamSinkChannel sink = channel.sendPushPromise(responseChannel.getStreamId(), requestHeaders, responseHeaders);
+            Http2ServerConnection newConnection = new Http2ServerConnection(channel, sink, getUndertowOptions(), getBufferSize(), rootHandler);
+            final HttpServerExchange exchange = new HttpServerExchange(newConnection, requestHeaders, responseHeaders, getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE));
+            exchange.setRequestMethod(method);
+            exchange.setProtocol(Protocols.HTTP_1_1);
+            Connectors.setExchangeRequestPath(exchange, path, getUndertowOptions().get(UndertowOptions.URL_CHARSET, ""UTF-8""), getUndertowOptions().get(UndertowOptions.DECODE_URL, true), getUndertowOptions().get(UndertowOptions.ALLOW_ENCODED_SLASH, false), new StringBuilder());
+
+            Connectors.terminateRequest(exchange);
+            getIoThread().execute(new Runnable() {
+                @Override
+                public void run() {
+                    Connectors.executeRootHandler(rootHandler, exchange);
+                }
+            });
+            return true;
+        } catch (IOException e) {
+            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+            return false;
+        }
+    }
 }",2014-09-25T23:38:30Z,376
"@@ -58,7 +58,7 @@ public class ComplexSSLTestCase {
     private static volatile String message;
 
     @Test
-    public void complexSSLTestCase() throws IOException, GeneralSecurityException, URISyntaxException {
+    public void complexSSLTestCase() throws IOException, GeneralSecurityException, URISyntaxException, InterruptedException {
         final PathHandler pathHandler = new PathHandler();
         File rootPath = new File(FileHandlerTestCase.class.getResource(""page.html"").toURI()).getParentFile();
 ",2014-09-25T23:38:30Z,133
"@@ -321,7 +321,7 @@ private static void runInternal(final RunNotifier notifier) {
 
 
                 } else if (h2 && isAlpnEnabled()) {
-                    openListener = new Http2OpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), OptionMap.create(UndertowOptions.ENABLE_SPDY, true), BUFFER_SIZE);
+                    openListener = new Http2OpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false), BUFFER_SIZE);
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
 
                     SSLContext serverContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE));
@@ -340,7 +340,7 @@ private static void runInternal(final RunNotifier notifier) {
 
 
                 } else if (h2c) {
-                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true), BUFFER_SIZE);
+                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false), BUFFER_SIZE);
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
 
                     InetSocketAddress targetAddress = new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT) + PROXY_OFFSET);",2014-09-25T23:38:30Z,76
"@@ -18,10 +18,9 @@
 
 package io.undertow.server.session;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 
@@ -44,7 +43,7 @@ public class InMemorySessionManager implements SessionManager {
 
     private final ConcurrentMap<String, InMemorySession> sessions = new SecureHashMap<>();
 
-    private volatile List<SessionListener> listeners = Collections.emptyList();
+    private final SessionListeners sessionListeners = new SessionListeners();
 
     /**
      * 30 minute default
@@ -58,6 +57,9 @@ public void start() {
 
     @Override
     public void stop() {
+        for (Map.Entry<String, InMemorySession> session : sessions.entrySet()) {
+            sessionListeners.sessionDestroyed(session.getValue().session, null, SessionListener.SessionDestroyedReason.UNDEPLOY);
+        }
         sessions.clear();
     }
 
@@ -78,9 +80,7 @@ public Session createSession(final HttpServerExchange serverExchange, final Sess
         final SessionImpl session = new SessionImpl(sessionID, config, serverExchange.getIoThread(), serverExchange.getConnection().getWorker());
         InMemorySession im = new InMemorySession(session, defaultSessionTimeout);
         sessions.put(sessionID, im);
-        for (SessionListener listener : listeners) {
-            listener.sessionCreated(session, serverExchange);
-        }
+        sessionListeners.sessionCreated(session, serverExchange);
         config.setSessionId(serverExchange, session.getId());
         im.lastAccessed = System.currentTimeMillis();
         session.bumpTimeout();
@@ -104,16 +104,12 @@ public Session getSession(final HttpServerExchange serverExchange, final Session
 
     @Override
     public synchronized void registerSessionListener(final SessionListener listener) {
-        final List<SessionListener> listeners = new ArrayList<SessionListener>(this.listeners);
-        listeners.add(listener);
-        this.listeners = Collections.unmodifiableList(listeners);
+        sessionListeners.addSessionListener(listener);
     }
 
     @Override
     public synchronized void removeSessionListener(final SessionListener listener) {
-        final List<SessionListener> listeners = new ArrayList<SessionListener>(this.listeners);
-        listeners.remove(listener);
-        this.listeners = Collections.unmodifiableList(listeners);
+        sessionListeners.removeSessionListener(listener);
     }
 
     @Override
@@ -140,7 +136,7 @@ public void run() {
                 worker.execute(new Runnable() {
                     @Override
                     public void run() {
-                        invalidate(null);
+                        invalidate(null, SessionListener.SessionDestroyedReason.TIMEOUT);
                     }
                 });
             }
@@ -240,12 +236,10 @@ public Object setAttribute(final String name, final Object value) {
                 throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.put(name, value);
-            for (SessionListener listener : listeners) {
-                if (existing == null) {
-                    listener.attributeAdded(sess.session, name, value);
-                } else {
-                    listener.attributeUpdated(sess.session, name, value);
-                }
+            if (existing == null) {
+                sessionListeners.attributeAdded(sess.session, name, value);
+            } else {
+                sessionListeners.attributeUpdated(sess.session, name, value, existing);
             }
             bumpTimeout();
             return existing;
@@ -258,25 +252,29 @@ public Object removeAttribute(final String name) {
                 throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.remove(name);
-            for (SessionListener listener : listeners) {
-                listener.attributeRemoved(sess.session, name);
-            }
+            sessionListeners.attributeRemoved(sess.session, name, existing);
             bumpTimeout();
             return existing;
         }
 
         @Override
         public void invalidate(final HttpServerExchange exchange) {
+            invalidate(exchange, SessionListener.SessionDestroyedReason.INVALIDATED);
+        }
+
+        void invalidate(final HttpServerExchange exchange, SessionListener.SessionDestroyedReason reason) {
             if (cancelKey != null) {
                 cancelKey.remove();
             }
-            final InMemorySession sess = sessions.remove(sessionId);
+            InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw UndertowMessages.MESSAGES.sessionAlreadyInvalidated();
-            }
-            for (SessionListener listener : listeners) {
-                listener.sessionDestroyed(sess.session, exchange, false);
+                if (reason == SessionListener.SessionDestroyedReason.INVALIDATED) {
+                    throw UndertowMessages.MESSAGES.sessionAlreadyInvalidated();
+                }
+                return;
             }
+            sessionListeners.sessionDestroyed(sess.session, exchange, reason);
+            sessions.remove(sessionId);
             if (exchange != null) {
                 sessionCookieConfig.clearSession(exchange, this.getId());
             }
@@ -314,7 +312,7 @@ private static class InMemorySession {
             this.maxInactiveInterval = maxInactiveInterval;
         }
 
-        final ConcurrentMap<String, Object> attributes = new SecureHashMap<String, Object>();
+        final ConcurrentMap<String, Object> attributes = new ConcurrentHashMap<>();
         volatile long lastAccessed;
         final long creationTime;
         volatile int maxInactiveInterval;",2013-05-13T03:29:32Z,13
"@@ -42,11 +42,17 @@ public interface SessionListener {
      * @param exchange The {@link HttpServerExchange} that destroyed the session, or null if the session timed out
      * @param expired If the session expired
      */
-    void sessionDestroyed(final Session session,  final HttpServerExchange exchange, final boolean expired);
+    void sessionDestroyed(final Session session,  final HttpServerExchange exchange, SessionDestroyedReason reason);
 
     void attributeAdded(final Session session, final String name, final Object value);
 
-    void attributeUpdated(final Session session, final String name, final Object newValue);
+    void attributeUpdated(final Session session, final String name, final Object newValue, final Object oldValue);
 
-    void attributeRemoved(final Session session, final String name);
+    void attributeRemoved(final Session session, final String name,final Object oldValue);
+
+    enum SessionDestroyedReason {
+        INVALIDATED,
+        TIMEOUT,
+        UNDEPLOY,
+    }
 }",2013-05-13T03:29:32Z,53
"@@ -0,0 +1,63 @@
+package io.undertow.server.session;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.undertow.server.HttpServerExchange;
+
+/**
+ * Utility class that maintains the session listeners.
+ *
+ *
+ * @author Stuart Douglas
+ */
+public class SessionListeners {
+
+    private final List<SessionListener> sessionListeners = new CopyOnWriteArrayList<>();
+
+    public void addSessionListener(final SessionListener listener) {
+        this.sessionListeners.add(listener);
+    }
+
+    public boolean removeSessionListener(final SessionListener listener) {
+        return this.sessionListeners.remove(listener);
+    }
+
+    public void clear() {
+        this.sessionListeners.clear();
+    }
+
+    public void sessionCreated(final Session session, final HttpServerExchange exchange) {
+        for (SessionListener listener : sessionListeners) {
+            listener.sessionCreated(session, exchange);
+        }
+    }
+
+    public void sessionDestroyed(final Session session, final HttpServerExchange exchange, SessionListener.SessionDestroyedReason reason) {
+        for (SessionListener listener : sessionListeners) {
+            listener.sessionDestroyed(session, exchange, reason);
+        }
+
+    }
+
+    public void attributeAdded(final Session session, final String name, final Object value) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeAdded(session, name, value);
+        }
+
+    }
+
+    public void attributeUpdated(final Session session, final String name, final Object newValue, final Object oldValue) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeUpdated(session, name, newValue, oldValue);
+        }
+
+    }
+
+    public void attributeRemoved(final Session session, final String name, final Object oldValue) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeRemoved(session, name, oldValue);
+        }
+    }
+
+}",2013-05-13T03:29:32Z,53
"@@ -105,4 +105,6 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         }
     }
 
+
+
 }",2013-05-13T03:29:32Z,14
"@@ -160,4 +160,5 @@ public interface UndertowServletMessages {
 
     @Message(id = 10038, value = ""No web socket handler was provided to the web socket servlet"")
     ServletException noWebSocketHandler();
+
 }",2013-05-13T03:29:32Z,141
"@@ -159,6 +159,8 @@ public void deploy() {
                 }
             }
 
+            deployment.getSessionManager().registerSessionListener(new SessionListenerBridge(listeners, servletContext));
+
             initializeErrorPages(deployment, deploymentInfo);
             initializeMimeMappings(deployment, deploymentInfo);
             initializeTempDir(servletContext, deploymentInfo);",2013-05-13T03:29:32Z,80
"@@ -0,0 +1,77 @@
+package io.undertow.servlet.core;
+
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpSessionBindingEvent;
+import javax.servlet.http.HttpSessionBindingListener;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.session.Session;
+import io.undertow.server.session.SessionListener;
+import io.undertow.servlet.handlers.ServletRequestContext;
+import io.undertow.servlet.spec.HttpSessionImpl;
+
+/**
+ * Class that bridges between Undertow native session listeners and servlet ones.
+ *
+ * @author Stuart Douglas
+ */
+public class SessionListenerBridge implements SessionListener {
+
+    private final ApplicationListeners applicationListeners;
+    private final ServletContext servletContext;
+
+    public SessionListenerBridge(final ApplicationListeners applicationListeners, final ServletContext servletContext) {
+        this.applicationListeners = applicationListeners;
+        this.servletContext = servletContext;
+    }
+
+    @Override
+    public void sessionCreated(final Session session, final HttpServerExchange exchange) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, true);
+        applicationListeners.sessionCreated(httpSession);
+    }
+
+    @Override
+    public void sessionDestroyed(final Session session, final HttpServerExchange exchange, final SessionDestroyedReason reason) {
+        try {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        applicationListeners.sessionDestroyed(httpSession);
+        } finally {
+            ServletRequestContext current = ServletRequestContext.current();
+            if(current != null) {
+                current.setSession(null);
+            }
+        }
+    }
+
+    @Override
+    public void attributeAdded(final Session session, final String name, final Object value) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        applicationListeners.httpSessionAttributeAdded(httpSession, name, value);
+    }
+
+    @Override
+    public void attributeUpdated(final Session session, final String name, final Object value, final Object old) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        if (old != value) {
+            if (old instanceof HttpSessionBindingListener) {
+                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(httpSession, name, old));
+            }
+            applicationListeners.httpSessionAttributeReplaced(httpSession, name, old);
+        }
+        if (value instanceof HttpSessionBindingListener) {
+            ((HttpSessionBindingListener) value).valueBound(new HttpSessionBindingEvent(httpSession, name, value));
+        }
+    }
+
+    @Override
+    public void attributeRemoved(final Session session, final String name, final Object old) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        if (old != null) {
+            applicationListeners.httpSessionAttributeRemoved(httpSession, name, old);
+            if (old instanceof HttpSessionBindingListener) {
+                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(httpSession, name, old));
+            }
+        }
+    }
+}",2013-05-13T03:29:32Z,377
"@@ -7,6 +7,7 @@
 import io.undertow.servlet.handlers.security.SingleConstraintMatch;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
 import io.undertow.servlet.spec.HttpServletResponseImpl;
+import io.undertow.servlet.spec.HttpSessionImpl;
 import io.undertow.util.AttachmentKey;
 
 import javax.servlet.DispatcherType;
@@ -58,6 +59,7 @@ public static ServletRequestContext current() {
 
     private List<SingleConstraintMatch> requiredConstrains;
     private TransportGuaranteeType transportGuarenteeType;
+    private HttpSessionImpl session;
 
     public ServletRequestContext(final HttpServletRequestImpl originalRequest, final HttpServletResponseImpl originalResponse) {
         this.originalRequest = originalRequest;
@@ -129,4 +131,12 @@ public HttpServletRequestImpl getOriginalRequest() {
     public HttpServletResponseImpl getOriginalResponse() {
         return originalResponse;
     }
+
+    public HttpSessionImpl getSession() {
+        return session;
+    }
+
+    public void setSession(final HttpSessionImpl session) {
+        this.session = session;
+    }
 }",2013-05-13T03:29:32Z,123
"@@ -23,14 +23,11 @@
 
 import javax.servlet.ServletContext;
 import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionBindingEvent;
-import javax.servlet.http.HttpSessionBindingListener;
 import javax.servlet.http.HttpSessionContext;
 
-import io.undertow.server.HttpServerExchange;
 import io.undertow.server.session.Session;
 import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.core.ApplicationListeners;
+import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.servlet.util.IteratorEnumeration;
 
 /**
@@ -40,19 +37,35 @@ public class HttpSessionImpl implements HttpSession {
 
     private final Session session;
     private final ServletContext servletContext;
-    private final ApplicationListeners applicationListeners;
-    private final HttpServerExchange exchange;
     private final boolean newSession;
     private volatile boolean invalid;
 
-    public HttpSessionImpl(final Session session, final ServletContext servletContext, final ApplicationListeners applicationListeners, final HttpServerExchange exchange, final boolean newSession) {
+    private HttpSessionImpl(final Session session, final ServletContext servletContext, final boolean newSession) {
         this.session = session;
         this.servletContext = servletContext;
-        this.applicationListeners = applicationListeners;
-        this.exchange = exchange;
         this.newSession = newSession;
     }
 
+    public static HttpSessionImpl forSession(final Session session, final ServletContext servletContext, final boolean newSession) {
+        ServletRequestContext current = ServletRequestContext.current();
+        if (current == null) {
+            return new HttpSessionImpl(session, servletContext, newSession);
+        } else {
+            HttpSessionImpl httpSession = current.getSession();
+            if (httpSession == null) {
+                httpSession = new HttpSessionImpl(session, servletContext, newSession);
+                current.setSession(httpSession);
+            } else {
+                if(httpSession.session != session) {
+                    //in some rare cases it may be that there are two different service contexts involved in the one request
+                    //in this case we just return a new session rather than using the thread local version
+                    httpSession = new HttpSessionImpl(session, servletContext, newSession);
+                }
+            }
+            return httpSession;
+        }
+    }
+
     @Override
     public long getCreationTime() {
         return session.getCreationTime();
@@ -119,18 +132,7 @@ public void setAttribute(final String name, final Object value) {
         if (value == null) {
             removeAttribute(name);
         } else {
-            Object old = session.setAttribute(name, value);
-            if (old == null) {
-                applicationListeners.httpSessionAttributeAdded(this, name, value);
-            } else if (old != value) {
-                if (old instanceof HttpSessionBindingListener) {
-                    ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(this, name, old));
-                }
-                applicationListeners.httpSessionAttributeReplaced(this, name, old);
-            }
-            if (value instanceof HttpSessionBindingListener) {
-                ((HttpSessionBindingListener) value).valueBound(new HttpSessionBindingEvent(this, name, value));
-            }
+            session.setAttribute(name, value);
         }
     }
 
@@ -141,13 +143,7 @@ public void putValue(final String name, final Object value) {
 
     @Override
     public void removeAttribute(final String name) {
-        Object old = session.removeAttribute(name);
-        if (old != null) {
-            applicationListeners.httpSessionAttributeRemoved(this, name, old);
-            if (old instanceof HttpSessionBindingListener) {
-                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(this, name, old));
-            }
-        }
+        session.removeAttribute(name);
     }
 
     @Override
@@ -158,8 +154,12 @@ public void removeValue(final String name) {
     @Override
     public void invalidate() {
         invalid = true;
-        applicationListeners.sessionDestroyed(this);
-        session.invalidate(exchange);
+        ServletRequestContext current = ServletRequestContext.current();
+        if (current == null) {
+            session.invalidate(null);
+        } else {
+            session.invalidate(current.getOriginalRequest().getExchange());
+        }
     }
 
     @Override",2013-05-13T03:29:32Z,378
"@@ -521,11 +521,11 @@ public HttpSessionImpl getSession(final HttpServerExchange exchange, boolean cre
             final SessionManager sessionManager = deployment.getSessionManager();
             Session session = sessionManager.getSession(exchange, c);
             if (session != null) {
-                httpSession = new HttpSessionImpl(session, this, getDeployment().getApplicationListeners(), exchange, false);
+                httpSession = HttpSessionImpl.forSession(session, this, false);
                 exchange.putAttachment(sessionAttachmentKey, httpSession);
             } else if (create) {
                 final Session newSession = sessionManager.createSession(exchange, c);
-                httpSession = new HttpSessionImpl(newSession, this, getDeployment().getApplicationListeners(), exchange, true);
+                httpSession = HttpSessionImpl.forSession(newSession, this, true);
                 exchange.putAttachment(sessionAttachmentKey, httpSession);
                 getDeployment().getApplicationListeners().sessionCreated(httpSession);
             }",2013-05-13T03:29:32Z,146
"@@ -18,8 +18,6 @@
 
 package io.undertow.servlet.handlers;
 
-import java.util.concurrent.Executor;
-
 import javax.servlet.DispatcherType;
 
 import io.undertow.UndertowLogger;
@@ -129,7 +127,7 @@ private void handleFirstRequest(final BlockingHttpServerExchange exchange, final
         ThreadSetupAction.Handle handle = setupAction.setup(exchange);
         try {
             if (dispatcher == null) {
-                final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange);
+                final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);
                 HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.DISPATCHER_TYPE_ATTACHMENT_KEY, DispatcherType.REQUEST);
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);",2012-10-04T22:26:48Z,145
"@@ -159,6 +159,7 @@ public void dispatch(final String path) {
     public void dispatch(final ServletContext context, final String path) {
 
         HttpServletRequestImpl requestImpl = HttpServletRequestImpl.getRequestImpl(servletRequest);
+        HttpServletResponseImpl responseImpl = HttpServletResponseImpl.getResponseImpl(servletResponse);
         final ServletInitialHandler handler;
         final BlockingHttpServerExchange exchange = requestImpl.getExchange();
 
@@ -201,6 +202,7 @@ public void dispatch(final ServletContext context, final String path) {
         requestImpl.getExchange().getExchange().setRequestPath(newRequestUri);
         requestImpl.getExchange().getExchange().setRequestURI(newRequestUri);
         requestImpl.setServletContext((ServletContextImpl) context);
+        responseImpl.setServletContext((ServletContextImpl) context);
 
         Deployment deployment = requestImpl.getServletContext().getDeployment();
         handler = deployment.getServletPaths().getServletHandlerByPath(newServletPath);",2012-10-04T22:26:48Z,244
"@@ -42,6 +42,7 @@
 import io.undertow.servlet.util.IteratorEnumeration;
 import io.undertow.util.AttachmentKey;
 import io.undertow.util.AttachmentList;
+import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
@@ -55,14 +56,16 @@ public class HttpServletResponseImpl implements HttpServletResponse {
     public static final AttachmentKey<ServletResponse> ATTACHMENT_KEY = AttachmentKey.create(ServletResponse.class);
 
     private final BlockingHttpServerExchange exchange;
+    private volatile ServletContextImpl servletContext;
 
     private ServletOutputStreamImpl servletOutputStream;
     private PrintWriter writer;
     private Integer bufferSize;
     private boolean insideInclude = false;
 
-    public HttpServletResponseImpl(final BlockingHttpServerExchange exchange) {
+    public HttpServletResponseImpl(final BlockingHttpServerExchange exchange, final ServletContextImpl servletContext) {
         this.exchange = exchange;
+        this.servletContext = servletContext;
     }
 
     public BlockingHttpServerExchange getExchange() {
@@ -105,7 +108,7 @@ public String encodeRedirectUrl(final String url) {
 
     @Override
     public void sendError(final int sc, final String msg) throws IOException {
-        if(exchange.getExchange().isResponseStarted()) {
+        if (exchange.getExchange().isResponseStarted()) {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
         exchange.getExchange().setResponseCode(sc);
@@ -116,7 +119,7 @@ public void sendError(final int sc, final String msg) throws IOException {
 
     @Override
     public void sendError(final int sc) throws IOException {
-        if(exchange.getExchange().isResponseStarted()) {
+        if (exchange.getExchange().isResponseStarted()) {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
         exchange.getExchange().setResponseCode(sc);
@@ -126,7 +129,24 @@ public void sendError(final int sc) throws IOException {
 
     @Override
     public void sendRedirect(final String location) throws IOException {
-
+        setStatus(302);
+        String realPath;
+        if (location.startsWith(""/"")) {
+            realPath = location;
+        } else {
+            String current = exchange.getExchange().getRelativePath();
+            int lastSlash = current.lastIndexOf(""/"");
+            if (lastSlash != -1) {
+                current = current.substring(0, lastSlash + 1);
+            }
+            realPath = servletContext.getContextPath() + CanonicalPathUtils.canonicalize(current + location);
+        }
+        String host = exchange.getExchange().getRequestHeaders().getFirst(Headers.HOST);
+        if (host == null) {
+            host = exchange.getExchange().getDestinationAddress().getAddress().getHostAddress();
+        }
+        String loc = exchange.getExchange().getRequestScheme() + ""://"" + host + realPath;
+        exchange.getExchange().getResponseHeaders().put(Headers.LOCATION, loc);
     }
 
     @Override
@@ -357,6 +377,10 @@ public void setInsideInclude(final boolean insideInclude) {
         this.insideInclude = insideInclude;
     }
 
+    public void setServletContext(final ServletContextImpl servletContext) {
+        this.servletContext = servletContext;
+    }
+
     public static HttpServletResponseImpl getResponseImpl(final ServletResponse response) {
         final HttpServletResponseImpl requestImpl;
         if (response instanceof HttpServletResponseImpl) {",2012-10-04T22:26:48Z,170
"@@ -61,6 +61,7 @@ public RequestDispatcherImpl(final ServletInitialHandler handler, final ServletC
     @Override
     public void forward(final ServletRequest request, final ServletResponse response) throws ServletException, IOException {
         HttpServletRequestImpl requestImpl = HttpServletRequestImpl.getRequestImpl(request);
+        final HttpServletResponseImpl responseImpl = HttpServletResponseImpl.getResponseImpl(response);
         final BlockingHttpServerExchange exchange = requestImpl.getExchange();
         response.resetBuffer();
 
@@ -114,6 +115,7 @@ public void forward(final ServletRequest request, final ServletResponse response
             requestImpl.getExchange().getExchange().setRequestPath(newRequestUri);
             requestImpl.getExchange().getExchange().setRequestURI(newRequestUri);
             requestImpl.setServletContext(servletContext);
+            responseImpl.setServletContext(servletContext);
         }
 
         try {
@@ -194,9 +196,10 @@ public void include(final ServletRequest request, final ServletResponse response
         boolean inInclude = responseImpl.isInsideInclude();
         responseImpl.setInsideInclude(true);
 
-        ServletContextImpl oldContext = (ServletContextImpl) requestImpl.getServletContext();
+        ServletContextImpl oldContext = requestImpl.getServletContext();
         try {
             requestImpl.setServletContext(servletContext);
+            responseImpl.setServletContext(servletContext);
             try {
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);
                 exchange.getExchange().putAttachment(HttpServletResponseImpl.ATTACHMENT_KEY, response);
@@ -211,6 +214,7 @@ public void include(final ServletRequest request, final ServletResponse response
         } finally {
             responseImpl.setInsideInclude(inInclude);
             requestImpl.setServletContext(oldContext);
+            responseImpl.setServletContext(oldContext);
             exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, oldRequest);
             exchange.getExchange().putAttachment(HttpServletResponseImpl.ATTACHMENT_KEY, oldResponse);
             if (!named) {",2012-10-04T22:26:48Z,171
"@@ -47,7 +47,7 @@
         <libraryPath></libraryPath>
         <java.library.path></java.library.path>
         <org.wildfly.openssl.path></org.wildfly.openssl.path>
-        <dependency.karaf.version>4.2.0.M2</dependency.karaf.version>
+        <dependency.karaf.version>4.2.0</dependency.karaf.version>
     </properties>
 
     <dependencies>",2018-05-02T22:19:11Z,334
"@@ -23,7 +23,7 @@
     <parent>
         <groupId>org.jboss</groupId>
         <artifactId>jboss-parent</artifactId>
-        <version>25</version>
+        <version>26</version>
     </parent>
 
     <groupId>io.undertow</groupId>
@@ -161,7 +161,9 @@
                         <failsOnError>true</failsOnError>
                         <includeTestSourceDirectory>true</includeTestSourceDirectory>
                         <useFile/>
-                        <sourceDirectory>${project.build.sourceDirectory}</sourceDirectory>
+                        <sourceDirectories>
+                            <sourceDirectory>${project.build.sourceDirectory}</sourceDirectory>
+                        </sourceDirectories>
                     </configuration>
                     <dependencies>
                         <dependency>",2018-05-02T22:19:11Z,265
"@@ -413,4 +413,7 @@ public interface UndertowMessages {
 
     @Message(id = 128, value = ""Remote peer closed connection before all data could be read"")
     IOException couldNotReadContentLengthData();
+
+    @Message(id = 129, value = ""Failed to decode url %s to charset %s"")
+    IllegalArgumentException failedToDecodeURL(String s, String enc, @Cause Exception e);
 }",2015-08-12T03:01:23Z,68
"@@ -52,6 +52,7 @@
 import java.nio.ByteBuffer;
 import java.util.TreeMap;
 
+import io.undertow.UndertowMessages;
 import io.undertow.security.impl.ExternalAuthenticationMechanism;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Headers;
@@ -420,7 +421,11 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
 
     private String decode(String url, final boolean containsUrlCharacters) throws UnsupportedEncodingException {
         if (doDecode && containsUrlCharacters) {
-            return URLDecoder.decode(url, encoding);
+            try {
+                return URLDecoder.decode(url, encoding);
+            } catch (Exception e) {
+                throw UndertowMessages.MESSAGES.failedToDecodeURL(url, encoding, e);
+            }
         }
         return url;
     }",2015-08-12T03:01:23Z,54
"@@ -124,4 +124,8 @@ public interface UndertowServletLogger extends BasicLogger {
     @LogMessage(level = WARN)
     @Message(id = 15020, value = ""Path %s is secured for some HTTP methods, however it is not secured for %s"")
     void unsecuredMethodsOnPath(String path, Set<String> missing);
+
+    @LogMessage(level = ERROR)
+    @Message(id = 15021, value = ""Failure dispatching async event"")
+    void failureDispatchingAsyncEvent(@Cause Throwable t);
 }",2017-08-31T00:16:09Z,379
"@@ -307,6 +307,8 @@ public synchronized void completeInternal() {
                     servletRequestContext.getOriginalRequest().clearAttributes();
                 } catch (IOException e) {
                     UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                } catch (Throwable t) {
+                    UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
                 }
             } else {
                 doDispatch(new Runnable() {
@@ -320,6 +322,8 @@ public void run() {
                             servletRequestContext.getOriginalRequest().closeAndDrainRequest();
                         } catch (IOException e) {
                             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                        } catch (Throwable t) {
+                            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
                         }
                     }
                 });
@@ -423,6 +427,8 @@ public void handleError(final Throwable error) {
                     }
                 } catch (IOException e) {
                     UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                } catch (Throwable t) {
+                    UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
                 }
             } else if (error instanceof IOException) {
                 UndertowLogger.REQUEST_IO_LOGGER.ioException((IOException) error);
@@ -516,6 +522,8 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                                                             }
                                                         } catch (IOException e) {
                                                             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                                                        } catch (Throwable t) {
+                                                            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
                                                         }
                                                     }
                                                 }, exchange);
@@ -604,6 +612,8 @@ public void run() {
                             listener.asyncListener.onComplete(event);
                         } catch (IOException e) {
                             UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                        } catch (Throwable t) {
+                            UndertowServletLogger.REQUEST_LOGGER.failureDispatchingAsyncEvent(t);
                         }
                     }
                 } finally {
@@ -620,6 +630,8 @@ private void onAsyncTimeout() {
                 listener.asyncListener.onTimeout(event);
             } catch (IOException e) {
                 UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            } catch (Throwable t) {
+                UndertowServletLogger.REQUEST_LOGGER.failureDispatchingAsyncEvent(t);
             }
         }
     }
@@ -641,6 +653,8 @@ public void run() {
                             listener.asyncListener.onStartAsync(event);
                         } catch (IOException e) {
                             UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                        } catch (Throwable t) {
+                            UndertowServletLogger.REQUEST_LOGGER.failureDispatchingAsyncEvent(t);
                         }
                     }
                 } finally {
@@ -664,6 +678,8 @@ public void run() {
                             listener.asyncListener.onError(event);
                         } catch (IOException e) {
                             UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                        } catch (Throwable t) {
+                            UndertowServletLogger.REQUEST_LOGGER.failureDispatchingAsyncEvent(t);
                         }
                     }
                 } finally {",2017-08-31T00:16:09Z,244
"@@ -0,0 +1,215 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2017 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.listener.request.async;
+
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.Comparator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Test that AsyncListener failures do not block execution of other listeners.
+ *
+ * @author ckozak
+ */
+@RunWith(DefaultServer.class)
+public class AsyncListenerExceptionTest {
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+
+        final PathHandler root = new PathHandler();
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+
+        ServletInfo runtime = new ServletInfo(""runtime"", RuntimeExceptionServlet.class)
+                .addMapping(""/runtime"")
+                .setAsyncSupported(true);
+        ServletInfo io = new ServletInfo(""io"", IOExceptionServlet.class)
+                .addMapping(""/io"")
+                .setAsyncSupported(true);
+        ServletInfo error = new ServletInfo(""error"", ErrorServlet.class)
+                .addMapping(""/error"")
+                .setAsyncSupported(true);
+
+        DeploymentInfo builder = new DeploymentInfo()
+                .setClassLoader(AsyncListenerExceptionTest.class.getClassLoader())
+                .setContextPath(""/servletContext"")
+                .setClassIntrospecter(TestClassIntrospector.INSTANCE)
+                .setDeploymentName(""servletContext.war"")
+                .addServlets(runtime, io, error);
+
+        DeploymentManager manager = container.addDeployment(builder);
+        manager.deploy();
+        root.addPrefixPath(builder.getContextPath(), manager.start());
+
+        DefaultServer.setRootHandler(root);
+    }
+
+    @Before
+    public void setUp() {
+        AbstractAsyncServlet.QUEUE.clear();
+    }
+
+    @Test
+    public void onCompleteThrowsRuntimeException() throws IOException, InterruptedException {
+        doTest(""runtime"", false);
+    }
+
+    @Test
+    public void onCompleteThrowsIOException() throws IOException, InterruptedException {
+        doTest(""io"", false);
+    }
+
+    @Test
+    public void onCompleteThrowsError() throws IOException, InterruptedException {
+        doTest(""error"", false);
+    }
+
+    @Test
+    public void onTimeoutThrowsRuntimeException() throws IOException, InterruptedException {
+        doTest(""runtime"", true);
+    }
+
+    @Test
+    public void onTimeoutThrowsIOException() throws IOException, InterruptedException {
+        doTest(""io"", true);
+    }
+
+    @Test
+    public void onTimeoutThrowsError() throws IOException, InterruptedException {
+        doTest(""error"", true);
+    }
+
+    private void doTest(String urlTail, boolean timeout) throws IOException, InterruptedException {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/servletContext/"" + urlTail);
+            if (timeout) {
+                get.addHeader(""timeout"", ""true"");
+            }
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(timeout ? 500 : 200, result.getStatusLine().getStatusCode());
+            HttpClientUtils.readResponse(result);
+            List<String> expected = new LinkedList<>();
+            expected.add(""onComplete"");
+            expected.add(""onComplete"");
+            if (timeout) {
+                expected.add(""onTimeout"");
+                expected.add(""onTimeout"");
+            }
+            List<String> actual = new LinkedList<>();
+            for (int i = 0; i < expected.size(); i++) {
+                actual.add(AbstractAsyncServlet.QUEUE.poll(10, TimeUnit.SECONDS));
+            }
+            actual.sort(Comparator.naturalOrder());
+            Assert.assertEquals(expected, actual);
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+    public abstract static class AbstractAsyncServlet extends HttpServlet {
+        static final BlockingQueue<String> QUEUE = new LinkedBlockingDeque<>();
+        @Override
+        protected void doGet(final HttpServletRequest req, final HttpServletResponse resp)
+                throws ServletException, IOException {
+            AsyncContext context = req.startAsync();
+            context.setTimeout(1000);
+            for (int i = 0; i < 2; i++) {
+                context.addListener(new AsyncListener() {
+                    @Override
+                    public void onComplete(AsyncEvent asyncEvent) throws IOException {
+                        QUEUE.add(""onComplete"");
+                        throwException();
+                    }
+
+                    @Override
+                    public void onTimeout(AsyncEvent asyncEvent) throws IOException {
+                        QUEUE.add(""onTimeout"");
+                        throwException();
+                    }
+
+                    @Override
+                    public void onError(AsyncEvent asyncEvent) throws IOException {
+                        QUEUE.add(""onError"");
+                        throwException();
+                    }
+
+                    @Override
+                    public void onStartAsync(AsyncEvent asyncEvent) throws IOException {
+                        QUEUE.add(""onStartAsync"");
+                    }
+                });
+            }
+            if (req.getHeader(""timeout"") == null) {
+                context.complete();
+            }
+        }
+
+        protected abstract void throwException() throws IOException;
+    }
+
+    public static final class RuntimeExceptionServlet extends AbstractAsyncServlet {
+        @Override
+        protected void throwException() throws IOException {
+            throw new RuntimeException();
+        }
+    }
+
+    public static final class IOExceptionServlet extends AbstractAsyncServlet {
+        @Override
+        protected void throwException() throws IOException {
+            throw new IOException();
+        }
+    }
+
+    public static final class ErrorServlet extends AbstractAsyncServlet {
+        @Override
+        protected void throwException() throws IOException {
+            throw new Error();
+        }
+    }
+}",2017-08-31T00:16:09Z,380
"@@ -22,12 +22,14 @@
 import java.nio.ByteBuffer;
 import java.util.zip.CRC32;
 import java.util.zip.Deflater;
+import java.util.zip.Inflater;
 
 import org.xnio.conduits.StreamSourceConduit;
 import io.undertow.UndertowMessages;
 import io.undertow.server.ConduitWrapper;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.ConduitFactory;
+import io.undertow.util.ObjectPool;
 
 /**
  * @author Stuart Douglas
@@ -60,6 +62,13 @@ public GzipStreamSourceConduit(HttpServerExchange exchange, StreamSourceConduit
         super(exchange, next);
     }
 
+    public GzipStreamSourceConduit(
+            HttpServerExchange exchange,
+            StreamSourceConduit next,
+            ObjectPool<Inflater> inflaterPool) {
+        super(exchange, next, inflaterPool);
+    }
+
     private int totalOut;
     private int headerRead = 0;
     private int footerRead = 0;",2017-06-15T15:15:11Z,381
"@@ -36,6 +36,10 @@
 import io.undertow.server.ConduitWrapper;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.ConduitFactory;
+import io.undertow.util.NewInstanceObjectPool;
+import io.undertow.util.ObjectPool;
+import io.undertow.util.PooledObject;
+import io.undertow.util.SimpleObjectPool;
 
 /**
  * @author Stuart Douglas
@@ -49,16 +53,35 @@ public StreamSourceConduit wrap(ConduitFactory<StreamSourceConduit> factory, Htt
         }
     };
 
+    private volatile Inflater inflater;
+
+    private final PooledObject<Inflater> pooledObject;
     private final HttpServerExchange exchange;
-    private final Inflater inflater = new Inflater(true);
     private PooledByteBuffer compressed;
     private PooledByteBuffer uncompressed;
     private boolean nextDone = false;
     private boolean headerDone = false;
 
     public InflatingStreamSourceConduit(HttpServerExchange exchange, StreamSourceConduit next) {
+        this(exchange, next, newInstanceInflaterPool());
+    }
+
+    public InflatingStreamSourceConduit(
+            HttpServerExchange exchange,
+            StreamSourceConduit next,
+            ObjectPool<Inflater> inflaterPool) {
         super(next);
         this.exchange = exchange;
+        this.pooledObject = inflaterPool.allocate();
+        this.inflater = pooledObject.getObject();
+    }
+
+    public static ObjectPool<Inflater> newInstanceInflaterPool() {
+        return new NewInstanceObjectPool<Inflater>(() -> new Inflater(true), Inflater::end);
+    }
+
+    public static ObjectPool<Inflater> simpleInflaterPool(int poolSize) {
+        return new SimpleObjectPool<Inflater>(poolSize, () -> new Inflater(true), Inflater::end);
     }
 
     @Override
@@ -167,7 +190,10 @@ private void done() {
         if (uncompressed != null) {
             uncompressed.close();
         }
-        inflater.end();
+        if (inflater != null) {
+            pooledObject.close();
+            inflater = null;
+        }
     }
 
     public long transferTo(final long position, final long count, final FileChannel target) throws IOException {",2017-06-15T15:15:11Z,382
"@@ -397,7 +397,11 @@ public void setContentLength(final int len) {
         if (insideInclude || responseStarted()) {
             return;
         }
-        exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, Integer.toString(len));
+        if(len >= 0) {
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, Integer.toString(len));
+        } else {
+            exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
+        }
         this.contentLength = (long) len;
     }
 
@@ -406,7 +410,11 @@ public void setContentLengthLong(final long len) {
         if (insideInclude || responseStarted()) {
             return;
         }
-        exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, Long.toString(len));
+        if(len >= 0) {
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, Long.toString(len));
+        } else {
+            exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
+        }
         this.contentLength = len;
     }
 ",2018-04-12T21:37:50Z,170
"@@ -49,15 +49,13 @@
 import io.undertow.util.HttpString;
 import io.undertow.util.LocaleUtils;
 import io.undertow.util.Methods;
-import org.xnio.LocalSocketAddress;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.SocketAddress;
 import java.nio.charset.Charset;
 import java.nio.charset.UnsupportedCharsetException;
 import java.security.AccessController;
@@ -994,11 +992,9 @@ public String getLocalName() {
 
     @Override
     public String getLocalAddr() {
-        SocketAddress address = exchange.getDestinationAddress();
-         if (address instanceof InetSocketAddress) {
-            return ((InetSocketAddress) address).getAddress().getHostAddress();
-        } else if (address instanceof LocalSocketAddress) {
-            return ((LocalSocketAddress) address).getName();
+        InetSocketAddress address = exchange.getDestinationAddress();
+         if (address != null) {
+            return address.getAddress().getHostAddress();
         }
         return null;
     }",2018-03-01T03:14:10Z,147
"@@ -426,9 +426,18 @@ public void run() {
                     outboundRequestHeaders.put(entry.getKey(), headerValue.replace('\n', ' '));
                 }
             }
-
+            final String remoteHost;
             final SocketAddress address = exchange.getConnection().getPeerAddress();
-            final String remoteHost = (address != null && address instanceof InetSocketAddress) ? ((InetSocketAddress) address).getHostString() : ""localhost"";
+            if (address != null && address instanceof InetSocketAddress) {
+                remoteHost = ((InetSocketAddress) address).getHostString();
+                if(!((InetSocketAddress) address).isUnresolved()) {
+                    request.putAttachment(ProxiedRequestAttachments.REMOTE_ADDRESS, ((InetSocketAddress) address).getAddress().getHostAddress());
+                }
+            } else {
+                //should never happen, unless this is some form of mock request
+                remoteHost = ""localhost"";
+            }
+
             request.putAttachment(ProxiedRequestAttachments.REMOTE_HOST, remoteHost);
 
             if (reuseXForwarded && request.getRequestHeaders().contains(Headers.X_FORWARDED_FOR)) {",2017-01-25T01:58:47Z,92
"@@ -63,4 +63,8 @@ public interface ProxyClient {
     interface ProxyTarget {
 
     }
+
+    interface MaxRetriesProxyTarget extends ProxyTarget {
+        int getMaxRetries();
+    }
 }",2016-11-28T04:19:02Z,383
"@@ -174,7 +174,11 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             return;
         }
         final long timeout = maxRequestTime > 0 ? System.currentTimeMillis() + maxRequestTime : 0;
-        final ProxyClientHandler clientHandler = new ProxyClientHandler(exchange, target, timeout, maxConnectionRetries, idempotentRequestPredicate);
+        int maxRetries = maxConnectionRetries;
+        if(target instanceof ProxyClient.MaxRetriesProxyTarget) {
+            maxRetries = Math.max(maxRetries, ((ProxyClient.MaxRetriesProxyTarget) target).getMaxRetries());
+        }
+        final ProxyClientHandler clientHandler = new ProxyClientHandler(exchange, target, timeout, maxRetries, idempotentRequestPredicate);
         if (timeout > 0) {
             final XnioExecutor.Key key = WorkerUtils.executeAfter(exchange.getIoThread(), new Runnable() {
                 @Override",2016-11-28T04:19:02Z,92
"@@ -24,7 +24,7 @@
 /**
  * @author Emanuel Muckenhuber
  */
-public interface ModClusterProxyTarget extends ProxyClient.ProxyTarget {
+public interface ModClusterProxyTarget extends ProxyClient.ProxyTarget, ProxyClient.MaxRetriesProxyTarget {
 
     /**
      * Resolve the responsible context handling this request.
@@ -41,6 +41,8 @@ class ExistingSessionTarget implements ModClusterProxyTarget {
         private final boolean forceStickySession;
         private final ModClusterContainer container;
 
+        private Context resolved;
+
         public ExistingSessionTarget(String jvmRoute, VirtualHost.HostEntry entry, ModClusterContainer container, boolean forceStickySession) {
             this.jvmRoute = jvmRoute;
             this.entry = entry;
@@ -50,30 +52,77 @@ public ExistingSessionTarget(String jvmRoute, VirtualHost.HostEntry entry, ModCl
 
         @Override
         public Context resolveContext(HttpServerExchange exchange) {
+            if(resolved == null) {
+                resolveNode();
+            }
+            return resolved;
+        }
+
+        void resolveNode() {
+
             final Context context = entry.getContextForNode(jvmRoute);
             if (context != null && context.checkAvailable(true)) {
                 final Node node = context.getNode();
                 node.elected(); // Maybe move this to context#handleRequest
-                return context;
+                this.resolved = context;
+                return;
             }
             final String domain = context != null ? context.getNode().getNodeConfig().getDomain() : null;
-            return container.findFailoverNode(entry, domain, jvmRoute, forceStickySession);
+            this.resolved = container.findFailoverNode(entry, domain, jvmRoute, forceStickySession);
+        }
+
+        @Override
+        public int getMaxRetries() {
+            if(resolved == null) {
+                resolveNode();
+            }
+            if(resolved == null) {
+                return 0;
+            }
+            Balancer balancer = resolved.getNode().getBalancer();
+            if(balancer == null) {
+                return 0;
+            }
+            return balancer.getMaxattempts() - 1;
         }
     }
 
     class BasicTarget implements ModClusterProxyTarget {
 
         private final VirtualHost.HostEntry entry;
         private final ModClusterContainer container;
+        private Context resolved;
 
         public BasicTarget(VirtualHost.HostEntry entry, ModClusterContainer container) {
             this.entry = entry;
             this.container = container;
         }
 
+        @Override
+        public int getMaxRetries() {
+            if(resolved == null) {
+                resolveNode();
+            }
+            if(resolved == null) {
+                return 0;
+            }
+            Balancer balancer = resolved.getNode().getBalancer();
+            if(balancer == null) {
+                return 0;
+            }
+            return balancer.getMaxattempts() - 1;
+        }
+
         @Override
         public Context resolveContext(HttpServerExchange exchange) {
-            return container.findNewNode(entry);
+            if(resolved == null) {
+                resolveNode();
+            }
+            return resolved;
+        }
+
+        private void resolveNode() {
+            this.resolved = container.findNewNode(entry);
         }
     }
 ",2016-11-28T04:19:02Z,384
"@@ -20,6 +20,8 @@
 
 import io.undertow.client.ClientConnection;
 import io.undertow.server.ServerConnection;
+import io.undertow.util.HeaderMap;
+import io.undertow.util.HttpString;
 import org.jboss.logging.BasicLogger;
 import org.jboss.logging.Logger;
 import org.jboss.logging.annotations.Cause;
@@ -29,9 +31,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.net.URI;
 import java.sql.SQLException;
+import java.util.List;
 
 /**
  * log messages start at 5000
@@ -184,4 +188,96 @@ public interface UndertowLogger extends BasicLogger {
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5036, value = ""ALPN negotiation failed for %s and no fallback defined, closing connection"")
     void noALPNFallback(SocketAddress address);
+
+    /**
+     * Undertow mod_cluster proxy messages
+     */
+    @LogMessage(level = Logger.Level.WARN)
+    @Message(id = 5037, value = ""Name of the cookie containing the session id, %s, had been too long and was truncated to: %s"")
+    void stickySessionCookieLengthTruncated(String original, String current);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5038, value = ""Balancer created: id: %s, name: %s, stickySession: %s, stickySessionCookie: %s, stickySessionPath: %s, stickySessionRemove: %s, stickySessionForce: %s, waitWorker: %s, maxattempts: %s"")
+    void balancerCreated(int id, String name, boolean stickySession, String stickySessionCookie, String stickySessionPath, boolean stickySessionRemove,
+                                            boolean stickySessionForce, int waitWorker, int maxattempts);
+
+    @LogMessage(level = Logger.Level.INFO)
+    @Message(id = 5039, value = ""Undertow starts mod_cluster proxy advertisements on %s with frequency %s ms"")
+    void proxyAdvertisementsStarted(String address, int frequency);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5040, value = ""Gonna send payload:\n%s"")
+    void proxyAdvertiseMessagePayload(String payload);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5041, value = ""Cannot send advertise message. Address: %s"")
+    void proxyAdvertiseCannotSendMessage(@Cause Exception e, InetSocketAddress address);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5042, value = ""Undertow mod_cluster proxy MCMPHandler created"")
+    void mcmpHandlerCreated();
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5043, value = ""Error in processing MCMP commands: Type:%s, Mess: %s"")
+    void mcmpProcessingError(String type, String errString);
+
+    @LogMessage(level = Logger.Level.INFO)
+    @Message(id = 5044, value = ""Removing node %s"")
+    void removingNode(String jvmRoute);
+
+    // Aliases intentionally omitted from INFO level.
+    @LogMessage(level = Logger.Level.INFO)
+    @Message(id = 5045, value = ""Registering context %s, for node %s"")
+    void registeringContext(String contextPath, String jvmRoute);
+
+    // Context path and JVMRoute redundantly logged with DEBUG soa s to provide meaning for aliases.
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5046, value = ""Registering context %s, for node %s, with aliases %s"")
+    void registeringContext(String contextPath, String jvmRoute, List<String> aliases);
+
+    @LogMessage(level = Logger.Level.INFO)
+    @Message(id = 5047, value = ""Unregistering context %s, from node %s"")
+    void unregisteringContext(String contextPath, String jvmRoute);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5048, value = ""Node %s in error"")
+    void nodeIsInError(String jvmRoute);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5049, value = ""NodeConfig created: connectionURI: %s, balancer: %s, domain: %s, jvmRoute: %s, flushPackets: %s, flushwait: %s, ping: %s,"" +
+            ""ttl: %s, timeout: %s, maxConnections: %s, cacheConnections: %s, requestQueueSize: %s, queueNewRequests: %s"")
+    void nodeConfigCreated(URI connectionURI, String balancer, String domain, String jvmRoute, boolean flushPackets, int flushwait, int ping, long ttl,
+                           int timeout, int maxConnections, int cacheConnections, int requestQueueSize, boolean queueNewRequests);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5050, value = ""Failed to process management request"")
+    void failedToProcessManagementReq(@Cause Exception e);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5051, value = ""Failed to send ping response"")
+    void failedToSendPingResponse(@Cause Exception e);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5052, value = ""Failed to send ping response, node.getJvmRoute(): %s, jvmRoute: %s"")
+    void failedToSendPingResponseDBG(@Cause Exception e, String node, String jvmRoute);
+
+    @LogMessage(level = Logger.Level.INFO)
+    @Message(id = 5053, value = ""Registering node %s, connection: %s"")
+    void registeringNode(String jvmRoute, URI connectionURI);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5054, value = ""MCMP processing, key: %s, value: %s"")
+    void mcmpKeyValue(HttpString name, String value);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5055, value = ""HttpClientPingTask run for connection: %s"")
+    void httpClientPingTask(URI connection);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5056, value = ""Received node load in STATUS message, node jvmRoute: %s, load: %s"")
+    void receivedNodeLoad(String jvmRoute, String loadValue);
+
+    @LogMessage(level = Logger.Level.DEBUG)
+    @Message(id = 5057, value = ""Sending MCMP response to destination: %s, HTTP status: %s, Headers: %s, response: %s"")
+    void mcmpSendingResponse(InetSocketAddress destination, int status, HeaderMap headers, String response);
 }",2015-05-28T15:05:30Z,65
"@@ -18,6 +18,8 @@
 
 package io.undertow.server.handlers.proxy.mod_cluster;
 
+import io.undertow.UndertowLogger;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -83,6 +85,8 @@ public class Balancer {
         this.stickySessionForce = b.isStickySessionForce();
         this.waitWorker = b.getWaitWorker();
         this.maxattempts = b.getMaxattempts();
+        UndertowLogger.ROOT_LOGGER.balancerCreated(this.id, this.name, this.stickySession, this.stickySessionCookie, this.stickySessionPath,
+                this.stickySessionRemove,  this.stickySessionForce, this.waitWorker, this.maxattempts);
     }
 
     public int getId() {
@@ -212,6 +216,7 @@ public String getStickySessionCookie() {
         public BalancerBuilder setStickySessionCookie(String stickySessionCookie) {
             if (stickySessionCookie != null && stickySessionCookie.length() > 30) {
                 this.stickySessionCookie = stickySessionCookie.substring(0, 30);
+                UndertowLogger.ROOT_LOGGER.stickySessionCookieLengthTruncated(stickySessionCookie, this.stickySessionCookie);
             } else {
                 this.stickySessionCookie = stickySessionCookie;
             }",2015-05-28T15:05:30Z,259
"@@ -104,7 +104,7 @@ public void handleEvent(MulticastMessageChannel channel) {
             ssalt = md.digest();
         }
 
-        UndertowLogger.ROOT_LOGGER.infof(""Undertow starts mod_cluster proxy advertisements on %s with frequency %d ms."", address, config.getAdvertiseFrequency());
+        UndertowLogger.ROOT_LOGGER.proxyAdvertisementsStarted(address.toString(), config.getAdvertiseFrequency());
     }
 
     private static final String CRLF = ""\r\n"";
@@ -161,10 +161,10 @@ public void run() {
 
             final String payload = builder.toString();
             final ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes());
-            UndertowLogger.ROOT_LOGGER.debugf(""Gonna send payload: \n%s"", payload);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseMessagePayload(payload);
             channel.sendTo(address, byteBuffer);
         } catch (Exception e) {
-            UndertowLogger.ROOT_LOGGER.errorf(e, ""Cannot send advertise message. address: %s"", address);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseCannotSendMessage(e, address);
         }
     }
 ",2015-05-28T15:05:30Z,260
"@@ -123,6 +123,7 @@ public MCMPHandler(MCMPConfig config, ModCluster modCluster, HttpHandler next) {
         this.modCluster = modCluster;
         this.container = modCluster.getContainer();
         this.parserFactory = FormParserFactory.builder(false).addParser(new FormEncodedDataDefinition().setForceCreation(true)).build();
+        UndertowLogger.ROOT_LOGGER.mcmpHandlerCreated();
     }
 
     @Override
@@ -148,7 +149,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         try {
             handleRequest(method, exchange);
         } catch (Exception e) {
-            UndertowLogger.ROOT_LOGGER.errorf(e, ""failed to process management request"");
+            UndertowLogger.ROOT_LOGGER.failedToProcessManagementReq(e);
             exchange.setResponseCode(StatusCodes.INTERNAL_SERVER_ERROR);
             exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, CONTENT_TYPE);
             final Sender sender = exchange.getResponseSender();
@@ -207,6 +208,7 @@ private void processConfig(final HttpServerExchange exchange, final RequestData
             final HttpString name = i.next();
             final String value = requestData.getFirst(name);
 
+            UndertowLogger.ROOT_LOGGER.mcmpKeyValue(name, value);
             if (!checkString(value)) {
                 processError(TYPESYNTAX, SBADFLD + name + SBADFLD1, exchange);
                 return;
@@ -427,6 +429,7 @@ void processStatus(final HttpServerExchange exchange, final RequestData requestD
             return;
         }
 
+        UndertowLogger.ROOT_LOGGER.receivedNodeLoad(jvmRoute, loadValue);
         final int load = Integer.valueOf(loadValue);
         if (load > 0 || load == -2) {
 
@@ -447,7 +450,7 @@ public void completed() {
                         }
                         sendResponse(exchange, response);
                     } catch (Exception e) {
-                        UndertowLogger.ROOT_LOGGER.debugf(e, ""failed to send ping response"");
+                        UndertowLogger.ROOT_LOGGER.failedToSendPingResponse(e);
                     }
                 }
 
@@ -458,7 +461,7 @@ public void failed() {
                         node.markInError();
                         sendResponse(exchange, response);
                     } catch (Exception e) {
-                        UndertowLogger.ROOT_LOGGER.debugf(e, ""failed to send ping response"");
+                        UndertowLogger.ROOT_LOGGER.failedToSendPingResponseDBG(e, node.getJvmRoute(), jvmRoute);
                     }
                 }
             };
@@ -689,6 +692,7 @@ static void sendResponse(final HttpServerExchange exchange, final String respons
         exchange.setResponseCode(StatusCodes.OK);
         exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, CONTENT_TYPE);
         final Sender sender = exchange.getResponseSender();
+        UndertowLogger.ROOT_LOGGER.mcmpSendingResponse(exchange.getSourceAddress(), exchange.getResponseCode(), exchange.getResponseHeaders(), response);
         sender.send(response);
     }
 
@@ -721,6 +725,7 @@ static void processError(String type, String errString, HttpServerExchange excha
         exchange.getResponseHeaders().add(new HttpString(""Type""), type);
         exchange.getResponseHeaders().add(new HttpString(""Mess""), errString);
         exchange.endExchange();
+        UndertowLogger.ROOT_LOGGER.mcmpProcessingError(type, errString);
     }
 
     /**",2015-05-28T15:05:30Z,100
"@@ -189,7 +189,7 @@ public synchronized boolean addNode(final NodeConfig config, final Balancer.Bala
         }
         // Remove from the failover groups
         failoverDomains.remove(node.getJvmRoute());
-        UndertowLogger.ROOT_LOGGER.infof(""registering node %s, connection: %s"", jvmRoute, config.getConnectionURI());
+        UndertowLogger.ROOT_LOGGER.registeringNode(jvmRoute, config.getConnectionURI());
         return true;
     }
 
@@ -269,7 +269,7 @@ protected synchronized void removeNode(final Node node, boolean onlyInError) {
         final String jvmRoute = node.getJvmRoute();
         node.markRemoved();
         if (nodes.remove(jvmRoute, node)) {
-            UndertowLogger.ROOT_LOGGER.infof(""removing node %s"", jvmRoute);
+             UndertowLogger.ROOT_LOGGER.removingNode(jvmRoute);
             node.markRemoved();
             // Remove the health check
             removeHealthCheck(node, node.getIoThread());
@@ -309,7 +309,8 @@ public synchronized boolean enableContext(final String contextPath, final String
             Context context = node.getContext(contextPath, aliases);
             if (context == null) {
                 context = node.registerContext(contextPath, aliases);
-                UndertowLogger.ROOT_LOGGER.infof(""registering context %s, for node %s, with aliases %s"", contextPath, jvmRoute, aliases);
+                UndertowLogger.ROOT_LOGGER.registeringContext(contextPath, jvmRoute);
+                UndertowLogger.ROOT_LOGGER.registeringContext(contextPath, jvmRoute, aliases);
                 for (final String alias : aliases) {
                     VirtualHost virtualHost = hosts.get(alias);
                     if (virtualHost == null) {
@@ -355,7 +356,7 @@ public synchronized boolean removeContext(final String contextPath, final Node n
             return false;
         }
         final String jvmRoute = node.getJvmRoute();
-        UndertowLogger.ROOT_LOGGER.infof(""unregistering context '%s' from node '%s'"", contextPath, jvmRoute);
+        UndertowLogger.ROOT_LOGGER.unregisteringContext(contextPath, jvmRoute);
         final Context context = node.removeContext(contextPath, aliases);
         if (context == null) {
             return false;",2015-05-28T15:05:30Z,261
"@@ -367,7 +367,7 @@ protected void markInError() {
             oldState = this.state;
             newState = oldState | ERROR;
             if (stateUpdater.compareAndSet(this, oldState, newState)) {
-                UndertowLogger.ROOT_LOGGER.debugf(""Node '%s' in error"", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
                 return;
             }
         }
@@ -395,7 +395,7 @@ private int healthCheckFailed() {
             oldState = this.state;
             if ((oldState & ERROR) != ERROR) {
                 newState = oldState | ERROR;
-                UndertowLogger.ROOT_LOGGER.debugf(""Node '%s' in error"", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
             } else if ((oldState & ERROR_MASK) == ERROR_MASK) {
                 return ERROR_MASK;
             } else {",2015-05-28T15:05:30Z,262
"@@ -17,6 +17,8 @@
  */
 package io.undertow.server.handlers.proxy.mod_cluster;
 
+import io.undertow.UndertowLogger;
+
 import java.net.URI;
 import java.net.URISyntaxException;
 
@@ -95,6 +97,7 @@ public class NodeConfig {
         cacheConnections = b.cacheConnections;
         requestQueueSize = b.requestQueueSize;
         queueNewRequests = b.queueNewRequests;
+        UndertowLogger.ROOT_LOGGER.nodeConfigCreated(this.connectionURI, balancer, domain, jvmRoute, flushPackets, flushwait, ping, ttl, timeout, maxConnections, cacheConnections, requestQueueSize, queueNewRequests);
     }
 
     /**",2015-05-28T15:05:30Z,263
"@@ -24,6 +24,7 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.TimeUnit;
 
+import io.undertow.UndertowLogger;
 import io.undertow.client.ClientCallback;
 import io.undertow.client.ClientConnection;
 import io.undertow.client.ClientExchange;
@@ -308,6 +309,7 @@ static class HttpClientPingTask implements Runnable {
         @Override
         public void run() {
 
+            UndertowLogger.ROOT_LOGGER.httpClientPingTask(connection);
             // TODO AJP has a special ping thing
             client.connect(new ClientCallback<ClientConnection>() {
                 @Override",2015-05-28T15:05:30Z,264
"@@ -18,11 +18,11 @@
 
 package io.undertow.util;
 
+import java.io.UnsupportedEncodingException;
+
 import io.undertow.UndertowMessages;
 import io.undertow.server.HttpServerExchange;
 
-import java.io.UnsupportedEncodingException;
-
 /**
  * Utilities for dealing with URLs
  *
@@ -71,7 +71,6 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
         boolean needToChange = false;
         int numChars = s.length();
         int i = 0;
-        boolean mightRequireSlashEscape = false;
 
         char c;
         byte[] bytes = null;
@@ -108,6 +107,18 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
                             if (c == '%') {
                                 char p1 = Character.toLowerCase(s.charAt(i + 1));
                                 char p2 = Character.toLowerCase(s.charAt(i + 2));
+                                if (!decodeSlash && ((p1 == '2' && p2 == 'f') || (p1 == '5' && p2 == 'c'))) {
+                                    bytes[pos++] = (byte) c;
+                                    // should be copied with preserved upper/lower case
+                                    bytes[pos++] = (byte) s.charAt(i + 1);
+                                    bytes[pos++] = (byte) s.charAt(i + 2);
+                                    i += 3;
+
+                                    if (i < numChars) {
+                                        c = s.charAt(i);
+                                    }
+                                    continue;
+                                }
                                 int v = 0;
                                 if (p1 >= '0' && p1 <= '9') {
                                     v = (p1 - '0') << 4;
@@ -126,9 +137,6 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
                                 if (v < 0) {
                                     throw UndertowMessages.MESSAGES.failedToDecodeURL(s, enc, null);
                                 }
-                                if (v == '/' || v == '\\') {
-                                    mightRequireSlashEscape = true;
-                                }
 
                                 bytes[pos++] = (byte) v;
                                 i += 3;
@@ -151,27 +159,7 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
                         }
 
                         String decoded = new String(bytes, 0, pos, enc);
-                        if (!decodeSlash && mightRequireSlashEscape) {
-                            //we need to re-encode slash characters
-                            //this is yuck, but a corner case
-                            int decPos = 0;
-                            for (int j = 0; j < decoded.length(); ++j) {
-                                char decChar = decoded.charAt(j);
-                                if (decChar == '/') {
-                                    buffer.append(decoded.substring(decPos, j));
-                                    buffer.append(""%2F"");
-                                    decPos = j + 1;
-                                } else if (decChar == '\\') {
-                                    buffer.append(decoded.substring(decPos, j));
-                                    buffer.append(""%5C"");
-                                    decPos = j + 1;
-                                }
-                            }
-                            buffer.append(decoded.substring(decPos));
-                        } else {
-                            buffer.append(decoded);
-                        }
-                        mightRequireSlashEscape = false;
+                        buffer.append(decoded);
                     } catch (NumberFormatException e) {
                         throw UndertowMessages.MESSAGES.failedToDecodeURL(s, enc, e);
                     } catch (UnsupportedEncodingException e) {",2017-01-06T00:32:40Z,276
"@@ -0,0 +1,59 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.util;
+
+import java.nio.charset.Charset;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+
+import static org.junit.Assert.assertEquals;
+/**
+ * @author Oleksandr Radchykov
+ */
+@RunWith(Parameterized.class)
+public class URLUtilsTestCase {
+
+    @Parameterized.Parameters
+    public static Object[] spaceCodes() {
+        return new Object[] { ""%2f"", ""%2F"" };
+    }
+
+    @Parameterized.Parameter
+    public String spaceCode = ""%2f"";
+
+    @Test
+    public void testDecodingWithEncodedAndDecodedSlashAndSlashDecodingDisabled() throws Exception {
+        String url = ""http://localhost:3001/by-path/wild%20card/wild%28west%29/wild"" + spaceCode + ""wolf"";
+
+        final String result = URLUtils.decode(url, Charset.defaultCharset().name(), false, new StringBuilder());
+        assertEquals(""http://localhost:3001/by-path/wild card/wild(west)/wild"" + spaceCode + ""wolf"", result);
+    }
+
+    @Test
+    public void testDecodingURLMustNotMutateSpaceSymbolsCaseIfSpaceDecodingDisabled() throws Exception {
+        final String url = ""http://localhost:3001/wild"" + spaceCode + ""west"";
+
+        final String result = URLUtils.decode(url, Charset.defaultCharset().name(), false, new StringBuilder());
+        assertEquals(url, result);
+    }
+
+}",2017-01-06T00:32:40Z,325
"@@ -30,7 +30,7 @@ public class SecureExchangeAttribute implements ExchangeAttribute {
 
     @Override
     public String readAttribute(HttpServerExchange exchange) {
-        return Boolean.toString(exchange.getProtocol().equalToString(""https""));
+        return Boolean.toString(exchange.getRequestScheme().toLowerCase().equals(""https""));
     }
 
     @Override",2017-04-26T22:49:55Z,385
"@@ -50,15 +50,17 @@ public class ExtendedAccessLogFileTestCase {
 
     private static final Path logDirectory = Paths.get(System.getProperty(""java.io.tmpdir""), ""logs"");
 
-    public static final String PATTERN = ""cs-uri cs(test-header) x-O(Connection)"";
+    public static final String PATTERN = ""cs-uri cs(test-header) x-O(Connection) x-H(secure)"";
 
     @Before
     public void before() throws IOException {
         Files.createDirectories(logDirectory);
+        DefaultServer.startSSLServer();
     }
 
     @After
     public void after() throws IOException {
+        DefaultServer.stopSSLServer();
         FileUtils.deleteRecursive(logDirectory);
     }
 
@@ -85,8 +87,9 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
         CompletionLatchHandler latchHandler;
         DefaultServer.setRootHandler(latchHandler = new CompletionLatchHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, PATTERN, new ExtendedAccessLogParser( ExtendedAccessLogFileTestCase.class.getClassLoader()).parse(PATTERN))));
         TestHttpClient client = new TestHttpClient();
+        client.setSSLContext(DefaultServer.getClientSSLContext());
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerSSLAddress() + ""/path"");
             get.addHeader(""test-header"", ""single-val"");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
@@ -99,7 +102,7 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
             Assert.assertEquals(""#Version: 2.0"", lines[1]);
             Assert.assertEquals(""#Software: "" + Version.getFullVersionString(), lines[2]);
             Assert.assertEquals("""", lines[3]);
-            Assert.assertEquals(""/path 'single-val' 'keep-alive'"", lines[4]);
+            Assert.assertEquals(""/path 'single-val' 'keep-alive' true"", lines[4]);
         } finally {
             client.getConnectionManager().shutdown();
         }",2017-04-26T22:49:55Z,386
"@@ -30,7 +30,7 @@ public class SecureExchangeAttribute implements ExchangeAttribute {
 
     @Override
     public String readAttribute(HttpServerExchange exchange) {
-        return Boolean.toString(exchange.getProtocol().equalToString(""https""));
+        return Boolean.toString(exchange.getRequestScheme().toLowerCase().equals(""https""));
     }
 
     @Override",2017-04-26T22:49:55Z,385
"@@ -50,15 +50,17 @@ public class ExtendedAccessLogFileTestCase {
 
     private static final Path logDirectory = Paths.get(System.getProperty(""java.io.tmpdir""), ""logs"");
 
-    public static final String PATTERN = ""cs-uri cs(test-header) x-O(Connection)"";
+    public static final String PATTERN = ""cs-uri cs(test-header) x-O(Connection) x-H(secure)"";
 
     @Before
     public void before() throws IOException {
         Files.createDirectories(logDirectory);
+        DefaultServer.startSSLServer();
     }
 
     @After
     public void after() throws IOException {
+        DefaultServer.stopSSLServer();
         FileUtils.deleteRecursive(logDirectory);
     }
 
@@ -85,8 +87,9 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
         CompletionLatchHandler latchHandler;
         DefaultServer.setRootHandler(latchHandler = new CompletionLatchHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, PATTERN, new ExtendedAccessLogParser( ExtendedAccessLogFileTestCase.class.getClassLoader()).parse(PATTERN))));
         TestHttpClient client = new TestHttpClient();
+        client.setSSLContext(DefaultServer.getClientSSLContext());
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerSSLAddress() + ""/path"");
             get.addHeader(""test-header"", ""single-val"");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
@@ -99,7 +102,7 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
             Assert.assertEquals(""#Version: 2.0"", lines[1]);
             Assert.assertEquals(""#Software: "" + Version.getFullVersionString(), lines[2]);
             Assert.assertEquals("""", lines[3]);
-            Assert.assertEquals(""/path 'single-val' 'keep-alive'"", lines[4]);
+            Assert.assertEquals(""/path 'single-val' 'keep-alive' true"", lines[4]);
         } finally {
             client.getConnectionManager().shutdown();
         }",2017-04-26T22:49:55Z,386
"@@ -169,6 +169,29 @@
         </testResources>
 
         <plugins>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    org.eclipse.jetty.*;resolution:=optional;version=""[1,2)"",
+                                    !., !sun.*, !org.xnio._private, *
+                                </Import-Package>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
@@ -183,6 +206,11 @@
                         </configuration>
                     </execution>
                 </executions>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
             </plugin>
             <plugin>
                 <groupId>org.bitstrings.maven.plugins</groupId>",2017-06-21T03:54:32Z,333
"@@ -409,4 +409,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String
     @LogMessage(level = ERROR)
     @Message(id = 5088, value = ""Failed to execute ServletOutputStream.closeAsync() on IO thread"")
     void closeAsyncFailed(@Cause IOException e);
+
+    @Message(id = 5089, value = ""Method parameter '%s' cannot be null"")
+    IllegalArgumentException nullParameter(String name);
 }",2017-06-21T03:54:32Z,65
"@@ -54,8 +54,6 @@
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLParameters;
 
-import static org.xnio._private.Messages.msg;
-
 /**
  * @author Stuart Douglas
  */
@@ -144,7 +142,7 @@ public <T> T setOption(final Option<T> option, final T value) throws IllegalArgu
         } else {
             return tcpServer.setOption(option, value);
         }
-        throw msg.nullParameter(""value"");
+        throw UndertowLogger.ROOT_LOGGER.nullParameter(""value"");
     }
 
     public XnioWorker getWorker() {",2017-06-21T03:54:32Z,232
"@@ -0,0 +1,196 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ JBoss, Home of Professional Open Source.
+  ~ Copyright 2012 Red Hat, Inc., and individual contributors
+  ~ as indicated by the @author tags.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>io.undertow</groupId>
+        <artifactId>undertow-parent</artifactId>
+        <version>2.0.0.Alpha2-SNAPSHOT</version>
+    </parent>
+
+    <groupId>io.undertow</groupId>
+    <artifactId>karaf</artifactId>
+    <version>2.0.0.Alpha2-SNAPSHOT</version>
+    <packaging>pom</packaging>
+
+    <name>Undertow Karaf Features</name>
+
+    <properties>
+        <test.level>INFO</test.level>
+        <ajp>false</ajp>
+        <proxy>false</proxy>
+        <dump>false</dump>
+        <https>false</https>
+        <openssl>false</openssl>
+        <test.ipv6>false</test.ipv6>
+        <bufferSize>8192</bufferSize>
+        <libraryPath></libraryPath>
+        <java.library.path></java.library.path>
+        <org.wildfly.openssl.path></org.wildfly.openssl.path>
+        <dependency.karaf.version>4.0.7</dependency.karaf.version>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.karaf.features</groupId>
+            <artifactId>framework</artifactId>
+            <version>${dependency.karaf.version}</version>
+            <type>kar</type>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-core</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-servlet</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-websockets-jsr</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging-processor</artifactId>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.xnio</groupId>
+            <artifactId>xnio-api</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.xnio</groupId>
+            <artifactId>xnio-nio</artifactId>
+            <scope>runtime</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.eclipse.jetty.alpn</groupId>
+            <artifactId>alpn-api</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+
+    <build>
+        <resources>
+            <resource>
+                <directory>src/main/resources</directory>
+                <filtering>true</filtering>
+            </resource>
+        </resources>
+
+        <plugins>
+            <plugin>
+                <groupId>io.reformanda.semper</groupId>
+                <artifactId>dependencyversion-maven-plugin</artifactId>
+                <version>1.0.0</version>
+                <executions>
+                    <execution>
+                        <id>set-all</id>
+                        <goals>
+                            <goal>set-version</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>filter</id>
+                        <phase>generate-resources</phase>
+                        <goals>
+                            <goal>resources</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.karaf.tooling</groupId>
+                <artifactId>karaf-maven-plugin</artifactId>
+                <version>${dependency.karaf.version}</version>
+                <executions>
+                    <execution>
+                        <id>verify</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>verify</goal>
+                        </goals>
+                        <configuration>
+                            <descriptors>
+                                <descriptor>mvn:org.apache.karaf.features/framework/${dependency.karaf.version}/xml/features</descriptor>
+                                <descriptor>file:${project.build.directory}/classes/features.xml</descriptor>
+                            </descriptors>
+                            <distribution>org.apache.karaf.features:framework</distribution>
+                            <javase>1.8</javase>
+                            <framework>
+                                <feature>framework</feature>
+                            </framework>
+                            <features>
+                                <feature>undertow</feature>
+                            </features>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>build-helper-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>attach-artifacts</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>attach-artifact</goal>
+                        </goals>
+                        <configuration>
+                            <artifacts>
+                                <artifact>
+                                    <file>target/classes/features.xml</file>
+                                    <type>xml</type>
+                                    <classifier>features</classifier>
+                                </artifact>
+                            </artifacts>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2017-06-21T03:54:32Z,334
"@@ -0,0 +1,34 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- 
+
+    Licensed under the Apache License, Version 2.0 (the ""License"");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+
+<features name=""io.undertow-${project.version}"" xmlns=""http://karaf.apache.org/xmlns/features/v1.0.0"">
+
+    <feature name=""undertow"" version=""${project.version}"">
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.annotation/jboss-annotations-api_1.2_spec/${version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.servlet/jboss-servlet-api_4.0_spec/${version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.spec.javax.websocket/jboss-websocket-api_1.1_spec/${version.org.jboss.spec.javax.websockets}</bundle>
+        <bundle dependency=""true"">mvn:org.jboss.logging/jboss-logging/${version.org.jboss.logging}</bundle>
+        <bundle dependency=""true"">mvn:org.wildfly.common/wildfly-common/${org.wildfly.common:wildfly-common:jar.version}</bundle>
+        <bundle dependency=""true"">mvn:org.wildfly.client/wildfly-client-config/${org.wildfly.client:wildfly-client-config:jar.version}</bundle>
+        <bundle>mvn:org.jboss.xnio/xnio-api/${version.xnio}</bundle>
+        <bundle>mvn:org.jboss.xnio/xnio-nio/${version.xnio}</bundle>
+        <bundle>mvn:io.undertow/undertow-core/${project.version}</bundle>
+        <bundle>mvn:io.undertow/undertow-servlet/${project.version}</bundle>
+        <bundle>mvn:io.undertow/undertow-websockets-jsr/${project.version}</bundle>
+    </feature>
+
+</features>",2017-06-21T03:54:32Z,335
"@@ -70,14 +70,16 @@
         <version.org.apache.httpcomponents>4.2.6</version.org.apache.httpcomponents>
         <version.org.glassfish.el>3.0.1-b08</version.org.glassfish.el>
         <version.org.jboss.classfilewriter>1.0.5.Final</version.org.jboss.classfilewriter>
-        <version.org.jboss.logging>3.2.1.Final</version.org.jboss.logging>
+        <version.org.jboss.logging>3.3.0.Final</version.org.jboss.logging>
         <version.org.jboss.logging.processor>2.0.0.Final</version.org.jboss.logging.processor>
         <version.org.jboss.logmanager>2.0.0.Final</version.org.jboss.logmanager>
         <version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>1.0.0.Alpha3</version.org.jboss.spec.javax.servlet.jboss-servlet-api_4.0_spec>
         <version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>1.0.0.Final</version.org.jboss.spec.javax.annotation.jboss-annotations-api_1.2_spec>
         <version.org.jboss.spec.javax.servlet.jsp>1.0.0.Final</version.org.jboss.spec.javax.servlet.jsp>
         <version.org.jboss.spec.javax.websockets>1.1.0.Final</version.org.jboss.spec.javax.websockets>
-        <version.xnio>3.3.6.Final</version.xnio>
+        <version.xnio>3.5.0.Beta7</version.xnio>
+        <version.org.wildfly.client.config>1.0.0.Beta5</version.org.wildfly.client.config> <!-- TODO: remove this once XNIO has been updated to include this version -->
+        <version.org.osgi.core>6.0.0</version.org.osgi.core>
 
         <!-- jacoco -->
         <version.org.jacoco>0.7.9</version.org.jacoco>
@@ -117,6 +119,7 @@
         <module>servlet</module>
         <module>examples</module>
         <module>websockets-jsr</module>
+        <module>karaf</module>
     </modules>
 
     <build>
@@ -239,6 +242,11 @@
                         </lifecycleMappingMetadata>
                     </configuration>
                 </plugin>
+                <plugin>
+                    <groupId>org.apache.felix</groupId>
+                    <artifactId>maven-bundle-plugin</artifactId>
+                    <version>3.2.0</version>
+                </plugin>
             </plugins>
         </pluginManagement>
     </build>
@@ -413,6 +421,18 @@
                 <version>${version.xnio}</version>
             </dependency>
 
+            <dependency>
+                <groupId>org.wildfly.client</groupId>
+                <artifactId>wildfly-client-config</artifactId>
+                <version>${version.org.wildfly.client.config}</version>
+            </dependency>
+
+            <dependency>
+                <groupId>org.osgi</groupId>
+                <artifactId>org.osgi.core</artifactId>
+                <version>${version.org.osgi.core}</version>
+            </dependency>
+
             <dependency>
                 <groupId>com.h2database</groupId>
                 <artifactId>h2</artifactId>",2017-06-21T03:54:32Z,265
"@@ -65,6 +65,14 @@
             <groupId>org.jboss.spec.javax.annotation</groupId>
             <artifactId>jboss-annotations-api_1.2_spec</artifactId>
         </dependency>
+
+        <dependency>
+            <groupId>org.osgi</groupId>
+            <artifactId>org.osgi.core</artifactId>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
+
         <!-- Test dependencies -->
 
         <dependency>
@@ -153,6 +161,31 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.servlet*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    !sun.*, *
+                                </Import-Package>
+                                <Bundle-Activator>
+                                    io.undertow.servlet.osgi.Activator
+                                </Bundle-Activator>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
@@ -167,6 +200,11 @@
                         </configuration>
                     </execution>
                 </executions>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>",2017-06-21T03:54:32Z,313
"@@ -284,6 +284,13 @@ private void handleExtensions(final DeploymentInfo deploymentInfo, final Servlet
                 }
             }
         }
+
+        for (ServletExtension extension : ServletExtensionHolder.getServletExtensions()) {
+            if (!loadedExtensions.contains(extension.getClass())) {
+                extension.handleDeployment(deploymentInfo, servletContext);
+            }
+        }
+
         for(ServletExtension extension : deploymentInfo.getServletExtensions()) {
             extension.handleDeployment(deploymentInfo, servletContext);
         }",2017-06-21T03:54:32Z,80
"@@ -0,0 +1,39 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.core;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.undertow.servlet.ServletExtension;
+
+/**
+ * Holder for global ServletExtension services.
+ * This is particularly useful in an OSGi environment where classloader constraints
+ * lead to the ServiceLoader not able to see ServletExtension implementations.
+ */
+public class ServletExtensionHolder {
+
+    private static List<ServletExtension> extensions = new CopyOnWriteArrayList<>();
+
+    public static List<ServletExtension> getServletExtensions() {
+        return extensions;
+    }
+
+}",2017-06-21T03:54:32Z,336
"@@ -0,0 +1,67 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.osgi;
+
+import io.undertow.servlet.ServletExtension;
+import io.undertow.servlet.core.ServletExtensionHolder;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.util.tracker.ServiceTracker;
+import org.osgi.util.tracker.ServiceTrackerCustomizer;
+
+/**
+ * OSGi Activator.
+ * The activator is called when the bundle is started.
+ * It tracks ServletExtension services registered in the OSGi registry
+ * and will update the {@link ServletExtensionHolder#getServletExtensions()}
+ * list accordingly.
+ */
+public class Activator implements BundleActivator, ServiceTrackerCustomizer<ServletExtension, ServletExtension> {
+
+    BundleContext bundleContext;
+    ServiceTracker<ServletExtension, ServletExtension> tracker;
+
+    @Override
+    public void start(BundleContext context) throws Exception {
+        bundleContext = context;
+        tracker = new ServiceTracker<>(context, ServletExtension.class, this);
+        tracker.open();
+    }
+
+    @Override
+    public void stop(BundleContext context) throws Exception {
+        tracker.close();
+    }
+
+    @Override
+    public ServletExtension addingService(ServiceReference<ServletExtension> reference) {
+        return null;
+    }
+
+    @Override
+    public void modifiedService(ServiceReference<ServletExtension> reference, ServletExtension service) {
+        ServletExtensionHolder.getServletExtensions().add(service);
+    }
+
+    @Override
+    public void removedService(ServiceReference<ServletExtension> reference, ServletExtension service) {
+        ServletExtensionHolder.getServletExtensions().remove(service);
+    }
+}",2017-06-21T03:54:32Z,337
"@@ -60,6 +60,12 @@
             <artifactId>jboss-logging-processor</artifactId>
             <scope>provided</scope>
         </dependency>
+        <dependency>
+            <groupId>org.osgi</groupId>
+            <artifactId>org.osgi.core</artifactId>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
 
         <!-- Test dependencies -->
 
@@ -128,6 +134,31 @@
         </testResources>
 
         <plugins>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>generate-manifest</id>
+                        <goals>
+                            <goal>manifest</goal>
+                        </goals>
+                        <configuration>
+                            <instructions>
+                                <Export-Package>
+                                    io.undertow.websockets.jsr.*;version=${project.version};-noimport:=true
+                                </Export-Package>
+                                <Import-Package>
+                                    !sun.*, *
+                                </Import-Package>
+                                <Bundle-Activator>
+                                    io.undertow.websockets.jsr.osgi.Activator
+                                </Bundle-Activator>
+                            </instructions>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
@@ -149,6 +180,15 @@
                     <argLine>${surefire.system.args} ${jacoco.agent.argLine}</argLine>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <archive>
+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                    </archive>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2017-06-21T03:54:32Z,236
"@@ -0,0 +1,46 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.websockets.jsr.osgi;
+
+import io.undertow.servlet.ServletExtension;
+import io.undertow.websockets.jsr.Bootstrap;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+
+/**
+ * OSGi Activator.  This activator will be called when the bundle is started.
+ * Its purpose is to register the ServletExtension to support websockets.
+ */
+public class Activator implements BundleActivator {
+
+    ServiceRegistration<ServletExtension> registration;
+
+    @Override
+    public void start(BundleContext context) throws Exception {
+        // Register the service in the OSGi registry.
+        registration = context.registerService(ServletExtension.class, new Bootstrap(), null);
+    }
+
+    @Override
+    public void stop(BundleContext context) throws Exception {
+        // Now, unregister the service.
+        registration.unregister();
+    }
+}",2017-06-21T03:54:32Z,338
"@@ -35,6 +35,6 @@
  */
 public interface ClassIntrospecter {
 
-    <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz);
+    <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz) throws NoSuchMethodException;
 
 }",2012-09-27T04:52:25Z,387
"@@ -33,7 +33,6 @@
 import javax.servlet.ServletException;
 
 import io.undertow.server.HttpHandler;
-import io.undertow.server.handlers.PathHandler;
 import io.undertow.server.handlers.blocking.BlockingHttpHandler;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.api.Deployment;
@@ -194,7 +193,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
                 if (path.equals(""/"")) {
                     //the default servlet
                     defaultServlet = handler;
-                    defaultHandler = servletChain(handler, threadSetupAction, listeners);
+                    defaultHandler = servletChain(handler, threadSetupAction, listeners, servlet);
                 } else if (!path.startsWith(""*."")) {
                     pathMatches.add(path);
                     if (pathServlets.containsKey(path)) {
@@ -210,11 +209,11 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
         }
 
         if (defaultServlet == null) {
-            DefaultServlet defaultInstance = new DefaultServlet(deploymentInfo.getResourceLoader(), deploymentInfo.getWelcomePages());
+            DefaultServlet defaultInstance = new DefaultServlet( deployment, deploymentInfo.getWelcomePages());
             final ManagedServlet managedDefaultServlet = new ManagedServlet(new ServletInfo(""DefaultServlet"", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance)), servletContext);
             lifecycles.add(managedDefaultServlet);
             defaultServlet = new ServletHandler(managedDefaultServlet);
-            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, executor == null ? null : executor.getInstance());
+            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, executor == null ? null : executor.getInstance(), null);
         }
 
         final ServletPathMatches.Builder builder = ServletPathMatches.builder();
@@ -261,7 +260,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
             final ServletInitialHandler initialHandler;
             if (noExtension.isEmpty()) {
                 if (targetServlet != null) {
-                    initialHandler = servletChain(targetServlet, threadSetupAction, listeners);
+                    initialHandler = servletChain(targetServlet, threadSetupAction, listeners, targetServlet.getManagedServlet().getServletInfo());
                 } else {
                     initialHandler = defaultHandler;
                 }
@@ -272,7 +271,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
                 } else {
                     handler = new FilterHandler(noExtension, defaultServlet);
                 }
-                initialHandler = servletChain(handler, threadSetupAction, listeners);
+                initialHandler = servletChain(handler, threadSetupAction, listeners, targetServlet == null ? null : targetServlet.getManagedServlet().getServletInfo());
             }
 
             if (path.endsWith(""/*"")) {
@@ -291,7 +290,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
                         } else {
                             handler = new FilterHandler(entry.getValue(), defaultServlet);
                         }
-                        builder.addExtensionMatch(prefix, entry.getKey(), servletChain(handler, threadSetupAction, listeners));
+                        builder.addExtensionMatch(prefix, entry.getKey(), servletChain(handler, threadSetupAction, listeners, pathServlet == null ? null : pathServlet.getManagedServlet().getServletInfo()));
                     }
                 }
             } else if (path.isEmpty()) {
@@ -327,15 +326,15 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
             }
 
             if (extension.isEmpty() && targetServlet != null) {
-                builder.addExtensionMatch("""", path, servletChain(targetServlet, threadSetupAction, listeners));
+                builder.addExtensionMatch("""", path, servletChain(targetServlet, threadSetupAction, listeners, targetServlet.getManagedServlet().getServletInfo()));
             } else if (!extension.isEmpty()) {
                 FilterHandler handler;
                 if (targetServlet != null) {
                     handler = new FilterHandler(extension, targetServlet);
                 } else {
                     handler = new FilterHandler(extension, defaultServlet);
                 }
-                builder.addExtensionMatch("""", path, servletChain(handler, threadSetupAction, listeners));
+                builder.addExtensionMatch("""", path, servletChain(handler, threadSetupAction, listeners, targetServlet == null ? null : targetServlet.getManagedServlet().getServletInfo()));
             }
         }
 
@@ -352,9 +351,9 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
                 }
             }
             if (filters.isEmpty()) {
-                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), threadSetupAction, listeners));
+                builder.addNameMatch(entry.getKey(), servletChain(entry.getValue(), threadSetupAction, listeners, entry.getValue().getManagedServlet().getServletInfo()));
             } else {
-                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filters, entry.getValue()), threadSetupAction, listeners));
+                builder.addNameMatch(entry.getKey(), servletChain(new FilterHandler(filters, entry.getValue()), threadSetupAction, listeners, entry.getValue().getManagedServlet().getServletInfo()));
             }
         }
 
@@ -374,8 +373,8 @@ private ApplicationListeners createListeners() {
         return new ApplicationListeners(managedListeners, deployment.getServletContext());
     }
 
-    private ServletInitialHandler servletChain(BlockingHttpHandler next, final CompositeThreadSetupAction setupAction, final ApplicationListeners applicationListeners) {
-        return new ServletInitialHandler(new RequestListenerHandler(applicationListeners, next), setupAction, deployment.getServletContext(), executor == null ? null : executor.getInstance());
+    private ServletInitialHandler servletChain(BlockingHttpHandler next, final CompositeThreadSetupAction setupAction, final ApplicationListeners applicationListeners, final ServletInfo servletInfo) {
+        return new ServletInitialHandler(new RequestListenerHandler(applicationListeners, next), setupAction, deployment.getServletContext(), executor == null ? null : executor.getInstance(), servletInfo);
     }
 
     private ServletHandler resolveServletForPath(final String path, final Map<String, ServletHandler> pathServlets) {",2012-09-27T04:52:25Z,80
"@@ -40,6 +40,7 @@
 import io.undertow.server.handlers.blocking.BlockingHttpHandler;
 import io.undertow.server.handlers.file.DirectFileCache;
 import io.undertow.server.handlers.file.FileCache;
+import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.ResourceLoader;
 import io.undertow.util.CopyOnWriteMap;
 import io.undertow.util.Headers;
@@ -60,7 +61,7 @@ public class DefaultServlet extends HttpServlet implements HttpHandler {
     private static final String[] DEFAULT_ALLOWED_EXTENSIONS = {""js"", ""css"", ""png"", ""jpg"", ""gif"", ""html"", ""htm""};
     private static final String[] DEFAULT_DISALLOWED_EXTENSIONS = {""class"", ""jar"", ""war"", ""zip"", ""xml""};
 
-    private final ResourceLoader resourceLoader;
+    private final Deployment deployment;
     private volatile FileCache fileCache = DirectFileCache.INSTANCE;
 
     private volatile boolean defaultAllowed = false;
@@ -70,8 +71,8 @@ public class DefaultServlet extends HttpServlet implements HttpHandler {
 
     private final List<String> welcomePages;
 
-    public DefaultServlet(final ResourceLoader resourceLoader, final List<String> welcomePages) {
-        this.resourceLoader = resourceLoader;
+    public DefaultServlet(final Deployment deployment, final List<String> welcomePages) {
+        this.deployment = deployment;
         this.welcomePages = welcomePages;
         allowed.addAll(Arrays.asList(DEFAULT_ALLOWED_EXTENSIONS));
         disallowed.addAll(Arrays.asList(DEFAULT_DISALLOWED_EXTENSIONS));
@@ -85,7 +86,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
             return;
         }
         ServletOutputStream out = null;
-        final File resource = resourceLoader.getResource(path);
+        final File resource = deployment.getDeploymentInfo().getResourceLoader().getResource(path);
         if (resource == null) {
             resp.setStatus(404);
             return;
@@ -116,7 +117,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
             completionHandler.handleComplete();
             return;
         }
-        File resource = resourceLoader.getResource(exchange.getRelativePath());
+        File resource = deployment.getDeploymentInfo().getResourceLoader().getResource(exchange.getRelativePath());
         if (resource == null) {
             exchange.setResponseCode(404);
             completionHandler.handleComplete();
@@ -129,7 +130,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
     }
 
     private void handleWelcomePage(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler, final File resource) {
-        final String found = findWelcomeResource(resource);
+        final String found = findWelcomeResource(resource, exchange.getRelativePath().endsWith(""/"") ? exchange.getRelativePath() : exchange.getRelativePath() + ""/"");
         if (found != null) {
             exchange.setResponseCode(302);
             StringBuilder newLocation = new StringBuilder(exchange.getRequestURL());
@@ -146,7 +147,7 @@ private void handleWelcomePage(final HttpServerExchange exchange, final HttpComp
     }
 
     private void handleWelcomePage(final HttpServletRequest req, final HttpServletResponse resp, final File resource) {
-        final String found = findWelcomeResource(resource);
+        final String found = findWelcomeResource(resource, req.getPathInfo().endsWith(""/"") ? req.getPathInfo() : req.getPathInfo() + ""/"");
         if (found != null) {
             resp.setStatus(302);
             StringBuffer newLocation = req.getRequestURL();
@@ -160,13 +161,20 @@ private void handleWelcomePage(final HttpServletRequest req, final HttpServletRe
         }
     }
 
-    private String findWelcomeResource(final File resource) {
+    private String findWelcomeResource(final File resource, final String path) {
         for (String i : welcomePages) {
             final File res = new File(resource + File.separator + i);
             if (res.exists()) {
                 return i;
             }
         }
+
+        for (String i : welcomePages) {
+            final ServletInitialHandler handler = deployment.getServletPaths().getServletHandlerByPath(path + i);
+            if(handler.getServletInfo() != null) {
+                return i;
+            }
+        }
         return null;
     }
 ",2012-09-27T04:52:25Z,155
"@@ -29,6 +29,7 @@
 import io.undertow.server.handlers.HttpHandlers;
 import io.undertow.server.handlers.blocking.BlockingHttpHandler;
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
+import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
@@ -56,17 +57,22 @@ public class ServletInitialHandler implements BlockingHttpHandler, HttpHandler {
 
     private volatile BlockingHttpHandler handler;
     private final Executor executor;
+    /**
+     * The information about the target5 servlet. This may be null.
+     */
+    private final ServletInfo servletInfo;
 
-    public ServletInitialHandler(final BlockingHttpHandler next, final HttpHandler asyncPath, final CompositeThreadSetupAction setupAction, final ServletContextImpl servletContext, final Executor executor) {
+    public ServletInitialHandler(final BlockingHttpHandler next, final HttpHandler asyncPath, final CompositeThreadSetupAction setupAction, final ServletContextImpl servletContext, final Executor executor, final ServletInfo servletInfo) {
         this.next = next;
         this.asyncPath = asyncPath;
         this.setupAction = setupAction;
         this.servletContext = servletContext;
         this.executor = executor;
+        this.servletInfo = servletInfo;
     }
 
-    public ServletInitialHandler(final BlockingHttpHandler next, final CompositeThreadSetupAction setupAction, final ServletContextImpl servletContext, final Executor executor) {
-        this(next, null, setupAction, servletContext, executor);
+    public ServletInitialHandler(final BlockingHttpHandler next, final CompositeThreadSetupAction setupAction, final ServletContextImpl servletContext, final Executor executor, final ServletInfo servletInfo) {
+        this(next, null, setupAction, servletContext, executor, servletInfo);
     }
 
     @Override
@@ -141,4 +147,8 @@ public void setRootHandler(final BlockingHttpHandler rootHandler) {
     public BlockingHttpHandler getNext() {
         return next;
     }
+
+    public ServletInfo getServletInfo() {
+        return servletInfo;
+    }
 }",2012-09-27T04:52:25Z,145
"@@ -22,6 +22,8 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
 import java.security.Principal;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -60,6 +62,7 @@
 import io.undertow.util.DateUtils;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
+import org.xnio.LocalSocketAddress;
 
 /**
  * The http servlet request implementation. This class is not thread safe
@@ -168,7 +171,11 @@ public Enumeration<String> getHeaderNames() {
 
     @Override
     public int getIntHeader(final String name) {
-        return Integer.parseInt(getHeader(name));
+        String header = getHeader(name);
+        if(header == null) {
+            return -1;
+        }
+        return Integer.parseInt(header);
     }
 
     @Override
@@ -420,7 +427,7 @@ public String getScheme() {
 
     @Override
     public String getServerName() {
-        return null;
+        return exchange.getExchange().getSourceAddress().getHostName();
     }
 
     @Override
@@ -502,12 +509,22 @@ public String getLocalName() {
 
     @Override
     public String getLocalAddr() {
+        SocketAddress address =  exchange.getExchange().getConnection().getLocalAddress();
+        if(address instanceof InetSocketAddress) {
+            return ((InetSocketAddress)address).getHostName();
+        } else if( address instanceof LocalSocketAddress) {
+            return ((LocalSocketAddress)address).getName();
+        }
         return null;
     }
 
     @Override
     public int getLocalPort() {
-        return 0;
+        SocketAddress address =  exchange.getExchange().getConnection().getLocalAddress();
+        if(address instanceof InetSocketAddress) {
+            return ((InetSocketAddress)address).getPort();
+        }
+        return -1;
     }
 
     @Override",2012-09-27T04:52:25Z,147
"@@ -233,7 +233,7 @@ public boolean setInitParameter(final String name, final String value) {
         if (deploymentInfo.getInitParameters().containsKey(name)) {
             return false;
         }
-        deploymentInfo.getInitParameters().put(name, value);
+        deploymentInfo.addInitParameter(name, value);
         return true;
     }
 
@@ -273,7 +273,7 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final St
         try {
             ServletInfo servlet = new ServletInfo(servletName, (Class<? extends Servlet>) deploymentInfo.getClassLoader().loadClass(className));
             deploymentInfo.addServlet(servlet);
-            return new ServletRegistrationImpl(servlet);
+            return new ServletRegistrationImpl(servlet, deploymentInfo);
         } catch (ClassNotFoundException e) {
             throw UndertowServletMessages.MESSAGES.cannotLoadClass(className, e);
         }
@@ -283,14 +283,14 @@ public ServletRegistration.Dynamic addServlet(final String servletName, final St
     public ServletRegistration.Dynamic addServlet(final String servletName, final Servlet servlet) {
         ServletInfo s = new ServletInfo(servletName, servlet.getClass(), new ImmediateInstanceFactory<Servlet>(servlet));
         deploymentInfo.addServlet(s);
-        return new ServletRegistrationImpl(s);
+        return new ServletRegistrationImpl(s, deploymentInfo);
     }
 
     @Override
     public ServletRegistration.Dynamic addServlet(final String servletName, final Class<? extends Servlet> servletClass) {
         ServletInfo servlet = new ServletInfo(servletName, servletClass);
         deploymentInfo.addServlet(servlet);
-        return new ServletRegistrationImpl(servlet);
+        return new ServletRegistrationImpl(servlet, deploymentInfo);
     }
 
     @Override
@@ -299,20 +299,22 @@ public <T extends Servlet> T createServlet(final Class<T> clazz) throws ServletE
             return deploymentInfo.getClassIntrospecter().createInstanceFactory(clazz).createInstance().getInstance();
         } catch (InstantiationException e) {
             throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
+        } catch (NoSuchMethodException e) {
+            throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
         }
     }
 
     @Override
     public ServletRegistration getServletRegistration(final String servletName) {
         final ServletInfo servlet = deploymentInfo.getServlets().get(servletName);
-        return new ServletRegistrationImpl(servlet);
+        return new ServletRegistrationImpl(servlet, deploymentInfo);
     }
 
     @Override
     public Map<String, ? extends ServletRegistration> getServletRegistrations() {
         final Map<String, ServletRegistration> ret = new HashMap<String, ServletRegistration>();
         for (Map.Entry<String, ServletInfo> entry : deploymentInfo.getServlets().entrySet()) {
-            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue()));
+            ret.put(entry.getKey(), new ServletRegistrationImpl(entry.getValue(), deploymentInfo));
         }
         return ret;
     }
@@ -349,6 +351,8 @@ public <T extends Filter> T createFilter(final Class<T> clazz) throws ServletExc
             return deploymentInfo.getClassIntrospecter().createInstanceFactory(clazz).createInstance().getInstance();
         } catch (InstantiationException e) {
             throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
+        } catch (NoSuchMethodException e) {
+            throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
         }
     }
 
@@ -407,7 +411,12 @@ public <T extends EventListener> void addListener(final T t) {
 
     @Override
     public void addListener(final Class<? extends EventListener> listenerClass) {
-        InstanceFactory<? extends EventListener> factory = deploymentInfo.getClassIntrospecter().createInstanceFactory(listenerClass);
+        InstanceFactory<? extends EventListener> factory = null;
+        try {
+            factory = deploymentInfo.getClassIntrospecter().createInstanceFactory(listenerClass);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalArgumentException(e);
+        }
         deploymentInfo.addListener(new ListenerInfo(listenerClass, factory));
     }
 
@@ -416,7 +425,9 @@ public <T extends EventListener> T createListener(final Class<T> clazz) throws S
         try {
             return deploymentInfo.getClassIntrospecter().createInstanceFactory(clazz).createInstance().getInstance();
         } catch (InstantiationException e) {
-            throw new ServletException(e);
+            throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
+        } catch (NoSuchMethodException e) {
+            throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(clazz.getName(), e);
         }
     }
 ",2012-09-27T04:52:25Z,146
"@@ -27,6 +27,7 @@
 import javax.servlet.ServletRegistration;
 import javax.servlet.ServletSecurityElement;
 
+import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.ServletInfo;
 
 /**
@@ -35,9 +36,11 @@
 public class ServletRegistrationImpl implements ServletRegistration, ServletRegistration.Dynamic {
 
     private final ServletInfo servletInfo;
+    private final DeploymentInfo deploymentInfo;
 
-    public ServletRegistrationImpl(final ServletInfo servletInfo) {
+    public ServletRegistrationImpl(final ServletInfo servletInfo, final DeploymentInfo deploymentInfo) {
         this.servletInfo = servletInfo;
+        this.deploymentInfo = deploymentInfo;
     }
 
     @Override
@@ -68,8 +71,12 @@ public void setAsyncSupported(final boolean isAsyncSupported) {
     @Override
     public Set<String> addMapping(final String... urlPatterns) {
         final Set<String> ret = new HashSet<String>();
+        final Set<String> existing = new HashSet<String>();
+        for(ServletInfo s : deploymentInfo.getServlets().values()){
+            existing.addAll(s.getMappings());
+        }
         for(String pattern : urlPatterns) {
-            if(servletInfo.getMappings().contains(pattern)) {
+            if(!existing.contains(pattern)) {
                 ret.add(pattern);
                 servletInfo.addMapping(pattern);
             }",2012-09-27T04:52:25Z,294
"@@ -32,11 +32,7 @@ private DefaultClassIntrospector() {
     }
 
     @Override
-    public <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz) {
-        try {
-            return new ConstructorInstanceFactory<T>(clazz.getDeclaredConstructor());
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        }
+    public <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz) throws NoSuchMethodException {
+        return new ConstructorInstanceFactory<T>(clazz.getDeclaredConstructor());
     }
 }",2012-09-27T04:52:25Z,388
"@@ -66,8 +66,8 @@ class MCMPAdvertiseTask implements Runnable {
 
     static void advertise(final ModClusterContainer container, final MCMPConfig.AdvertiseConfig config, final XnioWorker worker) throws IOException {
         InetSocketAddress bindAddress;
-        final InetAddress group = InetAddress.getByName(config.getAdvertiseGroup());
-        if (group == null || linuxLike || windows) {
+        final InetAddress group = InetAddress.getByName(config.getAdvertiseAddress());
+        if (group == null) {
             bindAddress = new InetSocketAddress(config.getAdvertisePort());
         } else {
             bindAddress = new InetSocketAddress(group, config.getAdvertisePort());
@@ -76,7 +76,7 @@ static void advertise(final ModClusterContainer container, final MCMPConfig.Adve
         try {
             channel = worker.createUdpServer(bindAddress, null, OptionMap.EMPTY);
         } catch (IOException e) {
-            if(group != null && linuxLike) {
+            if(group != null && (linuxLike || windows)) {
                 //try again with no group
                 //see UNDERTOW-454
                 UndertowLogger.ROOT_LOGGER.potentialCrossTalking(group, (group instanceof Inet4Address) ? ""IPv4"" : ""IPv6"", e.getLocalizedMessage());",2016-02-17T22:34:20Z,260
"@@ -0,0 +1,138 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy;
+
+/**
+ * The connection pool error handler is intended to be used per node and will therefore be shared across I/O threads.
+ *
+ * @author Emanuel Muckenhuber
+ */
+public interface ConnectionPoolErrorHandler {
+
+    /**
+     * Check whether pool is available
+     *
+     * @return whether the pool is available
+     */
+    boolean isAvailable();
+
+    /**
+     * Handle a connection error.
+     *
+     * @return {@code true} if the pool is still available, {@code false} otherwise
+     */
+    boolean handleError();
+
+    /**
+     * Clear the connection errors.
+     *
+     * @return {@code true} if the pool is available again, {@code false} otherwise
+     */
+    boolean clearError();
+
+    class SimpleConnectionPoolErrorHandler implements ConnectionPoolErrorHandler {
+
+        private volatile boolean problem;
+
+        @Override
+        public boolean isAvailable() {
+            return !problem;
+        }
+
+        @Override
+        public boolean handleError() {
+            problem = true;
+            return false;
+        }
+
+        @Override
+        public boolean clearError() {
+            problem = false;
+            return true;
+        }
+    }
+
+    /**
+     * Counting error handler, this only propagates the state to the delegate handler after reaching a given limit.
+     */
+    class CountingErrorHandler implements ConnectionPoolErrorHandler {
+
+        private int count;
+        private long timeout;
+
+        private final long interval;
+        private final int errorCount;
+        private final int successCount;
+        private final ConnectionPoolErrorHandler delegate;
+
+        public CountingErrorHandler(int errorCount, int successCount, long interval) {
+            this(errorCount, successCount, interval, new SimpleConnectionPoolErrorHandler());
+        }
+
+        public CountingErrorHandler(int errorCount, int successCount, long interval, ConnectionPoolErrorHandler delegate) {
+            this.errorCount = Math.max(errorCount, 1);
+            this.successCount = Math.max(successCount, 1);
+            this.interval = Math.max(interval, 0);
+            this.delegate = delegate;
+        }
+
+        @Override
+        public boolean isAvailable() {
+            return delegate.isAvailable();
+        }
+
+        @Override
+        public synchronized boolean handleError() {
+            if (delegate.isAvailable()) {
+                final long time = System.currentTimeMillis();
+                // If the timeout is reached reset the error count
+                if (time >= timeout) {
+                    count = 1;
+                    timeout = time + interval;
+                } else {
+                    if (count++ == 1) {
+                        timeout = time + interval;
+                    }
+                }
+                if (count >= errorCount) {
+                    return delegate.handleError();
+                }
+                return true;
+            } else {
+                count = 0; // if in error reset the successful count
+                return false;
+            }
+        }
+
+        @Override
+        public synchronized boolean clearError() {
+            if (delegate.isAvailable()) {
+                count = 0; // Just reset the error count
+                return true;
+            } else {
+                // Count the successful attempts
+                if (count++ == successCount) {
+                    return delegate.clearError();
+                }
+                return false;
+            }
+        }
+    }
+
+}",2014-08-29T00:18:16Z,389
"@@ -25,40 +25,7 @@
  *
  * @author Stuart Douglas
  */
-public interface ConnectionPoolManager {
-
-    /**
-     * Check if the pool is available.
-     *
-     * @return true if the pool can be used
-     */
-    boolean isAvailable();
-
-    /**
-     * Notify a connection error.
-     */
-    void connectionError();
-
-    /**
-     * Clear the connection error.
-     */
-    void clearErrorState();
-
-    /**
-     * Returns true if the connection pool can create a new connection
-     *
-     * @param connections The number of connections associated with the current IO thread.
-     * @param proxyConnectionPool The connection pool
-     * @return true if a connection can be created
-     */
-    boolean canCreateConnection(int connections, ProxyConnectionPool proxyConnectionPool);
-
-    /**
-     * Returns true if the pool should cache a new connection
-     *
-     * @return true if the connection can be cached
-     */
-    boolean cacheConnection(int connections, ProxyConnectionPool proxyConnectionPool);
+public interface ConnectionPoolManager extends ProxyConnectionPoolConfig, ConnectionPoolErrorHandler {
 
     /**
      * This is invoked when the target thread pool transitions to problem status. It will be called once for each queued request",2014-08-29T00:18:16Z,363
"@@ -316,12 +316,11 @@ protected Host findStickyHost(HttpServerExchange exchange) {
         return null;
     }
 
-    protected final class Host implements ConnectionPoolManager {
+    protected final class Host extends ConnectionPoolErrorHandler.SimpleConnectionPoolErrorHandler implements ConnectionPoolManager {
         final ProxyConnectionPool connectionPool;
         final String jvmRoute;
         final URI uri;
         final XnioSsl ssl;
-        private volatile boolean problem;
 
         private Host(String jvmRoute, InetSocketAddress bindAddress, URI uri, XnioSsl ssl, OptionMap options) {
             this.connectionPool = new ProxyConnectionPool(this, bindAddress, uri, ssl, client, options);
@@ -331,38 +330,38 @@ private Host(String jvmRoute, InetSocketAddress bindAddress, URI uri, XnioSsl ss
         }
 
         @Override
-        public boolean isAvailable() {
-            return !problem;
+        public void queuedConnectionFailed(ProxyTarget proxyTarget, HttpServerExchange exchange, ProxyCallback<ProxyConnection> callback, long timeoutMills) {
+            getConnection(proxyTarget, exchange, callback, timeoutMills, TimeUnit.MILLISECONDS);
         }
 
         @Override
-        public void connectionError() {
-            problem = true;
+        public int getProblemServerRetry() {
+            return problemServerRetry;
         }
 
         @Override
-        public void clearErrorState() {
-            problem = false;
+        public int getMaxConnections() {
+            return connectionsPerThread;
         }
 
         @Override
-        public boolean canCreateConnection(int connections, ProxyConnectionPool proxyConnectionPool) {
-            return connections < connectionsPerThread;
+        public int getMaxCachedConnections() {
+            return connectionsPerThread;
         }
 
         @Override
-        public boolean cacheConnection(int connections, ProxyConnectionPool proxyConnectionPool) {
-            return connections <= connectionsPerThread;
+        public int getSMaxConnections() {
+            return connectionsPerThread;
         }
 
         @Override
-        public void queuedConnectionFailed(ProxyTarget proxyTarget, HttpServerExchange exchange, ProxyCallback<ProxyConnection> callback, long timeoutMills) {
-            getConnection(proxyTarget, exchange, callback, timeoutMills, TimeUnit.MILLISECONDS);
+        public long getTtl() {
+            return -1;
         }
 
         @Override
-        public int getProblemServerRetry() {
-            return problemServerRetry;
+        public int getMaxQueueSize() {
+            return 0;
         }
     }
 ",2014-08-29T00:18:16Z,364
"@@ -70,12 +70,11 @@ public class ProxyConnectionPool implements Closeable {
      */
     private volatile boolean closed;
 
-    private boolean keepAlive = true; // set tcp keep-alive option
-    private final int maxConnections = 12;
-    private final int maxCachedConnections = 8;
-    private final int sMaxConnections = 0;
-    private final int maxRequestQueueSize = 32;
-    private final long ttl = 1;
+    private final int maxConnections;
+    private final int maxCachedConnections;
+    private final int sMaxConnections;
+    private final int maxRequestQueueSize;
+    private final long ttl;
 
     private final ConcurrentMap<XnioIoThread, HostThreadData> hostThreadData = new CopyOnWriteMap<>();
 
@@ -92,8 +91,13 @@ public ProxyConnectionPool(ConnectionPoolManager connectionPoolManager, URI uri,
     }
 
     public ProxyConnectionPool(ConnectionPoolManager connectionPoolManager, InetSocketAddress bindAddress,URI uri, XnioSsl ssl, UndertowClient client, OptionMap options) {
-        this.bindAddress = bindAddress;
         this.connectionPoolManager = connectionPoolManager;
+        this.maxConnections = Math.max(connectionPoolManager.getMaxConnections(), 1);
+        this.maxCachedConnections = Math.max(connectionPoolManager.getMaxCachedConnections(), 0);
+        this.sMaxConnections = Math.max(connectionPoolManager.getSMaxConnections(), 0);
+        this.maxRequestQueueSize = Math.max(connectionPoolManager.getMaxQueueSize(), 0);
+        this.ttl = connectionPoolManager.getTtl();
+        this.bindAddress = bindAddress;
         this.uri = uri;
         this.ssl = ssl;
         this.client = client;
@@ -200,7 +204,6 @@ private void openConnection(final HttpServerExchange exchange, final ProxyCallba
         client.connect(new ClientCallback<ClientConnection>() {
             @Override
             public void completed(final ClientConnection result) {
-                connectionPoolManager.clearErrorState();
                 final ConnectionHolder connectionHolder = new ConnectionHolder(result);
                 if (!exclusive) {
                     result.getCloseSetter().set(new ChannelListener<ClientConnection>() {
@@ -218,10 +221,11 @@ public void failed(IOException e) {
                 if (!exclusive) {
                     data.connections--;
                 }
-                connectionPoolManager.connectionError();
                 UndertowLogger.REQUEST_LOGGER.debug(""Failed to connect"", e);
-                redistributeQueued(getData());
-                scheduleFailedHostRetry(exchange);
+                if (!connectionPoolManager.handleError()) {
+                    redistributeQueued(getData());
+                    scheduleFailedHostRetry(exchange);
+                }
                 callback.failed(exchange);
             }
         }, bindAddress, getUri(), exchange.getIoThread(), ssl, exchange.getConnection().getBufferPool(), options);
@@ -259,24 +263,6 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
         callback.completed(exchange, new ProxyConnection(result.clientConnection, uri.getPath() == null ? ""/"" : uri.getPath()));
     }
 
-    /**
-     * Get the current queue size.
-     *
-     * @return {@code -1} if more connections can be opened
-     *         {@code >= 0} the current size of the queue
-     *         other values represent an error
-     */
-    public int getQueueStatus() {
-        if (closed) {
-            return Integer.MIN_VALUE;
-        }
-        final HostThreadData data = getData();
-        if (data.connections < maxConnections) {
-            return -1;
-        }
-        return data.awaitingConnections.size();
-    }
-
     public AvailabilityType available() {
         if (closed) {
             return AvailabilityType.CLOSED;
@@ -291,6 +277,9 @@ public AvailabilityType available() {
         if (!data.availableConnections.isEmpty()) {
             return AvailabilityType.AVAILABLE;
         }
+        if (data.awaitingConnections.size() >= maxConnections) {
+            return AvailabilityType.FULL_QUEUE;
+        }
         return AvailabilityType.FULL;
     }
 
@@ -301,7 +290,8 @@ public AvailabilityType available() {
      */
     private void scheduleFailedHostRetry(final HttpServerExchange exchange) {
         final int retry = connectionPoolManager.getProblemServerRetry();
-        if (retry > 0) {
+        // only schedule a retry task if the node is not available
+        if (!connectionPoolManager.isAvailable() && retry > 0) {
             exchange.getIoThread().executeAfter(new Runnable() {
                 @Override
                 public void run() {
@@ -314,21 +304,27 @@ public void run() {
                         @Override
                         public void completed(ClientConnection result) {
                             UndertowLogger.PROXY_REQUEST_LOGGER.debugf(""Connected to previously failed host %s, returning to service"", getUri());
-                            connectionPoolManager.clearErrorState();
-                            final ConnectionHolder connectionHolder = new ConnectionHolder(result);
-                            final HostThreadData data = getData();
-                            result.getCloseSetter().set(new ChannelListener<ClientConnection>() {
-                                @Override
-                                public void handleEvent(ClientConnection channel) {
-                                    handleClosedConnection(data, connectionHolder);
-                                }
-                            });
-                            returnConnection(connectionHolder);
+                            if (connectionPoolManager.clearError()) {
+                                // In case the node is available now, return the connection
+                                final ConnectionHolder connectionHolder = new ConnectionHolder(result);
+                                final HostThreadData data = getData();
+                                result.getCloseSetter().set(new ChannelListener<ClientConnection>() {
+                                    @Override
+                                    public void handleEvent(ClientConnection channel) {
+                                        handleClosedConnection(data, connectionHolder);
+                                    }
+                                });
+                                returnConnection(connectionHolder);
+                            } else {
+                                // Otherwise reschedule the retry task
+                                scheduleFailedHostRetry(exchange);
+                            }
                         }
 
                         @Override
                         public void failed(IOException e) {
                             UndertowLogger.PROXY_REQUEST_LOGGER.debugf(""Failed to reconnect to failed host %s"", getUri());
+                            connectionPoolManager.handleError();
                             scheduleFailedHostRetry(exchange);
                         }
                     }, bindAddress, getUri(), exchange.getIoThread(), ssl, exchange.getConnection().getBufferPool(), options);
@@ -532,6 +528,10 @@ public enum AvailabilityType {
          * All connections are in use, connections will be queued
          */
         FULL,
+        /**
+         * All connections are in use and the queue is full. Requests will be rejected.
+         */
+        FULL_QUEUE,
         /**
          * The host is probably down, only try as a last resort
          */",2014-08-29T00:18:16Z,6
"@@ -0,0 +1,61 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy;
+
+/**
+ * @author Emanuel Muckenhuber
+ */
+public interface ProxyConnectionPoolConfig {
+
+    /**
+     * Get the maximum number of connections per thread.
+     *
+     * @return
+     */
+    int getMaxConnections();
+
+    /**
+     * Get the maximum number of cached (idle) connections per thread.
+     *
+     * @return
+     */
+    int getMaxCachedConnections();
+
+    /**
+     * Get number of cached connections above which are closed after the time to live.
+     *
+     * @return
+     */
+    int getSMaxConnections();
+
+    /**
+     * Get the time to live for idle connections.
+     *
+     * @return
+     */
+    long getTtl();
+
+    /**
+     * Get the maximum number of requests which can be queued if there are no connections available.
+     *
+     * @return
+     */
+    int getMaxQueueSize();
+
+}",2014-08-29T00:18:16Z,6
"@@ -30,7 +30,6 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.proxy.ProxyCallback;
 import io.undertow.server.handlers.proxy.ProxyConnection;
-import org.xnio.IoUtils;
 
 /**
  *
@@ -179,12 +178,7 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
             });
             node.getConnectionPool().connect(target, exchange, callback, timeout, timeUnit, exclusive);
         } else {
-            if (exchange.isResponseStarted()) {
-                IoUtils.safeClose(exchange.getConnection());
-            } else {
-                exchange.setResponseCode(503);
-                exchange.endExchange();
-            }
+            callback.failed(exchange);
         }
     }
 ",2014-08-29T00:18:16Z,110
"@@ -54,7 +54,6 @@ public ProxyTarget findTarget(HttpServerExchange exchange) {
         return container.findTarget(exchange);
     }
 
-    @Override
     public void getConnection(final ProxyTarget target, final HttpServerExchange exchange,
                               final ProxyCallback<ProxyConnection> callback, final long timeout, final TimeUnit timeUnit) {
         final ExclusiveConnectionHolder holder = exchange.getConnection().getAttachment(exclusiveConnectionKey);
@@ -70,8 +69,8 @@ public void getConnection(final ProxyTarget target, final HttpServerExchange exc
 
         // Resolve the node
         final ModClusterProxyTarget proxyTarget = (ModClusterProxyTarget) target;
-        final Context node = proxyTarget.resolveContext(exchange);
-        if (node == null) {
+        final Context context = proxyTarget.resolveContext(exchange);
+        if (context == null) {
             callback.failed(exchange);
         } else {
             if (holder != null || (exclusivityChecker != null && exclusivityChecker.isExclusivityRequired(exchange))) {
@@ -109,10 +108,9 @@ public void closed(ServerConnection connection) {
                     }
                 };
 
-                node.handleRequest(proxyTarget, exchange, wrappedCallback, timeout, timeUnit, true);
-                /// node.getConnectionPool().connect(target, exchange, , timeout, timeUnit, true);
+                context.handleRequest(proxyTarget, exchange, wrappedCallback, timeout, timeUnit, true);
             } else {
-                node.handleRequest(proxyTarget, exchange, callback, timeout, timeUnit, true);
+                context.handleRequest(proxyTarget, exchange, callback, timeout, timeUnit, true);
             }
         }
     }",2014-08-29T00:18:16Z,129
"@@ -430,20 +430,14 @@ boolean isHotStandby() {
     protected boolean checkAvailable(final boolean existingSession) {
         if (allAreClear(state, ERROR | REMOVED)) {
             // Check the state of the queue on the connection pool
-            final int queueState = connectionPool.getQueueStatus();
-            if (queueState == -1) {
-                return true; // Connections available
-            } else if (queueState > -1) {
-                // If there are more queued requests than our max size, this node cannot be elected
-                if (queueState > nodeConfig.getRequestQueueSize()) {
-                    return false;
-                } else {
-                    // In case there is an existing session or we allow queueing of new requests
-                    if (existingSession) {
-                        return true;
-                    } else if (!existingSession && nodeConfig.isQueueNewRequests()) {
-                        return true;
-                    }
+            final ProxyConnectionPool.AvailabilityType availability = connectionPool.available();
+            if (availability == ProxyConnectionPool.AvailabilityType.AVAILABLE) {
+                return true;
+            } else if (availability == ProxyConnectionPool.AvailabilityType.FULL) {
+                if (existingSession) {
+                    return true;
+                } else if (!existingSession && nodeConfig.isQueueNewRequests()) {
+                    return true;
                 }
             }
         }
@@ -458,24 +452,40 @@ public boolean isAvailable() {
         }
 
         @Override
-        public void connectionError() {
+        public boolean handleError() {
             markInError();
+            return false;
+        }
+
+        @Override
+        public boolean clearError() {
+            // This needs to be cleared through the status update
+            return isAvailable();
+        }
+
+        @Override
+        public int getMaxConnections() {
+            return nodeConfig.getMaxConnections();
+        }
+
+        @Override
+        public int getMaxCachedConnections() {
+            return nodeConfig.getCacheConnections();
         }
 
         @Override
-        public void clearErrorState() {
-            // This needs to be cleared through the update status
+        public int getSMaxConnections() {
+            return nodeConfig.getSmax();
         }
 
         @Override
-        public boolean canCreateConnection(int connections, ProxyConnectionPool proxyConnectionPool) {
-            final int maxConnections = nodeConfig.getMaxConnections();
-            return maxConnections > 0 ? connections < maxConnections : true;
+        public long getTtl() {
+            return nodeConfig.getTtl();
         }
 
         @Override
-        public boolean cacheConnection(int connections, ProxyConnectionPool proxyConnectionPool) {
-            return connections <= nodeConfig.getCacheConnections();
+        public int getMaxQueueSize() {
+            return nodeConfig.getRequestQueueSize();
         }
 
         @Override",2014-08-29T00:18:16Z,262
"@@ -33,6 +33,7 @@
 import io.undertow.client.UndertowClient;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.PathHandler;
 import io.undertow.server.handlers.ResponseCodeHandler;
 import io.undertow.server.session.InMemorySessionManager;
 import io.undertow.server.session.Session;
@@ -45,6 +46,7 @@
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.cookie.Cookie;
 import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.cookie.BasicClientCookie;
 import org.apache.http.message.BasicHeader;
 import org.junit.After;
 import org.junit.AfterClass;
@@ -200,9 +202,8 @@ static void stopServers() {
     static void startServers(final NodeTestConfig... configs) {
         final int l = configs.length;
         servers = new Undertow[l];
-        final SessionCookieConfig session = new SessionCookieConfig();
         for (int i = 0; i < l; i++) {
-            servers[i] = createNode(configs[i], session);
+            servers[i] = createNode(configs[i]);
             servers[i].start();
         }
     }
@@ -213,6 +214,10 @@ static String checkGet(final String context, int statusCode) throws IOException
 
     static String checkGet(final String context, int statusCode, String route) throws IOException {
         final HttpGet get = get(context);
+        if (route != null && getSessionRoute() == null) {
+            BasicClientCookie cookie = new BasicClientCookie(""JSESSIONID"", ""randomSessionID.""+route);
+            httpClient.getCookieStore().addCookie(cookie);
+        }
         final HttpResponse result = httpClient.execute(get);
         final String response = HttpClientUtils.readResponse(result);
         Assert.assertEquals(statusCode, result.getStatusLine().getStatusCode());
@@ -270,7 +275,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         }
     }
 
-    static Undertow createNode(final NodeTestConfig config, final SessionCookieConfig sessionConfig) {
+    static Undertow createNode(final NodeTestConfig config) {
         final Undertow.Builder builder = Undertow.builder();
 
         final String type = config.getType();
@@ -289,10 +294,18 @@ static Undertow createNode(final NodeTestConfig config, final SessionCookieConfi
             default:
                 throw new IllegalArgumentException(type);
         }
+        final SessionCookieConfig sessionConfig = new SessionCookieConfig();
+        if (config.getStickySessionCookie() != null) {
+            sessionConfig.setCookieName(config.getStickySessionCookie());
+        }
+        final PathHandler pathHandler =  path(ResponseCodeHandler.HANDLE_200)
+                .addPrefixPath(""/name"", new StringSendHandler(config.getJvmRoute()))
+                .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(config.getJvmRoute(), sessionConfig), new InMemorySessionManager(""""), sessionConfig));
+
+        config.setupHandlers(pathHandler); // Setup test handlers
+
         builder.setSocketOption(Options.REUSE_ADDRESSES, true)
-               .setHandler(jvmRoute(""JSESSIONID"", config.getJvmRoute(), path(ResponseCodeHandler.HANDLE_200)
-                       .addPrefixPath(""/name"", new StringSendHandler(config.getJvmRoute()))
-                       .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(config.getJvmRoute(), sessionConfig), new InMemorySessionManager(""""), sessionConfig))));
+               .setHandler(jvmRoute(""JSESSIONID"", config.getJvmRoute(), pathHandler));
         return builder.build();
     }
 ",2014-08-29T00:18:16Z,390
"@@ -18,8 +18,10 @@
 
 package io.undertow.server.handlers.proxy.mod_cluster;
 
+import io.undertow.server.handlers.PathHandler;
+
 /**
- * Unit test configuration for a node.s
+ * Unit test configuration for a node.
  *
  * @author Emanuel Muckenhuber
  */
@@ -48,6 +50,8 @@ class NodeTestConfig implements Cloneable {
     private Integer waitWorker;
     private Integer maxattempts;
 
+    private NodeTestHandlers testHandlers;
+
     static NodeTestConfig builder() {
         return new NodeTestConfig();
     }
@@ -223,6 +227,21 @@ public NodeTestConfig setTimeout(Integer timeout) {
         return this;
     }
 
+    public NodeTestHandlers getTestHandlers() {
+        return testHandlers;
+    }
+
+    public NodeTestConfig setTestHandlers(NodeTestHandlers testHandlers) {
+        this.testHandlers = testHandlers;
+        return this;
+    }
+
+    void setupHandlers(final PathHandler pathHandler) {
+        if (testHandlers != null) {
+            testHandlers.setup(pathHandler, this);
+        }
+    }
+
     @Override
     protected NodeTestConfig clone()  {
         try {",2014-08-29T00:18:16Z,391
"@@ -0,0 +1,30 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy.mod_cluster;
+
+import io.undertow.server.handlers.PathHandler;
+
+/**
+ * @author Emanuel Muckenhuber
+ */
+interface NodeTestHandlers {
+
+    void setup(final PathHandler handler, final NodeTestConfig config);
+
+}",2014-08-29T00:18:16Z,392
"@@ -70,10 +70,32 @@ public class ProxyConnectionPool implements Closeable {
      */
     private volatile boolean closed;
 
+    /**
+     * The maximum number of connections that can be established to the target
+     */
     private final int maxConnections;
+
+    /**
+     * The maximum number of connections that will be kept alive once they are idle. If a time to live is set
+     * these connections may be timed out, depending on the value of {@link #coreCachedConnections}.
+     *
+     * NOTE: This value is per IO thread, so to get the actual value this must be multiplied by the number of IO threads
+     */
     private final int maxCachedConnections;
-    private final int sMaxConnections;
-    private final long ttl;
+
+    /**
+     * The minimum number of connections that this proxy connection pool will try and keep established. Once the pool
+     * is down to this number of connections no more connections will be timed out.
+     *
+     * NOTE: This value is per IO thread, so to get the actual value this must be multiplied by the number of IO threads
+     */
+    private final int coreCachedConnections;
+
+    /**
+     * The timeout for idle connections. Note that if {@code #coreCachedConnections} is set then once the pool is down
+     * to the core size no more connections will be timed out.
+     */
+    private final long timeToLive;
 
     private final ConcurrentMap<XnioIoThread, HostThreadData> hostThreadData = new CopyOnWriteMap<>();
 
@@ -93,8 +115,8 @@ public ProxyConnectionPool(ConnectionPoolManager connectionPoolManager, InetSock
         this.connectionPoolManager = connectionPoolManager;
         this.maxConnections = Math.max(connectionPoolManager.getMaxConnections(), 1);
         this.maxCachedConnections = Math.max(connectionPoolManager.getMaxCachedConnections(), 0);
-        this.sMaxConnections = Math.max(connectionPoolManager.getSMaxConnections(), 0);
-        this.ttl = connectionPoolManager.getTtl();
+        this.coreCachedConnections = Math.max(connectionPoolManager.getSMaxConnections(), 0);
+        this.timeToLive = connectionPoolManager.getTtl();
         this.bindAddress = bindAddress;
         this.uri = uri;
         this.ssl = ssl;
@@ -165,10 +187,19 @@ private void returnConnection(final ConnectionHolder connectionHolder) {
                 }
                 hostData.availableConnections.add(connectionHolder);
                 // If the soft max and ttl are configured
-                if (sMaxConnections >= 0 && ttl > 0) {
+                if (timeToLive > 0) {
+                    //we only start the timeout process once we have hit the core pool size
+                    //otherwise connections could start timing out immediately once the core pool size is hit
+                    //and if we never hit the core pool size then it does not make sense to start timers which are never
+                    //used (as timers are expensive)
                     final long currentTime = System.currentTimeMillis();
-                    connectionHolder.timeout = currentTime + ttl;
-                    timeoutConnections(currentTime, hostData);
+                    connectionHolder.timeout = currentTime + timeToLive;
+                    if(hostData.availableConnections.size() > coreCachedConnections) {
+                        if (hostData.nextTimeout <= 0) {
+                            hostData.timeoutKey = connection.getIoThread().executeAfter(hostData.timeoutTask, timeToLive, TimeUnit.MILLISECONDS);
+                            hostData.nextTimeout = connectionHolder.timeout;
+                        }
+                    }
                 }
             }
         } else if (connection.isOpen() && connection.isUpgraded()) {
@@ -342,7 +373,7 @@ private void timeoutConnections(final long currentTime, final HostThreadData dat
         int idleConnections = data.availableConnections.size();
         for (;;) {
             ConnectionHolder holder;
-            if (idleConnections > 0 && idleConnections >= sMaxConnections && (holder = data.availableConnections.peek()) != null) {
+            if (idleConnections > 0 && idleConnections >= coreCachedConnections && (holder = data.availableConnections.peek()) != null) {
                 if (!holder.clientConnection.isOpen()) {
                     // Already closed connections decrease the available connections
                     idleConnections--;
@@ -368,6 +399,7 @@ private void timeoutConnections(final long currentTime, final HostThreadData dat
                     data.timeoutKey.remove();
                     data.timeoutKey = null;
                 }
+                data.nextTimeout = -1;
                 return;
             }
         }
@@ -434,7 +466,7 @@ private final class HostThreadData {
 
         int connections = 0;
         XnioIoThread.Key timeoutKey;
-        long nextTimeout;
+        long nextTimeout = -1;
 
         final Deque<ConnectionHolder> availableConnections = new ArrayDeque<>();
         final Deque<CallbackHolder> awaitingConnections = new ArrayDeque<>();",2015-02-18T04:23:50Z,6
"@@ -26,81 +26,79 @@ class MCMPInfoUtil {
     private static final String NEWLINE = ""\n"";
 
     static void printDump(final Balancer balancer, final StringBuilder builder) {
-        builder.append(""balancer: ["").append(balancer.getId()).append(""],"")
+        builder.append(""balancer: ["").append(balancer.getId()).append(""]"")
                 .append("" Name: "").append(balancer.getName())
-                .append("" Sticky: "").append(formatBoolean(balancer.isStickySession()))
+                .append("" Sticky: "").append(toStringOneZero(balancer.isStickySession()))
                 .append("" ["").append(balancer.getStickySessionCookie()).append(""]/["").append(balancer.getStickySessionPath()).append(""]"")
-                .append("" remove: "").append(formatBoolean(balancer.isStickySessionRemove()))
-                .append(""force: "").append(formatBoolean(balancer.isStickySessionForce()))
-                .append(""Timeout: "").append(balancer.getWaitWorker())
-                .append(""maxAttempts: "").append(balancer.getMaxattempts())
+                .append("" remove: "").append(toStringOneZero(balancer.isStickySessionRemove()))
+                .append("" force: "").append(toStringOneZero(balancer.isStickySessionForce()))
+                .append("" Timeout: "").append(balancer.getWaitWorker())
+                .append("" maxAttempts: "").append(balancer.getMaxattempts())
                 .append(NEWLINE);
     }
 
     static void printInfo(final Node.VHostMapping host, final StringBuilder builder) {
-        builder.append(""Vhost: ["")
-                // .append(host.getNode().getBalancer().getId()).append("":"") // apparently no balancer
-                .append(host.getNode().getId()).append("":"")
-                .append(host.getId()).append("":"")
-                .append(-1) // id[i] id in the table!? does not exist
-                .append(""], Alias: "").append(host.getAliases())
-                .append(NEWLINE);
+        // node id is not unique?
+        for (final String alias : host.getAliases()) {
+            builder.append(""Vhost: ["")
+                    .append(host.getNode().getId()).append("":"")
+                    .append(host.getId()).append("":"")
+                    .append(-1) // id[i] id in the table!? does not exist
+                    .append(""], Alias: "").append(alias)
+                    .append(NEWLINE);
+        }
     }
 
     static void printDump(final Node.VHostMapping host, final StringBuilder builder) {
-        final int hostID = host.getId();
-        final int nodeID  = host.getNode().getId();
+        // node id is not unique?
         for (final String alias : host.getAliases()) {
-            builder.append(""host: "").append(hostID).append("" ["")
-                    .append(alias).append(""] vhost: "").append(host.getId())
-                    .append("" node: "").append(nodeID)
+            builder.append(""host: "").append(host.getId())
+                    .append("" ["").append(alias).append(""]"")
+                    .append("" vhost: "").append(host.getId())
+                    .append("" node: "").append(host.getNode().getId())
                     .append(NEWLINE);
         }
     }
 
     static void printInfo(final Context context, final StringBuilder builder) {
-        builder.append(""Context: "").append(""["")
+        builder.append(""Context: ["")
                 .append(context.getNode().getId()).append("":"")
                 .append(context.getVhost().getId()).append("":"")
-                .append(context.getId()).append(""]"")
-                .append(""],Context: "").append(context.getPath())
-                .append("",Status: "").append(context.getStatus())
+                .append(context.getId())
+                .append(""]"")
+                .append("", Context: "").append(context.getPath())
+                .append("", Status: "").append(context.getStatus())
                 .append(NEWLINE);
     }
 
     static void printDump(final Context context, final StringBuilder builder) {
-        builder.append(""context: "").append(""["").append(context.getId()).append(""]"")
-                .append("" ["").append(context.getPath())
-                .append(""] vhost: "").append(context.getVhost().getId())
-                .append(""node: "").append(context.getNode().getId())
-                .append(""status: "").append(context.getStatus())
+        builder.append(""context: "").append(context.getId())
+                .append("" ["").append(context.getPath()).append(""]"")
+                .append("" vhost: "").append(context.getVhost().getId())
+                .append("" node: "").append(context.getNode().getId())
+                .append("" status: "").append(formatStatus(context.getStatus()))
                 .append(NEWLINE);
     }
 
     static void printInfo(final Node node, final StringBuilder builder) {
-        builder.append(""Node: ["")
-                // .append(node.getBalancer().getId()).append("":"")
-                .append(node.getId()).append(""]"")
+        builder.append(""Node: "")
+                .append(""["").append(node.getId()).append(""]"")
                 .append("",Name: "").append(node.getJvmRoute())
                 .append("",Balancer: "").append(node.getNodeConfig().getBalancer())
-                .append("",JVMRoute: "").append(node.getJvmRoute())
-                .append("",LBGroup: "").append(node.getNodeConfig().getDomain())
+                .append("",LBGroup: "").append(formatString(node.getNodeConfig().getDomain()))
                 .append("",Host: "").append(node.getNodeConfig().getConnectionURI().getHost())
                 .append("",Port: "").append(node.getNodeConfig().getConnectionURI().getPort())
                 .append("",Type: "").append(node.getNodeConfig().getConnectionURI().getScheme())
-                .append("",flushpackets: "").append(formatBoolean(node.getNodeConfig().isFlushPackets()))
-                .append("",flushwait: "").append(node.getNodeConfig().getFlushwait())
-                .append("",ping: "").append(node.getNodeConfig().getPing())
-                .append("",smax: "").append(node.getNodeConfig().getSmax())
-                .append("",ttl: "").append(node.getNodeConfig().getTtl())
-                .append("",timeout: "").append(node.getNodeConfig().getTimeout())
-                //
+                .append("",Flushpackets: "").append(toStringOnOff(node.getNodeConfig().isFlushPackets()))
+                .append("",Flushwait: "").append(node.getNodeConfig().getFlushwait())
+                .append("",Ping: "").append(node.getNodeConfig().getPing())
+                .append("",Smax: "").append(node.getNodeConfig().getSmax())
+                .append("",Ttl: "").append(node.getNodeConfig().getTtl())
                 .append("",Elected: "").append(node.getElected())
                 .append("",Read: "").append(node.getConnectionPool().getClientStatistics().getRead())
-                .append("",Transferred: "").append(node.getConnectionPool().getClientStatistics().getWritten())
+                .append("",Transfered: "").append(node.getConnectionPool().getClientStatistics().getWritten())
                 .append("",Connected: "").append(node.getConnectionPool().getOpenConnections())
                 .append("",Load: "").append(node.getLoad())
-
                 .append(NEWLINE);
     }
 
@@ -110,11 +108,11 @@ static void printDump(final Node node, final StringBuilder builder) {
                 .append(node.getId()).append(""]"")
                 .append("",Balancer: "").append(node.getNodeConfig().getBalancer())
                 .append("",JVMRoute: "").append(node.getJvmRoute())
-                .append("",LBGroup: "").append(node.getNodeConfig().getDomain())
+                .append("",LBGroup: ["").append(formatString(node.getNodeConfig().getDomain())).append(""]"")
                 .append("",Host: "").append(node.getNodeConfig().getConnectionURI().getHost())
                 .append("",Port: "").append(node.getNodeConfig().getConnectionURI().getPort())
                 .append("",Type: "").append(node.getNodeConfig().getConnectionURI().getScheme())
-                .append("",flushpackets: "").append(formatBoolean(node.getNodeConfig().isFlushPackets()))
+                .append("",flushpackets: "").append(toStringOneZero(node.getNodeConfig().isFlushPackets()))
                 .append("",flushwait: "").append(node.getNodeConfig().getFlushwait())
                 .append("",ping: "").append(node.getNodeConfig().getPing())
                 .append("",smax: "").append(node.getNodeConfig().getSmax())
@@ -123,8 +121,24 @@ static void printDump(final Node node, final StringBuilder builder) {
                 .append(NEWLINE);
     }
 
-    static String formatBoolean(boolean value) {
-        return value ? ""1"" : ""0"";
+    static String toStringOneZero(boolean bool) {
+        return bool ? ""1"" : ""0"";
+    }
+
+    static String toStringOnOff(boolean bool) {
+        return bool ? ""On"" : ""Off"";
+    }
+
+    static String formatString(String str) {
+        return str == null ? """" : str;
+    }
+
+    /* matches constants defined in mod_cluster-1.3.7.Final/native/include/context.h */
+    static int formatStatus(Context.Status status) {
+        return status == Context.Status.ENABLED ? 1 :
+               status == Context.Status.DISABLED ? 2 :
+               status == Context.Status.STOPPED ? 3 :
+               -1;
     }
 
 }",2017-10-11T19:14:00Z,393
"@@ -238,7 +238,7 @@ void nodeCommandString(StringBuilder buf, String uri, MCMPAction status, String
 
     static void printProxyStat(StringBuilder buf, Node node, boolean reduceDisplay) {
         String status = ""NOTOK"";
-        if (node.getStatus() == Node.Status.NODE_UP)
+        if (node.getStatus() == NodeStatus.NODE_UP)
             status = ""OK"";
         if (reduceDisplay) {
             buf.append("" "" + status + "" "");",2015-05-20T06:29:15Z,394
"@@ -47,6 +47,7 @@ public class ModCluster {
     private final int requestQueueSize;
     private final boolean queueNewRequests;
     private final int maxRequestTime;
+    private final long ttl;
 
     private final XnioWorker xnioWorker;
     private final ModClusterContainer container;
@@ -63,6 +64,7 @@ public class ModCluster {
         this.removeBrokenNodes = builder.removeBrokenNodes;
         this.healthChecker = builder.healthChecker;
         this.maxRequestTime = builder.maxRequestTime;
+        this.ttl = builder.ttl;
         this.container = new ModClusterContainer(this, builder.xnioSsl, builder.client);
     }
 
@@ -74,6 +76,10 @@ protected ModClusterContainer getContainer() {
         return container;
     }
 
+    public ModClusterController getController() {
+        return container;
+    }
+
     public int getMaxConnections() {
         return maxConnections;
     }
@@ -102,6 +108,10 @@ public NodeHealthChecker getHealthChecker() {
         return healthChecker;
     }
 
+    public long getTtl() {
+        return ttl;
+    }
+
     /**
      * Get the handler proxying the requests.
      *
@@ -181,6 +191,7 @@ public static class Builder {
         private boolean queueNewRequests = false;
 
         private int maxRequestTime = -1;
+        private long ttl;
 
         private NodeHealthChecker healthChecker = NodeHealthChecker.NO_CHECK;
         private long healthCheckInterval = TimeUnit.SECONDS.toMillis(10);
@@ -235,6 +246,14 @@ public Builder setHealthChecker(NodeHealthChecker healthChecker) {
             this.healthChecker = healthChecker;
             return this;
         }
+
+        public long getTtl() {
+            return ttl;
+        }
+
+        public void setTtl(long ttl) {
+            this.ttl = ttl;
+        }
     }
 
 }",2015-05-20T06:29:15Z,395
"@@ -18,15 +18,6 @@
 
 package io.undertow.server.handlers.proxy.mod_cluster;
 
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.TimeUnit;
-
 import io.undertow.UndertowLogger;
 import io.undertow.client.UndertowClient;
 import io.undertow.server.HttpServerExchange;
@@ -41,11 +32,20 @@
 import org.xnio.XnioIoThread;
 import org.xnio.ssl.XnioSsl;
 
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
+
 /**
  * @author Stuart Douglas
  * @author Emanuel Muckenhuber
  */
-class ModClusterContainer {
+class ModClusterContainer implements ModClusterController {
 
     // The configured balancers
     private final ConcurrentMap<String, Balancer> balancers = new CopyOnWriteMap<>();
@@ -148,10 +148,10 @@ public ModClusterProxyTarget findTarget(final HttpServerExchange exchange) {
     /**
      * Register a new node.
      *
-     * @param config            the node configuration
-     * @param balancerConfig    the balancer configuration
-     * @param ioThread          the associated I/O thread
-     * @param bufferPool        the buffer pool
+     * @param config         the node configuration
+     * @param balancerConfig the balancer configuration
+     * @param ioThread       the associated I/O thread
+     * @param bufferPool     the buffer pool
      * @return whether the node could be created or not
      */
     public synchronized boolean addNode(final NodeConfig config, final Balancer.BalancerBuilder balancerConfig, final XnioIoThread ioThread, final Pool<ByteBuffer> bufferPool) {
@@ -196,7 +196,7 @@ public synchronized boolean addNode(final NodeConfig config, final Balancer.Bala
     /**
      * Management command enabling all contexts on the given node.
      *
-     * @param jvmRoute    the jvmRoute
+     * @param jvmRoute the jvmRoute
      * @return
      */
     public synchronized boolean enableNode(final String jvmRoute) {
@@ -213,7 +213,7 @@ public synchronized boolean enableNode(final String jvmRoute) {
     /**
      * Management command disabling all contexts on the given node.
      *
-     * @param jvmRoute    the jvmRoute
+     * @param jvmRoute the jvmRoute
      * @return
      */
     public synchronized boolean disableNode(final String jvmRoute) {
@@ -230,7 +230,7 @@ public synchronized boolean disableNode(final String jvmRoute) {
     /**
      * Management command stopping all contexts on the given node.
      *
-     * @param jvmRoute    the jvmRoute
+     * @param jvmRoute the jvmRoute
      * @return
      */
     public synchronized boolean stopNode(final String jvmRoute) {
@@ -325,7 +325,7 @@ public synchronized boolean enableContext(final String contextPath, final String
         return false;
     }
 
-    synchronized boolean disableContext(final String contextPath, final String jvmRoute, List<String> aliases) {
+    public synchronized boolean disableContext(final String contextPath, final String jvmRoute, List<String> aliases) {
         final Node node = nodes.get(jvmRoute);
         if (node != null) {
             node.disableContext(contextPath, aliases);
@@ -386,10 +386,10 @@ Context findNewNode(final VirtualHost.HostEntry entry) {
     /**
      * Try to find a failover node within the same load balancing group.
      *
-     * @oaram entry      the resolved virtual host entry
-     * @param domain     the load balancing domain, if known
-     * @param jvmRoute   the original jvmRoute
+     * @param domain   the load balancing domain, if known
+     * @param jvmRoute the original jvmRoute
      * @return the context, {@code null} if not found
+     * @oaram entry      the resolved virtual host entry
      */
     Context findFailoverNode(final VirtualHost.HostEntry entry, final String domain, final String jvmRoute, final boolean forceStickySession) {
         String failOverDomain = null;
@@ -421,7 +421,7 @@ Context findFailoverNode(final VirtualHost.HostEntry entry, final String domain,
     /**
      * Map a request to virtual host.
      *
-     * @param exchange    the http exchange
+     * @param exchange the http exchange
      * @return
      */
     private PathMatcher.PathMatch<VirtualHost.HostEntry> mapVirtualHost(final HttpServerExchange exchange) {
@@ -442,8 +442,8 @@ private PathMatcher.PathMatch<VirtualHost.HostEntry> mapVirtualHost(final HttpSe
             if (host == null) {
                 return null;
             }
-            PathMatcher.PathMatch<VirtualHost.HostEntry> result =  host.match(context);
-            if(result.getValue() == null) {
+            PathMatcher.PathMatch<VirtualHost.HostEntry> result = host.match(context);
+            if (result.getValue() == null) {
                 return null;
             }
             return result;
@@ -586,4 +586,190 @@ public void run() {
         }
     }
 
+
+    @Override
+    public ModClusterStatus getStatus() {
+        List<ModClusterStatus.LoadBalancer> balancers = new ArrayList<>();
+        for(Map.Entry<String, Balancer> bentry : this.balancers.entrySet()) {
+            List<ModClusterStatus.Node> nodes = new ArrayList<>();
+            for(Node node : this.getNodes()) {
+                if(node.getBalancer().getName().equals(bentry.getKey())) {
+                    List<ModClusterStatus.Context> contexts = new ArrayList<>();
+
+                    for(Context i : node.getContexts()) {
+                        contexts.add(new ContextImpl(i));
+                    }
+
+                    nodes.add(new NodeImpl(node, contexts));
+                }
+            }
+
+            balancers.add(new BalancerImpl(bentry.getValue(), nodes));
+        }
+        return new ModClusterStatusImpl(balancers);
+    }
+
+    private class ModClusterStatusImpl implements ModClusterStatus {
+
+        private final List<LoadBalancer> balancers;
+
+        private ModClusterStatusImpl(List<LoadBalancer> balancers) {
+            this.balancers = balancers;
+        }
+
+        @Override
+        public List<LoadBalancer> getLoadBalancers() {
+            return balancers;
+        }
+
+        @Override
+        public LoadBalancer getLoadBalancer(String name) {
+            for (LoadBalancer b : balancers) {
+                if (b.getName().equals(name)) {
+                    return b;
+                }
+            }
+            return null;
+        }
+    }
+
+    private class BalancerImpl implements ModClusterStatus.LoadBalancer {
+        private final Balancer balancer;
+        private final List<ModClusterStatus.Node> nodes;
+
+        private BalancerImpl(Balancer balancer, List<ModClusterStatus.Node> nodes) {
+            this.balancer = balancer;
+            this.nodes = nodes;
+        }
+
+        @Override
+        public String getName() {
+            return balancer.getName();
+        }
+
+        @Override
+        public List<ModClusterStatus.Node> getNodes() {
+            return nodes;
+        }
+
+        @Override
+        public ModClusterStatus.Node getNode(String name) {
+            for (ModClusterStatus.Node i : nodes) {
+                if(i.getName().equals(name)) {
+                    return i;
+                }
+            }
+            return null;
+        }
+
+        @Override
+        public boolean isStickySession() {
+            return balancer.isStickySession();
+        }
+
+        @Override
+        public String getStickySessionCookie() {
+            return balancer.getStickySessionCookie();
+        }
+
+        @Override
+        public String getStickySessionPath() {
+            return null;
+        }
+
+        @Override
+        public boolean isStickySessionRemove() {
+            return balancer.isStickySessionRemove();
+        }
+
+        @Override
+        public boolean isStickySessionForce() {
+            return balancer.isStickySessionForce();
+        }
+
+        @Override
+        public int getWaitWorker() {
+            return balancer.getWaitWorker();
+        }
+
+        @Override
+        public int getMaxAttempts() {
+            return balancer.getMaxattempts();
+        }
+    }
+
+    private class NodeImpl implements ModClusterStatus.Node {
+
+        private final Node node;
+        private final List<ModClusterStatus.Context> contexts;
+
+        private NodeImpl(Node node, List<ModClusterStatus.Context> contexts) {
+            this.node = node;
+            this.contexts = contexts;
+        }
+
+        @Override
+        public String getName() {
+            return node.getJvmRoute();
+        }
+
+        @Override
+        public List<ModClusterStatus.Context> getContexts() {
+            return Collections.unmodifiableList(contexts);
+        }
+
+        @Override
+        public ModClusterStatus.Context getContext(String name) {
+            for (ModClusterStatus.Context i : contexts) {
+                if(i.getName().equals(name)) {
+                    return i;
+                }
+            }
+            return null;
+        }
+
+        @Override
+        public int getLoad() {
+            return node.getLoad();
+        }
+
+        @Override
+        public NodeStatus getStatus() {
+            return node.getStatus();
+        }
+    }
+
+    private class ContextImpl implements ModClusterStatus.Context {
+        private final Context context;
+
+        private ContextImpl(Context context) {
+            this.context = context;
+        }
+
+        @Override
+        public String getName() {
+            return context.getPath();
+        }
+
+        @Override
+        public boolean isEnabled() {
+            return context.isEnabled();
+        }
+
+        @Override
+        public int getRequests() {
+            return context.getActiveRequests();
+        }
+
+        @Override
+        public void enable() {
+            context.enable();
+        }
+
+        @Override
+        public void disable() {
+            context.disable();
+        }
+    }
+
 }",2015-05-20T06:29:15Z,261
"@@ -0,0 +1,28 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy.mod_cluster;
+
+/**
+ * @author Stuart Douglas
+ */
+public interface ModClusterController {
+
+    ModClusterStatus getStatus();
+
+}",2015-05-20T06:29:15Z,396
"@@ -0,0 +1,116 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy.mod_cluster;
+
+import java.util.List;
+
+/**
+ * An interface that allows the current status of the mod_cluster container to be queried and modified
+ *
+ * @author Stuart Douglas
+ */
+public interface ModClusterStatus {
+
+    List<LoadBalancer> getLoadBalancers();
+
+    LoadBalancer getLoadBalancer(String name);
+
+    interface LoadBalancer {
+
+        String getName();
+
+        List<Node> getNodes();
+
+        Node getNode(String name);
+
+        /**
+         * Getter for stickySession
+         *
+         * @return the stickySession
+         */
+        boolean isStickySession();
+
+        /**
+         * Getter for stickySessionCookie
+         *
+         * @return the stickySessionCookie
+         */
+        String getStickySessionCookie();
+        /**
+         * Getter for stickySessionPath
+         *
+         * @return the stickySessionPath
+         */
+        String getStickySessionPath();
+
+        /**
+         * Getter for stickySessionRemove
+         *
+         * @return the stickySessionRemove
+         */
+        boolean isStickySessionRemove();
+
+        /**
+         * Getter for stickySessionForce
+         *
+         * @return the stickySessionForce
+         */
+        boolean isStickySessionForce();
+
+        /**
+         * Getter for waitWorker
+         *
+         * @return the waitWorker
+         */
+        int getWaitWorker();
+
+        /**
+         * Getter for maxattempts
+         *
+         * @return the maxattempts
+         */
+        int getMaxAttempts();
+    }
+
+    interface Node {
+
+        String getName();
+
+        List<Context> getContexts();
+
+        Context getContext(String name);
+
+        int getLoad();
+
+        NodeStatus getStatus();
+    }
+
+    interface Context {
+
+        String getName();
+
+        boolean isEnabled();
+
+        int getRequests();
+
+        void enable();
+
+        void disable();
+    }
+}",2015-05-20T06:29:15Z,397
"@@ -43,21 +43,6 @@
  */
 class Node {
 
-    enum Status {
-        /**
-         * The node is up
-         */
-        NODE_UP,
-        /**
-         * The node is down
-         */
-        NODE_DOWN,
-        /**
-         * The node is paused
-         */
-        NODE_HOT_STANDBY;
-    }
-
     private final int id;
     private final String jvmRoute;
     private final ConnectionPoolManager connectionPoolManager;
@@ -134,14 +119,14 @@ XnioIoThread getIoThread() {
         return ioThread;
     }
 
-    public Status getStatus() {
+    public NodeStatus getStatus() {
         final int status = this.state;
         if (anyAreSet(status, ERROR)) {
-            return Status.NODE_DOWN;
+            return NodeStatus.NODE_DOWN;
         } else if (anyAreSet(status, HOT_STANDBY)) {
-            return Status.NODE_HOT_STANDBY;
+            return NodeStatus.NODE_HOT_STANDBY;
         } else {
-            return Status.NODE_UP;
+            return NodeStatus.NODE_UP;
         }
     }
 ",2015-05-20T06:29:15Z,262
"@@ -66,9 +66,9 @@ public class NodeConfig {
     private final int ping;
 
     /**
-     * max time in seconds to life for connection above smax. Default 60 seconds (60_000 in milliseconds).
+     * max time in milliseconds to life for connection above smax. Default 60 seconds (60,000 in milliseconds).
      */
-    private final int ttl;
+    private final long ttl;
 
     /**
      * Max time the proxy will wait for the backend connection. Default 0 no timeout value in seconds.
@@ -147,7 +147,7 @@ public int getSmax() {
      *
      * @return the ttl
      */
-    public int getTtl() {
+    public long getTtl() {
         return this.ttl;
     }
 
@@ -240,14 +240,15 @@ public static class NodeBuilder {
         private int requestQueueSize;
         private boolean queueNewRequests = false;
 
-        private int ttl = 60000;
+        private long ttl = 60000;
         private int timeout = 0;
 
         NodeBuilder(final ModCluster modCluster) {
             this.maxConnections = modCluster.getMaxConnections();
             this.cacheConnections = modCluster.getCacheConnections();
             this.requestQueueSize = modCluster.getRequestQueueSize();
             this.queueNewRequests = modCluster.isQueueNewRequests();
+            this.ttl = modCluster.getTtl();
         }
 
         public NodeBuilder setHostname(String hostname) {
@@ -320,7 +321,7 @@ public NodeBuilder setQueueNewRequests(boolean queueNewRequests) {
             return this;
         }
 
-        public NodeBuilder setTtl(int ttl) {
+        public NodeBuilder setTtl(long ttl) {
             this.ttl = ttl;
             return this;
         }",2015-05-20T06:29:15Z,263
"@@ -0,0 +1,37 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server.handlers.proxy.mod_cluster;
+
+/**
+ * @author Stuart Douglas
+ */
+public enum NodeStatus {
+    /**
+     * The node is up
+     */
+    NODE_UP,
+    /**
+     * The node is down
+     */
+    NODE_DOWN,
+    /**
+     * The node is paused
+     */
+    NODE_HOT_STANDBY;
+}",2015-05-20T06:29:15Z,398
"@@ -24,7 +24,7 @@
 /**
  * @author Stuart Douglas
  */
-public class StatusCodesTestCase {
+public class NodeStatusCodesTestCase {
 
     @Test
     public void testCodeLookup() {",2015-05-20T06:29:15Z,47
"@@ -143,9 +143,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         } else if (info.getType() == ServletPathMatch.Type.REWRITE) {
             //this can only happen if the path ends with a /
             //otherwise there would be a redirect instead
-            exchange.setRelativePath(exchange.getRelativePath() + info.getRewriteLocation());
-            //exchange.setRequestURI(exchange.getRequestURI() + info.getRewriteLocation()); UNDERTOW-348
-            exchange.setRequestPath(exchange.getRequestPath() + info.getRewriteLocation());
+            exchange.setRelativePath(info.getRewriteLocation());
         }
 
         final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);",2015-04-09T06:56:58Z,145
"@@ -145,13 +145,17 @@ private ServletPathMatch findWelcomeFile(final String path, boolean requiresRedi
         if(File.separatorChar != '/' && path.contains(File.separator)) {
             return null;
         }
+        StringBuilder sb = new StringBuilder();
         for (String i : welcomePages) {
             try {
-                final String mergedPath = path + i;
+                sb.append(path);
+                sb.append(i);
+                final String mergedPath = sb.toString();
+                sb.setLength(0);
                 Resource resource = resourceManager.getResource(mergedPath);
                 if (resource != null) {
                     final ServletPathMatch handler = data.getServletHandlerByPath(mergedPath);
-                    return new ServletPathMatch(handler.getServletChain(), mergedPath, null, requiresRedirect ? REDIRECT : REWRITE, i);
+                    return new ServletPathMatch(handler.getServletChain(), mergedPath, null, requiresRedirect ? REDIRECT : REWRITE, mergedPath);
                 }
             } catch (IOException e) {
             }
@@ -160,11 +164,15 @@ private ServletPathMatch findWelcomeFile(final String path, boolean requiresRedi
     }
 
     private ServletPathMatch findWelcomeServlet(final String path, boolean requiresRedirect) {
+        StringBuilder sb = new StringBuilder();
         for (String i : welcomePages) {
-            String mergedPath = path + i;
+            sb.append(path);
+            sb.append(i);
+            final String mergedPath = sb.toString();
+            sb.setLength(0);
             final ServletPathMatch handler = data.getServletHandlerByPath(mergedPath);
             if (handler != null && !handler.isRequiredWelcomeFileMatch()) {
-                return new ServletPathMatch(handler.getServletChain(), handler.getMatched(), handler.getRemaining(), requiresRedirect ? REDIRECT : REWRITE, i);
+                return new ServletPathMatch(handler.getServletChain(), handler.getMatched(), handler.getRemaining(), requiresRedirect ? REDIRECT : REWRITE, mergedPath);
             }
         }
         return null;",2015-04-09T06:56:58Z,169
"@@ -101,7 +101,7 @@ public static void trySaveRequest(final HttpServerExchange exchange) {
                         }
                         headers.putAll(entry.getHeaderName(), entry);
                     }
-                    SavedRequest request = new SavedRequest(buffer, read, exchange.getRequestMethod(), exchange.getRequestPath(), exchange.getRequestHeaders());
+                    SavedRequest request = new SavedRequest(buffer, read, exchange.getRequestMethod(), exchange.getRelativePath(), exchange.getRequestHeaders());
                     final ServletRequestContext sc = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
                     HttpSessionImpl session = sc.getCurrentServletContext().getSession(exchange, true);
                     Session underlyingSession;
@@ -129,7 +129,7 @@ public static void tryRestoreRequest(final HttpServerExchange exchange, HttpSess
             }
             SavedRequest request = (SavedRequest) underlyingSession.getAttribute(SESSION_KEY);
             if(request != null) {
-                if(request.requestPath.equals(exchange.getRequestPath()) && exchange.isRequestComplete()) {
+                if(request.requestPath.equals(exchange.getRelativePath()) && exchange.isRequestComplete()) {
                     UndertowLogger.REQUEST_LOGGER.debugf(""restoring request body for request to %s"", request.requestPath);
                     exchange.setRequestMethod(request.method);
                     Connectors.ungetRequestBytes(exchange, new ImmediatePooled<>(ByteBuffer.wrap(request.data, 0, request.dataLength)));",2015-04-09T06:56:58Z,399
"@@ -367,4 +367,7 @@ public interface UndertowMessages {
 
     @Message(id = 113, value = ""Only the server side can send a push promise stream"")
     IOException pushPromiseCanOnlyBeCreatedByServer();
+
+    @Message(id = 114, value = ""Invalid IP access control rule %s. Format is: [ip-match] allow|deny"")
+    IllegalArgumentException invalidAclRule(String rule);
 }",2014-11-03T21:41:26Z,68
"@@ -22,14 +22,21 @@
 import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.regex.Pattern;
 
 import io.undertow.UndertowMessages;
+import io.undertow.server.HandlerWrapper;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.builder.HandlerBuilder;
 import io.undertow.util.StatusCodes;
 import org.xnio.Bits;
 
@@ -406,4 +413,96 @@ boolean matches(final InetAddress address) {
         }
     }
 
+
+    public static class Builder implements HandlerBuilder {
+
+        @Override
+        public String name() {
+            return ""ip-access-control"";
+        }
+
+        @Override
+        public Map<String, Class<?>> parameters() {
+            Map<String, Class<?>> params = new HashMap<>();
+            params.put(""acl"", String[].class);
+            params.put(""failure-status"", int.class);
+            params.put(""default-allow"", boolean.class);
+            return params;
+        }
+
+        @Override
+        public Set<String> requiredParameters() {
+            return Collections.singleton(""acl"");
+        }
+
+        @Override
+        public String defaultParameter() {
+            return ""acl"";
+        }
+
+        @Override
+        public HandlerWrapper build(Map<String, Object> config) {
+
+            String[] acl = (String[]) config.get(""acl"");
+            Boolean defaultAllow = (Boolean) config.get(""default-allow"");
+            Integer failureStatus = (Integer) config.get(""failure-status"");
+
+            List<Holder> peerMatches = new ArrayList<>();
+            for(String rule :acl) {
+                String[] parts = rule.split("" "");
+                if(parts.length != 2) {
+                    throw UndertowMessages.MESSAGES.invalidAclRule(rule);
+                }
+                if(parts[1].trim().equals(""allow"")) {
+                    peerMatches.add(new Holder(parts[0].trim(), false));
+                } else if(parts[1].trim().equals(""deny"")) {
+                    peerMatches.add(new Holder(parts[0].trim(), true));
+                } else {
+                    throw UndertowMessages.MESSAGES.invalidAclRule(rule);
+                }
+            }
+            return new Wrapper(peerMatches, defaultAllow == null ? false : defaultAllow, failureStatus == null ? StatusCodes.FORBIDDEN : failureStatus);
+        }
+
+    }
+
+    private static class Wrapper implements HandlerWrapper {
+
+        private final List<Holder> peerMatches;
+        private final boolean defaultAllow;
+        private final int failureStatus;
+
+
+        private Wrapper(List<Holder> peerMatches, boolean defaultAllow, int failureStatus) {
+            this.peerMatches = peerMatches;
+            this.defaultAllow = defaultAllow;
+            this.failureStatus = failureStatus;
+        }
+
+
+        @Override
+        public HttpHandler wrap(HttpHandler handler) {
+            IPAddressAccessControlHandler res = new IPAddressAccessControlHandler(handler, failureStatus);
+            for(Holder match: peerMatches) {
+                if(match.deny) {
+                    res.addDeny(match.rule);
+                } else {
+                    res.addAllow(match.rule);
+                }
+            }
+            res.setDefaultAllow(defaultAllow);
+            return res;
+        }
+    }
+
+    private static class Holder {
+        final String rule;
+        final boolean deny;
+
+        private Holder(String rule, boolean deny) {
+            this.rule = rule;
+            this.deny = deny;
+        }
+    }
+
 }",2014-11-03T21:41:26Z,29
"@@ -21,4 +21,5 @@ io.undertow.server.handlers.resource.ResourceHandler$Builder
 io.undertow.server.handlers.SSLHeaderHandler$Builder
 io.undertow.server.handlers.ResponseRateLimitingHandler$Builder
 io.undertow.server.handlers.URLDecodingHandler$Builder
-io.undertow.server.handlers.PathSeparatorHandler$Builder
\ No newline at end of file
+io.undertow.server.handlers.PathSeparatorHandler$Builder
+io.undertow.server.handlers.IPAddressAccessControlHandler$Builder
\ No newline at end of file",2014-11-03T21:41:26Z,175
"@@ -21,6 +21,7 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 
+import io.undertow.server.handlers.builder.HandlerParser;
 import io.undertow.util.StatusCodes;
 import org.junit.Assert;
 import org.junit.Test;
@@ -102,6 +103,16 @@ public void testIPv6SlashMatch() throws UnknownHostException {
                 .addAllow(""FE45:00:00:000:0:AAA:FFFF:0045"")
                 .addAllow(""FE45:00:00:000:0:AAA:FFFF:01F4/127"")
                 .addDeny(""FE45:00:00:000:0:AAA:FFFF:0/112"");
+        runIpv6SlashMAtchTest(handler);
+    }
+
+    @Test
+    public void testParsedHandler() throws UnknownHostException {
+        IPAddressAccessControlHandler handler = (IPAddressAccessControlHandler) HandlerParser.parse(""ip-access-control[default-allow=true, acl={'FE45:00:00:000:0:AAA:FFFF:0045 allow', 'FE45:00:00:000:0:AAA:FFFF:01F4/127 allow', 'FE45:00:00:000:0:AAA:FFFF:0/112 deny'}]"", getClass().getClassLoader()).wrap(ResponseCodeHandler.HANDLE_404);
+
+        runIpv6SlashMAtchTest(handler);
+    }
+    private void runIpv6SlashMAtchTest(IPAddressAccessControlHandler handler) throws UnknownHostException {
         Assert.assertTrue(handler.isAllowed(InetAddress.getByName(""FE45:0:0:0:0:AAA:FFFF:45"")));
         Assert.assertTrue(handler.isAllowed(InetAddress.getByName(""127.0.0.2"")));
         Assert.assertFalse(handler.isAllowed(InetAddress.getByName(""FE45:0:0:0:0:AAA:FFFF:46"")));
@@ -124,4 +135,5 @@ public void testDenyResponseCode() {
       IPAddressAccessControlHandler handler = new IPAddressAccessControlHandler(null, StatusCodes.NOT_FOUND);
       Assert.assertEquals(StatusCodes.NOT_FOUND, handler.getDenyResponseCode());
     }
+
 }",2014-11-03T21:41:26Z,29
"@@ -27,6 +27,7 @@
 import io.undertow.server.protocol.http.AlpnOpenListener;
 import io.undertow.server.protocol.http.HttpOpenListener;
 import io.undertow.server.protocol.http2.Http2OpenListener;
+import io.undertow.server.protocol.proxy.ProxyProtocolOpenListener;
 import org.xnio.ChannelListener;
 import org.xnio.ChannelListeners;
 import org.xnio.IoUtils;
@@ -40,8 +41,6 @@
 import org.xnio.XnioWorker;
 import org.xnio.channels.AcceptingChannel;
 import org.xnio.ssl.JsseSslUtils;
-import org.xnio.ssl.SslConnection;
-import org.xnio.ssl.XnioSsl;
 
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
@@ -152,7 +151,14 @@ public synchronized void start() {
                 if (listener.type == ListenerType.AJP) {
                     AjpOpenListener openListener = new AjpOpenListener(buffers, serverOptions);
                     openListener.setRootHandler(rootHandler);
-                    ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);
+
+                    final ChannelListener<StreamConnection> finalListener;
+                    if(listener.useProxyProtocol) {
+                        finalListener = new ProxyProtocolOpenListener(openListener, null, buffers, OptionMap.EMPTY);
+                    } else {
+                        finalListener = openListener;
+                    }
+                    ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(finalListener);
                     OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();
                     AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);
                     server.resumeAccepts();
@@ -168,7 +174,14 @@ public synchronized void start() {
                             handler = new Http2UpgradeHandler(handler);
                         }
                         openListener.setRootHandler(handler);
-                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);
+                        final ChannelListener<StreamConnection> finalListener;
+                        if(listener.useProxyProtocol) {
+                            finalListener = new ProxyProtocolOpenListener(openListener, null, buffers, OptionMap.EMPTY);
+                        } else {
+                            finalListener = openListener;
+                        }
+
+                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(finalListener);
                         OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();
                         AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);
                         server.resumeAccepts();
@@ -192,8 +205,8 @@ public synchronized void start() {
                         } else {
                             openListener = httpOpenListener;
                         }
-                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);
-                        XnioSsl xnioSsl;
+
+                        UndertowXnioSsl xnioSsl;
                         if (listener.sslContext != null) {
                             xnioSsl = new UndertowXnioSsl(xnio, OptionMap.create(Options.USE_DIRECT_BUFFERS, true), listener.sslContext);
                         } else {
@@ -204,8 +217,17 @@ public synchronized void start() {
                             }
                             xnioSsl = new UndertowXnioSsl(xnio, OptionMap.create(Options.USE_DIRECT_BUFFERS, true), JsseSslUtils.createSSLContext(listener.keyManagers, listener.trustManagers, new SecureRandom(), builder.getMap()));
                         }
+
                         OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();
-                        AcceptingChannel<SslConnection> sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptionsWithOverrides);
+                        AcceptingChannel<? extends StreamConnection> sslServer;
+                        if(listener.useProxyProtocol) {
+                            ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(new ProxyProtocolOpenListener(openListener, xnioSsl, buffers, socketOptionsWithOverrides));
+                            sslServer = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptionsWithOverrides);
+                        } else {
+                            ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);
+                            sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptionsWithOverrides);
+                        }
+
                         sslServer.resumeAccepts();
                         channels.add(sslServer);
                         listenerInfo.add(new ListenerInfo(""https"", sslServer.getLocalAddress(), listener.sslContext, openListener));
@@ -271,6 +293,7 @@ private static class ListenerConfig {
         final SSLContext sslContext;
         final HttpHandler rootHandler;
         final OptionMap overrideSocketOptions;
+        final boolean useProxyProtocol;
 
         private ListenerConfig(final ListenerType type, final int port, final String host, KeyManager[] keyManagers, TrustManager[] trustManagers, HttpHandler rootHandler) {
             this.type = type;
@@ -281,6 +304,7 @@ private ListenerConfig(final ListenerType type, final int port, final String hos
             this.rootHandler = rootHandler;
             this.sslContext = null;
             this.overrideSocketOptions = OptionMap.EMPTY;
+            this.useProxyProtocol = false;
         }
 
         private ListenerConfig(final ListenerType type, final int port, final String host, SSLContext sslContext, HttpHandler rootHandler) {
@@ -292,6 +316,7 @@ private ListenerConfig(final ListenerType type, final int port, final String hos
             this.trustManagers = null;
             this.sslContext = sslContext;
             this.overrideSocketOptions = OptionMap.EMPTY;
+            this.useProxyProtocol = false;
         }
 
         private ListenerConfig(final ListenerBuilder listenerBuilder) {
@@ -303,6 +328,7 @@ private ListenerConfig(final ListenerBuilder listenerBuilder) {
             this.trustManagers = listenerBuilder.trustManagers;
             this.sslContext = listenerBuilder.sslContext;
             this.overrideSocketOptions = listenerBuilder.overrideSocketOptions;
+            this.useProxyProtocol = listenerBuilder.useProxyProtocol;
         }
     }
 
@@ -315,6 +341,7 @@ public static final class ListenerBuilder {
         SSLContext sslContext;
         HttpHandler rootHandler;
         OptionMap overrideSocketOptions = OptionMap.EMPTY;
+        boolean useProxyProtocol;
 
         public ListenerBuilder setType(ListenerType type) {
             this.type = type;
@@ -355,6 +382,11 @@ public ListenerBuilder setOverrideSocketOptions(OptionMap overrideSocketOptions)
             this.overrideSocketOptions = overrideSocketOptions;
             return this;
         }
+
+        public ListenerBuilder setUseProxyProtocol(boolean useProxyProtocol) {
+            this.useProxyProtocol = useProxyProtocol;
+            return this;
+        }
     }
 
     public static final class Builder {",2017-08-24T05:50:51Z,400
"@@ -548,4 +548,13 @@ public interface UndertowMessages {
 
     @Message(id = 175, value = ""Invalid Hpack index %s"")
     HpackException invalidHpackIndex(int index);
+
+    @Message(id = 178, value = ""Buffer pool is too small, min size is %s"")
+    IllegalArgumentException bufferPoolTooSmall(int minSize);
+
+    @Message(id = 179, value = ""Invalid proxy header"")
+    IOException invalidProxyHeader();
+
+    @Message(id = 180, value = ""PROXY protocol header exceeded max size of 107 bytes"")
+    IOException headerSizeToLarge();
 }",2017-08-24T05:50:51Z,68
"@@ -0,0 +1,33 @@
+package io.undertow.server.protocol.proxy;
+
+import io.undertow.connector.ByteBufferPool;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
+import io.undertow.server.OpenListener;
+import org.xnio.ChannelListener;
+import org.xnio.OptionMap;
+import org.xnio.StreamConnection;
+
+/**
+ * Open listener for proxied connections
+ *
+ * @author Stuart Douglas
+ */
+public class ProxyProtocolOpenListener implements ChannelListener<StreamConnection> {
+    private final OpenListener openListener;
+    private final UndertowXnioSsl ssl;
+    private final ByteBufferPool bufferPool;
+    private final OptionMap sslOptionMap;
+
+    public ProxyProtocolOpenListener(OpenListener openListener, UndertowXnioSsl ssl, ByteBufferPool bufferPool, OptionMap sslOptionMap) {
+        this.openListener = openListener;
+        this.ssl = ssl;
+        this.bufferPool = bufferPool;
+        this.sslOptionMap = sslOptionMap;
+    }
+
+    @Override
+    public void handleEvent(StreamConnection streamConnection) {
+        streamConnection.getSourceChannel().setReadListener(new ProxyProtocolReadListener(streamConnection, openListener, ssl, bufferPool, sslOptionMap));
+        streamConnection.getSourceChannel().wakeupReads();
+    }
+}",2017-08-24T05:50:51Z,401
"@@ -0,0 +1,324 @@
+package io.undertow.server.protocol.proxy;
+
+import io.undertow.UndertowLogger;
+import io.undertow.UndertowMessages;
+import io.undertow.connector.ByteBufferPool;
+import io.undertow.connector.PooledByteBuffer;
+import io.undertow.protocols.ssl.UndertowXnioSsl;
+import io.undertow.server.DelegateOpenListener;
+import io.undertow.server.OpenListener;
+import io.undertow.util.PooledAdaptor;
+import org.xnio.ChannelListener;
+import org.xnio.IoUtils;
+import org.xnio.OptionMap;
+import org.xnio.StreamConnection;
+import org.xnio.channels.StreamSourceChannel;
+import org.xnio.conduits.PushBackStreamSourceConduit;
+import org.xnio.ssl.SslConnection;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.charset.StandardCharsets;
+
+/**
+ * Implementation of version 1 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
+ * <p>
+ * Even though it is not required by the spec this implementation provides a stateful parser, that can handle
+ * fragmentation of
+ *
+ * @author Stuart Douglas
+ */
+class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel> {
+
+    private static final int MAX_HEADER_LENGTH = 107;
+
+    private static final byte[] NAME = ""PROXY "".getBytes(StandardCharsets.US_ASCII);
+    private static final String UNKOWN = ""UNKOWN"";
+    private static final String TCP = ""TCP"";
+    private static final String TCP_6 = ""TCP6"";
+
+    private final StreamConnection streamConnection;
+    private final OpenListener openListener;
+    private final UndertowXnioSsl ssl;
+    private final ByteBufferPool bufferPool;
+    private final OptionMap sslOptionMap;
+
+    private int byteCount;
+    private String protocol;
+    private InetAddress sourceAddress;
+    private InetAddress destAddress;
+    private int sourcePort = -1;
+    private int destPort = -1;
+    private StringBuilder stringBuilder = new StringBuilder();
+    private boolean carriageReturnSeen = false;
+    private boolean parsingUnkown = false;
+
+
+    ProxyProtocolReadListener(StreamConnection streamConnection, OpenListener openListener, UndertowXnioSsl ssl, ByteBufferPool bufferPool, OptionMap sslOptionMap) {
+        this.streamConnection = streamConnection;
+        this.openListener = openListener;
+        this.ssl = ssl;
+        this.bufferPool = bufferPool;
+        this.sslOptionMap = sslOptionMap;
+        if (bufferPool.getBufferSize() < MAX_HEADER_LENGTH) {
+            throw UndertowMessages.MESSAGES.bufferPoolTooSmall(MAX_HEADER_LENGTH);
+        }
+    }
+
+    @Override
+    public void handleEvent(StreamSourceChannel streamSourceChannel) {
+        PooledByteBuffer buffer = bufferPool.allocate();
+        boolean freeBuffer = true;
+        try {
+            for (; ; ) {
+                int res = streamSourceChannel.read(buffer.getBuffer());
+                if (res == -1) {
+                    IoUtils.safeClose(streamConnection);
+                    return;
+                } else if (res == 0) {
+                    return;
+                } else {
+                    buffer.getBuffer().flip();
+                    while (buffer.getBuffer().hasRemaining()) {
+                        char c = (char) buffer.getBuffer().get();
+                        if (byteCount < NAME.length) {
+                            //first we verify that we have the correct protocol
+                            if (c != NAME[byteCount]) {
+                                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                            }
+                        } else {
+                            if (parsingUnkown) {
+                                //we are parsing the UNKOWN protocol
+                                //we just ignore everything till \r\n
+                                if (c == '\r') {
+                                    carriageReturnSeen = true;
+                                } else if (c == '\n') {
+                                    if (!carriageReturnSeen) {
+                                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                    }
+                                    //we are done
+                                    if (buffer.getBuffer().hasRemaining()) {
+                                        freeBuffer = false;
+                                        proxyAccept(null, null, buffer);
+                                    } else {
+                                        proxyAccept(null, null, null);
+                                    }
+                                    return;
+                                } else if (carriageReturnSeen) {
+                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                }
+                            } else if (carriageReturnSeen) {
+                                if (c == '\n') {
+                                    //we are done
+                                    SocketAddress s = new InetSocketAddress(sourceAddress, sourcePort);
+                                    SocketAddress d = new InetSocketAddress(destAddress, destPort);
+                                    if (buffer.getBuffer().hasRemaining()) {
+                                        freeBuffer = false;
+                                        proxyAccept(s, d, buffer);
+                                    } else {
+                                        proxyAccept(s, d, null);
+                                    }
+                                    return;
+                                } else {
+                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                }
+                            } else if (c == ' ') {
+                                //we have a space
+                                if (sourcePort != -1 || stringBuilder.length() == 0) {
+                                    //header was invalid, either we are expecting a \r or a \n, or the previous character was a space
+                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                } else if (protocol == null) {
+                                    protocol = stringBuilder.toString();
+                                    stringBuilder.setLength(0);
+                                    if (protocol.equals(UNKOWN)) {
+                                        parsingUnkown = true;
+                                    } else if (!protocol.equals(TCP) && !protocol.equals(TCP_6)) {
+                                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                    }
+                                } else if (sourceAddress == null) {
+                                    sourceAddress = parseAddress(stringBuilder.toString(), protocol);
+                                    stringBuilder.setLength(0);
+                                } else if (destAddress == null) {
+                                    destAddress = parseAddress(stringBuilder.toString(), protocol);
+                                    stringBuilder.setLength(0);
+                                } else {
+                                    sourcePort = Integer.parseInt(stringBuilder.toString());
+                                    stringBuilder.setLength(0);
+                                }
+                            } else if (c == '\r') {
+                                if (destPort == -1 && sourcePort != -1 && !carriageReturnSeen && stringBuilder.length() > 0) {
+                                    destPort = Integer.parseInt(stringBuilder.toString());
+                                    stringBuilder.setLength(0);
+                                    carriageReturnSeen = true;
+                                } else {
+                                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                                }
+                            } else if (c == '\n') {
+                                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                            } else {
+                                stringBuilder.append(c);
+                            }
+
+                        }
+                        byteCount++;
+                        if (byteCount == MAX_HEADER_LENGTH) {
+                            throw UndertowMessages.MESSAGES.headerSizeToLarge();
+                        }
+
+                    }
+
+
+                }
+            }
+
+        } catch (IOException e) {
+            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+            IoUtils.safeClose(streamConnection);
+        } catch (Exception e) {
+            UndertowLogger.REQUEST_IO_LOGGER.ioException(new IOException(e));
+            IoUtils.safeClose(streamConnection);
+        } finally {
+            if (freeBuffer) {
+                buffer.close();
+            }
+        }
+
+    }
+
+    private void proxyAccept(SocketAddress source, SocketAddress dest, PooledByteBuffer additionalData) {
+        StreamConnection streamConnection = this.streamConnection;
+        if (source != null) {
+            streamConnection = new AddressWrappedConnection(streamConnection, source, dest);
+        }
+        if (ssl != null) {
+
+            //we need to apply the additional data before the SSL wrapping
+            if (additionalData != null) {
+                PushBackStreamSourceConduit conduit = new PushBackStreamSourceConduit(streamConnection.getSourceChannel().getConduit());
+                conduit.pushBack(new PooledAdaptor(additionalData));
+                streamConnection.getSourceChannel().setConduit(conduit);
+            }
+            SslConnection sslConnection = ssl.wrapExistingConnection(streamConnection, sslOptionMap == null ? OptionMap.EMPTY : sslOptionMap);
+            UndertowXnioSsl.getSslEngine(sslConnection).setUseClientMode(false);
+            streamConnection = sslConnection;
+
+            callOpenListener(streamConnection, null);
+        } else {
+            callOpenListener(streamConnection, additionalData);
+        }
+    }
+
+
+    private void callOpenListener(StreamConnection streamConnection, final PooledByteBuffer buffer) {
+        if (openListener instanceof DelegateOpenListener) {
+            ((DelegateOpenListener) openListener).handleEvent(streamConnection, buffer);
+        } else {
+            if (buffer != null) {
+                PushBackStreamSourceConduit conduit = new PushBackStreamSourceConduit(streamConnection.getSourceChannel().getConduit());
+                conduit.pushBack(new PooledAdaptor(buffer));
+                streamConnection.getSourceChannel().setConduit(conduit);
+            }
+            openListener.handleEvent(streamConnection);
+        }
+    }
+
+    static InetAddress parseAddress(String addressString, String protocol) throws IOException {
+        InetAddress address;
+        if (protocol.equals(TCP)) {
+            String[] parts = addressString.split(""\\."");
+            if (parts.length != 4) {
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+            }
+            byte[] data = new byte[4];
+            for (int i = 0; i < 4; ++i) {
+                String part = parts[i];
+                if (part.length() == 0 || (part.charAt(0) == '0' && part.length() > 1)) {
+                    //leading zeros are not allowed
+                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                }
+                data[i] = (byte) Integer.parseInt(part);
+            }
+            address = InetAddress.getByAddress(data);
+        } else {
+            boolean startsWithColon = addressString.startsWith("":"");
+            if (startsWithColon && !addressString.startsWith(""::"")) {
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+            }
+            String[] parts = (startsWithColon ? addressString.substring(1) : addressString).split("":""); //because of the way split works we want to change a leading double colon to a single one. We have already verified that the address does not actually start with a single colon
+            byte[] data = new byte[16];
+            int partOffset = 0;
+            boolean seenEmpty = false;
+            if (parts.length > 8) {
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+            }
+            for (int i = 0; i < parts.length; ++i) {
+                String part = parts[i];
+                if (part.length() > 4) {
+                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                } else if (part.isEmpty()) {
+                    if (seenEmpty) {
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                    }
+                    seenEmpty = true;
+                    int off = 8 - parts.length;//this works because of the empty part that represents the double colon, so the parts list is one larger than the number of digits
+                    if (off < 0) {
+                        throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                    }
+                    partOffset = off * 2;
+                } else if (part.length() > 1 && part.charAt(0) == '0') {
+                    //leading zeros are not allowed
+                    throw UndertowMessages.MESSAGES.invalidProxyHeader();
+                } else {
+                    int num = Integer.parseInt(part, 16);
+                    data[i * 2 + partOffset] = (byte) (num >> 8);
+                    data[i * 2 + partOffset + 1] = (byte) (num);
+                }
+            }
+            if (parts.length < 8 && !seenEmpty) {
+                //address was too small
+                throw UndertowMessages.MESSAGES.invalidProxyHeader();
+            }
+            address = InetAddress.getByAddress(data);
+        }
+        return address;
+    }
+
+    private static final class AddressWrappedConnection extends StreamConnection {
+
+        private final StreamConnection delegate;
+        private final SocketAddress source;
+        private final SocketAddress dest;
+
+        AddressWrappedConnection(StreamConnection delegate, SocketAddress source, SocketAddress dest) {
+            super(delegate.getIoThread());
+            this.delegate = delegate;
+            this.source = source;
+            this.dest = dest;
+            setSinkConduit(delegate.getSinkChannel().getConduit());
+            setSourceConduit(delegate.getSourceChannel().getConduit());
+        }
+
+        @Override
+        protected void notifyWriteClosed() {
+            IoUtils.safeClose(delegate.getSinkChannel());
+        }
+
+        @Override
+        protected void notifyReadClosed() {
+            IoUtils.safeClose(delegate.getSourceChannel());
+        }
+
+        @Override
+        public SocketAddress getPeerAddress() {
+            return source;
+        }
+
+        @Override
+        public SocketAddress getLocalAddress() {
+            return dest;
+        }
+    }
+
+}",2017-08-24T05:50:51Z,173
"@@ -0,0 +1,166 @@
+package io.undertow.server.protocol.proxy;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+
+/**
+ * verifies that the proxy protocol ip address parser correctly parses IP addresses as per the additional requirements
+ * in the proxy protocol spec
+ *
+ * @author Stuart Douglas
+ */
+public class ProxyProtocolReadListenerAddressParsingTestCase {
+
+    @Test
+    public void testIpV4Address() throws IOException {
+        InetAddress res = ProxyProtocolReadListener.parseAddress(""1.123.255.2"", ""TCP"");
+        Assert.assertTrue(res instanceof Inet4Address);
+        Assert.assertEquals(1, res.getAddress()[0]);
+        Assert.assertEquals(123, res.getAddress()[1]);
+        Assert.assertEquals((byte)255, res.getAddress()[2]);
+        Assert.assertEquals(2, res.getAddress()[3]);
+        Assert.assertEquals(""/1.123.255.2"", res.toString());
+
+
+        res = ProxyProtocolReadListener.parseAddress(""127.0.0.1"", ""TCP"");
+        Assert.assertTrue(res instanceof Inet4Address);
+        Assert.assertEquals(127, res.getAddress()[0]);
+        Assert.assertEquals(0, res.getAddress()[1]);
+        Assert.assertEquals((byte)0, res.getAddress()[2]);
+        Assert.assertEquals(1, res.getAddress()[3]);
+        Assert.assertEquals(""/127.0.0.1"", res.toString());
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4AddressWithLeadingZero() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""01.123.255.2"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4AddressToSmall() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""01.123.255"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4AddressToLarge() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""01.123.255.1.1"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4AddressMultipleDots() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""1..255.2"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4AddressMultipleDots2() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""1..3.255.2"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4Hostname() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""localhost"", ""TCP"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV4Hostname2() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""ff"", ""TCP"");
+    }
+    @Test(expected = IOException.class)
+    public void testIpV4AddressStartsWithDot() throws IOException {
+        ProxyProtocolReadListener.parseAddress("".1.123.255.2"", ""TCP"");
+    }
+
+    @Test
+    public void testIpv6Address() throws IOException {
+        String addressString = ""2001:1db8:100:3:6:ff00:42:8329"";
+        InetAddress res = ProxyProtocolReadListener.parseAddress(addressString, ""TCP_6"");
+        Assert.assertTrue(res instanceof Inet6Address);
+
+        int[] parts = {0x2001, 0x1db8, 0x100, 0x3, 0x6, 0xff00, 0x42, 0x8329};
+        for(int i = 0 ; i < parts.length; ++i) {
+            Assert.assertEquals(((byte)(parts[i]>>8)), res.getAddress()[i * 2]);
+            Assert.assertEquals(((byte)(parts[i])), res.getAddress()[i * 2 + 1]);
+        }
+        Assert.assertEquals(""/"" + addressString, res.toString());
+
+        addressString = ""2001:1db8:100::6:ff00:42:8329"";
+        res = ProxyProtocolReadListener.parseAddress(addressString, ""TCP_6"");
+        Assert.assertTrue(res instanceof Inet6Address);
+
+        parts = new int[]{0x2001, 0x1db8, 0x100, 0x0, 0x6, 0xff00, 0x42, 0x8329};
+        for(int i = 0 ; i < parts.length; ++i) {
+            Assert.assertEquals(((byte)(parts[i]>>8)), res.getAddress()[i * 2]);
+            Assert.assertEquals(((byte)(parts[i])), res.getAddress()[i * 2 + 1]);
+        }
+        Assert.assertEquals(""/2001:1db8:100:0:6:ff00:42:8329"", res.toString());
+
+        addressString = ""2001:1db8:100::ff00:42:8329"";
+        res = ProxyProtocolReadListener.parseAddress(addressString, ""TCP_6"");
+        Assert.assertTrue(res instanceof Inet6Address);
+
+        parts = new int[]{0x2001, 0x1db8, 0x100, 0x0, 0x0, 0xff00, 0x42, 0x8329};
+        for(int i = 0 ; i < parts.length; ++i) {
+            Assert.assertEquals(((byte)(parts[i]>>8)), res.getAddress()[i * 2]);
+            Assert.assertEquals(((byte)(parts[i])), res.getAddress()[i * 2 + 1]);
+        }
+        Assert.assertEquals(""/2001:1db8:100:0:0:ff00:42:8329"", res.toString());
+
+
+        addressString = ""::1"";
+        res = ProxyProtocolReadListener.parseAddress(addressString, ""TCP_6"");
+        Assert.assertTrue(res instanceof Inet6Address);
+
+        parts = new int[]{0, 0, 0, 0, 0, 0, 0, 0x1};
+        for(int i = 0 ; i < parts.length; ++i) {
+            Assert.assertEquals(((byte)(parts[i]>>8)), res.getAddress()[i * 2]);
+            Assert.assertEquals(((byte)(parts[i])), res.getAddress()[i * 2 + 1]);
+        }
+        Assert.assertEquals(""/0:0:0:0:0:0:0:1"", res.toString());
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressWithLeadingZero() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""2001:1db8:100:03:6:ff00:42:8329"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressToSmall() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""2001:1db8:3:6:ff00:42:8329"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressToLarge() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""2001:1db8:100:3:6:7:ff00:42:8329"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressMultipleColons() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""2001:1db8:100::3:6:ff00:42:8329"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressMultipleColons2() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""2001::100::329"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6Hostname() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""localhost"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6Hostname2() throws IOException {
+        ProxyProtocolReadListener.parseAddress(""ff"", ""TCP_6"");
+    }
+
+    @Test(expected = IOException.class)
+    public void testIpV6AddressStartsWithColon() throws IOException {
+        ProxyProtocolReadListener.parseAddress("":2001:1db8:100:3:6:ff00:42:8329"", ""TCP_6"");
+    }
+
+}",2017-08-24T05:50:51Z,402
"@@ -0,0 +1,84 @@
+package io.undertow.server.protocol.proxy;
+
+import io.undertow.Undertow;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.util.FileUtils;
+import io.undertow.util.HttpString;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.nio.charset.StandardCharsets;
+
+/**
+ * Tests the proxy protocol
+ *
+ * @author Stuart Douglas
+ */
+public class ProxyProtocolTestCase {
+
+    @Test
+    public void testProxyProtocol() throws Exception {
+        Undertow undertow = Undertow.builder().addListener(
+                new Undertow.ListenerBuilder()
+                        .setType(Undertow.ListenerType.HTTP)
+                        .setHost(DefaultServer.getHostAddress())
+                        .setUseProxyProtocol(true)
+                        .setPort(0)
+        )
+                .setHandler(new HttpHandler() {
+                    @Override
+                    public void handleRequest(HttpServerExchange exchange) throws Exception {
+                        exchange.setPersistent(false);
+                        exchange.getResponseHeaders().put(new HttpString(""result""), exchange.getSourceAddress().toString() + "" "" + exchange.getDestinationAddress().toString());
+                    }
+                })
+                .build();
+        try {
+            undertow.start();
+            int port = ((InetSocketAddress) undertow.getListenerInfo().get(0).getAddress()).getPort();
+            Socket s = new Socket(DefaultServer.getHostAddress(), port);
+            s.getOutputStream().write(""PROXY TCP 1.2.3.4 5.6.7.8 444 555\r\nGET / HTTP/1.0\r\n\r\n"".getBytes(StandardCharsets.US_ASCII));
+            String result = FileUtils.readFile(s.getInputStream());
+            Assert.assertTrue(result, result.contains(""result: /1.2.3.4:444 /5.6.7.8:555""));
+        } finally {
+            undertow.stop();
+        }
+    }
+
+
+    @Test
+    public void testProxyProtocolSSl() throws Exception {
+        Undertow undertow = Undertow.builder().addListener(
+                new Undertow.ListenerBuilder()
+                        .setType(Undertow.ListenerType.HTTPS)
+                        .setSslContext(DefaultServer.getServerSslContext())
+                        .setHost(DefaultServer.getHostAddress())
+                        .setUseProxyProtocol(true)
+                        .setPort(0)
+        )
+                .setHandler(new HttpHandler() {
+                    @Override
+                    public void handleRequest(HttpServerExchange exchange) throws Exception {
+                        exchange.setPersistent(false);
+                        exchange.getResponseHeaders().put(new HttpString(""result""), exchange.getSourceAddress().toString() + "" "" + exchange.getDestinationAddress().toString());
+                    }
+                })
+                .build();
+        try {
+            undertow.start();
+            int port = ((InetSocketAddress) undertow.getListenerInfo().get(0).getAddress()).getPort();
+            Socket s = new Socket(DefaultServer.getHostAddress(), port);
+            s.getOutputStream().write(""PROXY TCP 1.2.3.4 5.6.7.8 444 555\r\n"".getBytes(StandardCharsets.US_ASCII));
+            s = DefaultServer.getClientSSLContext().getSocketFactory().createSocket(s, DefaultServer.getHostAddress(), port, true);
+            s.getOutputStream().write(""GET / HTTP/1.0\r\n\r\n"".getBytes(StandardCharsets.US_ASCII));
+            String result = FileUtils.readFile(s.getInputStream());
+            Assert.assertTrue(result, result.contains(""result: /1.2.3.4:444 /5.6.7.8:555""));
+        } finally {
+            undertow.stop();
+        }
+    }
+}",2017-08-24T05:50:51Z,314
"@@ -3,7 +3,7 @@ Undertow
 
 Java web server using non-blocking IO
 
-Project Lead: Stuart Douglas <sdouglas@gmail.com>
+Project Lead: Stuart Douglas <sdouglas@redhat.com>
 
 Mailing List: undertow-dev@lists.jboss.org  
 http://lists.jboss.org/mailman/listinfo/undertow-dev",2012-09-13T23:32:23Z,160
"@@ -102,6 +102,7 @@ public class DeploymentInfo implements Cloneable {
     private boolean disableCachingForSecuredPages = true;
     private boolean escapeErrorMessage = true;
     private boolean sendCustomReasonPhraseOnError = false;
+    private boolean useCachedAuthenticationMechanism = true;
     private AuthenticationMode authenticationMode = AuthenticationMode.PRO_ACTIVE;
     private ExceptionHandler exceptionHandler;
     private final Map<String, ServletInfo> servlets = new HashMap<>();
@@ -1212,6 +1213,22 @@ public DeploymentInfo setChangeSessionIdOnLogin(boolean changeSessionIdOnLogin)
         return this;
     }
 
+    public boolean isUseCachedAuthenticationMechanism() {
+        return useCachedAuthenticationMechanism;
+    }
+
+    /**
+     * If this is set to false the the cached authenticated session mechanism won't be installed. If you want FORM and
+     * other auth methods that require caching to work then you need to install another caching based auth method (such
+     * as SSO).
+     * @param useCachedAuthenticationMechanism If Undertow should use its internal authentication cache mechanism
+     * @return this
+     */
+    public DeploymentInfo setUseCachedAuthenticationMechanism(boolean useCachedAuthenticationMechanism) {
+        this.useCachedAuthenticationMechanism = useCachedAuthenticationMechanism;
+        return this;
+    }
+
     public boolean isSecurityDisabled() {
         return securityDisabled;
     }
@@ -1305,6 +1322,7 @@ public DeploymentInfo clone() {
         info.changeSessionIdOnLogin = changeSessionIdOnLogin;
         info.crawlerSessionManagerConfig = crawlerSessionManagerConfig;
         info.securityDisabled = securityDisabled;
+        info.useCachedAuthenticationMechanism = useCachedAuthenticationMechanism;
         return info;
     }
 ",2016-02-02T20:28:39Z,142
"@@ -361,8 +361,9 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
                 authenticationMechanisms.add(factory.create(name, parser, properties));
             }
         }
-
-        authenticationMechanisms.add(new CachedAuthenticatedSessionMechanism(identityManager)); //TODO: does this really need to be hard coded?
+        if(deploymentInfo.isUseCachedAuthenticationMechanism()) {
+            authenticationMechanisms.add(new CachedAuthenticatedSessionMechanism(identityManager));
+        }
         deployment.setAuthenticationMechanisms(authenticationMechanisms);
         //if the JASPI auth mechanism is set then it takes over
         if(deploymentInfo.getJaspiAuthenticationMechanism() == null) {",2016-02-02T20:28:39Z,80
"@@ -140,4 +140,9 @@ public interface UndertowMessages {
     @Message(id = 38, value = ""Authentication failed, requested user name '%s'"")
     String authenticationFailed(final String userName);
 
+    @Message(id = 39, value = ""To many query parameters, cannot have more than %s query parameters"")
+    RuntimeException tooManyQueryParameters(int noParams);
+
+    @Message(id = 40, value = ""To many headers, cannot have more than %s header"")
+    RuntimeException tooManyHeaders(int noParams);
 }",2013-04-02T06:29:19Z,68
"@@ -268,6 +268,7 @@ final int handlePath(ByteBuffer buffer, int remaining, ParseState state, HttpSer
                     state.nextHeader = null;
                     state.queryParamPos = 0;
                     state.requestEnd = 0;
+                    state.mapCount = 0;
                     return remaining;
                 }
             } else if( next == '\r' || next == '\n') {
@@ -303,11 +304,19 @@ final int handlePath(ByteBuffer buffer, int remaining, ParseState state, HttpSer
                     queryParamPos = stringBuilder.length() + 1;
                 } else if (next == '&' && parseState == QUERY_PARAM_NAME) {
                     parseState = QUERY_PARAM_NAME;
+                    if(state.mapCount++ > 1000) {
+                        //todo: make configurable
+                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(1000);
+                    }
                     exchange.addQueryParam(stringBuilder.substring(queryParamPos), """");
                     nextQueryParam = null;
                     queryParamPos = stringBuilder.length() + 1;
                 } else if (next == '&' && parseState == QUERY_PARAM_VALUE) {
                     parseState = QUERY_PARAM_NAME;
+                    if(state.mapCount++ > 1000) {
+                        //todo: make configurable
+                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(1000);
+                    }
                     exchange.addQueryParam(nextQueryParam, stringBuilder.substring(queryParamPos));
                     nextQueryParam = null;
                     queryParamPos = stringBuilder.length() + 1;
@@ -349,6 +358,11 @@ final int handleHeaderValue(ByteBuffer buffer, int remaining, ParseState state,
         if (stringBuilder == null) {
             stringBuilder = new StringBuilder();
             state.parseState = 0;
+
+            if(state.mapCount++ > 1000) {
+                //todo: make configurable
+                throw UndertowMessages.MESSAGES.tooManyHeaders(1000);
+            }
         }
 
 ",2013-04-02T06:29:19Z,77
"@@ -96,6 +96,7 @@ class ParseState {
 
     String nextQueryParam;
 
+    int mapCount;
 
     public ParseState() {
         this.parseState = 0;",2013-04-02T06:29:19Z,86
"@@ -77,18 +77,21 @@ public String toString() {
     }
 
     public static List<WebSocketExtension> parse(final String extensionHeader) {
+        if(extensionHeader == null || extensionHeader.isEmpty()) {
+            return Collections.emptyList();
+        }
         List<WebSocketExtension> extensions = new ArrayList<>();
         //TODO: more efficient parsing algorithm
         String[] parts = extensionHeader.split("","");
         for (String part : parts) {
             String[] items = part.split("";"");
             if (items.length > 0) {
                 final List<Parameter> params = new ArrayList<>(items.length - 1);
-                String name = items[0];
+                String name = items[0].trim();
                 for (int i = 1; i < items.length; ++i) {
                     String[] param = items[i].split(""="");
                     if (param.length == 2) {
-                        params.add(new Parameter(param[0], param[1]));
+                        params.add(new Parameter(param[0].trim(), param[1].trim()));
                     }
                 }
                 extensions.add(new WebSocketExtension(name, params));",2014-10-28T02:17:58Z,403
"@@ -94,7 +94,7 @@ public Map<String, String> createHeaders() {
                 Iterator<WebSocketExtension> it = extensions.iterator();
                 while (it.hasNext()) {
                     WebSocketExtension next = it.next();
-                    sb.append(next);
+                    sb.append(next.getName());
                     for (WebSocketExtension.Parameter param : next.getParameters()) {
                         sb.append(""; "");
                         sb.append(param.getName());",2014-10-28T02:17:58Z,404
"@@ -19,6 +19,7 @@
 package io.undertow.websockets.core.protocol;
 
 import io.undertow.util.Headers;
+import io.undertow.websockets.WebSocketExtension;
 import io.undertow.websockets.core.WebSocketChannel;
 import io.undertow.websockets.core.WebSocketVersion;
 import io.undertow.websockets.spi.WebSocketHttpExchange;
@@ -27,6 +28,9 @@
 import org.xnio.StreamConnection;
 
 import java.nio.ByteBuffer;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
 import java.util.regex.Pattern;
 
@@ -162,6 +166,31 @@ protected final void selectSubprotocol(final WebSocketHttpExchange exchange) {
 
     }
 
+
+    protected final void selectExtensions(final WebSocketHttpExchange exchange) {
+        List<WebSocketExtension> requestedExtensions = WebSocketExtension.parse(exchange.getRequestHeader(Headers.SEC_WEB_SOCKET_EXTENSIONS_STRING));
+        List<WebSocketExtension> extensions = selectedExtension(requestedExtensions);
+        if (extensions != null && !extensions.isEmpty()) {
+            StringBuilder sb = new StringBuilder();
+            Iterator<WebSocketExtension> it = extensions.iterator();
+            while (it.hasNext()) {
+                WebSocketExtension next = it.next();
+                sb.append(next.getName());
+                for (WebSocketExtension.Parameter param : next.getParameters()) {
+                    sb.append(""; "");
+                    sb.append(param.getName());
+                    sb.append(""="");
+                    sb.append(param.getValue());
+                }
+                if (it.hasNext()) {
+                    sb.append("", "");
+                }
+            }
+            exchange.setResponseHeader(Headers.SEC_WEB_SOCKET_EXTENSIONS_STRING, sb.toString());
+        }
+
+    }
+
     protected String supportedSubprotols(String[] requestedSubprotocolArray) {
         for (String p : requestedSubprotocolArray) {
             String requestedSubprotocol = p.trim();
@@ -174,4 +203,8 @@ protected String supportedSubprotols(String[] requestedSubprotocolArray) {
         }
         return null;
     }
+
+    protected List<WebSocketExtension> selectedExtension(List<WebSocketExtension> extensionList) {
+        return Collections.emptyList();
+    }
 }",2014-10-28T02:17:58Z,55
"@@ -76,6 +76,7 @@ protected void handshakeInternal(final WebSocketHttpExchange exchange) {
             exchange.setResponseHeader(Headers.SEC_WEB_SOCKET_ORIGIN_STRING, origin);
         }
         selectSubprotocol(exchange);
+        selectExtensions(exchange);
         exchange.setResponseHeader(Headers.SEC_WEB_SOCKET_LOCATION_STRING, getWebSocketLocation(exchange));
 
         final String key = exchange.getRequestHeader(Headers.SEC_WEB_SOCKET_KEY_STRING);",2014-10-28T02:17:58Z,10
"@@ -54,6 +54,7 @@ protected void handshakeInternal(final WebSocketHttpExchange exchange) {
             exchange.setResponseHeader(Headers.ORIGIN_STRING, origin);
         }
         selectSubprotocol(exchange);
+        selectExtensions(exchange);
         exchange.setResponseHeader(Headers.SEC_WEB_SOCKET_LOCATION_STRING, getWebSocketLocation(exchange));
 
         final String key = exchange.getRequestHeader(Headers.SEC_WEB_SOCKET_KEY_STRING);",2014-10-28T02:17:58Z,134
"@@ -59,9 +59,9 @@ public String getNegotiatedSubprotocol(final List<String> supported, final List<
     @Override
     public List<Extension> getNegotiatedExtensions(final List<Extension> installed, final List<Extension> requested) {
         final List<Extension> ret = new ArrayList<>();
-        for(Extension extension : installed) {
-            for(Extension req : requested) {
-                if(extension.getName().equals(req.getName())) {
+        for (Extension req : requested) {
+            for (Extension extension : installed) {
+                if (extension.getName().equals(req.getName())) {
                     ret.add(req);
                     break;
                 }",2014-10-28T02:17:58Z,49
"@@ -27,7 +27,7 @@
 /**
  * @author Stuart Douglas
  */
-class ExtensionImpl implements Extension {
+public class ExtensionImpl implements Extension {
 
     private final String name;
     private final List<Parameter> parameters;",2014-10-28T02:17:58Z,405
"@@ -18,8 +18,11 @@
 package io.undertow.websockets.jsr.handshake;
 
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
+import javax.websocket.Extension;
 import javax.websocket.server.ServerEndpointConfig;
 
 import io.undertow.util.AttachmentKey;
@@ -62,14 +65,14 @@ public static void prepareUpgrade(final ServerEndpointConfig config, final WebSo
     }
 
     /**
-     * Set the {@link ServerEndpointConfiguration} which is used to create the {@link WebSocketChannel}.
+     * Set the {@link ConfiguredServerEndpoint} which is used to create the {@link WebSocketChannel}.
      */
     public static void setConfig(WebSocketChannel channel, ConfiguredServerEndpoint config) {
         channel.setAttribute(CONFIG_KEY, config);
     }
 
     /**
-     * Returns the {@link ServerEndpointConfiguration} which was used while create the {@link WebSocketChannel}.
+     * Returns the {@link ConfiguredServerEndpoint} which was used while create the {@link WebSocketChannel}.
      */
     public static ConfiguredServerEndpoint getConfig(WebSocketChannel channel) {
         return (ConfiguredServerEndpoint) channel.getAttribute(CONFIG_KEY);
@@ -90,4 +93,12 @@ static String selectSubProtocol(final ConfiguredServerEndpoint config, final Str
             return null;
         }
     }
+
+    static List<Extension> selectExtensions(final ConfiguredServerEndpoint config, final List<Extension> requestedExtensions) {
+        if (config.getEndpointConfiguration().getConfigurator() != null) {
+            return config.getEndpointConfiguration().getConfigurator().getNegotiatedExtensions(config.getEndpointConfiguration().getExtensions(), requestedExtensions);
+        } else {
+            return Collections.emptyList();
+        }
+    }
 }",2014-10-28T02:17:58Z,9
"@@ -17,15 +17,20 @@
  */
 package io.undertow.websockets.jsr.handshake;
 
+import io.undertow.websockets.WebSocketExtension;
 import io.undertow.websockets.core.WebSocketChannel;
 import io.undertow.websockets.core.protocol.version13.Hybi13Handshake;
 import io.undertow.websockets.jsr.ConfiguredServerEndpoint;
+import io.undertow.websockets.jsr.ExtensionImpl;
 import io.undertow.websockets.spi.WebSocketHttpExchange;
 import org.xnio.Pool;
 import org.xnio.StreamConnection;
 
+import javax.websocket.Extension;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 
 /**
  * {@link Hybi13Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfiguration} and
@@ -63,4 +68,26 @@ public boolean matches(WebSocketHttpExchange exchange) {
     protected String supportedSubprotols(String[] requestedSubprotocolArray) {
         return HandshakeUtil.selectSubProtocol(config, requestedSubprotocolArray);
     }
+
+    @Override
+    protected List<WebSocketExtension> selectedExtension(List<WebSocketExtension> extensionList) {
+        List<Extension> ext = new ArrayList<>();
+        for(WebSocketExtension i : extensionList) {
+            ext.add(ExtensionImpl.create(i));
+        }
+        List<Extension> selected = HandshakeUtil.selectExtensions(config, ext);
+        if(selected == null) {
+            return Collections.emptyList();
+        }
+        List<WebSocketExtension> ret = new ArrayList<>();
+        for(Extension i : selected) {
+            List<WebSocketExtension.Parameter> parameters = new ArrayList<>();
+            for(Extension.Parameter p : i.getParameters()) {
+                parameters.add(new WebSocketExtension.Parameter(p.getName(), p.getValue()));
+            }
+            ret.add(new WebSocketExtension(i.getName(), parameters));
+        }
+
+        return ret;
+    }
 }",2014-10-28T02:17:58Z,33
"@@ -85,7 +85,7 @@ public void handleEvent(SpdyChannel channel) {
     }
 
     @Override
-    public void sendRequest(ClientRequest request, ClientCallback<ClientExchange> clientCallback) {
+    public synchronized void sendRequest(ClientRequest request, ClientCallback<ClientExchange> clientCallback) {
         request.getRequestHeaders().put(PATH, request.getPath());
         request.getRequestHeaders().put(SCHEME, ""https"");
         request.getRequestHeaders().put(VERSION, request.getProtocol().toString());",2016-09-14T13:02:23Z,406
"@@ -100,6 +100,7 @@
         <version.org.mortbay.jetty.alpn.jdk8.71>8.1.7.v20160121</version.org.mortbay.jetty.alpn.jdk8.71>
         <version.org.mortbay.jetty.alpn.jdk8.92>8.1.8.v20160420</version.org.mortbay.jetty.alpn.jdk8.92>
         <version.org.mortbay.jetty.alpn.jdk8.101>8.1.9.v20160720</version.org.mortbay.jetty.alpn.jdk8.101>
+        <version.org.mortbay.jetty.alpn.jdk8.121>8.1.10.v20161026</version.org.mortbay.jetty.alpn.jdk8.121>
         <version.org.mortbay.jetty.alpn>${version.org.mortbay.jetty.alpn.jdk7}</version.org.mortbay.jetty.alpn>
         <version.org.eclipse.jetty.alpn>1.0.0</version.org.eclipse.jetty.alpn>
         <alpn-boot-string></alpn-boot-string>
@@ -753,6 +754,23 @@
                 </dependency>
             </dependencies>
         </profile>
+        <profile>
+            <id>jdk8.121</id>
+            <activation>
+                <jdk>1.8.0_121</jdk>
+            </activation>
+            <properties>
+                <version.org.mortbay.jetty.alpn>${version.org.mortbay.jetty.alpn.jdk8.121}</version.org.mortbay.jetty.alpn>
+                <alpn-boot-string>-Xbootclasspath/p:${org.mortbay.jetty.alpn:alpn-boot:jar}</alpn-boot-string>
+            </properties>
+            <dependencies>
+                <dependency>
+                    <groupId>org.mortbay.jetty.alpn</groupId>
+                    <artifactId>alpn-boot</artifactId>
+                    <scope>test</scope>
+                </dependency>
+            </dependencies>
+        </profile>
         <profile>
             <id>jdk7</id>
             <activation>",2017-01-20T03:34:22Z,265
"@@ -149,7 +149,7 @@ public interface UndertowMessages {
     RuntimeException tooManyQueryParameters(int noParams);
 
     @Message(id = 40, value = ""To many headers, cannot have more than %s header"")
-    RuntimeException tooManyHeaders(int noParams);
+    String tooManyHeaders(int noParams);
 
     @Message(id = 41, value = ""Channel is closed"")
     ClosedChannelException channelIsClosed();",2016-11-01T22:53:55Z,68
"@@ -77,6 +77,8 @@ public class UndertowOptions {
      */
     public static final Option<Integer> NO_REQUEST_TIMEOUT = Option.simple(UndertowOptions.class, ""NO_REQUEST_TIMEOUT"", Integer.class);
 
+    public static final int DEFAULT_MAX_PARAMETERS = 1000;
+
     /**
      * The maximum number of parameters that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>
@@ -87,6 +89,8 @@ public class UndertowOptions {
      */
     public static final Option<Integer> MAX_PARAMETERS = Option.simple(UndertowOptions.class, ""MAX_PARAMETERS"", Integer.class);
 
+    public static final int DEFAULT_MAX_HEADERS = 200;
+
     /**
      * The maximum number of headers that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>",2016-11-01T22:53:55Z,140
"@@ -128,7 +128,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
     private int sendMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;
     private int receiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;
     private int unackedReceiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE; //the old max frame size, this gets updated when our setting frame is acked
-    private int maxHeaderListSize = -1;
+    private final int maxHeaders;
 
     /**
      * How much data we have told the remote endpoint we are prepared to accept.
@@ -178,6 +178,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
 
         this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;
+        this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);
 
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
         receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);
@@ -746,6 +747,10 @@ HpackDecoder getDecoder() {
         return decoder;
     }
 
+    int getMaxHeaders() {
+        return maxHeaders;
+    }
+
     @Override
     public <T> T getAttachment(AttachmentKey<T> key) {
         if (key == null) {",2016-11-01T22:53:55Z,166
"@@ -79,7 +79,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     if (streamId == 0) {
                         throw new ConnectionErrorException(Http2Channel.ERROR_PROTOCOL_ERROR, UndertowMessages.MESSAGES.streamIdMustNotBeZeroForFrameType(Http2Channel.FRAME_TYPE_HEADERS));
                     }
-                    parser = new Http2HeadersParser(length, http2Channel.getDecoder());
+                    parser = new Http2HeadersParser(length, http2Channel.getDecoder(), http2Channel.getMaxHeaders());
                     if(allAreClear(flags, Http2Channel.HEADERS_FLAG_END_HEADERS)) {
                         continuationParser = (Http2HeadersParser) parser;
                     }
@@ -99,7 +99,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     break;
                 }
                 case FRAME_TYPE_PUSH_PROMISE: {
-                    parser = new Http2PushPromiseParser(length, http2Channel.getDecoder());
+                    parser = new Http2PushPromiseParser(length, http2Channel.getDecoder(), http2Channel.getMaxHeaders());
                     if(allAreClear(flags, Http2Channel.HEADERS_FLAG_END_HEADERS)) {
                         continuationParser = (Http2HeadersParser) parser;
                     }",2016-11-01T22:53:55Z,167
"@@ -24,6 +24,7 @@
 import io.undertow.UndertowLogger;
 import org.xnio.Bits;
 
+import io.undertow.UndertowMessages;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.HttpString;
 
@@ -40,14 +41,19 @@ abstract class Http2HeaderBlockParser extends Http2PushBackParser implements Hpa
     private final HpackDecoder decoder;
     private int frameRemaining = -1;
     private boolean invalid = false;
+    private final int maxHeaders;
 
-    Http2HeaderBlockParser(int frameLength, HpackDecoder decoder) {
+    Http2HeaderBlockParser(int frameLength, HpackDecoder decoder, int maxHeaders) {
         super(frameLength);
         this.decoder = decoder;
+        this.maxHeaders = maxHeaders;
     }
 
     @Override
     protected void handleData(ByteBuffer resource, Http2FrameHeaderParser header) throws IOException {
+        if(maxHeaders > 0 && headerMap.size() >= maxHeaders) {
+            throw new IOException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
+        }
         boolean continuationFramesComing = Bits.anyAreClear(header.flags, Http2Channel.HEADERS_FLAG_END_HEADERS);
         if (frameRemaining == -1) {
             frameRemaining = header.length;",2016-11-01T22:53:55Z,407
"@@ -35,8 +35,8 @@ class Http2HeadersParser extends Http2HeaderBlockParser {
     private boolean headersEndStream = false;
     private boolean exclusive;
 
-    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder,int maxHeaders) {
+        super(frameLength, hpackDecoder, maxHeaders);
     }
 
     @Override",2016-11-01T22:53:55Z,408
"@@ -33,8 +33,8 @@ class Http2PushPromiseParser extends Http2HeaderBlockParser {
     private int promisedStreamId;
     private static final int STREAM_MASK = ~(1 << 7);
 
-    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder, int maxHeaders) {
+        super(frameLength, hpackDecoder, maxHeaders);
     }
 
     @Override",2016-11-01T22:53:55Z,409
"@@ -19,6 +19,7 @@
 package io.undertow.server;
 
 import io.undertow.UndertowLogger;
+import io.undertow.UndertowOptions;
 import io.undertow.server.handlers.Cookie;
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
@@ -235,15 +236,25 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
         }
     }
 
-
     /**
      * Sets the request path and query parameters, decoding to the requested charset.
      *
      * @param exchange    The exchange
      * @param encodedPath        The encoded path
      * @param charset     The charset
      */
+    @Deprecated
     public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer) {
+        setExchangeRequestPath(exchange, encodedPath, charset, decode, allowEncodedSlash, decodeBuffer, exchange.getConnection().getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS));
+    }
+        /**
+         * Sets the request path and query parameters, decoding to the requested charset.
+         *
+         * @param exchange    The exchange
+         * @param encodedPath        The encoded path
+         * @param charset     The charset
+         */
+    public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer, int maxParameters) {
         boolean requiresDecode = false;
         for (int i = 0; i < encodedPath.length(); ++i) {
             char c = encodedPath.charAt(i);
@@ -260,7 +271,7 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                 exchange.setRequestURI(encodedPart);
                 final String qs = encodedPath.substring(i + 1);
                 exchange.setQueryString(qs);
-                URLUtils.parseQueryString(qs, exchange, charset, decode);
+                URLUtils.parseQueryString(qs, exchange, charset, decode, maxParameters);
                 return;
             } else if(c == ';') {
                 String part;
@@ -276,15 +287,15 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                     if (encodedPath.charAt(j) == '?') {
                         exchange.setRequestURI(encodedPath.substring(0, j));
                         String pathParams = encodedPath.substring(i + 1, j);
-                        URLUtils.parsePathParms(pathParams, exchange, charset, decode);
+                        URLUtils.parsePathParms(pathParams, exchange, charset, decode, maxParameters);
                         String qs = encodedPath.substring(j + 1);
                         exchange.setQueryString(qs);
-                        URLUtils.parseQueryString(qs, exchange, charset, decode);
+                        URLUtils.parseQueryString(qs, exchange, charset, decode, maxParameters);
                         return;
                     }
                 }
                 exchange.setRequestURI(encodedPath);
-                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode);
+                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
                 return;
             } else if(c == '%' || c == '+') {
                 requiresDecode = true;",2016-11-01T22:53:55Z,163
"@@ -82,7 +82,7 @@ public AjpOpenListener(final ByteBufferPool pool, final OptionMap undertowOption
         PooledByteBuffer buf = pool.allocate();
         this.bufferSize = buf.getBuffer().remaining();
         buf.close();
-        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true));
+        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true), undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS), undertowOptions.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS));
         connectorStatistics = new ConnectorStatisticsImpl();
         statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
@@ -153,7 +153,7 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
         }
         this.undertowOptions = undertowOptions;
         statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
-        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true));
+        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true), undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS), undertowOptions.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS));
     }
 
     @Override",2016-11-01T22:53:55Z,83
"@@ -67,6 +67,8 @@ public class AjpRequestParser {
 
     private final String encoding;
     private final boolean doDecode;
+    private final int maxParameters;
+    private final int maxHeaders;
 
     private static final HttpString[] HTTP_HEADERS;
 
@@ -169,13 +171,15 @@ public class AjpRequestParser {
         ATTRIBUTES[13] = STORED_METHOD;
     }
 
-    public AjpRequestParser(String encoding, boolean doDecode) {
+    public AjpRequestParser(String encoding, boolean doDecode, int maxParameters, int maxHeaders) {
         this.encoding = encoding;
         this.doDecode = doDecode;
+        this.maxParameters = maxParameters;
+        this.maxHeaders = maxHeaders;
     }
 
 
-    public void parse(final ByteBuffer buf, final AjpRequestParseState state, final HttpServerExchange exchange) throws IOException {
+    public void parse(final ByteBuffer buf, final AjpRequestParseState state, final HttpServerExchange exchange) throws IOException, BadRequestException {
         if (!buf.hasRemaining()) {
             return;
         }
@@ -250,7 +254,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                         exchange.setRequestURI(result.value);
                         exchange.setRequestPath(res);
                         exchange.setRelativePath(res);
-                        URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters);
+                        URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters, maxParameters);
                     }
                 } else {
                     state.state = AjpRequestParseState.READING_REQUEST_URI;
@@ -313,6 +317,9 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     return;
                 } else {
                     state.numHeaders = result.value;
+                    if(state.numHeaders > maxHeaders) {
+                        throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(state.numHeaders));
+                    }
                 }
             }
             case AjpRequestParseState.READING_HEADERS: {
@@ -392,8 +399,9 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     }
                     //query string.
                     if (state.currentAttribute.equals(QUERY_STRING)) {
-                        exchange.setQueryString(result == null ? """" : result);
-                        URLUtils.parseQueryString(result, exchange, encoding, doDecode);
+                        String resultAsQueryString = result == null ? """" : result;
+                        exchange.setQueryString(resultAsQueryString);
+                        URLUtils.parseQueryString(resultAsQueryString, exchange, encoding, doDecode, maxParameters);
                     } else if (state.currentAttribute.equals(REMOTE_USER)) {
                         exchange.putAttachment(ExternalAuthenticationMechanism.EXTERNAL_PRINCIPAL, result);
                     } else if (state.currentAttribute.equals(AUTH_TYPE)) {
@@ -554,6 +562,11 @@ enum StringType {
         URL,
         QUERY_STRING,
         OTHER
+    }
 
+    public static class BadRequestException extends Exception {
+        public BadRequestException(String msg) {
+            super(msg);
+        }
     }
 }",2016-11-01T22:53:55Z,54
"@@ -175,8 +175,8 @@ public abstract class HttpRequestParser {
     }
 
     public HttpRequestParser(OptionMap options) {
-        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, 1000);
-        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, 200);
+        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
+        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS);
         allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         decode = options.get(UndertowOptions.DECODE_URL, true);
         charset = options.get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name());
@@ -194,7 +194,7 @@ public static final HttpRequestParser instance(final OptionMap options) {
     }
 
 
-    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) {
+    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) throws BadRequestException {
         if (currentState.state == ParseState.VERB) {
             //fast path, we assume that it will parse fully so we avoid all the if statements
 
@@ -261,7 +261,7 @@ public void handle(ByteBuffer buffer, final ParseState currentState, final HttpS
         handleStateful(buffer, currentState, builder);
     }
 
-    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) {
+    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) throws BadRequestException {
         if (currentState.state == ParseState.PATH) {
             handlePath(buffer, currentState, builder);
             if (!buffer.hasRemaining()) {
@@ -641,7 +641,7 @@ final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerE
      * @return The number of bytes remaining
      */
     @SuppressWarnings(""unused"")
-    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
+    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
         HttpString headerName = state.nextHeader;
         StringBuilder stringBuilder = state.stringBuilder;
         HashMap<HttpString, String> headerValuesCache = state.headerValuesCache;
@@ -657,7 +657,7 @@ final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExch
         handleHeaderValueCacheMiss(buffer, state, builder, headerName, headerValuesCache, stringBuilder);
     }
 
-    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) {
+    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) throws BadRequestException {
 
         int parseState = state.parseState;
         while (buffer.hasRemaining() && parseState == NORMAL) {
@@ -717,7 +717,7 @@ private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, Htt
 
 
                         if (state.mapCount++ > maxHeaders) {
-                            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
+                            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
                         }
                         //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
                         builder.getRequestHeaders().add(headerName, headerValue);
@@ -754,7 +754,7 @@ private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, Htt
         state.parseState = parseState;
     }
 
-    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
+    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
         int pos = buffer.position();
         while (pos < buffer.limit() && buffer.get(pos) == ' ') {
             pos++;
@@ -783,7 +783,7 @@ protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseSt
         }
         buffer.position(pos + i);
         if (state.mapCount++ > maxHeaders) {
-            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
+            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
         }
         //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
         builder.getRequestHeaders().add(state.nextHeader, existing);
@@ -854,4 +854,10 @@ protected static Map<String, HttpString> httpStrings() {
 
     }
 
+    public static class BadRequestException extends Exception {
+        public BadRequestException(String msg) {
+            super(msg);
+        }
+    }
+
 }",2016-11-01T22:53:55Z,77
"@@ -68,6 +68,7 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
     private final StringBuilder decodeBuffer = new StringBuilder();
     private final boolean allowEncodingSlash;
     private final int bufferSize;
+    private final int maxParameters;
 
 
 
@@ -89,6 +90,7 @@ public Http2ReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions,
         this.maxEntitySize = undertowOptions.get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.allowEncodingSlash = undertowOptions.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         this.decode = undertowOptions.get(UndertowOptions.DECODE_URL, true);
+        this.maxParameters = undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
         if (undertowOptions.get(UndertowOptions.DECODE_URL, true)) {
             this.encoding = undertowOptions.get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name());
         } else {
@@ -144,7 +146,7 @@ private void handleRequests(Http2Channel channel, Http2StreamSourceChannel frame
         exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(AUTHORITY));
 
         final String path = exchange.getRequestHeaders().getFirst(PATH);
-        Connectors.setExchangeRequestPath(exchange, path, encoding, decode, allowEncodingSlash, decodeBuffer);
+        Connectors.setExchangeRequestPath(exchange, path, encoding, decode, allowEncodingSlash, decodeBuffer, maxParameters);
         SSLSession session = channel.getSslSession();
         if(session != null) {
             connection.setSslSessionInfo(new Http2SslSessionInfo(channel));
@@ -202,7 +204,7 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel) {
         exchange.setRequestMethod(initial.getRequestMethod());
         exchange.setQueryString(initial.getQueryString());
         String uri = exchange.getQueryString().isEmpty() ? initial.getRequestURI() : initial.getRequestURI() + '?' + exchange.getQueryString();
-        Connectors.setExchangeRequestPath(exchange, uri, encoding, decode, allowEncodingSlash, decodeBuffer);
+        Connectors.setExchangeRequestPath(exchange, uri, encoding, decode, allowEncodingSlash, decodeBuffer, maxParameters);
 
         SSLSession session = channel.getSslSession();
         if(session != null) {",2016-11-01T22:53:55Z,164
"@@ -397,7 +397,7 @@ public boolean pushResource(String path, HttpString method, HeaderMap requestHea
             exchange.setRequestMethod(method);
             exchange.setProtocol(Protocols.HTTP_1_1);
             exchange.setRequestScheme(this.exchange.getRequestScheme());
-            Connectors.setExchangeRequestPath(exchange, path, getUndertowOptions().get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name()), getUndertowOptions().get(UndertowOptions.DECODE_URL, true), getUndertowOptions().get(UndertowOptions.ALLOW_ENCODED_SLASH, false), new StringBuilder());
+            Connectors.setExchangeRequestPath(exchange, path, getUndertowOptions().get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name()), getUndertowOptions().get(UndertowOptions.DECODE_URL, true), getUndertowOptions().get(UndertowOptions.ALLOW_ENCODED_SLASH, false), new StringBuilder(), getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_HEADERS));
 
             Connectors.terminateRequest(exchange);
             getIoThread().execute(new Runnable() {",2016-11-01T22:53:55Z,376
"@@ -49,12 +49,12 @@ private URLUtils() {
 
     }
 
-    public static void parseQueryString(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
-        QUERY_STRING_PARSER.parse(string, exchange, charset, doDecode);
+    public static void parseQueryString(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) {
+        QUERY_STRING_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 
-    public static void parsePathParms(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
-        PATH_PARAM_PARSER.parse(string, exchange, charset, doDecode);
+    public static void parsePathParms(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) {
+        PATH_PARAM_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 
     /**
@@ -206,7 +206,8 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
 
     private abstract static class QueryStringParser {
 
-        void parse(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
+        void parse(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int max) {
+            int count = 0;
             try {
                 int stringStart = 0;
                 String attrName = null;
@@ -218,17 +219,29 @@ void parse(final String string, final HttpServerExchange exchange, final String
                     } else if (c == '&') {
                         if (attrName != null) {
                             handle(exchange, decode(charset, attrName, doDecode), decode(charset, string.substring(stringStart, i), doDecode));
+                            if(++count > max) {
+                                throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                            }
                         } else {
                             handle(exchange, decode(charset, string.substring(stringStart, i), doDecode), """");
+                            if(++count > max) {
+                                throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                            }
                         }
                         stringStart = i + 1;
                         attrName = null;
                     }
                 }
                 if (attrName != null) {
                     handle(exchange, decode(charset, attrName, doDecode), decode(charset, string.substring(stringStart, string.length()), doDecode));
+                    if(++count > max) {
+                        throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                    }
                 } else if (string.length() != stringStart) {
                     handle(exchange, decode(charset, string.substring(stringStart, string.length()), doDecode), """");
+                    if(++count > max) {
+                        throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                    }
                 }
             } catch (UnsupportedEncodingException e) {
                 throw new RuntimeException(e);",2016-11-01T22:53:55Z,276
"@@ -23,13 +23,13 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
+import org.junit.Assert;
+import org.junit.Test;
+import org.xnio.IoUtils;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 import io.undertow.util.Protocols;
-import org.junit.Assert;
-import org.junit.Test;
-import org.xnio.IoUtils;
 
 /**
  * @author Stuart Douglas
@@ -55,11 +55,11 @@ public class AjpParsingUnitTestCase {
         }
     }
 
-    public static final AjpRequestParser AJP_REQUEST_PARSER = new AjpRequestParser(""UTF-8"", true);
+    public static final AjpRequestParser AJP_REQUEST_PARSER = new AjpRequestParser(""UTF-8"", true, 100, 100);
 
 
     @Test
-    public void testAjpParsing() throws IOException {
+    public void testAjpParsing() throws IOException, AjpRequestParser.BadRequestException {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
         HttpServerExchange result = new HttpServerExchange(null);
         final AjpRequestParseState state = new AjpRequestParseState();
@@ -72,7 +72,7 @@ public void testAjpParsing() throws IOException {
     }
 
     @Test
-    public void testByteByByteAjpParsing() throws IOException {
+    public void testByteByByteAjpParsing() throws IOException, AjpRequestParser.BadRequestException {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
 
         HttpServerExchange result = new HttpServerExchange(null);",2016-11-01T22:53:55Z,125
"@@ -53,7 +53,7 @@ public void testMethodSplit() {
     }
 
     @Test
-    public void testOneCharacterAtATime() {
+    public void testOneCharacterAtATime() throws HttpRequestParser.BadRequestException {
         context.reset();
         byte[] in = DATA.getBytes();
         HttpServerExchange result = new HttpServerExchange(null);
@@ -70,7 +70,7 @@ public void testOneCharacterAtATime() {
         runAssertions(result);
     }
 
-    private void testResume(final int split, byte[] in) {
+    private void testResume(final int split, byte[] in) throws HttpRequestParser.BadRequestException {
         context.reset();
         HttpServerExchange result = new HttpServerExchange(null);
         ByteBuffer buffer = ByteBuffer.wrap(in);",2016-11-01T22:53:55Z,30
"@@ -46,7 +46,7 @@ public class SimpleParserTestCase {
     private final ParseState parseState = new ParseState();
 
     @Test
-    public void testEncodedSlashDisallowed() {
+    public void testEncodedSlashDisallowed() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath%2FotherPath HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -58,7 +58,7 @@ public void testEncodedSlashDisallowed() {
     }
 
     @Test
-    public void testEncodedSlashAllowed() {
+    public void testEncodedSlashAllowed() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath%2fotherPath HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -70,7 +70,7 @@ public void testEncodedSlashAllowed() {
     }
 
     @Test
-    public void testColonSlashInURL() {
+    public void testColonSlashInURL() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -82,7 +82,7 @@ public void testColonSlashInURL() {
     }
 
     @Test
-    public void testColonSlashInFullURL() {
+    public void testColonSlashInFullURL() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET http://foo.com/a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -95,7 +95,7 @@ public void testColonSlashInFullURL() {
 
 
     @Test
-    public void testPathParameters() {
+    public void testPathParameters() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath;p1 HTTP/1.1\r\n\r\n"".getBytes();
         ParseState context = new ParseState();
         HttpServerExchange result = new HttpServerExchange(null);
@@ -119,7 +119,7 @@ public void testPathParameters() {
     }
 
     @Test
-    public void testFullUrlRootPath() {
+    public void testFullUrlRootPath() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET http://myurl.com HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -130,15 +130,15 @@ public void testFullUrlRootPath() {
         Assert.assertEquals(""http://myurl.com"", result.getRequestURI());
     }
     @Test
-    public void testSimpleRequest() {
+    public void testSimpleRequest() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\n\r\n"".getBytes();
         runTest(in);
     }
 
 
 
     @Test
-    public void testSimpleRequestWithHeaderCaching() {
+    public void testSimpleRequestWithHeaderCaching() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: foo\r\n\r\n"".getBytes();
         runTest(in, ""foo"");
         in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader:       foo\r\n\r\n"".getBytes();
@@ -151,26 +151,26 @@ public void testSimpleRequestWithHeaderCaching() {
 
 
     @Test
-    public void testCarriageReturnLineEnds() {
+    public void testCarriageReturnLineEnds() throws HttpRequestParser.BadRequestException {
 
         byte[] in = ""GET /somepath HTTP/1.1\rHost:   www.somehost.net\rOtherHeader: some\r    value\r\r\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testLineFeedsLineEnds() {
+    public void testLineFeedsLineEnds() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\nHost:   www.somehost.net\nOtherHeader: some\n    value\n\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testTabWhitespace() {
+    public void testTabWhitespace() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\t/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testCanonicalPath() {
+    public void testCanonicalPath() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -181,7 +181,7 @@ public void testCanonicalPath() {
     }
 
     @Test
-    public void testNoHeaders() {
+    public void testNoHeaders() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\t/aa\tHTTP/1.1\n\n\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -192,7 +192,7 @@ public void testNoHeaders() {
     }
 
     @Test
-    public void testQueryParams() {
+    public void testQueryParams() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath?a=b&b=c&d&e&f=\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -210,7 +210,7 @@ public void testQueryParams() {
     }
 
     @Test
-    public void testSameHttpStringReturned() {
+    public void testSameHttpStringReturned() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nAccept-Charset:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context1 = new ParseState();
@@ -241,7 +241,7 @@ public void testSameHttpStringReturned() {
 
 
     @Test
-    public void testEmptyQueryParams() {
+    public void testEmptyQueryParams() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /clusterbench/requestinfo//?;?=44&test=OK;devil=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&777=666 HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -256,7 +256,7 @@ public void testEmptyQueryParams() {
         Assert.assertEquals(""44"", result.getQueryParameters().get("";?"").getFirst());
     }
     @Test
-    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException {
+    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException, HttpRequestParser.BadRequestException {
         byte[] in = ""GET /bÃ¥r HTTP/1.1\r\n\r\n"".getBytes(""ISO-8859-1"");
 
         final ParseState context = new ParseState();
@@ -267,10 +267,10 @@ public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException
         Assert.assertEquals(""/bÃ¥r"", result.getRequestURI()); //not decoded
     }
 
-    private void runTest(final byte[] in) {
+    private void runTest(final byte[] in) throws HttpRequestParser.BadRequestException {
         runTest(in, ""some value"");
     }
-    private void runTest(final byte[] in, String lastHeader) {
+    private void runTest(final byte[] in, String lastHeader) throws HttpRequestParser.BadRequestException {
         parseState.reset();
         HttpServerExchange result = new HttpServerExchange(null);
         HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), parseState, result);",2016-11-01T22:53:55Z,91
"@@ -82,4 +82,8 @@ public interface UndertowLogger extends BasicLogger {
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5011, value = ""Ignoring AJP request with prefix %s"")
     void ignoringAjpRequestWithPrefixCode(byte prefix);
+
+    @LogMessage(level = Logger.Level.WARN)
+    @Message(id = 5012, value = ""Could not find boundary in multipart request with ContentType: %s, multipart data will not be available"")
+    void couldNotDetectBoundary(String mimeType);
 }",2013-04-26T01:43:28Z,65
"@@ -70,6 +70,11 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         String mimeType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
         if (mimeType != null && mimeType.startsWith(MULTIPART_FORM_DATA)) {
             String boundary = Headers.extractTokenFromHeader(mimeType, ""boundary"");
+            if(boundary == null) {
+                UndertowLogger.REQUEST_LOGGER.couldNotDetectBoundary(mimeType);
+                next.handleRequest(exchange);
+                return;
+            }
             final MultiPartUploadHandler multiPartUploadHandler = new MultiPartUploadHandler(exchange, boundary, defaultEncoding);
             exchange.putAttachment(FormDataParser.ATTACHMENT_KEY, multiPartUploadHandler);
         }",2013-04-26T01:43:28Z,119
"@@ -223,8 +223,8 @@ public interface UndertowMessages {
     @Message(id = 65, value = ""SSL must be specified to connect to a https URL"")
     IOException sslWasNull();
 
-    @Message(id = 66, value = ""Incorrect magic number for AJP packet header"")
-    IOException wrongMagicNumber();
+    @Message(id = 66, value = ""Incorrect magic number %s for AJP packet header"")
+    IOException wrongMagicNumber(int number);
 
     @Message(id = 67, value = ""No client cert was provided"")
     SSLPeerUnverifiedException peerUnverified();",2015-08-13T00:30:33Z,68
"@@ -186,7 +186,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     return;
                 } else {
                     if (result.value != 0x1234) {
-                        throw new IllegalStateException(""Wrong magic number"");
+                        throw UndertowMessages.MESSAGES.wrongMagicNumber(result.value);
                     }
                 }
             }",2015-08-13T00:30:33Z,54
"@@ -145,8 +145,7 @@ public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel t
 
     @Override
     public void terminateReads() throws IOException {
-        if(exchange.isPersistent()) {
-            state |= STATE_FINISHED;
+        if(exchange.isPersistent() && anyAreSet(state, STATE_FINISHED)) {
             return;
         }
         super.terminateReads();
@@ -233,7 +232,7 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
                 byte b1 = headerBuffer.get(); //0x12
                 byte b2 = headerBuffer.get(); //0x34
                 if (b1 != 0x12 || b2 != 0x34) {
-                    throw UndertowMessages.MESSAGES.wrongMagicNumber();
+                    throw UndertowMessages.MESSAGES.wrongMagicNumber(b1 << 8 | b2);
                 }
                 headerBuffer.get();//the length headers, two more than the string length header
                 headerBuffer.get();",2015-08-13T00:30:33Z,121
"@@ -149,7 +149,7 @@ public interface UndertowMessages {
     RuntimeException tooManyQueryParameters(int noParams);
 
     @Message(id = 40, value = ""To many headers, cannot have more than %s header"")
-    RuntimeException tooManyHeaders(int noParams);
+    String tooManyHeaders(int noParams);
 
     @Message(id = 41, value = ""Channel is closed"")
     ClosedChannelException channelIsClosed();",2016-11-01T22:53:55Z,68
"@@ -77,6 +77,8 @@ public class UndertowOptions {
      */
     public static final Option<Integer> NO_REQUEST_TIMEOUT = Option.simple(UndertowOptions.class, ""NO_REQUEST_TIMEOUT"", Integer.class);
 
+    public static final int DEFAULT_MAX_PARAMETERS = 1000;
+
     /**
      * The maximum number of parameters that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>
@@ -87,6 +89,8 @@ public class UndertowOptions {
      */
     public static final Option<Integer> MAX_PARAMETERS = Option.simple(UndertowOptions.class, ""MAX_PARAMETERS"", Integer.class);
 
+    public static final int DEFAULT_MAX_HEADERS = 200;
+
     /**
      * The maximum number of headers that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>",2016-11-01T22:53:55Z,140
"@@ -128,7 +128,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
     private int sendMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;
     private int receiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;
     private int unackedReceiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE; //the old max frame size, this gets updated when our setting frame is acked
-    private int maxHeaderListSize = -1;
+    private final int maxHeaders;
 
     /**
      * How much data we have told the remote endpoint we are prepared to accept.
@@ -178,6 +178,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
 
         this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;
+        this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);
 
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
         receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);
@@ -746,6 +747,10 @@ HpackDecoder getDecoder() {
         return decoder;
     }
 
+    int getMaxHeaders() {
+        return maxHeaders;
+    }
+
     @Override
     public <T> T getAttachment(AttachmentKey<T> key) {
         if (key == null) {",2016-11-01T22:53:55Z,166
"@@ -79,7 +79,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     if (streamId == 0) {
                         throw new ConnectionErrorException(Http2Channel.ERROR_PROTOCOL_ERROR, UndertowMessages.MESSAGES.streamIdMustNotBeZeroForFrameType(Http2Channel.FRAME_TYPE_HEADERS));
                     }
-                    parser = new Http2HeadersParser(length, http2Channel.getDecoder());
+                    parser = new Http2HeadersParser(length, http2Channel.getDecoder(), http2Channel.getMaxHeaders());
                     if(allAreClear(flags, Http2Channel.HEADERS_FLAG_END_HEADERS)) {
                         continuationParser = (Http2HeadersParser) parser;
                     }
@@ -99,7 +99,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     break;
                 }
                 case FRAME_TYPE_PUSH_PROMISE: {
-                    parser = new Http2PushPromiseParser(length, http2Channel.getDecoder());
+                    parser = new Http2PushPromiseParser(length, http2Channel.getDecoder(), http2Channel.getMaxHeaders());
                     if(allAreClear(flags, Http2Channel.HEADERS_FLAG_END_HEADERS)) {
                         continuationParser = (Http2HeadersParser) parser;
                     }",2016-11-01T22:53:55Z,167
"@@ -24,6 +24,7 @@
 import io.undertow.UndertowLogger;
 import org.xnio.Bits;
 
+import io.undertow.UndertowMessages;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.HttpString;
 
@@ -40,14 +41,19 @@ abstract class Http2HeaderBlockParser extends Http2PushBackParser implements Hpa
     private final HpackDecoder decoder;
     private int frameRemaining = -1;
     private boolean invalid = false;
+    private final int maxHeaders;
 
-    Http2HeaderBlockParser(int frameLength, HpackDecoder decoder) {
+    Http2HeaderBlockParser(int frameLength, HpackDecoder decoder, int maxHeaders) {
         super(frameLength);
         this.decoder = decoder;
+        this.maxHeaders = maxHeaders;
     }
 
     @Override
     protected void handleData(ByteBuffer resource, Http2FrameHeaderParser header) throws IOException {
+        if(maxHeaders > 0 && headerMap.size() >= maxHeaders) {
+            throw new IOException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
+        }
         boolean continuationFramesComing = Bits.anyAreClear(header.flags, Http2Channel.HEADERS_FLAG_END_HEADERS);
         if (frameRemaining == -1) {
             frameRemaining = header.length;",2016-11-01T22:53:55Z,407
"@@ -35,8 +35,8 @@ class Http2HeadersParser extends Http2HeaderBlockParser {
     private boolean headersEndStream = false;
     private boolean exclusive;
 
-    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder,int maxHeaders) {
+        super(frameLength, hpackDecoder, maxHeaders);
     }
 
     @Override",2016-11-01T22:53:55Z,408
"@@ -33,8 +33,8 @@ class Http2PushPromiseParser extends Http2HeaderBlockParser {
     private int promisedStreamId;
     private static final int STREAM_MASK = ~(1 << 7);
 
-    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder, int maxHeaders) {
+        super(frameLength, hpackDecoder, maxHeaders);
     }
 
     @Override",2016-11-01T22:53:55Z,409
"@@ -19,6 +19,7 @@
 package io.undertow.server;
 
 import io.undertow.UndertowLogger;
+import io.undertow.UndertowOptions;
 import io.undertow.server.handlers.Cookie;
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
@@ -235,15 +236,25 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
         }
     }
 
-
     /**
      * Sets the request path and query parameters, decoding to the requested charset.
      *
      * @param exchange    The exchange
      * @param encodedPath        The encoded path
      * @param charset     The charset
      */
+    @Deprecated
     public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer) {
+        setExchangeRequestPath(exchange, encodedPath, charset, decode, allowEncodedSlash, decodeBuffer, exchange.getConnection().getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS));
+    }
+        /**
+         * Sets the request path and query parameters, decoding to the requested charset.
+         *
+         * @param exchange    The exchange
+         * @param encodedPath        The encoded path
+         * @param charset     The charset
+         */
+    public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer, int maxParameters) {
         boolean requiresDecode = false;
         for (int i = 0; i < encodedPath.length(); ++i) {
             char c = encodedPath.charAt(i);
@@ -260,7 +271,7 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                 exchange.setRequestURI(encodedPart);
                 final String qs = encodedPath.substring(i + 1);
                 exchange.setQueryString(qs);
-                URLUtils.parseQueryString(qs, exchange, charset, decode);
+                URLUtils.parseQueryString(qs, exchange, charset, decode, maxParameters);
                 return;
             } else if(c == ';') {
                 String part;
@@ -276,15 +287,15 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                     if (encodedPath.charAt(j) == '?') {
                         exchange.setRequestURI(encodedPath.substring(0, j));
                         String pathParams = encodedPath.substring(i + 1, j);
-                        URLUtils.parsePathParms(pathParams, exchange, charset, decode);
+                        URLUtils.parsePathParms(pathParams, exchange, charset, decode, maxParameters);
                         String qs = encodedPath.substring(j + 1);
                         exchange.setQueryString(qs);
-                        URLUtils.parseQueryString(qs, exchange, charset, decode);
+                        URLUtils.parseQueryString(qs, exchange, charset, decode, maxParameters);
                         return;
                     }
                 }
                 exchange.setRequestURI(encodedPath);
-                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode);
+                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
                 return;
             } else if(c == '%' || c == '+') {
                 requiresDecode = true;",2016-11-01T22:53:55Z,163
"@@ -82,7 +82,7 @@ public AjpOpenListener(final ByteBufferPool pool, final OptionMap undertowOption
         PooledByteBuffer buf = pool.allocate();
         this.bufferSize = buf.getBuffer().remaining();
         buf.close();
-        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true));
+        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true), undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS), undertowOptions.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS));
         connectorStatistics = new ConnectorStatisticsImpl();
         statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
@@ -153,7 +153,7 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
         }
         this.undertowOptions = undertowOptions;
         statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
-        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true));
+        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true), undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS), undertowOptions.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS));
     }
 
     @Override",2016-11-01T22:53:55Z,83
"@@ -67,6 +67,8 @@ public class AjpRequestParser {
 
     private final String encoding;
     private final boolean doDecode;
+    private final int maxParameters;
+    private final int maxHeaders;
 
     private static final HttpString[] HTTP_HEADERS;
 
@@ -169,13 +171,15 @@ public class AjpRequestParser {
         ATTRIBUTES[13] = STORED_METHOD;
     }
 
-    public AjpRequestParser(String encoding, boolean doDecode) {
+    public AjpRequestParser(String encoding, boolean doDecode, int maxParameters, int maxHeaders) {
         this.encoding = encoding;
         this.doDecode = doDecode;
+        this.maxParameters = maxParameters;
+        this.maxHeaders = maxHeaders;
     }
 
 
-    public void parse(final ByteBuffer buf, final AjpRequestParseState state, final HttpServerExchange exchange) throws IOException {
+    public void parse(final ByteBuffer buf, final AjpRequestParseState state, final HttpServerExchange exchange) throws IOException, BadRequestException {
         if (!buf.hasRemaining()) {
             return;
         }
@@ -250,7 +254,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                         exchange.setRequestURI(result.value);
                         exchange.setRequestPath(res);
                         exchange.setRelativePath(res);
-                        URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters);
+                        URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters, maxParameters);
                     }
                 } else {
                     state.state = AjpRequestParseState.READING_REQUEST_URI;
@@ -313,6 +317,9 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     return;
                 } else {
                     state.numHeaders = result.value;
+                    if(state.numHeaders > maxHeaders) {
+                        throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(state.numHeaders));
+                    }
                 }
             }
             case AjpRequestParseState.READING_HEADERS: {
@@ -392,8 +399,9 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     }
                     //query string.
                     if (state.currentAttribute.equals(QUERY_STRING)) {
-                        exchange.setQueryString(result == null ? """" : result);
-                        URLUtils.parseQueryString(result, exchange, encoding, doDecode);
+                        String resultAsQueryString = result == null ? """" : result;
+                        exchange.setQueryString(resultAsQueryString);
+                        URLUtils.parseQueryString(resultAsQueryString, exchange, encoding, doDecode, maxParameters);
                     } else if (state.currentAttribute.equals(REMOTE_USER)) {
                         exchange.putAttachment(ExternalAuthenticationMechanism.EXTERNAL_PRINCIPAL, result);
                     } else if (state.currentAttribute.equals(AUTH_TYPE)) {
@@ -554,6 +562,11 @@ enum StringType {
         URL,
         QUERY_STRING,
         OTHER
+    }
 
+    public static class BadRequestException extends Exception {
+        public BadRequestException(String msg) {
+            super(msg);
+        }
     }
 }",2016-11-01T22:53:55Z,54
"@@ -175,8 +175,8 @@ public abstract class HttpRequestParser {
     }
 
     public HttpRequestParser(OptionMap options) {
-        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, 1000);
-        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, 200);
+        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
+        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS);
         allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         decode = options.get(UndertowOptions.DECODE_URL, true);
         charset = options.get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name());
@@ -194,7 +194,7 @@ public static final HttpRequestParser instance(final OptionMap options) {
     }
 
 
-    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) {
+    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) throws BadRequestException {
         if (currentState.state == ParseState.VERB) {
             //fast path, we assume that it will parse fully so we avoid all the if statements
 
@@ -261,7 +261,7 @@ public void handle(ByteBuffer buffer, final ParseState currentState, final HttpS
         handleStateful(buffer, currentState, builder);
     }
 
-    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) {
+    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) throws BadRequestException {
         if (currentState.state == ParseState.PATH) {
             handlePath(buffer, currentState, builder);
             if (!buffer.hasRemaining()) {
@@ -641,7 +641,7 @@ final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerE
      * @return The number of bytes remaining
      */
     @SuppressWarnings(""unused"")
-    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
+    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
         HttpString headerName = state.nextHeader;
         StringBuilder stringBuilder = state.stringBuilder;
         HashMap<HttpString, String> headerValuesCache = state.headerValuesCache;
@@ -657,7 +657,7 @@ final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExch
         handleHeaderValueCacheMiss(buffer, state, builder, headerName, headerValuesCache, stringBuilder);
     }
 
-    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) {
+    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) throws BadRequestException {
 
         int parseState = state.parseState;
         while (buffer.hasRemaining() && parseState == NORMAL) {
@@ -717,7 +717,7 @@ private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, Htt
 
 
                         if (state.mapCount++ > maxHeaders) {
-                            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
+                            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
                         }
                         //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
                         builder.getRequestHeaders().add(headerName, headerValue);
@@ -754,7 +754,7 @@ private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, Htt
         state.parseState = parseState;
     }
 
-    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
+    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
         int pos = buffer.position();
         while (pos < buffer.limit() && buffer.get(pos) == ' ') {
             pos++;
@@ -783,7 +783,7 @@ protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseSt
         }
         buffer.position(pos + i);
         if (state.mapCount++ > maxHeaders) {
-            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
+            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
         }
         //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
         builder.getRequestHeaders().add(state.nextHeader, existing);
@@ -854,4 +854,10 @@ protected static Map<String, HttpString> httpStrings() {
 
     }
 
+    public static class BadRequestException extends Exception {
+        public BadRequestException(String msg) {
+            super(msg);
+        }
+    }
+
 }",2016-11-01T22:53:55Z,77
"@@ -68,6 +68,7 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
     private final StringBuilder decodeBuffer = new StringBuilder();
     private final boolean allowEncodingSlash;
     private final int bufferSize;
+    private final int maxParameters;
 
 
 
@@ -89,6 +90,7 @@ public Http2ReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions,
         this.maxEntitySize = undertowOptions.get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.allowEncodingSlash = undertowOptions.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         this.decode = undertowOptions.get(UndertowOptions.DECODE_URL, true);
+        this.maxParameters = undertowOptions.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
         if (undertowOptions.get(UndertowOptions.DECODE_URL, true)) {
             this.encoding = undertowOptions.get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name());
         } else {
@@ -144,7 +146,7 @@ private void handleRequests(Http2Channel channel, Http2StreamSourceChannel frame
         exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(AUTHORITY));
 
         final String path = exchange.getRequestHeaders().getFirst(PATH);
-        Connectors.setExchangeRequestPath(exchange, path, encoding, decode, allowEncodingSlash, decodeBuffer);
+        Connectors.setExchangeRequestPath(exchange, path, encoding, decode, allowEncodingSlash, decodeBuffer, maxParameters);
         SSLSession session = channel.getSslSession();
         if(session != null) {
             connection.setSslSessionInfo(new Http2SslSessionInfo(channel));
@@ -202,7 +204,7 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel) {
         exchange.setRequestMethod(initial.getRequestMethod());
         exchange.setQueryString(initial.getQueryString());
         String uri = exchange.getQueryString().isEmpty() ? initial.getRequestURI() : initial.getRequestURI() + '?' + exchange.getQueryString();
-        Connectors.setExchangeRequestPath(exchange, uri, encoding, decode, allowEncodingSlash, decodeBuffer);
+        Connectors.setExchangeRequestPath(exchange, uri, encoding, decode, allowEncodingSlash, decodeBuffer, maxParameters);
 
         SSLSession session = channel.getSslSession();
         if(session != null) {",2016-11-01T22:53:55Z,164
"@@ -397,7 +397,7 @@ public boolean pushResource(String path, HttpString method, HeaderMap requestHea
             exchange.setRequestMethod(method);
             exchange.setProtocol(Protocols.HTTP_1_1);
             exchange.setRequestScheme(this.exchange.getRequestScheme());
-            Connectors.setExchangeRequestPath(exchange, path, getUndertowOptions().get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name()), getUndertowOptions().get(UndertowOptions.DECODE_URL, true), getUndertowOptions().get(UndertowOptions.ALLOW_ENCODED_SLASH, false), new StringBuilder());
+            Connectors.setExchangeRequestPath(exchange, path, getUndertowOptions().get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name()), getUndertowOptions().get(UndertowOptions.DECODE_URL, true), getUndertowOptions().get(UndertowOptions.ALLOW_ENCODED_SLASH, false), new StringBuilder(), getUndertowOptions().get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_HEADERS));
 
             Connectors.terminateRequest(exchange);
             getIoThread().execute(new Runnable() {",2016-11-01T22:53:55Z,376
"@@ -49,12 +49,12 @@ private URLUtils() {
 
     }
 
-    public static void parseQueryString(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
-        QUERY_STRING_PARSER.parse(string, exchange, charset, doDecode);
+    public static void parseQueryString(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) {
+        QUERY_STRING_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 
-    public static void parsePathParms(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
-        PATH_PARAM_PARSER.parse(string, exchange, charset, doDecode);
+    public static void parsePathParms(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int maxParameters) {
+        PATH_PARAM_PARSER.parse(string, exchange, charset, doDecode, maxParameters);
     }
 
     /**
@@ -206,7 +206,8 @@ public static String decode(String s, String enc, boolean decodeSlash, StringBui
 
     private abstract static class QueryStringParser {
 
-        void parse(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode) {
+        void parse(final String string, final HttpServerExchange exchange, final String charset, final boolean doDecode, int max) {
+            int count = 0;
             try {
                 int stringStart = 0;
                 String attrName = null;
@@ -218,17 +219,29 @@ void parse(final String string, final HttpServerExchange exchange, final String
                     } else if (c == '&') {
                         if (attrName != null) {
                             handle(exchange, decode(charset, attrName, doDecode), decode(charset, string.substring(stringStart, i), doDecode));
+                            if(++count > max) {
+                                throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                            }
                         } else {
                             handle(exchange, decode(charset, string.substring(stringStart, i), doDecode), """");
+                            if(++count > max) {
+                                throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                            }
                         }
                         stringStart = i + 1;
                         attrName = null;
                     }
                 }
                 if (attrName != null) {
                     handle(exchange, decode(charset, attrName, doDecode), decode(charset, string.substring(stringStart, string.length()), doDecode));
+                    if(++count > max) {
+                        throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                    }
                 } else if (string.length() != stringStart) {
                     handle(exchange, decode(charset, string.substring(stringStart, string.length()), doDecode), """");
+                    if(++count > max) {
+                        throw new RuntimeException(UndertowMessages.MESSAGES.tooManyParameters(max));
+                    }
                 }
             } catch (UnsupportedEncodingException e) {
                 throw new RuntimeException(e);",2016-11-01T22:53:55Z,276
"@@ -23,13 +23,13 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
+import org.junit.Assert;
+import org.junit.Test;
+import org.xnio.IoUtils;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 import io.undertow.util.Protocols;
-import org.junit.Assert;
-import org.junit.Test;
-import org.xnio.IoUtils;
 
 /**
  * @author Stuart Douglas
@@ -55,11 +55,11 @@ public class AjpParsingUnitTestCase {
         }
     }
 
-    public static final AjpRequestParser AJP_REQUEST_PARSER = new AjpRequestParser(""UTF-8"", true);
+    public static final AjpRequestParser AJP_REQUEST_PARSER = new AjpRequestParser(""UTF-8"", true, 100, 100);
 
 
     @Test
-    public void testAjpParsing() throws IOException {
+    public void testAjpParsing() throws IOException, AjpRequestParser.BadRequestException {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
         HttpServerExchange result = new HttpServerExchange(null);
         final AjpRequestParseState state = new AjpRequestParseState();
@@ -72,7 +72,7 @@ public void testAjpParsing() throws IOException {
     }
 
     @Test
-    public void testByteByByteAjpParsing() throws IOException {
+    public void testByteByByteAjpParsing() throws IOException, AjpRequestParser.BadRequestException {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
 
         HttpServerExchange result = new HttpServerExchange(null);",2016-11-01T22:53:55Z,125
"@@ -53,7 +53,7 @@ public void testMethodSplit() {
     }
 
     @Test
-    public void testOneCharacterAtATime() {
+    public void testOneCharacterAtATime() throws HttpRequestParser.BadRequestException {
         context.reset();
         byte[] in = DATA.getBytes();
         HttpServerExchange result = new HttpServerExchange(null);
@@ -70,7 +70,7 @@ public void testOneCharacterAtATime() {
         runAssertions(result);
     }
 
-    private void testResume(final int split, byte[] in) {
+    private void testResume(final int split, byte[] in) throws HttpRequestParser.BadRequestException {
         context.reset();
         HttpServerExchange result = new HttpServerExchange(null);
         ByteBuffer buffer = ByteBuffer.wrap(in);",2016-11-01T22:53:55Z,30
"@@ -46,7 +46,7 @@ public class SimpleParserTestCase {
     private final ParseState parseState = new ParseState();
 
     @Test
-    public void testEncodedSlashDisallowed() {
+    public void testEncodedSlashDisallowed() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath%2FotherPath HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -58,7 +58,7 @@ public void testEncodedSlashDisallowed() {
     }
 
     @Test
-    public void testEncodedSlashAllowed() {
+    public void testEncodedSlashAllowed() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath%2fotherPath HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -70,7 +70,7 @@ public void testEncodedSlashAllowed() {
     }
 
     @Test
-    public void testColonSlashInURL() {
+    public void testColonSlashInURL() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -82,7 +82,7 @@ public void testColonSlashInURL() {
     }
 
     @Test
-    public void testColonSlashInFullURL() {
+    public void testColonSlashInFullURL() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET http://foo.com/a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -95,7 +95,7 @@ public void testColonSlashInFullURL() {
 
 
     @Test
-    public void testPathParameters() {
+    public void testPathParameters() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath;p1 HTTP/1.1\r\n\r\n"".getBytes();
         ParseState context = new ParseState();
         HttpServerExchange result = new HttpServerExchange(null);
@@ -119,7 +119,7 @@ public void testPathParameters() {
     }
 
     @Test
-    public void testFullUrlRootPath() {
+    public void testFullUrlRootPath() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET http://myurl.com HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -130,15 +130,15 @@ public void testFullUrlRootPath() {
         Assert.assertEquals(""http://myurl.com"", result.getRequestURI());
     }
     @Test
-    public void testSimpleRequest() {
+    public void testSimpleRequest() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\n\r\n"".getBytes();
         runTest(in);
     }
 
 
 
     @Test
-    public void testSimpleRequestWithHeaderCaching() {
+    public void testSimpleRequestWithHeaderCaching() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: foo\r\n\r\n"".getBytes();
         runTest(in, ""foo"");
         in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader:       foo\r\n\r\n"".getBytes();
@@ -151,26 +151,26 @@ public void testSimpleRequestWithHeaderCaching() {
 
 
     @Test
-    public void testCarriageReturnLineEnds() {
+    public void testCarriageReturnLineEnds() throws HttpRequestParser.BadRequestException {
 
         byte[] in = ""GET /somepath HTTP/1.1\rHost:   www.somehost.net\rOtherHeader: some\r    value\r\r\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testLineFeedsLineEnds() {
+    public void testLineFeedsLineEnds() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /somepath HTTP/1.1\nHost:   www.somehost.net\nOtherHeader: some\n    value\n\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testTabWhitespace() {
+    public void testTabWhitespace() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\t/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
         runTest(in);
     }
 
     @Test
-    public void testCanonicalPath() {
+    public void testCanonicalPath() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -181,7 +181,7 @@ public void testCanonicalPath() {
     }
 
     @Test
-    public void testNoHeaders() {
+    public void testNoHeaders() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\t/aa\tHTTP/1.1\n\n\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -192,7 +192,7 @@ public void testNoHeaders() {
     }
 
     @Test
-    public void testQueryParams() {
+    public void testQueryParams() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath?a=b&b=c&d&e&f=\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -210,7 +210,7 @@ public void testQueryParams() {
     }
 
     @Test
-    public void testSameHttpStringReturned() {
+    public void testSameHttpStringReturned() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nAccept-Charset:\tsome\n \t  value\n\r\n"".getBytes();
 
         final ParseState context1 = new ParseState();
@@ -241,7 +241,7 @@ public void testSameHttpStringReturned() {
 
 
     @Test
-    public void testEmptyQueryParams() {
+    public void testEmptyQueryParams() throws HttpRequestParser.BadRequestException {
         byte[] in = ""GET /clusterbench/requestinfo//?;?=44&test=OK;devil=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&777=666 HTTP/1.1\r\n\r\n"".getBytes();
 
         final ParseState context = new ParseState();
@@ -256,7 +256,7 @@ public void testEmptyQueryParams() {
         Assert.assertEquals(""44"", result.getQueryParameters().get("";?"").getFirst());
     }
     @Test
-    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException {
+    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException, HttpRequestParser.BadRequestException {
         byte[] in = ""GET /bÃ¥r HTTP/1.1\r\n\r\n"".getBytes(""ISO-8859-1"");
 
         final ParseState context = new ParseState();
@@ -267,10 +267,10 @@ public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException
         Assert.assertEquals(""/bÃ¥r"", result.getRequestURI()); //not decoded
     }
 
-    private void runTest(final byte[] in) {
+    private void runTest(final byte[] in) throws HttpRequestParser.BadRequestException {
         runTest(in, ""some value"");
     }
-    private void runTest(final byte[] in, String lastHeader) {
+    private void runTest(final byte[] in, String lastHeader) throws HttpRequestParser.BadRequestException {
         parseState.reset();
         HttpServerExchange result = new HttpServerExchange(null);
         HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), parseState, result);",2016-11-01T22:53:55Z,91
"@@ -82,4 +82,8 @@ public interface UndertowLogger extends BasicLogger {
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5011, value = ""Ignoring AJP request with prefix %s"")
     void ignoringAjpRequestWithPrefixCode(byte prefix);
+
+    @LogMessage(level = Logger.Level.WARN)
+    @Message(id = 5012, value = ""Could not find boundary in multipart request with ContentType: %s, multipart data will not be available"")
+    void couldNotDetectBoundary(String mimeType);
 }",2013-04-26T01:43:28Z,65
"@@ -70,6 +70,11 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         String mimeType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
         if (mimeType != null && mimeType.startsWith(MULTIPART_FORM_DATA)) {
             String boundary = Headers.extractTokenFromHeader(mimeType, ""boundary"");
+            if(boundary == null) {
+                UndertowLogger.REQUEST_LOGGER.couldNotDetectBoundary(mimeType);
+                next.handleRequest(exchange);
+                return;
+            }
             final MultiPartUploadHandler multiPartUploadHandler = new MultiPartUploadHandler(exchange, boundary, defaultEncoding);
             exchange.putAttachment(FormDataParser.ATTACHMENT_KEY, multiPartUploadHandler);
         }",2013-04-26T01:43:28Z,119
"@@ -223,8 +223,8 @@ public interface UndertowMessages {
     @Message(id = 65, value = ""SSL must be specified to connect to a https URL"")
     IOException sslWasNull();
 
-    @Message(id = 66, value = ""Incorrect magic number for AJP packet header"")
-    IOException wrongMagicNumber();
+    @Message(id = 66, value = ""Incorrect magic number %s for AJP packet header"")
+    IOException wrongMagicNumber(int number);
 
     @Message(id = 67, value = ""No client cert was provided"")
     SSLPeerUnverifiedException peerUnverified();",2015-08-13T00:30:33Z,68
"@@ -186,7 +186,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     return;
                 } else {
                     if (result.value != 0x1234) {
-                        throw new IllegalStateException(""Wrong magic number"");
+                        throw UndertowMessages.MESSAGES.wrongMagicNumber(result.value);
                     }
                 }
             }",2015-08-13T00:30:33Z,54
"@@ -145,8 +145,7 @@ public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel t
 
     @Override
     public void terminateReads() throws IOException {
-        if(exchange.isPersistent()) {
-            state |= STATE_FINISHED;
+        if(exchange.isPersistent() && anyAreSet(state, STATE_FINISHED)) {
             return;
         }
         super.terminateReads();
@@ -233,7 +232,7 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
                 byte b1 = headerBuffer.get(); //0x12
                 byte b2 = headerBuffer.get(); //0x34
                 if (b1 != 0x12 || b2 != 0x34) {
-                    throw UndertowMessages.MESSAGES.wrongMagicNumber();
+                    throw UndertowMessages.MESSAGES.wrongMagicNumber(b1 << 8 | b2);
                 }
                 headerBuffer.get();//the length headers, two more than the string length header
                 headerBuffer.get();",2015-08-13T00:30:33Z,121
"@@ -384,4 +384,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String
     @LogMessage(level = ERROR)
     @Message(id = 5081, value = ""Response has already been started, cannot proxy request %s"")
     void cannotProxyStartedRequest(HttpServerExchange exchange);
+
+    @Message(id = 5082, value = ""Configured mod_cluster management host address cannot be a wildcard address (%s)!"")
+    IllegalArgumentException cannotUseWildcardAddressAsModClusterManagementHost(String providedAddress);
 }",2016-11-13T03:34:04Z,65
"@@ -43,6 +43,9 @@ public static WebBuilder webBuilder() {
 
     public MCMPConfig(Builder builder) {
         this.managementSocketAddress = new InetSocketAddress(builder.managementHost, builder.managementPort);
+        if (managementSocketAddress.getAddress().isAnyLocalAddress()) {
+            throw UndertowLogger.PROXY_REQUEST_LOGGER.cannotUseWildcardAddressAsModClusterManagementHost(builder.managementHost);
+        }
         if (managementSocketAddress.isUnresolved()) {
             throw UndertowLogger.PROXY_REQUEST_LOGGER.unableToResolveModClusterManagementHost(builder.managementHost);
         }",2016-11-13T03:34:04Z,410
"@@ -1,181 +0,0 @@
-package io.undertow.security.impl;
-
-import io.undertow.security.api.AuthenticationMechanism;
-import io.undertow.security.api.SecurityContext;
-import io.undertow.security.idm.Account;
-import io.undertow.server.ConduitWrapper;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.Cookie;
-import io.undertow.server.handlers.CookieImpl;
-import io.undertow.server.session.SecureRandomSessionIdGenerator;
-import io.undertow.server.session.Session;
-import io.undertow.server.session.SessionListener;
-import io.undertow.server.session.SessionManager;
-import io.undertow.util.ConduitFactory;
-import io.undertow.util.Sessions;
-import org.xnio.conduits.StreamSinkConduit;
-
-import java.util.Collections;
-import java.util.IdentityHashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Authenticator that can be used to configure single sign on.
- *
- * @author Stuart Douglas
- */
-public abstract class AbstractSingleSignOnAuthenticationMechanism implements AuthenticationMechanism {
-
-    private static final SecureRandomSessionIdGenerator SECURE_RANDOM_SESSION_ID_GENERATOR = new SecureRandomSessionIdGenerator();
-
-    private static final String SSO_SESSION_ATTRIBUTE = AbstractSingleSignOnAuthenticationMechanism.class.getName() + "".SSOID"";
-
-    private final Set<SessionManager> seenSessionManagers = Collections.synchronizedSet(Collections.newSetFromMap(new IdentityHashMap<SessionManager, Boolean>()));
-
-    private String cookieName = ""JSESSIONIDSSO"";
-    private boolean httpOnly;
-    private boolean secure;
-    private String domain;
-    private final SessionInvalidationListener listener = new SessionInvalidationListener();
-    private final ResponseListener responseListener = new ResponseListener();
-
-    @Override
-    public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange, SecurityContext securityContext) {
-        Cookie cookie = exchange.getRequestCookies().get(cookieName);
-        if (cookie != null) {
-            SingleSignOnEntry entry = findSsoEntry(cookie.getValue());
-            if (entry != null) {
-                registerSessionIfRequired(exchange, entry);
-                securityContext.authenticationComplete(entry.getAccount(), entry.getMechanismName(), false);
-                return AuthenticationMechanismOutcome.AUTHENTICATED;
-            } else {
-                clearSsoCookie(exchange);
-            }
-        }
-        exchange.addResponseWrapper(responseListener);
-        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
-    }
-
-    protected abstract SingleSignOnEntry findSsoEntry(String ssoId);
-    protected abstract void storeSsoEntry(String ssoId, SingleSignOnEntry entry);
-    protected abstract void removeSsoEntry(String sso);
-
-    private void registerSessionIfRequired(HttpServerExchange exchange, SingleSignOnEntry entry) {
-        Session session = getSession(exchange);
-        if (!entry.getSessions().containsKey(session.getId())) {
-            entry.getSessions().put(session.getId(), session);
-            if (!seenSessionManagers.contains(session.getSessionManager())) {
-                session.getSessionManager().registerSessionListener(listener);
-            }
-        }
-    }
-
-    private void clearSsoCookie(HttpServerExchange exchange) {
-        exchange.getResponseCookies().put(cookieName, new CookieImpl(cookieName).setMaxAge(0).setHttpOnly(httpOnly).setSecure(secure).setDomain(domain));
-    }
-
-    @Override
-    public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
-        return new ChallengeResult(false);
-    }
-
-    protected Session getSession(final HttpServerExchange exchange) {
-        return Sessions.getOrCreateSession(exchange);
-    }
-
-    private final class ResponseListener implements ConduitWrapper<StreamSinkConduit> {
-
-        @Override
-        public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpServerExchange exchange) {
-            SecurityContext sc = exchange.getSecurityContext();
-            Account account = sc.getAuthenticatedAccount();
-            if(account != null) {
-                String ssoId = SECURE_RANDOM_SESSION_ID_GENERATOR.createSessionId();
-                SingleSignOnEntry entry = new SingleSignOnEntry(account, sc.getMechanismName());
-                registerSessionIfRequired(exchange, entry);
-                storeSsoEntry(ssoId, entry);
-                exchange.getResponseCookies().put(cookieName, new CookieImpl(cookieName, ssoId).setHttpOnly(httpOnly).setSecure(secure).setDomain(domain));
-            }
-            return factory.create();
-        }
-    }
-
-
-    private final class SessionInvalidationListener implements SessionListener {
-
-        @Override
-        public void sessionCreated(Session session, HttpServerExchange exchange) {
-        }
-
-        @Override
-        public void sessionDestroyed(Session session, HttpServerExchange exchange, SessionDestroyedReason reason) {
-            Object sso = session.getAttribute(SSO_SESSION_ATTRIBUTE);
-            if (sso != null) {
-                SingleSignOnEntry entry = findSsoEntry((String) sso);
-                if (entry != null) {
-                    entry.getSessions().remove(session.getId());
-                    if (reason == SessionDestroyedReason.INVALIDATED) {
-                        for(Map.Entry<String, Session> s : entry.getSessions().entrySet()) {
-                            s.getValue().invalidate(null);
-                        }
-                        removeSsoEntry((String) sso);
-                    }
-                }
-            }
-        }
-
-        @Override
-        public void attributeAdded(Session session, String name, Object value) {
-        }
-
-        @Override
-        public void attributeUpdated(Session session, String name, Object newValue, Object oldValue) {
-        }
-
-        @Override
-        public void attributeRemoved(Session session, String name, Object oldValue) {
-        }
-
-        @Override
-        public void sessionIdChanged(Session session, String oldSessionId) {
-        }
-    }
-
-
-    public String getCookieName() {
-        return cookieName;
-    }
-
-    public AbstractSingleSignOnAuthenticationMechanism setCookieName(String cookieName) {
-        this.cookieName = cookieName;
-        return this;
-    }
-
-    public boolean isHttpOnly() {
-        return httpOnly;
-    }
-
-    public AbstractSingleSignOnAuthenticationMechanism setHttpOnly(boolean httpOnly) {
-        this.httpOnly = httpOnly;
-        return this;
-    }
-
-    public boolean isSecure() {
-        return secure;
-    }
-
-    public AbstractSingleSignOnAuthenticationMechanism setSecure(boolean secure) {
-        this.secure = secure;
-        return this;
-    }
-
-    public String getDomain() {
-        return domain;
-    }
-
-    public AbstractSingleSignOnAuthenticationMechanism setDomain(String domain) {
-        this.domain = domain;
-        return this;
-    }
-}",2014-01-10T08:07:46Z,411
"@@ -0,0 +1,94 @@
+package io.undertow.security.impl;
+
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import io.undertow.security.idm.Account;
+import io.undertow.server.session.SecureRandomSessionIdGenerator;
+import io.undertow.server.session.Session;
+import io.undertow.server.session.SessionManager;
+import io.undertow.util.CopyOnWriteMap;
+
+/**
+ * @author Stuart Douglas
+ * @author Paul Ferraro
+ */
+public class InMemorySingleSignOnManager implements SingleSignOnManager {
+
+    private static final SecureRandomSessionIdGenerator SECURE_RANDOM_SESSION_ID_GENERATOR = new SecureRandomSessionIdGenerator();
+
+    private final Map<String, SingleSignOn> ssoEntries = new ConcurrentHashMap<String, SingleSignOn>();
+
+    @Override
+    public SingleSignOn findSingleSignOn(String ssoId) {
+        return this.ssoEntries.get(ssoId);
+    }
+
+    @Override
+    public SingleSignOn createSingleSignOn(Account account, String mechanism) {
+        String id = SECURE_RANDOM_SESSION_ID_GENERATOR.createSessionId();
+        SingleSignOn entry = new SimpleSingleSignOnEntry(id, account, mechanism);
+        this.ssoEntries.put(id, entry);
+        return entry;
+    }
+
+    @Override
+    public void removeSingleSignOn(String ssoId) {
+        this.ssoEntries.remove(ssoId);
+    }
+
+    private static class SimpleSingleSignOnEntry implements SingleSignOn {
+        private final String id;
+        private final Account account;
+        private final String mechanismName;
+        private final Map<SessionManager, Session> sessions = new CopyOnWriteMap<SessionManager, Session>();
+
+        SimpleSingleSignOnEntry(String id, Account account, String mechanismName) {
+            this.id = id;
+            this.account = account;
+            this.mechanismName = mechanismName;
+        }
+
+        @Override
+        public String getId() {
+            return this.id;
+        }
+
+        @Override
+        public Account getAccount() {
+            return this.account;
+        }
+
+        @Override
+        public String getMechanismName() {
+            return this.mechanismName;
+        }
+
+        @Override
+        public Iterator<Session> iterator() {
+            return Collections.unmodifiableCollection(this.sessions.values()).iterator();
+        }
+
+        @Override
+        public boolean contains(Session session) {
+            return this.sessions.containsKey(session.getSessionManager());
+        }
+
+        @Override
+        public Session getSession(SessionManager manager) {
+            return this.sessions.get(manager);
+        }
+
+        @Override
+        public void add(Session session) {
+            this.sessions.put(session.getSessionManager(), session);
+        }
+
+        @Override
+        public void remove(Session session) {
+            this.sessions.remove(session.getSessionManager());
+        }
+    }
+}",2014-01-10T08:07:46Z,412
"@@ -0,0 +1,56 @@
+package io.undertow.security.impl;
+
+import io.undertow.security.idm.Account;
+import io.undertow.server.session.Session;
+import io.undertow.server.session.SessionManager;
+
+/**
+ * @author Stuart Douglas
+ * @author Paul Ferraro
+ */
+public interface SingleSignOn extends Iterable<Session> {
+
+    /**
+     * Returns the unique identifier for this SSO.
+     * @return
+     */
+    String getId();
+
+    /**
+     * Returns the account associated with this SSO.
+     * @return an account
+     */
+    Account getAccount();
+
+    /**
+     * Returns the authentication mechanism used to create the account associated with this SSO.
+     * @return an authentication mechanism
+     */
+    String getMechanismName();
+
+    /**
+     * Indicates whether or not the specified session is contained in the set of sessions to which the user is authenticated
+     * @param manager a session manager
+     * @return
+     */
+    boolean contains(Session session);
+
+    /**
+     * Adds the specified session to the set of sessions to which the user is authenticated
+     * @param manager a session manager
+     */
+    void add(Session session);
+
+    /**
+     * Removes the specified session from the set of sessions to which the user is authenticated
+     * @param manager a session manager
+     */
+    void remove(Session session);
+
+    /**
+     * Returns the session associated with the deployment of the specified session manager
+     * @param manager a session manager
+     * @return a session
+     */
+    Session getSession(SessionManager manager);
+}",2014-01-10T08:07:46Z,413
"@@ -1,29 +1,180 @@
 package io.undertow.security.impl;
 
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
+import io.undertow.security.api.AuthenticationMechanism;
+import io.undertow.security.api.SecurityContext;
+import io.undertow.security.idm.Account;
+import io.undertow.server.ConduitWrapper;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.Cookie;
+import io.undertow.server.handlers.CookieImpl;
+import io.undertow.server.session.Session;
+import io.undertow.server.session.SessionListener;
+import io.undertow.server.session.SessionManager;
+import io.undertow.util.ConduitFactory;
+import io.undertow.util.Sessions;
+
+import org.xnio.conduits.StreamSinkConduit;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.WeakHashMap;
 
 /**
  * Authenticator that can be used to configure single sign on.
  *
  * @author Stuart Douglas
+ * @author Paul Ferraro
  */
-public class SingleSignOnAuthenticationMechanism extends AbstractSingleSignOnAuthenticationMechanism {
+public class SingleSignOnAuthenticationMechanism implements AuthenticationMechanism {
 
-    private final Map<String, SingleSignOnEntry> ssoEntries = new ConcurrentHashMap<String, SingleSignOnEntry>();
+    private static final String SSO_SESSION_ATTRIBUTE = SingleSignOnAuthenticationMechanism.class.getName() + "".SSOID"";
 
-    @Override
-    protected SingleSignOnEntry findSsoEntry(String ssoId) {
-        return ssoEntries.get(ssoId);
+    // Use weak references to prevent memory leaks following undeployment
+    private final Set<SessionManager> seenSessionManagers = Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<SessionManager, Boolean>()));
+
+    private String cookieName = ""JSESSIONIDSSO"";
+    private boolean httpOnly;
+    private boolean secure;
+    private String domain;
+    private final SessionInvalidationListener listener = new SessionInvalidationListener();
+    private final ResponseListener responseListener = new ResponseListener();
+    private final SingleSignOnManager manager;
+
+    public SingleSignOnAuthenticationMechanism(SingleSignOnManager storage) {
+        this.manager = storage;
     }
 
     @Override
-    protected void storeSsoEntry(String ssoId, SingleSignOnEntry entry) {
-        ssoEntries.put(ssoId, entry);
+    public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange, SecurityContext securityContext) {
+        Cookie cookie = exchange.getRequestCookies().get(cookieName);
+        if (cookie != null) {
+            SingleSignOn sso = this.manager.findSingleSignOn(cookie.getValue());
+            if (sso != null) {
+                registerSessionIfRequired(exchange, sso);
+                securityContext.authenticationComplete(sso.getAccount(), sso.getMechanismName(), false);
+                return AuthenticationMechanismOutcome.AUTHENTICATED;
+            }
+            clearSsoCookie(exchange);
+        }
+        exchange.addResponseWrapper(responseListener);
+        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
+    }
+
+    private void registerSessionIfRequired(HttpServerExchange exchange, SingleSignOn sso) {
+        Session session = getSession(exchange);
+        if (!sso.contains(session)) {
+            sso.add(session);
+            session.setAttribute(SSO_SESSION_ATTRIBUTE, sso.getId());
+            SessionManager manager = session.getSessionManager();
+            if (seenSessionManagers.add(manager)) {
+                manager.registerSessionListener(listener);
+            }
+        }
+    }
+
+    private void clearSsoCookie(HttpServerExchange exchange) {
+        exchange.getResponseCookies().put(cookieName, new CookieImpl(cookieName).setMaxAge(0).setHttpOnly(httpOnly).setSecure(secure).setDomain(domain));
     }
 
     @Override
-    protected void removeSsoEntry(String sso) {
-        ssoEntries.remove(sso);
+    public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
+        return new ChallengeResult(false);
+    }
+
+    protected Session getSession(final HttpServerExchange exchange) {
+        return Sessions.getOrCreateSession(exchange);
+    }
+
+    final class ResponseListener implements ConduitWrapper<StreamSinkConduit> {
+
+        @Override
+        public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpServerExchange exchange) {
+            SecurityContext sc = exchange.getSecurityContext();
+            Account account = sc.getAuthenticatedAccount();
+            if(account != null) {
+                SingleSignOn sso = manager.createSingleSignOn(account, sc.getMechanismName());
+                registerSessionIfRequired(exchange, sso);
+                exchange.getResponseCookies().put(cookieName, new CookieImpl(cookieName, sso.getId()).setHttpOnly(httpOnly).setSecure(secure).setDomain(domain));
+            }
+            return factory.create();
+        }
+    }
+
+
+    final class SessionInvalidationListener implements SessionListener {
+
+        @Override
+        public void sessionCreated(Session session, HttpServerExchange exchange) {
+        }
+
+        @Override
+        public void sessionDestroyed(Session session, HttpServerExchange exchange, SessionDestroyedReason reason) {
+            String ssoId = (String) session.getAttribute(SSO_SESSION_ATTRIBUTE);
+            if (ssoId != null) {
+                SingleSignOn sso = manager.findSingleSignOn(ssoId);
+                if (sso != null) {
+                    sso.remove(session);
+                    if (reason == SessionDestroyedReason.INVALIDATED) {
+                        for (Session associatedSession: sso) {
+                            associatedSession.invalidate(null);
+                        }
+                        manager.removeSingleSignOn(ssoId);
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void attributeAdded(Session session, String name, Object value) {
+        }
+
+        @Override
+        public void attributeUpdated(Session session, String name, Object newValue, Object oldValue) {
+        }
+
+        @Override
+        public void attributeRemoved(Session session, String name, Object oldValue) {
+        }
+
+        @Override
+        public void sessionIdChanged(Session session, String oldSessionId) {
+        }
+    }
+
+
+    public String getCookieName() {
+        return cookieName;
+    }
+
+    public SingleSignOnAuthenticationMechanism setCookieName(String cookieName) {
+        this.cookieName = cookieName;
+        return this;
+    }
+
+    public boolean isHttpOnly() {
+        return httpOnly;
+    }
+
+    public SingleSignOnAuthenticationMechanism setHttpOnly(boolean httpOnly) {
+        this.httpOnly = httpOnly;
+        return this;
+    }
+
+    public boolean isSecure() {
+        return secure;
+    }
+
+    public SingleSignOnAuthenticationMechanism setSecure(boolean secure) {
+        this.secure = secure;
+        return this;
+    }
+
+    public String getDomain() {
+        return domain;
+    }
+
+    public SingleSignOnAuthenticationMechanism setDomain(String domain) {
+        this.domain = domain;
+        return this;
     }
 }",2014-01-10T08:07:46Z,414
"@@ -1,34 +0,0 @@
-package io.undertow.security.impl;
-
-import io.undertow.security.idm.Account;
-import io.undertow.server.session.Session;
-import io.undertow.util.CopyOnWriteMap;
-
-import java.util.Map;
-
-/**
- * @author Stuart Douglas
- */
-public class SingleSignOnEntry {
-
-    private final Account account;
-    private final String mechanismName;
-    private final Map<String, Session> sessions = new CopyOnWriteMap<String, Session>();
-
-    public SingleSignOnEntry(Account account, String mechanismName) {
-        this.account = account;
-        this.mechanismName = mechanismName;
-    }
-
-    public Account getAccount() {
-        return account;
-    }
-
-    public Map<String, Session> getSessions() {
-        return sessions;
-    }
-
-    public String getMechanismName() {
-        return mechanismName;
-    }
-}",2014-01-10T08:07:46Z,415
"@@ -0,0 +1,14 @@
+package io.undertow.security.impl;
+
+import io.undertow.security.idm.Account;
+
+/**
+ * @author Paul Ferraro
+ */
+public interface SingleSignOnManager {
+    SingleSignOn createSingleSignOn(Account account, String mechanism);
+
+    SingleSignOn findSingleSignOn(String ssoId);
+
+    void removeSingleSignOn(String ssoId);
+}",2014-01-10T08:07:46Z,416
"@@ -24,6 +24,7 @@
 import io.undertow.util.ConcurrentDirectDeque;
 import io.undertow.util.FastConcurrentDirectDeque;
 import io.undertow.util.PortableConcurrentDirectDeque;
+
 import org.xnio.XnioExecutor;
 import org.xnio.XnioWorker;
 
@@ -58,7 +59,10 @@ public class InMemorySessionManager implements SessionManager {
 
     private final ConcurrentDirectDeque<String> evictionQueue;
 
-    public InMemorySessionManager(int maxSessions) {
+    private final String deploymentName;
+
+    public InMemorySessionManager(String deploymentName, int maxSessions) {
+        this.deploymentName = deploymentName;
         this.sessions = new ConcurrentHashMap<String, InMemorySession>();
         this.maxSize = maxSessions;
         ConcurrentDirectDeque<String> evictionQueue = null;
@@ -72,8 +76,13 @@ public InMemorySessionManager(int maxSessions) {
         this.evictionQueue = evictionQueue;
     }
 
-    public InMemorySessionManager() {
-        this(-1);
+    public InMemorySessionManager(String id) {
+        this(id, -1);
+    }
+
+    @Override
+    public String getDeploymentName() {
+        return this.deploymentName;
     }
 
     @Override
@@ -172,6 +181,23 @@ public Set<String> getAllSessions() {
         return new HashSet<String>(sessions.keySet());
     }
 
+    @Override
+    public boolean equals(Object object) {
+        if (!(object instanceof SessionManager)) return false;
+        SessionManager manager = (SessionManager) object;
+        return this.deploymentName.equals(manager.getDeploymentName());
+    }
+
+    @Override
+    public int hashCode() {
+        return this.deploymentName.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return this.deploymentName.toString();
+    }
+
     /**
      * session implementation for the in memory session manager
      */",2014-01-10T08:07:46Z,13
"@@ -39,6 +39,12 @@ public interface SessionManager {
 
     AttachmentKey<SessionManager> ATTACHMENT_KEY = AttachmentKey.create(SessionManager.class);
 
+    /**
+     * Uniquely identifies this session manager
+     * @return a unique identifier
+     */
+    String getDeploymentName();
+
     /**
      * Starts the session manager
      */",2014-01-10T08:07:46Z,26
"@@ -66,14 +66,14 @@ public static void setup() throws URISyntaxException {
         server1 = Undertow.builder()
                 .addListener(port + 1, DefaultServer.getHostAddress(""default""))
                 .setHandler(jvmRoute(""JSESSIONID"", ""s1"", path()
-                        .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(), sessionConfig))
+                        .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(""""), sessionConfig))
                         .addPrefixPath(""/name"", new StringSendHandler(""server1""))))
                 .build();
 
         server2 = Undertow.builder()
                 .addListener(port + 2, DefaultServer.getHostAddress(""default""))
                 .setHandler(jvmRoute(""JSESSIONID"", ""s2"", path()
-                        .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(), sessionConfig))
+                        .addPrefixPath(""/session"", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(""""), sessionConfig))
                         .addPrefixPath(""/name"", new StringSendHandler(""server2""))))
                 .build();
         server1.start();",2014-01-10T08:07:46Z,417
"@@ -55,7 +55,7 @@ public void inMemorySessionTest() throws IOException {
         client.setCookieStore(new BasicCookieStore());
         try {
             final SessionCookieConfig sessionConfig = new SessionCookieConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig);
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""""), sessionConfig);
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange) throws Exception {
@@ -111,7 +111,7 @@ public void inMemoryMaxSessionsTest() throws IOException {
 
         try {
             final SessionCookieConfig sessionConfig = new SessionCookieConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(1), sessionConfig);
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager("""", 1), sessionConfig);
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange) throws Exception {",2014-01-10T08:07:46Z,14
"@@ -57,7 +57,7 @@ public void testSslSession() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
             final SslSessionConfig sessionConfig = new SslSessionConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig)
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""""), sessionConfig)
                     .setNext(new HttpHandler() {
                         @Override
                         public void handleRequest(final HttpServerExchange exchange) throws Exception {",2014-01-10T08:07:46Z,23
"@@ -55,7 +55,7 @@ public class URLRewritingSessionTestCase {
     @BeforeClass
     public static void setup() {
         final PathParameterSessionConfig sessionConfig = new PathParameterSessionConfig();
-        final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig);
+        final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""""), sessionConfig);
         handler.setNext(new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {",2014-01-10T08:07:46Z,418
"@@ -11,6 +11,7 @@
 import io.undertow.security.handlers.SecurityInitialHandler;
 import io.undertow.security.impl.BasicAuthenticationMechanism;
 import io.undertow.security.impl.FormAuthenticationMechanism;
+import io.undertow.security.impl.InMemorySingleSignOnManager;
 import io.undertow.security.impl.SingleSignOnAuthenticationMechanism;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.handlers.PathHandler;
@@ -21,6 +22,7 @@
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.FlexBase64;
+
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
@@ -48,7 +50,7 @@ public class SsoTestCase extends AuthenticationTestBase {
     @BeforeClass
     public static void setup() {
 
-        final SingleSignOnAuthenticationMechanism sso = new SingleSignOnAuthenticationMechanism();
+        final SingleSignOnAuthenticationMechanism sso = new SingleSignOnAuthenticationMechanism(new InMemorySingleSignOnManager());
         final PathHandler path = new PathHandler();
         HttpHandler current = new ResponseHandler();
         current = new AuthenticationCallHandler(current);
@@ -80,7 +82,7 @@ public static void setup() {
         path.addPrefixPath(""/test2"", current);
 
 
-        DefaultServer.setRootHandler(new SessionAttachmentHandler(path, new InMemorySessionManager(), new SessionCookieConfig()));
+        DefaultServer.setRootHandler(new SessionAttachmentHandler(path, new InMemorySessionManager(""""), new SessionCookieConfig()));
     }
 
     @Override",2014-01-10T08:07:46Z,419
"@@ -41,6 +41,6 @@ public InMemorySessionManagerFactory(int maxSessions) {
 
     @Override
     public SessionManager createSessionManager(Deployment deployment) {
-        return new InMemorySessionManager(maxSessions);
+        return new InMemorySessionManager(deployment.getDeploymentInfo().getDeploymentName(), maxSessions);
     }
 }",2014-01-10T08:07:46Z,420
"@@ -114,9 +114,9 @@ public final class ProxyHandler implements HttpHandler {
 
     private final HttpHandler next;
 
-    private final boolean rewriteHostHeader;
-    private final boolean reuseXForwarded;
-    private final int maxConnectionRetries;
+    private volatile boolean rewriteHostHeader;
+    private volatile boolean reuseXForwarded;
+    private volatile int maxConnectionRetries;
 
     private final Predicate idempotentRequestPredicate = IdempotentPredicate.INSTANCE;
 
@@ -755,6 +755,29 @@ public void handleException(Channel channel, IOException exception) {
         }
     }
 
+    public ProxyHandler setMaxConnectionRetries(int maxConnectionRetries) {
+        this.maxConnectionRetries = maxConnectionRetries;
+        return this;
+    }
+
+    public boolean isRewriteHostHeader() {
+        return rewriteHostHeader;
+    }
+
+    public ProxyHandler setRewriteHostHeader(boolean rewriteHostHeader) {
+        this.rewriteHostHeader = rewriteHostHeader;
+        return this;
+    }
+
+    public boolean isReuseXForwarded() {
+        return reuseXForwarded;
+    }
+
+    public ProxyHandler setReuseXForwarded(boolean reuseXForwarded) {
+        this.reuseXForwarded = reuseXForwarded;
+        return this;
+    }
+
     public int getMaxConnectionRetries() {
         return maxConnectionRetries;
     }",2016-09-19T11:13:06Z,92
"@@ -53,6 +53,7 @@ public class ModCluster {
 
     private final XnioWorker xnioWorker;
     private final ModClusterContainer container;
+    private final int maxRetries;
 
     private final String serverID = UUID.randomUUID().toString(); // TODO
 
@@ -68,6 +69,7 @@ public class ModCluster {
         this.maxRequestTime = builder.maxRequestTime;
         this.ttl = builder.ttl;
         this.useAlias = builder.useAlias;
+        this.maxRetries = builder.maxRetries;
         this.container = new ModClusterContainer(this, builder.xnioSsl, builder.client, builder.clientOptions);
     }
 
@@ -134,7 +136,7 @@ public HttpHandler getProxyHandler() {
      * @return the proxy handler
      */
     public HttpHandler createProxyHandler() {
-        return new ProxyHandler(container.getProxyClient(), maxRequestTime, NEXT_HANDLER);
+        return new ProxyHandler(container.getProxyClient(), maxRequestTime, NEXT_HANDLER, false, false, maxRetries);
     }
 
     /**
@@ -143,7 +145,7 @@ public HttpHandler createProxyHandler() {
      * @return the proxy handler
      */
     public HttpHandler createProxyHandler(HttpHandler next) {
-        return new ProxyHandler(container.getProxyClient(), maxRequestTime, next);
+        return new ProxyHandler(container.getProxyClient(), maxRequestTime, next, false, false, maxRetries);
     }
     /**
      * Start
@@ -205,6 +207,7 @@ public static class Builder {
         private long healthCheckInterval = TimeUnit.SECONDS.toMillis(10);
         private long removeBrokenNodes = TimeUnit.MINUTES.toMillis(1);
         public OptionMap clientOptions = OptionMap.EMPTY;
+        public int maxRetries;
 
         private Builder(XnioWorker xnioWorker, UndertowClient client, XnioSsl xnioSsl) {
             this.xnioSsl = xnioSsl;
@@ -261,6 +264,10 @@ public Builder setUseAlias(boolean useAlias) {
             return this;
         }
 
+        public void setMaxRetries(int maxRetries) {
+            this.maxRetries = maxRetries;
+        }
+
         public long getTtl() {
             return ttl;
         }",2016-09-19T11:13:06Z,395
"@@ -50,33 +50,42 @@ public final class ChannelUpgradeHandler implements HttpHandler {
      * @param openListener  the open listener to call
      * @param handshake     a handshake implementation that can be used to verify the client request and modify the response
      */
-    public synchronized void addProtocol(String productString, final ChannelListener<? super StreamConnection> openListener, final HttpUpgradeHandshake handshake) {
-        addProtocol(productString, new HttpUpgradeListener() {
-            @Override
-            public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange exchange) {
-                ChannelListeners.invokeChannelListener(streamConnection, openListener);
-            }
-        }, handshake);
+    public synchronized void addProtocol(String productString, ChannelListener<? super StreamConnection> openListener, final HttpUpgradeHandshake handshake) {
+        addProtocol(productString, null, openListener, handshake);
     }
+
     /**
      * Add a protocol to this handler.
      *
      * @param productString the product string to match
      * @param openListener  the open listener to call
      * @param handshake     a handshake implementation that can be used to verify the client request and modify the response
      */
-    public synchronized void addProtocol(String productString, HttpUpgradeListener openListener, final HttpUpgradeHandshake handshake) {
+    private synchronized void addProtocol(String productString, HttpUpgradeListener openListener, final HttpUpgradeHandshake handshake) {
+        addProtocol(productString, openListener, null, handshake);
+    }
+
+    private synchronized void addProtocol(String productString, HttpUpgradeListener openListener, final ChannelListener<? super StreamConnection> channelListener, final HttpUpgradeHandshake handshake) {
         if (productString == null) {
             throw new IllegalArgumentException(""productString is null"");
         }
-        if (openListener == null) {
+        if (openListener == null && channelListener == null) {
             throw new IllegalArgumentException(""openListener is null"");
         }
+        if(openListener == null) {
+            openListener = new HttpUpgradeListener() {
+                @Override
+                public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange exchange) {
+                    ChannelListeners.invokeChannelListener(streamConnection, channelListener);
+                }
+            };
+        }
+
         List<Holder> list = handlers.get(productString);
         if (list == null) {
             handlers.put(productString, list = new CopyOnWriteArrayList<>());
         }
-        list.add(new Holder(openListener, handshake));
+        list.add(new Holder(openListener, handshake, channelListener));
     }
 
     /**
@@ -122,7 +131,32 @@ public synchronized void removeProtocol(String productString, ChannelListener<?
         Iterator<Holder> it = holders.iterator();
         while (it.hasNext()) {
             Holder holder = it.next();
-            if (holder.listener == openListener) {
+            if (holder.channelListener == openListener) {
+                it.remove();
+                break;
+            }
+        }
+        if (holders.isEmpty()) {
+            handlers.remove(productString);
+        }
+    }
+
+
+    /**
+     * Remove a protocol from this handler.
+     *
+     * @param productString the product string to match
+     * @param upgradeListener  The upgrade listener
+     */
+    public synchronized void removeProtocol(String productString, HttpUpgradeListener upgradeListener) {
+        List<Holder> holders = handlers.get(productString);
+        if (holders == null) {
+            return;
+        }
+        Iterator<Holder> it = holders.iterator();
+        while (it.hasNext()) {
+            Holder holder = it.next();
+            if (holder.listener == upgradeListener) {
                 it.remove();
                 break;
             }
@@ -181,10 +215,12 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     private static final class Holder {
         final HttpUpgradeListener listener;
         final HttpUpgradeHandshake handshake;
+        final ChannelListener<? super StreamConnection> channelListener;
 
-        private Holder(final HttpUpgradeListener listener, final HttpUpgradeHandshake handshake) {
+        private Holder(final HttpUpgradeListener listener, final HttpUpgradeHandshake handshake, ChannelListener<? super StreamConnection> channelListener) {
             this.listener = listener;
             this.handshake = handshake;
+            this.channelListener = channelListener;
         }
     }
 }",2016-09-19T21:57:50Z,421
"@@ -469,6 +469,11 @@
     <profiles>
         <profile>
             <id>findbugs</id>
+            <activation>
+                <property>
+                    <name>findbugs</name>
+                </property>
+            </activation>
             <build>
                 <plugins>
                     <plugin>",2016-09-19T21:57:50Z,265
"@@ -114,9 +114,9 @@ public final class ProxyHandler implements HttpHandler {
 
     private final HttpHandler next;
 
-    private final boolean rewriteHostHeader;
-    private final boolean reuseXForwarded;
-    private final int maxConnectionRetries;
+    private volatile boolean rewriteHostHeader;
+    private volatile boolean reuseXForwarded;
+    private volatile int maxConnectionRetries;
 
     private final Predicate idempotentRequestPredicate = IdempotentPredicate.INSTANCE;
 
@@ -755,6 +755,29 @@ public void handleException(Channel channel, IOException exception) {
         }
     }
 
+    public ProxyHandler setMaxConnectionRetries(int maxConnectionRetries) {
+        this.maxConnectionRetries = maxConnectionRetries;
+        return this;
+    }
+
+    public boolean isRewriteHostHeader() {
+        return rewriteHostHeader;
+    }
+
+    public ProxyHandler setRewriteHostHeader(boolean rewriteHostHeader) {
+        this.rewriteHostHeader = rewriteHostHeader;
+        return this;
+    }
+
+    public boolean isReuseXForwarded() {
+        return reuseXForwarded;
+    }
+
+    public ProxyHandler setReuseXForwarded(boolean reuseXForwarded) {
+        this.reuseXForwarded = reuseXForwarded;
+        return this;
+    }
+
     public int getMaxConnectionRetries() {
         return maxConnectionRetries;
     }",2016-09-19T11:13:06Z,92
"@@ -53,6 +53,7 @@ public class ModCluster {
 
     private final XnioWorker xnioWorker;
     private final ModClusterContainer container;
+    private final int maxRetries;
 
     private final String serverID = UUID.randomUUID().toString(); // TODO
 
@@ -68,6 +69,7 @@ public class ModCluster {
         this.maxRequestTime = builder.maxRequestTime;
         this.ttl = builder.ttl;
         this.useAlias = builder.useAlias;
+        this.maxRetries = builder.maxRetries;
         this.container = new ModClusterContainer(this, builder.xnioSsl, builder.client, builder.clientOptions);
     }
 
@@ -134,7 +136,7 @@ public HttpHandler getProxyHandler() {
      * @return the proxy handler
      */
     public HttpHandler createProxyHandler() {
-        return new ProxyHandler(container.getProxyClient(), maxRequestTime, NEXT_HANDLER);
+        return new ProxyHandler(container.getProxyClient(), maxRequestTime, NEXT_HANDLER, false, false, maxRetries);
     }
 
     /**
@@ -143,7 +145,7 @@ public HttpHandler createProxyHandler() {
      * @return the proxy handler
      */
     public HttpHandler createProxyHandler(HttpHandler next) {
-        return new ProxyHandler(container.getProxyClient(), maxRequestTime, next);
+        return new ProxyHandler(container.getProxyClient(), maxRequestTime, next, false, false, maxRetries);
     }
     /**
      * Start
@@ -205,6 +207,7 @@ public static class Builder {
         private long healthCheckInterval = TimeUnit.SECONDS.toMillis(10);
         private long removeBrokenNodes = TimeUnit.MINUTES.toMillis(1);
         public OptionMap clientOptions = OptionMap.EMPTY;
+        public int maxRetries;
 
         private Builder(XnioWorker xnioWorker, UndertowClient client, XnioSsl xnioSsl) {
             this.xnioSsl = xnioSsl;
@@ -261,6 +264,10 @@ public Builder setUseAlias(boolean useAlias) {
             return this;
         }
 
+        public void setMaxRetries(int maxRetries) {
+            this.maxRetries = maxRetries;
+        }
+
         public long getTtl() {
             return ttl;
         }",2016-09-19T11:13:06Z,395
"@@ -141,7 +141,7 @@ public boolean tryServeResponse(boolean markCacheable) {
             exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, existingKey.getLanguage());
         }
         if(etag != null) {
-            exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, (etag.isWeak() ? ""w/\"""" :""\"""") + etag.getTag() + ""\"""");
+            exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, etag.toString());
         }
 
         //TODO: support if-range",2013-03-05T01:11:01Z,422
"@@ -19,19 +19,29 @@
 package io.undertow.server.handlers.error;
 
 import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.channels.Channel;
+import java.nio.channels.FileChannel;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
-import io.undertow.UndertowMessages;
+import io.undertow.UndertowLogger;
 import io.undertow.server.DefaultResponseListener;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.HttpHandlers;
 import io.undertow.server.handlers.ResponseCodeHandler;
-import io.undertow.server.handlers.file.DirectFileSource;
-import io.undertow.server.handlers.file.FileSource;
+import io.undertow.util.Headers;
+import io.undertow.util.WorkerDispatcher;
+import org.jboss.logging.Logger;
+import org.xnio.ChannelListener;
+import org.xnio.FileAccess;
+import org.xnio.IoUtils;
+import org.xnio.channels.Channels;
+import org.xnio.channels.StreamSinkChannel;
 
 /**
  * Handler that serves up a file from disk to serve as an error page.
@@ -43,6 +53,7 @@
  */
 public class FileErrorPageHandler implements HttpHandler {
 
+    private static final Logger log = Logger.getLogger(""io.undertow.server.error.file"");
     private volatile HttpHandler next = ResponseCodeHandler.HANDLE_404;
 
     /**
@@ -52,8 +63,6 @@ public class FileErrorPageHandler implements HttpHandler {
 
     private volatile File file;
 
-    private volatile FileSource fileSource = DirectFileSource.INSTANCE;
-
     public FileErrorPageHandler(final File file, final Integer... responseCodes) {
         this.file = file;
         this.responseCodes = new HashSet<Integer>(Arrays.asList(responseCodes));
@@ -66,7 +75,7 @@ public void handleRequest(final HttpServerExchange exchange) {
             public boolean handleDefaultResponse(final HttpServerExchange exchange) {
                 Set<Integer> codes = responseCodes;
                 if (!exchange.isResponseStarted() && codes.contains(exchange.getResponseCode())) {
-                    fileSource.serveFile(exchange, file, false);
+                    serveFile(exchange);
                     return true;
                 }
                 return false;
@@ -76,6 +85,53 @@ public boolean handleDefaultResponse(final HttpServerExchange exchange) {
         HttpHandlers.executeHandler(next, exchange);
     }
 
+    private void serveFile(final HttpServerExchange exchange) {
+        WorkerDispatcher.dispatch(exchange, new Runnable() {
+            @Override
+            public void run() {
+                final FileChannel fileChannel;
+                try {
+                    try {
+                        fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
+                    } catch (FileNotFoundException e) {
+                        //TODO: how to handle this
+                        exchange.endExchange();
+                        return;
+                    }
+                } catch (IOException e) {
+                    UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
+                    exchange.endExchange();
+                    return;
+                }
+
+                final StreamSinkChannel response = exchange.getResponseChannel();
+                response.getCloseSetter().set(new ChannelListener<Channel>() {
+                    public void handleEvent(final Channel channel) {
+                        IoUtils.safeClose(fileChannel);
+                    }
+                });
+                exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, file.length());
+
+                try {
+                    log.tracef(""Serving file %s (blocking)"", fileChannel);
+                    Channels.transferBlocking(response, fileChannel, 0, file.length());
+                    log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
+                    response.shutdownWrites();
+                    log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
+                    Channels.flushBlocking(response);
+                    log.tracef(""Finished serving %s (complete)"", fileChannel);
+                    exchange.endExchange();
+                } catch (IOException ignored) {
+                    log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
+                    exchange.endExchange();
+                    IoUtils.safeClose(response);
+                } finally {
+                    IoUtils.safeClose(fileChannel);
+                }
+            }
+        });
+    }
+
     public HttpHandler getNext() {
         return next;
     }
@@ -112,16 +168,4 @@ public FileErrorPageHandler setFile(final File file) {
         this.file = file;
         return this;
     }
-
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public FileErrorPageHandler setFileSource(final FileSource fileSource) {
-        if(fileSource == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""fileCache"");
-        }
-        this.fileSource = fileSource;
-        return this;
-    }
 }",2013-03-05T01:11:01Z,423
"@@ -1,186 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.undertow.server.handlers.file;
-
-import java.nio.ByteBuffer;
-
-/**
- * Constant Content
- *
- * @author Jason T. Greene
- */
-public class Blobs {
-      public static final String FILE_JS=""function growit() {\n"" +
-              ""    var table = document.getElementById(\""thetable\"");\n"" +
-              ""\n"" +
-              ""    var i = table.rows.length - 1;\n"" +
-              ""    while (i-- > 0) {\n"" +
-              ""        if (table.rows[i].id == \""eraseme\"") {\n"" +
-              ""            table.deleteRow(i);\n"" +
-              ""        } else {\n"" +
-              ""            break;\n"" +
-              ""        }\n"" +
-              ""    }\n"" +
-              ""    table.style.height=\""\"";\n"" +
-              ""    var i = 0;\n"" +
-              ""    while (table.offsetHeight < window.innerHeight - 24) {\n"" +
-              ""        i++;\n"" +
-              ""        var tbody = table.tBodies[0];\n"" +
-              ""        var row = tbody.insertRow(tbody.rows.length);\n"" +
-              ""        row.id=\""eraseme\"";\n"" +
-              ""        var cell = row.insertCell(0);\n"" +
-              ""        if (table.rows.length % 2 != 0) {\n"" +
-              ""            row.className=\""even eveninvis\"";\n"" +
-              ""        } else {\n"" +
-              ""            row.className=\""odd oddinvis\"";\n"" +
-              ""        }\n"" +
-              ""\n"" +
-              ""        cell.colSpan=3;\n"" +
-              ""        cell.appendChild(document.createTextNode(\""i\""));\n"" +
-              ""    }\n"" +
-              ""    table.style.height=\""100%\"";\n"" +
-              ""    if (i > 0) {\n"" +
-              ""        document.documentElement.style.overflowY=\""hidden\"";\n"" +
-              ""    } else {\n"" +
-              ""        document.documentElement.style.overflowY=\""auto\"";\n"" +
-              ""    }\n"" +
-              ""}"";
-      public static final String FILE_CSS =
-              ""body {\n"" +
-              ""    font-family: \""Lucida Grande\"", \""Lucida Sans Unicode\"", \""Trebuchet MS\"", Helvetica, Arial, Verdana, sans-serif;\n"" +
-              ""    margin: 5px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.loc {\n"" +
-              ""    background-image: linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -o-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -moz-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -webkit-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -ms-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    \n"" +
-              ""    background-image: -webkit-gradient(\n"" +
-              ""        linear,\n"" +
-              ""        left bottom,\n"" +
-              ""        left top,\n"" +
-              ""        color-stop(0.08, rgb(153,151,153)),\n"" +
-              ""        color-stop(0.54, rgb(199,199,199))\n"" +
-              ""    );\n"" +
-              ""    color: black;\n"" +
-              ""    padding: 2px;\n"" +
-              ""    font-weight: normal;\n"" +
-              ""    border: solid 1px;\n"" +
-              ""    font-size: 150%;\n"" +
-              ""    text-align: left;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.label {\n"" +
-              ""    border: solid  1px;\n"" +
-              ""    text-align: left;\n"" +
-              ""    padding: 4px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-weight: normal;\n"" +
-              ""    font-size: small;\n"" +
-              ""    background-color: #e8e8e8;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.offset {\n"" +
-              ""    padding-left: 32px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.footer {\n"" +
-              ""    font-size: 75%;\n"" +
-              ""    text-align: right;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.icon {\n"" +
-              ""    padding-left: 24px;\n"" +
-              ""    text-decoration: none;\n"" +
-              ""    color: black;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.icon:hover {\n"" +
-              ""    text-decoration: underline;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""table {\n"" +
-              ""    border: 1px solid;\n"" +
-              ""    border-spacing: 0px;\n"" +
-              ""    width: 100%;\n"" +
-              ""    border-collapse: collapse;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.odd {\n"" +
-              ""    background-color: #f3f6fa;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.odd td {\n"" +
-              ""    padding: 2px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-size: smaller;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.even {\n"" +
-              ""    background-color: #ffffff;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.even td {\n"" +
-              ""    padding: 2px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-size: smaller;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.eveninvis td {\n"" +
-              ""    color: #ffffff;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.oddinvis td {\n"" +
-              ""    color: #f3f6fa\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.up {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4y2P4//8/Ay7sM4nhPwjjUwMm0ua//Y+M0+e//QrSGDAfgvEZAjdgydHXcAzTXLjWDoxhhqBbhGLA1N0vwBhdM7ohMHVwA8yrzn4zLj/936j8FE7N6IaA1IL0gPQy2DVc+rnp3FeCmtENAekB6WXw7Lz1tWD5x/+wEIdhdI3o8iA9IL0MYZMfvq9a9+V/w+avcIzLAGQ1ID0gvQxJc56/aNn29X/vnm9wjMsAZDWtQD0gvQwFy94+6N37/f/Moz/gGJcByGpAekB6GarXf7427ciP/0vP/YRjdP/CMLIakB6QXobKDd9PN+769b91P2kYpAekl2HJhb8r11/583/9ZRIxUM+8U783MQCBGBDXAHEbibgGrBdfTiMGU2wAAPz+nxp+TnhDAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.dir {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAAA+UlEQVQ4jWP4//8/AyUYTKTNf/sfGafPf/s1be47G5IMWHL0NRxP2f3mbcaCtz/RDUbHKAZM3f2CJAw3wLzq7Dfj8tP/jcpPkYRBekB6GewaLv3cdO7r/y0XSMMgPSC9DJ6dt74WLP/4v3TVZ5IwSA9IL0PY5Ifvq9Z9+d+w+StJGKQHpJchac7zFy3bvv7v3fONJNwK1APSy5C/7O2D3r3f/888+oMkDNID0stQvf7ztWlHfvxfeu4nSRikB6SXoXLD99ONu379b91PGgbpAellWHLh38r1V/78X3+ZRAzUM/fUr00MQCAGxDVA3EYirgHrpUpupAQDAPs+7c1tGDnPAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.file {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAABM0lEQVQ4y5WSTW6DMBCF3xvzc4wuOEIO0kVAuUB7vJ4g3KBdoHSRROomEpusUaoAcaYLfmKoqVRLIxnJ7/M3YwJVBcknACv8b+1U9SvoP1bXa/3WNDVIAQmQBLsNOEsGQYAwDNcARgDqusbl+wIRA2NkBEyqP0s+kCOAQhhjICJdkaDIJDwEvQAhH+G+SHagWTsi4jHoAWYIOxYDZDjnb8Fn4Akvz6AHcAbx3Tp5ETwI3RwckyVtv4Fr4VEe9qq6bDB5tlnYWou2bWGtRRRF6jdwAm5Za1FVFc7nM0QERVG8A9hPDRaGpapomgZlWSJJEuR5ftpsNq8ADr9amC+SuN/vuN1uIIntdnvKsuwZwKf2wxgBxpjpX+dA4jjW4/H4kabpixt2AbvAmDX+XnsAB509ww+A8mAar+XXgQAAAABJRU5ErkJggg==') left center no-repeat;\n"" +
-              ""}"";
-
-    public static final ByteBuffer FILE_CSS_BUFFER;
-    public static final ByteBuffer FILE_JS_BUFFER;
-
-    static {
-        try {
-            byte[] bytes = FILE_CSS.getBytes(""US-ASCII"");
-            FILE_CSS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
-            FILE_CSS_BUFFER.put(bytes);
-            FILE_CSS_BUFFER.flip();
-
-            bytes = FILE_JS.getBytes(""US-ASCII"");
-            FILE_JS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
-            FILE_JS_BUFFER.put(bytes);
-            FILE_JS_BUFFER.flip();
-        } catch (Exception e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-}",2013-03-05T01:11:01Z,104
"@@ -1,148 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.nio.channels.Channel;
-import java.nio.channels.FileChannel;
-
-import io.undertow.UndertowLogger;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.cache.ResponseCache;
-import io.undertow.util.HttpString;
-import io.undertow.util.WorkerDispatcher;
-import org.jboss.logging.Logger;
-import org.xnio.ChannelListener;
-import org.xnio.FileAccess;
-import org.xnio.IoUtils;
-import org.xnio.channels.Channels;
-import org.xnio.channels.StreamSinkChannel;
-
-import static io.undertow.util.Headers.CONTENT_LENGTH;
-import static io.undertow.util.Methods.GET;
-import static io.undertow.util.Methods.HEAD;
-
-/**
- * A file cache that serves files directly with no caching.
- *
- * @author Stuart Douglas
- */
-public class DirectFileSource implements FileSource {
-
-    private static final Logger log = Logger.getLogger(""io.undertow.server.handlers.file"");
-
-    public static final FileSource INSTANCE = new DirectFileSource();
-
-    @Override
-    public void serveFile(final HttpServerExchange exchange, final File file, final boolean directoryListingEnabled) {
-        // ignore request body
-
-        //try and serve a cached version, and also mark the response as cachable
-        final ResponseCache cache = exchange.getAttachment(ResponseCache.ATTACHMENT_KEY);
-        if(cache != null) {
-            if(cache.tryServeResponse()) {
-                return;
-            }
-        }
-        WorkerDispatcher.dispatch(exchange, new FileWriteTask(exchange, file, directoryListingEnabled));
-    }
-
-    private static class FileWriteTask implements Runnable {
-
-        private final HttpServerExchange exchange;
-        private final File file;
-        private final boolean directoryListingEnabled;
-
-        private FileWriteTask(final HttpServerExchange exchange, final File file, final boolean directoryListingEnabled) {
-            this.exchange = exchange;
-            this.file = file;
-            this.directoryListingEnabled = directoryListingEnabled;
-        }
-
-        @Override
-        public void run() {
-
-            if(file.isDirectory()) {
-                if (directoryListingEnabled) {
-                    FileHandler.renderDirectoryListing(exchange, file);
-                } else {
-                    exchange.setResponseCode(404);
-                    exchange.endExchange();
-                }
-                return;
-            }
-
-            final HttpString method = exchange.getRequestMethod();
-            final FileChannel fileChannel;
-            final long length;
-            try {
-                try {
-                    fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
-                } catch (FileNotFoundException e) {
-                    exchange.setResponseCode(404);
-                    exchange.endExchange();
-                    return;
-                }
-                length = fileChannel.size();
-            } catch (IOException e) {
-                UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
-                exchange.setResponseCode(500);
-                exchange.endExchange();
-                return;
-            }
-            if (!method.equals(GET) && !method.equals(HEAD)) {
-                exchange.setResponseCode(500);
-                exchange.endExchange();
-                return;
-            }
-
-            exchange.getResponseHeaders().put(CONTENT_LENGTH, Long.toString(length));
-            if (method.equals(HEAD)) {
-                exchange.endExchange();
-                return;
-            }
-            final StreamSinkChannel response = exchange.getResponseChannel();
-            response.getCloseSetter().set(new ChannelListener<Channel>() {
-                public void handleEvent(final Channel channel) {
-                    IoUtils.safeClose(fileChannel);
-                }
-            });
-
-
-            try {
-                log.tracef(""Serving file %s (blocking)"", fileChannel);
-                Channels.transferBlocking(response, fileChannel, 0, length);
-                log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
-                response.shutdownWrites();
-                log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
-                Channels.flushBlocking(response);
-                log.tracef(""Finished serving %s (complete)"", fileChannel);
-                exchange.endExchange();
-            } catch (IOException ignored) {
-                log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
-                exchange.endExchange();
-                IoUtils.safeClose(response);
-            } finally {
-                IoUtils.safeClose(fileChannel);
-            }
-        }
-    }
-}",2013-03-05T01:11:01Z,61
"@@ -1,269 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import io.undertow.UndertowMessages;
-import io.undertow.io.IoCallback;
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
-import io.undertow.util.Methods;
-import io.undertow.util.MimeMappings;
-import org.xnio.channels.Channels;
-
-/**
- *
- * Serves files direct from the file system.
- *
- * @author Stuart Douglas
- * @author Jason T. Greene
- */
-public class FileHandler implements HttpHandler {
-
-    private volatile File base;
-    private volatile FileSource fileSource = new DirectFileSource();
-    private volatile boolean directoryListingEnabled = false;
-    private volatile MimeMappings mimeMappings = MimeMappings.DEFAULT;
-
-    public FileHandler(final File base) {
-        if (base == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
-        }
-        this.base = base;
-    }
-
-    @Override
-    public void handleRequest(final HttpServerExchange exchange) {
-        String path = exchange.getRelativePath();
-        if (File.separatorChar != '/') {
-            if (path.indexOf(File.separatorChar) != -1) {
-                exchange.setResponseCode(404);
-                exchange.endExchange();
-                return;
-            }
-            path = path.replace('/', File.separatorChar);
-        }
-
-        if (sendRequestedBlobs(exchange)) {
-            return;
-        }
-
-        final File file = new File(base, path);
-        if(mimeMappings != null) {
-            final String fileName = file.getName();
-            int index = fileName.lastIndexOf('.');
-            if(index != -1 && index != fileName.length() - 1) {
-                final String mime = mimeMappings.getMimeType(fileName.substring(index +1));
-                if(mime != null) {
-                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, mime);
-                } else {
-                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
-                }
-            } else {
-                exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
-            }
-        }
-        fileSource.serveFile(exchange, file, directoryListingEnabled);
-    }
-
-    public File getBase() {
-        return base;
-    }
-
-    public FileHandler setBase(final File base) {
-        if (base == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
-        }
-        this.base = base;
-        return this;
-    }
-
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public FileHandler setFileSource(final FileSource fileSource) {
-        if (fileSource == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""fileCache"");
-        }
-        this.fileSource = fileSource;
-        return this;
-    }
-
-    private boolean sendRequestedBlobs(HttpServerExchange exchange) {
-        ByteBuffer buffer = null;
-        String type = null;
-        if (""css"".equals(exchange.getQueryString())) {
-            buffer = Blobs.FILE_CSS_BUFFER.duplicate();
-            type = ""text/css"";
-        } else if (""js"".equals(exchange.getQueryString())) {
-            buffer = Blobs.FILE_JS_BUFFER.duplicate();
-            type = ""application/javascript"";
-        }
-
-        if (buffer != null) {
-            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(buffer.limit()));
-            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, type);
-            if (Methods.HEAD.equals(exchange.getRequestMethod())) {
-                exchange.endExchange();
-                return true;
-            }
-            exchange.getResponseSender().send(buffer, IoCallback.END_EXCHANGE);
-
-            return true;
-        }
-
-        return false;
-    }
-
-    public static void renderDirectoryListing(HttpServerExchange exchange, File file) {
-        String requestPath = exchange.getRequestPath();
-        if (! requestPath.endsWith(""/"")) {
-            exchange.setResponseCode(302);
-            exchange.getResponseHeaders().put(Headers.LOCATION, requestPath + ""/"");
-            exchange.endExchange();
-            return;
-        }
-
-        // TODO - Fix exchange to sanitize path, so handlers don't need to do this
-        String resolvedPath = exchange.getResolvedPath();
-        for (int i = 0; i < resolvedPath.length(); i++) {
-            if (resolvedPath.charAt(i) != '/') {
-                resolvedPath = resolvedPath.substring(Math.max(0, i - 1));
-                break;
-            }
-        }
-
-        StringBuilder builder = new StringBuilder();
-        builder.append(""<html><head><script src='"").append(resolvedPath).append(""?js'></script>"")
-                .append(""<link rel='stylesheet' type='txt/css' href='"").append(resolvedPath).append(""?css'/></head>"");
-        builder.append(""<body onresize='growit()' onload='growit()'><table id='thetable'><thead>"");
-        builder.append(""<tr><th class='loc' colspan='3'>Directory Listing - "").append(requestPath)
-                .append(""<tr><th class='label offset'>Name</th><th class='label'>Last Modified</th><th class='label'>Size</th></tr></thead>"")
-                .append(""<tfoot><tr><th class=\""loc footer\"" colspan=\""3\"">Powered by Undertow</th></tr></tfoot><tbody>"");
-
-        int state  = 0;
-        String parent = null;
-        for (int i = requestPath.length() - 1; i >= 0; i--) {
-            if (state == 1) {
-                if (requestPath.charAt(i) == '/') {
-                    state = 2;
-                }
-            } else if (requestPath.charAt(i) != '/') {
-                if (state == 2) {
-                    parent = requestPath.substring(0, i + 1);
-                    break;
-                }
-                state = 1;
-            }
-        }
-
-        SimpleDateFormat format = new SimpleDateFormat(""MMM dd, yyyy HH:mm:ss"");
-        int i = 0;
-        if (parent != null) {
-            i++;
-            builder.append(""<tr class='odd'><td><a class='icon up' href='"").append(parent).append(""'>[..]</a></td><td>"");
-            builder.append(format.format(new Date(file.lastModified()))).append(""</td><td>--</td></tr>"");
-        }
-
-        for (File entry : file.listFiles()) {
-            builder.append(""<tr class='"").append((++i & 1) == 1 ? ""odd"" : ""even"").append(""'><td><a class='icon "");
-            builder.append(entry.isFile() ? ""file"" : ""dir"");
-            builder.append(""' href='"").append(entry.getName()).append(""'>"").append(entry.getName()).append(""</a></td><td>"");
-            builder.append(format.format(new Date(entry.lastModified()))).append(""</td><td>"");
-            if (entry.isFile()) {
-                formatSize(builder, entry.length());
-            } else {
-                builder.append(""--"");
-            }
-            builder.append(""</td></tr>"");
-        }
-        builder.append(""</tbody></table></body></html>"");
-
-        try {
-            ByteBuffer output = ByteBuffer.wrap(builder.toString().getBytes(""UTF-8""));
-            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(output.limit()));
-            Channels.writeBlocking(exchange.getResponseChannel(), output);
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException(e);
-        } catch (IOException e) {
-            exchange.setResponseCode(500);
-        }
-
-        exchange.endExchange();
-        return;
-    }
-
-
-    private static StringBuilder formatSize(StringBuilder builder, long size) {
-        int n = 1024 * 1024 * 1024;
-        int type = 0;
-        while (size < n && n >= 1024) {
-            n /= 1024;
-            type++;
-        }
-
-        long top = (size * 100) / n;
-        long bottom =  top % 100;
-        top /= 100;
-
-        builder.append(top);
-        if (bottom > 0) {
-            builder.append(""."").append(bottom / 10);
-            bottom %= 10;
-            if (bottom > 0) {
-                builder.append(bottom);
-            }
-
-        }
-
-        switch (type) {
-            case 0: builder.append("" GB""); break;
-            case 1: builder.append("" MB""); break;
-            case 2: builder.append("" KB""); break;
-        }
-
-        return builder;
-    }
-
-    public boolean isDirectoryListingEnabled() {
-        return directoryListingEnabled;
-    }
-
-    public FileHandler setDirectoryListingEnabled(final boolean directoryListingEnabled) {
-        this.directoryListingEnabled = directoryListingEnabled;
-        return this;
-    }
-
-    public MimeMappings getMimeMappings() {
-        return mimeMappings;
-    }
-
-    public FileHandler setMimeMappings(final MimeMappings mimeMappings) {
-        this.mimeMappings = mimeMappings;
-        return this;
-    }
-}",2013-03-05T01:11:01Z,424
"@@ -1,48 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-
-import io.undertow.server.HttpServerExchange;
-
-/**
- * A file cache that serves files directly to a client.
- *
- * @author Stuart Douglas
- */
-public interface FileSource {
-
-    /**
-     * Serves a file directly to the client, once the file has been transferred the completion handler is invoked.
-     * <p/>
-     * This method essentially takes over the request, once it has been invoked no further handlers should process
-     * the request.
-     * <p/>
-     * This method must set the Content-Length header on the {@link HttpServerExchange}.
-     *
-     *
-     * @param exchange                The exchange
-     * @param file                    The file to serve
-     * @param directoryListingEnabled If the handler should serve up a directory listing page
-     * @throws IllegalStateException If the response channel has already been acquired
-     */
-    void serveFile(final HttpServerExchange exchange, final File file, boolean directoryListingEnabled);
-
-}",2013-03-05T01:11:01Z,2
"@@ -0,0 +1,336 @@
+package io.undertow.server.handlers.resource;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.text.SimpleDateFormat;
+
+import io.undertow.io.IoCallback;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.Headers;
+import io.undertow.util.Methods;
+import org.xnio.channels.Channels;
+
+/**
+ * @author Stuart Douglas
+ */
+public class DirectoryUtils {
+
+    /**
+     * Serve static resource for the directory listing
+     *
+     * @param exchange The exchange
+     * @return true if resources were served
+     */
+    public static boolean sendRequestedBlobs(HttpServerExchange exchange) {
+        ByteBuffer buffer = null;
+        String type = null;
+        if (""css"".equals(exchange.getQueryString())) {
+            buffer = Blobs.FILE_CSS_BUFFER.duplicate();
+            type = ""text/css"";
+        } else if (""js"".equals(exchange.getQueryString())) {
+            buffer = Blobs.FILE_JS_BUFFER.duplicate();
+            type = ""application/javascript"";
+        }
+
+        if (buffer != null) {
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(buffer.limit()));
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, type);
+            if (Methods.HEAD.equals(exchange.getRequestMethod())) {
+                exchange.endExchange();
+                return true;
+            }
+            exchange.getResponseSender().send(buffer, IoCallback.END_EXCHANGE);
+
+            return true;
+        }
+
+        return false;
+    }
+
+    public static void renderDirectoryListing(HttpServerExchange exchange, Resource resource) {
+        String requestPath = exchange.getRequestPath();
+        if (! requestPath.endsWith(""/"")) {
+            exchange.setResponseCode(302);
+            exchange.getResponseHeaders().put(Headers.LOCATION, requestPath + ""/"");
+            exchange.endExchange();
+            return;
+        }
+
+        // TODO - Fix exchange to sanitize path, so handlers don't need to do this
+        String resolvedPath = exchange.getResolvedPath();
+        for (int i = 0; i < resolvedPath.length(); i++) {
+            if (resolvedPath.charAt(i) != '/') {
+                resolvedPath = resolvedPath.substring(Math.max(0, i - 1));
+                break;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder();
+        builder.append(""<html><head><script src='"").append(resolvedPath).append(""?js'></script>"")
+                .append(""<link rel='stylesheet' type='txt/css' href='"").append(resolvedPath).append(""?css'/></head>"");
+        builder.append(""<body onresize='growit()' onload='growit()'><table id='thetable'><thead>"");
+        builder.append(""<tr><th class='loc' colspan='3'>Directory Listing - "").append(requestPath)
+                .append(""<tr><th class='label offset'>Name</th><th class='label'>Last Modified</th><th class='label'>Size</th></tr></thead>"")
+                .append(""<tfoot><tr><th class=\""loc footer\"" colspan=\""3\"">Powered by Undertow</th></tr></tfoot><tbody>"");
+
+        int state  = 0;
+        String parent = null;
+        for (int i = requestPath.length() - 1; i >= 0; i--) {
+            if (state == 1) {
+                if (requestPath.charAt(i) == '/') {
+                    state = 2;
+                }
+            } else if (requestPath.charAt(i) != '/') {
+                if (state == 2) {
+                    parent = requestPath.substring(0, i + 1);
+                    break;
+                }
+                state = 1;
+            }
+        }
+
+        SimpleDateFormat format = new SimpleDateFormat(""MMM dd, yyyy HH:mm:ss"");
+        int i = 0;
+        if (parent != null) {
+            i++;
+            builder.append(""<tr class='odd'><td><a class='icon up' href='"").append(parent).append(""'>[..]</a></td><td>"");
+            builder.append(format.format(resource.getLastModified())).append(""</td><td>--</td></tr>"");
+        }
+
+        for (Resource entry : resource.list()) {
+            builder.append(""<tr class='"").append((++i & 1) == 1 ? ""odd"" : ""even"").append(""'><td><a class='icon "");
+            builder.append(entry.isDirectory() ? ""dir"" : ""file"");
+            builder.append(""' href='"").append(entry.getName()).append(""'>"").append(entry.getName()).append(""</a></td><td>"");
+            builder.append(format.format(entry.getLastModified())).append(""</td><td>"");
+            if (entry.isDirectory()) {
+                builder.append(""--"");
+            } else {
+                formatSize(builder, entry.getContentLength());
+            }
+            builder.append(""</td></tr>"");
+        }
+        builder.append(""</tbody></table></body></html>"");
+
+        try {
+            ByteBuffer output = ByteBuffer.wrap(builder.toString().getBytes(""UTF-8""));
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(output.limit()));
+            Channels.writeBlocking(exchange.getResponseChannel(), output);
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalStateException(e);
+        } catch (IOException e) {
+            exchange.setResponseCode(500);
+        }
+
+        exchange.endExchange();
+        return;
+    }
+
+
+    private static StringBuilder formatSize(StringBuilder builder, Long size) {
+        if(size == null) {
+            builder.append(""???"");
+            return builder;
+        }
+        int n = 1024 * 1024 * 1024;
+        int type = 0;
+        while (size < n && n >= 1024) {
+            n /= 1024;
+            type++;
+        }
+
+        long top = (size * 100) / n;
+        long bottom =  top % 100;
+        top /= 100;
+
+        builder.append(top);
+        if (bottom > 0) {
+            builder.append(""."").append(bottom / 10);
+            bottom %= 10;
+            if (bottom > 0) {
+                builder.append(bottom);
+            }
+
+        }
+
+        switch (type) {
+            case 0: builder.append("" GB""); break;
+            case 1: builder.append("" MB""); break;
+            case 2: builder.append("" KB""); break;
+        }
+
+        return builder;
+    }
+
+
+
+    private DirectoryUtils() {
+
+    }
+
+    /**
+     * Constant Content
+     *
+     * @author Jason T. Greene
+     */
+    static class Blobs {
+          public static final String FILE_JS=""function growit() {\n"" +
+                  ""    var table = document.getElementById(\""thetable\"");\n"" +
+                  ""\n"" +
+                  ""    var i = table.rows.length - 1;\n"" +
+                  ""    while (i-- > 0) {\n"" +
+                  ""        if (table.rows[i].id == \""eraseme\"") {\n"" +
+                  ""            table.deleteRow(i);\n"" +
+                  ""        } else {\n"" +
+                  ""            break;\n"" +
+                  ""        }\n"" +
+                  ""    }\n"" +
+                  ""    table.style.height=\""\"";\n"" +
+                  ""    var i = 0;\n"" +
+                  ""    while (table.offsetHeight < window.innerHeight - 24) {\n"" +
+                  ""        i++;\n"" +
+                  ""        var tbody = table.tBodies[0];\n"" +
+                  ""        var row = tbody.insertRow(tbody.rows.length);\n"" +
+                  ""        row.id=\""eraseme\"";\n"" +
+                  ""        var cell = row.insertCell(0);\n"" +
+                  ""        if (table.rows.length % 2 != 0) {\n"" +
+                  ""            row.className=\""even eveninvis\"";\n"" +
+                  ""        } else {\n"" +
+                  ""            row.className=\""odd oddinvis\"";\n"" +
+                  ""        }\n"" +
+                  ""\n"" +
+                  ""        cell.colSpan=3;\n"" +
+                  ""        cell.appendChild(document.createTextNode(\""i\""));\n"" +
+                  ""    }\n"" +
+                  ""    table.style.height=\""100%\"";\n"" +
+                  ""    if (i > 0) {\n"" +
+                  ""        document.documentElement.style.overflowY=\""hidden\"";\n"" +
+                  ""    } else {\n"" +
+                  ""        document.documentElement.style.overflowY=\""auto\"";\n"" +
+                  ""    }\n"" +
+                  ""}"";
+          public static final String FILE_CSS =
+                  ""body {\n"" +
+                  ""    font-family: \""Lucida Grande\"", \""Lucida Sans Unicode\"", \""Trebuchet MS\"", Helvetica, Arial, Verdana, sans-serif;\n"" +
+                  ""    margin: 5px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.loc {\n"" +
+                  ""    background-image: linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -o-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -moz-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -webkit-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -ms-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    \n"" +
+                  ""    background-image: -webkit-gradient(\n"" +
+                  ""        linear,\n"" +
+                  ""        left bottom,\n"" +
+                  ""        left top,\n"" +
+                  ""        color-stop(0.08, rgb(153,151,153)),\n"" +
+                  ""        color-stop(0.54, rgb(199,199,199))\n"" +
+                  ""    );\n"" +
+                  ""    color: black;\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    font-weight: normal;\n"" +
+                  ""    border: solid 1px;\n"" +
+                  ""    font-size: 150%;\n"" +
+                  ""    text-align: left;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.label {\n"" +
+                  ""    border: solid  1px;\n"" +
+                  ""    text-align: left;\n"" +
+                  ""    padding: 4px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-weight: normal;\n"" +
+                  ""    font-size: small;\n"" +
+                  ""    background-color: #e8e8e8;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.offset {\n"" +
+                  ""    padding-left: 32px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.footer {\n"" +
+                  ""    font-size: 75%;\n"" +
+                  ""    text-align: right;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.icon {\n"" +
+                  ""    padding-left: 24px;\n"" +
+                  ""    text-decoration: none;\n"" +
+                  ""    color: black;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.icon:hover {\n"" +
+                  ""    text-decoration: underline;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""table {\n"" +
+                  ""    border: 1px solid;\n"" +
+                  ""    border-spacing: 0px;\n"" +
+                  ""    width: 100%;\n"" +
+                  ""    border-collapse: collapse;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.odd {\n"" +
+                  ""    background-color: #f3f6fa;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.odd td {\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-size: smaller;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.even {\n"" +
+                  ""    background-color: #ffffff;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.even td {\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-size: smaller;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.eveninvis td {\n"" +
+                  ""    color: #ffffff;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.oddinvis td {\n"" +
+                  ""    color: #f3f6fa\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.up {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4y2P4//8/Ay7sM4nhPwjjUwMm0ua//Y+M0+e//QrSGDAfgvEZAjdgydHXcAzTXLjWDoxhhqBbhGLA1N0vwBhdM7ohMHVwA8yrzn4zLj/936j8FE7N6IaA1IL0gPQy2DVc+rnp3FeCmtENAekB6WXw7Lz1tWD5x/+wEIdhdI3o8iA9IL0MYZMfvq9a9+V/w+avcIzLAGQ1ID0gvQxJc56/aNn29X/vnm9wjMsAZDWtQD0gvQwFy94+6N37/f/Moz/gGJcByGpAekB6GarXf7427ciP/0vP/YRjdP/CMLIakB6QXobKDd9PN+769b91P2kYpAekl2HJhb8r11/583/9ZRIxUM+8U783MQCBGBDXAHEbibgGrBdfTiMGU2wAAPz+nxp+TnhDAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.dir {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAAA+UlEQVQ4jWP4//8/AyUYTKTNf/sfGafPf/s1be47G5IMWHL0NRxP2f3mbcaCtz/RDUbHKAZM3f2CJAw3wLzq7Dfj8tP/jcpPkYRBekB6GewaLv3cdO7r/y0XSMMgPSC9DJ6dt74WLP/4v3TVZ5IwSA9IL0PY5Ifvq9Z9+d+w+StJGKQHpJchac7zFy3bvv7v3fONJNwK1APSy5C/7O2D3r3f/888+oMkDNID0stQvf7ztWlHfvxfeu4nSRikB6SXoXLD99ONu379b91PGgbpAellWHLh38r1V/78X3+ZRAzUM/fUr00MQCAGxDVA3EYirgHrpUpupAQDAPs+7c1tGDnPAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.file {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAABM0lEQVQ4y5WSTW6DMBCF3xvzc4wuOEIO0kVAuUB7vJ4g3KBdoHSRROomEpusUaoAcaYLfmKoqVRLIxnJ7/M3YwJVBcknACv8b+1U9SvoP1bXa/3WNDVIAQmQBLsNOEsGQYAwDNcARgDqusbl+wIRA2NkBEyqP0s+kCOAQhhjICJdkaDIJDwEvQAhH+G+SHagWTsi4jHoAWYIOxYDZDjnb8Fn4Akvz6AHcAbx3Tp5ETwI3RwckyVtv4Fr4VEe9qq6bDB5tlnYWou2bWGtRRRF6jdwAm5Za1FVFc7nM0QERVG8A9hPDRaGpapomgZlWSJJEuR5ftpsNq8ADr9amC+SuN/vuN1uIIntdnvKsuwZwKf2wxgBxpjpX+dA4jjW4/H4kabpixt2AbvAmDX+XnsAB509ww+A8mAar+XXgQAAAABJRU5ErkJggg==') left center no-repeat;\n"" +
+                  ""}"";
+
+        public static final ByteBuffer FILE_CSS_BUFFER;
+        public static final ByteBuffer FILE_JS_BUFFER;
+
+        static {
+            try {
+                byte[] bytes = FILE_CSS.getBytes(""US-ASCII"");
+                FILE_CSS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
+                FILE_CSS_BUFFER.put(bytes);
+                FILE_CSS_BUFFER.flip();
+
+                bytes = FILE_JS.getBytes(""US-ASCII"");
+                FILE_JS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
+                FILE_JS_BUFFER.put(bytes);
+                FILE_JS_BUFFER.flip();
+            } catch (Exception e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+    }
+}",2013-03-05T01:11:01Z,374
"@@ -0,0 +1,68 @@
+package io.undertow.server.handlers.resource;
+
+import java.util.Date;
+import java.util.List;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.ETag;
+import io.undertow.util.MimeMappings;
+
+/**
+ * Representation of a static resource.
+ *
+ *
+ * @author Stuart Douglas
+ */
+public interface Resource {
+
+    /**
+     *
+     * @return The last modified date of this resource, or null if this cannot be determined
+     */
+    Date getLastModified();
+
+    /**
+     *
+     * @return The resources etags
+     */
+    ETag getETag();
+
+    /**
+     *
+     * @return The name of the resource
+     */
+    String getName();
+
+    /**
+     *
+     * @return <code>true</code> if this resource represents a directory
+     */
+    boolean isDirectory();
+
+    /**
+     *
+     * @return a list of resources in this directory
+     */
+    List<Resource> list();
+
+    /**
+     * Return the resources content type. In most cases this will simply use the provided
+     * mime mappings, however in some cases the resource may have additional information as
+     * to the actual content type.
+     *
+     */
+    String getContentType(final MimeMappings mimeMappings);
+
+    /**
+     * Serve the resource, and end the exchange when done
+     *
+     * @param exchange The exchange
+     */
+    void serve(final HttpServerExchange exchange);
+
+    /**
+     *
+     * @return The content length, or null if it is unknown
+     */
+    Long getContentLength();
+}",2013-03-05T01:11:01Z,425
"@@ -0,0 +1,175 @@
+package io.undertow.server.handlers.resource;
+
+import java.util.Date;
+
+import io.undertow.predicate.Predicate;
+import io.undertow.predicate.TruePredicate;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.cache.ResponseCache;
+import io.undertow.util.DateUtils;
+import io.undertow.util.ETag;
+import io.undertow.util.ETagUtils;
+import io.undertow.util.Headers;
+import io.undertow.util.Methods;
+import io.undertow.util.MimeMappings;
+import io.undertow.util.WorkerDispatcher;
+
+/**
+ * @author Stuart Douglas
+ */
+public class ResourceHandler implements HttpHandler {
+
+    /**
+     * If directory listing is enabled.
+     */
+    private volatile boolean directoryListingEnabled = false;
+
+    /**
+     * The mime mappings that are used to determine the content type.
+     */
+    private volatile MimeMappings mimeMappings = MimeMappings.DEFAULT;
+
+    private volatile Predicate<HttpServerExchange> cachable = TruePredicate.instance();
+
+    private volatile Predicate<HttpServerExchange> allowed = TruePredicate.instance();
+
+    private volatile ResourceManager resourceManager;
+
+
+    @Override
+    public void handleRequest(final HttpServerExchange exchange) {
+        if (exchange.getRequestMethod().equals(Methods.GET) ||
+                exchange.getRequestMethod().equals(Methods.POST)) {
+            serveResource(exchange, true);
+        } else if (exchange.getRequestMethod().equals(Methods.HEAD)) {
+            serveResource(exchange, false);
+        } else {
+            exchange.setResponseCode(405);
+            exchange.endExchange();
+        }
+    }
+
+    private void serveResource(final HttpServerExchange exchange, final boolean sendContent) {
+
+        if(DirectoryUtils.sendRequestedBlobs(exchange)) {
+            return;
+        }
+
+        if (!allowed.resolve(exchange)) {
+            exchange.setResponseCode(403);
+            exchange.endExchange();
+        }
+
+        ResponseCache cache = exchange.getAttachment(ResponseCache.ATTACHMENT_KEY);
+        if (cache != null && cachable.resolve(exchange)) {
+            if (cache.tryServeResponse()) {
+                return;
+            }
+        }
+
+        //we now dispatch to a worker thread
+        //as resource manager methods are potentially blocking
+        WorkerDispatcher.dispatch(exchange, new Runnable() {
+            @Override
+            public void run() {
+                Resource resource = resourceManager.getResource(exchange.getRelativePath());
+                if (resource == null) {
+                    exchange.setResponseCode(404);
+                    exchange.endExchange();
+                    return;
+                }
+
+                if (resource.isDirectory()) {
+                    DirectoryUtils.renderDirectoryListing(exchange, resource);
+                    return;
+                }
+
+                final ETag etag = resource.getETag();
+                final Date lastModified = resource.getLastModified();
+                if (!ETagUtils.handleIfMatch(exchange, etag, false) ||
+                        !DateUtils.handleIfUnmodifiedSince(exchange, lastModified)) {
+                    exchange.setResponseCode(412);
+                    exchange.endExchange();
+                    return;
+                }
+                if (!ETagUtils.handleIfNoneMatch(exchange, etag, true) ||
+                        !DateUtils.handleIfModifiedSince(exchange, lastModified)) {
+                    exchange.setResponseCode(304);
+                    exchange.endExchange();
+                    return;
+                }
+                //todo: handle range requests
+                //we are going to proceed. Set the appropriate headers
+                final String contentType = resource.getContentType(mimeMappings);
+                if (contentType != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);
+                } else {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
+                }
+                if (lastModified != null) {
+                    exchange.getResponseHeaders().put(Headers.LAST_MODIFIED, DateUtils.toDateString(lastModified));
+                }
+                if (etag != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, etag.toString());
+                }
+                Long contentLength = resource.getContentLength();
+                if (contentLength != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, contentLength.toString());
+                }
+                if(!sendContent) {
+                    exchange.endExchange();
+                } else {
+                    resource.serve(exchange);
+                }
+            }
+        });
+
+
+    }
+
+    public boolean isDirectoryListingEnabled() {
+        return directoryListingEnabled;
+    }
+
+    public ResourceHandler setDirectoryListingEnabled(final boolean directoryListingEnabled) {
+        this.directoryListingEnabled = directoryListingEnabled;
+        return this;
+    }
+
+    public MimeMappings getMimeMappings() {
+        return mimeMappings;
+    }
+
+    public ResourceHandler setMimeMappings(final MimeMappings mimeMappings) {
+        this.mimeMappings = mimeMappings;
+        return this;
+    }
+
+    public Predicate<HttpServerExchange> getCachable() {
+        return cachable;
+    }
+
+    public ResourceHandler setCachable(final Predicate<HttpServerExchange> cachable) {
+        this.cachable = cachable;
+        return this;
+    }
+
+    public Predicate<HttpServerExchange> getAllowed() {
+        return allowed;
+    }
+
+    public ResourceHandler setAllowed(final Predicate<HttpServerExchange> allowed) {
+        this.allowed = allowed;
+        return this;
+    }
+
+    public ResourceManager getResourceManager() {
+        return resourceManager;
+    }
+
+    public ResourceHandler setResourceManager(final ResourceManager resourceManager) {
+        this.resourceManager = resourceManager;
+        return this;
+    }
+}",2013-03-05T01:11:01Z,426
"@@ -0,0 +1,22 @@
+package io.undertow.server.handlers.resource;
+
+/**
+ *
+ * Representation of a resource manager. A resource manager knows how to obtain
+ * a resource for a given path.
+ *
+ * @author Stuart Douglas
+ */
+public interface ResourceManager {
+
+    /**
+     * Returns a resource for the given path.
+     *
+     * It is the responsibility of the called to make sure that the path in Canonicalised.
+     *
+     * @param path The path
+     * @return The resource representing the path, or null if no resource was found.
+     */
+    Resource getResource(final String path);
+
+}",2013-03-05T01:11:01Z,427
"@@ -0,0 +1,146 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.resource.file;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.channels.Channel;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.undertow.UndertowLogger;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.resource.Resource;
+import io.undertow.util.ETag;
+import io.undertow.util.MimeMappings;
+import org.jboss.logging.Logger;
+import org.xnio.ChannelListener;
+import org.xnio.FileAccess;
+import org.xnio.IoUtils;
+import org.xnio.channels.Channels;
+import org.xnio.channels.StreamSinkChannel;
+
+/**
+ * A file resource
+ *
+ * @author Stuart Douglas
+ */
+public class FileResource implements Resource {
+
+    private static final Logger log = Logger.getLogger(""io.undertow.server.resources.file"");
+
+    private final File file;
+
+    public FileResource(final File file) {
+        this.file = file;
+    }
+
+    @Override
+    public Date getLastModified() {
+        return new Date(file.lastModified());
+    }
+
+    @Override
+    public ETag getETag() {
+        return null;
+    }
+
+    @Override
+    public String getName() {
+        return file.getName();
+    }
+
+    @Override
+    public boolean isDirectory() {
+        return file.isDirectory();
+    }
+
+    @Override
+    public List<Resource> list() {
+        final List<Resource> resources = new ArrayList<Resource>();
+        for (String f : file.list()) {
+            final File child = new File(file, f);
+            resources.add(new FileResource(child));
+        }
+        return resources;
+    }
+
+    @Override
+    public String getContentType(final MimeMappings mimeMappings) {
+        final String fileName = file.getName();
+        int index = fileName.lastIndexOf('.');
+        if (index != -1 && index != fileName.length() - 1) {
+            return mimeMappings.getMimeType(fileName.substring(index + 1));
+        }
+        return null;
+    }
+
+    @Override
+    public void serve(final HttpServerExchange exchange) {
+        //TODO: should be using async IO here as much as possible
+        final FileChannel fileChannel;
+        try {
+            try {
+                fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
+            } catch (FileNotFoundException e) {
+                exchange.setResponseCode(404);
+                exchange.endExchange();
+                return;
+            }
+        } catch (IOException e) {
+            UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
+            exchange.setResponseCode(500);
+            exchange.endExchange();
+            return;
+        }
+
+        final StreamSinkChannel response = exchange.getResponseChannel();
+        response.getCloseSetter().set(new ChannelListener<Channel>() {
+            public void handleEvent(final Channel channel) {
+                IoUtils.safeClose(fileChannel);
+            }
+        });
+
+
+        try {
+            log.tracef(""Serving file %s (blocking)"", fileChannel);
+            Channels.transferBlocking(response, fileChannel, 0, file.length());
+            log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
+            response.shutdownWrites();
+            log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
+            Channels.flushBlocking(response);
+            log.tracef(""Finished serving %s (complete)"", fileChannel);
+            exchange.endExchange();
+        } catch (IOException ignored) {
+            log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
+            exchange.endExchange();
+            IoUtils.safeClose(response);
+        } finally {
+            IoUtils.safeClose(fileChannel);
+        }
+    }
+
+    @Override
+    public Long getContentLength() {
+        return file.length();
+    }
+}",2013-03-05T01:11:01Z,116
"@@ -0,0 +1,68 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.resource.file;
+
+import java.io.File;
+
+import io.undertow.UndertowMessages;
+import io.undertow.server.handlers.resource.Resource;
+import io.undertow.server.handlers.resource.ResourceManager;
+/**
+ * Serves files from the file system.
+ */
+public class FileResourceManager implements ResourceManager {
+
+    private volatile File base;
+
+    public FileResourceManager(final File base) {
+        if (base == null) {
+            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
+        }
+        this.base = base;
+    }
+
+    public File getBase() {
+        return base;
+    }
+
+    public FileResourceManager setBase(final File base) {
+        if (base == null) {
+            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
+        }
+        this.base = base;
+        return this;
+    }
+
+    public Resource getResource(final String p) {
+        String path = p;
+        if (File.separatorChar != '/') {
+            if (path.indexOf(File.separatorChar) != -1) {
+                return null;
+            }
+            path = path.replace('/', File.separatorChar);
+        }
+
+        final File file = new File(base, path);
+        if(file.exists()) {
+            return new FileResource(file);
+        } else {
+            return null;
+        }
+    }
+}",2013-03-05T01:11:01Z,116
"@@ -21,6 +21,15 @@ public String getTag() {
         return tag;
     }
 
+    @Override
+    public String toString() {
+        if(weak) {
+            return ""W/\"""" + tag + ""\"""";
+        } else {
+            return ""\"""" + tag + ""\"""";
+        }
+    }
+
     @Override
     public boolean equals(final Object o) {
         if (this == o) return true;",2013-03-05T01:11:01Z,428
"@@ -32,7 +32,8 @@
 import io.undertow.server.handlers.cache.CacheHandler;
 import io.undertow.server.handlers.cache.CachedHttpRequest;
 import io.undertow.server.handlers.cache.DirectBufferCache;
-import io.undertow.server.handlers.file.FileHandler;
+import io.undertow.server.handlers.resource.ResourceHandler;
+import io.undertow.server.handlers.resource.file.FileResourceManager;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
@@ -56,7 +57,8 @@ public class FileHandlerStressTestCase {
     public void simpleFileStressTest() throws IOException, ExecutionException, InterruptedException {
         ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
         try {
-            final FileHandler handler = new FileHandler(new File(getClass().getResource(""page.html"").getFile()).getParentFile());
+            final ResourceHandler handler = new ResourceHandler()
+                    .setResourceManager(new FileResourceManager(new File(getClass().getResource(""page.html"").getFile()).getParentFile()));
 
             final CacheHandler cacheHandler = new CacheHandler(new DirectBufferCache<CachedHttpRequest>(1024, 10480), handler);
             final PathHandler path = new PathHandler();",2013-03-05T01:11:01Z,60
"@@ -23,13 +23,14 @@
 
 import io.undertow.server.handlers.CanonicalPathHandler;
 import io.undertow.server.handlers.PathHandler;
-import io.undertow.server.handlers.file.FileHandler;
+import io.undertow.server.handlers.resource.ResourceHandler;
+import io.undertow.server.handlers.resource.file.FileResourceManager;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
+import io.undertow.util.TestHttpClient;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,13 +46,11 @@ public class FileHandlerTestCase {
     public void testFileIsServed() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            final FileHandler handler = new FileHandler(new File(getClass().getResource(""page.html"").getFile()).getParentFile());
-            handler.setDirectoryListingEnabled(true);
-            final PathHandler path = new PathHandler();
-            path.addPath(""/path"", handler);
-            final CanonicalPathHandler root = new CanonicalPathHandler();
-            root.setNext(path);
-            DefaultServer.setRootHandler(root);
+            DefaultServer.setRootHandler(new CanonicalPathHandler()
+                    .setNext(new PathHandler()
+                            .addPath(""/path"", new ResourceHandler()
+                                    .setResourceManager(new FileResourceManager(new File(getClass().getResource(""page.html"").getFile()).getParentFile()))
+                                    .setDirectoryListingEnabled(true))));
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path/page.html"");
             HttpResponse result = client.execute(get);",2013-03-05T01:11:01Z,79
"@@ -380,7 +380,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
             lifecycles.add(managedDefaultServlet);
             pathMatches.add(""/*"");
             defaultServlet = new ServletHandler(managedDefaultServlet);
-            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, managedDefaultServlet);
+            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), threadSetupAction, servletContext, managedDefaultServlet);
         }
 
         final ServletPathMatches.Builder builder = ServletPathMatches.builder();",2013-03-05T01:11:01Z,80
"@@ -37,10 +37,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.file.DirectFileSource;
-import io.undertow.server.handlers.file.FileSource;
 import io.undertow.servlet.api.DefaultServletConfig;
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
@@ -64,11 +61,10 @@
  *
  * @author Stuart Douglas
  */
-public class DefaultServlet extends HttpServlet implements HttpHandler {
+public class DefaultServlet extends HttpServlet {
 
 
     private final Deployment deployment;
-    private volatile FileSource fileSource = DirectFileSource.INSTANCE;
     private final DefaultServletConfig config;
 
     private final List<String> welcomePages;
@@ -134,7 +130,7 @@ private void serveFileBlocking(final HttpServletResponse resp, final File resour
             IoUtils.safeClose(in);
         }
     }
-
+/*
     @Override
     public void handleRequest(final HttpServerExchange exchange) {
         if (!isAllowed(exchange.getRelativePath())) {
@@ -169,7 +165,7 @@ private void handleWelcomePage(final HttpServerExchange exchange, final File res
                 exchange.endExchange();
             }
         }
-    }
+    }*/
 
     private void handleWelcomePage(final HttpServletRequest req, final HttpServletResponse resp, final File resource) throws IOException, ServletException {
         File welcomePage = findWelcomeFile(resource);
@@ -274,11 +270,4 @@ private boolean isAllowed(String path) {
         }
     }
 
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public void setFileSource(final FileSource fileSource) {
-        this.fileSource = fileSource;
-    }
 }",2013-03-05T01:11:01Z,155
"@@ -141,7 +141,7 @@ public boolean tryServeResponse(boolean markCacheable) {
             exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, existingKey.getLanguage());
         }
         if(etag != null) {
-            exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, (etag.isWeak() ? ""w/\"""" :""\"""") + etag.getTag() + ""\"""");
+            exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, etag.toString());
         }
 
         //TODO: support if-range",2013-03-05T01:11:01Z,422
"@@ -19,19 +19,29 @@
 package io.undertow.server.handlers.error;
 
 import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.channels.Channel;
+import java.nio.channels.FileChannel;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
-import io.undertow.UndertowMessages;
+import io.undertow.UndertowLogger;
 import io.undertow.server.DefaultResponseListener;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.HttpHandlers;
 import io.undertow.server.handlers.ResponseCodeHandler;
-import io.undertow.server.handlers.file.DirectFileSource;
-import io.undertow.server.handlers.file.FileSource;
+import io.undertow.util.Headers;
+import io.undertow.util.WorkerDispatcher;
+import org.jboss.logging.Logger;
+import org.xnio.ChannelListener;
+import org.xnio.FileAccess;
+import org.xnio.IoUtils;
+import org.xnio.channels.Channels;
+import org.xnio.channels.StreamSinkChannel;
 
 /**
  * Handler that serves up a file from disk to serve as an error page.
@@ -43,6 +53,7 @@
  */
 public class FileErrorPageHandler implements HttpHandler {
 
+    private static final Logger log = Logger.getLogger(""io.undertow.server.error.file"");
     private volatile HttpHandler next = ResponseCodeHandler.HANDLE_404;
 
     /**
@@ -52,8 +63,6 @@ public class FileErrorPageHandler implements HttpHandler {
 
     private volatile File file;
 
-    private volatile FileSource fileSource = DirectFileSource.INSTANCE;
-
     public FileErrorPageHandler(final File file, final Integer... responseCodes) {
         this.file = file;
         this.responseCodes = new HashSet<Integer>(Arrays.asList(responseCodes));
@@ -66,7 +75,7 @@ public void handleRequest(final HttpServerExchange exchange) {
             public boolean handleDefaultResponse(final HttpServerExchange exchange) {
                 Set<Integer> codes = responseCodes;
                 if (!exchange.isResponseStarted() && codes.contains(exchange.getResponseCode())) {
-                    fileSource.serveFile(exchange, file, false);
+                    serveFile(exchange);
                     return true;
                 }
                 return false;
@@ -76,6 +85,53 @@ public boolean handleDefaultResponse(final HttpServerExchange exchange) {
         HttpHandlers.executeHandler(next, exchange);
     }
 
+    private void serveFile(final HttpServerExchange exchange) {
+        WorkerDispatcher.dispatch(exchange, new Runnable() {
+            @Override
+            public void run() {
+                final FileChannel fileChannel;
+                try {
+                    try {
+                        fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
+                    } catch (FileNotFoundException e) {
+                        //TODO: how to handle this
+                        exchange.endExchange();
+                        return;
+                    }
+                } catch (IOException e) {
+                    UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
+                    exchange.endExchange();
+                    return;
+                }
+
+                final StreamSinkChannel response = exchange.getResponseChannel();
+                response.getCloseSetter().set(new ChannelListener<Channel>() {
+                    public void handleEvent(final Channel channel) {
+                        IoUtils.safeClose(fileChannel);
+                    }
+                });
+                exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, file.length());
+
+                try {
+                    log.tracef(""Serving file %s (blocking)"", fileChannel);
+                    Channels.transferBlocking(response, fileChannel, 0, file.length());
+                    log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
+                    response.shutdownWrites();
+                    log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
+                    Channels.flushBlocking(response);
+                    log.tracef(""Finished serving %s (complete)"", fileChannel);
+                    exchange.endExchange();
+                } catch (IOException ignored) {
+                    log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
+                    exchange.endExchange();
+                    IoUtils.safeClose(response);
+                } finally {
+                    IoUtils.safeClose(fileChannel);
+                }
+            }
+        });
+    }
+
     public HttpHandler getNext() {
         return next;
     }
@@ -112,16 +168,4 @@ public FileErrorPageHandler setFile(final File file) {
         this.file = file;
         return this;
     }
-
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public FileErrorPageHandler setFileSource(final FileSource fileSource) {
-        if(fileSource == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""fileCache"");
-        }
-        this.fileSource = fileSource;
-        return this;
-    }
 }",2013-03-05T01:11:01Z,423
"@@ -1,186 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.undertow.server.handlers.file;
-
-import java.nio.ByteBuffer;
-
-/**
- * Constant Content
- *
- * @author Jason T. Greene
- */
-public class Blobs {
-      public static final String FILE_JS=""function growit() {\n"" +
-              ""    var table = document.getElementById(\""thetable\"");\n"" +
-              ""\n"" +
-              ""    var i = table.rows.length - 1;\n"" +
-              ""    while (i-- > 0) {\n"" +
-              ""        if (table.rows[i].id == \""eraseme\"") {\n"" +
-              ""            table.deleteRow(i);\n"" +
-              ""        } else {\n"" +
-              ""            break;\n"" +
-              ""        }\n"" +
-              ""    }\n"" +
-              ""    table.style.height=\""\"";\n"" +
-              ""    var i = 0;\n"" +
-              ""    while (table.offsetHeight < window.innerHeight - 24) {\n"" +
-              ""        i++;\n"" +
-              ""        var tbody = table.tBodies[0];\n"" +
-              ""        var row = tbody.insertRow(tbody.rows.length);\n"" +
-              ""        row.id=\""eraseme\"";\n"" +
-              ""        var cell = row.insertCell(0);\n"" +
-              ""        if (table.rows.length % 2 != 0) {\n"" +
-              ""            row.className=\""even eveninvis\"";\n"" +
-              ""        } else {\n"" +
-              ""            row.className=\""odd oddinvis\"";\n"" +
-              ""        }\n"" +
-              ""\n"" +
-              ""        cell.colSpan=3;\n"" +
-              ""        cell.appendChild(document.createTextNode(\""i\""));\n"" +
-              ""    }\n"" +
-              ""    table.style.height=\""100%\"";\n"" +
-              ""    if (i > 0) {\n"" +
-              ""        document.documentElement.style.overflowY=\""hidden\"";\n"" +
-              ""    } else {\n"" +
-              ""        document.documentElement.style.overflowY=\""auto\"";\n"" +
-              ""    }\n"" +
-              ""}"";
-      public static final String FILE_CSS =
-              ""body {\n"" +
-              ""    font-family: \""Lucida Grande\"", \""Lucida Sans Unicode\"", \""Trebuchet MS\"", Helvetica, Arial, Verdana, sans-serif;\n"" +
-              ""    margin: 5px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.loc {\n"" +
-              ""    background-image: linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -o-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -moz-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -webkit-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    background-image: -ms-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
-              ""    \n"" +
-              ""    background-image: -webkit-gradient(\n"" +
-              ""        linear,\n"" +
-              ""        left bottom,\n"" +
-              ""        left top,\n"" +
-              ""        color-stop(0.08, rgb(153,151,153)),\n"" +
-              ""        color-stop(0.54, rgb(199,199,199))\n"" +
-              ""    );\n"" +
-              ""    color: black;\n"" +
-              ""    padding: 2px;\n"" +
-              ""    font-weight: normal;\n"" +
-              ""    border: solid 1px;\n"" +
-              ""    font-size: 150%;\n"" +
-              ""    text-align: left;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.label {\n"" +
-              ""    border: solid  1px;\n"" +
-              ""    text-align: left;\n"" +
-              ""    padding: 4px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-weight: normal;\n"" +
-              ""    font-size: small;\n"" +
-              ""    background-color: #e8e8e8;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.offset {\n"" +
-              ""    padding-left: 32px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""th.footer {\n"" +
-              ""    font-size: 75%;\n"" +
-              ""    text-align: right;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.icon {\n"" +
-              ""    padding-left: 24px;\n"" +
-              ""    text-decoration: none;\n"" +
-              ""    color: black;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.icon:hover {\n"" +
-              ""    text-decoration: underline;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""table {\n"" +
-              ""    border: 1px solid;\n"" +
-              ""    border-spacing: 0px;\n"" +
-              ""    width: 100%;\n"" +
-              ""    border-collapse: collapse;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.odd {\n"" +
-              ""    background-color: #f3f6fa;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.odd td {\n"" +
-              ""    padding: 2px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-size: smaller;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.even {\n"" +
-              ""    background-color: #ffffff;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.even td {\n"" +
-              ""    padding: 2px;\n"" +
-              ""    padding-left: 8px;\n"" +
-              ""    font-size: smaller;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.eveninvis td {\n"" +
-              ""    color: #ffffff;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""tr.oddinvis td {\n"" +
-              ""    color: #f3f6fa\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.up {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4y2P4//8/Ay7sM4nhPwjjUwMm0ua//Y+M0+e//QrSGDAfgvEZAjdgydHXcAzTXLjWDoxhhqBbhGLA1N0vwBhdM7ohMHVwA8yrzn4zLj/936j8FE7N6IaA1IL0gPQy2DVc+rnp3FeCmtENAekB6WXw7Lz1tWD5x/+wEIdhdI3o8iA9IL0MYZMfvq9a9+V/w+avcIzLAGQ1ID0gvQxJc56/aNn29X/vnm9wjMsAZDWtQD0gvQwFy94+6N37/f/Moz/gGJcByGpAekB6GarXf7427ciP/0vP/YRjdP/CMLIakB6QXobKDd9PN+769b91P2kYpAekl2HJhb8r11/583/9ZRIxUM+8U783MQCBGBDXAHEbibgGrBdfTiMGU2wAAPz+nxp+TnhDAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.dir {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAAA+UlEQVQ4jWP4//8/AyUYTKTNf/sfGafPf/s1be47G5IMWHL0NRxP2f3mbcaCtz/RDUbHKAZM3f2CJAw3wLzq7Dfj8tP/jcpPkYRBekB6GewaLv3cdO7r/y0XSMMgPSC9DJ6dt74WLP/4v3TVZ5IwSA9IL0PY5Ifvq9Z9+d+w+StJGKQHpJchac7zFy3bvv7v3fONJNwK1APSy5C/7O2D3r3f/888+oMkDNID0stQvf7ztWlHfvxfeu4nSRikB6SXoXLD99ONu379b91PGgbpAellWHLh38r1V/78X3+ZRAzUM/fUr00MQCAGxDVA3EYirgHrpUpupAQDAPs+7c1tGDnPAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
-              ""}\n"" +
-              ""\n"" +
-              ""a.file {\n"" +
-              ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAABM0lEQVQ4y5WSTW6DMBCF3xvzc4wuOEIO0kVAuUB7vJ4g3KBdoHSRROomEpusUaoAcaYLfmKoqVRLIxnJ7/M3YwJVBcknACv8b+1U9SvoP1bXa/3WNDVIAQmQBLsNOEsGQYAwDNcARgDqusbl+wIRA2NkBEyqP0s+kCOAQhhjICJdkaDIJDwEvQAhH+G+SHagWTsi4jHoAWYIOxYDZDjnb8Fn4Akvz6AHcAbx3Tp5ETwI3RwckyVtv4Fr4VEe9qq6bDB5tlnYWou2bWGtRRRF6jdwAm5Za1FVFc7nM0QERVG8A9hPDRaGpapomgZlWSJJEuR5ftpsNq8ADr9amC+SuN/vuN1uIIntdnvKsuwZwKf2wxgBxpjpX+dA4jjW4/H4kabpixt2AbvAmDX+XnsAB509ww+A8mAar+XXgQAAAABJRU5ErkJggg==') left center no-repeat;\n"" +
-              ""}"";
-
-    public static final ByteBuffer FILE_CSS_BUFFER;
-    public static final ByteBuffer FILE_JS_BUFFER;
-
-    static {
-        try {
-            byte[] bytes = FILE_CSS.getBytes(""US-ASCII"");
-            FILE_CSS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
-            FILE_CSS_BUFFER.put(bytes);
-            FILE_CSS_BUFFER.flip();
-
-            bytes = FILE_JS.getBytes(""US-ASCII"");
-            FILE_JS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
-            FILE_JS_BUFFER.put(bytes);
-            FILE_JS_BUFFER.flip();
-        } catch (Exception e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-}",2013-03-05T01:11:01Z,104
"@@ -1,148 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.nio.channels.Channel;
-import java.nio.channels.FileChannel;
-
-import io.undertow.UndertowLogger;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.cache.ResponseCache;
-import io.undertow.util.HttpString;
-import io.undertow.util.WorkerDispatcher;
-import org.jboss.logging.Logger;
-import org.xnio.ChannelListener;
-import org.xnio.FileAccess;
-import org.xnio.IoUtils;
-import org.xnio.channels.Channels;
-import org.xnio.channels.StreamSinkChannel;
-
-import static io.undertow.util.Headers.CONTENT_LENGTH;
-import static io.undertow.util.Methods.GET;
-import static io.undertow.util.Methods.HEAD;
-
-/**
- * A file cache that serves files directly with no caching.
- *
- * @author Stuart Douglas
- */
-public class DirectFileSource implements FileSource {
-
-    private static final Logger log = Logger.getLogger(""io.undertow.server.handlers.file"");
-
-    public static final FileSource INSTANCE = new DirectFileSource();
-
-    @Override
-    public void serveFile(final HttpServerExchange exchange, final File file, final boolean directoryListingEnabled) {
-        // ignore request body
-
-        //try and serve a cached version, and also mark the response as cachable
-        final ResponseCache cache = exchange.getAttachment(ResponseCache.ATTACHMENT_KEY);
-        if(cache != null) {
-            if(cache.tryServeResponse()) {
-                return;
-            }
-        }
-        WorkerDispatcher.dispatch(exchange, new FileWriteTask(exchange, file, directoryListingEnabled));
-    }
-
-    private static class FileWriteTask implements Runnable {
-
-        private final HttpServerExchange exchange;
-        private final File file;
-        private final boolean directoryListingEnabled;
-
-        private FileWriteTask(final HttpServerExchange exchange, final File file, final boolean directoryListingEnabled) {
-            this.exchange = exchange;
-            this.file = file;
-            this.directoryListingEnabled = directoryListingEnabled;
-        }
-
-        @Override
-        public void run() {
-
-            if(file.isDirectory()) {
-                if (directoryListingEnabled) {
-                    FileHandler.renderDirectoryListing(exchange, file);
-                } else {
-                    exchange.setResponseCode(404);
-                    exchange.endExchange();
-                }
-                return;
-            }
-
-            final HttpString method = exchange.getRequestMethod();
-            final FileChannel fileChannel;
-            final long length;
-            try {
-                try {
-                    fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
-                } catch (FileNotFoundException e) {
-                    exchange.setResponseCode(404);
-                    exchange.endExchange();
-                    return;
-                }
-                length = fileChannel.size();
-            } catch (IOException e) {
-                UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
-                exchange.setResponseCode(500);
-                exchange.endExchange();
-                return;
-            }
-            if (!method.equals(GET) && !method.equals(HEAD)) {
-                exchange.setResponseCode(500);
-                exchange.endExchange();
-                return;
-            }
-
-            exchange.getResponseHeaders().put(CONTENT_LENGTH, Long.toString(length));
-            if (method.equals(HEAD)) {
-                exchange.endExchange();
-                return;
-            }
-            final StreamSinkChannel response = exchange.getResponseChannel();
-            response.getCloseSetter().set(new ChannelListener<Channel>() {
-                public void handleEvent(final Channel channel) {
-                    IoUtils.safeClose(fileChannel);
-                }
-            });
-
-
-            try {
-                log.tracef(""Serving file %s (blocking)"", fileChannel);
-                Channels.transferBlocking(response, fileChannel, 0, length);
-                log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
-                response.shutdownWrites();
-                log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
-                Channels.flushBlocking(response);
-                log.tracef(""Finished serving %s (complete)"", fileChannel);
-                exchange.endExchange();
-            } catch (IOException ignored) {
-                log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
-                exchange.endExchange();
-                IoUtils.safeClose(response);
-            } finally {
-                IoUtils.safeClose(fileChannel);
-            }
-        }
-    }
-}",2013-03-05T01:11:01Z,61
"@@ -1,269 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import io.undertow.UndertowMessages;
-import io.undertow.io.IoCallback;
-import io.undertow.server.HttpHandler;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
-import io.undertow.util.Methods;
-import io.undertow.util.MimeMappings;
-import org.xnio.channels.Channels;
-
-/**
- *
- * Serves files direct from the file system.
- *
- * @author Stuart Douglas
- * @author Jason T. Greene
- */
-public class FileHandler implements HttpHandler {
-
-    private volatile File base;
-    private volatile FileSource fileSource = new DirectFileSource();
-    private volatile boolean directoryListingEnabled = false;
-    private volatile MimeMappings mimeMappings = MimeMappings.DEFAULT;
-
-    public FileHandler(final File base) {
-        if (base == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
-        }
-        this.base = base;
-    }
-
-    @Override
-    public void handleRequest(final HttpServerExchange exchange) {
-        String path = exchange.getRelativePath();
-        if (File.separatorChar != '/') {
-            if (path.indexOf(File.separatorChar) != -1) {
-                exchange.setResponseCode(404);
-                exchange.endExchange();
-                return;
-            }
-            path = path.replace('/', File.separatorChar);
-        }
-
-        if (sendRequestedBlobs(exchange)) {
-            return;
-        }
-
-        final File file = new File(base, path);
-        if(mimeMappings != null) {
-            final String fileName = file.getName();
-            int index = fileName.lastIndexOf('.');
-            if(index != -1 && index != fileName.length() - 1) {
-                final String mime = mimeMappings.getMimeType(fileName.substring(index +1));
-                if(mime != null) {
-                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, mime);
-                } else {
-                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
-                }
-            } else {
-                exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
-            }
-        }
-        fileSource.serveFile(exchange, file, directoryListingEnabled);
-    }
-
-    public File getBase() {
-        return base;
-    }
-
-    public FileHandler setBase(final File base) {
-        if (base == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
-        }
-        this.base = base;
-        return this;
-    }
-
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public FileHandler setFileSource(final FileSource fileSource) {
-        if (fileSource == null) {
-            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""fileCache"");
-        }
-        this.fileSource = fileSource;
-        return this;
-    }
-
-    private boolean sendRequestedBlobs(HttpServerExchange exchange) {
-        ByteBuffer buffer = null;
-        String type = null;
-        if (""css"".equals(exchange.getQueryString())) {
-            buffer = Blobs.FILE_CSS_BUFFER.duplicate();
-            type = ""text/css"";
-        } else if (""js"".equals(exchange.getQueryString())) {
-            buffer = Blobs.FILE_JS_BUFFER.duplicate();
-            type = ""application/javascript"";
-        }
-
-        if (buffer != null) {
-            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(buffer.limit()));
-            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, type);
-            if (Methods.HEAD.equals(exchange.getRequestMethod())) {
-                exchange.endExchange();
-                return true;
-            }
-            exchange.getResponseSender().send(buffer, IoCallback.END_EXCHANGE);
-
-            return true;
-        }
-
-        return false;
-    }
-
-    public static void renderDirectoryListing(HttpServerExchange exchange, File file) {
-        String requestPath = exchange.getRequestPath();
-        if (! requestPath.endsWith(""/"")) {
-            exchange.setResponseCode(302);
-            exchange.getResponseHeaders().put(Headers.LOCATION, requestPath + ""/"");
-            exchange.endExchange();
-            return;
-        }
-
-        // TODO - Fix exchange to sanitize path, so handlers don't need to do this
-        String resolvedPath = exchange.getResolvedPath();
-        for (int i = 0; i < resolvedPath.length(); i++) {
-            if (resolvedPath.charAt(i) != '/') {
-                resolvedPath = resolvedPath.substring(Math.max(0, i - 1));
-                break;
-            }
-        }
-
-        StringBuilder builder = new StringBuilder();
-        builder.append(""<html><head><script src='"").append(resolvedPath).append(""?js'></script>"")
-                .append(""<link rel='stylesheet' type='txt/css' href='"").append(resolvedPath).append(""?css'/></head>"");
-        builder.append(""<body onresize='growit()' onload='growit()'><table id='thetable'><thead>"");
-        builder.append(""<tr><th class='loc' colspan='3'>Directory Listing - "").append(requestPath)
-                .append(""<tr><th class='label offset'>Name</th><th class='label'>Last Modified</th><th class='label'>Size</th></tr></thead>"")
-                .append(""<tfoot><tr><th class=\""loc footer\"" colspan=\""3\"">Powered by Undertow</th></tr></tfoot><tbody>"");
-
-        int state  = 0;
-        String parent = null;
-        for (int i = requestPath.length() - 1; i >= 0; i--) {
-            if (state == 1) {
-                if (requestPath.charAt(i) == '/') {
-                    state = 2;
-                }
-            } else if (requestPath.charAt(i) != '/') {
-                if (state == 2) {
-                    parent = requestPath.substring(0, i + 1);
-                    break;
-                }
-                state = 1;
-            }
-        }
-
-        SimpleDateFormat format = new SimpleDateFormat(""MMM dd, yyyy HH:mm:ss"");
-        int i = 0;
-        if (parent != null) {
-            i++;
-            builder.append(""<tr class='odd'><td><a class='icon up' href='"").append(parent).append(""'>[..]</a></td><td>"");
-            builder.append(format.format(new Date(file.lastModified()))).append(""</td><td>--</td></tr>"");
-        }
-
-        for (File entry : file.listFiles()) {
-            builder.append(""<tr class='"").append((++i & 1) == 1 ? ""odd"" : ""even"").append(""'><td><a class='icon "");
-            builder.append(entry.isFile() ? ""file"" : ""dir"");
-            builder.append(""' href='"").append(entry.getName()).append(""'>"").append(entry.getName()).append(""</a></td><td>"");
-            builder.append(format.format(new Date(entry.lastModified()))).append(""</td><td>"");
-            if (entry.isFile()) {
-                formatSize(builder, entry.length());
-            } else {
-                builder.append(""--"");
-            }
-            builder.append(""</td></tr>"");
-        }
-        builder.append(""</tbody></table></body></html>"");
-
-        try {
-            ByteBuffer output = ByteBuffer.wrap(builder.toString().getBytes(""UTF-8""));
-            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(output.limit()));
-            Channels.writeBlocking(exchange.getResponseChannel(), output);
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException(e);
-        } catch (IOException e) {
-            exchange.setResponseCode(500);
-        }
-
-        exchange.endExchange();
-        return;
-    }
-
-
-    private static StringBuilder formatSize(StringBuilder builder, long size) {
-        int n = 1024 * 1024 * 1024;
-        int type = 0;
-        while (size < n && n >= 1024) {
-            n /= 1024;
-            type++;
-        }
-
-        long top = (size * 100) / n;
-        long bottom =  top % 100;
-        top /= 100;
-
-        builder.append(top);
-        if (bottom > 0) {
-            builder.append(""."").append(bottom / 10);
-            bottom %= 10;
-            if (bottom > 0) {
-                builder.append(bottom);
-            }
-
-        }
-
-        switch (type) {
-            case 0: builder.append("" GB""); break;
-            case 1: builder.append("" MB""); break;
-            case 2: builder.append("" KB""); break;
-        }
-
-        return builder;
-    }
-
-    public boolean isDirectoryListingEnabled() {
-        return directoryListingEnabled;
-    }
-
-    public FileHandler setDirectoryListingEnabled(final boolean directoryListingEnabled) {
-        this.directoryListingEnabled = directoryListingEnabled;
-        return this;
-    }
-
-    public MimeMappings getMimeMappings() {
-        return mimeMappings;
-    }
-
-    public FileHandler setMimeMappings(final MimeMappings mimeMappings) {
-        this.mimeMappings = mimeMappings;
-        return this;
-    }
-}",2013-03-05T01:11:01Z,424
"@@ -1,48 +0,0 @@
-/*
- * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
- * as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.undertow.server.handlers.file;
-
-import java.io.File;
-
-import io.undertow.server.HttpServerExchange;
-
-/**
- * A file cache that serves files directly to a client.
- *
- * @author Stuart Douglas
- */
-public interface FileSource {
-
-    /**
-     * Serves a file directly to the client, once the file has been transferred the completion handler is invoked.
-     * <p/>
-     * This method essentially takes over the request, once it has been invoked no further handlers should process
-     * the request.
-     * <p/>
-     * This method must set the Content-Length header on the {@link HttpServerExchange}.
-     *
-     *
-     * @param exchange                The exchange
-     * @param file                    The file to serve
-     * @param directoryListingEnabled If the handler should serve up a directory listing page
-     * @throws IllegalStateException If the response channel has already been acquired
-     */
-    void serveFile(final HttpServerExchange exchange, final File file, boolean directoryListingEnabled);
-
-}",2013-03-05T01:11:01Z,2
"@@ -0,0 +1,336 @@
+package io.undertow.server.handlers.resource;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.text.SimpleDateFormat;
+
+import io.undertow.io.IoCallback;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.Headers;
+import io.undertow.util.Methods;
+import org.xnio.channels.Channels;
+
+/**
+ * @author Stuart Douglas
+ */
+public class DirectoryUtils {
+
+    /**
+     * Serve static resource for the directory listing
+     *
+     * @param exchange The exchange
+     * @return true if resources were served
+     */
+    public static boolean sendRequestedBlobs(HttpServerExchange exchange) {
+        ByteBuffer buffer = null;
+        String type = null;
+        if (""css"".equals(exchange.getQueryString())) {
+            buffer = Blobs.FILE_CSS_BUFFER.duplicate();
+            type = ""text/css"";
+        } else if (""js"".equals(exchange.getQueryString())) {
+            buffer = Blobs.FILE_JS_BUFFER.duplicate();
+            type = ""application/javascript"";
+        }
+
+        if (buffer != null) {
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(buffer.limit()));
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, type);
+            if (Methods.HEAD.equals(exchange.getRequestMethod())) {
+                exchange.endExchange();
+                return true;
+            }
+            exchange.getResponseSender().send(buffer, IoCallback.END_EXCHANGE);
+
+            return true;
+        }
+
+        return false;
+    }
+
+    public static void renderDirectoryListing(HttpServerExchange exchange, Resource resource) {
+        String requestPath = exchange.getRequestPath();
+        if (! requestPath.endsWith(""/"")) {
+            exchange.setResponseCode(302);
+            exchange.getResponseHeaders().put(Headers.LOCATION, requestPath + ""/"");
+            exchange.endExchange();
+            return;
+        }
+
+        // TODO - Fix exchange to sanitize path, so handlers don't need to do this
+        String resolvedPath = exchange.getResolvedPath();
+        for (int i = 0; i < resolvedPath.length(); i++) {
+            if (resolvedPath.charAt(i) != '/') {
+                resolvedPath = resolvedPath.substring(Math.max(0, i - 1));
+                break;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder();
+        builder.append(""<html><head><script src='"").append(resolvedPath).append(""?js'></script>"")
+                .append(""<link rel='stylesheet' type='txt/css' href='"").append(resolvedPath).append(""?css'/></head>"");
+        builder.append(""<body onresize='growit()' onload='growit()'><table id='thetable'><thead>"");
+        builder.append(""<tr><th class='loc' colspan='3'>Directory Listing - "").append(requestPath)
+                .append(""<tr><th class='label offset'>Name</th><th class='label'>Last Modified</th><th class='label'>Size</th></tr></thead>"")
+                .append(""<tfoot><tr><th class=\""loc footer\"" colspan=\""3\"">Powered by Undertow</th></tr></tfoot><tbody>"");
+
+        int state  = 0;
+        String parent = null;
+        for (int i = requestPath.length() - 1; i >= 0; i--) {
+            if (state == 1) {
+                if (requestPath.charAt(i) == '/') {
+                    state = 2;
+                }
+            } else if (requestPath.charAt(i) != '/') {
+                if (state == 2) {
+                    parent = requestPath.substring(0, i + 1);
+                    break;
+                }
+                state = 1;
+            }
+        }
+
+        SimpleDateFormat format = new SimpleDateFormat(""MMM dd, yyyy HH:mm:ss"");
+        int i = 0;
+        if (parent != null) {
+            i++;
+            builder.append(""<tr class='odd'><td><a class='icon up' href='"").append(parent).append(""'>[..]</a></td><td>"");
+            builder.append(format.format(resource.getLastModified())).append(""</td><td>--</td></tr>"");
+        }
+
+        for (Resource entry : resource.list()) {
+            builder.append(""<tr class='"").append((++i & 1) == 1 ? ""odd"" : ""even"").append(""'><td><a class='icon "");
+            builder.append(entry.isDirectory() ? ""dir"" : ""file"");
+            builder.append(""' href='"").append(entry.getName()).append(""'>"").append(entry.getName()).append(""</a></td><td>"");
+            builder.append(format.format(entry.getLastModified())).append(""</td><td>"");
+            if (entry.isDirectory()) {
+                builder.append(""--"");
+            } else {
+                formatSize(builder, entry.getContentLength());
+            }
+            builder.append(""</td></tr>"");
+        }
+        builder.append(""</tbody></table></body></html>"");
+
+        try {
+            ByteBuffer output = ByteBuffer.wrap(builder.toString().getBytes(""UTF-8""));
+            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(output.limit()));
+            Channels.writeBlocking(exchange.getResponseChannel(), output);
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalStateException(e);
+        } catch (IOException e) {
+            exchange.setResponseCode(500);
+        }
+
+        exchange.endExchange();
+        return;
+    }
+
+
+    private static StringBuilder formatSize(StringBuilder builder, Long size) {
+        if(size == null) {
+            builder.append(""???"");
+            return builder;
+        }
+        int n = 1024 * 1024 * 1024;
+        int type = 0;
+        while (size < n && n >= 1024) {
+            n /= 1024;
+            type++;
+        }
+
+        long top = (size * 100) / n;
+        long bottom =  top % 100;
+        top /= 100;
+
+        builder.append(top);
+        if (bottom > 0) {
+            builder.append(""."").append(bottom / 10);
+            bottom %= 10;
+            if (bottom > 0) {
+                builder.append(bottom);
+            }
+
+        }
+
+        switch (type) {
+            case 0: builder.append("" GB""); break;
+            case 1: builder.append("" MB""); break;
+            case 2: builder.append("" KB""); break;
+        }
+
+        return builder;
+    }
+
+
+
+    private DirectoryUtils() {
+
+    }
+
+    /**
+     * Constant Content
+     *
+     * @author Jason T. Greene
+     */
+    static class Blobs {
+          public static final String FILE_JS=""function growit() {\n"" +
+                  ""    var table = document.getElementById(\""thetable\"");\n"" +
+                  ""\n"" +
+                  ""    var i = table.rows.length - 1;\n"" +
+                  ""    while (i-- > 0) {\n"" +
+                  ""        if (table.rows[i].id == \""eraseme\"") {\n"" +
+                  ""            table.deleteRow(i);\n"" +
+                  ""        } else {\n"" +
+                  ""            break;\n"" +
+                  ""        }\n"" +
+                  ""    }\n"" +
+                  ""    table.style.height=\""\"";\n"" +
+                  ""    var i = 0;\n"" +
+                  ""    while (table.offsetHeight < window.innerHeight - 24) {\n"" +
+                  ""        i++;\n"" +
+                  ""        var tbody = table.tBodies[0];\n"" +
+                  ""        var row = tbody.insertRow(tbody.rows.length);\n"" +
+                  ""        row.id=\""eraseme\"";\n"" +
+                  ""        var cell = row.insertCell(0);\n"" +
+                  ""        if (table.rows.length % 2 != 0) {\n"" +
+                  ""            row.className=\""even eveninvis\"";\n"" +
+                  ""        } else {\n"" +
+                  ""            row.className=\""odd oddinvis\"";\n"" +
+                  ""        }\n"" +
+                  ""\n"" +
+                  ""        cell.colSpan=3;\n"" +
+                  ""        cell.appendChild(document.createTextNode(\""i\""));\n"" +
+                  ""    }\n"" +
+                  ""    table.style.height=\""100%\"";\n"" +
+                  ""    if (i > 0) {\n"" +
+                  ""        document.documentElement.style.overflowY=\""hidden\"";\n"" +
+                  ""    } else {\n"" +
+                  ""        document.documentElement.style.overflowY=\""auto\"";\n"" +
+                  ""    }\n"" +
+                  ""}"";
+          public static final String FILE_CSS =
+                  ""body {\n"" +
+                  ""    font-family: \""Lucida Grande\"", \""Lucida Sans Unicode\"", \""Trebuchet MS\"", Helvetica, Arial, Verdana, sans-serif;\n"" +
+                  ""    margin: 5px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.loc {\n"" +
+                  ""    background-image: linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -o-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -moz-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -webkit-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    background-image: -ms-linear-gradient(bottom, rgb(153,151,153) 8%, rgb(199,199,199) 54%);\n"" +
+                  ""    \n"" +
+                  ""    background-image: -webkit-gradient(\n"" +
+                  ""        linear,\n"" +
+                  ""        left bottom,\n"" +
+                  ""        left top,\n"" +
+                  ""        color-stop(0.08, rgb(153,151,153)),\n"" +
+                  ""        color-stop(0.54, rgb(199,199,199))\n"" +
+                  ""    );\n"" +
+                  ""    color: black;\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    font-weight: normal;\n"" +
+                  ""    border: solid 1px;\n"" +
+                  ""    font-size: 150%;\n"" +
+                  ""    text-align: left;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.label {\n"" +
+                  ""    border: solid  1px;\n"" +
+                  ""    text-align: left;\n"" +
+                  ""    padding: 4px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-weight: normal;\n"" +
+                  ""    font-size: small;\n"" +
+                  ""    background-color: #e8e8e8;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.offset {\n"" +
+                  ""    padding-left: 32px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""th.footer {\n"" +
+                  ""    font-size: 75%;\n"" +
+                  ""    text-align: right;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.icon {\n"" +
+                  ""    padding-left: 24px;\n"" +
+                  ""    text-decoration: none;\n"" +
+                  ""    color: black;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.icon:hover {\n"" +
+                  ""    text-decoration: underline;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""table {\n"" +
+                  ""    border: 1px solid;\n"" +
+                  ""    border-spacing: 0px;\n"" +
+                  ""    width: 100%;\n"" +
+                  ""    border-collapse: collapse;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.odd {\n"" +
+                  ""    background-color: #f3f6fa;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.odd td {\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-size: smaller;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.even {\n"" +
+                  ""    background-color: #ffffff;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.even td {\n"" +
+                  ""    padding: 2px;\n"" +
+                  ""    padding-left: 8px;\n"" +
+                  ""    font-size: smaller;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.eveninvis td {\n"" +
+                  ""    color: #ffffff;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""tr.oddinvis td {\n"" +
+                  ""    color: #f3f6fa\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.up {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4y2P4//8/Ay7sM4nhPwjjUwMm0ua//Y+M0+e//QrSGDAfgvEZAjdgydHXcAzTXLjWDoxhhqBbhGLA1N0vwBhdM7ohMHVwA8yrzn4zLj/936j8FE7N6IaA1IL0gPQy2DVc+rnp3FeCmtENAekB6WXw7Lz1tWD5x/+wEIdhdI3o8iA9IL0MYZMfvq9a9+V/w+avcIzLAGQ1ID0gvQxJc56/aNn29X/vnm9wjMsAZDWtQD0gvQwFy94+6N37/f/Moz/gGJcByGpAekB6GarXf7427ciP/0vP/YRjdP/CMLIakB6QXobKDd9PN+769b91P2kYpAekl2HJhb8r11/583/9ZRIxUM+8U783MQCBGBDXAHEbibgGrBdfTiMGU2wAAPz+nxp+TnhDAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.dir {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAAA+UlEQVQ4jWP4//8/AyUYTKTNf/sfGafPf/s1be47G5IMWHL0NRxP2f3mbcaCtz/RDUbHKAZM3f2CJAw3wLzq7Dfj8tP/jcpPkYRBekB6GewaLv3cdO7r/y0XSMMgPSC9DJ6dt74WLP/4v3TVZ5IwSA9IL0PY5Ifvq9Z9+d+w+StJGKQHpJchac7zFy3bvv7v3fONJNwK1APSy5C/7O2D3r3f/888+oMkDNID0stQvf7ztWlHfvxfeu4nSRikB6SXoXLD99ONu379b91PGgbpAellWHLh38r1V/78X3+ZRAzUM/fUr00MQCAGxDVA3EYirgHrpUpupAQDAPs+7c1tGDnPAAAAAElFTkSuQmCC') left center no-repeat; background-size: 16px 16px;\n"" +
+                  ""}\n"" +
+                  ""\n"" +
+                  ""a.file {\n"" +
+                  ""    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXZwQWcAAAAQAAAAEABcxq3DAAABM0lEQVQ4y5WSTW6DMBCF3xvzc4wuOEIO0kVAuUB7vJ4g3KBdoHSRROomEpusUaoAcaYLfmKoqVRLIxnJ7/M3YwJVBcknACv8b+1U9SvoP1bXa/3WNDVIAQmQBLsNOEsGQYAwDNcARgDqusbl+wIRA2NkBEyqP0s+kCOAQhhjICJdkaDIJDwEvQAhH+G+SHagWTsi4jHoAWYIOxYDZDjnb8Fn4Akvz6AHcAbx3Tp5ETwI3RwckyVtv4Fr4VEe9qq6bDB5tlnYWou2bWGtRRRF6jdwAm5Za1FVFc7nM0QERVG8A9hPDRaGpapomgZlWSJJEuR5ftpsNq8ADr9amC+SuN/vuN1uIIntdnvKsuwZwKf2wxgBxpjpX+dA4jjW4/H4kabpixt2AbvAmDX+XnsAB509ww+A8mAar+XXgQAAAABJRU5ErkJggg==') left center no-repeat;\n"" +
+                  ""}"";
+
+        public static final ByteBuffer FILE_CSS_BUFFER;
+        public static final ByteBuffer FILE_JS_BUFFER;
+
+        static {
+            try {
+                byte[] bytes = FILE_CSS.getBytes(""US-ASCII"");
+                FILE_CSS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
+                FILE_CSS_BUFFER.put(bytes);
+                FILE_CSS_BUFFER.flip();
+
+                bytes = FILE_JS.getBytes(""US-ASCII"");
+                FILE_JS_BUFFER = ByteBuffer.allocateDirect(bytes.length);
+                FILE_JS_BUFFER.put(bytes);
+                FILE_JS_BUFFER.flip();
+            } catch (Exception e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+    }
+}",2013-03-05T01:11:01Z,374
"@@ -0,0 +1,68 @@
+package io.undertow.server.handlers.resource;
+
+import java.util.Date;
+import java.util.List;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.ETag;
+import io.undertow.util.MimeMappings;
+
+/**
+ * Representation of a static resource.
+ *
+ *
+ * @author Stuart Douglas
+ */
+public interface Resource {
+
+    /**
+     *
+     * @return The last modified date of this resource, or null if this cannot be determined
+     */
+    Date getLastModified();
+
+    /**
+     *
+     * @return The resources etags
+     */
+    ETag getETag();
+
+    /**
+     *
+     * @return The name of the resource
+     */
+    String getName();
+
+    /**
+     *
+     * @return <code>true</code> if this resource represents a directory
+     */
+    boolean isDirectory();
+
+    /**
+     *
+     * @return a list of resources in this directory
+     */
+    List<Resource> list();
+
+    /**
+     * Return the resources content type. In most cases this will simply use the provided
+     * mime mappings, however in some cases the resource may have additional information as
+     * to the actual content type.
+     *
+     */
+    String getContentType(final MimeMappings mimeMappings);
+
+    /**
+     * Serve the resource, and end the exchange when done
+     *
+     * @param exchange The exchange
+     */
+    void serve(final HttpServerExchange exchange);
+
+    /**
+     *
+     * @return The content length, or null if it is unknown
+     */
+    Long getContentLength();
+}",2013-03-05T01:11:01Z,425
"@@ -0,0 +1,175 @@
+package io.undertow.server.handlers.resource;
+
+import java.util.Date;
+
+import io.undertow.predicate.Predicate;
+import io.undertow.predicate.TruePredicate;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.cache.ResponseCache;
+import io.undertow.util.DateUtils;
+import io.undertow.util.ETag;
+import io.undertow.util.ETagUtils;
+import io.undertow.util.Headers;
+import io.undertow.util.Methods;
+import io.undertow.util.MimeMappings;
+import io.undertow.util.WorkerDispatcher;
+
+/**
+ * @author Stuart Douglas
+ */
+public class ResourceHandler implements HttpHandler {
+
+    /**
+     * If directory listing is enabled.
+     */
+    private volatile boolean directoryListingEnabled = false;
+
+    /**
+     * The mime mappings that are used to determine the content type.
+     */
+    private volatile MimeMappings mimeMappings = MimeMappings.DEFAULT;
+
+    private volatile Predicate<HttpServerExchange> cachable = TruePredicate.instance();
+
+    private volatile Predicate<HttpServerExchange> allowed = TruePredicate.instance();
+
+    private volatile ResourceManager resourceManager;
+
+
+    @Override
+    public void handleRequest(final HttpServerExchange exchange) {
+        if (exchange.getRequestMethod().equals(Methods.GET) ||
+                exchange.getRequestMethod().equals(Methods.POST)) {
+            serveResource(exchange, true);
+        } else if (exchange.getRequestMethod().equals(Methods.HEAD)) {
+            serveResource(exchange, false);
+        } else {
+            exchange.setResponseCode(405);
+            exchange.endExchange();
+        }
+    }
+
+    private void serveResource(final HttpServerExchange exchange, final boolean sendContent) {
+
+        if(DirectoryUtils.sendRequestedBlobs(exchange)) {
+            return;
+        }
+
+        if (!allowed.resolve(exchange)) {
+            exchange.setResponseCode(403);
+            exchange.endExchange();
+        }
+
+        ResponseCache cache = exchange.getAttachment(ResponseCache.ATTACHMENT_KEY);
+        if (cache != null && cachable.resolve(exchange)) {
+            if (cache.tryServeResponse()) {
+                return;
+            }
+        }
+
+        //we now dispatch to a worker thread
+        //as resource manager methods are potentially blocking
+        WorkerDispatcher.dispatch(exchange, new Runnable() {
+            @Override
+            public void run() {
+                Resource resource = resourceManager.getResource(exchange.getRelativePath());
+                if (resource == null) {
+                    exchange.setResponseCode(404);
+                    exchange.endExchange();
+                    return;
+                }
+
+                if (resource.isDirectory()) {
+                    DirectoryUtils.renderDirectoryListing(exchange, resource);
+                    return;
+                }
+
+                final ETag etag = resource.getETag();
+                final Date lastModified = resource.getLastModified();
+                if (!ETagUtils.handleIfMatch(exchange, etag, false) ||
+                        !DateUtils.handleIfUnmodifiedSince(exchange, lastModified)) {
+                    exchange.setResponseCode(412);
+                    exchange.endExchange();
+                    return;
+                }
+                if (!ETagUtils.handleIfNoneMatch(exchange, etag, true) ||
+                        !DateUtils.handleIfModifiedSince(exchange, lastModified)) {
+                    exchange.setResponseCode(304);
+                    exchange.endExchange();
+                    return;
+                }
+                //todo: handle range requests
+                //we are going to proceed. Set the appropriate headers
+                final String contentType = resource.getContentType(mimeMappings);
+                if (contentType != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);
+                } else {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/octet-stream"");
+                }
+                if (lastModified != null) {
+                    exchange.getResponseHeaders().put(Headers.LAST_MODIFIED, DateUtils.toDateString(lastModified));
+                }
+                if (etag != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, etag.toString());
+                }
+                Long contentLength = resource.getContentLength();
+                if (contentLength != null) {
+                    exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, contentLength.toString());
+                }
+                if(!sendContent) {
+                    exchange.endExchange();
+                } else {
+                    resource.serve(exchange);
+                }
+            }
+        });
+
+
+    }
+
+    public boolean isDirectoryListingEnabled() {
+        return directoryListingEnabled;
+    }
+
+    public ResourceHandler setDirectoryListingEnabled(final boolean directoryListingEnabled) {
+        this.directoryListingEnabled = directoryListingEnabled;
+        return this;
+    }
+
+    public MimeMappings getMimeMappings() {
+        return mimeMappings;
+    }
+
+    public ResourceHandler setMimeMappings(final MimeMappings mimeMappings) {
+        this.mimeMappings = mimeMappings;
+        return this;
+    }
+
+    public Predicate<HttpServerExchange> getCachable() {
+        return cachable;
+    }
+
+    public ResourceHandler setCachable(final Predicate<HttpServerExchange> cachable) {
+        this.cachable = cachable;
+        return this;
+    }
+
+    public Predicate<HttpServerExchange> getAllowed() {
+        return allowed;
+    }
+
+    public ResourceHandler setAllowed(final Predicate<HttpServerExchange> allowed) {
+        this.allowed = allowed;
+        return this;
+    }
+
+    public ResourceManager getResourceManager() {
+        return resourceManager;
+    }
+
+    public ResourceHandler setResourceManager(final ResourceManager resourceManager) {
+        this.resourceManager = resourceManager;
+        return this;
+    }
+}",2013-03-05T01:11:01Z,426
"@@ -0,0 +1,22 @@
+package io.undertow.server.handlers.resource;
+
+/**
+ *
+ * Representation of a resource manager. A resource manager knows how to obtain
+ * a resource for a given path.
+ *
+ * @author Stuart Douglas
+ */
+public interface ResourceManager {
+
+    /**
+     * Returns a resource for the given path.
+     *
+     * It is the responsibility of the called to make sure that the path in Canonicalised.
+     *
+     * @param path The path
+     * @return The resource representing the path, or null if no resource was found.
+     */
+    Resource getResource(final String path);
+
+}",2013-03-05T01:11:01Z,427
"@@ -0,0 +1,146 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.resource.file;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.channels.Channel;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.undertow.UndertowLogger;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.resource.Resource;
+import io.undertow.util.ETag;
+import io.undertow.util.MimeMappings;
+import org.jboss.logging.Logger;
+import org.xnio.ChannelListener;
+import org.xnio.FileAccess;
+import org.xnio.IoUtils;
+import org.xnio.channels.Channels;
+import org.xnio.channels.StreamSinkChannel;
+
+/**
+ * A file resource
+ *
+ * @author Stuart Douglas
+ */
+public class FileResource implements Resource {
+
+    private static final Logger log = Logger.getLogger(""io.undertow.server.resources.file"");
+
+    private final File file;
+
+    public FileResource(final File file) {
+        this.file = file;
+    }
+
+    @Override
+    public Date getLastModified() {
+        return new Date(file.lastModified());
+    }
+
+    @Override
+    public ETag getETag() {
+        return null;
+    }
+
+    @Override
+    public String getName() {
+        return file.getName();
+    }
+
+    @Override
+    public boolean isDirectory() {
+        return file.isDirectory();
+    }
+
+    @Override
+    public List<Resource> list() {
+        final List<Resource> resources = new ArrayList<Resource>();
+        for (String f : file.list()) {
+            final File child = new File(file, f);
+            resources.add(new FileResource(child));
+        }
+        return resources;
+    }
+
+    @Override
+    public String getContentType(final MimeMappings mimeMappings) {
+        final String fileName = file.getName();
+        int index = fileName.lastIndexOf('.');
+        if (index != -1 && index != fileName.length() - 1) {
+            return mimeMappings.getMimeType(fileName.substring(index + 1));
+        }
+        return null;
+    }
+
+    @Override
+    public void serve(final HttpServerExchange exchange) {
+        //TODO: should be using async IO here as much as possible
+        final FileChannel fileChannel;
+        try {
+            try {
+                fileChannel = exchange.getConnection().getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
+            } catch (FileNotFoundException e) {
+                exchange.setResponseCode(404);
+                exchange.endExchange();
+                return;
+            }
+        } catch (IOException e) {
+            UndertowLogger.REQUEST_LOGGER.exceptionReadingFile(file, e);
+            exchange.setResponseCode(500);
+            exchange.endExchange();
+            return;
+        }
+
+        final StreamSinkChannel response = exchange.getResponseChannel();
+        response.getCloseSetter().set(new ChannelListener<Channel>() {
+            public void handleEvent(final Channel channel) {
+                IoUtils.safeClose(fileChannel);
+            }
+        });
+
+
+        try {
+            log.tracef(""Serving file %s (blocking)"", fileChannel);
+            Channels.transferBlocking(response, fileChannel, 0, file.length());
+            log.tracef(""Finished serving %s, shutting down (blocking)"", fileChannel);
+            response.shutdownWrites();
+            log.tracef(""Finished serving %s, flushing (blocking)"", fileChannel);
+            Channels.flushBlocking(response);
+            log.tracef(""Finished serving %s (complete)"", fileChannel);
+            exchange.endExchange();
+        } catch (IOException ignored) {
+            log.tracef(""Failed to serve %s: %s"", fileChannel, ignored);
+            exchange.endExchange();
+            IoUtils.safeClose(response);
+        } finally {
+            IoUtils.safeClose(fileChannel);
+        }
+    }
+
+    @Override
+    public Long getContentLength() {
+        return file.length();
+    }
+}",2013-03-05T01:11:01Z,116
"@@ -0,0 +1,68 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.handlers.resource.file;
+
+import java.io.File;
+
+import io.undertow.UndertowMessages;
+import io.undertow.server.handlers.resource.Resource;
+import io.undertow.server.handlers.resource.ResourceManager;
+/**
+ * Serves files from the file system.
+ */
+public class FileResourceManager implements ResourceManager {
+
+    private volatile File base;
+
+    public FileResourceManager(final File base) {
+        if (base == null) {
+            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
+        }
+        this.base = base;
+    }
+
+    public File getBase() {
+        return base;
+    }
+
+    public FileResourceManager setBase(final File base) {
+        if (base == null) {
+            throw UndertowMessages.MESSAGES.argumentCannotBeNull(""base"");
+        }
+        this.base = base;
+        return this;
+    }
+
+    public Resource getResource(final String p) {
+        String path = p;
+        if (File.separatorChar != '/') {
+            if (path.indexOf(File.separatorChar) != -1) {
+                return null;
+            }
+            path = path.replace('/', File.separatorChar);
+        }
+
+        final File file = new File(base, path);
+        if(file.exists()) {
+            return new FileResource(file);
+        } else {
+            return null;
+        }
+    }
+}",2013-03-05T01:11:01Z,116
"@@ -21,6 +21,15 @@ public String getTag() {
         return tag;
     }
 
+    @Override
+    public String toString() {
+        if(weak) {
+            return ""W/\"""" + tag + ""\"""";
+        } else {
+            return ""\"""" + tag + ""\"""";
+        }
+    }
+
     @Override
     public boolean equals(final Object o) {
         if (this == o) return true;",2013-03-05T01:11:01Z,428
"@@ -32,7 +32,8 @@
 import io.undertow.server.handlers.cache.CacheHandler;
 import io.undertow.server.handlers.cache.CachedHttpRequest;
 import io.undertow.server.handlers.cache.DirectBufferCache;
-import io.undertow.server.handlers.file.FileHandler;
+import io.undertow.server.handlers.resource.ResourceHandler;
+import io.undertow.server.handlers.resource.file.FileResourceManager;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
@@ -56,7 +57,8 @@ public class FileHandlerStressTestCase {
     public void simpleFileStressTest() throws IOException, ExecutionException, InterruptedException {
         ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
         try {
-            final FileHandler handler = new FileHandler(new File(getClass().getResource(""page.html"").getFile()).getParentFile());
+            final ResourceHandler handler = new ResourceHandler()
+                    .setResourceManager(new FileResourceManager(new File(getClass().getResource(""page.html"").getFile()).getParentFile()));
 
             final CacheHandler cacheHandler = new CacheHandler(new DirectBufferCache<CachedHttpRequest>(1024, 10480), handler);
             final PathHandler path = new PathHandler();",2013-03-05T01:11:01Z,60
"@@ -23,13 +23,14 @@
 
 import io.undertow.server.handlers.CanonicalPathHandler;
 import io.undertow.server.handlers.PathHandler;
-import io.undertow.server.handlers.file.FileHandler;
+import io.undertow.server.handlers.resource.ResourceHandler;
+import io.undertow.server.handlers.resource.file.FileResourceManager;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
+import io.undertow.util.TestHttpClient;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,13 +46,11 @@ public class FileHandlerTestCase {
     public void testFileIsServed() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            final FileHandler handler = new FileHandler(new File(getClass().getResource(""page.html"").getFile()).getParentFile());
-            handler.setDirectoryListingEnabled(true);
-            final PathHandler path = new PathHandler();
-            path.addPath(""/path"", handler);
-            final CanonicalPathHandler root = new CanonicalPathHandler();
-            root.setNext(path);
-            DefaultServer.setRootHandler(root);
+            DefaultServer.setRootHandler(new CanonicalPathHandler()
+                    .setNext(new PathHandler()
+                            .addPath(""/path"", new ResourceHandler()
+                                    .setResourceManager(new FileResourceManager(new File(getClass().getResource(""page.html"").getFile()).getParentFile()))
+                                    .setDirectoryListingEnabled(true))));
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path/page.html"");
             HttpResponse result = client.execute(get);",2013-03-05T01:11:01Z,79
"@@ -380,7 +380,7 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
             lifecycles.add(managedDefaultServlet);
             pathMatches.add(""/*"");
             defaultServlet = new ServletHandler(managedDefaultServlet);
-            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, managedDefaultServlet);
+            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), threadSetupAction, servletContext, managedDefaultServlet);
         }
 
         final ServletPathMatches.Builder builder = ServletPathMatches.builder();",2013-03-05T01:11:01Z,80
"@@ -37,10 +37,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.file.DirectFileSource;
-import io.undertow.server.handlers.file.FileSource;
 import io.undertow.servlet.api.DefaultServletConfig;
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
@@ -64,11 +61,10 @@
  *
  * @author Stuart Douglas
  */
-public class DefaultServlet extends HttpServlet implements HttpHandler {
+public class DefaultServlet extends HttpServlet {
 
 
     private final Deployment deployment;
-    private volatile FileSource fileSource = DirectFileSource.INSTANCE;
     private final DefaultServletConfig config;
 
     private final List<String> welcomePages;
@@ -134,7 +130,7 @@ private void serveFileBlocking(final HttpServletResponse resp, final File resour
             IoUtils.safeClose(in);
         }
     }
-
+/*
     @Override
     public void handleRequest(final HttpServerExchange exchange) {
         if (!isAllowed(exchange.getRelativePath())) {
@@ -169,7 +165,7 @@ private void handleWelcomePage(final HttpServerExchange exchange, final File res
                 exchange.endExchange();
             }
         }
-    }
+    }*/
 
     private void handleWelcomePage(final HttpServletRequest req, final HttpServletResponse resp, final File resource) throws IOException, ServletException {
         File welcomePage = findWelcomeFile(resource);
@@ -274,11 +270,4 @@ private boolean isAllowed(String path) {
         }
     }
 
-    public FileSource getFileSource() {
-        return fileSource;
-    }
-
-    public void setFileSource(final FileSource fileSource) {
-        this.fileSource = fileSource;
-    }
 }",2013-03-05T01:11:01Z,155
"@@ -121,15 +121,13 @@ private void handleRequests(Http2Channel channel, Http2StreamSourceChannel frame
         final Http2StreamSourceChannel dataChannel = frame;
         final Http2ServerConnection connection = new Http2ServerConnection(channel, dataChannel, undertowOptions, bufferSize, rootHandler);
 
-        if(!dataChannel.getHeaders().contains(SCHEME) ||
-                !dataChannel.getHeaders().contains(METHOD) ||
-                !dataChannel.getHeaders().contains(AUTHORITY) ||
-                !dataChannel.getHeaders().contains(PATH)) {
+        // Check request headers.
+        if (!checkRequestHeaders(dataChannel.getHeaders())) {
             channel.sendRstStream(frame.getStreamId(), Http2Channel.ERROR_PROTOCOL_ERROR);
             try {
                 Channels.drain(frame, Long.MAX_VALUE);
             } catch (IOException e) {
-                //ignore, this is expected because of the RST
+                // ignore, this is expected because of the RST
             }
             return;
         }
@@ -218,4 +216,30 @@ public void handleEvent(Http2DataStreamSinkChannel channel) {
         Connectors.executeRootHandler(rootHandler, exchange);
     }
 
+    /**
+     * Performs HTTP2 specification compliance check for headers and pseudo-headers of a current request.
+     *
+     * @param headers map of the request headers
+     * @return true if check was successful, false otherwise
+     */
+    private boolean checkRequestHeaders(HeaderMap headers) {
+        // :method pseudo-header must be present always exactly one time.
+        if (headers.count(METHOD) != 1) {
+            return false;
+        }
+
+        // if CONNECT type is used, then we expect :method and :authority to be present only;
+        // :scheme and :path must not be present
+        if (headers.get(METHOD).equals(Methods.CONNECT)) {
+            if (headers.contains(SCHEME) || headers.contains(PATH) || headers.count(AUTHORITY) != 1) {
+                return false;
+            }
+        // For other HTTP methods we expect that :scheme, :method, and :path pseudo-headers are
+        // present exactly one time.
+        } else if (headers.count(SCHEME) != 1 || headers.count(PATH) != 1) {
+            return false;
+        }
+
+        return true;
+    }
 }",2016-09-05T05:00:12Z,164
"@@ -73,15 +73,15 @@ public void connect(ClientCallback<ClientConnection> listener, InetSocketAddress
             }
             OptionMap tlsOptions = OptionMap.builder().addAll(options).set(Options.SSL_STARTTLS, true).getMap();
             if (bindAddress == null) {
-                ssl.openSslConnection(worker, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions), tlsOptions).addNotifier(createNotifier(listener), null);
+                ssl.openSslConnection(worker, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions, uri), tlsOptions).addNotifier(createNotifier(listener), null);
             } else {
-                ssl.openSslConnection(worker, bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions), tlsOptions).addNotifier(createNotifier(listener), null);
+                ssl.openSslConnection(worker, bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions, uri), tlsOptions).addNotifier(createNotifier(listener), null);
             }
         } else {
             if (bindAddress == null) {
-                worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), options).addNotifier(createNotifier(listener), null);
+                worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri), options).addNotifier(createNotifier(listener), null);
             } else {
-                worker.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), null, options).addNotifier(createNotifier(listener), null);
+                worker.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri), null, options).addNotifier(createNotifier(listener), null);
             }
         }
     }
@@ -95,15 +95,15 @@ public void connect(ClientCallback<ClientConnection> listener, InetSocketAddress
             }
             OptionMap tlsOptions = OptionMap.builder().addAll(options).set(Options.SSL_STARTTLS, true).getMap();
             if (bindAddress == null) {
-                ssl.openSslConnection(ioThread, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions), tlsOptions).addNotifier(createNotifier(listener), null);
+                ssl.openSslConnection(ioThread, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions, uri), tlsOptions).addNotifier(createNotifier(listener), null);
             } else {
-                ssl.openSslConnection(ioThread, bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions), tlsOptions).addNotifier(createNotifier(listener), null);
+                ssl.openSslConnection(ioThread, bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 443 : uri.getPort()), createOpenListener(listener, bufferPool, tlsOptions, uri), tlsOptions).addNotifier(createNotifier(listener), null);
             }
         } else {
             if (bindAddress == null) {
-                ioThread.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), options).addNotifier(createNotifier(listener), null);
+                ioThread.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri), options).addNotifier(createNotifier(listener), null);
             } else {
-                ioThread.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), null, options).addNotifier(createNotifier(listener), null);
+                ioThread.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri), null, options).addNotifier(createNotifier(listener), null);
             }
         }
     }
@@ -119,17 +119,17 @@ public void notify(IoFuture<? extends StreamConnection> ioFuture, Object o) {
         };
     }
 
-    private ChannelListener<StreamConnection> createOpenListener(final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
+    private ChannelListener<StreamConnection> createOpenListener(final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final URI uri) {
         return new ChannelListener<StreamConnection>() {
             @Override
             public void handleEvent(StreamConnection connection) {
-                handleConnected(connection, listener, bufferPool, options);
+                handleConnected(connection, listener, bufferPool, options, uri);
             }
         };
     }
 
 
-    private void handleConnected(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
+    private void handleConnected(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, URI uri) {
         if (options.get(UndertowOptions.ENABLE_SPDY, false) && connection instanceof SslConnection && SpdyClientProvider.isEnabled()) {
             try {
                 SpdyClientProvider.handlePotentialSpdyConnection(connection, listener, bufferPool, options, new ChannelListener<SslConnection>() {
@@ -148,7 +148,7 @@ public void handleEvent(SslConnection channel) {
                     public void handleEvent(SslConnection channel) {
                         listener.completed(new HttpClientConnection(connection, options, bufferPool));
                     }
-                });
+                }, uri);
             } catch (Exception e) {
                 listener.failed(new IOException(e));
             }",2015-06-19T07:42:48Z,248
"@@ -81,7 +81,7 @@ public void connect(final ClientCallback<ClientConnection> listener, InetSocketA
             return;
         }
         Map<String, String> headers = createHeaders(options, bufferPool, uri);
-        HttpUpgrade.performUpgrade(worker, bindAddress, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener), null, options, null).addNotifier(new FailedNotifier(listener), null);
+        HttpUpgrade.performUpgrade(worker, bindAddress, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener, uri.getHost()), null, options, null).addNotifier(new FailedNotifier(listener), null);
     }
 
     @Override
@@ -99,7 +99,7 @@ public void connect(final ClientCallback<ClientConnection> listener, final InetS
                 @Override
                 public void handleEvent(StreamConnection channel) {
                     Map<String, String> headers = createHeaders(options, bufferPool, uri);
-                    HttpUpgrade.performUpgrade(channel, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener), null).addNotifier(new FailedNotifier(listener), null);
+                    HttpUpgrade.performUpgrade(channel, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener, uri.getHost()), null).addNotifier(new FailedNotifier(listener), null);
                 }
             }, new ChannelListener<BoundChannel>() {
                 @Override
@@ -112,7 +112,7 @@ public void handleEvent(BoundChannel channel) {
                 @Override
                 public void handleEvent(StreamConnection channel) {
                     Map<String, String> headers = createHeaders(options, bufferPool, uri);
-                    HttpUpgrade.performUpgrade(channel, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener), null).addNotifier(new FailedNotifier(listener), null);
+                    HttpUpgrade.performUpgrade(channel, upgradeUri, headers, new Http2ClearOpenListener(bufferPool, options, listener, uri.getHost()), null).addNotifier(new FailedNotifier(listener), null);
                 }
             }, new ChannelListener<BoundChannel>() {
                 @Override
@@ -179,20 +179,23 @@ private static void pushOption(ByteBuffer currentBuffer, int id, int value) {
     }
 
     private static class Http2ClearOpenListener implements ChannelListener<StreamConnection> {
+
         private final Pool<ByteBuffer> bufferPool;
         private final OptionMap options;
         private final ClientCallback<ClientConnection> listener;
+        private final String defaultHost;
 
-        public Http2ClearOpenListener(Pool<ByteBuffer> bufferPool, OptionMap options, ClientCallback<ClientConnection> listener) {
+        public Http2ClearOpenListener(Pool<ByteBuffer> bufferPool, OptionMap options, ClientCallback<ClientConnection> listener, String defaultHost) {
             this.bufferPool = bufferPool;
             this.options = options;
             this.listener = listener;
+            this.defaultHost = defaultHost;
         }
 
         @Override
         public void handleEvent(StreamConnection channel) {
             Http2Channel http2Channel = new Http2Channel(channel, null, bufferPool, null, true, true, options);
-            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, true);
+            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, true, defaultHost);
 
             listener.completed(http2ClientConnection);
         }",2015-06-19T07:42:48Z,348
"@@ -76,9 +76,11 @@ public class Http2ClientConnection implements ClientConnection {
     private final Map<Integer, Http2ClientExchange> currentExchanges = new ConcurrentHashMap<>();
 
     private boolean initialUpgradeRequest;
+    private final String defaultHost;
 
-    public Http2ClientConnection(Http2Channel http2Channel, boolean initialUpgradeRequest) {
+    public Http2ClientConnection(Http2Channel http2Channel, boolean initialUpgradeRequest, String defaultHost) {
         this.http2Channel = http2Channel;
+        this.defaultHost = defaultHost;
         http2Channel.getReceiveSetter().set(new Http2ReceiveListener());
         http2Channel.resumeReceives();
         http2Channel.addCloseTask(new ChannelListener<Http2Channel>() {
@@ -95,7 +97,12 @@ public void sendRequest(ClientRequest request, ClientCallback<ClientExchange> cl
         request.getRequestHeaders().put(PATH, request.getPath());
         request.getRequestHeaders().put(SCHEME, ""https"");
         request.getRequestHeaders().put(METHOD, request.getMethod().toString());
-        request.getRequestHeaders().put(AUTHORITY, request.getRequestHeaders().getFirst(Headers.HOST));
+        final String host = request.getRequestHeaders().getFirst(Headers.HOST);
+        if(host != null) {
+            request.getRequestHeaders().put(AUTHORITY, host);
+        } else {
+            request.getRequestHeaders().put(AUTHORITY, defaultHost);
+        }
         request.getRequestHeaders().remove(Headers.HOST);
 
 ",2015-06-19T07:42:48Z,196
"@@ -161,7 +161,7 @@ private void handleConnected(StreamConnection connection, final ClientCallback<C
             public void handleEvent(SslConnection channel) {
                 listener.failed(UndertowMessages.MESSAGES.spdyNotSupported());
             }
-        });
+        }, uri);
     }
 
     public static boolean isEnabled() {
@@ -171,7 +171,7 @@ public static boolean isEnabled() {
     /**
      * Not really part of the public API, but is used by the HTTP client to initiate a HTTP2 connection for HTTPS requests.
      */
-    public static void handlePotentialHttp2Connection(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final ChannelListener<SslConnection> http2FailedListener) {
+    public static void handlePotentialHttp2Connection(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final ChannelListener<SslConnection> http2FailedListener, final URI uri) {
 
         final SslConnection sslConnection = (SslConnection) connection;
         final SSLEngine sslEngine = UndertowXnioSsl.getSslEngine(sslConnection);
@@ -196,7 +196,7 @@ public void handleEvent(StreamSourceChannel channel) {
                             http2FailedListener.handleEvent(sslConnection);
                             return;
                         } else if (http2SelectionProvider.selected.equals(HTTP2)) {
-                            listener.completed(createHttp2Channel(connection, bufferPool, options));
+                            listener.completed(createHttp2Channel(connection, bufferPool, options, uri.getHost()));
                         }
                     } else {
                         ByteBuffer buf = ByteBuffer.allocate(100);
@@ -218,7 +218,7 @@ public void handleEvent(StreamSourceChannel channel) {
                             } else if (http2SelectionProvider.selected != null) {
                                 //we have spdy
                                 if (http2SelectionProvider.selected.equals(HTTP2)) {
-                                    listener.completed(createHttp2Channel(connection, bufferPool, options));
+                                    listener.completed(createHttp2Channel(connection, bufferPool, options, uri.getHost()));
                                 }
                             }
                         } catch (IOException e) {
@@ -238,9 +238,9 @@ public void handleEvent(StreamSourceChannel channel) {
 
     }
 
-    private static Http2ClientConnection createHttp2Channel(StreamConnection connection, Pool<ByteBuffer> bufferPool, OptionMap options) {
+    private static Http2ClientConnection createHttp2Channel(StreamConnection connection, Pool<ByteBuffer> bufferPool, OptionMap options, String defaultHost) {
         Http2Channel http2Channel = new Http2Channel(connection, null, bufferPool, null, true, false, options);
-        return new Http2ClientConnection(http2Channel, false);
+        return new Http2ClientConnection(http2Channel, false, defaultHost);
     }
 
     private static class Http2SelectionProvider implements ALPN.ClientProvider {",2015-06-19T07:42:48Z,230
"@@ -68,18 +68,18 @@ public Set<String> handlesSchemes() {
     public void connect(final ClientCallback<ClientConnection> listener, InetSocketAddress bindAddress, final URI uri, final XnioWorker worker, final XnioSsl ssl, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
 
         if (bindAddress == null) {
-            worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), options).addNotifier(createNotifier(listener), null);
+            worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri.getHost()), options).addNotifier(createNotifier(listener), null);
         } else {
-            worker.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), null, options).addNotifier(createNotifier(listener), null);
+            worker.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri.getHost()), null, options).addNotifier(createNotifier(listener), null);
         }}
 
     @Override
     public void connect(final ClientCallback<ClientConnection> listener, final InetSocketAddress bindAddress, final URI uri, final XnioIoThread ioThread, final XnioSsl ssl, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
 
         if (bindAddress == null) {
-            ioThread.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), options).addNotifier(createNotifier(listener), null);
+            ioThread.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri.getHost()), options).addNotifier(createNotifier(listener), null);
         } else {
-            ioThread.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options), null, options).addNotifier(createNotifier(listener), null);
+            ioThread.openStreamConnection(bindAddress, new InetSocketAddress(uri.getHost(), uri.getPort() == -1 ? 80 : uri.getPort()), createOpenListener(listener, bufferPool, options, uri.getHost()), null, options).addNotifier(createNotifier(listener), null);
         }
     }
 
@@ -94,16 +94,16 @@ public void notify(IoFuture<? extends StreamConnection> ioFuture, Object o) {
         };
     }
 
-    private ChannelListener<StreamConnection> createOpenListener(final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
+    private ChannelListener<StreamConnection> createOpenListener(final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final String defaultHost) {
         return new ChannelListener<StreamConnection>() {
             @Override
             public void handleEvent(StreamConnection connection) {
-                handleConnected(connection, listener, bufferPool, options);
+                handleConnected(connection, listener, bufferPool, options, defaultHost);
             }
         };
     }
 
-    private void handleConnected(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options) {
+    private void handleConnected(final StreamConnection connection, final ClientCallback<ClientConnection> listener, final Pool<ByteBuffer> bufferPool, final OptionMap options, final String defaultHost) {
         try {
             final ByteBuffer pri = ByteBuffer.wrap(PRI_REQUEST);
             pri.flip();
@@ -118,15 +118,15 @@ public void handleEvent(ConduitStreamSinkChannel channel) {
                             if(pri.hasRemaining()) {
                                 return;
                             }
-                            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false));
+                            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost));
                         } catch (IOException e) {
                             listener.failed(e);
                         }
                     }
                 });
                 return;
             }
-            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false));
+            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost));
         } catch (IOException e) {
             listener.failed(e);
         }",2015-06-19T07:42:48Z,429
"@@ -44,6 +44,7 @@
 import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import org.xnio.channels.Channels;
 
 /**
  * The recieve listener for a Http2 connection.
@@ -120,6 +121,19 @@ private void handleRequests(Http2Channel channel, Http2StreamSourceChannel frame
         final Http2StreamSourceChannel dataChannel = frame;
         final Http2ServerConnection connection = new Http2ServerConnection(channel, dataChannel, undertowOptions, bufferSize, rootHandler);
 
+        if(!dataChannel.getHeaders().contains(SCHEME) ||
+                !dataChannel.getHeaders().contains(METHOD) ||
+                !dataChannel.getHeaders().contains(AUTHORITY) ||
+                !dataChannel.getHeaders().contains(PATH)) {
+            channel.sendRstStream(frame.getStreamId(), Http2Channel.ERROR_PROTOCOL_ERROR);
+            try {
+                Channels.drain(frame, Long.MAX_VALUE);
+            } catch (IOException e) {
+                //ignore, this is expected because of the RST
+            }
+            return;
+        }
+
 
         final HttpServerExchange exchange = new HttpServerExchange(connection, dataChannel.getHeaders(), dataChannel.getResponseChannel().getHeaders(), maxEntitySize);
         connection.setExchange(exchange);",2015-06-19T07:42:48Z,164
"@@ -662,9 +662,8 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                 return 0;
             }
         }
-
+        boolean bytesProduced = false;
         PooledByteBuffer unwrappedData = this.unwrappedData;
-        boolean existingUnwrappedData = false;
         //copy any exiting data
         if(unwrappedData != null) {
             if(userBuffers != null) {
@@ -677,8 +676,6 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                     readListenerInvocationCount = 0;
                 }
                 return copied;
-            } else {
-                existingUnwrappedData = true;
             }
         }
         try {
@@ -732,6 +729,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                         result = engine.unwrap(this.dataToUnwrap.getBuffer(), d);
                         unwrapBufferUsed = true;
                     }
+                    bytesProduced = result.bytesProduced() > 0;
                 } else {
                     unwrapBufferUsed = true;
                     if (unwrappedData == null) {
@@ -740,6 +738,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                         unwrappedData.getBuffer().compact();
                     }
                     result = engine.unwrap(this.dataToUnwrap.getBuffer(), unwrappedData.getBuffer());
+                    bytesProduced = result.bytesProduced() > 0;
                 }
             } finally {
                 if (unwrapBufferUsed) {
@@ -789,7 +788,8 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
             throw e;
         } finally {
             boolean requiresListenerInvocation = false; //if there is data in the buffer and reads are resumed we should re-run the listener
-            if (unwrappedData != null && unwrappedData.getBuffer().hasRemaining()) {
+            //we always need to re-invoke if bytes have been produced, as the engine may have buffered some data
+            if (bytesProduced || (unwrappedData != null && unwrappedData.getBuffer().hasRemaining())) {
                 requiresListenerInvocation = true;
             }
             if (dataToUnwrap != null) {
@@ -808,7 +808,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
             }
             //if we are in the read listener handshake we don't need to invoke
             //as it is about to be invoked anyway
-            if (requiresListenerInvocation && anyAreSet(state, FLAG_READS_RESUMED) && !invokingReadListenerHandshake) {
+            if (requiresListenerInvocation && (anyAreSet(state, FLAG_READS_RESUMED) || allAreSet(state, FLAG_WRITE_REQUIRES_READ | FLAG_WRITES_RESUMED)) && !invokingReadListenerHandshake) {
                 runReadListener(false);
             }
         }",2016-03-30T04:42:44Z,185
"@@ -32,6 +32,7 @@ public class ResponseTimeAttribute implements ExchangeAttribute {
     public static final String RESPONSE_TIME_MILLIS_SHORT = ""%D"";
     public static final String RESPONSE_TIME_SECONDS_SHORT = ""%T"";
     public static final String RESPONSE_TIME_MILLIS = ""%{RESPONSE_TIME}"";
+    public static final String RESPONSE_TIME_NANOS = ""%{RESPONSE_TIME_NANOS}"";
 
     private final TimeUnit timeUnit;
 
@@ -68,6 +69,9 @@ public ExchangeAttribute build(String token) {
             if (token.equals(RESPONSE_TIME_SECONDS_SHORT)) {
                 return new ResponseTimeAttribute(TimeUnit.SECONDS);
             }
+            if(token.equals(RESPONSE_TIME_NANOS)) {
+                return new ResponseTimeAttribute(TimeUnit.NANOSECONDS);
+            }
             return null;
         }
 ",2015-05-05T04:34:02Z,430
"@@ -34,12 +34,12 @@
  *
  * @author Stuart Douglas
  */
-@MessageLogger(projectCode = ""TEXUGO"")
-public interface TexugoLogger extends BasicLogger {
+@MessageLogger(projectCode = ""UNDERTOW"")
+public interface UndertowLogger extends BasicLogger {
 
-    TexugoLogger ROOT_LOGGER = Logger.getMessageLogger(TexugoLogger.class, TexugoLogger.class.getPackage().getName());
+    UndertowLogger ROOT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName());
 
-    TexugoLogger REQUEST_LOGGER = Logger.getMessageLogger(TexugoLogger.class, TexugoLogger.class.getPackage().getName() + "".request"");
+    UndertowLogger REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + "".request"");
 
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5000, value = ""HttpServerExchange.getRequestChannel() has been called without also calling "" +",2012-07-29T21:52:09Z,65
"@@ -25,10 +25,10 @@
 /**
  * @author Stuart Douglas
  */
-@MessageBundle(projectCode = ""TEXUGO"")
-public interface TexugoMessages {
+@MessageBundle(projectCode = ""UNDERTOW"")
+public interface UndertowMessages {
 
-    TexugoMessages MESSAGES = Messages.getBundle(TexugoMessages.class);
+    UndertowMessages MESSAGES = Messages.getBundle(UndertowMessages.class);
 
     @Message(id = 2, value = ""The response has already been started"")
     IllegalStateException responseAlreadyStarted();",2012-07-29T21:52:09Z,68
"@@ -19,11 +19,12 @@
 package io.undertow.server;
 
 import java.nio.ByteBuffer;
+
+import io.undertow.UndertowLogger;
 import org.xnio.ChannelListener;
 import org.xnio.Pool;
 import org.xnio.channels.ConnectedStreamChannel;
 import org.xnio.channels.PushBackStreamChannel;
-import io.undertow.TexugoLogger;
 
 /**
  * Open listener for HTTP server.  XNIO should be set up to chain the accept handler to post-accept open
@@ -42,8 +43,8 @@ public HttpOpenListener(final Pool<ByteBuffer> pool) {
     }
 
     public void handleEvent(final ConnectedStreamChannel channel) {
-        if(TexugoLogger.REQUEST_LOGGER.isTraceEnabled()) {
-            TexugoLogger.REQUEST_LOGGER.tracef(""Opened connection with %s"", channel.getPeerAddress());
+        if(UndertowLogger.REQUEST_LOGGER.isTraceEnabled()) {
+            UndertowLogger.REQUEST_LOGGER.tracef(""Opened connection with %s"", channel.getPeerAddress());
         }
         final PushBackStreamChannel pushBackStreamChannel = new PushBackStreamChannel(channel);
         HttpReadListener readListener = new HttpReadListener(bufferPool, rootHandler, channel);",2012-07-29T21:52:09Z,127
"@@ -21,7 +21,7 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-import io.undertow.TexugoLogger;
+import io.undertow.UndertowLogger;
 import io.undertow.server.httpparser.HttpExchangeBuilder;
 import io.undertow.server.httpparser.HttpParser;
 import io.undertow.server.httpparser.ParseState;
@@ -67,8 +67,8 @@ public void handleEvent(final PushBackStreamChannel channel) {
             try {
                 res = channel.read(buffer);
             } catch (IOException e) {
-                if(TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                    TexugoLogger.REQUEST_LOGGER.debugf(e, ""Connection closed with IOException"");
+                if(UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                    UndertowLogger.REQUEST_LOGGER.debugf(e, ""Connection closed with IOException"");
                 }
                 safeClose(channel);
                 return;
@@ -81,8 +81,8 @@ public void handleEvent(final PushBackStreamChannel channel) {
                     channel.shutdownReads();
                     // TODO: enqueue a write handler which shuts down the write side of the connection
                 } catch (IOException e) {
-                    if(TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                        TexugoLogger.REQUEST_LOGGER.debugf(e, ""Connection closed with IOException when attempting to shut down reads"");
+                    if(UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                        UndertowLogger.REQUEST_LOGGER.debugf(e, ""Connection closed with IOException when attempting to shut down reads"");
                     }
                     // fuck it, it's all ruined
                     IoUtils.safeClose(channel);
@@ -127,7 +127,7 @@ public void handleComplete() {
 
                 } catch (Throwable t) {
                     //TODO: we should attempt to return a 500 status code in this situation
-                    TexugoLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);
+                    UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);
                     IoUtils.safeClose(underlyingChannel);
                 }
             }",2012-07-29T21:52:09Z,105
"@@ -26,7 +26,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import io.undertow.TexugoMessages;
+import io.undertow.UndertowMessages;
 import io.undertow.util.AbstractAttachable;
 import io.undertow.util.GatedStreamSinkChannel;
 import io.undertow.util.HeaderMap;
@@ -290,7 +290,7 @@ public StreamSourceChannel getRequestChannel() {
         for (ChannelWrapper wrapper : wrappers) {
             channel = ((ChannelWrapper<StreamSourceChannel>) wrapper).wrap(channel, this);
             if (channel == null) {
-                throw TexugoMessages.MESSAGES.failedToAcquireRequestChannel();
+                throw UndertowMessages.MESSAGES.failedToAcquireRequestChannel();
             }
         }
         return channel;
@@ -331,7 +331,7 @@ public StreamSinkChannel getResponseChannel() {
         for (ChannelWrapper wrapper : wrappers) {
             channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(channel, this);
             if (channel == null) {
-                throw TexugoMessages.MESSAGES.failedToAcquireResponseChannel();
+                throw UndertowMessages.MESSAGES.failedToAcquireResponseChannel();
             }
         }
         return channel;
@@ -359,7 +359,7 @@ public void setResponseCode(final int responseCode) {
         do {
             oldVal = responseState;
             if (allAreSet(oldVal, FLAG_RESPONSE_SENT)) {
-                throw TexugoMessages.MESSAGES.responseAlreadyStarted();
+                throw UndertowMessages.MESSAGES.responseAlreadyStarted();
             }
             newVal = oldVal & ~MASK_RESPONSE_CODE | responseCode & MASK_RESPONSE_CODE;
         } while (!responseStateUpdater.compareAndSet(this, oldVal, newVal));
@@ -377,7 +377,7 @@ public void addRequestWrapper(final ChannelWrapper<StreamSinkChannel> wrapper) {
         do {
             oldVal = requestWrappers;
             if (oldVal == null) {
-                throw TexugoMessages.MESSAGES.requestChannelAlreadyProvided();
+                throw UndertowMessages.MESSAGES.requestChannelAlreadyProvided();
             }
             oldLen = oldVal.length;
             newVal = Arrays.copyOf(oldVal, oldLen + 1);
@@ -397,7 +397,7 @@ public void addResponseWrapper(final ChannelWrapper<StreamSinkChannel> wrapper)
         do {
             oldVal = responseWrappers;
             if (oldVal == null) {
-                throw TexugoMessages.MESSAGES.responseChannelAlreadyProvided();
+                throw UndertowMessages.MESSAGES.responseChannelAlreadyProvided();
             }
             oldLen = oldVal.length;
             newVal = Arrays.copyOf(oldVal, oldLen + 1);
@@ -455,7 +455,7 @@ void startResponse() throws IllegalStateException {
         do {
             oldVal = responseState;
             if (allAreSet(oldVal, FLAG_RESPONSE_SENT)) {
-                throw TexugoMessages.MESSAGES.responseAlreadyStarted();
+                throw UndertowMessages.MESSAGES.responseAlreadyStarted();
             }
             newVal = oldVal | FLAG_RESPONSE_SENT;
         } while (!responseStateUpdater.compareAndSet(this, oldVal, newVal));",2012-07-29T21:52:09Z,132
"@@ -18,7 +18,7 @@
 
 package io.undertow.server.handlers;
 
-import io.undertow.TexugoMessages;
+import io.undertow.UndertowMessages;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -51,7 +51,7 @@ public static void executeHandler(final HttpHandler handler, final HttpServerExc
 
     public static void handlerNotNull(final HttpHandler handler) {
         if(handler == null) {
-            throw TexugoMessages.MESSAGES.handlerCannotBeNull();
+            throw UndertowMessages.MESSAGES.handlerCannotBeNull();
         }
     }
 }",2012-07-29T21:52:09Z,84
"@@ -25,7 +25,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import io.undertow.TexugoLogger;
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -51,8 +51,8 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
         if (origin == null) {
             if (requireOriginHeader) {
                 //TODO: Is 403 (Forbidden) the best response code
-                if (TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                    TexugoLogger.REQUEST_LOGGER.debugf(""Refusing request for %s due to lack of Origin: header"", exchange.getRequestPath());
+                if (UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                    UndertowLogger.REQUEST_LOGGER.debugf(""Refusing request for %s due to lack of Origin: header"", exchange.getRequestPath());
                 }
                 HttpHandlers.executeHandler(originFailedHandler, exchange, completionHandler);
                 return;
@@ -67,16 +67,16 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
                         break;
                     }
                 } else if (requireAllOrigins) {
-                    if (TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                        TexugoLogger.REQUEST_LOGGER.debugf(""Refusing request for %s due to Origin %s not being in the allowed origins list"", exchange.getRequestPath(), header);
+                    if (UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                        UndertowLogger.REQUEST_LOGGER.debugf(""Refusing request for %s due to Origin %s not being in the allowed origins list"", exchange.getRequestPath(), header);
                     }
                     HttpHandlers.executeHandler(originFailedHandler, exchange, completionHandler);
                     return;
                 }
             }
             if (!found) {
-                if (TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                    TexugoLogger.REQUEST_LOGGER.debugf(""Refusing request for %s as none of the specified origins %s were in the allowed origins list"", exchange.getRequestPath(), origin);
+                if (UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                    UndertowLogger.REQUEST_LOGGER.debugf(""Refusing request for %s as none of the specified origins %s were in the allowed origins list"", exchange.getRequestPath(), origin);
                 }
                 HttpHandlers.executeHandler(originFailedHandler, exchange, completionHandler);
                 return;",2012-07-29T21:52:09Z,98
"@@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentMap;
 
-import io.undertow.TexugoMessages;
+import io.undertow.UndertowMessages;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -88,7 +88,7 @@ public void setDefaultHandler(HttpHandler defaultHandler) {
     public void addPath(final String path, final HttpHandler handler) {
         HttpHandlers.handlerNotNull(handler);
         if(path == null || path.isEmpty()) {
-            throw TexugoMessages.MESSAGES.pathMustBeSpecified();
+            throw UndertowMessages.MESSAGES.pathMustBeSpecified();
         }
         if(path.charAt(0) != '/') {
             paths.put(""/"" + path, handler);
@@ -99,7 +99,7 @@ public void addPath(final String path, final HttpHandler handler) {
 
     public void removePath(final String path) {
         if(path == null || path.isEmpty()) {
-            throw TexugoMessages.MESSAGES.pathMustBeSpecified();
+            throw UndertowMessages.MESSAGES.pathMustBeSpecified();
         }
         if(path.charAt(0) != '/') {
             paths.remove(""/"" + path);",2012-07-29T21:52:09Z,88
"@@ -18,7 +18,7 @@
 
 package io.undertow.server.handlers.blocking;
 
-import io.undertow.TexugoLogger;
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -62,8 +62,8 @@ public void run() {
                         handler.handleRequest(blockingExchange);
                     }
                 } catch (Throwable t) {
-                    if (TexugoLogger.REQUEST_LOGGER.isDebugEnabled()) {
-                        TexugoLogger.REQUEST_LOGGER.debugf(t, ""Blocking request failed %s"", blockingExchange);
+                    if (UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
+                        UndertowLogger.REQUEST_LOGGER.debugf(t, ""Blocking request failed %s"", blockingExchange);
                     }
                 } finally {
                     completionHandler.handleComplete();",2012-07-29T21:52:09Z,75
"@@ -26,7 +26,7 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 
-import io.undertow.TexugoLogger;
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -70,7 +70,7 @@ public void handleComplete() {
                 Set<Integer> codes = responseCodes;
                 if (!exchange.isResponseStarted() &&  codes.contains(exchange.getResponseCode())) {
                     if(!file.exists()) {
-                        TexugoLogger.ROOT_LOGGER.errorPageDoesNotExist(file);
+                        UndertowLogger.ROOT_LOGGER.errorPageDoesNotExist(file);
                         completionHandler.handleComplete();
                     } else  {
                         final StreamSinkChannel response = exchange.getResponseChannel();
@@ -84,7 +84,7 @@ protected void writeDone(final StreamSinkChannel channel) {
                             response.getWriteSetter().set(listener);
                             response.resumeWrites();
                         } catch (IOException e) {
-                            TexugoLogger.ROOT_LOGGER.errorLoadingErrorPage(e, file);
+                            UndertowLogger.ROOT_LOGGER.errorLoadingErrorPage(e, file);
                             completionHandler.handleComplete();
                         }
                     }",2012-07-29T21:52:09Z,423
"@@ -24,10 +24,10 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentMap;
 
+import io.undertow.UndertowLogger;
+import io.undertow.UndertowMessages;
 import org.xnio.FinishedIoFuture;
 import org.xnio.IoFuture;
-import io.undertow.TexugoLogger;
-import io.undertow.TexugoMessages;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.SecureHashMap;
 
@@ -66,7 +66,7 @@ public IoFuture<Session> createSession(final HttpServerExchange serverExchange)
         if(config != null) {
             config.setSessionCookie(serverExchange, session);
         } else {
-            TexugoLogger.REQUEST_LOGGER.couldNotFindSessionCookieConfig();
+            UndertowLogger.REQUEST_LOGGER.couldNotFindSessionCookieConfig();
         }
         return new FinishedIoFuture<Session>(session);
     }
@@ -127,7 +127,7 @@ public void requestDone(final HttpServerExchange serverExchange) {
         public long getCreationTime() {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             return sess.creationTime;
         }
@@ -136,7 +136,7 @@ public long getCreationTime() {
         public long getLastAccessedTime() {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             return sess.lastAccessed;
         }
@@ -145,7 +145,7 @@ public long getLastAccessedTime() {
         public void setMaxInactiveInterval(final int interval) {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             sess.maxInactiveInterval = interval;
         }
@@ -154,7 +154,7 @@ public void setMaxInactiveInterval(final int interval) {
         public int getMaxInactiveInterval() {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             return sess.maxInactiveInterval;
         }
@@ -163,7 +163,7 @@ public int getMaxInactiveInterval() {
         public IoFuture<Object> getAttribute(final String name) {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             return new FinishedIoFuture<Object>(sess.attributes.get(name));
         }
@@ -172,7 +172,7 @@ public IoFuture<Object> getAttribute(final String name) {
         public IoFuture<Set<String>> getAttributeNames() {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             return new FinishedIoFuture<Set<String>>(sess.attributes.keySet());
         }
@@ -181,7 +181,7 @@ public IoFuture<Set<String>> getAttributeNames() {
         public IoFuture<Void> setAttribute(final String name, final Object value) {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.put(name, value);
             for (SessionListener listener : listeners) {
@@ -198,7 +198,7 @@ public IoFuture<Void> setAttribute(final String name, final Object value) {
         public IoFuture<Void> removeAttribute(final String name) {
             final InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw TexugoMessages.MESSAGES.sessionNotFound(sessionId);
+                throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.remove(name);
             for (SessionListener listener : listeners) {
@@ -218,7 +218,7 @@ public IoFuture<Void> invalidate(final HttpServerExchange exchange) {
             if(config != null) {
                 config.clearCookie(exchange, this);
             } else {
-                TexugoLogger.REQUEST_LOGGER.couldNotFindSessionCookieConfig();
+                UndertowLogger.REQUEST_LOGGER.couldNotFindSessionCookieConfig();
             }
             return new FinishedIoFuture<Void>(null);
         }",2012-07-29T21:52:09Z,13
"@@ -21,9 +21,9 @@
 import java.io.IOException;
 import java.util.Deque;
 
+import io.undertow.UndertowLogger;
+import io.undertow.UndertowMessages;
 import org.xnio.IoFuture;
-import io.undertow.TexugoLogger;
-import io.undertow.TexugoMessages;
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -55,15 +55,15 @@ public class SessionAttachmentHandler implements HttpHandler {
 
     public SessionAttachmentHandler(final SessionManager sessionManager) {
         if(sessionManager == null) {
-            throw TexugoMessages.MESSAGES.sessionManagerMustNotBeNull();
+            throw UndertowMessages.MESSAGES.sessionManagerMustNotBeNull();
         }
         this.sessionManager = sessionManager;
     }
 
     @Override
     public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
         if (sessionManager == null) {
-            throw TexugoMessages.MESSAGES.sessionManagerMustNotBeNull();
+            throw UndertowMessages.MESSAGES.sessionManagerMustNotBeNull();
         }
         exchange.putAttachment(SessionManager.ATTACHMENT_KEY, sessionManager);
         String path = this.path;
@@ -87,14 +87,14 @@ public void notify(final IoFuture<? extends Session> ioFuture, final Session att
                             HttpHandlers.executeHandler(next, exchange, completionHandler);
                         } else if (ioFuture.getStatus() == IoFuture.Status.FAILED) {
                             //we failed to get the session
-                            TexugoLogger.REQUEST_LOGGER.getSessionFailed(ioFuture.getException());
+                            UndertowLogger.REQUEST_LOGGER.getSessionFailed(ioFuture.getException());
                             HttpHandlers.executeHandler(ResponseCodeHandler.HANDLE_500, exchange, completionHandler);
                         } else {
-                            TexugoLogger.REQUEST_LOGGER.unexpectedStatusGettingSession(ioFuture.getStatus());
+                            UndertowLogger.REQUEST_LOGGER.unexpectedStatusGettingSession(ioFuture.getStatus());
                             HttpHandlers.executeHandler(ResponseCodeHandler.HANDLE_500, exchange, completionHandler);
                         }
                     } catch (IOException e) {
-                        TexugoLogger.REQUEST_LOGGER.getSessionFailed(e);
+                        UndertowLogger.REQUEST_LOGGER.getSessionFailed(e);
                         HttpHandlers.executeHandler(ResponseCodeHandler.HANDLE_500, exchange, completionHandler);
                     }
                 }
@@ -142,7 +142,7 @@ public SessionManager getSessionManager() {
 
     public void setSessionManager(final SessionManager sessionManager) {
         if(sessionManager == null) {
-            throw TexugoMessages.MESSAGES.sessionManagerMustNotBeNull();
+            throw UndertowMessages.MESSAGES.sessionManagerMustNotBeNull();
         }
         this.sessionManager = sessionManager;
     }",2012-07-29T21:52:09Z,37
"@@ -18,7 +18,7 @@
 
 package io.undertow.server.session;
 
-import io.undertow.TexugoLogger;
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Headers;
 
@@ -52,7 +52,7 @@ public SessionCookieConfig(final String cookieName, final String path, final Str
 
     public void setSessionCookie(final HttpServerExchange exchange, final Session session) {
         if(exchange.isResponseStarted()) {
-            TexugoLogger.REQUEST_LOGGER.couldNotSendSessionCookieAsResponseAlreadyStarted();
+            UndertowLogger.REQUEST_LOGGER.couldNotSendSessionCookieAsResponseAlreadyStarted();
             return;
         }
         final StringBuilder header = new StringBuilder(cookieName);
@@ -84,7 +84,7 @@ public void setSessionCookie(final HttpServerExchange exchange, final Session se
 
     public void clearCookie(final HttpServerExchange exchange, final Session session) {
         if(exchange.isResponseStarted()) {
-            TexugoLogger.REQUEST_LOGGER.couldNotInvalidateSessionCookieAsResponseAlreadyStarted();
+            UndertowLogger.REQUEST_LOGGER.couldNotInvalidateSessionCookieAsResponseAlreadyStarted();
             return;
         }
         final StringBuilder header = new StringBuilder(cookieName);",2012-07-29T21:52:09Z,115
"@@ -63,8 +63,7 @@ public class Http2ClientConnection implements ClientConnection {
     static final HttpString METHOD = new HttpString("":method"");
     static final HttpString PATH = new HttpString("":path"");
     static final HttpString SCHEME = new HttpString("":scheme"");
-    static final HttpString VERSION = new HttpString("":version"");
-    static final HttpString HOST = new HttpString("":host"");
+    static final HttpString AUTHORITY = new HttpString("":authority"");
     static final HttpString STATUS = new HttpString("":status"");
 
     private final Http2Channel http2Channel;
@@ -91,9 +90,9 @@ public void handleEvent(Http2Channel channel) {
     public void sendRequest(ClientRequest request, ClientCallback<ClientExchange> clientCallback) {
         request.getRequestHeaders().put(PATH, request.getPath());
         request.getRequestHeaders().put(SCHEME, ""https"");
-        request.getRequestHeaders().put(VERSION, request.getProtocol().toString());
+        request.getRequestHeaders().put(AUTHORITY, request.getProtocol().toString());
         request.getRequestHeaders().put(METHOD, request.getMethod().toString());
-        request.getRequestHeaders().put(HOST, request.getRequestHeaders().getFirst(Headers.HOST));
+        request.getRequestHeaders().put(AUTHORITY, request.getRequestHeaders().getFirst(Headers.HOST));
         request.getRequestHeaders().remove(Headers.HOST);
 
 ",2014-09-10T03:06:17Z,196
"@@ -115,7 +115,7 @@ void responseReady(Http2StreamSourceChannel result) {
         if (status != null && status.length() > 3) {
             statusCode = Integer.parseInt(status.substring(0, 3));
         }
-        headers.remove(Http2ClientConnection.VERSION);
+        headers.remove(Http2ClientConnection.AUTHORITY);
         headers.remove(Http2ClientConnection.STATUS);
         clientResponse = new ClientResponse(statusCode, status != null ? status.substring(3) : """", clientRequest.getProtocol(), headers);
         if (responseListener != null) {",2014-09-10T03:06:17Z,431
"@@ -169,12 +169,15 @@ public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bu
                 throw new RuntimeException(e);
             }
         }
-        sendPreface();
-        sendSettings();
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
         enablePush = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);
         this.decoder = new HpackDecoder(Hpack.DEFAULT_TABLE_SIZE);
         this.encoder = new HpackEncoder(encoderHeaderTableSize);
+
+        if(clientSide) {
+            sendPreface();
+        }
+        sendSettings();
     }
 
     private void sendSettings() {
@@ -248,9 +251,8 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
                 break;
             }
             case FRAME_TYPE_SETTINGS: {
-                if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {
+                    if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {
                     updateSettings(((Http2SettingsParser) frameParser.parser).getSettings());
-                } else {
                     sendSettingsAck();
                 }
                 channel = new Http2SettingsStreamSourceChannel(this, frameData, frameParser.getFrameLength(), ((Http2SettingsParser) frameParser.parser).getSettings());",2014-09-10T03:06:17Z,166
"@@ -51,7 +51,7 @@
  */
 public final class Http2OpenListener implements ChannelListener<StreamConnection>, OpenListener {
 
-    private static final String PROTOCOL_KEY = Http2OpenListener.class.getName() + "".protocol"";
+    //private static final String PROTOCOL_KEY = Http2OpenListener.class.getName() + "".protocol"";
 
     private static final String HTTP2 = ""h2-14"";
     private static final String HTTP_1_1 = ""http/1.1"";
@@ -89,47 +89,27 @@ public void handleEvent(final StreamConnection channel) {
         final PotentialHttp2Connection potentialConnection = new PotentialHttp2Connection(channel);
         channel.getSourceChannel().setReadListener(potentialConnection);
         final SSLEngine sslEngine = JsseXnioSsl.getSslEngine((SslConnection) channel);
-        String existing = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
-        //resuming an existing session, no need for ALPN
-        if (existing != null) {
-            UndertowLogger.REQUEST_LOGGER.debug(""Resuming existing session, not doing NPN negotiation"");
-            if (existing.equals(HTTP2)) {
-                Http2Channel sc = new Http2Channel(channel, bufferPool, new ImmediatePooled<>(ByteBuffer.wrap(new byte[0])), false, false, undertowOptions);
-                sc.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
-                sc.resumeReceives();
-            } else {
-                if (delegate == null) {
-                    UndertowLogger.REQUEST_IO_LOGGER.couldNotInitiateHttp2Connection();
-                    IoUtils.safeClose(channel);
-                    return;
-                }
-                channel.getSourceChannel().setReadListener(null);
-                delegate.handleEvent(channel);
+        ALPN.put(sslEngine, new ALPN.ServerProvider() {
+            @Override
+            public void unsupported() {
+                potentialConnection.selected = HTTP_1_1;
             }
-        } else {
-            ALPN.put(sslEngine, new ALPN.ServerProvider() {
-                @Override
-                public void unsupported() {
-                    potentialConnection.selected = HTTP_1_1;
-                }
 
-                @Override
-                public String select(List<String> strings) {
-                    ALPN.remove(sslEngine);
-                    for (String s : strings) {
-                        if (s.equals(HTTP2)) {
-                            potentialConnection.selected = s;
-                            sslEngine.getSession().putValue(PROTOCOL_KEY, s);
-                            return s;
-                        }
+            @Override
+            public String select(List<String> strings) {
+                ALPN.remove(sslEngine);
+                for (String s : strings) {
+                    if (s.equals(HTTP2)) {
+                        potentialConnection.selected = s;
+                        return s;
                     }
-                    sslEngine.getSession().putValue(PROTOCOL_KEY, HTTP_1_1);
-                    potentialConnection.selected = HTTP_1_1;
-                    return HTTP_1_1;
                 }
-            });
-            potentialConnection.handleEvent(channel.getSourceChannel());
-        }
+                potentialConnection.selected = HTTP_1_1;
+                return HTTP_1_1;
+            }
+        });
+        potentialConnection.handleEvent(channel.getSourceChannel());
+
     }
 
     @Override",2014-09-10T03:06:17Z,375
"@@ -20,6 +20,8 @@
 
 import java.io.IOException;
 import javax.net.ssl.SSLSession;
+
+import io.undertow.util.Protocols;
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;
 import org.xnio.OptionMap;
@@ -52,8 +54,7 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
     private static final HttpString METHOD = new HttpString("":method"");
     private static final HttpString PATH = new HttpString("":path"");
     private static final HttpString SCHEME = new HttpString("":scheme"");
-    private static final HttpString VERSION = new HttpString("":version"");
-    private static final HttpString HOST = new HttpString("":host"");
+    private static final HttpString AUTHORITY = new HttpString("":authority"");
 
     private final HttpHandler rootHandler;
     private final long maxEntitySize;
@@ -96,9 +97,9 @@ public void handleEvent(Http2Channel channel) {
                 final HttpServerExchange exchange = new HttpServerExchange(connection, dataChannel.getHeaders(), dataChannel.getResponseChannel().getHeaders(), maxEntitySize);
                 dataChannel.setMaxStreamSize(maxEntitySize);
                 exchange.setRequestScheme(exchange.getRequestHeaders().getFirst(SCHEME));
-                exchange.setProtocol(new HttpString(exchange.getRequestHeaders().getFirst(VERSION)));
+                exchange.setProtocol(Protocols.HTTP_1_1);
                 exchange.setRequestMethod(new HttpString(exchange.getRequestHeaders().getFirst(METHOD)));
-                exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(HOST));
+                exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(AUTHORITY));
                 final String path = exchange.getRequestHeaders().getFirst(PATH);
                 setRequestPath(exchange, path, encoding, allowEncodingSlash, decodeBuffer);
 ",2014-09-10T03:06:17Z,164
"@@ -74,8 +74,6 @@ public void run() {
         xnio = Xnio.getInstance();
         try {
             worker = xnio.createWorker(OptionMap.builder()
-                    .set(Options.WORKER_WRITE_THREADS, 4)
-                    .set(Options.WORKER_READ_THREADS, 4)
                     .set(Options.CONNECTION_HIGH_WATER, 1000000)
                     .set(Options.CONNECTION_LOW_WATER, 1000000)
                     .set(Options.WORKER_TASK_CORE_THREADS, 10)
@@ -85,7 +83,6 @@ public void run() {
                     .getMap());
 
             OptionMap serverOptions = OptionMap.builder()
-                    .set(Options.WORKER_ACCEPT_THREADS, 4)
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
                     .getMap();",2016-04-17T03:32:31Z,432
"@@ -26,6 +26,7 @@
 import io.undertow.servlet.core.ContextClassLoaderSetupAction;
 import io.undertow.servlet.spec.ServletContextImpl;
 import io.undertow.connector.ByteBufferPool;
+import io.undertow.websockets.extensions.ExtensionHandshake;
 import org.xnio.XnioWorker;
 
 import javax.servlet.DispatcherType;
@@ -34,10 +35,12 @@
 import javax.servlet.ServletContextEvent;
 import javax.servlet.ServletContextListener;
 import javax.websocket.DeploymentException;
+import javax.websocket.Extension;
 import javax.websocket.server.ServerContainer;
 import javax.websocket.server.ServerEndpointConfig;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 
@@ -83,8 +86,11 @@ public void handleDeployment(DeploymentInfo deploymentInfo, ServletContext servl
         if(info.getClientBindAddress() != null) {
             bind = new InetSocketAddress(info.getClientBindAddress(), 0);
         }
-
-        ServerWebSocketContainer container = new ServerWebSocketContainer(deploymentInfo.getClassIntrospecter(), servletContext.getClassLoader(), worker, buffers, threadSetupAction, info.isDispatchToWorkerThread(), bind, info.getReconnectHandler());
+        List<Extension> extensions = new ArrayList<>();
+        for(ExtensionHandshake e: info.getExtensions()) {
+            extensions.add(new ExtensionImpl(e.getName(), Collections.emptyList()));
+        }
+        ServerWebSocketContainer container = new ServerWebSocketContainer(deploymentInfo.getClassIntrospecter(), servletContext.getClassLoader(), worker, buffers, threadSetupAction, info.isDispatchToWorkerThread(), bind, info.getReconnectHandler(), extensions);
         try {
             for (Class<?> annotation : info.getAnnotatedEndpoints()) {
                 container.addEndpoint(annotation);",2016-04-17T03:32:31Z,433
"@@ -125,6 +125,7 @@ public class ServerWebSocketContainer implements ServerContainer, Closeable {
 
     private final List<WebsocketClientSslProvider> clientSslProviders;
     private final List<PauseListener> pauseListeners = new ArrayList<>();
+    private final List<Extension> installedExtensions;
 
     private volatile boolean closed = false;
 
@@ -137,12 +138,17 @@ public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final
     }
 
     public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final ClassLoader classLoader, XnioWorker xnioWorker, ByteBufferPool bufferPool, ThreadSetupAction threadSetupAction, boolean dispatchToWorker, InetSocketAddress clientBindAddress, WebSocketReconnectHandler reconnectHandler) {
+        this(classIntrospecter, classLoader, xnioWorker, bufferPool, threadSetupAction, dispatchToWorker, clientBindAddress, reconnectHandler, Collections.emptyList());
+    }
+
+    public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final ClassLoader classLoader, XnioWorker xnioWorker, ByteBufferPool bufferPool, ThreadSetupAction threadSetupAction, boolean dispatchToWorker, InetSocketAddress clientBindAddress, WebSocketReconnectHandler reconnectHandler, List<Extension> installedExtensions) {
         this.classIntrospecter = classIntrospecter;
         this.bufferPool = bufferPool;
         this.xnioWorker = xnioWorker;
         this.threadSetupAction = threadSetupAction;
         this.dispatchToWorker = dispatchToWorker;
         this.clientBindAddress = clientBindAddress;
+        this.installedExtensions = new ArrayList<>(installedExtensions);
         List<WebsocketClientSslProvider> clientSslProviders = new ArrayList<>();
         for (WebsocketClientSslProvider provider : ServiceLoader.load(WebsocketClientSslProvider.class, classLoader)) {
             clientSslProviders.add(provider);
@@ -616,6 +622,7 @@ public InstanceHandle<Object> createInstance() throws InstantiationException {
                     .decoders(Arrays.asList(serverEndpoint.decoders()))
                     .encoders(Arrays.asList(serverEndpoint.encoders()))
                     .subprotocols(Arrays.asList(serverEndpoint.subprotocols()))
+                    .extensions(installedExtensions)
                     .configurator(configurator)
                     .build();
 ",2016-04-17T03:32:31Z,319
"@@ -20,6 +20,7 @@
 import io.undertow.websockets.WebSocketExtension;
 import io.undertow.websockets.core.WebSocketChannel;
 import io.undertow.websockets.core.protocol.version13.Hybi13Handshake;
+import io.undertow.websockets.extensions.ExtensionHandshake;
 import io.undertow.websockets.jsr.ConfiguredServerEndpoint;
 import io.undertow.websockets.jsr.ExtensionImpl;
 import io.undertow.websockets.spi.WebSocketHttpExchange;
@@ -29,7 +30,9 @@
 import javax.websocket.Extension;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * {@link Hybi13Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfig} and
@@ -78,13 +81,21 @@ protected List<WebSocketExtension> selectedExtension(List<WebSocketExtension> ex
         if(selected == null) {
             return Collections.emptyList();
         }
+        Map<String, ExtensionHandshake> extensionMap = new HashMap<>();
+        for(ExtensionHandshake availible : availableExtensions) {
+            extensionMap.put(availible.getName(), availible);
+        }
         List<WebSocketExtension> ret = new ArrayList<>();
         for(Extension i : selected) {
+            ExtensionHandshake handshake = extensionMap.get(i.getName());
+            if(handshake == null) {
+                continue; //should not happen
+            }
             List<WebSocketExtension.Parameter> parameters = new ArrayList<>();
             for(Extension.Parameter p : i.getParameters()) {
                 parameters.add(new WebSocketExtension.Parameter(p.getName(), p.getValue()));
             }
-            ret.add(new WebSocketExtension(i.getName(), parameters));
+            ret.add(handshake.accept(new WebSocketExtension(i.getName(), parameters)));
         }
 
         return ret;",2016-04-17T03:32:31Z,33
"@@ -26,6 +26,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
+import io.undertow.testutils.DebuggingSlicePool;
 import io.undertow.websockets.extensions.PerMessageDeflateHandshake;
 import io.undertow.websockets.jsr.ServerWebSocketContainer;
 import io.undertow.websockets.jsr.WebSocketDeploymentInfo;
@@ -80,7 +81,8 @@ public void run() {
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
                     .getMap();
-            HttpOpenListener openListener = new HttpOpenListener(new DefaultByteBufferPool(true, 8192));
+            DebuggingSlicePool pool = new DebuggingSlicePool( new DefaultByteBufferPool(true, 8192));
+            HttpOpenListener openListener = new HttpOpenListener(pool);
             ChannelListener acceptListener = ChannelListeners.openListenerAdapter(openListener);
             AcceptingChannel<StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(port), acceptListener, serverOptions);
 
@@ -95,8 +97,9 @@ public void run() {
                     .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                     .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME,
                             new WebSocketDeploymentInfo()
-                                    .setBuffers(new DefaultByteBufferPool(true, 100))
+                                    .setBuffers(pool)
                                     .setWorker(worker)
+                                    .setDispatchToWorkerThread(true)
                                     .addEndpoint(AutobahnAnnotatedExtensionsEndpoint.class)
                                     .addListener(new WebSocketDeploymentInfo.ContainerReadyListener() {
                                         @Override",2016-04-17T03:32:31Z,434
"@@ -21,10 +21,13 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Writer;
+import java.util.List;
 
+import javax.websocket.Extension;
 import javax.websocket.OnMessage;
 import javax.websocket.Session;
 import javax.websocket.server.ServerEndpoint;
+import javax.websocket.server.ServerEndpointConfig;
 
 /**
  * An Endpoint class to be used in Autobahn test suite.
@@ -34,9 +37,16 @@
  * @author Stuart Douglas
  * @author Lucas Ponce
  */
-@ServerEndpoint(""/"")
+@ServerEndpoint(value = ""/"", configurator = AutobahnAnnotatedExtensionsEndpoint.Config.class)
 public class AutobahnAnnotatedExtensionsEndpoint {
 
+    public static class Config extends ServerEndpointConfig.Configurator {
+        @Override
+        public List<Extension> getNegotiatedExtensions(List<Extension> installed, List<Extension> requested) {
+            return super.getNegotiatedExtensions(installed, requested);
+        }
+    }
+
     Writer writer;
     OutputStream stream;
     int txtCount = 0;",2016-04-17T03:32:31Z,435
"@@ -73,6 +73,8 @@ public class DefaultAccessLogReceiver implements AccessLogReceiver, Runnable, Cl
 
     private Writer writer = null;
 
+    private volatile boolean closed = false;
+
     public DefaultAccessLogReceiver(final Executor logWriteExecutor, final File outputDirectory, final String logBaseName) {
         this(logWriteExecutor, outputDirectory, logBaseName, null);
     }
@@ -89,9 +91,10 @@ public DefaultAccessLogReceiver(final Executor logWriteExecutor, final File outp
 
     private void calculateChangeOverPoint() {
         Calendar calendar = Calendar.getInstance();
-        calendar.set(Calendar.SECOND, 59);
-        calendar.set(Calendar.MINUTE, 59);
-        calendar.set(Calendar.HOUR, 23);
+        calendar.set(Calendar.SECOND, 0);
+        calendar.set(Calendar.MINUTE, 0);
+        calendar.set(Calendar.HOUR, 0);
+        calendar.add(Calendar.DATE, 1);
         changeOverPoint = calendar.getTimeInMillis();
         SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd"");
         currentDateString = df.format(new Date());
@@ -141,6 +144,14 @@ public void run() {
                 if (stateUpdater.compareAndSet(this, 0, 1)) {
                     logWriteExecutor.execute(this);
                 }
+            } else if(closed) {
+                try {
+                    writer.flush();
+                    writer.close();
+                    writer = null;
+                } catch (IOException e) {
+                    UndertowLogger.ROOT_LOGGER.errorWritingAccessLog(e);
+                }
             }
         }
     }
@@ -215,8 +226,9 @@ public void rotate() {
 
     @Override
     public void close() throws IOException {
-        writer.flush();
-        writer.close();
-        writer = null;
+        closed = true;
+        if (stateUpdater.compareAndSet(this, 0, 1)) {
+            logWriteExecutor.execute(this);
+        }
     }
 }",2014-11-03T22:24:23Z,237
"@@ -19,7 +19,6 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -45,16 +44,7 @@ protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxExcept
     }
 
     protected URI getRedirectURI(HttpServerExchange exchange, int port) throws URISyntaxException {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        } else {
-            if (host.startsWith(""["")) {
-                host = host.substring(1, host.indexOf(']'));
-            } else {
-                host = host.substring(0, host.indexOf(':'));
-            }
-        }
+        String host = exchange.getHostName();
 
         String queryString = exchange.getQueryString();
         return new URI(""https"", null, host, port, exchange.getRequestURI(),",2013-05-27T02:00:32Z,281
"@@ -159,12 +159,8 @@ protected Integer servePage(final HttpServerExchange exchange, final String loca
 
 
     static void sendRedirect(final HttpServerExchange exchange, final String location) {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        }
         // TODO - String concatenation to construct URLS is extremely error prone - switch to a URI which will better handle this.
-        String loc = exchange.getRequestScheme() + ""://"" + host + location;
+        String loc = exchange.getRequestScheme() + ""://"" + exchange.getHostAndPort() + location;
         exchange.getResponseHeaders().put(Headers.LOCATION, loc);
     }
 }",2013-05-27T02:00:32Z,148
"@@ -44,6 +44,7 @@
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.NetworkUtils;
 import io.undertow.util.Protocols;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.WrapperConduitFactory;
@@ -453,12 +454,54 @@ public String getRequestURL() {
         if (isHostIncludedInRequestURI()) {
             return getRequestURI();
         } else {
-            String host = getRequestHeaders().getFirst(Headers.HOST);
-            if (host == null) {
-                host = getDestinationAddress().getAddress().getHostAddress();
+            return getRequestScheme() + ""://"" + getHostAndPort() + getRequestURI();
+        }
+    }
+
+    /**
+     * Return the host that this request was sent to, in general this will be the
+     * value of the Host header, minus the port specifier.
+     *
+     * If this resolves to an IPv6 address it will not be enclosed by square brackets.
+     * Care must be taken when constructing URLs based on this method to ensure IPv6 URLs
+     * are handled correctly.
+     *
+     * @return The host part of the destination address
+     */
+    public String getHostName() {
+        String host = requestHeaders.getFirst(Headers.HOST);
+        if (host == null) {
+            host = getDestinationAddress().getAddress().getHostAddress();
+        } else {
+            if (host.startsWith(""["")) {
+                host = host.substring(1, host.indexOf(']'));
+            } else if (host.indexOf(':') != -1) {
+                host = host.substring(0, host.indexOf(':'));
+            }
+        }
+        return host;
+    }
+
+    /**
+     * Return the host, and also the port if this request was sent to a non-standard port. In general
+     * this will just be the value of the Host header.
+     *
+     * If this resolves to an IPv6 address it *will*  be enclosed by square brackets. The return
+     * value of this method is suitable for inclusion in a URL.
+     *
+     * @return The host and port part of the destination address
+     */
+    public String getHostAndPort() {
+        String host = requestHeaders.getFirst(Headers.HOST);
+        if (host == null) {
+            host = NetworkUtils.formatPossibleIpv6Address(getDestinationAddress().getAddress().getHostAddress());
+            int port = getDestinationAddress().getPort();
+            if (!((getRequestScheme().equals(""http"") && port == 80)
+                    || (getRequestScheme().equals(""https"") && port == 8080))) {
+                host = host + "":"" + port;
             }
-            return getRequestScheme() + ""://"" + host + getRequestURI();
         }
+        return host;
     }
 
     /**",2013-05-27T02:00:32Z,132
"@@ -0,0 +1,24 @@
+package io.undertow.util;
+
+/**
+ * @author Stuart Douglas
+ */
+public class NetworkUtils {
+
+    public static String formatPossibleIpv6Address(String address) {
+        if (address == null) {
+            return address;
+        }
+        if (!address.contains("":"")) {
+            return address;
+        }
+        if (address.startsWith(""["") && address.endsWith(""]"")) {
+            return address;
+        }
+        return ""["" + address + ""]"";
+    }
+
+    private NetworkUtils() {
+
+    }
+}",2013-05-27T02:00:32Z,174
"@@ -696,15 +696,7 @@ public String getScheme() {
 
     @Override
     public String getServerName() {
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if(host != null) {
-            if(host.contains("":"")) {
-                String[] split = host.split("":"");
-                return split[0];
-            }
-            return host;
-        }
-        return exchange.getDestinationAddress().getHostName();
+        return exchange.getHostName();
     }
 
     @Override",2013-05-27T02:00:32Z,147
"@@ -156,11 +156,7 @@ public void sendRedirect(final String location) throws IOException {
             }
             realPath = servletContext.getContextPath() + CanonicalPathUtils.canonicalize(current + location);
         }
-        String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
-        if (host == null) {
-            host = exchange.getDestinationAddress().getAddress().getHostAddress();
-        }
-        String loc = exchange.getRequestScheme() + ""://"" + host + realPath;
+        String loc = exchange.getRequestScheme() + ""://"" + exchange.getHostAndPort() + realPath;
         exchange.getResponseHeaders().put(Headers.LOCATION, loc);
         responseDone();
     }",2013-05-27T02:00:32Z,170
"@@ -434,4 +434,7 @@ public interface UndertowMessages {
 
     @Message(id = 135, value = ""renegotiation failed"")
     IllegalStateException rengotiationFailed();
+
+    @Message(id = 136, value = ""User agent charset string must have an even number of items, in the form pattern,charset,pattern,charset,... Instead got: %s"")
+    IllegalArgumentException userAgentCharsetMustHaveEvenNumberOfItems(String supplied);
 }",2016-01-31T21:14:39Z,68
"@@ -21,10 +21,16 @@
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
+import io.undertow.UndertowMessages;
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.AuthenticationMechanismFactory;
 import io.undertow.security.api.SecurityContext;
@@ -34,6 +40,8 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.form.FormParserFactory;
 import io.undertow.util.FlexBase64;
+import io.undertow.util.Headers;
+
 import static io.undertow.util.Headers.AUTHORIZATION;
 import static io.undertow.util.Headers.BASIC;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
@@ -47,6 +55,17 @@
 public class BasicAuthenticationMechanism implements AuthenticationMechanism {
 
     public static final String SILENT = ""silent"";
+    public static final String CHARSET = ""charset"";
+    /**
+     * A comma separated list of patterns and charsets. The pattern is a regular expression.
+     *
+     * Because different browsers user different encodings this allows for the correct encoding to be selected based
+     * on the current browser. In general though it is recommended that BASIC auth not be used when passwords contain
+     * characters outside ASCII, as some browsers use the current locate to determine encoding.
+     *
+     * This list must have an even number of elements, as it is interpreted as pattern,charset,pattern,charset,...
+     */
+    public static final String USER_AGENT_CHARSETS = ""user-agent-charsets"";
 
     private final String name;
     private final String challenge;
@@ -65,6 +84,9 @@ public class BasicAuthenticationMechanism implements AuthenticationMechanism {
 
     private final IdentityManager identityManager;
 
+    private final Charset charset;
+    private final Map<Pattern, Charset> userAgentCharsets;
+
     public BasicAuthenticationMechanism(final String realmName) {
         this(realmName, ""BASIC"");
     }
@@ -76,12 +98,17 @@ public BasicAuthenticationMechanism(final String realmName, final String mechani
     public BasicAuthenticationMechanism(final String realmName, final String mechanismName, final boolean silent) {
         this(realmName, mechanismName, silent, null);
     }
-
     public BasicAuthenticationMechanism(final String realmName, final String mechanismName, final boolean silent, final IdentityManager identityManager) {
+        this(realmName, mechanismName, silent, identityManager, StandardCharsets.UTF_8, Collections.emptyMap());
+    }
+
+    public BasicAuthenticationMechanism(final String realmName, final String mechanismName, final boolean silent, final IdentityManager identityManager, Charset charset, Map<Pattern, Charset> userAgentCharsets) {
         this.challenge = BASIC_PREFIX + ""realm=\"""" + realmName + ""\"""";
         this.name = mechanismName;
         this.silent = silent;
         this.identityManager = identityManager;
+        this.charset = charset;
+        this.userAgentCharsets = Collections.unmodifiableMap(new LinkedHashMap<>(userAgentCharsets));
     }
 
     @SuppressWarnings(""deprecation"")
@@ -103,7 +130,21 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
                     String plainChallenge = null;
                     try {
                         ByteBuffer decode = FlexBase64.decode(base64Challenge);
-                        plainChallenge = new String(decode.array(), decode.arrayOffset(), decode.limit(), StandardCharsets.UTF_8);
+
+                        Charset charset = this.charset;
+                        if(!userAgentCharsets.isEmpty()) {
+                            String ua = exchange.getRequestHeaders().getFirst(Headers.USER_AGENT);
+                            if(ua != null) {
+                                for (Map.Entry<Pattern, Charset> entry : userAgentCharsets.entrySet()) {
+                                    if(entry.getKey().matcher(ua).find()) {
+                                        charset = entry.getValue();
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+
+                        plainChallenge = new String(decode.array(), decode.arrayOffset(), decode.limit(), charset);
                     } catch (IOException e) {
                     }
                     int colonPos;
@@ -172,7 +213,23 @@ public Factory(IdentityManager identityManager) {
         public AuthenticationMechanism create(String mechanismName, FormParserFactory formParserFactory, Map<String, String> properties) {
             String realm = properties.get(REALM);
             String silent = properties.get(SILENT);
-            return new BasicAuthenticationMechanism(realm, mechanismName, silent != null && silent.equals(""true""), identityManager);
+            String charsetString = properties.get(CHARSET);
+            Charset charset = charsetString == null ? StandardCharsets.UTF_8 : Charset.forName(charsetString);
+            Map<Pattern, Charset> userAgentCharsets = new HashMap<>();
+            String userAgentString = properties.get(USER_AGENT_CHARSETS);
+            if(userAgentString != null) {
+                String[] parts = userAgentString.split("","");
+                if(parts.length % 2 != 0) {
+                    throw UndertowMessages.MESSAGES.userAgentCharsetMustHaveEvenNumberOfItems(userAgentString);
+                }
+                for(int i = 0; i < parts.length; i += 2) {
+                    Pattern pattern = Pattern.compile(parts[i]);
+                    Charset c = Charset.forName(parts[i + 1]);
+                    userAgentCharsets.put(pattern, c);
+                }
+            }
+
+            return new BasicAuthenticationMechanism(realm, mechanismName, silent != null && silent.equals(""true""), identityManager, charset, userAgentCharsets);
         }
     }
 ",2016-01-31T21:14:39Z,1
"@@ -86,6 +86,7 @@ public abstract class AuthenticationTestBase {
         final Map<String, char[]> passwordUsers = new HashMap<>(2);
         passwordUsers.put(""userOne"", ""passwordOne"".toCharArray());
         passwordUsers.put(""userTwo"", ""passwordTwo"".toCharArray());
+        passwordUsers.put(""encodingUser"", ""password-ü"".toCharArray());
 
         identityManager = new IdentityManager() {
 ",2016-01-31T21:14:39Z,74
"@@ -0,0 +1,164 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.servlet.test.security.basic;
+
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.servlet.api.AuthMethodConfig;
+import io.undertow.servlet.api.DeploymentInfo;
+import io.undertow.servlet.api.DeploymentManager;
+import io.undertow.servlet.api.LoginConfig;
+import io.undertow.servlet.api.SecurityConstraint;
+import io.undertow.servlet.api.SecurityInfo;
+import io.undertow.servlet.api.ServletContainer;
+import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.api.WebResourceCollection;
+import io.undertow.servlet.test.SimpleServletTestCase;
+import io.undertow.servlet.test.security.SendAuthTypeServlet;
+import io.undertow.servlet.test.security.SendUsernameServlet;
+import io.undertow.servlet.test.security.constraint.ServletIdentityManager;
+import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.FlexBase64;
+import io.undertow.util.Headers;
+import io.undertow.util.StatusCodes;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.servlet.ServletException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.Map;
+
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.BASIC;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class ServletBasicAuthTestCase {
+    private static final String REALM_NAME = ""Servlet_Realm"";
+
+    @BeforeClass
+    public static void setup() throws ServletException {
+
+        final PathHandler path = new PathHandler();
+
+        final ServletContainer container = ServletContainer.Factory.newInstance();
+
+        ServletInfo usernameServlet = new ServletInfo(""Username Servlet"", SendUsernameServlet.class)
+                .addMapping(""/secured/username"");
+
+        ServletInfo authTypeServlet = new ServletInfo(""Auth Type Servlet"", SendAuthTypeServlet.class)
+                .addMapping(""/secured/authType"");
+
+        ServletIdentityManager identityManager = new ServletIdentityManager();
+        identityManager.addUser(""user1"", ""password1"", ""role1"");
+        identityManager.addUser(""charsetUser"", ""password-ü"", ""role1"");
+
+        LoginConfig loginConfig = new LoginConfig(REALM_NAME);
+        Map<String, String> props = new HashMap<>();
+        props.put(""charset"", ""ISO_8859_1"");
+        props.put(""user-agent-charsets"", ""Chrome,UTF-8,OPR,UTF-8"");
+        loginConfig.addFirstAuthMethod(new AuthMethodConfig(""BASIC"", props));
+        DeploymentInfo builder = new DeploymentInfo()
+                .setClassLoader(SimpleServletTestCase.class.getClassLoader())
+                .setContextPath(""/servletContext"")
+                .setClassIntrospecter(TestClassIntrospector.INSTANCE)
+                .setDeploymentName(""servletContext.war"")
+                .setIdentityManager(identityManager)
+                .setLoginConfig(loginConfig)
+                .addServlets(usernameServlet, authTypeServlet);
+
+        builder.addSecurityConstraint(new SecurityConstraint()
+                .addWebResourceCollection(new WebResourceCollection()
+                        .addUrlPattern(""/secured/*""))
+                .addRoleAllowed(""role1"")
+                .setEmptyRoleSemantic(SecurityInfo.EmptyRoleSemantic.DENY));
+
+        DeploymentManager manager = container.addDeployment(builder);
+        manager.deploy();
+        path.addPrefixPath(builder.getContextPath(), manager.start());
+
+        DefaultServer.setRootHandler(path);
+    }
+
+    @Test
+    public void testChallengeSent() throws Exception {
+        TestHttpClient client = new TestHttpClient();
+        String url = DefaultServer.getDefaultServerURL() + ""/servletContext/secured/username"";
+        HttpGet get = new HttpGet(url);
+        HttpResponse result = client.execute(get);
+        HttpClientUtils.readResponse(result);
+        assertEquals(StatusCodes.UNAUTHORIZED, result.getStatusLine().getStatusCode());
+        Header[] values = result.getHeaders(WWW_AUTHENTICATE.toString());
+        assertEquals(1, values.length);
+        String value = values[0].getValue();
+        assertTrue(value.startsWith(""Basic""));
+    }
+
+    @Test
+    public void testUserName() throws Exception {
+        testCall(""username"", ""user1"", StandardCharsets.UTF_8, ""Chrome"", ""user1"", ""password1"", 200);
+    }
+
+    @Test
+    public void testAuthType() throws Exception {
+        testCall(""authType"", ""BASIC"", StandardCharsets.UTF_8, ""Chrome"", ""user1"", ""password1"", 200);
+    }
+
+    @Test
+    public void testBasicAuthNonAscii() throws Exception {
+        testCall(""authType"", ""BASIC"", StandardCharsets.UTF_8, ""Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"", ""charsetUser"", ""password-ü"", 200);
+        testCall(""authType"", ""BASIC"", StandardCharsets.ISO_8859_1, ""Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"", ""charsetUser"", ""password-ü"", 401);
+        testCall(""authType"", ""BASIC"", StandardCharsets.ISO_8859_1, ""Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1"", ""charsetUser"", ""password-ü"", 200);
+        testCall(""authType"", ""BASIC"", StandardCharsets.UTF_8, ""Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1"", ""charsetUser"", ""password-ü"", 401);
+    }
+
+    public void testCall(final String path, final String expectedResponse, Charset charset, String userAgent, String user, String password, int expect) throws Exception {
+        TestHttpClient client = new TestHttpClient();
+        try {
+            String url = DefaultServer.getDefaultServerURL() + ""/servletContext/secured/"" + path;
+            HttpGet get = new HttpGet(url);
+            get = new HttpGet(url);
+            get.addHeader(Headers.USER_AGENT_STRING, userAgent);
+            get.addHeader(AUTHORIZATION.toString(), BASIC + "" "" + FlexBase64.encodeString((user + "":"" + password).getBytes(charset), false));
+            HttpResponse result = client.execute(get);
+            assertEquals(expect, result.getStatusLine().getStatusCode());
+
+            final String response = HttpClientUtils.readResponse(result);
+            if(expect == 200) {
+                assertEquals(expectedResponse, response);
+            }
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+}",2016-01-31T21:14:39Z,436
"@@ -69,6 +69,7 @@ public class InMemorySessionManager implements SessionManager, SessionManagerSta
     private final AtomicLong rejectedSessionCount = new AtomicLong();
     private final AtomicLong averageSessionLifetime = new AtomicLong();
     private final AtomicLong longestSessionLifetime = new AtomicLong();
+    private final boolean statisticsEnabled;
 
     private volatile long startTime;
 
@@ -80,8 +81,13 @@ public InMemorySessionManager(String deploymentName, int maxSessions, boolean ex
     }
 
     public InMemorySessionManager(SessionIdGenerator sessionIdGenerator, String deploymentName, int maxSessions, boolean expireOldestUnusedSessionOnMax) {
+        this(sessionIdGenerator, deploymentName, maxSessions, expireOldestUnusedSessionOnMax, true);
+    }
+
+    public InMemorySessionManager(SessionIdGenerator sessionIdGenerator, String deploymentName, int maxSessions, boolean expireOldestUnusedSessionOnMax, boolean statisticsEnabled) {
         this.sessionIdGenerator = sessionIdGenerator;
         this.deploymentName = deploymentName;
+        this.statisticsEnabled = statisticsEnabled;
         this.expireOldestUnusedSessionOnMax = expireOldestUnusedSessionOnMax;
         this.sessions = new ConcurrentHashMap<>();
         this.maxSize = maxSessions;
@@ -135,7 +141,9 @@ public Session createSession(final HttpServerExchange serverExchange, final Sess
                     }
                 }
             } else if(sessions.size() >= maxSize) {
-                rejectedSessionCount.incrementAndGet();
+                if(statisticsEnabled) {
+                    rejectedSessionCount.incrementAndGet();
+                }
                 throw UndertowMessages.MESSAGES.tooManySessions(maxSize);
             }
         }
@@ -161,7 +169,9 @@ public Session createSession(final HttpServerExchange serverExchange, final Sess
         } else {
             evictionToken = null;
         }
-        createdSessionCount.incrementAndGet();
+        if(statisticsEnabled) {
+            createdSessionCount.incrementAndGet();
+        }
         final SessionImpl session = new SessionImpl(this, sessionID, config, serverExchange.getIoThread(), serverExchange.getConnection().getWorker(), evictionToken, defaultSessionTimeout);
         sessions.put(sessionID, session);
         config.setSessionId(serverExchange, session.getId());
@@ -499,23 +509,25 @@ void invalidate(final HttpServerExchange exchange, SessionListener.SessionDestro
             sessionManager.sessionListeners.sessionDestroyed(this, exchange, reason);
             invalid = true;
 
-            long avg, newAvg;
-            do {
-                avg = sessionManager.averageSessionLifetime.get();
-                BigDecimal bd = new BigDecimal(avg);
-                bd.multiply(new BigDecimal(sessionManager.expiredSessionCount.get())).add(bd);
-                newAvg = bd.divide(new BigDecimal(sessionManager.expiredSessionCount.get() + 1), MathContext.DECIMAL64).longValue();
-            } while (!sessionManager.averageSessionLifetime.compareAndSet(avg, newAvg));
-
-
-            sessionManager.expiredSessionCount.incrementAndGet();
-            long life = System.currentTimeMillis() - creationTime;
-            long existing = sessionManager.longestSessionLifetime.get();
-            while (life > existing) {
-                if(sessionManager.longestSessionLifetime.compareAndSet(existing, life)) {
-                    break;
+            if(sessionManager.statisticsEnabled) {
+                long avg, newAvg;
+                do {
+                    avg = sessionManager.averageSessionLifetime.get();
+                    BigDecimal bd = new BigDecimal(avg);
+                    bd.multiply(new BigDecimal(sessionManager.expiredSessionCount.get())).add(bd);
+                    newAvg = bd.divide(new BigDecimal(sessionManager.expiredSessionCount.get() + 1), MathContext.DECIMAL64).longValue();
+                } while (!sessionManager.averageSessionLifetime.compareAndSet(avg, newAvg));
+
+
+                sessionManager.expiredSessionCount.incrementAndGet();
+                long life = System.currentTimeMillis() - creationTime;
+                long existing = sessionManager.longestSessionLifetime.get();
+                while (life > existing) {
+                    if (sessionManager.longestSessionLifetime.compareAndSet(existing, life)) {
+                        break;
+                    }
+                    existing = sessionManager.longestSessionLifetime.get();
                 }
-                existing = sessionManager.longestSessionLifetime.get();
             }
             if (exchange != null) {
                 sessionCookieConfig.clearSession(exchange, this.getId());",2015-07-27T21:36:54Z,13
"@@ -41,6 +41,6 @@ public InMemorySessionManagerFactory(int maxSessions) {
 
     @Override
     public SessionManager createSessionManager(Deployment deployment) {
-        return new InMemorySessionManager(deployment.getDeploymentInfo().getSessionIdGenerator(), deployment.getDeploymentInfo().getDeploymentName(), maxSessions, false);
+        return new InMemorySessionManager(deployment.getDeploymentInfo().getSessionIdGenerator(), deployment.getDeploymentInfo().getDeploymentName(), maxSessions, deployment.getDeploymentInfo().getMetricsCollector() != null);
     }
 }",2015-07-27T21:36:54Z,420
"@@ -166,6 +166,12 @@ public class UndertowOptions {
      */
     public static final Option<Boolean> ENABLE_HTTP2 = Option.simple(UndertowOptions.class, ""ENABLE_HTTP2"", Boolean.class);
 
+    /**
+     * If connector level statistics should be enabled. This has a slight performance impact, but allows statistics such
+     * as bytes sent/recevied to be monitored.
+     */
+    public static final Option<Boolean> ENABLE_CONNECTOR_STATISTICS = Option.simple(UndertowOptions.class, ""ENABLE_CONNECTOR_STATISTICS"", Boolean.class);
+
     /**
      * The size of the header table that is used in the encoder
      */",2014-10-06T06:16:40Z,140
"@@ -0,0 +1,30 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.conduits;
+
+/**
+ * Callback that allows the bytes read from or written to a stream to be tracked
+ *
+ * @author Stuart Douglas
+ */
+public interface ByteActivityCallback {
+
+    void activity(long bytes);
+
+}",2014-10-06T06:16:40Z,437
"@@ -0,0 +1,74 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.conduits;
+
+import org.xnio.channels.StreamSinkChannel;
+import org.xnio.conduits.AbstractStreamSourceConduit;
+import org.xnio.conduits.StreamSourceConduit;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+
+/**
+ * @author Stuart Douglas
+ */
+public class BytesReceivedStreamSourceConduit extends AbstractStreamSourceConduit<StreamSourceConduit> {
+
+    private final ByteActivityCallback callback;
+
+    /**
+     * Construct a new instance.
+     *
+     * @param next the delegate conduit to set
+     * @param callback
+     */
+    public BytesReceivedStreamSourceConduit(StreamSourceConduit next, ByteActivityCallback callback) {
+        super(next);
+        this.callback = callback;
+    }
+
+    @Override
+    public long transferTo(long position, long count, FileChannel target) throws IOException {
+        long l = super.transferTo(position, count, target);
+        callback.activity(l);
+        return l;
+    }
+
+    @Override
+    public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel target) throws IOException {
+        long l = super.transferTo(count, throughBuffer, target);
+        callback.activity(l);
+        return l;
+    }
+
+    @Override
+    public int read(ByteBuffer dst) throws IOException {
+        int i = super.read(dst);
+        callback.activity(i);
+        return i;
+    }
+
+    @Override
+    public long read(ByteBuffer[] dsts, int offs, int len) throws IOException {
+        long l = super.read(dsts, offs, len);
+        callback.activity(l);
+        return l;
+    }
+}",2014-10-06T06:16:40Z,438
"@@ -0,0 +1,88 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.conduits;
+
+import org.xnio.channels.StreamSourceChannel;
+import org.xnio.conduits.AbstractStreamSinkConduit;
+import org.xnio.conduits.StreamSinkConduit;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+
+/**
+ * @author Stuart Douglas
+ */
+public class BytesSentStreamSinkConduit extends AbstractStreamSinkConduit<StreamSinkConduit> {
+
+    private final ByteActivityCallback callback;
+
+    /**
+     * Construct a new instance.
+     *
+     * @param next the delegate conduit to set
+     * @param callback
+     */
+    public BytesSentStreamSinkConduit(StreamSinkConduit next, ByteActivityCallback callback) {
+        super(next);
+        this.callback = callback;
+    }
+
+    @Override
+    public long transferFrom(FileChannel src, long position, long count) throws IOException {
+        long l = super.transferFrom(src, position, count);
+        callback.activity(l);
+        return l;
+    }
+
+    @Override
+    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {
+        long l = super.transferFrom(source, count, throughBuffer);
+        callback.activity(l);
+        return l;
+    }
+
+    @Override
+    public int write(ByteBuffer src) throws IOException {
+        int i = super.write(src);
+        callback.activity(i);
+        return i;
+    }
+
+    @Override
+    public long write(ByteBuffer[] srcs, int offs, int len) throws IOException {
+        long l = super.write(srcs, offs, len);
+        callback.activity(l);
+        return l;
+    }
+
+    @Override
+    public int writeFinal(ByteBuffer src) throws IOException {
+        int i = super.writeFinal(src);
+        callback.activity(i);
+        return i;
+    }
+
+    @Override
+    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {
+        long l = super.writeFinal(srcs, offset, length);
+        callback.activity(l);
+        return l;
+    }
+}",2014-10-06T06:16:40Z,439
"@@ -0,0 +1,70 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server;
+
+/**
+ * Connector level statistics
+ *
+ *
+ * @author Stuart Douglas
+ */
+public interface ConnectorStatistics {
+
+    /**
+     *
+     * @return The number of requests processed by this connector
+     */
+    long getRequestCount();
+
+    /**
+     *
+     * @return The number of bytes sent on this connector
+     */
+    long getBytesSent();
+
+    /**
+     *
+     * @return The number of bytes that have been received by this connector
+     */
+    long getBytesReceived();
+
+    /**
+     *
+     * @return The number of requests that triggered an error (i.e. 500) response.
+     */
+    long getErrorCount();
+
+    /**
+     *
+     * @return The total amount of time spent processing all requests on this connector
+     */
+    long getProcessingTime();
+
+    /**
+     *
+     * @return The time taken by the slowest request
+     */
+    long getMaxProcessingTime();
+
+    /**
+     * Resets all values to zero
+     */
+    void reset();
+
+}",2014-10-06T06:16:40Z,440
"@@ -0,0 +1,154 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.server;
+
+import io.undertow.conduits.ByteActivityCallback;
+
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+
+/**
+ * @author Stuart Douglas
+ */
+public class ConnectorStatisticsImpl implements ConnectorStatistics {
+
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> requestCountUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""requestCount"");
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> bytesSentUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""bytesSent"");
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> bytesReceivedUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""bytesReceived"");
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> errorCountUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""errorCount"");
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> processingTimeUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""processingTime"");
+    private static final AtomicLongFieldUpdater<ConnectorStatisticsImpl> maxProcessingTimeUpdater = AtomicLongFieldUpdater.newUpdater(ConnectorStatisticsImpl.class, ""maxProcessingTime"");
+
+    private volatile long requestCount;
+    private volatile long bytesSent;
+    private volatile long bytesReceived;
+    private volatile long errorCount;
+    private volatile long processingTime;
+    private volatile long maxProcessingTime;
+
+    private final ExchangeCompletionListener completionListener = new ExchangeCompletionListener() {
+        @Override
+        public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener) {
+            try {
+                if (exchange.getResponseCode() == 500) {
+                    errorCountUpdater.incrementAndGet(ConnectorStatisticsImpl.this);
+
+                }
+                long start = exchange.getRequestStartTime();
+                if (start > 0) {
+                    long elapsed = System.currentTimeMillis() - start;
+                    processingTimeUpdater.addAndGet(ConnectorStatisticsImpl.this, elapsed);
+                    long oldMax;
+                    do {
+                        oldMax = maxProcessingTimeUpdater.get(ConnectorStatisticsImpl.this);
+                        if (oldMax >= elapsed) {
+                            break;
+                        }
+                    } while (!maxProcessingTimeUpdater.compareAndSet(ConnectorStatisticsImpl.this, oldMax, elapsed));
+                }
+
+            } finally {
+                nextListener.proceed();
+            }
+        }
+    };
+
+    @Override
+    public long getRequestCount() {
+        return requestCountUpdater.get(this);
+    }
+
+    @Override
+    public long getBytesSent() {
+        return bytesSentUpdater.get(this);
+    }
+
+    @Override
+    public long getBytesReceived() {
+        return bytesReceivedUpdater.get(this);
+    }
+
+    @Override
+    public long getErrorCount() {
+        return errorCountUpdater.get(this);
+    }
+
+    @Override
+    public long getProcessingTime() {
+        return processingTimeUpdater.get(this);
+    }
+
+    @Override
+    public long getMaxProcessingTime() {
+        return maxProcessingTimeUpdater.get(this);
+    }
+
+    @Override
+    public void reset() {
+        requestCountUpdater.set(this, 0);
+        bytesSentUpdater.set(this, 0);
+        bytesReceivedUpdater.set(this, 0);
+        errorCountUpdater.set(this, 0);
+        maxProcessingTimeUpdater.set(this, 0);
+        processingTimeUpdater.set(this, 0);
+    }
+
+    public void requestFinished(long bytesSent, long bytesReceived, boolean error) {
+        bytesSentUpdater.addAndGet(this, bytesSent);
+        bytesReceivedUpdater.addAndGet(this, bytesReceived);
+        if (error) {
+            errorCountUpdater.incrementAndGet(this);
+        }
+    }
+
+    public void updateBytesSent(long bytes) {
+        bytesSentUpdater.addAndGet(this, bytes);
+    }
+
+    public void updateBytesReceived(long bytes) {
+        bytesReceivedUpdater.addAndGet(this, bytes);
+    }
+
+    public void setup(HttpServerExchange exchange) {
+        requestCountUpdater.incrementAndGet(this);
+        exchange.addExchangeCompleteListener(completionListener);
+    }
+
+    public ByteActivityCallback sentAccumulator() {
+        return new BytesSentAccumulator();
+    }
+
+    public ByteActivityCallback receivedAccumulator() {
+        return new BytesReceivedAccumulator();
+    }
+
+    //todo: we can do a way
+    private class BytesSentAccumulator implements ByteActivityCallback {
+        @Override
+        public void activity(long bytes) {
+            bytesSentUpdater.addAndGet(ConnectorStatisticsImpl.this, bytes);
+        }
+    }
+
+    private class BytesReceivedAccumulator implements ByteActivityCallback {
+        @Override
+        public void activity(long bytes) {
+            bytesReceivedUpdater.addAndGet(ConnectorStatisticsImpl.this, bytes);
+        }
+    }
+}",2014-10-06T06:16:40Z,441
"@@ -268,8 +268,15 @@ public final class HttpServerExchange extends AbstractAttachable {
      * or the exchange will be ended.
      */
     private static final int FLAG_IN_CALL = 1 << 17;
+    /**
+     * Flag that indicates that reads should be resumed when the call stack returns.
+     */
     private static final int FLAG_SHOULD_RESUME_READS = 1 << 18;
-    private static final int FLAG_SHOLD_RESUME_WRITES = 1 << 19;
+
+    /**
+     * Flag that indicates that writes should be resumed when the call stack returns
+     */
+    private static final int FLAG_SHOULD_RESUME_WRITES = 1 << 19;
 
     /**
      * The source address for the request. If this is null then the actual source address from the channel is used
@@ -1604,15 +1611,15 @@ public void setSecurityContext(SecurityContext securityContext) {
      */
     boolean runResumeReadWrite() {
         boolean ret = false;
-        if(anyAreSet(state, FLAG_SHOLD_RESUME_WRITES)) {
+        if(anyAreSet(state, FLAG_SHOULD_RESUME_WRITES)) {
             responseChannel.runResume();
             ret = true;
         }
         if(anyAreSet(state, FLAG_SHOULD_RESUME_READS)) {
             requestChannel.runResume();
             ret = true;
         }
-        state &= ~(FLAG_SHOULD_RESUME_READS | FLAG_SHOLD_RESUME_WRITES);
+        state &= ~(FLAG_SHOULD_RESUME_READS | FLAG_SHOULD_RESUME_WRITES);
         return ret;
     }
 
@@ -1709,7 +1716,7 @@ public void resumeWrites() {
                 return;
             }
             if (isInCall()) {
-                state |= FLAG_SHOLD_RESUME_WRITES;
+                state |= FLAG_SHOULD_RESUME_WRITES;
             } else {
                 delegate.resumeWrites();
             }
@@ -1722,15 +1729,15 @@ public void wakeupWrites() {
             }
             if (isInCall()) {
                 wakeup = true;
-                state |= FLAG_SHOLD_RESUME_WRITES;
+                state |= FLAG_SHOULD_RESUME_WRITES;
             } else {
                 delegate.wakeupWrites();
             }
         }
 
         @Override
         public boolean isWriteResumed() {
-            return anyAreSet(state, FLAG_SHOLD_RESUME_WRITES) || super.isWriteResumed();
+            return anyAreSet(state, FLAG_SHOULD_RESUME_WRITES) || super.isWriteResumed();
         }
 
         public void runResume() {",2014-10-06T06:16:40Z,132
"@@ -26,17 +26,46 @@
 import java.nio.ByteBuffer;
 
 /**
+ * Interface that represents an open listener, aka a connector.
+ *
  * @author Stuart Douglas
  */
 public interface OpenListener extends ChannelListener<StreamConnection> {
 
+    /**
+     *
+     * @return The first handler that will be executed by requests on the connector
+     */
     HttpHandler getRootHandler();
 
+    /**
+     * Sets the root handler
+     *
+     * @param rootHandler The new root handler
+     */
     void setRootHandler(HttpHandler rootHandler);
 
+    /**
+     *
+     * @return The connector options
+     */
     OptionMap getUndertowOptions();
 
+    /**
+     *
+     * @param undertowOptions The connector options
+     */
     void setUndertowOptions(OptionMap undertowOptions);
 
+    /**
+     *
+     * @return The buffer pool in use by this connector
+     */
     Pool<ByteBuffer> getBufferPool();
+
+    /**
+     *
+     * @return The connector statistics, or null if statistics gathering is disabled.
+     */
+    ConnectorStatistics getConnectorStatistics();
 }",2014-10-06T06:16:40Z,442
"@@ -21,8 +21,12 @@
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowMessages;
 import io.undertow.UndertowOptions;
+import io.undertow.conduits.BytesReceivedStreamSourceConduit;
+import io.undertow.conduits.BytesSentStreamSinkConduit;
 import io.undertow.conduits.ReadTimeoutStreamSourceConduit;
 import io.undertow.conduits.WriteTimeoutStreamSinkConduit;
+import io.undertow.server.ConnectorStatistics;
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.OpenListener;
 import org.xnio.IoUtils;
@@ -55,6 +59,9 @@ public class AjpOpenListener implements OpenListener {
 
     private final AjpRequestParser parser;
 
+    private volatile boolean statisticsEnabled;
+    private final ConnectorStatisticsImpl connectorStatistics;
+
     @Deprecated
     public AjpOpenListener(final Pool<ByteBuffer> pool, final int bufferSize) {
         this(pool, OptionMap.EMPTY);
@@ -75,6 +82,8 @@ public AjpOpenListener(final Pool<ByteBuffer> pool, final OptionMap undertowOpti
         this.bufferSize = buf.getResource().remaining();
         buf.free();
         parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, UTF_8), undertowOptions.get(DECODE_URL, true));
+        connectorStatistics = new ConnectorStatisticsImpl();
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
@@ -108,9 +117,13 @@ public void handleEvent(final StreamConnection channel) {
             IoUtils.safeClose(channel);
             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
         }
+        if(statisticsEnabled) {
+            channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
+            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+        }
 
         AjpServerConnection connection = new AjpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);
-        AjpReadListener readListener = new AjpReadListener(connection, scheme, parser);
+        AjpReadListener readListener = new AjpReadListener(connection, scheme, parser, statisticsEnabled ? connectorStatistics : null);
         connection.setAjpReadListener(readListener);
         readListener.startRequest();
         channel.getSourceChannel().setReadListener(readListener);
@@ -138,13 +151,22 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""undertowOptions"");
         }
         this.undertowOptions = undertowOptions;
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
     public Pool<ByteBuffer> getBufferPool() {
         return bufferPool;
     }
 
+    @Override
+    public ConnectorStatistics getConnectorStatistics() {
+        if(statisticsEnabled) {
+            return connectorStatistics;
+        }
+        return null;
+    }
+
     public String getScheme() {
         return scheme;
     }",2014-10-06T06:16:40Z,83
"@@ -24,6 +24,7 @@
 import io.undertow.conduits.EmptyStreamSourceConduit;
 import io.undertow.conduits.ReadDataStreamSourceConduit;
 import io.undertow.server.AbstractServerConnection;
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.server.Connectors;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.HeaderMap;
@@ -63,13 +64,15 @@ final class AjpReadListener implements ChannelListener<StreamSourceChannel> {
     private final int maxRequestSize;
     private final long maxEntitySize;
     private final AjpRequestParser parser;
+    private final ConnectorStatisticsImpl connectorStatistics;
     private WriteReadyHandler.ChannelListenerHandler<ConduitStreamSinkChannel> writeReadyHandler;
 
 
-    AjpReadListener(final AjpServerConnection connection, final String scheme, AjpRequestParser parser) {
+    AjpReadListener(final AjpServerConnection connection, final String scheme, AjpRequestParser parser, ConnectorStatisticsImpl connectorStatistics) {
         this.connection = connection;
         this.scheme = scheme;
         this.parser = parser;
+        this.connectorStatistics = connectorStatistics;
         this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);
         this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.writeReadyHandler = new WriteReadyHandler.ChannelListenerHandler<>(connection.getChannel().getSinkChannel());
@@ -201,6 +204,9 @@ public void handleEvent(AjpServerResponseConduit channel) {
                     Connectors.setRequestStartTime(httpServerExchange);
                 }
                 connection.setCurrentExchange(httpServerExchange);
+                if(connectorStatistics != null) {
+                    connectorStatistics.setup(httpServerExchange);
+                }
                 Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);
 
             } catch (Throwable t) {",2014-10-06T06:16:40Z,20
"@@ -21,8 +21,12 @@
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowMessages;
 import io.undertow.UndertowOptions;
+import io.undertow.conduits.BytesReceivedStreamSourceConduit;
+import io.undertow.conduits.BytesSentStreamSinkConduit;
 import io.undertow.conduits.ReadTimeoutStreamSourceConduit;
 import io.undertow.conduits.WriteTimeoutStreamSinkConduit;
+import io.undertow.server.ConnectorStatistics;
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.OpenListener;
 import org.xnio.ChannelListener;
@@ -53,6 +57,9 @@ public final class HttpOpenListener implements ChannelListener<StreamConnection>
 
     private volatile HttpRequestParser parser;
 
+    private volatile boolean statisticsEnabled;
+    private final ConnectorStatisticsImpl connectorStatistics;
+
     @Deprecated
     public HttpOpenListener(final Pool<ByteBuffer> pool, final int bufferSize) {
         this(pool, OptionMap.EMPTY);
@@ -74,6 +81,8 @@ public HttpOpenListener(final Pool<ByteBuffer> pool, final OptionMap undertowOpt
         this.bufferSize = buf.getResource().remaining();
         buf.free();
         parser = HttpRequestParser.instance(undertowOptions);
+        connectorStatistics = new ConnectorStatisticsImpl();
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
@@ -110,7 +119,11 @@ public void handleEvent(final StreamConnection channel) {
 
 
         HttpServerConnection connection = new HttpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);
-        HttpReadListener readListener = new HttpReadListener(connection, parser);
+        HttpReadListener readListener = new HttpReadListener(connection, parser, statisticsEnabled ? connectorStatistics : null);
+        if(statisticsEnabled) {
+            channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
+            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+        }
 
         connection.setReadListener(readListener);
         readListener.newRequest();
@@ -140,10 +153,19 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
         }
         this.undertowOptions = undertowOptions;
         this.parser = HttpRequestParser.instance(undertowOptions);
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
     public Pool<ByteBuffer> getBufferPool() {
         return bufferPool;
     }
+
+    @Override
+    public ConnectorStatistics getConnectorStatistics() {
+        if(statisticsEnabled) {
+            return connectorStatistics;
+        }
+        return null;
+    }
 }",2014-10-06T06:16:40Z,127
"@@ -21,6 +21,7 @@
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowOptions;
 import io.undertow.conduits.ReadDataStreamSourceConduit;
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.server.Connectors;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.ClosingChannelExceptionHandler;
@@ -63,16 +64,21 @@ final class HttpReadListener implements ChannelListener<ConduitStreamSourceChann
     //0 = new request ok, reads resumed
     //1 = request running, new request not ok
     //2 = suspending/resuming in progress
+    @SuppressWarnings(""unused"")
     private volatile int requestState;
-
     private static final AtomicIntegerFieldUpdater<HttpReadListener> requestStateUpdater = AtomicIntegerFieldUpdater.newUpdater(HttpReadListener.class, ""requestState"");
 
-    HttpReadListener(final HttpServerConnection connection, final HttpRequestParser parser) {
+    private final ConnectorStatisticsImpl connectorStatistics;
+
+
+    HttpReadListener(final HttpServerConnection connection, final HttpRequestParser parser, ConnectorStatisticsImpl connectorStatistics) {
         this.connection = connection;
         this.parser = parser;
+        this.connectorStatistics = connectorStatistics;
         this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);
         this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.recordRequestStartTime = connection.getUndertowOptions().get(UndertowOptions.RECORD_REQUEST_START_TIME, false);
+
     }
 
     public void newRequest() {
@@ -156,6 +162,9 @@ public void handleEventWithNoRunningRequest(final ConduitStreamSourceChannel cha
                 Connectors.setRequestStartTime(httpServerExchange);
             }
             connection.setCurrentExchange(httpServerExchange);
+            if(connectorStatistics != null) {
+                connectorStatistics.setup(httpServerExchange);
+            }
             Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);
         } catch (Exception e) {
             sendBadRequestAndClose(connection.getChannel(), e);",2014-10-06T06:16:40Z,105
"@@ -22,6 +22,11 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 import javax.net.ssl.SSLEngine;
+
+import io.undertow.conduits.BytesReceivedStreamSourceConduit;
+import io.undertow.conduits.BytesSentStreamSinkConduit;
+import io.undertow.server.ConnectorStatistics;
+import io.undertow.server.ConnectorStatisticsImpl;
 import org.eclipse.jetty.alpn.ALPN;
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;
@@ -62,6 +67,8 @@ public final class Http2OpenListener implements ChannelListener<StreamConnection
 
     private volatile OptionMap undertowOptions;
     private final HttpOpenListener delegate;
+    private volatile boolean statisticsEnabled;
+    private final ConnectorStatisticsImpl connectorStatistics;
 
     public Http2OpenListener(final Pool<ByteBuffer> pool) {
         this(pool, OptionMap.EMPTY, null);
@@ -82,6 +89,8 @@ public Http2OpenListener(final Pool<ByteBuffer> pool, final OptionMap undertowOp
         this.bufferSize = buf.getResource().remaining();
         buf.free();
         this.delegate = httpDelegate;
+        connectorStatistics = new ConnectorStatisticsImpl();
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     public void handleEvent(final StreamConnection channel) {
@@ -97,7 +106,7 @@ public void handleEvent(final StreamConnection channel) {
             UndertowLogger.REQUEST_LOGGER.debug(""Resuming existing session, not doing NPN negotiation"");
             if (existing.equals(HTTP2)) {
                 Http2Channel sc = new Http2Channel(channel, bufferPool, new ImmediatePooled<>(ByteBuffer.wrap(new byte[0])), false, false, undertowOptions);
-                sc.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
+                sc.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize, statisticsEnabled ? connectorStatistics : null));
                 sc.resumeReceives();
             } else {
                 if (delegate == null) {
@@ -134,6 +143,13 @@ public String select(List<String> strings) {
         }
     }
 
+    @Override
+    public ConnectorStatistics getConnectorStatistics() {
+        if(statisticsEnabled) {
+            return connectorStatistics;
+        }
+        return null;
+    }
     @Override
     public HttpHandler getRootHandler() {
         return rootHandler;
@@ -158,6 +174,7 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""undertowOptions"");
         }
         this.undertowOptions = undertowOptions;
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
@@ -193,8 +210,12 @@ public void handleEvent(StreamSourceChannel source) {
                         if (idleTimeout != null && idleTimeout > 0) {
                             channel.setIdleTimeout(idleTimeout);
                         }
+                        if(statisticsEnabled) {
+                            this.channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(this.channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                        }
                         free = false;
-                        channel.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
+                        channel.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize, connectorStatistics));
                         channel.resumeReceives();
                         return;
                     } else if (HTTP_1_1.equals(selected) || res > 0) {",2014-10-06T06:16:40Z,375
"@@ -21,6 +21,7 @@
 import java.io.IOException;
 import javax.net.ssl.SSLSession;
 
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.util.Protocols;
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;
@@ -63,12 +64,14 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
     private final StringBuilder decodeBuffer = new StringBuilder();
     private final boolean allowEncodingSlash;
     private final int bufferSize;
+    private final ConnectorStatisticsImpl connectorStatistics;
 
 
-    public Http2ReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions, int bufferSize) {
+    public Http2ReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions, int bufferSize, ConnectorStatisticsImpl connectorStatistics) {
         this.rootHandler = rootHandler;
         this.undertowOptions = undertowOptions;
         this.bufferSize = bufferSize;
+        this.connectorStatistics = connectorStatistics;
         this.maxEntitySize = undertowOptions.get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.allowEncodingSlash = undertowOptions.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         this.decode = undertowOptions.get(UndertowOptions.DECODE_URL, true);
@@ -121,6 +124,9 @@ public void handleEvent(Http2StreamSourceChannel channel) {
                         }
                     });
                 }
+                if(connectorStatistics != null) {
+                    connectorStatistics.setup(exchange);
+                }
 
                 Connectors.executeRootHandler(rootHandler, exchange);
             }",2014-10-06T06:16:40Z,164
"@@ -70,7 +70,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                                 }
                                 next.handleRequest(exchange);
                             }
-                        }, undertowOptions, exchange.getConnection().getBufferSize());
+                        }, undertowOptions, exchange.getConnection().getBufferSize(), null);
                         channel.getReceiveSetter().set(receiveListener);
                         receiveListener.handleInitialRequest(exchange, channel);
                         channel.resumeReceives();",2014-10-06T06:16:40Z,349
"@@ -22,6 +22,11 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 import javax.net.ssl.SSLEngine;
+
+import io.undertow.conduits.BytesReceivedStreamSourceConduit;
+import io.undertow.conduits.BytesSentStreamSinkConduit;
+import io.undertow.server.ConnectorStatistics;
+import io.undertow.server.ConnectorStatisticsImpl;
 import org.eclipse.jetty.alpn.ALPN;
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;
@@ -64,6 +69,8 @@ public final class SpdyOpenListener implements ChannelListener<StreamConnection>
 
     private volatile OptionMap undertowOptions;
     private final HttpOpenListener delegate;
+    private volatile boolean statisticsEnabled;
+    private final ConnectorStatisticsImpl connectorStatistics;
 
     public SpdyOpenListener(final Pool<ByteBuffer> pool, final Pool<ByteBuffer> heapBufferPool) {
         this(pool, heapBufferPool, OptionMap.EMPTY, null);
@@ -93,6 +100,8 @@ public SpdyOpenListener(final Pool<ByteBuffer> pool, final Pool<ByteBuffer> heap
         } finally {
             buff.free();
         }
+        connectorStatistics = new ConnectorStatisticsImpl();
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     public void handleEvent(final StreamConnection channel) {
@@ -108,7 +117,7 @@ public void handleEvent(final StreamConnection channel) {
             UndertowLogger.REQUEST_LOGGER.debug(""Resuming existing session, not doing NPN negotiation"");
             if (existing.equals(SPDY_3_1) || existing.equals(SPDY_3)) {
                 SpdyChannel sc = new SpdyChannel(channel, bufferPool, new ImmediatePooled<>(ByteBuffer.wrap(new byte[0])), heapBufferPool, false);
-                sc.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
+                sc.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize, statisticsEnabled ? connectorStatistics : null));
                 sc.resumeReceives();
             } else {
                 if (delegate == null) {
@@ -169,6 +178,7 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""undertowOptions"");
         }
         this.undertowOptions = undertowOptions;
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
@@ -205,7 +215,12 @@ public void handleEvent(StreamSourceChannel source) {
                             channel.setIdleTimeout(idleTimeout);
                         }
                         free = false;
-                        channel.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
+
+                        if(statisticsEnabled) {
+                            this.channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(this.channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                        }
+                        channel.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize, connectorStatistics));
                         channel.resumeReceives();
                         return;
                     } else if (HTTP_1_1.equals(selected) || res > 0) {
@@ -239,4 +254,11 @@ public void handleEvent(StreamSourceChannel source) {
             }
         }
     }
+    @Override
+    public ConnectorStatistics getConnectorStatistics() {
+        if(statisticsEnabled) {
+            return connectorStatistics;
+        }
+        return null;
+    }
 }",2014-10-06T06:16:40Z,443
"@@ -19,6 +19,11 @@
 package io.undertow.server.protocol.spdy;
 
 import java.nio.ByteBuffer;
+
+import io.undertow.conduits.BytesReceivedStreamSourceConduit;
+import io.undertow.conduits.BytesSentStreamSinkConduit;
+import io.undertow.server.ConnectorStatistics;
+import io.undertow.server.ConnectorStatisticsImpl;
 import org.xnio.ChannelListener;
 import org.xnio.OptionMap;
 import org.xnio.Pool;
@@ -48,6 +53,8 @@ public final class SpdyPlainOpenListener implements ChannelListener<StreamConnec
     private volatile HttpHandler rootHandler;
 
     private volatile OptionMap undertowOptions;
+    private volatile boolean statisticsEnabled;
+    private final ConnectorStatisticsImpl connectorStatistics;
 
     public SpdyPlainOpenListener(final Pool<ByteBuffer> pool, final Pool<ByteBuffer> heapBufferPool) {
         this(pool, heapBufferPool, OptionMap.EMPTY);
@@ -68,6 +75,8 @@ public SpdyPlainOpenListener(final Pool<ByteBuffer> pool, final Pool<ByteBuffer>
         } finally {
             buff.free();
         }
+        connectorStatistics = new ConnectorStatisticsImpl();
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     public void handleEvent(final StreamConnection channel) {
@@ -79,11 +88,23 @@ public void handleEvent(final StreamConnection channel) {
         if (idleTimeout != null && idleTimeout > 0) {
             spdy.setIdleTimeout(idleTimeout);
         }
-        spdy.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
+        if(statisticsEnabled) {
+            channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
+            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+        }
+        spdy.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize, statisticsEnabled ? connectorStatistics : null));
         spdy.resumeReceives();
 
     }
 
+    @Override
+    public ConnectorStatistics getConnectorStatistics() {
+        if(statisticsEnabled) {
+            return connectorStatistics;
+        }
+        return null;
+    }
+
     @Override
     public HttpHandler getRootHandler() {
         return rootHandler;
@@ -105,10 +126,12 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
             throw UndertowMessages.MESSAGES.argumentCannotBeNull(""undertowOptions"");
         }
         this.undertowOptions = undertowOptions;
+        statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
     }
 
     @Override
     public Pool<ByteBuffer> getBufferPool() {
         return bufferPool;
     }
+
 }",2014-10-06T06:16:40Z,444
"@@ -21,6 +21,7 @@
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowOptions;
 import io.undertow.protocols.spdy.SpdyStreamStreamSourceChannel;
+import io.undertow.server.ConnectorStatisticsImpl;
 import io.undertow.server.Connectors;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -62,12 +63,14 @@ public class SpdyReceiveListener implements ChannelListener<SpdyChannel> {
     private final StringBuilder decodeBuffer = new StringBuilder();
     private final boolean allowEncodingSlash;
     private final int bufferSize;
+    private final ConnectorStatisticsImpl connectorStatistics;
 
 
-    public SpdyReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions, int bufferSize) {
+    public SpdyReceiveListener(HttpHandler rootHandler, OptionMap undertowOptions, int bufferSize, ConnectorStatisticsImpl connectorStatistics) {
         this.rootHandler = rootHandler;
         this.undertowOptions = undertowOptions;
         this.bufferSize = bufferSize;
+        this.connectorStatistics = connectorStatistics;
         this.maxEntitySize = undertowOptions.get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.allowEncodingSlash = undertowOptions.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
         this.decode = undertowOptions.get(UndertowOptions.DECODE_URL, true);
@@ -123,7 +126,9 @@ public void handleEvent(SpdyStreamStreamSourceChannel channel) {
                         }
                     });
                 }
-
+                if(connectorStatistics != null) {
+                    connectorStatistics.setup(exchange);
+                }
                 Connectors.executeRootHandler(rootHandler, exchange);
             }
 ",2014-10-06T06:16:40Z,445
"@@ -396,7 +396,7 @@ private static void runInternal(final RunNotifier notifier) {
                     if(spdy) {
                         log.error(""SPDY selected but Netty ALPN was not on the boot class path"");
                     }
-                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true));
+                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true, UndertowOptions.ENABLE_CONNECTOR_STATISTICS, true));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
                     if (!proxy) {
                         server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT)), acceptListener, serverOptions);",2014-10-06T06:16:40Z,76
"@@ -53,8 +53,8 @@ public SingleSignOn createSingleSignOn(Account account, String mechanism) {
     }
 
     @Override
-    public void removeSingleSignOn(String ssoId) {
-        this.ssoEntries.remove(ssoId);
+    public void removeSingleSignOn(SingleSignOn sso) {
+        this.ssoEntries.remove(sso.getId());
     }
 
     private static class SimpleSingleSignOnEntry implements SingleSignOn {",2015-10-07T13:48:13Z,412
"@@ -82,7 +82,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         Cookie cookie = exchange.getRequestCookies().get(cookieName);
         if (cookie != null) {
             final String ssoId = cookie.getValue();
-            try (SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
+            try (final SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
                 if (sso != null) {
                     Account verified = getIdentityManager(securityContext).verify(sso.getAccount());
                     if (verified == null) {
@@ -96,7 +96,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
                         @Override
                         public void handleNotification(SecurityNotification notification) {
                             if (notification.getEventType() == SecurityNotification.EventType.LOGGED_OUT) {
-                                singleSignOnManager.removeSingleSignOn(ssoId);
+                                singleSignOnManager.removeSingleSignOn(sso);
                             }
                         }
                     });
@@ -161,7 +161,7 @@ public void sessionCreated(Session session, HttpServerExchange exchange) {
         public void sessionDestroyed(Session session, HttpServerExchange exchange, SessionDestroyedReason reason) {
             String ssoId = (String) session.getAttribute(SSO_SESSION_ATTRIBUTE);
             if (ssoId != null) {
-                try (SingleSignOn sso = singleSignOnManager.findSingleSignOn(ssoId)) {
+                try (final SingleSignOn sso = singleSignOnManager.findSingleSignOn(ssoId)) {
                     if (sso != null) {
                         sso.remove(session);
                         if (reason == SessionDestroyedReason.INVALIDATED) {
@@ -172,7 +172,7 @@ public void sessionDestroyed(Session session, HttpServerExchange exchange, Sessi
                         }
                         // If there are no more associated sessions, remove the SSO altogether
                         if (!sso.iterator().hasNext()) {
-                            singleSignOnManager.removeSingleSignOn(ssoId);
+                            singleSignOnManager.removeSingleSignOn(sso);
                         }
                     }
                 }",2015-10-07T13:48:13Z,414
"@@ -28,5 +28,5 @@ public interface SingleSignOnManager {
 
     SingleSignOn findSingleSignOn(String ssoId);
 
-    void removeSingleSignOn(String ssoId);
+    void removeSingleSignOn(SingleSignOn sso);
 }",2015-10-07T13:48:13Z,416
"@@ -49,6 +49,7 @@ public Map<E, String> parseHeader(final String header) {
         int nameStart = 0;
         E currentToken = null;
         int valueStart = 0;
+        boolean containsEscapes = false;
 
         for (int i = 0; i < headerChars.length; i++) {
             switch (searchingFor) {
@@ -81,11 +82,28 @@ public Map<E, String> parseHeader(final String header) {
                     }
                     break;
                 case LAST_QUOTE:
-                    if (headerChars[i] == QUOTE) {
+                    boolean backslash = headerChars[i - 1] != '\\';
+                    if (headerChars[i] == QUOTE && backslash) {
                         String value = String.valueOf(headerChars, valueStart, i - valueStart);
+                        if(containsEscapes) {
+                            StringBuilder sb = new StringBuilder();
+                            boolean lastEscape = false;
+                            for(int j = 0; j < value.length(); ++j) {
+                                char c = value.charAt(j);
+                                if(c == '\\' && !lastEscape) {
+                                    lastEscape = true;
+                                } else {
+                                    lastEscape = false;
+                                    sb.append(c);
+                                }
+                            }
+                            value = sb.toString();
+                        }
                         response.put(currentToken, value);
 
                         searchingFor = SearchingFor.START_OF_NAME;
+                    } else if(backslash) {
+                        containsEscapes = true;
                     }
                     break;
                 case END_OF_VALUE:",2014-10-14T01:00:05Z,25
"@@ -0,0 +1,37 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2014 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package io.undertow.util;
+
+import io.undertow.security.impl.DigestAuthorizationToken;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.Collections;
+
+/**
+ * @author Stuart Douglas
+ */
+public class HeaderTokenParserTestCase {
+
+    @Test
+    public void testHeaderTokenParser() {
+        HeaderTokenParser<DigestAuthorizationToken> h = new HeaderTokenParser(Collections.<String, DigestAuthorizationToken>singletonMap(""username"", DigestAuthorizationToken.USERNAME));
+        Assert.assertEquals(""a\""b"", h.parseHeader(""username=\""a\\\""b\"""").get(DigestAuthorizationToken.USERNAME));
+    }
+}",2014-10-14T01:00:05Z,25
"@@ -18,11 +18,16 @@
 
 package io.undertow.client;
 
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
 import io.undertow.UndertowLogger;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 import io.undertow.util.Methods;
-import io.undertow.util.StatusCodes;
 import org.xnio.ChannelListener;
 import org.xnio.ChannelListeners;
 import org.xnio.FutureResult;
@@ -40,12 +45,6 @@
 import org.xnio.channels.PushBackStreamChannel;
 import org.xnio.channels.StreamSinkChannel;
 
-import java.io.IOException;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-
 import static io.undertow.client.UndertowClientMessages.MESSAGES;
 import static org.xnio.Bits.allAreClear;
 import static org.xnio.Bits.allAreSet;
@@ -174,18 +173,18 @@ public IoFuture<ConnectedStreamChannel> upgradeToWebSocket(String service, Optio
             // Upgrade the connection
             final URI requestURI = new URI(""/""); // TOOD get this somewhere
             final HttpClientRequest request = internalCreateRequest(Methods.GET, requestURI, false); // disable pipelining for connection upgrades
-            if(request == null) {
+            if (request == null) {
                 return null;
             }
             // Set the upgraded flag already to prevent new requests after this one
             int oldState, newState;
             do {
                 oldState = state;
-                if(allAreSet(oldState, UPGRADED | CLOSE_REQ | CLOSED)) {
+                if (allAreSet(oldState, UPGRADED | CLOSE_REQ | CLOSED)) {
                     return null;
                 }
                 newState = oldState | UPGRADED;
-            } while (! stateUpdater.compareAndSet(this, oldState, newState));
+            } while (!stateUpdater.compareAndSet(this, oldState, newState));
 
             // Add connection headers
             request.getRequestHeaders().add(Headers.CONNECTION, Headers.UPGRADE_STRING);
@@ -197,7 +196,7 @@ public IoFuture<ConnectedStreamChannel> upgradeToWebSocket(String service, Optio
                 @Override
                 public void notify(IoFuture<? extends HttpClientResponse> future, Void attachment) {
                     IOException failure = null;
-                    switch(future.getStatus()) {
+                    switch (future.getStatus()) {
                         case CANCELLED:
                             result.setCancelled();
                             break;
@@ -207,15 +206,14 @@ public void notify(IoFuture<? extends HttpClientResponse> future, Void attachmen
                         case DONE:
                             try {
                                 final HttpClientResponse response = future.get();
-                                if(response.getResponseCode() == 101) {
+                                if (response.getResponseCode() == 101) {
                                     // return the upgraded channel
                                     final AssembledConnectedStreamChannel channel = new AssembledConnectedStreamChannel(readChannel, underlyingChannel);
                                     result.setResult(channel);
                                     return;
                                 } else {
-                                    final String reason = StatusCodes.getReason(response.getResponseCode());
-                                    final String result = StatusCodes.UNKNOWN.getReason() == reason ? response.getReasonPhrase() : reason;
-                                    failure = new IOException(MESSAGES.failedToUpgradeChannel(result));
+                                    final String result = response.getReasonPhrase();
+                                    failure = new IOException(MESSAGES.failedToUpgradeChannel(response.getResponseCode(), result));
                                 }
                             } catch (IOException ex) {
                                 // not possible
@@ -226,20 +224,20 @@ public void notify(IoFuture<? extends HttpClientResponse> future, Void attachmen
                     int oldState, newState;
                     do {
                         oldState = state;
-                        if(allAreClear(oldState, UPGRADED)) {
+                        if (allAreClear(oldState, UPGRADED)) {
                             break;
                         }
                         newState = oldState & UPGRADED;
-                    } while (! stateUpdater.compareAndSet(HttpClientConnectionImpl.this, oldState, newState));
+                    } while (!stateUpdater.compareAndSet(HttpClientConnectionImpl.this, oldState, newState));
                     // Report the error
-                    if(failure != null) {
+                    if (failure != null) {
                         result.setException(failure);
                     }
                 }
             }, null);
         } catch (IOException e) {
             result.setException(e);
-        } catch (Exception e){
+        } catch (Exception e) {
             result.setException(new IOException(e));
         }
         return result.getIoFuture();
@@ -248,13 +246,13 @@ public void notify(IoFuture<? extends HttpClientResponse> future, Void attachmen
     /**
      * Create a http client request.
      *
-     * @param method the http method
-     * @param target the target uri
+     * @param method     the http method
+     * @param target     the target uri
      * @param pipelining whether to potentially allow pipelining
      * @return a new request instance
      */
     protected HttpClientRequest internalCreateRequest(final HttpString method, final URI target, final boolean pipelining) {
-        if(allAreSet(state, UPGRADED | CLOSE_REQ | CLOSE_REQ)) {
+        if (allAreSet(state, UPGRADED | CLOSE_REQ | CLOSE_REQ)) {
             return null;
         }
         return new HttpClientRequestImpl(this, underlyingChannel, method, target, pipelining);
@@ -265,11 +263,11 @@ public void close() throws IOException {
         int oldState, newState;
         do {
             oldState = state;
-            if(allAreSet(oldState, CLOSED)) {
+            if (allAreSet(oldState, CLOSED)) {
                 return;
             }
             newState = oldState | CLOSED | CLOSE_REQ;
-        } while (! stateUpdater.compareAndSet(this, oldState, newState));
+        } while (!stateUpdater.compareAndSet(this, oldState, newState));
         underlyingChannel.close();
     }
 
@@ -283,7 +281,7 @@ void enqueueRequest(final PendingHttpRequest request) throws IOException {
         int oldState, newState;
         do {
             oldState = state;
-            if(anyAreSet(oldState, CLOSE_REQ | CLOSED)) {
+            if (anyAreSet(oldState, CLOSE_REQ | CLOSED)) {
                 throw new IOException(MESSAGES.connectionClosed());
             }
             newState = oldState + 1;
@@ -337,27 +335,27 @@ void requestConnectionClose() throws IOException {
         int oldState, newState;
         do {
             oldState = state;
-            if(anyAreSet(oldState, CLOSE_REQ | CLOSED)) {
+            if (anyAreSet(oldState, CLOSE_REQ | CLOSED)) {
                 return;
             }
             newState = oldState | CLOSE_REQ;
-        } while (! stateUpdater.compareAndSet(this, oldState, newState));
+        } while (!stateUpdater.compareAndSet(this, oldState, newState));
         UndertowLogger.CLIENT_LOGGER.tracef(""request to close the connection"");
-        if(newState == CLOSE_REQ) {
+        if (newState == CLOSE_REQ) {
             close();
         }
     }
 
     // Internal callback once a request is can start sending it's data
     void doSendRequest(final PendingHttpRequest request, boolean fromCallback) {
         int currentState = state;
-        if(anyAreSet(currentState, CLOSE_REQ | CLOSED)) {
+        if (anyAreSet(currentState, CLOSE_REQ | CLOSED)) {
             request.setCancelled();
             sendingCompleted(request);
             return;
         }
         UndertowLogger.CLIENT_LOGGER.tracef(""start sending request %s"", request);
-        if(fromCallback) { // Don't call startRequest in a read thread
+        if (fromCallback) { // Don't call startRequest in a read thread
             underlyingChannel.getWriteSetter().set(new ChannelListener<StreamSinkChannel>() {
                 @Override
                 public void handleEvent(StreamSinkChannel channel) {
@@ -406,7 +404,7 @@ public void handleEvent(PushBackStreamChannel channel) {
                         return;
                     }
 
-                    if(res == 0) {
+                    if (res == 0) {
                         if (!channel.isReadResumed()) {
                             channel.getReadSetter().set(this);
                             channel.resumeReads();
@@ -445,7 +443,7 @@ public void handleEvent(PushBackStreamChannel channel) {
                         channel.unget(pooled);
                     }
 
-                } while(! state.isComplete());
+                } while (!state.isComplete());
 
                 channel.getReadSetter().set(null);
                 channel.suspendReads();",2013-03-06T01:21:46Z,122
"@@ -22,8 +22,8 @@ public interface UndertowClientMessages {
     IllegalStateException requestAlreadyWritten();
 
     // 1020
-    @Message(id = 1020, value = ""Failed to upgrade channel: %s"")
-    String failedToUpgradeChannel(String reason);
+    @Message(id = 1020, value = ""Failed to upgrade channel due to response %s (%s)"")
+    String failedToUpgradeChannel(final int responseCode, String reason);
 
     // 1030
     @Message(id = 1030, value = ""invalid content length %d"")",2013-03-06T01:21:46Z,122
"@@ -19,7 +19,6 @@
 package io.undertow.security.api;
 
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.StatusCodes;
 
 /**
  * The interface to be implemented by a single authentication mechanism.
@@ -67,8 +66,6 @@ public interface AuthenticationMechanism {
     /**
      * Perform authentication of the request. Any potentially blocking work should be performed in the handoff executor provided
      *
-     *
-     *
      * @param exchange The exchange
      * @return
      */
@@ -77,14 +74,12 @@ AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
 
     /**
      * Send an authentication challenge to the remote client.
-     *
+     * <p/>
      * The individual mechanisms should update the response headers and body of the message as appropriate however they should
      * not set the response code, instead that should be indicated in the {@link ChallengeResult} and the most appropriate
      * overall response code will be selected.
      *
-     *
-     *
-     * @param exchange The exchange
+     * @param exchange        The exchange
      * @param securityContext The security context
      * @return A {@link ChallengeResult} indicating if a challenge was sent and the desired response code.
      */
@@ -121,9 +116,9 @@ public enum AuthenticationMechanismOutcome {
     public class ChallengeResult {
 
         private final boolean challengeSent;
-        private final StatusCodes statusCode;
+        private final Integer statusCode;
 
-        public ChallengeResult(final boolean challengeSent, final StatusCodes statusCode) {
+        public ChallengeResult(final boolean challengeSent, final Integer statusCode) {
             this.statusCode = statusCode;
             this.challengeSent = challengeSent;
         }
@@ -134,19 +129,19 @@ public ChallengeResult(final boolean challengeSent) {
 
         /**
          * Obtain the response code desired by this mechanism for the challenge.
-         *
+         * <p/>
          * Where multiple mechanisms are in use concurrently all of the requested response codes will be checked and the most
          * suitable one selected. If no specific response code is required any value less than 0 can be set.
          *
          * @return The desired response code or null if no code specified.
          */
-        public StatusCodes getDesiredResponseCode() {
+        public Integer getDesiredResponseCode() {
             return statusCode;
         }
 
         /**
          * Check if the mechanism did send a challenge.
-         *
+         * <p/>
          * Some mechanisms do not send a challenge and just rely on the correct information to authenticate a user being
          * available in the request, in that case it would be normal for the mechanism to set this to false.
          *",2013-03-06T01:21:46Z,64
"@@ -33,7 +33,7 @@
 import static io.undertow.util.Headers.AUTHORIZATION;
 import static io.undertow.util.Headers.BASIC;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
+import static io.undertow.util.StatusCodes.UNAUTHORIZED;
 
 /**
  * The authentication handler responsible for BASIC authentication as described by RFC2617
@@ -101,7 +101,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
     }
 
-    public AuthenticationMechanismOutcome runBasic(final SecurityContext securityContext,final String userName, final char[] password) {
+    public AuthenticationMechanismOutcome runBasic(final SecurityContext securityContext, final String userName, final char[] password) {
         // To reach this point we must have been supplied a username and password.
         AuthenticationMechanismOutcome result = null;
         IdentityManager idm = securityContext.getIdentityManager();
@@ -123,7 +123,7 @@ public AuthenticationMechanismOutcome runBasic(final SecurityContext securityCon
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
         exchange.getResponseHeaders().add(WWW_AUTHENTICATE, challenge);
-        return new ChallengeResult(true, CODE_401);
+        return new ChallengeResult(true, UNAUTHORIZED);
     }
 
 }",2013-03-06T01:21:46Z,1
"@@ -44,7 +44,7 @@
 import static io.undertow.util.Headers.DIGEST;
 import static io.undertow.util.Headers.NEXT_NONCE;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
+import static io.undertow.util.StatusCodes.UNAUTHORIZED;
 
 /**
  * {@link io.undertow.server.HttpHandler} to handle HTTP Digest authentication, both according to RFC-2617 and draft update to allow additional
@@ -90,7 +90,7 @@ public class DigestAuthenticationMechanism implements AuthenticationMechanism {
     // Maybe even support registration of a session so it can be invalidated?
 
     public DigestAuthenticationMechanism(final List<DigestAlgorithm> supportedAlgorithms, final List<DigestQop> supportedQops,
-            final String realmName, final String domain, final NonceManager nonceManager, final boolean plainTextPasswords) {
+                                         final String realmName, final String domain, final NonceManager nonceManager, final boolean plainTextPasswords) {
         this.supportedAlgorithms = supportedAlgorithms;
         this.supportedQops = supportedQops;
         this.realmName = realmName;
@@ -153,7 +153,7 @@ public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exch
     @Override
     public ChallengeResult sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext) {
         sendChallengeHeaders(exchange);
-        return new ChallengeResult(true, CODE_401);
+        return new ChallengeResult(true, UNAUTHORIZED);
     }
 
 
@@ -327,7 +327,7 @@ private boolean validateNonceUse(DigestContext context, Map<DigestAuthorizationT
     }
 
     private byte[] createHA1(final byte[] userName, final Account account, final MessageDigest digest,
-            final SecurityContext securityContext) throws AuthenticationException {
+                             final SecurityContext securityContext) throws AuthenticationException {
         if (plainTextPasswords) {
             byte[] password = new String(securityContext.getIdentityManager().getPassword(account)).getBytes(UTF_8);
 ",2013-03-06T01:21:46Z,59
"@@ -17,7 +17,9 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.util.StatusCodes.CODE_307;
+import java.io.IOException;
+import java.util.Map;
+
 import io.undertow.UndertowLogger;
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.SecurityContext;
@@ -33,8 +35,7 @@
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 
-import java.io.IOException;
-import java.util.Map;
+import static io.undertow.util.StatusCodes.TEMPORARY_REDIRECT;
 
 /**
  * @author Stuart Douglas
@@ -129,14 +130,14 @@ public ChallengeResult sendChallenge(final HttpServerExchange exchange, final Se
         if (exchange.getRequestURI().endsWith(postLocation) && exchange.getRequestMethod().equals(Methods.POST)) {
             // This method would no longer be called if authentication had already occurred.
             sendRedirect(exchange, errorPage);
-            return new ChallengeResult(true, CODE_307);
+            return new ChallengeResult(true, TEMPORARY_REDIRECT);
         } else {
             // we need to store the URL
             CookieImpl.addResponseCookie(exchange, new CookieImpl(LOCATION_COOKIE, exchange.getRequestURI()));
             // TODO - Rather than redirecting, in order to make this mechanism compatible with the other mechanisms we need to
             // return the actual error page not a redirect.
             sendRedirect(exchange, loginPage);
-            return new ChallengeResult(true, CODE_307);
+            return new ChallengeResult(true, TEMPORARY_REDIRECT);
         }
     }
 ",2013-03-06T01:21:46Z,148
"@@ -47,14 +47,14 @@
 import static io.undertow.util.Headers.HOST;
 import static io.undertow.util.Headers.NEGOTIATE;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
+import static io.undertow.util.StatusCodes.UNAUTHORIZED;
 
 /**
  * {@link io.undertow.security.api.AuthenticationMechanism} for GSSAPI / SPNEGO based authentication.
- *
+ * <p/>
  * GSSAPI authentication is associated with the HTTP connection, as long as a connection is being re-used allow the
  * authentication state to be re-used.
- *
+ * <p/>
  * TODO - May consider an option to allow it to also be associated with the underlying session but that has it's own risks so
  * would need to come with a warning.
  *
@@ -131,7 +131,7 @@ public ChallengeResult sendChallenge(final HttpServerExchange exchange, final Se
 
         exchange.getResponseHeaders().add(WWW_AUTHENTICATE, header);
 
-        return new ChallengeResult(true, CODE_401);
+        return new ChallengeResult(true, UNAUTHORIZED);
     }
 
 ",2013-03-06T01:21:46Z,17
"@@ -35,11 +35,10 @@
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.security.idm.PasswordCredential;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.StatusCodes;
 
 import static io.undertow.UndertowMessages.MESSAGES;
-import static io.undertow.util.StatusCodes.CODE_200;
-import static io.undertow.util.StatusCodes.CODE_403;
+import static io.undertow.util.StatusCodes.FORBIDDEN;
+import static io.undertow.util.StatusCodes.OK;
 
 /**
  * The internal SecurityContext used to hold the state of security for the current exchange.
@@ -292,7 +291,7 @@ private class ChallengeSender {
         private final HttpServerExchange exchange;
 
         private boolean atLeastOneChallenge = false;
-        private StatusCodes chosenStatusCode = null;
+        private Integer chosenStatusCode = null;
 
         private ChallengeSender(final Iterator<AuthenticationMechanism> mechanismIterator, final HttpServerExchange exchange) {
             this.mechanismIterator = mechanismIterator;
@@ -306,11 +305,11 @@ private AuthenticationState transition() {
 
                 if (result.isChallengeSent()) {
                     atLeastOneChallenge = true;
-                    StatusCodes desiredCode = result.getDesiredResponseCode();
+                    Integer desiredCode = result.getDesiredResponseCode();
                     if (chosenStatusCode == null) {
                         chosenStatusCode = desiredCode;
                     } else if (desiredCode != null) {
-                        if (chosenStatusCode.equals(CODE_200)) {
+                        if (chosenStatusCode.equals(OK)) {
                             // Allows a more specific code to be chosen.
                             // TODO - Still need a more complex code resolution strategy if many different codes are
                             // returned (Although those mechanisms may just never work together.)
@@ -327,11 +326,11 @@ private AuthenticationState transition() {
                 // Iterated all mechanisms, now need to select a suitable status code.
                 if (atLeastOneChallenge) {
                     if (chosenStatusCode != null) {
-                        exchange.setResponseCode(chosenStatusCode.getCode());
+                        exchange.setResponseCode(chosenStatusCode);
                     }
                 } else {
                     // No mechanism generated a challenge so send a 403 as our challenge - i.e. just rejecting the request.
-                    exchange.setResponseCode(CODE_403.getCode());
+                    exchange.setResponseCode(FORBIDDEN);
                 }
 
                 return AuthenticationState.CHALLENGE_SENT;",2013-03-06T01:21:46Z,56
"@@ -25,81 +25,149 @@
 /**
  * @author Stuart Douglas
  */
-public enum StatusCodes {
-    UNKNOWN(0, ""Unknown""),
-    CODE_100(100, ""Continue""),
-    CODE_101(101, ""Switching Protocols""),
-    CODE_200(200, ""OK""),
-    CODE_201(201, ""Created""),
-    CODE_202(202, ""Accepted""),
-    CODE_203(203, ""Non-Authoritative Information""),
-    CODE_204(204, ""No Content""),
-    CODE_205(205, ""Reset Content""),
-    CODE_206(206, ""Partial Content""),
-    CODE_300(300, ""Multiple Choices""),
-    CODE_301(301, ""Moved Permanently""),
-    CODE_302(302, ""Found""),
-    CODE_303(303, ""See Other""),
-    CODE_304(304, ""Not Modified""),
-    CODE_305(305, ""Use Proxy""),
-    CODE_307(307, ""Temporary Redirect""),
-    CODE_400(400, ""Bad Request""),
-    CODE_401(401, ""Unauthorized""),
-    CODE_402(402, ""Payment Required""),
-    CODE_403(403, ""Forbidden""),
-    CODE_404(404, ""Not Found""),
-    CODE_405(405, ""Method Not Allowed""),
-    CODE_406(406, ""Not Acceptable""),
-    CODE_407(407, ""Proxy Authentication Required""),
-    CODE_408(408, ""Request Time-out""),
-    CODE_409(409, ""Conflict""),
-    CODE_410(410, ""Gone""),
-    CODE_411(411, ""Length Required""),
-    CODE_412(412, ""Precondition Failed""),
-    CODE_413(413, ""Request Entity Too Large""),
-    CODE_414(414, ""Request-URI Too Large""),
-    CODE_415(415, ""Unsupported Media Type""),
-    CODE_416(416, ""Requested range not satisfiable""),
-    CODE_417(417, ""Expectation Failed""),
-    CODE_500(500, ""Internal Server Error""),
-    CODE_501(501, ""Not Implemented""),
-    CODE_502(502, ""Bad Gateway""),
-    CODE_503(503, ""Service Unavailable""),
-    CODE_504(504, ""Gateway Time-out""),
-    CODE_505(505, ""HTTP Version not supported""),;
+public class StatusCodes {
+    public static final int CONTINUE = 100;
+    public static final int SWITCHING_PROTOCOLS = 101;
+    public static final int OK = 200;
+    public static final int CREATED = 201;
+    public static final int ACCEPTED = 202;
+    public static final int NON_AUTHORITATIVE_INFORMATION = 203;
+    public static final int NO_CONTENT = 204;
+    public static final int RESET_CONTENT = 205;
+    public static final int PARTIAL_CONTENT = 206;
+    public static final int MULTIPLE_CHOICES = 300;
+    public static final int MOVED_PERMENANTLY = 301;
+    public static final int FOUND = 302;
+    public static final int SEE_OTHER = 303;
+    public static final int NOT_MODIFIED = 304;
+    public static final int USE_PROXY = 305;
+    public static final int TEMPORARY_REDIRECT = 307;
+    public static final int BAD_REQUEST = 400;
+    public static final int UNAUTHORIZED = 401;
+    public static final int PAYMENT_REQUIRED = 402;
+    public static final int FORBIDDEN = 403;
+    public static final int NOT_FOUND = 404;
+    public static final int METHOD_NOT_ALLOWED = 405;
+    public static final int NOT_ACCEPTABLE = 406;
+    public static final int PROXY_AUTHENTICATION_REQUIRED = 407;
+    public static final int REQUEST_TIME_OUT = 408;
+    public static final int CONFLICT = 409;
+    public static final int GONE = 410;
+    public static final int LENGTH_REQUIRED = 411;
+    public static final int PRECONDITION_FAILED = 412;
+    public static final int REQUEST_ENTITY_TOO_LARGE = 413;
+    public static final int REQUEST_URI_TOO_LARGE = 414;
+    public static final int UNSUPPORTED_MEDIA_TYPE = 415;
+    public static final int REQUEST_RANGE_NOT_SATISFIABLE = 416;
+    public static final int EXPECTATION_FAILED = 417;
+    public static final int INTERNAL_SERVER_ERROR = 500;
+    public static final int NOT_IMPLEMENTED = 501;
+    public static final int BAD_GATEWAY = 502;
+    public static final int SERVICE_UNAVAILABLE = 503;
+    public static final int GATEWAY_TIME_OUT = 504;
+    public static final int HTTP_VERSION_NOT_SUPPORTED = 505;
 
-    private final int code;
-    private final String reason;
 
-    private static final Map<Integer, StatusCodes> CODES;
+    public static final String CONTINUE_STRING = ""Continue"";
+    public static final String SWITCHING_PROTOCOLS_STRING = ""Switching Protocols"";
+    public static final String OK_STRING = ""OK"";
+    public static final String CREATED_STRING = ""Created"";
+    public static final String ACCEPTED_STRING = ""Accepted"";
+    public static final String NON_AUTHORITATIVE_INFORMATION_STRING = ""Non-Authoritative Information"";
+    public static final String NO_CONTENT_STRING = ""No Content"";
+    public static final String RESET_CONTENT_STRING = ""Reset Content"";
+    public static final String PARTIAL_CONTENT_STRING = ""Partial Content"";
+    public static final String MULTIPLE_CHOICES_STRING = ""Multiple Choices"";
+    public static final String MOVED_PERMENANTLY_STRING = ""Moved Permanently"";
+    public static final String FOUND_STRING = ""Found"";
+    public static final String SEE_OTHER_STRING = ""See Other"";
+    public static final String NOT_MODIFIED_STRING = ""Not Modified"";
+    public static final String USE_PROXY_STRING = ""Use Proxy"";
+    public static final String TEMPORARY_REDIRECT_STRING = ""Temporary Redirect"";
+    public static final String BAD_REQUEST_STRING = ""Bad Request"";
+    public static final String UNAUTHORIZED_STRING = ""Unauthorized"";
+    public static final String PAYMENT_REQUIRED_STRING = ""Payment Required"";
+    public static final String FORBIDDEN_STRING = ""Forbidden"";
+    public static final String NOT_FOUND_STRING = ""Not Found"";
+    public static final String METHOD_NOT_ALLOWED_STRING = ""Method Not Allowed"";
+    public static final String NOT_ACCEPTABLE_STRING = ""Not Acceptable"";
+    public static final String PROXY_AUTHENTICATION_REQUIRED_STRING = ""Proxy Authentication Required"";
+    public static final String REQUEST_TIME_OUT_STRING = ""Request Time-out"";
+    public static final String CONFLICT_STRING = ""Conflict"";
+    public static final String GONE_STRING = ""Gone"";
+    public static final String LENGTH_REQUIRED_STRING = ""Length Required"";
+    public static final String PRECONDITION_FAILED_STRING = ""Precondition Failed"";
+    public static final String REQUEST_ENTITY_TOO_LARGE_STRING = ""Request Entity Too Large"";
+    public static final String REQUEST_URI_TOO_LARGE_STRING = ""Request-URI Too Large"";
+    public static final String UNSUPPORTED_MEDIA_TYPE_STRING = ""Unsupported Media Type"";
+    public static final String REQUEST_RANGE_NOT_SATISFIABLE_STRING = ""Requested range not satisfiable"";
+    public static final String EXPECTATION_FAILED_STRING = ""Expectation Failed"";
+    public static final String INTERNAL_SERVER_ERROR_STRING = ""Internal Server Error"";
+    public static final String NOT_IMPLEMENTED_STRING = ""Not Implemented"";
+    public static final String BAD_GATEWAY_STRING = ""Bad Gateway"";
+    public static final String SERVICE_UNAVAILABLE_STRING = ""Service Unavailable"";
+    public static final String GATEWAY_TIME_OUT_STRING = ""Gateway Time-out"";
+    public static final String HTTP_VERSION_NOT_SUPPORTED_STRING = ""HTTP Version not supported"";
+    ;
+
+    private static final Map<Integer, String> CODES;
 
     static {
-        final Map<Integer, StatusCodes> codes = new HashMap<Integer, StatusCodes>();
-        for (final StatusCodes code : values()) {
-            codes.put(code.code, code);
-        }
-        CODES = Collections.unmodifiableMap(codes);
-    }
+        final Map<Integer, String> codes = new HashMap<Integer, String>();
+        codes.put(CONTINUE, CONTINUE_STRING);
+        codes.put(SWITCHING_PROTOCOLS, SWITCHING_PROTOCOLS_STRING);
+        codes.put(OK, OK_STRING);
+        codes.put(CREATED, CREATED_STRING);
+        codes.put(ACCEPTED, ACCEPTED_STRING);
+        codes.put(NON_AUTHORITATIVE_INFORMATION, NON_AUTHORITATIVE_INFORMATION_STRING);
+        codes.put(NO_CONTENT, NO_CONTENT_STRING);
+        codes.put(RESET_CONTENT, RESET_CONTENT_STRING);
+        codes.put(PARTIAL_CONTENT, PARTIAL_CONTENT_STRING);
+        codes.put(MULTIPLE_CHOICES, MULTIPLE_CHOICES_STRING);
+        codes.put(MOVED_PERMENANTLY, MOVED_PERMENANTLY_STRING);
+        codes.put(FOUND, FOUND_STRING);
+        codes.put(SEE_OTHER, SEE_OTHER_STRING);
+        codes.put(NOT_MODIFIED, NOT_MODIFIED_STRING);
+        codes.put(USE_PROXY, USE_PROXY_STRING);
+        codes.put(TEMPORARY_REDIRECT, TEMPORARY_REDIRECT_STRING);
+        codes.put(BAD_REQUEST, BAD_REQUEST_STRING);
+        codes.put(UNAUTHORIZED, UNAUTHORIZED_STRING);
+        codes.put(PAYMENT_REQUIRED, PAYMENT_REQUIRED_STRING);
+        codes.put(FORBIDDEN, FORBIDDEN_STRING);
+        codes.put(NOT_FOUND, NOT_FOUND_STRING);
+        codes.put(METHOD_NOT_ALLOWED, METHOD_NOT_ALLOWED_STRING);
+        codes.put(NOT_ACCEPTABLE, NOT_ACCEPTABLE_STRING);
+        codes.put(PROXY_AUTHENTICATION_REQUIRED, PROXY_AUTHENTICATION_REQUIRED_STRING);
+        codes.put(REQUEST_TIME_OUT, REQUEST_TIME_OUT_STRING);
+        codes.put(CONFLICT, CONFLICT_STRING);
+        codes.put(GONE, GONE_STRING);
+        codes.put(LENGTH_REQUIRED, LENGTH_REQUIRED_STRING);
+        codes.put(PRECONDITION_FAILED, PRECONDITION_FAILED_STRING);
+        codes.put(REQUEST_ENTITY_TOO_LARGE, REQUEST_ENTITY_TOO_LARGE_STRING);
+        codes.put(REQUEST_URI_TOO_LARGE, REQUEST_URI_TOO_LARGE_STRING);
+        codes.put(UNSUPPORTED_MEDIA_TYPE, UNSUPPORTED_MEDIA_TYPE_STRING);
+        codes.put(REQUEST_RANGE_NOT_SATISFIABLE, REQUEST_RANGE_NOT_SATISFIABLE_STRING);
+        codes.put(EXPECTATION_FAILED, EXPECTATION_FAILED_STRING);
+        codes.put(INTERNAL_SERVER_ERROR, INTERNAL_SERVER_ERROR_STRING);
+        codes.put(NOT_IMPLEMENTED, NOT_IMPLEMENTED_STRING);
+        codes.put(BAD_GATEWAY, BAD_GATEWAY_STRING);
+        codes.put(SERVICE_UNAVAILABLE, SERVICE_UNAVAILABLE_STRING);
+        codes.put(GATEWAY_TIME_OUT, GATEWAY_TIME_OUT_STRING);
+        codes.put(HTTP_VERSION_NOT_SUPPORTED, HTTP_VERSION_NOT_SUPPORTED_STRING);
 
-    private StatusCodes(final int code, final String reason) {
-        this.code = code;
-        this.reason = reason;
-    }
 
-    public int getCode() {
-        return code;
+        CODES = Collections.unmodifiableMap(codes);
     }
 
-    public String getReason() {
-        return reason;
+    private StatusCodes() {
     }
 
     public static final String getReason(final int code) {
-        final StatusCodes result = CODES.get(code);
+        final String result = CODES.get(code);
         if (result == null) {
-            return UNKNOWN.reason;
+            return ""Unknown"";
         } else {
-            return result.reason;
+            return result;
         }
     }
 }",2013-03-06T01:21:46Z,11
"@@ -50,7 +50,7 @@ public void testSimpleErrorPageIsGenerated() throws IOException {
             Assert.assertEquals(404, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);
 
-            Assert.assertTrue(response, response.contains(StatusCodes.CODE_404.getReason()));
+            Assert.assertTrue(response, response.contains(StatusCodes.NOT_FOUND_STRING));
 
         } finally {
             client.getConnectionManager().shutdown();",2013-03-06T01:21:46Z,124
"@@ -84,6 +84,12 @@
             <artifactId>junit</artifactId>
             <scope>test</scope>
         </dependency>
+        
+        <dependency>
+            <groupId>org.apache.directory.server</groupId>
+            <artifactId>apacheds-all</artifactId>
+            <scope>test</scope>
+        </dependency>        
 
         <dependency>
             <groupId>org.apache.httpcomponents</groupId>",2013-11-22T11:27:17Z,333
"@@ -36,7 +36,7 @@
 import static org.junit.Assert.assertEquals;
 
 /**
- * A test case to test when the only authentication mechanism
+ * A test case to test when the only authentication mechanism is the BASIC mechanism.
  *
  * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
  */",2013-11-22T11:27:17Z,71
"@@ -0,0 +1,302 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2013 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.server.security;
+
+import static javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag.REQUIRED;
+import io.undertow.testutils.DefaultServer;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.security.auth.Subject;
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.auth.login.AppConfigurationEntry;
+import javax.security.auth.login.Configuration;
+import javax.security.auth.login.LoginContext;
+import javax.security.auth.login.LoginException;
+
+import org.apache.directory.api.ldap.model.entry.DefaultEntry;
+import org.apache.directory.api.ldap.model.ldif.LdifEntry;
+import org.apache.directory.api.ldap.model.ldif.LdifReader;
+import org.apache.directory.api.ldap.model.schema.SchemaManager;
+import org.apache.directory.server.core.api.CoreSession;
+import org.apache.directory.server.core.api.DirectoryService;
+import org.apache.directory.server.core.api.partition.Partition;
+import org.apache.directory.server.core.factory.DefaultDirectoryServiceFactory;
+import org.apache.directory.server.core.factory.DirectoryServiceFactory;
+import org.apache.directory.server.core.factory.PartitionFactory;
+import org.apache.directory.server.core.kerberos.KeyDerivationInterceptor;
+import org.apache.directory.server.kerberos.KerberosConfig;
+import org.apache.directory.server.kerberos.kdc.KdcServer;
+import org.apache.directory.server.ldap.LdapServer;
+import org.apache.directory.server.protocol.shared.transport.TcpTransport;
+import org.apache.directory.server.protocol.shared.transport.Transport;
+import org.apache.directory.server.protocol.shared.transport.UdpTransport;
+
+/**
+ * Utility class to start up a test KDC backed by a directory server.
+ *
+ * It is better to start the server once instead of once per test but once running
+ * the overhead is minimal.  However a better solution may be to use the {@link Suite}
+ * runner but we currently need to use the {@link DefaultServer} runner.
+ *
+ * TODO - May be able to add some lifecycle methods to DefaultServer to allow
+ * for an extension.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+class KerberosKDCUtil {
+
+    private static final boolean IS_IBM = System.getProperty(""java.vendor"").contains(""IBM"");
+
+    private static final Charset UTF_8 = Charset.forName(""UTF-8"");
+
+    static final int LDAP_PORT = 11389;
+    static final int KDC_PORT = 6088;
+
+    private static final String DIRECTORY_NAME = ""Test Service"";
+    private static boolean initialised;
+    private static File workingDir;
+
+    /*
+     * LDAP Related
+     */
+    private static DirectoryService directoryService;
+    private static LdapServer ldapServer;
+
+    /*
+     * KDC Related
+     */
+    private static KdcServer kdcServer;
+
+
+
+    public static boolean startServer() throws Exception {
+        if (initialised == true) {
+            return false;
+        }
+        startLdapServer();
+        startKDC();
+        setupEnvironment();
+
+        initialised = true;
+        return true;
+    }
+
+    private static void startLdapServer() throws Exception {
+        createWorkingDir();
+        DirectoryServiceFactory dsf = new DefaultDirectoryServiceFactory();
+        dsf.init(DIRECTORY_NAME);
+        directoryService = dsf.getDirectoryService();
+        directoryService.addLast(new KeyDerivationInterceptor()); // Derives the Kerberos keys for new entries.
+        directoryService.getChangeLog().setEnabled(false);
+        SchemaManager schemaManager = directoryService.getSchemaManager();
+
+        createPartition(dsf, schemaManager, ""users"", ""ou=users,dc=undertow,dc=io"");
+
+        CoreSession adminSession = directoryService.getAdminSession();
+        Map<String, String> mappings = Collections.singletonMap(""hostname"", DefaultServer.getDefaultServerAddress().getHostString());
+        processLdif(schemaManager, adminSession, ""partition.ldif"", mappings);
+        processLdif(schemaManager, adminSession, ""krbtgt.ldif"", mappings);
+        processLdif(schemaManager, adminSession, ""user.ldif"", mappings);
+        processLdif(schemaManager, adminSession, ""server.ldif"", mappings);
+
+        ldapServer = new LdapServer();
+        ldapServer.setServiceName(""DefaultLDAP"");
+        Transport ldap = new TcpTransport( ""0.0.0.0"", LDAP_PORT, 3, 5 );
+        ldapServer.addTransports(ldap);
+        ldapServer.setDirectoryService(directoryService);
+        ldapServer.start();
+    }
+
+    private static void createPartition(final DirectoryServiceFactory dsf, final SchemaManager schemaManager, final String id,
+            final String suffix) throws Exception {
+        PartitionFactory pf = dsf.getPartitionFactory();
+        Partition p = pf.createPartition(schemaManager, id, suffix, 1000, workingDir);
+        pf.addIndex(p, ""krb5PrincipalName"", 10);
+        p.initialize();
+        directoryService.addPartition(p);
+    }
+
+    private static void processLdif(final SchemaManager schemaManager, final CoreSession adminSession, final String ldifName,
+            final Map<String, String> mappings) throws Exception {
+        InputStream resourceInput = KerberosKDCUtil.class.getResourceAsStream(""/ldif/"" + ldifName);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(resourceInput.available());
+        int current;
+        while ((current = resourceInput.read()) != -1) {
+            if (current == '$') {
+                // Enter String replacement mode.
+                int second = resourceInput.read();
+                if (second == '{') {
+                    ByteArrayOutputStream substitute = new ByteArrayOutputStream();
+                    while ((current = resourceInput.read()) != -1 && current != '}') {
+                        substitute.write(current);
+                    }
+                    if (current == -1) {
+                        baos.write(substitute.toByteArray()); // Terminator never found.
+                    }
+                    String toReplace = new String(substitute.toByteArray(), UTF_8);
+                    if (mappings.containsKey(toReplace)) {
+                        baos.write(mappings.get(toReplace).getBytes());
+                    } else {
+                        throw new IllegalArgumentException(String.format(""No mapping found for '%s'"", toReplace));
+                    }
+                } else {
+                    baos.write(current);
+                }
+            } else {
+                baos.write(current);
+            }
+        }
+
+        ByteArrayInputStream ldifInput = new ByteArrayInputStream(baos.toByteArray());
+        LdifReader ldifReader = new LdifReader(ldifInput);
+        for (LdifEntry ldifEntry : ldifReader) {
+            adminSession.add(new DefaultEntry(schemaManager, ldifEntry.getEntry()));
+        }
+        ldifReader.close();
+        ldifInput.close();
+    }
+
+    private static void startKDC() throws Exception {
+        kdcServer = new KdcServer();
+        kdcServer.setServiceName(""Test KDC"");
+        kdcServer.setSearchBaseDn(""ou=users,dc=undertow,dc=io"");
+        KerberosConfig config = kdcServer.getConfig();
+        config.setServicePrincipal(""krbtgt/UNDERTOW.IO@UNDERTOW.IO"");
+        config.setPrimaryRealm(""UNDERTOW.IO"");
+
+        config.setPaEncTimestampRequired(false);
+
+        UdpTransport udp = new UdpTransport(""0.0.0.0"", KDC_PORT);
+        kdcServer.addTransports(udp);
+
+        kdcServer.setDirectoryService(directoryService);
+        kdcServer.start();
+    }
+
+    private static void setupEnvironment() {
+        final URL configPath = KerberosKDCUtil.class.getResource(""/krb5.conf"");
+        System.setProperty(""java.security.krb5.conf"", configPath.getFile());
+    }
+
+    private static void createWorkingDir() throws IOException {
+        if (workingDir == null) {
+            if (workingDir == null) {
+                workingDir = new File(""."");
+                workingDir = new File(workingDir, ""target"");
+                workingDir = new File(workingDir, ""apacheds_working"").getCanonicalFile();
+                if (!workingDir.exists()) {
+                    workingDir.mkdirs();
+                }
+            }
+        }
+        for (File current : workingDir.listFiles()) {
+          current.delete();
+        }
+    }
+
+    static Subject login(final String userName, final char[] password) throws LoginException {
+        Subject theSubject = new Subject();
+        CallbackHandler cbh = new UsernamePasswordCBH(userName, password);
+        LoginContext lc = new LoginContext(""KDC"", theSubject, cbh, createJaasConfiguration());
+        lc.login();
+
+        return theSubject;
+    }
+
+    private static Configuration createJaasConfiguration() {
+        return new Configuration() {
+
+            @Override
+            public AppConfigurationEntry[] getAppConfigurationEntry(String name) {
+                if (""KDC"".equals(name) == false) {
+                    throw new IllegalArgumentException(""Unexpected name '"" + name + ""'"");
+                }
+
+                AppConfigurationEntry[] entries = new AppConfigurationEntry[1];
+                Map<String, Object> options = new HashMap<String, Object>();
+                options.put(""debug"", ""true"");
+                options.put(""refreshKrb5Config"", ""true"");
+
+                if (IS_IBM) {
+                    options.put(""noAddress"", ""true"");
+                    options.put(""credsType"", ""both"");
+                    entries[0] = new AppConfigurationEntry(""com.ibm.security.auth.module.Krb5LoginModule"", REQUIRED, options);
+                } else {
+                    options.put(""storeKey"", ""true"");
+                    options.put(""isInitiator"", ""true"");
+                    entries[0] = new AppConfigurationEntry(""com.sun.security.auth.module.Krb5LoginModule"", REQUIRED, options);
+                }
+
+                return entries;
+            }
+
+        };
+    }
+
+    private static class UsernamePasswordCBH implements CallbackHandler {
+
+        /*
+         * Note: We use CallbackHandler implementations like this in test cases as test cases need to run unattended, a true
+         * CallbackHandler implementation should interact directly with the current user to prompt for the username and
+         * password.
+         *
+         * i.e. In a client app NEVER prompt for these values in advance and provide them to a CallbackHandler like this.
+         */
+
+        private final String username;
+        private final char[] password;
+
+        private UsernamePasswordCBH(final String username, final char[] password) {
+            this.username = username;
+            this.password = password;
+        }
+
+        @Override
+        public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+            for (Callback current : callbacks) {
+                if (current instanceof NameCallback) {
+                    NameCallback ncb = (NameCallback) current;
+                    ncb.setName(username);
+                } else if (current instanceof PasswordCallback) {
+                    PasswordCallback pcb = (PasswordCallback) current;
+                    pcb.setPassword(password);
+                } else {
+                    throw new UnsupportedCallbackException(current);
+                }
+            }
+
+        }
+
+    }
+
+}",2013-11-22T11:27:17Z,446
"@@ -15,8 +15,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.undertow.server.security;
 
+import javax.security.auth.Subject;
+
+import io.undertow.testutils.DefaultServer;
+
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -29,19 +34,32 @@
 public class SpnegoAuthenticationTestCase {
 
     @BeforeClass
-    public static void startServers() {
-
+    public static void startServers() throws Exception {
+        KerberosKDCUtil.startServer();
     }
 
     @AfterClass
     public static void stopServers() {
 
     }
 
-
     @Test
     public void test() {
+        System.out.println(""Test Run"");
+    }
+
+    @Test
+    public void testJDuke() throws Exception {
+        Subject subject = KerberosKDCUtil.login(""jduke"", ""theduke"".toCharArray());
+
+        System.out.println(subject.toString());
+    }
+
+    @Test
+    public void testServer() throws Exception {
+        Subject subject = KerberosKDCUtil.login(""HTTP/"" + DefaultServer.getDefaultServerAddress().getHostString(), ""servicepwd"".toCharArray());
 
+        System.out.println(subject.toString());
     }
 
 }",2013-11-22T11:27:17Z,447
"@@ -1,3 +1,21 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.undertow.testutils;
 
 import javax.net.ssl.SSLContext;",2013-11-22T11:27:17Z,95
"@@ -0,0 +1,18 @@
+[libdefaults]
+	default_realm = UNDERTOW.IO
+	default_tgs_enctypes = des-cbc-md5,des3-cbc-sha1-kd
+	default_tkt_enctypes = des-cbc-md5,des3-cbc-sha1-kd
+	kdc_timeout = 5000
+	dns_lookup_realm = false
+	dns_lookup_kdc = false
+	allow_weak_crypto = yes
+	forwardable = true
+
+[realms]
+	UNDERTOW.IO = {
+		kdc = localhost:6088
+	}
+
+[login]
+	krb4_convert = true
+	krb4_get_tickets = false",2013-11-22T11:27:17Z,448
"@@ -0,0 +1,12 @@
+dn: uid=krbtgt,ou=users,dc=undertow,dc=io
+objectClass: top
+objectClass: person
+objectClass: inetOrgPerson
+objectClass: krb5principal
+objectClass: krb5kdcentry
+cn: KDC Service
+sn: Service
+uid: krbtgt
+userPassword: secret
+krb5PrincipalName: krbtgt/UNDERTOW.IO@UNDERTOW.IO
+krb5KeyVersionNumber: 0
\ No newline at end of file",2013-11-22T11:27:17Z,449
"@@ -0,0 +1,4 @@
+dn: ou=users,dc=undertow,dc=io
+objectClass: organizationalUnit
+objectClass: top
+ou: users
\ No newline at end of file",2013-11-22T11:27:17Z,450
"@@ -0,0 +1,12 @@
+dn: uid=Server,ou=users,dc=undertow,dc=io
+objectClass: top
+objectClass: person
+objectClass: inetOrgPerson
+objectClass: krb5principal
+objectClass: krb5kdcentry
+cn: Server
+sn: Service
+uid: Server
+userPassword: servicepwd
+krb5PrincipalName: HTTP/${hostname}@UNDERTOW.IO
+krb5KeyVersionNumber: 0
\ No newline at end of file",2013-11-22T11:27:17Z,451
"@@ -0,0 +1,12 @@
+dn: uid=jduke,ou=users,dc=undertow,dc=io
+objectClass: top
+objectClass: person
+objectClass: inetOrgPerson
+objectClass: krb5principal
+objectClass: krb5kdcentry
+cn: Java Duke
+sn: duke
+uid: jduke
+userPassword: theduke
+krb5PrincipalName: jduke@UNDERTOW.IO
+krb5KeyVersionNumber: 0",2013-11-22T11:27:17Z,452
"@@ -53,7 +53,7 @@
         <!-- Build configuration -->
         <maven.compiler.source>1.6</maven.compiler.source>
         <maven.compiler.target>1.6</maven.compiler.target>
-        <version.checkstyle.plugin>2.10</version.checkstyle.plugin>
+        <version.checkstyle.plugin>2.11</version.checkstyle.plugin>
         <version.surefire.plugin>2.11</version.surefire.plugin>
         <!--
             Dependency versions. Please keep alphabetical.
@@ -69,7 +69,8 @@
         <version.easymock>3.2</version.easymock>        
         <version.io.undertow.jastow>1.0.0.Beta2</version.io.undertow.jastow>
         <version.junit>4.11</version.junit>        
-        <version.netty>3.6.6.Final</version.netty>        
+        <version.netty>3.6.6.Final</version.netty>     
+        <version.org.apache.directory.server>2.0.0-M15</version.org.apache.directory.server>   
         <version.org.apache.httpmime>4.2.5</version.org.apache.httpmime>
         <version.org.apache.httpcomponents>4.2.5</version.org.apache.httpcomponents>
         <version.org.glassfish.el>3.0.0</version.org.glassfish.el>
@@ -82,7 +83,7 @@
         <version.org.jboss.spec.javax.servlet.jsp>1.0.0.Beta1</version.org.jboss.spec.javax.servlet.jsp>
         <version.org.jboss.spec.javax.websockets>1.0.0.Final</version.org.jboss.spec.javax.websockets>
         <version.org.jboss.web.jasper-jdt>7.0.3.Final</version.org.jboss.web.jasper-jdt>
-        <version.xnio>3.2.0.Beta2</version.xnio>
+        <version.xnio>3.2.0.Beta2</version.xnio>       
         
         <!-- Surefire args -->
         <surefire.jpda.args/>
@@ -284,6 +285,13 @@
                 <scope>test</scope>
             </dependency>
 
+            <dependency>
+                <groupId>org.apache.directory.server</groupId>
+                <artifactId>apacheds-all</artifactId>
+                <version>${version.org.apache.directory.server}</version>
+                <scope>test</scope>
+            </dependency>            
+
             <dependency>
                 <groupId>org.apache.httpcomponents</groupId>
                 <artifactId>httpclient</artifactId>",2013-11-22T11:27:17Z,265
"@@ -21,10 +21,6 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.StatusCodes;
 
-import java.util.concurrent.Executor;
-
-import org.xnio.IoFuture;
-
 /**
  * The interface to be implemented by a single authentication mechanism.
  * <p/>
@@ -71,13 +67,13 @@ public interface AuthenticationMechanism {
     /**
      * Perform authentication of the request. Any potentially blocking work should be performed in the handoff executor provided
      *
+     *
+     *
      * @param exchange The exchange
-     * @param identityManager The identity manager
-     * @param handOffExecutor The executor to use for potentially blocking tasks
      * @return
      */
-    IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange exchange,
-            final SecurityContext securityContext, final Executor handOffExecutor);
+    AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
+                                                final SecurityContext securityContext);
 
     /**
      * Send an authentication challenge to the remote client.
@@ -86,13 +82,13 @@ IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange e
      * not set the response code, instead that should be indicated in the {@link ChallengeResult} and the most appropriate
      * overall response code will be selected.
      *
+     *
+     *
      * @param exchange The exchange
      * @param securityContext The security context
-     * @param handOffExecutor The executor to use for potentially blocking tasks.
      * @return A {@link ChallengeResult} indicating if a challenge was sent and the desired response code.
      */
-    IoFuture<ChallengeResult> sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext,
-            final Executor handOffExecutor);
+    ChallengeResult sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext);
 
     /**
      * The AuthenticationOutcome is used by an AuthenticationMechanism to indicate the outcome of the call to authenticate, the",2013-02-21T11:31:54Z,64
"@@ -17,14 +17,12 @@
  */
 package io.undertow.security.api;
 
+import java.util.List;
+
 import io.undertow.security.idm.Account;
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.util.AttachmentKey;
 
-import java.util.List;
-
-import org.xnio.IoFuture;
-
 /**
  * The security context.
  *
@@ -57,13 +55,9 @@ public interface SecurityContext {
      * If the result indicates that a response has been sent to the client then no further attempts should be made to modify the
      * response. The caller of this method is responsible for ending the exchange.
      *
-     * When this method is called depending on the authentication mechanisms and the current thread making the call the request
-     * could occur in the same thread or be dispatched to a different thread, unless the caller is required to block it should
-     * register a {@link IoFuture.Notifier} to handle the response.
-     *
-     * return {@link IoFuture<Boolean>} to indicate if a response has been sent to the calling client.
+     * return <code>false</code> to indicate that authentication failed and the response has been send to the calling client
      */
-    IoFuture<Boolean> authenticate();
+    boolean authenticate();
 
     /*
      * API for Direct Control of Authentication",2013-02-21T11:31:54Z,453
"@@ -17,11 +17,6 @@
  */
 package io.undertow.security.handlers;
 
-import java.io.IOException;
-
-import org.xnio.IoFuture;
-import org.xnio.IoFuture.Notifier;
-
 import io.undertow.security.api.SecurityContext;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -49,26 +44,12 @@ public AuthenticationCallHandler(final HttpHandler next) {
     @Override
     public void handleRequest(final HttpServerExchange exchange) {
         SecurityContext context = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
-        IoFuture<Boolean> result = context.authenticate();
-        result.addNotifier(new Notifier<Boolean, Object>() {
-
-            @Override
-            public void notify(IoFuture<? extends Boolean> ioFuture, Object attachment) {
-                try {
-                    if (ioFuture.get()) {
-                        // Response has already been send - end the exchange.
-                        exchange.endExchange();
-                    } else {
-                        HttpHandlers.executeHandler(next, exchange);
-                    }
-                } catch (IOException e) {
-                    // Response has already been send - end the exchange.
-                    // TODO - Error reporting.
-                    exchange.endExchange();
-                }
-            }
-        }, null);
-
+        boolean challengeSent = !context.authenticate();
+        if(challengeSent) {
+            exchange.endExchange();
+        } else {
+            HttpHandlers.executeHandler(next, exchange);
+        }
     }
 
 }",2013-02-21T11:31:54Z,97
"@@ -17,27 +17,23 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.util.Headers.AUTHORIZATION;
-import static io.undertow.util.Headers.BASIC;
-import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.List;
+
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.SecurityContext;
 import io.undertow.security.idm.Account;
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.security.idm.PasswordCredential;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.ConcreteIoFuture;
 import io.undertow.util.FlexBase64;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import org.xnio.FinishedIoFuture;
-import org.xnio.IoFuture;
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.BASIC;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static io.undertow.util.StatusCodes.CODE_401;
 
 /**
  * The authentication handler responsible for BASIC authentication as described by RFC2617
@@ -73,9 +69,7 @@ public String getName() {
      * @see io.undertow.server.HttpHandler#handleRequest(io.undertow.server.HttpServerExchange)
      */
     @Override
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(HttpServerExchange exchange, SecurityContext securityContext,
-            Executor handOffExecutor) {
-        ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
+    public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange, SecurityContext securityContext) {
 
         List<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);
         if (authHeaders != null) {
@@ -92,68 +86,44 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(HttpServerExchange
                     if (plainChallenge != null && (colonPos = plainChallenge.indexOf(COLON)) > -1) {
                         String userName = plainChallenge.substring(0, colonPos);
                         String password = plainChallenge.substring(colonPos + 1);
-                        handOffExecutor.execute(new BasicRunnable(securityContext, result, userName, password.toCharArray()));
 
-                        // The request has now potentially been dispatched to a different worker thread, the run method
-                        // within BasicRunnable is now responsible for ensuring the request continues.
-                        return result;
+                        return runBasic(securityContext, userName, password.toCharArray());
                     }
 
                     // By this point we had a header we should have been able to verify but for some reason
                     // it was not correctly structured.
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return result;
+                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
                 }
             }
         }
 
         // No suitable header has been found in this request,
-        result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
-        return result;
+        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
     }
 
-    private final class BasicRunnable implements Runnable {
-
-        private final SecurityContext securityContext;
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-        private final String userName;
-        private final char[] password;
-
-        private BasicRunnable(final SecurityContext securityContext,
-                final ConcreteIoFuture<AuthenticationMechanismOutcome> result, final String userName, final char[] password) {
-            this.securityContext = securityContext;
-            this.result = result;
-            this.userName = userName;
-            this.password = password;
-        }
-
-        @Override
-        public void run() {
-            // To reach this point we must have been supplied a username and password.
-            AuthenticationMechanismOutcome result = null;
-            IdentityManager idm = securityContext.getIdentityManager();
-            PasswordCredential credential = new PasswordCredential(password);
-            try {
-                Account account = idm.verify(userName, credential);
-                if (account != null) {
-                    securityContext.authenticationComplete(account, getName(), false);
-                    result = AuthenticationMechanismOutcome.AUTHENTICATED;
-                }
-            } finally {
-                this.result.setResult(result != null ? result : AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-
-                for (int i = 0; i < password.length; i++) {
-                    password[i] = 0x00;
-                }
+    public AuthenticationMechanismOutcome runBasic(final SecurityContext securityContext,final String userName, final char[] password) {
+        // To reach this point we must have been supplied a username and password.
+        AuthenticationMechanismOutcome result = null;
+        IdentityManager idm = securityContext.getIdentityManager();
+        PasswordCredential credential = new PasswordCredential(password);
+        try {
+            Account account = idm.verify(userName, credential);
+            if (account != null) {
+                securityContext.authenticationComplete(account, getName(), false);
+                result = AuthenticationMechanismOutcome.AUTHENTICATED;
+            }
+            return result != null ? result : AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        } finally {
+            for (int i = 0; i < password.length; i++) {
+                password[i] = 0x00;
             }
         }
     }
 
     @Override
-    public IoFuture<ChallengeResult> sendChallenge(HttpServerExchange exchange, SecurityContext securityContext,
-            Executor handOffExecutor) {
+    public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
         exchange.getResponseHeaders().add(WWW_AUTHENTICATE, challenge);
-        return new FinishedIoFuture<AuthenticationMechanism.ChallengeResult>(new ChallengeResult(true, CODE_401));
+        return new ChallengeResult(true, CODE_401);
     }
 
 }",2013-02-21T11:31:54Z,1
"@@ -23,11 +23,6 @@
 import io.undertow.security.api.SecurityContext;
 import io.undertow.security.idm.Account;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.ConcreteIoFuture;
-
-import java.util.concurrent.Executor;
-
-import org.xnio.IoFuture;
 
 /**
  * An {@link AuthenticationMechanism} which uses any cached {@link AuthenticationSession}s.
@@ -45,68 +40,41 @@ public String getName() {
     }
 
     @Override
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(HttpServerExchange exchange, SecurityContext securityContext,
-            Executor handOffExecutor) {
-        ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
+    public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange, SecurityContext securityContext) {
 
         AuthenticatedSessionManager sessionManager = exchange.getAttachment(AuthenticatedSessionManager.ATTACHMENT_KEY);
         if (sessionManager != null) {
-            handOffExecutor.execute(new CachedAuthenticationRunnable(result, exchange, securityContext, sessionManager));
+            return runCached(exchange, securityContext, sessionManager);
         } else {
-            result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
+            return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
         }
-
-        return result;
     }
 
-    private static class CachedAuthenticationRunnable implements Runnable {
-
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-        private final HttpServerExchange exchange;
-        private final SecurityContext securityContext;
-        private final AuthenticatedSessionManager sessionManager;
-
-        private CachedAuthenticationRunnable(final ConcreteIoFuture<AuthenticationMechanismOutcome> result,
-                final HttpServerExchange exchange, final SecurityContext securityContext,
-                final AuthenticatedSessionManager sessionManager) {
-            this.result = result;
-            this.exchange = exchange;
-            this.securityContext = securityContext;
-            this.sessionManager = sessionManager;
-        }
-
-        @Override
-        public void run() {
-            AuthenticatedSession authSession = sessionManager.lookupSession(exchange);
-            if (authSession != null) {
-                Account account = securityContext.getIdentityManager().verify(authSession.getAccount());
-                if (account != null) {
-                    // This is based on a previously cached account so re-use the mechanism and allow to be cached again.
-                    securityContext.authenticationComplete(account, authSession.getMechanism(), true);
-                    result.setResult(AuthenticationMechanismOutcome.AUTHENTICATED);
-                } else {
-                    // We know we had a previously authenticated account but for some reason the IdentityManager is no longer
-                    // accepting it, safer to mark as a failed authentication.
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                }
+    public AuthenticationMechanismOutcome runCached(final HttpServerExchange exchange, final SecurityContext securityContext, final AuthenticatedSessionManager sessionManager) {
+        AuthenticatedSession authSession = sessionManager.lookupSession(exchange);
+        if (authSession != null) {
+            Account account = securityContext.getIdentityManager().verify(authSession.getAccount());
+            if (account != null) {
+                // This is based on a previously cached account so re-use the mechanism and allow to be cached again.
+                securityContext.authenticationComplete(account, authSession.getMechanism(), true);
+                return AuthenticationMechanismOutcome.AUTHENTICATED;
             } else {
-                // It is possible an AuthenticatedSessionManager could have been available even if there was no chance of it
-                // loading a session.
-                result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
+                // We know we had a previously authenticated account but for some reason the IdentityManager is no longer
+                // accepting it, safer to mark as a failed authentication.
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
-
+        } else {
+            // It is possible an AuthenticatedSessionManager could have been available even if there was no chance of it
+            // loading a session.
+            return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
         }
 
     }
 
     @Override
-    public IoFuture<ChallengeResult> sendChallenge(HttpServerExchange exchange, SecurityContext securityContext,
-            Executor handOffExecutor) {
+    public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
         // This mechanism can only use what is already available and can not send a challenge of it's own.
-        ConcreteIoFuture<ChallengeResult> result = new ConcreteIoFuture<ChallengeResult>();
-        result.setResult(new ChallengeResult(false));
-
-        return result;
+        return new ChallengeResult(false);
     }
 
 }",2013-02-21T11:31:54Z,454
"@@ -17,24 +17,19 @@
  */
 package io.undertow.security.impl;
 
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.SecurityContext;
 import io.undertow.security.idm.Account;
 import io.undertow.security.idm.Credential;
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.security.idm.X509CertificateCredential;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.ConcreteIoFuture;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.concurrent.Executor;
-
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-
-import org.xnio.FinishedIoFuture;
-import org.xnio.IoFuture;
 
 /**
  * The Client Cert based authentication mechanism.
@@ -60,18 +55,16 @@ public String getName() {
         return name;
     }
 
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange exchange,
-            final SecurityContext securityContext, final Executor handOffExecutor) {
-        ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
+    public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
+                                                       final SecurityContext securityContext) {
 
         SSLSession sslSession = exchange.getConnection().getSslSession();
         if (sslSession != null) {
             try {
                 Certificate[] clientCerts = sslSession.getPeerCertificates();
                 if (clientCerts[0] instanceof X509Certificate) {
                     // Hand off to the executor as now we need an IDM based check.
-                    handOffExecutor.execute(new ClientCertRunnable(securityContext, result, (X509Certificate) clientCerts[0]));
-                    return result;
+                    return runClientCert(securityContext,  (X509Certificate) clientCerts[0]);
                 }
             } catch (SSLPeerUnverifiedException e) {
                 // No action - this mechanism can not attempt authentication without peer certificates so allow it to drop out
@@ -80,42 +73,27 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExc
         }
 
         // There was no SSLSession to verify or early verification failed.
-        result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
-        return result;
+        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
     }
 
-    private final class ClientCertRunnable implements Runnable {
-        private final SecurityContext securityContext;
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-        private final X509Certificate certificate;
-
-        private ClientCertRunnable(SecurityContext securityContext, ConcreteIoFuture<AuthenticationMechanismOutcome> result,
-                X509Certificate certificate) {
-            this.result = result;
-            this.securityContext = securityContext;
-            this.certificate = certificate;
-        }
-
-        public void run() {
-            Credential credential = new X509CertificateCredential(certificate);
-
-            IdentityManager idm = securityContext.getIdentityManager();
-            Account account = idm.verify(credential);
-            if (account != null) {
-                securityContext.authenticationComplete(account, getName(), false);
-                result.setResult(AuthenticationMechanismOutcome.AUTHENTICATED);
-            } else {
-                // TODO - Double check if we want NOT_AUTHENTICATED - this mechanism we may want to fail silently with
-                // NOT_ATTEMPTED as triggering a challenge will not help this mechanism and may inadvertently affect the others.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-            }
+    public AuthenticationMechanismOutcome runClientCert(final SecurityContext securityContext, final X509Certificate certificate) {
+        Credential credential = new X509CertificateCredential(certificate);
+
+        IdentityManager idm = securityContext.getIdentityManager();
+        Account account = idm.verify(credential);
+        if (account != null) {
+            securityContext.authenticationComplete(account, getName(), false);
+            return AuthenticationMechanismOutcome.AUTHENTICATED;
+        } else {
+            // TODO - Double check if we want NOT_AUTHENTICATED - this mechanism we may want to fail silently with
+            // NOT_ATTEMPTED as triggering a challenge will not help this mechanism and may inadvertently affect the others.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         }
     }
 
     @Override
-    public IoFuture<ChallengeResult> sendChallenge(HttpServerExchange exchange, SecurityContext securityContext,
-            Executor handOffExecutor) {
-        return new FinishedIoFuture<AuthenticationMechanism.ChallengeResult>(new ChallengeResult(false));
+    public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
+        return new ChallengeResult(false);
     }
 
 }",2013-02-21T11:31:54Z,219
"@@ -16,14 +16,16 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.UndertowLogger.REQUEST_LOGGER;
-import static io.undertow.security.impl.DigestAuthorizationToken.parseHeader;
-import static io.undertow.util.Headers.AUTHENTICATION_INFO;
-import static io.undertow.util.Headers.AUTHORIZATION;
-import static io.undertow.util.Headers.DIGEST;
-import static io.undertow.util.Headers.NEXT_NONCE;
-import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.NonceManager;
 import io.undertow.security.api.SecurityContext;
@@ -36,19 +38,14 @@
 import io.undertow.util.Headers;
 import io.undertow.util.HexConverter;
 
-import java.nio.charset.Charset;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.Executor;
-
-import org.xnio.FinishedIoFuture;
-import org.xnio.IoFuture;
+import static io.undertow.UndertowLogger.REQUEST_LOGGER;
+import static io.undertow.security.impl.DigestAuthorizationToken.parseHeader;
+import static io.undertow.util.Headers.AUTHENTICATION_INFO;
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.DIGEST;
+import static io.undertow.util.Headers.NEXT_NONCE;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static io.undertow.util.StatusCodes.CODE_401;
 
 /**
  * {@link io.undertow.server.HttpHandler} to handle HTTP Digest authentication, both according to RFC-2617 and draft update to allow additional
@@ -117,8 +114,8 @@ public String getName() {
         return null;
     }
 
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange exchange,
-            final SecurityContext securityContext, final Executor handOffExecutor) {
+    public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
+                                                       final SecurityContext securityContext) {
         ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
         List<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);
         if (authHeaders != null) {
@@ -133,11 +130,7 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExc
                         // Some form of Digest authentication is going to occur so get the DigestContext set on the exchange.
                         exchange.putAttachment(DigestContext.ATTACHMENT_KEY, context);
 
-                        handOffExecutor.execute(new DigestRunnable(result, exchange, securityContext));
-
-                        // The request has now potentially been dispatched to a different worker thread, the run method
-                        // within BasicRunnable is now responsible for ensuring the request continues.
-                        return result;
+                        return runDigest(exchange, securityContext);
                     } catch (Exception e) {
                         e.printStackTrace();
                     }
@@ -147,301 +140,273 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExc
                 // it was not correctly structured.
                 // By this point we had a header we should have been able to verify but for some reason
                 // it was not correctly structured.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return result;
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
         }
 
         // No suitable header has been found in this request,
-        result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
-        return result;
+        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
     }
 
     @Override
-    public IoFuture<ChallengeResult> sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext,
-            final Executor handOffExecutor) {
-            sendChallengeHeaders(exchange);
-            return new FinishedIoFuture<ChallengeResult>(new ChallengeResult(true, CODE_401));
+    public ChallengeResult sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext) {
+        sendChallengeHeaders(exchange);
+        return new ChallengeResult(true, CODE_401);
     }
 
-    private final class DigestRunnable implements Runnable {
 
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-        private final HttpServerExchange exchange;
-        private final DigestContext context;
-        private final Map<DigestAuthorizationToken, String> parsedHeader;
-        private final SecurityContext securityContext;
-        private MessageDigest digest;
+    public AuthenticationMechanismOutcome runDigest(HttpServerExchange exchange, final SecurityContext securityContext) {
+        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);
+        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();
+        // Step 1 - Verify the set of tokens received to ensure valid values.
+        Set<DigestAuthorizationToken> mandatoryTokens = new HashSet<DigestAuthorizationToken>(MANDATORY_REQUEST_TOKENS);
+        if (supportedAlgorithms.contains(DigestAlgorithm.MD5) == false) {
+            // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.
+            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);
+        }
+        if (supportedQops.isEmpty() == false && supportedQops.contains(DigestQop.AUTH) == false) {
+            // If we do not support auth then we are mandating auth-int so force the client to send a QOP
+            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);
+        }
+
+        DigestQop qop = null;
+        // This check is early as is increases the list of mandatory tokens.
+        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {
+            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
+            if (qop == null || supportedQops.contains(qop) == false) {
+                // We are also ensuring the client is not trying to force a qop that has been disabled.
+                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),
+                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
+                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+            }
+            context.setQop(qop);
+            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);
+            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);
+        }
+
+        // Check all mandatory tokens are present.
+        mandatoryTokens.removeAll(parsedHeader.keySet());
+        if (mandatoryTokens.size() > 0) {
+            for (DigestAuthorizationToken currentToken : mandatoryTokens) {
+                // TODO - Need a better check and possible concatenate the list of tokens - however
+                // even having one missing token is not something we should routinely expect.
+                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());
+            }
+            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-        private DigestRunnable(final ConcreteIoFuture<AuthenticationMechanismOutcome> result, HttpServerExchange exchange, final SecurityContext securityContext) {
-            this.result = result;
-            this.exchange = exchange;
-            context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);
-            this.parsedHeader = context.getParsedHeader();
-            this.securityContext = securityContext;
+        // Perform some validation of the remaining tokens.
+        if (realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM)) == false) {
+            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),
+                    parsedHeader.get(DigestAuthorizationToken.REALM));
+            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         }
 
-        public void run() {
-            // Step 1 - Verify the set of tokens received to ensure valid values.
-            Set<DigestAuthorizationToken> mandatoryTokens = new HashSet<DigestAuthorizationToken>(MANDATORY_REQUEST_TOKENS);
-            if (supportedAlgorithms.contains(DigestAlgorithm.MD5) == false) {
-                // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.
-                mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);
-            }
-            if (supportedQops.isEmpty() == false && supportedQops.contains(DigestQop.AUTH) == false) {
-                // If we do not support auth then we are mandating auth-int so force the client to send a QOP
-                mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);
-            }
+        // TODO - Validate the URI
 
-            DigestQop qop = null;
-            // This check is early as is increases the list of mandatory tokens.
-            if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {
-                qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
-                if (qop == null || supportedQops.contains(qop) == false) {
-                    // We are also ensuring the client is not trying to force a qop that has been disabled.
-                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),
-                            parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));
-                    // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return;
-                }
-                context.setQop(qop);
-                mandatoryTokens.add(DigestAuthorizationToken.CNONCE);
-                mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);
+        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {
+            if (OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE)) == false) {
+                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),
+                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
+        }
 
-            // Check all mandatory tokens are present.
-            mandatoryTokens.removeAll(parsedHeader.keySet());
-            if (mandatoryTokens.size() > 0) {
-                for (DigestAuthorizationToken currentToken : mandatoryTokens) {
-                    // TODO - Need a better check and possible concatenate the list of tokens - however
-                    // even having one missing token is not something we should routinely expect.
-                    REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());
-                }
+        DigestAlgorithm algorithm;
+        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {
+            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
+            if (algorithm == null || supportedAlgorithms.contains(algorithm) == false) {
+                // We are also ensuring the client is not trying to force an algorithm that has been disabled.
+                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),
+                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
                 // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
+        } else {
+            // We know this is safe as the algorithm token was made mandatory
+            // if MD5 is not supported.
+            algorithm = DigestAlgorithm.MD5;
+        }
+        MessageDigest digest = null;
+        // Step 2 - Based on the headers received verify that in theory the response is valid.
+        try {
+            digest = algorithm.getMessageDigest();
+            context.setDigest(digest);
+        } catch (NoSuchAlgorithmException e) {
+            // This is really not expected but the API makes us consider it.
+            REQUEST_LOGGER.exceptionProcessingRequest(e);
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-            // Perform some validation of the remaining tokens.
-            if (realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM)) == false) {
-                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),
-                        parsedHeader.get(DigestAuthorizationToken.REALM));
-                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
-            }
+        byte[] ha1;
 
-            // TODO - Validate the URI
 
-            if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {
-                if (OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE)) == false) {
-                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),
-                            parsedHeader.get(DigestAuthorizationToken.OPAQUE));
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return;
-                }
-            }
+        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);
+        final IdentityManager identityManager = securityContext.getIdentityManager();
+        final Account account = identityManager.getAccount(userName);
+        if (account == null) {
+            //the user does not exist.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-            DigestAlgorithm algorithm;
-            if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {
-                algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
-                if (algorithm == null || supportedAlgorithms.contains(algorithm) == false) {
-                    // We are also ensuring the client is not trying to force an algorithm that has been disabled.
-                    REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),
-                            parsedHeader.get(DigestAuthorizationToken.ALGORITHM));
-                    // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return;
-                }
+        // Step 2.1 Calculate H(A1)
+        try {
+            if (algorithm.isSession()) {
+                ha1 = lookupOrCreateSessionHA1(parsedHeader);
             } else {
-                // We know this is safe as the algorithm token was made mandatory
-                // if MD5 is not supported.
-                algorithm = DigestAlgorithm.MD5;
-            }
-
-            // Step 2 - Based on the headers received verify that in theory the response is valid.
-            try {
-                digest = algorithm.getMessageDigest();
-                context.setDigest(digest);
-            } catch (NoSuchAlgorithmException e) {
-                // This is really not expected but the API makes us consider it.
-                REQUEST_LOGGER.exceptionProcessingRequest(e);
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
+                // This is the most simple form of a hash involving the username, realm and password.
+                ha1 = createHA1(userName.getBytes(UTF_8), account, digest, securityContext);
             }
+            context.setHa1(ha1);
+        } catch (AuthenticationException e) {
+            // Most likely the user does not exist.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-            byte[] ha1;
-
-
-            final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);
-            final IdentityManager identityManager = securityContext.getIdentityManager();
-            final Account account = identityManager.getAccount(userName);
-            if (account == null) {
-                //the user does not exist.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
-            }
+        byte[] ha2;
+        // Step 2.2 Calculate H(A2)
+        if (qop == null || qop.equals(DigestQop.AUTH)) {
+            ha2 = createHA2Auth(exchange, digest, parsedHeader);
+        } else {
+            ha2 = createHA2AuthInt();
+        }
 
-            // Step 2.1 Calculate H(A1)
-            try {
-                if (algorithm.isSession()) {
-                    ha1 = lookupOrCreateSessionHA1(parsedHeader);
-                } else {
-                    // This is the most simple form of a hash involving the username, realm and password.
-                    ha1 = createHA1(userName.getBytes(UTF_8), account);
-                }
-                context.setHa1(ha1);
-            } catch (AuthenticationException e) {
-                // Most likely the user does not exist.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
-            }
+        byte[] requestDigest;
+        if (qop == null) {
+            requestDigest = createRFC2069RequestDigest(ha1, ha2, digest, parsedHeader);
+        } else {
+            requestDigest = createRFC2617RequestDigest(ha1, ha2, digest, parsedHeader);
+        }
 
-            byte[] ha2;
-            // Step 2.2 Calculate H(A2)
-            if (qop == null || qop.equals(DigestQop.AUTH)) {
-                ha2 = createHA2Auth();
-            } else {
-                ha2 = createHA2AuthInt();
-            }
+        byte[] providedResponse = parsedHeader.get(DigestAuthorizationToken.RESPONSE).getBytes(UTF_8);
+        if (MessageDigest.isEqual(requestDigest, providedResponse) == false) {
+            // TODO - We should look at still marking the nonce as used, a failure in authentication due to say a failure
+            // looking up the users password would leave it open to the packet being replayed.
+            REQUEST_LOGGER.authenticationFailed(parsedHeader.get(DigestAuthorizationToken.USERNAME), DIGEST.toString());
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-            byte[] requestDigest;
-            if (qop == null) {
-                requestDigest = createRFC2069RequestDigest(ha1, ha2);
-            } else {
-                requestDigest = createRFC2617RequestDigest(ha1, ha2);
-            }
+        // Step 3 - Verify that the nonce was eligible to be used.
+        if (validateNonceUse(context, parsedHeader, exchange) == false) {
+            // TODO - This is the right place to make use of the decision but the check needs to be much much sooner
+            // otherwise a failure server
+            // side could leave a packet that could be 're-played' after the failed auth.
+            // The username and password verification passed but for some reason we do not like the nonce.
+            context.markStale();
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
 
-            byte[] providedResponse = parsedHeader.get(DigestAuthorizationToken.RESPONSE).getBytes(UTF_8);
-            if (MessageDigest.isEqual(requestDigest, providedResponse) == false) {
-                // TODO - We should look at still marking the nonce as used, a failure in authentication due to say a failure
-                // looking up the users password would leave it open to the packet being replayed.
-                REQUEST_LOGGER.authenticationFailed(parsedHeader.get(DigestAuthorizationToken.USERNAME), DIGEST.toString());
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
-            }
+        // We have authenticated the remote user.
 
-            // Step 3 - Verify that the nonce was eligible to be used.
-            if (validateNonceUse() == false) {
-                // TODO - This is the right place to make use of the decision but the check needs to be much much sooner
-                // otherwise a failure server
-                // side could leave a packet that could be 're-played' after the failed auth.
-                // The username and password verification passed but for some reason we do not like the nonce.
-                context.markStale();
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
-            }
+        sendAuthenticationInfoHeader(exchange);
+        securityContext.authenticationComplete(account, getName(), false);
+        return AuthenticationMechanismOutcome.AUTHENTICATED;
 
-            // We have authenticated the remote user.
+        // Step 4 - Set up any QOP related requirements.
 
-            sendAuthenticationInfoHeader(exchange);
-            securityContext.authenticationComplete(account, getName(), false);
-            result.setResult(AuthenticationMechanismOutcome.AUTHENTICATED);
+        // TODO - Do QOP
+    }
 
-            // Step 4 - Set up any QOP related requirements.
+    private boolean validateNonceUse(DigestContext context, Map<DigestAuthorizationToken, String> parsedHeader, final HttpServerExchange exchange) {
+        String suppliedNonce = parsedHeader.get(DigestAuthorizationToken.NONCE);
+        int nonceCount = -1;
+        if (parsedHeader.containsKey(DigestAuthorizationToken.NONCE_COUNT)) {
+            String nonceCountHex = parsedHeader.get(DigestAuthorizationToken.NONCE_COUNT);
 
-            // TODO - Do QOP
+            nonceCount = Integer.parseInt(nonceCountHex, 16);
         }
 
-        private boolean validateNonceUse() {
-            String suppliedNonce = parsedHeader.get(DigestAuthorizationToken.NONCE);
-            int nonceCount = -1;
-            if (parsedHeader.containsKey(DigestAuthorizationToken.NONCE_COUNT)) {
-                String nonceCountHex = parsedHeader.get(DigestAuthorizationToken.NONCE_COUNT);
+        context.setNonce(suppliedNonce);
+        // TODO - A replay attempt will need an exception.
+        return (nonceManager.validateNonce(suppliedNonce, nonceCount, exchange));
+    }
 
-                nonceCount = Integer.parseInt(nonceCountHex, 16);
-            }
+    private byte[] createHA1(final byte[] userName, final Account account, final MessageDigest digest, final SecurityContext securityContext) throws AuthenticationException {
+        byte[] password = new String(securityContext.getIdentityManager().getPassword(account)).getBytes(UTF_8);
 
-            context.setNonce(suppliedNonce);
-            // TODO - A replay attempt will need an exception.
-            return (nonceManager.validateNonce(suppliedNonce, nonceCount, exchange));
+        try {
+            digest.update(userName);
+            digest.update(COLON);
+            digest.update(realmBytes);
+            digest.update(COLON);
+            digest.update(password);
+
+            return HexConverter.convertToHexBytes(digest.digest());
+        } finally {
+            digest.reset();
         }
+    }
 
-        private byte[] createHA1(final byte[] userName, final Account account) throws AuthenticationException {
-            byte[] password = new String(securityContext.getIdentityManager().getPassword(account)).getBytes(UTF_8);
+    private byte[] lookupOrCreateSessionHA1(final Map<DigestAuthorizationToken, String> parsedHeader) {
+        // TODO - Implement method.
+        throw new IllegalStateException(""Method not implemented."");
+    }
 
-            try {
-                digest.update(userName);
-                digest.update(COLON);
-                digest.update(realmBytes);
-                digest.update(COLON);
-                digest.update(password);
+    private byte[] createHA2Auth(final HttpServerExchange exchange, final MessageDigest digest, Map<DigestAuthorizationToken, String> parsedHeader) {
+        byte[] method = exchange.getRequestMethod().toString().getBytes(UTF_8);
+        byte[] digestUri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI).getBytes(UTF_8);
 
-                return HexConverter.convertToHexBytes(digest.digest());
-            } finally {
-                digest.reset();
-            }
-        }
+        try {
+            digest.update(method);
+            digest.update(COLON);
+            digest.update(digestUri);
 
-        private byte[] lookupOrCreateSessionHA1(final Map<DigestAuthorizationToken, String> parsedHeader) {
-            // TODO - Implement method.
-            throw new IllegalStateException(""Method not implemented."");
+            return HexConverter.convertToHexBytes(digest.digest());
+        } finally {
+            digest.reset();
         }
+    }
 
-        private byte[] createHA2Auth() {
-            byte[] method = exchange.getRequestMethod().toString().getBytes(UTF_8);
-            byte[] digestUri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI).getBytes(UTF_8);
+    private byte[] createHA2AuthInt() {
+        // TODO - Implement method.
+        throw new IllegalStateException(""Method not implemented."");
+    }
 
-            try {
-                digest.update(method);
-                digest.update(COLON);
-                digest.update(digestUri);
+    private byte[] createRFC2069RequestDigest(final byte[] ha1, final byte[] ha2, final MessageDigest digest, Map<DigestAuthorizationToken, String> parsedHeader) {
+        byte[] nonce = parsedHeader.get(DigestAuthorizationToken.NONCE).getBytes(UTF_8);
 
-                return HexConverter.convertToHexBytes(digest.digest());
-            } finally {
-                digest.reset();
-            }
-        }
+        try {
+            digest.update(ha1);
+            digest.update(COLON);
+            digest.update(nonce);
+            digest.update(COLON);
+            digest.update(ha2);
 
-        private byte[] createHA2AuthInt() {
-            // TODO - Implement method.
-            throw new IllegalStateException(""Method not implemented."");
+            return HexConverter.convertToHexBytes(digest.digest());
+        } finally {
+            digest.reset();
         }
+    }
 
-        private byte[] createRFC2069RequestDigest(final byte[] ha1, final byte[] ha2) {
-            byte[] nonce = parsedHeader.get(DigestAuthorizationToken.NONCE).getBytes(UTF_8);
-
-            try {
-                digest.update(ha1);
-                digest.update(COLON);
-                digest.update(nonce);
-                digest.update(COLON);
-                digest.update(ha2);
+    private byte[] createRFC2617RequestDigest(final byte[] ha1, final byte[] ha2, final MessageDigest digest, Map<DigestAuthorizationToken, String> parsedHeader) {
+        byte[] nonce = parsedHeader.get(DigestAuthorizationToken.NONCE).getBytes(UTF_8);
+        byte[] nonceCount = parsedHeader.get(DigestAuthorizationToken.NONCE_COUNT).getBytes(UTF_8);
+        byte[] cnonce = parsedHeader.get(DigestAuthorizationToken.CNONCE).getBytes(UTF_8);
+        byte[] qop = parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP).getBytes(UTF_8);
 
-                return HexConverter.convertToHexBytes(digest.digest());
-            } finally {
-                digest.reset();
-            }
-        }
+        try {
+            digest.update(ha1);
+            digest.update(COLON);
+            digest.update(nonce);
+            digest.update(COLON);
+            digest.update(nonceCount);
+            digest.update(COLON);
+            digest.update(cnonce);
+            digest.update(COLON);
+            digest.update(qop);
+            digest.update(COLON);
+            digest.update(ha2);
 
-        private byte[] createRFC2617RequestDigest(final byte[] ha1, final byte[] ha2) {
-            byte[] nonce = parsedHeader.get(DigestAuthorizationToken.NONCE).getBytes(UTF_8);
-            byte[] nonceCount = parsedHeader.get(DigestAuthorizationToken.NONCE_COUNT).getBytes(UTF_8);
-            byte[] cnonce = parsedHeader.get(DigestAuthorizationToken.CNONCE).getBytes(UTF_8);
-            byte[] qop = parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP).getBytes(UTF_8);
-
-            try {
-                digest.update(ha1);
-                digest.update(COLON);
-                digest.update(nonce);
-                digest.update(COLON);
-                digest.update(nonceCount);
-                digest.update(COLON);
-                digest.update(cnonce);
-                digest.update(COLON);
-                digest.update(qop);
-                digest.update(COLON);
-                digest.update(ha2);
-
-                return HexConverter.convertToHexBytes(digest.digest());
-            } finally {
-                digest.reset();
-            }
+            return HexConverter.convertToHexBytes(digest.digest());
+        } finally {
+            digest.reset();
         }
-
     }
 
+
     public void sendChallengeHeaders(final HttpServerExchange exchange) {
         DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);
         boolean stale = context == null ? false : context.isStale();
@@ -523,11 +488,6 @@ private byte[] createHA2Auth(final DigestContext context) {
         }
     }
 
-    private byte[] createHA2AuthInt() {
-        // TODO - Implement method.
-        throw new IllegalStateException(""Method not implemented."");
-    }
-
     // TODO - Get all digesting into a single wrapper of the MessageDigest.
     private String createRFC2617RequestDigest(final byte[] ha1, final byte[] ha2, final DigestContext context) {
         Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();",2013-02-21T11:31:54Z,59
"@@ -17,7 +17,9 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.util.StatusCodes.CODE_307;
+import java.io.IOException;
+import java.util.Map;
+
 import io.undertow.UndertowLogger;
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.SecurityContext;
@@ -34,12 +36,7 @@
 import io.undertow.util.Headers;
 import io.undertow.util.Methods;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.concurrent.Executor;
-
-import org.xnio.FinishedIoFuture;
-import org.xnio.IoFuture;
+import static io.undertow.util.StatusCodes.CODE_307;
 
 /**
  * @author Stuart Douglas
@@ -68,100 +65,81 @@ public FormAuthenticationMechanism(final String name, final String loginPage, fi
     }
 
     @Override
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange exchange,
-            final SecurityContext securityContext, final Executor handOffExecutor) {
+    public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
+                                                       final SecurityContext securityContext) {
         if (exchange.getRequestURI().endsWith(postLocation) && exchange.getRequestMethod().equals(Methods.POST)) {
             ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
-            handOffExecutor.execute(new FormAuthRunnable(exchange, securityContext, result));
-            return result;
+            return runFormAuth(exchange, securityContext);
         } else {
-            return new FinishedIoFuture<AuthenticationMechanismOutcome>(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
+            return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
         }
     }
 
-
-    private class FormAuthRunnable implements Runnable {
-        final HttpServerExchange exchange;
-        final SecurityContext securityContext;
-        final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-
-        private FormAuthRunnable(final HttpServerExchange exchange, final SecurityContext securityContext, final ConcreteIoFuture<AuthenticationMechanismOutcome> result) {
-            this.exchange = exchange;
-            this.securityContext = securityContext;
-            this.result = result;
+    public AuthenticationMechanismOutcome runFormAuth(final HttpServerExchange exchange, final SecurityContext securityContext) {
+        final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
+        if (parser == null) {
+            UndertowLogger.REQUEST_LOGGER.debug(""Could not authenticate as no form parser is present"");
+            // TODO - May need a better error signaling mechanism here to prevent repeated attempts.
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         }
 
-
-        @Override
-        public void run() {
-            final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
-            if (parser == null) {
-                UndertowLogger.REQUEST_LOGGER.debug(""Could not authenticate as no form parser is present"");
-                // TODO - May need a better error signaling mechanism here to prevent repeated attempts.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                return;
+        try {
+            final FormData data = parser.parse().get();
+            final FormData.FormValue jUsername = data.getFirst(""j_username"");
+            final FormData.FormValue jPassword = data.getFirst(""j_password"");
+            if (jUsername == null || jPassword == null) {
+                UndertowLogger.REQUEST_LOGGER.debug(""Could not authenticate as username or password was not present in the posted result"");
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
-
+            final String userName = jUsername.getValue();
+            final String password = jPassword.getValue();
+            AuthenticationMechanismOutcome outcome = null;
+            PasswordCredential credential = new PasswordCredential(password.toCharArray());
             try {
-                final FormData data = parser.parse().get();
-                final FormData.FormValue jUsername = data.getFirst(""j_username"");
-                final FormData.FormValue jPassword = data.getFirst(""j_password"");
-                if (jUsername == null || jPassword == null) {
-                    UndertowLogger.REQUEST_LOGGER.debug(""Could not authenticate as username or password was not present in the posted result"");
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return;
+                IdentityManager identityManager = securityContext.getIdentityManager();
+                Account account = identityManager.verify(userName, credential);
+                if (account != null) {
+                    securityContext.authenticationComplete(account, name, true);
+                    outcome = AuthenticationMechanismOutcome.AUTHENTICATED;
                 }
-                final String userName = jUsername.getValue();
-                final String password = jPassword.getValue();
-                AuthenticationMechanismOutcome outcome = null;
-                PasswordCredential credential = new PasswordCredential(password.toCharArray());
-                try {
-                    IdentityManager identityManager = securityContext.getIdentityManager();
-                    Account account = identityManager.verify(userName, credential);
-                    if (account != null) {
-                        securityContext.authenticationComplete(account, name, true);
-                        outcome = AuthenticationMechanismOutcome.AUTHENTICATED;
-                    }
-                } finally {
-                    if (outcome == AuthenticationMechanismOutcome.AUTHENTICATED) {
-                        final Map<String, Cookie> cookies = CookieImpl.getRequestCookies(exchange);
-                        if (cookies != null && cookies.containsKey(LOCATION_COOKIE)) {
-                            final String location = cookies.get(LOCATION_COOKIE).getValue();
-                            exchange.addDefaultResponseListener(new DefaultResponseListener() {
-                                @Override
-                                public boolean handleDefaultResponse(final HttpServerExchange exchange) {
-                                    FormAuthenticationMechanism.sendRedirect(exchange, location);
-                                    exchange.endExchange();
-                                    return true;
-                                }
-                            });
-
-                            final CookieImpl cookie = new CookieImpl(LOCATION_COOKIE);
-                            cookie.setMaxAge(0);
-                            CookieImpl.addResponseCookie(exchange, cookie);
-                        }
+            } finally {
+                if (outcome == AuthenticationMechanismOutcome.AUTHENTICATED) {
+                    final Map<String, Cookie> cookies = CookieImpl.getRequestCookies(exchange);
+                    if (cookies != null && cookies.containsKey(LOCATION_COOKIE)) {
+                        final String location = cookies.get(LOCATION_COOKIE).getValue();
+                        exchange.addDefaultResponseListener(new DefaultResponseListener() {
+                            @Override
+                            public boolean handleDefaultResponse(final HttpServerExchange exchange) {
+                                FormAuthenticationMechanism.sendRedirect(exchange, location);
+                                exchange.endExchange();
+                                return true;
+                            }
+                        });
+
+                        final CookieImpl cookie = new CookieImpl(LOCATION_COOKIE);
+                        cookie.setMaxAge(0);
+                        CookieImpl.addResponseCookie(exchange, cookie);
                     }
-                    this.result.setResult(outcome != null ? outcome : AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
                 }
-            } catch (IOException e) {
-                result.setException(e);
+                return outcome != null ? outcome : AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
     }
 
-    public IoFuture<ChallengeResult> sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext,
-            final Executor handOffExecutor) {
+    public ChallengeResult sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext) {
         if (exchange.getRequestURI().endsWith(postLocation) && exchange.getRequestMethod().equals(Methods.POST)) {
             // This method would no longer be called if authentication had already occurred.
             sendRedirect(exchange, errorPage);
-            return new FinishedIoFuture<ChallengeResult>(new ChallengeResult(true, CODE_307));
+            return new ChallengeResult(true, CODE_307);
         } else {
             // we need to store the URL
             CookieImpl.addResponseCookie(exchange, new CookieImpl(LOCATION_COOKIE, exchange.getRequestURI()));
             // TODO - Rather than redirecting, in order to make this mechanism compatible with the other mechanisms we need to
             // return the actual error page not a redirect.
             sendRedirect(exchange, loginPage);
-            return new FinishedIoFuture<ChallengeResult>(new ChallengeResult(true, CODE_307));
+            return new ChallengeResult(true, CODE_307);
         }
     }
 ",2013-02-21T11:31:54Z,148
"@@ -17,41 +17,37 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.util.Headers.AUTHORIZATION;
-import static io.undertow.util.Headers.HOST;
-import static io.undertow.util.Headers.NEGOTIATE;
-import static io.undertow.util.Headers.WWW_AUTHENTICATE;
-import static io.undertow.util.StatusCodes.CODE_401;
-import io.undertow.security.api.AuthenticationMechanism;
-import io.undertow.security.api.GSSAPIServerSubjectFactory;
-import io.undertow.security.api.SecurityContext;
-import io.undertow.security.idm.Account;
-import io.undertow.security.idm.GSSContextCredential;
-import io.undertow.security.idm.IdentityManager;
-import io.undertow.server.HttpServerConnection;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.util.AttachmentKey;
-import io.undertow.util.ConcreteIoFuture;
-import io.undertow.util.FlexBase64;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.security.GeneralSecurityException;
 import java.security.Principal;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.List;
-import java.util.concurrent.Executor;
 
 import javax.security.auth.Subject;
 import javax.security.auth.kerberos.KerberosPrincipal;
 
+import io.undertow.security.api.AuthenticationMechanism;
+import io.undertow.security.api.GSSAPIServerSubjectFactory;
+import io.undertow.security.api.SecurityContext;
+import io.undertow.security.idm.Account;
+import io.undertow.security.idm.GSSContextCredential;
+import io.undertow.security.idm.IdentityManager;
+import io.undertow.server.HttpServerConnection;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.AttachmentKey;
+import io.undertow.util.FlexBase64;
 import org.ietf.jgss.GSSContext;
 import org.ietf.jgss.GSSCredential;
 import org.ietf.jgss.GSSException;
 import org.ietf.jgss.GSSManager;
-import org.xnio.FinishedIoFuture;
-import org.xnio.IoFuture;
+
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.HOST;
+import static io.undertow.util.Headers.NEGOTIATE;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static io.undertow.util.StatusCodes.CODE_401;
 
 /**
  * {@link io.undertow.security.api.AuthenticationMechanism} for GSSAPI / SPNEGO based authentication.
@@ -80,9 +76,8 @@ public String getName() {
     }
 
     @Override
-    public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExchange exchange,
-            final SecurityContext securityContext, final Executor handOffExecutor) {
-        ConcreteIoFuture<AuthenticationMechanismOutcome> result = new ConcreteIoFuture<AuthenticationMechanismOutcome>();
+    public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
+                                                       final SecurityContext securityContext) {
         HttpServerConnection connection = exchange.getConnection();
         NegotiationContext negContext = connection.getAttachment(NegotiationContext.ATTACHMENT_KEY);
         if (negContext != null) {
@@ -92,9 +87,9 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExc
                 final Account account = identityManager.verify(new GSSContextCredential(negContext.getGssContext()));
                 if (account != null) {
                     securityContext.authenticationComplete(account, getName(), false);
-                    result.setResult(AuthenticationMechanismOutcome.AUTHENTICATED);
+                    return AuthenticationMechanismOutcome.AUTHENTICATED;
                 } else {
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
+                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
                 }
             }
         }
@@ -106,28 +101,22 @@ public IoFuture<AuthenticationMechanismOutcome> authenticate(final HttpServerExc
                     String base64Challenge = current.substring(NEGOTIATE_PREFIX.length());
                     try {
                         ByteBuffer challenge = FlexBase64.decode(base64Challenge);
-                        handOffExecutor.execute(new GSSAPIRunnable(result, exchange, challenge, securityContext));
-                        // The request has now potentially been dispatched to a different worker thread, the run method
-                        // within GSSAPIRunnable is now responsible for ensuring the request continues.
-                        return result;
+                        return runGSSAPI(exchange, challenge, securityContext);
                     } catch (IOException e) {
                     }
 
                     // By this point we had a header we should have been able to verify but for some reason
                     // it was not correctly structured.
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                    return result;
+                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
                 }
             }
         }
 
         // No suitable header was found so authentication was not even attempted.
-        result.setResult(AuthenticationMechanismOutcome.NOT_ATTEMPTED);
-        return result;
+        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
     }
 
-    public IoFuture<ChallengeResult> sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext,
-            final Executor handOffExecutor) {
+    public ChallengeResult sendChallenge(final HttpServerExchange exchange, final SecurityContext securityContext) {
         NegotiationContext negContext = exchange.getAttachment(NegotiationContext.ATTACHMENT_KEY);
 
         String header = NEGOTIATION_PLAIN;
@@ -142,7 +131,23 @@ public IoFuture<ChallengeResult> sendChallenge(final HttpServerExchange exchange
 
         exchange.getResponseHeaders().add(WWW_AUTHENTICATE, header);
 
-        return new FinishedIoFuture<ChallengeResult>(new ChallengeResult(true, CODE_401));
+        return new ChallengeResult(true, CODE_401);
+    }
+
+
+    public AuthenticationMechanismOutcome runGSSAPI(final HttpServerExchange exchange,
+                                                    final ByteBuffer challenge, final SecurityContext securityContext) {
+        try {
+            Subject server = subjectFactory.getSubjectForHost(getHostName(exchange));
+            // The AcceptSecurityContext takes over responsibility for setting the result.
+            return Subject.doAs(server, new AcceptSecurityContext(exchange, challenge, securityContext));
+        } catch (GeneralSecurityException e) {
+            e.printStackTrace();
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        } catch (PrivilegedActionException e) {
+            e.printStackTrace();
+            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
+        }
     }
 
     private String getHostName(final HttpServerExchange exchange) {
@@ -157,53 +162,21 @@ private String getHostName(final HttpServerExchange exchange) {
         return null;
     }
 
-    private final class GSSAPIRunnable implements Runnable {
-
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
-        private final HttpServerExchange exchange;
-        private final ByteBuffer challenge;
-        private final SecurityContext securityContext;
-
-        private GSSAPIRunnable(final ConcreteIoFuture<AuthenticationMechanismOutcome> result, final HttpServerExchange exchange,
-                               final ByteBuffer challenge, final SecurityContext securityContext) {
-            this.result = result;
-            this.exchange = exchange;
-            this.challenge = challenge;
-            this.securityContext = securityContext;
-        }
 
-        public void run() {
-            try {
-                Subject server = subjectFactory.getSubjectForHost(getHostName(exchange));
-                // The AcceptSecurityContext takes over responsibility for setting the result.
-                Subject.doAs(server, new AcceptSecurityContext(result, exchange, challenge, securityContext));
-            } catch (GeneralSecurityException e) {
-                e.printStackTrace();
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-            } catch (PrivilegedActionException e) {
-                e.printStackTrace();
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-            }
-        }
+    private class AcceptSecurityContext implements PrivilegedExceptionAction<AuthenticationMechanismOutcome> {
 
-    }
-
-    private class AcceptSecurityContext implements PrivilegedExceptionAction<Void> {
-
-        private final ConcreteIoFuture<AuthenticationMechanismOutcome> result;
         private final HttpServerExchange exchange;
         private final ByteBuffer challenge;
         private final SecurityContext securityContext;
 
-        private AcceptSecurityContext(final ConcreteIoFuture<AuthenticationMechanismOutcome> result, final HttpServerExchange exchange,
+        private AcceptSecurityContext(final HttpServerExchange exchange,
                                       final ByteBuffer challenge, final SecurityContext securityContext) {
-            this.result = result;
             this.exchange = exchange;
             this.challenge = challenge;
             this.securityContext = securityContext;
         }
 
-        public Void run() throws GSSException {
+        public AuthenticationMechanismOutcome run() throws GSSException {
             NegotiationContext negContext = exchange.getAttachment(NegotiationContext.ATTACHMENT_KEY);
             if (negContext == null) {
                 negContext = new NegotiationContext();
@@ -224,25 +197,24 @@ public Void run() throws GSSException {
             negContext.setResponseToken(respToken);
 
             if (negContext.isEstablished()) {
+
+                if (respToken != null) {
+                    // There will be no further challenge but we do have a token so set it here.
+                    exchange.getResponseHeaders().add(WWW_AUTHENTICATE,
+                            NEGOTIATE_PREFIX + FlexBase64.encodeString(respToken, false));
+                }
                 IdentityManager identityManager = securityContext.getIdentityManager();
                 final Account account = identityManager.verify(new GSSContextCredential(negContext.getGssContext()));
                 if (account != null) {
                     securityContext.authenticationComplete(account, getName(), false);
-                    result.setResult(AuthenticationMechanismOutcome.AUTHENTICATED);
+                    return AuthenticationMechanismOutcome.AUTHENTICATED;
                 } else {
-                    result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
-                }
-                if (respToken != null) {
-                    // There will be no further challenge but we do have a token so set it here.
-                    exchange.getResponseHeaders().add(WWW_AUTHENTICATE,
-                            NEGOTIATE_PREFIX + FlexBase64.encodeString(respToken, false));
+                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
                 }
             } else {
                 // This isn't a failure but as the context is not established another round trip with the client is needed.
-                result.setResult(AuthenticationMechanismOutcome.NOT_AUTHENTICATED);
+                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
-
-            return null;
         }
     }
 ",2013-02-21T11:31:54Z,17
"@@ -17,9 +17,13 @@
  */
 package io.undertow.security.impl;
 
-import static io.undertow.UndertowMessages.MESSAGES;
-import static io.undertow.util.StatusCodes.CODE_200;
-import static io.undertow.util.StatusCodes.CODE_403;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
 import io.undertow.security.api.AuthenticationMechanism;
 import io.undertow.security.api.AuthenticationMechanism.AuthenticationMechanismOutcome;
 import io.undertow.security.api.AuthenticationMechanism.ChallengeResult;
@@ -31,21 +35,11 @@
 import io.undertow.security.idm.IdentityManager;
 import io.undertow.security.idm.PasswordCredential;
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.ConcreteIoFuture;
 import io.undertow.util.StatusCodes;
-import io.undertow.util.WorkerDispatcher;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.Executor;
 
-import org.xnio.IoFuture;
-import org.xnio.IoFuture.Notifier;
+import static io.undertow.UndertowMessages.MESSAGES;
+import static io.undertow.util.StatusCodes.CODE_200;
+import static io.undertow.util.StatusCodes.CODE_403;
 
 /**
  * The internal SecurityContext used to hold the state of security for the current exchange.
@@ -98,70 +92,48 @@ public SecurityContextImpl(final HttpServerExchange exchange, final Authenticati
      * CHALLENGED_SENT
      */
 
-    public IoFuture<Boolean> authenticate() {
-        ConcreteIoFuture<Boolean> result = new ConcreteIoFuture<Boolean>();
+    public boolean authenticate() {
         // TODO - I don't see a need to force single threaded - if this request is from the servlet APIs then the request will
         // have already been dispatched.
-        authTransition(result);
-
-        return result;
+        return !authTransition();
     }
 
-    private void authTransition(final ConcreteIoFuture<Boolean> result) {
+    private boolean authTransition() {
         if (authTransitionRequired()) {
-            IoFuture<AuthenticationState> transitionResult = null;
             switch (authenticationState) {
                 case NOT_ATTEMPTED:
-                    transitionResult = attemptAuthentication();
+                    authenticationState = attemptAuthentication();
                     break;
                 case ATTEMPTED:
-                    transitionResult = sendChallenges();
+                    authenticationState = sendChallenges();
                     break;
                 default:
                     throw new IllegalStateException(""It should not be possible to reach this."");
             }
-            transitionResult.addNotifier(new Notifier<AuthenticationState, Object>() {
-
-                @Override
-                public void notify(IoFuture<? extends AuthenticationState> ioFuture, Object attachment) {
-                    // TODO - Could result contain an Exception?
-                    try {
-                        authenticationState = ioFuture.get();
-                    } catch (IOException e) {
-                        // TODO - Need a failure state I think to transition to.
-                    }
-                    authTransition(result);
-                }
-            }, null);
+            return authTransition();
 
         } else {
             // Keep in mind this switch statement is only called after a call to authTransitionRequired.
             switch (authenticationState) {
                 case NOT_ATTEMPTED: // No constraint was set that mandated authentication so not reason to hold up the request.
                 case ATTEMPTED: // Attempted based on incoming request but no a failure so allow the request to proceed.
                 case AUTHENITCATED: // Authentication was a success - no responses sent.
-                    result.setResult(false);
+                    return false;
                 default:
                     // Remaining option is CHALLENGE_SENT to request processing must end.
-                    result.setResult(true);
+                    return true;
             }
         }
     }
 
-    private IoFuture<AuthenticationState> attemptAuthentication() {
-        ConcreteIoFuture<AuthenticationState> response = new ConcreteIoFuture<AuthenticationState>();
-
-        new AuthAttempter(authMechanisms.iterator(), exchange, new WorkerDispatcherExecutor(exchange)).transition(response);
-
-        return response;
+    private AuthenticationState attemptAuthentication() {
+        return new AuthAttempter(authMechanisms.iterator(), exchange).transition();
     }
 
-    private IoFuture<AuthenticationState> sendChallenges() {
-        ConcreteIoFuture<AuthenticationState> response = new ConcreteIoFuture<AuthenticationState>();
+    private AuthenticationState sendChallenges() {
 
-        new ChallengeSender(authMechanisms.iterator(), exchange, new WorkerDispatcherExecutor(exchange)).transition(response);
+        return new ChallengeSender(authMechanisms.iterator(), exchange).transition();
 
-        return response;
     }
 
     private boolean authTransitionRequired() {
@@ -278,53 +250,36 @@ private class AuthAttempter {
 
         private final Iterator<AuthenticationMechanism> mechanismIterator;
         private final HttpServerExchange exchange;
-        private final Executor handOffExecutor;
 
-        private AuthAttempter(final Iterator<AuthenticationMechanism> mechanismIterator, final HttpServerExchange exchange,
-                final Executor handOffExecutor) {
+        private AuthAttempter(final Iterator<AuthenticationMechanism> mechanismIterator, final HttpServerExchange exchange) {
             this.mechanismIterator = mechanismIterator;
             this.exchange = exchange;
-            this.handOffExecutor = handOffExecutor;
         }
 
-        private void transition(final ConcreteIoFuture<AuthenticationState> authenticationState) {
+        private AuthenticationState transition() {
             if (mechanismIterator.hasNext()) {
                 final AuthenticationMechanism mechanism = mechanismIterator.next();
-                IoFuture<AuthenticationMechanismOutcome> mechanismResult = mechanism.authenticate(exchange,
-                        SecurityContextImpl.this, handOffExecutor);
-                mechanismResult.addNotifier(new Notifier<AuthenticationMechanismOutcome, Object>() {
-
-                    @Override
-                    public void notify(IoFuture<? extends AuthenticationMechanismOutcome> ioFuture, Object attachment) {
-                        try {
-                            AuthenticationMechanismOutcome outcome = ioFuture.get();
-                            switch (outcome) {
-                                case AUTHENTICATED:
-                                    // TODO - Should verify that the mechanism did register an authenticated Account.
-                                    authenticationState.setResult(AuthenticationState.AUTHENITCATED);
-                                    break;
-                                case NOT_AUTHENTICATED:
-                                    // A mechanism attempted to authenticate but could not complete, this now means that
-                                    // authentication is required and challenges need to be sent.
-                                    setAuthenticationRequired();
-                                    authenticationState.setResult(AuthenticationState.ATTEMPTED);
-                                    break;
-                                case NOT_ATTEMPTED:
-                                    // Time to try the next mechanism.
-                                    transition(authenticationState);
-                                    break;
-                            }
-                        } catch (IOException e) {
-                            // TODO - Something internal failed, probably want to to add a possible error state.
-                            authenticationState.setResult(AuthenticationState.ATTEMPTED);
-                        }
-
-                    }
-                }, null);
+                AuthenticationMechanismOutcome outcome = mechanism.authenticate(exchange, SecurityContextImpl.this);
+
+                switch (outcome) {
+                    case AUTHENTICATED:
+                        // TODO - Should verify that the mechanism did register an authenticated Account.
+                        return AuthenticationState.AUTHENITCATED;
+                    case NOT_AUTHENTICATED:
+                        // A mechanism attempted to authenticate but could not complete, this now means that
+                        // authentication is required and challenges need to be sent.
+                        setAuthenticationRequired();
+                        return AuthenticationState.ATTEMPTED;
+                    case NOT_ATTEMPTED:
+                        // Time to try the next mechanism.
+                        return transition();
+                    default:
+                        throw new IllegalStateException();
+                }
 
             } else {
                 // Reached the end of the mechanisms and no mechanism authenticated for us to reach this point.
-                authenticationState.setResult(AuthenticationState.ATTEMPTED);
+                return AuthenticationState.ATTEMPTED;
             }
         }
 
@@ -337,51 +292,38 @@ private class ChallengeSender {
 
         private final Iterator<AuthenticationMechanism> mechanismIterator;
         private final HttpServerExchange exchange;
-        private final Executor handOffExecutor;
 
         private boolean atLeastOneChallenge = false;
         private StatusCodes chosenStatusCode = null;
 
-        private ChallengeSender(final Iterator<AuthenticationMechanism> mechanismIterator, final HttpServerExchange exchange,
-                final Executor handOffExecutor) {
+        private ChallengeSender(final Iterator<AuthenticationMechanism> mechanismIterator, final HttpServerExchange exchange) {
             this.mechanismIterator = mechanismIterator;
             this.exchange = exchange;
-            this.handOffExecutor = handOffExecutor;
         }
 
-        private void transition(final ConcreteIoFuture<AuthenticationState> authenticationState) {
+        private AuthenticationState transition() {
             if (mechanismIterator.hasNext()) {
                 final AuthenticationMechanism mechanism = mechanismIterator.next();
-                IoFuture<ChallengeResult> challengeResult = mechanism.sendChallenge(exchange, SecurityContextImpl.this,
-                        handOffExecutor);
-                challengeResult.addNotifier(new Notifier<ChallengeResult, Object>() {
-
-                    @Override
-                    public void notify(IoFuture<? extends ChallengeResult> ioFuture, Object attachment) {
-                        try {
-                            ChallengeResult result = ioFuture.get();
-                            if (result.isChallengeSent()) {
-                                atLeastOneChallenge = true;
-                                StatusCodes desiredCode = result.getDesiredResponseCode();
-                                if (chosenStatusCode == null) {
-                                    chosenStatusCode = desiredCode;
-                                } else if (desiredCode != null) {
-                                    if (chosenStatusCode.equals(CODE_200)) {
-                                        // Allows a more specific code to be chosen.
-                                        // TODO - Still need a more complex code resolution strategy if many different codes are
-                                        // returned (Although those mechanisms may just never work together.)
-                                        chosenStatusCode = desiredCode;
-                                    }
-                                }
-                            }
-                        } catch (IOException e) {
-                            // TODO - Something about the exception - only sending a challenge at this point.
+                ChallengeResult result = mechanism.sendChallenge(exchange, SecurityContextImpl.this);
+
+                if (result.isChallengeSent()) {
+                    atLeastOneChallenge = true;
+                    StatusCodes desiredCode = result.getDesiredResponseCode();
+                    if (chosenStatusCode == null) {
+                        chosenStatusCode = desiredCode;
+                    } else if (desiredCode != null) {
+                        if (chosenStatusCode.equals(CODE_200)) {
+                            // Allows a more specific code to be chosen.
+                            // TODO - Still need a more complex code resolution strategy if many different codes are
+                            // returned (Although those mechanisms may just never work together.)
+                            chosenStatusCode = desiredCode;
                         }
-
-                        // We always transition so we can reach the end of the list and hit the else.
-                        transition(authenticationState);
                     }
-                }, null);
+                }
+
+
+                // We always transition so we can reach the end of the list and hit the else.
+                return transition();
 
             } else {
                 // Iterated all mechanisms, now need to select a suitable status code.
@@ -394,7 +336,7 @@ public void notify(IoFuture<? extends ChallengeResult> ioFuture, Object attachme
                     exchange.setResponseCode(CODE_403.getCode());
                 }
 
-                authenticationState.setResult(AuthenticationState.CHALLENGE_SENT);
+                return AuthenticationState.CHALLENGE_SENT;
 
             }
         }
@@ -405,29 +347,13 @@ public void notify(IoFuture<? extends ChallengeResult> ioFuture, Object attachme
      * Representation of the current authentication state of the SecurityContext.
      */
     enum AuthenticationState {
-      NOT_ATTEMPTED,
+        NOT_ATTEMPTED,
 
-      ATTEMPTED,
+        ATTEMPTED,
 
-      AUTHENITCATED,
+        AUTHENITCATED,
 
-      CHALLENGE_SENT;
+        CHALLENGE_SENT;
     }
 
-    private static final class WorkerDispatcherExecutor implements Executor {
-
-        private final HttpServerExchange exchange;
-
-        private WorkerDispatcherExecutor(final HttpServerExchange exchange) {
-            this.exchange = exchange;
-        }
-
-        @Override
-        public void execute(final Runnable command) {
-            WorkerDispatcher.dispatch(exchange, command);
-        }
-    }
-
-
-
 }",2013-02-21T11:31:54Z,56
"@@ -18,31 +18,6 @@
 
 package io.undertow.servlet.spec;
 
-import io.undertow.security.api.RoleMappingManager;
-import io.undertow.security.api.SecurityContext;
-import io.undertow.security.idm.Account;
-import io.undertow.server.HttpServerExchange;
-import io.undertow.server.handlers.CookieImpl;
-import io.undertow.server.handlers.form.FormData;
-import io.undertow.server.handlers.form.FormDataParser;
-import io.undertow.server.handlers.form.MultiPartHandler;
-import io.undertow.servlet.UndertowServletLogger;
-import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.api.SecurityRoleRef;
-import io.undertow.servlet.handlers.ServletAttachments;
-import io.undertow.servlet.handlers.ServletPathMatch;
-import io.undertow.servlet.util.EmptyEnumeration;
-import io.undertow.servlet.util.IteratorEnumeration;
-import io.undertow.util.AttachmentKey;
-import io.undertow.util.CanonicalPathUtils;
-import io.undertow.util.DateUtils;
-import io.undertow.util.HeaderMap;
-import io.undertow.util.Headers;
-import io.undertow.util.HttpString;
-import io.undertow.util.LocaleUtils;
-import io.undertow.util.Methods;
-import io.undertow.util.QValueParser;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -84,7 +59,30 @@
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.Part;
 
-import org.xnio.IoFuture;
+import io.undertow.security.api.RoleMappingManager;
+import io.undertow.security.api.SecurityContext;
+import io.undertow.security.idm.Account;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.CookieImpl;
+import io.undertow.server.handlers.form.FormData;
+import io.undertow.server.handlers.form.FormDataParser;
+import io.undertow.server.handlers.form.MultiPartHandler;
+import io.undertow.servlet.UndertowServletLogger;
+import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.servlet.api.SecurityRoleRef;
+import io.undertow.servlet.handlers.ServletAttachments;
+import io.undertow.servlet.handlers.ServletPathMatch;
+import io.undertow.servlet.util.EmptyEnumeration;
+import io.undertow.servlet.util.IteratorEnumeration;
+import io.undertow.util.AttachmentKey;
+import io.undertow.util.CanonicalPathUtils;
+import io.undertow.util.DateUtils;
+import io.undertow.util.HeaderMap;
+import io.undertow.util.Headers;
+import io.undertow.util.HttpString;
+import io.undertow.util.LocaleUtils;
+import io.undertow.util.Methods;
+import io.undertow.util.QValueParser;
 import org.xnio.LocalSocketAddress;
 import org.xnio.streams.ChannelInputStream;
 
@@ -349,19 +347,17 @@ public boolean authenticate(final HttpServletResponse response) throws IOExcepti
         sc.setAuthenticationRequired();
         // TODO: this will set the status code and headers without going through any potential
         // wrappers, is this a problem?
-        IoFuture<Boolean> result = sc.authenticate();
-        if (result.get()) {
-            // Not authenticated and response already sent.
-            HttpServletResponseImpl responseImpl = HttpServletResponseImpl.getResponseImpl(response);
-            responseImpl.closeStreamAndWriter();
-            return false;
-        } else {
+        if (sc.authenticate()) {
             if (sc.isAuthenticated()) {
                 return true;
             } else {
                 throw UndertowServletMessages.MESSAGES.authenticationFailed();
             }
-
+        } else {
+            // Not authenticated and response already sent.
+            HttpServletResponseImpl responseImpl = HttpServletResponseImpl.getResponseImpl(response);
+            responseImpl.closeStreamAndWriter();
+            return false;
         }
     }
 ",2013-02-21T11:31:54Z,147
"@@ -41,36 +41,17 @@ public class FilterRegistrationImpl implements FilterRegistration, FilterRegistr
 
     private final FilterInfo filterInfo;
     private final Deployment deployment;
+    private final ServletContextImpl servletContext;
 
-    public FilterRegistrationImpl(final FilterInfo filterInfo, final Deployment deployment) {
+    public FilterRegistrationImpl(final FilterInfo filterInfo, final Deployment deployment, ServletContextImpl servletContext) {
         this.filterInfo = filterInfo;
         this.deployment = deployment;
+        this.servletContext = servletContext;
     }
 
     @Override
     public void addMappingForServletNames(final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... servletNames) {
-        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
-
-        for(final String servlet : servletNames){
-            if(isMatchAfter) {
-                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
-                    deploymentInfo.addFilterServletNameMapping(filterInfo.getName(), servlet, DispatcherType.REQUEST);
-                } else {
-                    for(final DispatcherType dispatcher : dispatcherTypes) {
-                        deploymentInfo.addFilterServletNameMapping(filterInfo.getName(), servlet, dispatcher);
-                    }
-                }
-            } else {
-                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
-                    deploymentInfo.insertFilterServletNameMapping(0, filterInfo.getName(), servlet, DispatcherType.REQUEST);
-                } else {
-                    for(final DispatcherType dispatcher : dispatcherTypes) {
-                        deploymentInfo.insertFilterServletNameMapping(0, filterInfo.getName(), servlet, dispatcher);
-                    }
-                }
-            }
-        }
-        deployment.getServletPaths().invalidate();
+        servletContext.addMappingForServletNames(filterInfo, dispatcherTypes, isMatchAfter, servletNames);
     }
 
     @Override
@@ -89,27 +70,7 @@ public Collection<String> getServletNameMappings() {
 
     @Override
     public void addMappingForUrlPatterns(final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... urlPatterns) {
-        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
-        for(final String url : urlPatterns){
-            if(isMatchAfter) {
-                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
-                    deploymentInfo.addFilterUrlMapping(filterInfo.getName(), url, DispatcherType.REQUEST);
-                } else {
-                    for(final DispatcherType dispatcher : dispatcherTypes) {
-                        deploymentInfo.addFilterUrlMapping(filterInfo.getName(), url, dispatcher);
-                    }
-                }
-            } else {
-                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
-                    deploymentInfo.insertFilterUrlMapping(0, filterInfo.getName(), url, DispatcherType.REQUEST);
-                } else {
-                    for(final DispatcherType dispatcher : dispatcherTypes) {
-                        deploymentInfo.insertFilterUrlMapping(0, filterInfo.getName(), url, dispatcher);
-                    }
-                }
-            }
-        }
-        deployment.getServletPaths().invalidate();
+        servletContext.addMappingForUrlPatterns(filterInfo, dispatcherTypes, isMatchAfter, urlPatterns);
     }
 
     @Override",2014-09-14T21:46:23Z,329
"@@ -54,6 +54,7 @@
 
 import javax.annotation.security.DeclareRoles;
 import javax.annotation.security.RunAs;
+import javax.servlet.DispatcherType;
 import javax.servlet.Filter;
 import javax.servlet.FilterRegistration;
 import javax.servlet.MultipartConfigElement;
@@ -80,6 +81,7 @@
 import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.EnumSet;
 import java.util.Enumeration;
 import java.util.EventListener;
 import java.util.HashMap;
@@ -108,6 +110,7 @@ public class ServletContextImpl implements ServletContext {
     private volatile Set<SessionTrackingMode> defaultSessionTrackingModes = new HashSet<>(Arrays.asList(new SessionTrackingMode[]{SessionTrackingMode.COOKIE, SessionTrackingMode.URL}));
     private volatile SessionConfig sessionConfig;
     private volatile boolean initialized = false;
+    private int filterMappingInsertPosition = 0;
 
 
     public ServletContextImpl(final ServletContainer servletContainer, final Deployment deployment) {
@@ -491,7 +494,7 @@ public FilterRegistration.Dynamic addFilter(final String filterName, final Strin
             FilterInfo filter = new FilterInfo(filterName, (Class<? extends Filter>) deploymentInfo.getClassLoader().loadClass(className));
             deploymentInfo.addFilter(filter);
             deployment.getFilters().addFilter(filter);
-            return new FilterRegistrationImpl(filter, deployment);
+            return new FilterRegistrationImpl(filter, deployment, this);
         } catch (ClassNotFoundException e) {
             throw UndertowServletMessages.MESSAGES.cannotLoadClass(className, e);
         }
@@ -508,7 +511,7 @@ public FilterRegistration.Dynamic addFilter(final String filterName, final Filte
         FilterInfo f = new FilterInfo(filterName, filter.getClass(), new ImmediateInstanceFactory<>(filter));
         deploymentInfo.addFilter(f);
         deployment.getFilters().addFilter(f);
-        return new FilterRegistrationImpl(f, deployment);
+        return new FilterRegistrationImpl(f, deployment, this);
 
     }
 
@@ -522,7 +525,7 @@ public FilterRegistration.Dynamic addFilter(final String filterName, final Class
         FilterInfo filter = new FilterInfo(filterName, filterClass);
         deploymentInfo.addFilter(filter);
         deployment.getFilters().addFilter(filter);
-        return new FilterRegistrationImpl(filter, deployment);
+        return new FilterRegistrationImpl(filter, deployment, this);
     }
 
     @Override
@@ -542,15 +545,15 @@ public FilterRegistration getFilterRegistration(final String filterName) {
         if (filterInfo == null) {
             return null;
         }
-        return new FilterRegistrationImpl(filterInfo, deployment);
+        return new FilterRegistrationImpl(filterInfo, deployment, this);
     }
 
     @Override
     public Map<String, ? extends FilterRegistration> getFilterRegistrations() {
         ensureNotProgramaticListener();
         final Map<String, FilterRegistration> ret = new HashMap<>();
         for (Map.Entry<String, FilterInfo> entry : deploymentInfo.getFilters().entrySet()) {
-            ret.put(entry.getKey(), new FilterRegistrationImpl(entry.getValue(), deployment));
+            ret.put(entry.getKey(), new FilterRegistrationImpl(entry.getValue(), deployment, this));
         }
         return ret;
     }
@@ -812,4 +815,53 @@ public Void run() {
             return null;
         }
     }
+
+    void addMappingForServletNames(FilterInfo filterInfo, final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... servletNames) {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
+
+        for(final String servlet : servletNames){
+            if(isMatchAfter) {
+                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
+                    deploymentInfo.addFilterServletNameMapping(filterInfo.getName(), servlet, DispatcherType.REQUEST);
+                } else {
+                    for(final DispatcherType dispatcher : dispatcherTypes) {
+                        deploymentInfo.addFilterServletNameMapping(filterInfo.getName(), servlet, dispatcher);
+                    }
+                }
+            } else {
+                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
+                    deploymentInfo.insertFilterServletNameMapping(filterMappingInsertPosition++, filterInfo.getName(), servlet, DispatcherType.REQUEST);
+                } else {
+                    for(final DispatcherType dispatcher : dispatcherTypes) {
+                        deploymentInfo.insertFilterServletNameMapping(filterMappingInsertPosition++, filterInfo.getName(), servlet, dispatcher);
+                    }
+                }
+            }
+        }
+        deployment.getServletPaths().invalidate();
+    }
+
+    void addMappingForUrlPatterns(FilterInfo filterInfo, final EnumSet<DispatcherType> dispatcherTypes, final boolean isMatchAfter, final String... urlPatterns) {
+        DeploymentInfo deploymentInfo = deployment.getDeploymentInfo();
+        for(final String url : urlPatterns){
+            if(isMatchAfter) {
+                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
+                    deploymentInfo.addFilterUrlMapping(filterInfo.getName(), url, DispatcherType.REQUEST);
+                } else {
+                    for(final DispatcherType dispatcher : dispatcherTypes) {
+                        deploymentInfo.addFilterUrlMapping(filterInfo.getName(), url, dispatcher);
+                    }
+                }
+            } else {
+                if(dispatcherTypes == null || dispatcherTypes.isEmpty()) {
+                    deploymentInfo.insertFilterUrlMapping(filterMappingInsertPosition++, filterInfo.getName(), url, DispatcherType.REQUEST);
+                } else {
+                    for(final DispatcherType dispatcher : dispatcherTypes) {
+                        deploymentInfo.insertFilterUrlMapping(filterMappingInsertPosition++, filterInfo.getName(), url, dispatcher);
+                    }
+                }
+            }
+        }
+        deployment.getServletPaths().invalidate();
+    }
 }",2014-09-14T21:46:23Z,146
"@@ -163,7 +163,10 @@ private BasicCompletionHandler(final HttpServerExchange exchange, final HttpComp
 
         public void handleComplete() {
             SecurityContext context = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
-            if (context.getAuthenticationState() == AuthenticationState.REQUIRED) {
+            AuthenticationState authenticationState = context.getAuthenticationState();
+            // TODO Including Failed in this check to allow a subsequent attemp, may prefer a utility method somethere
+            // e.g. shouldSendChallenge()
+            if (authenticationState == AuthenticationState.REQUIRED || authenticationState == AuthenticationState.FAILED) {
                 exchange.getResponseHeaders().add(WWW_AUTHENTICATE, challenge);
                 exchange.setResponseCode(CODE_401.getCode());
             }",2012-10-10T11:16:56Z,1
"@@ -0,0 +1,299 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.server.handlers.security;
+
+import static io.undertow.util.Base64.base64Decode;
+import static io.undertow.util.Base64.encode;
+import static io.undertow.util.Headers.AUTHORIZATION;
+import static io.undertow.util.Headers.HOST;
+import static io.undertow.util.Headers.NEGOTIATE;
+import static io.undertow.util.Headers.WWW_AUTHENTICATE;
+import static io.undertow.util.StatusCodes.CODE_401;
+import static io.undertow.util.WorkerDispatcher.dispatch;
+import io.undertow.server.HttpCompletionHandler;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerConnection;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.AttachmentKey;
+import io.undertow.util.HeaderMap;
+
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.Principal;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.Deque;
+
+import javax.security.auth.Subject;
+import javax.security.auth.kerberos.KerberosPrincipal;
+
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+
+/**
+ * HTTP Handler for GSSAPI / SPNEGO based authentication.
+ *
+ * GSSAPI authentication is associated with the HTTP connection, as long as a connection is being re-used allow the
+ * authentication state to be re-used.
+ *
+ * TODO - May consider an option to allow it to also be associated with the underlying session but that has it's own risks so
+ * would need to come with a warning.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public class GSSAPIAuthenticationHandler implements HttpHandler {
+
+    private static final Charset UTF_8 = Charset.forName(""UTF-8"");
+    private static final String NEGOTIATE_PREFIX = NEGOTIATE + "" "";
+
+    private final HttpHandler next;
+    private final GSSAPIServerSubjectFactory subjectFactory;
+
+    public GSSAPIAuthenticationHandler(final HttpHandler next, final GSSAPIServerSubjectFactory subjectFactory) {
+        this.next = next;
+        this.subjectFactory = subjectFactory;
+    }
+
+    /**
+     * @see io.undertow.server.HttpHandler#handleRequest(io.undertow.server.HttpServerExchange,
+     *      io.undertow.server.HttpCompletionHandler)
+     */
+    @Override
+    public void handleRequest(HttpServerExchange exchange, HttpCompletionHandler completionHandler) {
+        HttpCompletionHandler wrapperCompletionHandler = new GSSAPICompletionHandler(exchange, completionHandler);
+        SecurityContext secContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+        AuthenticationState authState = secContext.getAuthenticationState();
+
+        if (authState == AuthenticationState.REQUIRED || authState == AuthenticationState.NOT_REQUIRED) {
+            HttpServerConnection connection = exchange.getConnection();
+            NegotiationContext negContext = connection.getAttachment(NegotiationContext.ATTACHMENT_KEY);
+            if (negContext != null) {
+                exchange.putAttachment(NegotiationContext.ATTACHMENT_KEY, negContext);
+                if (negContext.isEstablished()) {
+                    secContext.setAuthenticatedPrincipal(negContext.getPrincipal());
+                    secContext.setAuthenticationState(AuthenticationState.AUTHENTICATED);
+                }
+            }
+        }
+
+        // Repeat this check in case a cached authentication has now updates the state.
+        if (authState == AuthenticationState.REQUIRED || authState == AuthenticationState.NOT_REQUIRED) {
+            Deque<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);
+            if (authHeaders != null) {
+                for (String current : authHeaders) {
+                    if (current.startsWith(NEGOTIATE_PREFIX)) {
+                        String base64Challenge = current.substring(NEGOTIATE_PREFIX.length());
+                        byte[] challenge = base64Decode(base64Challenge).getBytes(UTF_8);
+
+                        dispatch(exchange, new GSSAPIRunnable(exchange, wrapperCompletionHandler, challenge));
+
+                        // The request has now potentially been dispatched to a different worker thread, the run method
+                        // within GSSAPIRunnable is now responsible for ensuring the request continues.
+                        return;
+                    }
+                }
+            }
+
+        }
+
+        // Either an authentication attempt has already occurred or no suitable header has been found in this request,
+        // either way let the call continue for the final decision to be made in the SecurityEndHandler.
+        next.handleRequest(exchange, wrapperCompletionHandler);
+    }
+
+    private String getHostName(final HttpServerExchange exchange) {
+        final Deque<String> host = exchange.getRequestHeaders().get(HOST);
+        if (host != null) {
+            String hostName = host.getFirst();
+            if (hostName.contains("":"")) {
+                hostName = hostName.substring(0, hostName.indexOf("":""));
+            }
+
+            return hostName;
+        }
+
+        return null;
+    }
+
+    private final class GSSAPIRunnable implements Runnable {
+
+        private final HttpServerExchange exchange;
+        private final HttpCompletionHandler completionHandler;
+        private final byte[] challenge;
+
+        private GSSAPIRunnable(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler,
+                final byte[] challenge) {
+            this.exchange = exchange;
+            this.completionHandler = completionHandler;
+            this.challenge = challenge;
+        }
+
+        public void run() {
+            try {
+                Subject server = subjectFactory.getSubjectForHost(getHostName(exchange));
+                Subject.doAs(server, new AcceptSecurityContext(exchange, challenge));
+            } catch (GeneralSecurityException e) {
+                SecurityContext secContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+                secContext.setAuthenticationState(AuthenticationState.FAILED);
+            } catch (PrivilegedActionException e) {
+                SecurityContext secContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+                secContext.setAuthenticationState(AuthenticationState.FAILED);
+            }
+
+            next.handleRequest(exchange, completionHandler);
+        }
+
+    }
+
+    private class AcceptSecurityContext implements PrivilegedExceptionAction<Void> {
+
+        private final HttpServerExchange exchange;
+        private final byte[] challenge;
+
+        private AcceptSecurityContext(final HttpServerExchange exchange, final byte[] challenge) {
+            this.exchange = exchange;
+            this.challenge = challenge;
+        }
+
+        public Void run() throws GSSException {
+            NegotiationContext negContext = exchange.getAttachment(NegotiationContext.ATTACHMENT_KEY);
+            if (negContext == null) {
+                negContext = new NegotiationContext();
+                exchange.putAttachment(NegotiationContext.ATTACHMENT_KEY, negContext);
+                // Also cache it on the connection for future calls.
+                exchange.getConnection().putAttachment(NegotiationContext.ATTACHMENT_KEY, negContext);
+            }
+
+            GSSContext gssContext = negContext.getGssContext();
+            if (gssContext == null) {
+                GSSManager manager = GSSManager.getInstance();
+                gssContext = manager.createContext((GSSCredential) null);
+
+                negContext.setGssContext(gssContext);
+            }
+
+            byte[] respToken = gssContext.acceptSecContext(challenge, 0, challenge.length);
+            negContext.setResponseToken(respToken);
+
+            if (negContext.isEstablished()) {
+                SecurityContext secContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+                secContext.setAuthenticatedPrincipal(negContext.getPrincipal());
+                secContext.setAuthenticationState(AuthenticationState.AUTHENTICATED);
+            }
+
+            return null;
+        }
+
+    }
+
+    private class GSSAPICompletionHandler implements HttpCompletionHandler {
+
+        private final HttpServerExchange exchange;
+        private final HttpCompletionHandler next;
+
+        private GSSAPICompletionHandler(final HttpServerExchange exchange, final HttpCompletionHandler next) {
+            this.exchange = exchange;
+            this.next = next;
+        }
+
+        @Override
+        public void handleComplete() {
+            SecurityContext secContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
+            NegotiationContext negContext = exchange.getAttachment(NegotiationContext.ATTACHMENT_KEY);
+            AuthenticationState authenticationState = secContext.getAuthenticationState();
+
+            if (negContext != null) {
+                byte[] responseChallenge = negContext.useResponseToken();
+                if (responseChallenge != null) {
+                    HeaderMap headers = exchange.getResponseHeaders();
+                    headers.add(WWW_AUTHENTICATE, NEGOTIATE_PREFIX + new String(encode(responseChallenge), UTF_8));
+                    if (authenticationState != AuthenticationState.AUTHENTICATED) {
+                        exchange.setResponseCode(CODE_401.getCode());
+                    }
+
+                    next.handleComplete();
+                    return;
+                }
+            }
+
+            // An in-progress authentication didn't take this handle call so check if a new challenge is needed.
+            if (authenticationState == AuthenticationState.REQUIRED || authenticationState == AuthenticationState.FAILED) {
+                exchange.getResponseHeaders().add(WWW_AUTHENTICATE, NEGOTIATE);
+                exchange.setResponseCode(CODE_401.getCode());
+            }
+
+            next.handleComplete();
+        }
+
+    }
+
+    private static class NegotiationContext {
+
+        static AttachmentKey<NegotiationContext> ATTACHMENT_KEY = AttachmentKey.create(NegotiationContext.class);
+
+        private GSSContext gssContext;
+        private byte[] responseToken;
+        private Principal principal;
+
+        GSSContext getGssContext() {
+            return gssContext;
+        }
+
+        void setGssContext(GSSContext gssContext) {
+            this.gssContext = gssContext;
+        }
+
+        byte[] useResponseToken() {
+            // The token only needs to be returned once so clear it once used.
+            try {
+                return responseToken;
+            } finally {
+                responseToken = null;
+            }
+        }
+
+        void setResponseToken(byte[] responseToken) {
+            this.responseToken = responseToken;
+        }
+
+        boolean isEstablished() {
+            return gssContext != null ? gssContext.isEstablished() : false;
+        }
+
+        Principal getPrincipal() {
+            if (isEstablished() == false) {
+                throw new IllegalStateException(""No established GSSContext to use for the Principal."");
+            }
+
+            if (principal == null) {
+                try {
+                    principal = new KerberosPrincipal(gssContext.getSrcName().toString());
+                } catch (GSSException e) {
+                    throw new IllegalStateException(""Unable to create Principal"", e);
+                }
+
+            }
+
+            return principal;
+        }
+
+    }
+
+}",2012-10-10T11:16:56Z,455
"@@ -0,0 +1,51 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.server.handlers.security;
+
+import java.security.GeneralSecurityException;
+
+import javax.security.auth.Subject;
+
+/**
+ * The GSSAPIServerSubjectFactory is a factory responsible for returning the {@link Subject} that should be used for handing the
+ * GSSAPI based authentication for a specific request.
+ * 
+ * The authentication handlers will not perform any caching of the returned Subject, the factory implementation can either
+ * return a new Subject for each request or can cache them maybe based on the expiration time of tickets contained within the
+ * Subject.
+ * 
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public interface GSSAPIServerSubjectFactory {
+    
+    // TODO - Does this need to be supplying some kind of wrapper that allows a try/finally approach to being and end using the Subject?
+
+    /**
+     * Obtain the Subject to use for the specified host.
+     * 
+     * All virtual hosts on a server could use the same Subject or each virtual host could have a different Subject, the
+     * implementation of the factory will make that decision. The factory implementation will also decide if there should be a
+     * default fallback Subject or if a Subject should only be provided for recognised hosts.
+     * 
+     * @param hostName - The host name used for this request.
+     * @return The Subject to use for the specified host name or null if no match possible.
+     * @throws GeneralSecurityException if there is a security failure obtaining the {@link Subject}
+     */
+    Subject getSubjectForHost(final String hostName) throws GeneralSecurityException;
+
+}",2012-10-10T11:16:56Z,7
"@@ -28,7 +28,8 @@
  */
 public class SecurityContext {
 
-    static AttachmentKey<SecurityContext> ATTACHMENT_KEY = AttachmentKey.create(SecurityContext.class);
+    // TODO - May reduce back to default
+    public static AttachmentKey<SecurityContext> ATTACHMENT_KEY = AttachmentKey.create(SecurityContext.class);
 
     private AuthenticationState authenticationState;
     private Principal authenticatedPrincipal;",2012-10-10T11:16:56Z,56
"@@ -20,7 +20,6 @@
 
 import java.util.ArrayDeque;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;",2012-10-10T11:16:56Z,48
"@@ -171,6 +171,7 @@ private Headers() {
 
     // Authentication Schemes
     public static final String BASIC = ""Basic"";
+    public static final String NEGOTIATE = ""Negotiate"";
 
     /**
      * Extracts a token from a header that has a given key. For instance if the header is",2012-10-10T11:16:56Z,58
"@@ -41,6 +41,10 @@ public SinglePortConfidentialityHandler(final HttpHandler next, final int redire
 
     @Override
     protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxException {
+        return getRedirectURI(exchange, redirectPort);
+    }
+
+    protected URI getRedirectURI(HttpServerExchange exchange, int port) throws URISyntaxException {
         String host = exchange.getRequestHeaders().getFirst(Headers.HOST);
         if (host == null) {
             host = exchange.getDestinationAddress().getAddress().getHostAddress();",2013-01-31T10:54:16Z,281
"@@ -0,0 +1,31 @@
+/*
+ * Copyright 2013 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.servlet.api;
+
+import io.undertow.server.HttpServerExchange;
+
+/**
+ * A utility to take the {@see HttpServerExchange} of the current request and obtain the number of the port number to use in
+ * https redirects.
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public interface ConfidentialPortManager {
+
+    int getConfidentialPort(final HttpServerExchange exchange);
+
+}",2013-01-31T10:54:16Z,456
"@@ -65,6 +65,7 @@ public class DeploymentInfo implements Cloneable {
     private volatile SessionManager sessionManager = new InMemorySessionManager();
     private volatile LoginConfig loginConfig;
     private volatile IdentityManager identityManager;
+    private volatile ConfidentialPortManager confidentialPortManager;
     private final Map<String, ServletInfo> servlets = new HashMap<String, ServletInfo>();
     private final Map<String, FilterInfo> filters = new HashMap<String, FilterInfo>();
     private final List<FilterMappingInfo> filterServletNameMappings = new ArrayList<FilterMappingInfo>();
@@ -504,6 +505,14 @@ public DeploymentInfo setIdentityManager(IdentityManager identityManager) {
         return this;
     }
 
+    public ConfidentialPortManager getConfidentialPortManager() {
+        return confidentialPortManager;
+    }
+
+    public void setConfidentialPortManager(ConfidentialPortManager confidentialPortManager) {
+        this.confidentialPortManager = confidentialPortManager;
+    }
+
     public DeploymentInfo addPrincipleVsRoleMapping(final String principle, final String role) {
         Set<String> roles = principleVsRoleMapping.get(principle);
         if (roles == null) {",2013-01-31T10:54:16Z,142
"@@ -78,6 +78,7 @@
 import io.undertow.servlet.handlers.ServletPathMatches;
 import io.undertow.servlet.handlers.security.SecurityPathMatches;
 import io.undertow.servlet.handlers.security.ServletAuthenticationConstraintHandler;
+import io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletSecurityRoleHandler;
 import io.undertow.servlet.spec.AsyncContextImpl;
@@ -191,6 +192,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
 
         current = new AuthenticationCallHandler(current);
         current = new ServletAuthenticationConstraintHandler(current);
+        current = new ServletConfidentialityConstraintHandler(deploymentInfo.getConfidentialPortManager(), current);
         current = new ServletSecurityConstraintHandler(buildSecurityConstraints(), current);
 
         if (loginConfig != null) {",2013-01-31T10:54:16Z,80
"@@ -0,0 +1,58 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2013 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.undertow.servlet.handlers.security;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import io.undertow.security.handlers.SinglePortConfidentialityHandler;
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.servlet.api.ConfidentialPortManager;
+import io.undertow.servlet.api.TransportGuaranteeType;
+import io.undertow.servlet.handlers.ServletAttachments;
+
+/**
+ * Servlet specific extension to {@see SinglePortConfidentialityHandler}
+ *
+ * @author <a href=""mailto:darran.lofthouse@jboss.com"">Darran Lofthouse</a>
+ */
+public class ServletConfidentialityConstraintHandler extends SinglePortConfidentialityHandler {
+
+    private final ConfidentialPortManager portManager;
+
+    public ServletConfidentialityConstraintHandler(final ConfidentialPortManager portManager, final HttpHandler next) {
+        super(next, -1);
+        this.portManager = portManager;
+    }
+
+    @Override
+    protected boolean confidentialityRequired(HttpServerExchange exchange) {
+        TransportGuaranteeType transportGuarantee = exchange.getAttachment(ServletAttachments.TRANSPORT_GUARANTEE_TYPE);
+
+        // TODO - We may be able to add more flexibility here especially with authentication mechanisms such as Digest for
+        // INTEGRAL - for now just use SSL.
+        return (TransportGuaranteeType.CONFIDENTIAL == transportGuarantee || TransportGuaranteeType.INTEGRAL == transportGuarantee);
+    }
+
+    @Override
+    protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxException {
+        return super.getRedirectURI(exchange, portManager.getConfidentialPort(exchange));
+    }
+
+}",2013-01-31T10:54:16Z,457
"@@ -75,7 +75,7 @@ public void sessionDestroyed(final Session session, final HttpServerExchange exc
                 handle.tearDown();
             }
             ServletRequestContext current = SecurityActions.currentServletRequestContext();
-            if (current != null) {
+            if (current != null && current.getSession().getSession() == session) {
                 current.setSession(null);
             }
         }",2014-06-26T15:47:08Z,377
"@@ -18,10 +18,9 @@
 
 package io.undertow.server.session;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 
@@ -44,7 +43,7 @@ public class InMemorySessionManager implements SessionManager {
 
     private final ConcurrentMap<String, InMemorySession> sessions = new SecureHashMap<>();
 
-    private volatile List<SessionListener> listeners = Collections.emptyList();
+    private final SessionListeners sessionListeners = new SessionListeners();
 
     /**
      * 30 minute default
@@ -58,6 +57,9 @@ public void start() {
 
     @Override
     public void stop() {
+        for (Map.Entry<String, InMemorySession> session : sessions.entrySet()) {
+            sessionListeners.sessionDestroyed(session.getValue().session, null, SessionListener.SessionDestroyedReason.UNDEPLOY);
+        }
         sessions.clear();
     }
 
@@ -78,9 +80,7 @@ public Session createSession(final HttpServerExchange serverExchange, final Sess
         final SessionImpl session = new SessionImpl(sessionID, config, serverExchange.getIoThread(), serverExchange.getConnection().getWorker());
         InMemorySession im = new InMemorySession(session, defaultSessionTimeout);
         sessions.put(sessionID, im);
-        for (SessionListener listener : listeners) {
-            listener.sessionCreated(session, serverExchange);
-        }
+        sessionListeners.sessionCreated(session, serverExchange);
         config.setSessionId(serverExchange, session.getId());
         im.lastAccessed = System.currentTimeMillis();
         session.bumpTimeout();
@@ -104,16 +104,12 @@ public Session getSession(final HttpServerExchange serverExchange, final Session
 
     @Override
     public synchronized void registerSessionListener(final SessionListener listener) {
-        final List<SessionListener> listeners = new ArrayList<SessionListener>(this.listeners);
-        listeners.add(listener);
-        this.listeners = Collections.unmodifiableList(listeners);
+        sessionListeners.addSessionListener(listener);
     }
 
     @Override
     public synchronized void removeSessionListener(final SessionListener listener) {
-        final List<SessionListener> listeners = new ArrayList<SessionListener>(this.listeners);
-        listeners.remove(listener);
-        this.listeners = Collections.unmodifiableList(listeners);
+        sessionListeners.removeSessionListener(listener);
     }
 
     @Override
@@ -140,7 +136,7 @@ public void run() {
                 worker.execute(new Runnable() {
                     @Override
                     public void run() {
-                        invalidate(null);
+                        invalidate(null, SessionListener.SessionDestroyedReason.TIMEOUT);
                     }
                 });
             }
@@ -240,12 +236,10 @@ public Object setAttribute(final String name, final Object value) {
                 throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.put(name, value);
-            for (SessionListener listener : listeners) {
-                if (existing == null) {
-                    listener.attributeAdded(sess.session, name, value);
-                } else {
-                    listener.attributeUpdated(sess.session, name, value);
-                }
+            if (existing == null) {
+                sessionListeners.attributeAdded(sess.session, name, value);
+            } else {
+                sessionListeners.attributeUpdated(sess.session, name, value, existing);
             }
             bumpTimeout();
             return existing;
@@ -258,25 +252,29 @@ public Object removeAttribute(final String name) {
                 throw UndertowMessages.MESSAGES.sessionNotFound(sessionId);
             }
             final Object existing = sess.attributes.remove(name);
-            for (SessionListener listener : listeners) {
-                listener.attributeRemoved(sess.session, name);
-            }
+            sessionListeners.attributeRemoved(sess.session, name, existing);
             bumpTimeout();
             return existing;
         }
 
         @Override
         public void invalidate(final HttpServerExchange exchange) {
+            invalidate(exchange, SessionListener.SessionDestroyedReason.INVALIDATED);
+        }
+
+        void invalidate(final HttpServerExchange exchange, SessionListener.SessionDestroyedReason reason) {
             if (cancelKey != null) {
                 cancelKey.remove();
             }
-            final InMemorySession sess = sessions.remove(sessionId);
+            InMemorySession sess = sessions.get(sessionId);
             if (sess == null) {
-                throw UndertowMessages.MESSAGES.sessionAlreadyInvalidated();
-            }
-            for (SessionListener listener : listeners) {
-                listener.sessionDestroyed(sess.session, exchange, false);
+                if (reason == SessionListener.SessionDestroyedReason.INVALIDATED) {
+                    throw UndertowMessages.MESSAGES.sessionAlreadyInvalidated();
+                }
+                return;
             }
+            sessionListeners.sessionDestroyed(sess.session, exchange, reason);
+            sessions.remove(sessionId);
             if (exchange != null) {
                 sessionCookieConfig.clearSession(exchange, this.getId());
             }
@@ -314,7 +312,7 @@ private static class InMemorySession {
             this.maxInactiveInterval = maxInactiveInterval;
         }
 
-        final ConcurrentMap<String, Object> attributes = new SecureHashMap<String, Object>();
+        final ConcurrentMap<String, Object> attributes = new ConcurrentHashMap<>();
         volatile long lastAccessed;
         final long creationTime;
         volatile int maxInactiveInterval;",2013-05-13T03:29:32Z,13
"@@ -42,11 +42,17 @@ public interface SessionListener {
      * @param exchange The {@link HttpServerExchange} that destroyed the session, or null if the session timed out
      * @param expired If the session expired
      */
-    void sessionDestroyed(final Session session,  final HttpServerExchange exchange, final boolean expired);
+    void sessionDestroyed(final Session session,  final HttpServerExchange exchange, SessionDestroyedReason reason);
 
     void attributeAdded(final Session session, final String name, final Object value);
 
-    void attributeUpdated(final Session session, final String name, final Object newValue);
+    void attributeUpdated(final Session session, final String name, final Object newValue, final Object oldValue);
 
-    void attributeRemoved(final Session session, final String name);
+    void attributeRemoved(final Session session, final String name,final Object oldValue);
+
+    enum SessionDestroyedReason {
+        INVALIDATED,
+        TIMEOUT,
+        UNDEPLOY,
+    }
 }",2013-05-13T03:29:32Z,53
"@@ -0,0 +1,63 @@
+package io.undertow.server.session;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.undertow.server.HttpServerExchange;
+
+/**
+ * Utility class that maintains the session listeners.
+ *
+ *
+ * @author Stuart Douglas
+ */
+public class SessionListeners {
+
+    private final List<SessionListener> sessionListeners = new CopyOnWriteArrayList<>();
+
+    public void addSessionListener(final SessionListener listener) {
+        this.sessionListeners.add(listener);
+    }
+
+    public boolean removeSessionListener(final SessionListener listener) {
+        return this.sessionListeners.remove(listener);
+    }
+
+    public void clear() {
+        this.sessionListeners.clear();
+    }
+
+    public void sessionCreated(final Session session, final HttpServerExchange exchange) {
+        for (SessionListener listener : sessionListeners) {
+            listener.sessionCreated(session, exchange);
+        }
+    }
+
+    public void sessionDestroyed(final Session session, final HttpServerExchange exchange, SessionListener.SessionDestroyedReason reason) {
+        for (SessionListener listener : sessionListeners) {
+            listener.sessionDestroyed(session, exchange, reason);
+        }
+
+    }
+
+    public void attributeAdded(final Session session, final String name, final Object value) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeAdded(session, name, value);
+        }
+
+    }
+
+    public void attributeUpdated(final Session session, final String name, final Object newValue, final Object oldValue) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeUpdated(session, name, newValue, oldValue);
+        }
+
+    }
+
+    public void attributeRemoved(final Session session, final String name, final Object oldValue) {
+        for (SessionListener listener : sessionListeners) {
+            listener.attributeRemoved(session, name, oldValue);
+        }
+    }
+
+}",2013-05-13T03:29:32Z,53
"@@ -105,4 +105,6 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         }
     }
 
+
+
 }",2013-05-13T03:29:32Z,14
"@@ -160,4 +160,5 @@ public interface UndertowServletMessages {
 
     @Message(id = 10038, value = ""No web socket handler was provided to the web socket servlet"")
     ServletException noWebSocketHandler();
+
 }",2013-05-13T03:29:32Z,141
"@@ -159,6 +159,8 @@ public void deploy() {
                 }
             }
 
+            deployment.getSessionManager().registerSessionListener(new SessionListenerBridge(listeners, servletContext));
+
             initializeErrorPages(deployment, deploymentInfo);
             initializeMimeMappings(deployment, deploymentInfo);
             initializeTempDir(servletContext, deploymentInfo);",2013-05-13T03:29:32Z,80
"@@ -0,0 +1,77 @@
+package io.undertow.servlet.core;
+
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpSessionBindingEvent;
+import javax.servlet.http.HttpSessionBindingListener;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.server.session.Session;
+import io.undertow.server.session.SessionListener;
+import io.undertow.servlet.handlers.ServletRequestContext;
+import io.undertow.servlet.spec.HttpSessionImpl;
+
+/**
+ * Class that bridges between Undertow native session listeners and servlet ones.
+ *
+ * @author Stuart Douglas
+ */
+public class SessionListenerBridge implements SessionListener {
+
+    private final ApplicationListeners applicationListeners;
+    private final ServletContext servletContext;
+
+    public SessionListenerBridge(final ApplicationListeners applicationListeners, final ServletContext servletContext) {
+        this.applicationListeners = applicationListeners;
+        this.servletContext = servletContext;
+    }
+
+    @Override
+    public void sessionCreated(final Session session, final HttpServerExchange exchange) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, true);
+        applicationListeners.sessionCreated(httpSession);
+    }
+
+    @Override
+    public void sessionDestroyed(final Session session, final HttpServerExchange exchange, final SessionDestroyedReason reason) {
+        try {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        applicationListeners.sessionDestroyed(httpSession);
+        } finally {
+            ServletRequestContext current = ServletRequestContext.current();
+            if(current != null) {
+                current.setSession(null);
+            }
+        }
+    }
+
+    @Override
+    public void attributeAdded(final Session session, final String name, final Object value) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        applicationListeners.httpSessionAttributeAdded(httpSession, name, value);
+    }
+
+    @Override
+    public void attributeUpdated(final Session session, final String name, final Object value, final Object old) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        if (old != value) {
+            if (old instanceof HttpSessionBindingListener) {
+                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(httpSession, name, old));
+            }
+            applicationListeners.httpSessionAttributeReplaced(httpSession, name, old);
+        }
+        if (value instanceof HttpSessionBindingListener) {
+            ((HttpSessionBindingListener) value).valueBound(new HttpSessionBindingEvent(httpSession, name, value));
+        }
+    }
+
+    @Override
+    public void attributeRemoved(final Session session, final String name, final Object old) {
+        final HttpSessionImpl httpSession = HttpSessionImpl.forSession(session, servletContext, false);
+        if (old != null) {
+            applicationListeners.httpSessionAttributeRemoved(httpSession, name, old);
+            if (old instanceof HttpSessionBindingListener) {
+                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(httpSession, name, old));
+            }
+        }
+    }
+}",2013-05-13T03:29:32Z,377
"@@ -7,6 +7,7 @@
 import io.undertow.servlet.handlers.security.SingleConstraintMatch;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
 import io.undertow.servlet.spec.HttpServletResponseImpl;
+import io.undertow.servlet.spec.HttpSessionImpl;
 import io.undertow.util.AttachmentKey;
 
 import javax.servlet.DispatcherType;
@@ -58,6 +59,7 @@ public static ServletRequestContext current() {
 
     private List<SingleConstraintMatch> requiredConstrains;
     private TransportGuaranteeType transportGuarenteeType;
+    private HttpSessionImpl session;
 
     public ServletRequestContext(final HttpServletRequestImpl originalRequest, final HttpServletResponseImpl originalResponse) {
         this.originalRequest = originalRequest;
@@ -129,4 +131,12 @@ public HttpServletRequestImpl getOriginalRequest() {
     public HttpServletResponseImpl getOriginalResponse() {
         return originalResponse;
     }
+
+    public HttpSessionImpl getSession() {
+        return session;
+    }
+
+    public void setSession(final HttpSessionImpl session) {
+        this.session = session;
+    }
 }",2013-05-13T03:29:32Z,123
"@@ -23,14 +23,11 @@
 
 import javax.servlet.ServletContext;
 import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionBindingEvent;
-import javax.servlet.http.HttpSessionBindingListener;
 import javax.servlet.http.HttpSessionContext;
 
-import io.undertow.server.HttpServerExchange;
 import io.undertow.server.session.Session;
 import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.core.ApplicationListeners;
+import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.servlet.util.IteratorEnumeration;
 
 /**
@@ -40,19 +37,35 @@ public class HttpSessionImpl implements HttpSession {
 
     private final Session session;
     private final ServletContext servletContext;
-    private final ApplicationListeners applicationListeners;
-    private final HttpServerExchange exchange;
     private final boolean newSession;
     private volatile boolean invalid;
 
-    public HttpSessionImpl(final Session session, final ServletContext servletContext, final ApplicationListeners applicationListeners, final HttpServerExchange exchange, final boolean newSession) {
+    private HttpSessionImpl(final Session session, final ServletContext servletContext, final boolean newSession) {
         this.session = session;
         this.servletContext = servletContext;
-        this.applicationListeners = applicationListeners;
-        this.exchange = exchange;
         this.newSession = newSession;
     }
 
+    public static HttpSessionImpl forSession(final Session session, final ServletContext servletContext, final boolean newSession) {
+        ServletRequestContext current = ServletRequestContext.current();
+        if (current == null) {
+            return new HttpSessionImpl(session, servletContext, newSession);
+        } else {
+            HttpSessionImpl httpSession = current.getSession();
+            if (httpSession == null) {
+                httpSession = new HttpSessionImpl(session, servletContext, newSession);
+                current.setSession(httpSession);
+            } else {
+                if(httpSession.session != session) {
+                    //in some rare cases it may be that there are two different service contexts involved in the one request
+                    //in this case we just return a new session rather than using the thread local version
+                    httpSession = new HttpSessionImpl(session, servletContext, newSession);
+                }
+            }
+            return httpSession;
+        }
+    }
+
     @Override
     public long getCreationTime() {
         return session.getCreationTime();
@@ -119,18 +132,7 @@ public void setAttribute(final String name, final Object value) {
         if (value == null) {
             removeAttribute(name);
         } else {
-            Object old = session.setAttribute(name, value);
-            if (old == null) {
-                applicationListeners.httpSessionAttributeAdded(this, name, value);
-            } else if (old != value) {
-                if (old instanceof HttpSessionBindingListener) {
-                    ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(this, name, old));
-                }
-                applicationListeners.httpSessionAttributeReplaced(this, name, old);
-            }
-            if (value instanceof HttpSessionBindingListener) {
-                ((HttpSessionBindingListener) value).valueBound(new HttpSessionBindingEvent(this, name, value));
-            }
+            session.setAttribute(name, value);
         }
     }
 
@@ -141,13 +143,7 @@ public void putValue(final String name, final Object value) {
 
     @Override
     public void removeAttribute(final String name) {
-        Object old = session.removeAttribute(name);
-        if (old != null) {
-            applicationListeners.httpSessionAttributeRemoved(this, name, old);
-            if (old instanceof HttpSessionBindingListener) {
-                ((HttpSessionBindingListener) old).valueUnbound(new HttpSessionBindingEvent(this, name, old));
-            }
-        }
+        session.removeAttribute(name);
     }
 
     @Override
@@ -158,8 +154,12 @@ public void removeValue(final String name) {
     @Override
     public void invalidate() {
         invalid = true;
-        applicationListeners.sessionDestroyed(this);
-        session.invalidate(exchange);
+        ServletRequestContext current = ServletRequestContext.current();
+        if (current == null) {
+            session.invalidate(null);
+        } else {
+            session.invalidate(current.getOriginalRequest().getExchange());
+        }
     }
 
     @Override",2013-05-13T03:29:32Z,378
"@@ -521,11 +521,11 @@ public HttpSessionImpl getSession(final HttpServerExchange exchange, boolean cre
             final SessionManager sessionManager = deployment.getSessionManager();
             Session session = sessionManager.getSession(exchange, c);
             if (session != null) {
-                httpSession = new HttpSessionImpl(session, this, getDeployment().getApplicationListeners(), exchange, false);
+                httpSession = HttpSessionImpl.forSession(session, this, false);
                 exchange.putAttachment(sessionAttachmentKey, httpSession);
             } else if (create) {
                 final Session newSession = sessionManager.createSession(exchange, c);
-                httpSession = new HttpSessionImpl(newSession, this, getDeployment().getApplicationListeners(), exchange, true);
+                httpSession = HttpSessionImpl.forSession(newSession, this, true);
                 exchange.putAttachment(sessionAttachmentKey, httpSession);
                 getDeployment().getApplicationListeners().sessionCreated(httpSession);
             }",2013-05-13T03:29:32Z,146
"@@ -96,5 +96,13 @@ public interface UndertowLogger extends BasicLogger {
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5014, value = ""Failed to parse HTTP request"")
     void failedToParseRequest(@Cause Exception e);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5015, value = ""Error rotating access log"")
+    void errorRotatingAccessLog(@Cause IOException e);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 5016, value = ""Error writing access log"")
+    void errorWritingAccessLog(@Cause IOException e);
 }
 ",2013-06-25T03:10:07Z,65
"@@ -31,13 +31,13 @@ public AccessLogHandler(final HttpHandler next, final AccessLogReceiver accessLo
         while (tokeniser.hasMoreElements()) {
             String elem = (String) tokeniser.nextElement();
             TokenHandler tokenHandler = null;
-            for(TokenHandler.Factory factory : factories) {
+            for (TokenHandler.Factory factory : factories) {
                 tokenHandler = factory.create(elem);
-                if(tokenHandler != null) {
+                if (tokenHandler != null) {
                     break;
                 }
             }
-            if(tokenHandler == null) {
+            if (tokenHandler == null) {
                 tokenHandler = new ConstantAccessLogToken(elem);
             }
             tokenHandlers.add(tokenHandler);
@@ -56,19 +56,23 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     private class AccessLogCompletionListener implements ExchangeCompletionListener {
         @Override
         public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
-            StringBuilder builder = new StringBuilder();
-            for(int i = 0; i < tokens.length; ++i) {
-                String result = tokens[i].generateMessage(exchange);
-                if(result == null) {
-                    builder.append('-');
-                } else {
-                    builder.append(result);
-                }
-                if(i != tokens.length -1) {
-                    builder.append(' ');
+            try {
+                StringBuilder builder = new StringBuilder();
+                for (int i = 0; i < tokens.length; ++i) {
+                    String result = tokens[i].generateMessage(exchange);
+                    if (result == null) {
+                        builder.append('-');
+                    } else {
+                        builder.append(result);
+                    }
+                    if (i != tokens.length - 1) {
+                        builder.append(' ');
+                    }
                 }
+                accessLogReceiver.logMessage(builder.toString());
+            } finally {
+                nextListener.proceed();
             }
-            accessLogReceiver.logMessage(builder.toString());
         }
     }
 ",2013-06-25T03:10:07Z,458
"@@ -1,23 +1,34 @@
 package io.undertow.server.handlers.accesslog;
 
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.Deque;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
+import io.undertow.UndertowLogger;
+
 /**
  * Log Receiver that stores logs in a directory under the specified file name, and rotates them after
  * midnight.
- *
+ * <p/>
  * Web threads do not touch the log file, but simply queue messages to be written later by a worker thread.
  * A lightwieght CAS based locking mechanism is used to ensure than only 1 thread is active writing messages at
  * any given time
  *
  * @author Stuart Douglas
  */
-public class DefaultAccessLogReceiver implements AccessLogReceiver, Runnable {
+public class DefaultAccessLogReceiver implements AccessLogReceiver, Runnable, Closeable {
 
     private final Executor logWriteExecutor;
 
@@ -27,21 +38,46 @@ public class DefaultAccessLogReceiver implements AccessLogReceiver, Runnable {
     //1 = queued
     //2 = running
     @SuppressWarnings(""unused"")
-    private final int state = 0;
+    private volatile int state = 0;
 
     private static final AtomicIntegerFieldUpdater<DefaultAccessLogReceiver> stateUpdater = AtomicIntegerFieldUpdater.newUpdater(DefaultAccessLogReceiver.class, ""state"");
 
-    public DefaultAccessLogReceiver(final Executor logWriteExecutor) {
+    private long changeOverPoint;
+    private String currentDateString;
+    private boolean forceLogRotation;
+
+    private final File outputDirectory;
+    private final File defaultLogFile;
+
+    private final String logBaseName;
+
+    private Writer writer = null;
+
+    public DefaultAccessLogReceiver(final Executor logWriteExecutor, final File outputDirectory, final String logBaseName) {
         this.logWriteExecutor = logWriteExecutor;
+        this.outputDirectory = outputDirectory;
+        this.logBaseName = logBaseName;
         this.pendingMessages = new ConcurrentLinkedDeque<String>();
+        this.defaultLogFile = new File(outputDirectory, logBaseName + "".log"");
+        calculateChangeOverPoint();
+    }
+
+    private void calculateChangeOverPoint() {
+        Calendar calendar = Calendar.getInstance();
+        calendar.set(Calendar.SECOND, 59);
+        calendar.set(Calendar.MINUTE, 59);
+        calendar.set(Calendar.HOUR, 23);
+        changeOverPoint = calendar.getTimeInMillis();
+        SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd"");
+        currentDateString = df.format(new Date());
     }
 
     @Override
     public void logMessage(final String message) {
         this.pendingMessages.add(message);
         int state = stateUpdater.get(this);
-        if(state == 0) {
-            if(stateUpdater.compareAndSet(this, 0, 1)) {
+        if (state == 0) {
+            if (stateUpdater.compareAndSet(this, 0, 1)) {
                 logWriteExecutor.execute(this);
             }
         }
@@ -52,16 +88,107 @@ public void logMessage(final String message) {
      */
     @Override
     public void run() {
-        if(!stateUpdater.compareAndSet(this, 1, 2)) {
+        if (!stateUpdater.compareAndSet(this, 1, 2)) {
             return;
         }
+        if(forceLogRotation) {
+            doRotate();
+        }
         List<String> messsages = new ArrayList<String>();
         String msg = null;
-        for(int i = 0; i < 20; ++i) {
+        //only grab at most 20 messages at a time
+        for (int i = 0; i < 20; ++i) {
             msg = pendingMessages.poll();
-            if(msg == null) {
+            if (msg == null) {
                 break;
             }
+            messsages.add(msg);
+        }
+        if(!messsages.isEmpty()) {
+            writeMessage(messsages);
+        }
+        stateUpdater.set(this, 0);
+        //check to see if there is still more messages
+        //if so then run this again
+        if (!pendingMessages.isEmpty() || forceLogRotation) {
+            if (stateUpdater.compareAndSet(this, 0, 1)) {
+                logWriteExecutor.execute(this);
+            }
+        }
+    }
+
+    /**
+     * For tests only. Blocks the current thread until all messages are written
+     * Just does a busy wait.
+     *
+     * DO NOT USE THIS OUTSIDE OF A TEST
+     */
+    void awaitWrittenForTest() throws InterruptedException {
+        while (!pendingMessages.isEmpty() || forceLogRotation) {
+            Thread.sleep(10);
         }
+        while (state != 0) {
+            Thread.sleep(10);
+        }
+    }
+
+    private void writeMessage(final List<String> messsages) {
+        if (System.currentTimeMillis() > changeOverPoint) {
+            doRotate();
+        }
+        try {
+            if (writer == null) {
+                writer = new BufferedWriter(new FileWriter(defaultLogFile));
+            }
+            for (String message : messsages) {
+                writer.write(message);
+                writer.write('\n');
+            }
+            writer.flush();
+        } catch (IOException e) {
+            UndertowLogger.ROOT_LOGGER.errorWritingAccessLog(e);
+        }
+    }
+
+    private void doRotate() {
+        forceLogRotation = false;
+        try {
+            if (writer != null) {
+                writer.flush();
+                writer.close();
+                writer = null;
+            }
+            File newFile = new File(outputDirectory, logBaseName + ""_"" + currentDateString + "".log"");
+            int count = 0;
+            while (newFile.exists())  {
+                ++count;
+                newFile = new File(outputDirectory, logBaseName + ""_"" + currentDateString  + ""-"" + count + "".log"");
+            }
+            if (!defaultLogFile.renameTo(newFile)) {
+                UndertowLogger.ROOT_LOGGER.errorRotatingAccessLog(new IOException());
+            }
+        } catch (IOException e) {
+            UndertowLogger.ROOT_LOGGER.errorRotatingAccessLog(e);
+        } finally {
+            calculateChangeOverPoint();
+        }
+    }
+
+    /**
+     * forces a log rotation. This rotation is performed in an async manner, you cannot rely on the rotation
+     * being performed immediately after this method returns.
+     */
+    public void rotate() {
+        forceLogRotation = true;
+        if (stateUpdater.compareAndSet(this, 0, 1)) {
+            logWriteExecutor.execute(this);
+        }
+    }
+
+    @Override
+    public void close() throws IOException {
+        writer.flush();
+        writer.close();
+        writer = null;
     }
 }",2013-06-25T03:10:07Z,237
"@@ -0,0 +1,172 @@
+package io.undertow.server.handlers.accesslog;
+
+import java.io.File;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import io.undertow.server.HttpHandler;
+import io.undertow.server.HttpServerExchange;
+import io.undertow.testutils.DefaultServer;
+import io.undertow.testutils.FileUtils;
+import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.TestHttpClient;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Tests writing the access log to a file
+ *
+ * @author Stuart Douglas
+ */
+@RunWith(DefaultServer.class)
+public class AccessLogFileTestCase {
+
+    private static final File logDirectory = new File(System.getProperty(""java.io.tmpdir"") + ""/logs"");
+
+    private static final int NUM_THREADS = 10;
+    private static final int NUM_REQUESTS = 12;
+
+    @Before
+    public void before() {
+        logDirectory.mkdirs();
+    }
+
+    @After
+    public void after() {
+        FileUtils.deleteRecursive(logDirectory);
+    }
+
+    private static final HttpHandler HELLO_HANDLER = new HttpHandler() {
+        @Override
+        public void handleRequest(final HttpServerExchange exchange) throws Exception {
+            exchange.getResponseSender().send(""Hello"");
+        }
+    };
+
+    @Test
+    public void testSingleLogMessageToFile() throws IOException, InterruptedException {
+        File directory = new File(System.getProperty(""java.io.tmpdir""));
+        File logFileName = new File(directory, ""server.log"");
+
+        DefaultAccessLogReceiver logReceiver = new DefaultAccessLogReceiver(DefaultServer.getWorker(), directory, ""server"");
+        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, ""Remote address %a Code %s test-header %{test-header}i"", DefaultAccessLogTokens.INSTANCE));
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            get.addHeader(""test-header"", ""single-val"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            Assert.assertEquals(""Hello"", HttpClientUtils.readResponse(result));
+            logReceiver.awaitWrittenForTest();
+            Assert.assertEquals(""Remote address 127.0.0.1 Code 200 test-header single-val\n"", FileUtils.readFile(logFileName));
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+
+    @Test
+    public void testLogLotsOfThreads() throws IOException, InterruptedException, ExecutionException {
+        File directory = new File(System.getProperty(""java.io.tmpdir""));
+        File logFileName = new File(directory, ""server.log"");
+
+        DefaultAccessLogReceiver logReceiver = new DefaultAccessLogReceiver(DefaultServer.getWorker(), directory, ""server"");
+        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, ""REQ %{test-header}i"", DefaultAccessLogTokens.INSTANCE));
+
+        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
+        try {
+
+            final List<Future<?>> futures = new ArrayList<Future<?>>();
+            for (int i = 0; i < NUM_THREADS; ++i) {
+                final int threadNo = i;
+                futures.add(executor.submit(new Runnable() {
+                    @Override
+                    public void run() {
+                        TestHttpClient client = new TestHttpClient();
+                        try {
+                            for (int i = 0; i < NUM_REQUESTS; ++i) {
+                                HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+                                get.addHeader(""test-header"", ""thread-"" + threadNo + ""-request-"" + i);
+                                HttpResponse result = client.execute(get);
+                                Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+                                final String response = HttpClientUtils.readResponse(result);
+                                Assert.assertEquals(""Hello"", response);
+                            }
+                        } catch (IOException e) {
+                            throw new RuntimeException(e);
+                        } finally {
+                            client.getConnectionManager().shutdown();
+                        }
+                    }
+                }));
+            }
+            for (Future<?> future : futures) {
+                future.get();
+            }
+
+        } finally {
+            executor.shutdown();
+        }
+        logReceiver.awaitWrittenForTest();
+        String completeLog = FileUtils.readFile(logFileName);
+        for (int i = 0; i < NUM_THREADS; ++i) {
+            for (int j = 0; j < NUM_REQUESTS; ++j) {
+                Assert.assertTrue(completeLog.contains(""REQ thread-"" + i + ""-request-"" + j));
+            }
+        }
+
+    }
+
+
+    @Test
+    public void testForcedLogRotation() throws IOException, InterruptedException {
+        File logFileName = new File(logDirectory, ""server.log"");
+
+        DefaultAccessLogReceiver logReceiver = new DefaultAccessLogReceiver(DefaultServer.getWorker(), logDirectory, ""server"");
+        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, logReceiver, ""Remote address %a Code %s test-header %{test-header}i"", DefaultAccessLogTokens.INSTANCE));
+        TestHttpClient client = new TestHttpClient();
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            get.addHeader(""test-header"", ""v1"");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            Assert.assertEquals(""Hello"", HttpClientUtils.readResponse(result));
+            logReceiver.awaitWrittenForTest();
+            Assert.assertEquals(""Remote address 127.0.0.1 Code 200 test-header v1\n"", FileUtils.readFile(logFileName));
+            logReceiver.rotate();
+            logReceiver.awaitWrittenForTest();
+            Assert.assertFalse(logFileName.exists());
+            File firstLogRotate = new File(logDirectory, ""server_"" + new SimpleDateFormat(""yyyy-MM-dd"").format(new Date()) + "".log"");
+            Assert.assertEquals(""Remote address 127.0.0.1 Code 200 test-header v1\n"", FileUtils.readFile(firstLogRotate));
+
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + ""/path"");
+            get.addHeader(""test-header"", ""v2"");
+            result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            Assert.assertEquals(""Hello"", HttpClientUtils.readResponse(result));
+            logReceiver.awaitWrittenForTest();
+            Assert.assertEquals(""Remote address 127.0.0.1 Code 200 test-header v2\n"", FileUtils.readFile(logFileName));
+            logReceiver.rotate();
+            logReceiver.awaitWrittenForTest();
+            Assert.assertFalse(logFileName.exists());
+            File secondLogRotate = new File(logDirectory, ""server_"" + new SimpleDateFormat(""yyyy-MM-dd"").format(new Date()) + ""-1.log"");
+            Assert.assertEquals(""Remote address 127.0.0.1 Code 200 test-header v2\n"", FileUtils.readFile(secondLogRotate));
+
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+
+}",2013-06-25T03:10:07Z,312
"@@ -85,28 +85,26 @@ public static String readFile(InputStream file) {
     }
 
 
-
-
-    public static File getFileOrCheckParentsIfNotFound( String baseStr, String path ) throws FileNotFoundException {
+    public static File getFileOrCheckParentsIfNotFound(String baseStr, String path) throws FileNotFoundException {
         //File f = new File( System.getProperty(""jbossas.project.dir"", ""../../.."") );
-        File base = new File( baseStr );
-        if( ! base.exists() ){
-            throw new FileNotFoundException( ""Base path not found: "" + base.getPath() );
+        File base = new File(baseStr);
+        if (!base.exists()) {
+            throw new FileNotFoundException(""Base path not found: "" + base.getPath());
         }
         base = base.getAbsoluteFile();
 
-        File f = new File( base, path );
-        if ( f.exists() )
+        File f = new File(base, path);
+        if (f.exists())
             return f;
 
         File fLast = f;
-        while( ! f.exists() ){
-            int slash = path.lastIndexOf( File.separatorChar );
-            if( slash <= 0 )  // no slash or ""/xxx""
+        while (!f.exists()) {
+            int slash = path.lastIndexOf(File.separatorChar);
+            if (slash <= 0)  // no slash or ""/xxx""
                 throw new FileNotFoundException(""Path not found: "" + f.getPath());
-            path = path.substring( 0, slash );
+            path = path.substring(0, slash);
             fLast = f;
-            f = new File( base, path );
+            f = new File(base, path);
         }
         // When first existing is found, report the last non-existent.
         throw new FileNotFoundException(""Path not found: "" + fLast.getPath());
@@ -144,5 +142,14 @@ public static void close(Closeable closeable) {
         }
     }
 
+    public static void deleteRecursive(final File file) {
+        File[] files = file.listFiles();
+        if (files != null) {
+            for (File f : files) {
+                deleteRecursive(f);
+            }
+        }
+        file.delete();
+    }
 
 }",2013-06-25T03:10:07Z,81
"@@ -216,19 +216,25 @@ private static class SessionImpl implements Session {
         private String sessionId;
         private volatile Object evictionToken;
         private final SessionConfig sessionCookieConfig;
+        private volatile long expireTime = -1;
 
         final XnioExecutor executor;
         final XnioWorker worker;
 
-        XnioExecutor.Key cancelKey;
+        XnioExecutor.Key timerCancelKey;
 
         Runnable cancelTask = new Runnable() {
             @Override
             public void run() {
                 worker.execute(new Runnable() {
                     @Override
                     public void run() {
-                        invalidate(null, SessionListener.SessionDestroyedReason.TIMEOUT);
+                        long currentTime = System.currentTimeMillis();
+                        if(currentTime >= expireTime) {
+                            invalidate(null, SessionListener.SessionDestroyedReason.TIMEOUT);
+                        } else {
+                            timerCancelKey = executor.executeAfter(cancelTask, expireTime - currentTime, TimeUnit.MILLISECONDS);
+                        }
                     }
                 });
             }
@@ -244,14 +250,16 @@ private SessionImpl(InMemorySessionManager sessionManager, final String sessionI
         }
 
         synchronized void bumpTimeout() {
-            if (cancelKey != null) {
-                if (!cancelKey.remove()) {
-                    return;
+            final int maxInactiveInterval = getMaxInactiveInterval();
+            if (maxInactiveInterval > 0) {
+                expireTime = System.currentTimeMillis() + (maxInactiveInterval * 1000);
+                if(timerCancelKey == null) {
+                    //+1 second, to make sure that the time has actually expired
+                    //we don't re-schedule every time, as it is expensive
+                    //instead when it expires we check if the timeout has been bumped, and if so we re-schedule
+                    timerCancelKey = executor.executeAfter(cancelTask, maxInactiveInterval + 1, TimeUnit.SECONDS);
                 }
             }
-            if (getMaxInactiveInterval() > 0) {
-                cancelKey = executor.executeAfter(cancelTask, getMaxInactiveInterval(), TimeUnit.SECONDS);
-            }
             if (evictionToken != null) {
                 Object token = evictionToken;
                 if (evictionTokenUpdater.compareAndSet(this, token, null)) {
@@ -366,8 +374,8 @@ public void invalidate(final HttpServerExchange exchange) {
         }
 
         synchronized void invalidate(final HttpServerExchange exchange, SessionListener.SessionDestroyedReason reason) {
-            if (cancelKey != null) {
-                cancelKey.remove();
+            if (timerCancelKey != null) {
+                timerCancelKey.remove();
             }
             InMemorySession sess = sessionManager.sessions.get(sessionId);
             if (sess == null) {
@@ -402,8 +410,8 @@ public String changeSessionId(final HttpServerExchange exchange, final SessionCo
         }
 
         private synchronized void destroy() {
-            if (cancelKey != null) {
-                cancelKey.remove();
+            if (timerCancelKey != null) {
+                timerCancelKey.remove();
             }
             cancelTask = null;
         }",2014-06-06T13:48:38Z,13
"@@ -10,6 +10,7 @@
 import org.xnio.StreamConnection;
 import org.xnio.XnioWorker;
 import org.xnio.http.HttpUpgrade;
+import org.xnio.ssl.XnioSsl;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -28,7 +29,16 @@ public static IoFuture<WebSocketChannel> connect(XnioWorker worker, final Pool<B
         return connect(worker, bufferPool, optionMap, uri, version, null);
     }
 
+    public static IoFuture<WebSocketChannel> connect(XnioWorker worker, XnioSsl ssl, final Pool<ByteBuffer> bufferPool, final OptionMap optionMap, final URI uri, WebSocketVersion version) {
+        return connect(worker, ssl, bufferPool, optionMap, uri, version, null);
+    }
+
     public static IoFuture<WebSocketChannel> connect(XnioWorker worker, final Pool<ByteBuffer> bufferPool, final OptionMap optionMap, final URI uri, WebSocketVersion version, WebSocketClientNegotiation clientNegotiation) {
+        return connect(worker, null, bufferPool, optionMap, uri, version, clientNegotiation);
+    }
+
+    public static IoFuture<WebSocketChannel> connect(XnioWorker worker, XnioSsl ssl, final Pool<ByteBuffer> bufferPool, final OptionMap optionMap, final URI uri, WebSocketVersion version, WebSocketClientNegotiation clientNegotiation) {
+
         final FutureResult<WebSocketChannel> ioFuture = new FutureResult<WebSocketChannel>();
         final URI newUri;
         try {
@@ -38,16 +48,27 @@ public static IoFuture<WebSocketChannel> connect(XnioWorker worker, final Pool<B
         }
         final WebSocketClientHandshake handshake = WebSocketClientHandshake.create(version, newUri, clientNegotiation);
         final Map<String, String> headers = handshake.createHeaders();
-        if(clientNegotiation != null) {
+        if (clientNegotiation != null) {
             clientNegotiation.beforeRequest(headers);
         }
-        IoFuture<StreamConnection> result = HttpUpgrade.performUpgrade(worker, null, newUri, headers, new ChannelListener<StreamConnection>() {
-            @Override
-            public void handleEvent(StreamConnection channel) {
-                WebSocketChannel result = handshake.createChannel(channel, newUri.toString(), bufferPool);
-                ioFuture.setResult(result);
-            }
-        }, null, optionMap, handshake.handshakeChecker(newUri, headers));
+        IoFuture<? extends StreamConnection> result;
+        if (ssl == null) {
+            result = HttpUpgrade.performUpgrade(worker, ssl, null, newUri, headers, new ChannelListener<StreamConnection>() {
+                @Override
+                public void handleEvent(StreamConnection channel) {
+                    WebSocketChannel result = handshake.createChannel(channel, newUri.toString(), bufferPool);
+                    ioFuture.setResult(result);
+                }
+            }, null, optionMap, handshake.handshakeChecker(newUri, headers));
+        } else {
+            result = HttpUpgrade.performUpgrade(worker, null, newUri, headers, new ChannelListener<StreamConnection>() {
+                @Override
+                public void handleEvent(StreamConnection channel) {
+                    WebSocketChannel result = handshake.createChannel(channel, newUri.toString(), bufferPool);
+                    ioFuture.setResult(result);
+                }
+            }, null, optionMap, handshake.handshakeChecker(newUri, headers));
+        }
         result.addNotifier(new IoFuture.Notifier<StreamConnection, Object>() {
             @Override
             public void notify(IoFuture<? extends StreamConnection> res, Object attachment) {",2014-04-16T08:28:34Z,326
"@@ -38,12 +38,13 @@ public void handleDeployment(DeploymentInfo deploymentInfo, ServletContext servl
         setup.add(new ContextClassLoaderSetupAction(deploymentInfo.getClassLoader()));
         setup.addAll(deploymentInfo.getThreadSetupActions());
         final CompositeThreadSetupAction threadSetupAction = new CompositeThreadSetupAction(setup);
-        ServerWebSocketContainer container = new ServerWebSocketContainer(deploymentInfo.getClassIntrospecter(), info.getWorker(), info.getBuffers(), threadSetupAction, false);
+        ServerWebSocketContainer container = new ServerWebSocketContainer(deploymentInfo.getClassIntrospecter(), servletContext.getClassLoader(), info.getWorker(), info.getBuffers(), threadSetupAction, false);
+
         try {
             for (Class<?> annotation : info.getAnnotatedEndpoints()) {
                 container.addEndpoint(annotation);
             }
-            for(ServerEndpointConfig programatic : info.getProgramaticEndpoints()) {
+            for (ServerEndpointConfig programatic : info.getProgramaticEndpoints()) {
                 container.addEndpoint(programatic);
             }
         } catch (DeploymentException e) {
@@ -63,7 +64,7 @@ public void contextInitialized(ServletContextEvent sce) {
             ServerWebSocketContainer container = (ServerWebSocketContainer) sce.getServletContext().getAttribute(ServerContainer.class.getName());
             FilterRegistration.Dynamic filter = sce.getServletContext().addFilter(FILTER_NAME, JsrWebSocketFilter.class);
             filter.setAsyncSupported(true);
-            if(!container.getConfiguredServerEndpoints().isEmpty()){
+            if (!container.getConfiguredServerEndpoints().isEmpty()) {
                 filter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, ""/*"");
             } else {
                 container.setContextToAddFilter((ServletContextImpl) sce.getServletContext());",2014-04-16T08:28:34Z,433
"@@ -0,0 +1,67 @@
+package io.undertow.websockets.jsr;
+
+import org.xnio.OptionMap;
+import org.xnio.XnioWorker;
+import org.xnio.ssl.JsseXnioSsl;
+import org.xnio.ssl.XnioSsl;
+
+import javax.net.ssl.SSLContext;
+import javax.websocket.ClientEndpointConfig;
+import javax.websocket.Endpoint;
+import java.net.URI;
+
+/**
+ * Client SSL provider that gets the SSL context in one of two ways.
+ *
+ * Either the {@link #setSslContext(javax.net.ssl.SSLContext)} method can
+ * be invoked before connecting, and this context will be used for the next
+ * client connection from this thread, or alternatively the
+ * io.undertow.websocket.SSL_CONTEXT property can be set in the user properties
+ * of the ClientEndpointConfig.
+ *
+ * @author Stuart Douglas
+ */
+public class DefaultWebSocketClientSslProvider implements WebsocketClientSslProvider {
+
+    public static final String SSL_CONTEXT = ""io.undertow.websocket.SSL_CONTEXT"";
+
+    private static final ThreadLocal<SSLContext> LOCAL_SSL_CONTEXT = new ThreadLocal<SSLContext>();
+
+    @Override
+    public XnioSsl getSsl(XnioWorker worker, Class<?> annotatedEndpoint, URI uri) {
+        return getThreadLocalSsl(worker);
+    }
+
+    @Override
+    public XnioSsl getSsl(XnioWorker worker, Object annotatedEndpointInstance, URI uri) {
+        return getThreadLocalSsl(worker);
+    }
+
+    @Override
+    public XnioSsl getSsl(XnioWorker worker, Endpoint endpoint, ClientEndpointConfig cec, URI uri) {
+        XnioSsl ssl =  getThreadLocalSsl(worker);
+        if(ssl != null) {
+            return ssl;
+        }
+        //look for some SSL config
+        SSLContext sslContext = (SSLContext) cec.getUserProperties().get(SSL_CONTEXT);
+
+        if (sslContext != null) {
+            return new JsseXnioSsl(worker.getXnio(), OptionMap.EMPTY, sslContext);
+        }
+        return null;
+    }
+
+    public static void setSslContext(final SSLContext context) {
+        LOCAL_SSL_CONTEXT.set(context);
+    }
+    private XnioSsl getThreadLocalSsl(XnioWorker worker) {
+        SSLContext val = LOCAL_SSL_CONTEXT.get();
+        if (val != null) {
+            LOCAL_SSL_CONTEXT.remove();
+            return new JsseXnioSsl(worker.getXnio(), OptionMap.EMPTY, val);
+        }
+        return null;
+    }
+
+}",2014-04-16T08:28:34Z,459
"@@ -34,6 +34,7 @@
 import org.xnio.OptionMap;
 import org.xnio.Pool;
 import org.xnio.XnioWorker;
+import org.xnio.ssl.XnioSsl;
 
 import javax.servlet.DispatcherType;
 import javax.websocket.ClientEndpoint;
@@ -56,6 +57,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.ServiceLoader;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.Executor;
@@ -68,6 +70,7 @@
  */
 public class ServerWebSocketContainer implements ServerContainer {
 
+
     private final ClassIntrospecter classIntrospecter;
 
     private final Map<Class<?>, ConfiguredClientEndpoint> clientEndpoints = new HashMap<Class<?>, ConfiguredClientEndpoint>();
@@ -94,13 +97,24 @@ public class ServerWebSocketContainer implements ServerContainer {
 
     private ServletContextImpl contextToAddFilter = null;
 
+    private final List<WebsocketClientSslProvider> clientSslProviders;
+
+    public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final XnioWorker xnioWorker, Pool<ByteBuffer> bufferPool, ThreadSetupAction threadSetupAction, boolean clientMode) {
+        this(classIntrospecter, ServerWebSocketContainer.class.getClassLoader(), xnioWorker, bufferPool, threadSetupAction, clientMode);
+    }
 
-    public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, XnioWorker xnioWorker, Pool<ByteBuffer> bufferPool, ThreadSetupAction threadSetupAction, boolean clientMode) {
+    public ServerWebSocketContainer(final ClassIntrospecter classIntrospecter, final ClassLoader classLoader, XnioWorker xnioWorker, Pool<ByteBuffer> bufferPool, ThreadSetupAction threadSetupAction,  boolean clientMode) {
         this.classIntrospecter = classIntrospecter;
         this.bufferPool = bufferPool;
         this.xnioWorker = xnioWorker;
         this.threadSetupAction = threadSetupAction;
         this.clientMode = clientMode;
+        List<WebsocketClientSslProvider> clientSslProviders = new ArrayList<WebsocketClientSslProvider>();
+        for (WebsocketClientSslProvider provider : ServiceLoader.load(WebsocketClientSslProvider.class, classLoader)) {
+            clientSslProviders.add(provider);
+        }
+
+        this.clientSslProviders = Collections.unmodifiableList(clientSslProviders);
     }
 
     @Override
@@ -120,7 +134,14 @@ public Session connectToServer(final Object annotatedEndpointInstance, final URI
             throw JsrWebSocketMessages.MESSAGES.notAValidClientEndpointType(annotatedEndpointInstance.getClass());
         }
         Endpoint instance = config.getFactory().createInstanceForExisting(annotatedEndpointInstance);
-        return connectToServerInternal(instance, config, path);
+        XnioSsl ssl = null;
+        for (WebsocketClientSslProvider provider : clientSslProviders) {
+            ssl = provider.getSsl(xnioWorker, annotatedEndpointInstance, path);
+            if (ssl != null) {
+                break;
+            }
+        }
+        return connectToServerInternal(instance, ssl, config, path);
     }
 
     @Override
@@ -131,7 +152,14 @@ public Session connectToServer(Class<?> aClass, URI uri) throws DeploymentExcept
         }
         try {
             InstanceHandle<Endpoint> instance = config.getFactory().createInstance();
-            return connectToServerInternal(instance.getInstance(), config, uri);
+            XnioSsl ssl = null;
+            for (WebsocketClientSslProvider provider : clientSslProviders) {
+                ssl = provider.getSsl(xnioWorker, aClass, uri);
+                if (ssl != null) {
+                    break;
+                }
+            }
+            return connectToServerInternal(instance.getInstance(), ssl, config, uri);
         } catch (InstantiationException e) {
             throw new RuntimeException(e);
         }
@@ -141,18 +169,26 @@ public Session connectToServer(Class<?> aClass, URI uri) throws DeploymentExcept
     public Session connectToServer(final Endpoint endpointInstance, final ClientEndpointConfig cec, final URI path) throws DeploymentException, IOException {
         //in theory we should not be able to connect until the deployment is complete, but the definition of when a deployment is complete is a bit nebulous.
         WebSocketClientNegotiation clientNegotiation = new ClientNegotiation(cec.getPreferredSubprotocols(), toExtensionList(cec.getExtensions()), cec);
-        IoFuture<WebSocketChannel> session = WebSocketClient.connect(xnioWorker, bufferPool, OptionMap.EMPTY, path, WebSocketVersion.V13, clientNegotiation);
+        XnioSsl ssl = null;
+        for (WebsocketClientSslProvider provider : clientSslProviders) {
+            ssl = provider.getSsl(xnioWorker, endpointInstance, cec, path);
+            if (ssl != null) {
+                break;
+            }
+        }
+
+        IoFuture<WebSocketChannel> session = WebSocketClient.connect(xnioWorker, ssl, bufferPool, OptionMap.EMPTY, path, WebSocketVersion.V13, clientNegotiation);
         WebSocketChannel channel = session.get();
         EndpointSessionHandler sessionHandler = new EndpointSessionHandler(this);
 
         final List<Extension> extensions = new ArrayList<Extension>();
         final Map<String, Extension> extMap = new HashMap<String, Extension>();
-        for(Extension ext : cec.getExtensions()) {
+        for (Extension ext : cec.getExtensions()) {
             extMap.put(ext.getName(), ext);
         }
-        for(WebSocketExtension e : clientNegotiation.getSelectedExtensions()) {
+        for (WebSocketExtension e : clientNegotiation.getSelectedExtensions()) {
             Extension ext = extMap.get(e.getName());
-            if(ext == null) {
+            if (ext == null) {
                 throw JsrWebSocketMessages.MESSAGES.extensionWasNotPresentInClientHandshake(e.getName(), clientNegotiation.getSupportedExtensions());
             }
             extensions.add(ExtensionImpl.create(e));
@@ -179,21 +215,23 @@ public Session connectToServer(final Class<? extends Endpoint> endpointClass, fi
         }
     }
 
-    private Session connectToServerInternal(final Endpoint endpointInstance, final ConfiguredClientEndpoint cec, final URI path) throws DeploymentException, IOException {
+    private Session connectToServerInternal(final Endpoint endpointInstance, XnioSsl ssl, final ConfiguredClientEndpoint cec, final URI path) throws DeploymentException, IOException {
         //in theory we should not be able to connect until the deployment is complete, but the definition of when a deployment is complete is a bit nebulous.
         WebSocketClientNegotiation clientNegotiation = new ClientNegotiation(cec.getConfig().getPreferredSubprotocols(), toExtensionList(cec.getConfig().getExtensions()), cec.getConfig());
-        IoFuture<WebSocketChannel> session = WebSocketClient.connect(xnioWorker, bufferPool, OptionMap.EMPTY, path, WebSocketVersion.V13, clientNegotiation); //TODO: fix this
+
+
+        IoFuture<WebSocketChannel> session = WebSocketClient.connect(xnioWorker, ssl, bufferPool, OptionMap.EMPTY, path, WebSocketVersion.V13, clientNegotiation); //TODO: fix this
         WebSocketChannel channel = session.get();
         EndpointSessionHandler sessionHandler = new EndpointSessionHandler(this);
 
         final List<Extension> extensions = new ArrayList<Extension>();
         final Map<String, Extension> extMap = new HashMap<String, Extension>();
-        for(Extension ext : cec.getConfig().getExtensions()) {
+        for (Extension ext : cec.getConfig().getExtensions()) {
             extMap.put(ext.getName(), ext);
         }
-        for(WebSocketExtension e : clientNegotiation.getSelectedExtensions()) {
+        for (WebSocketExtension e : clientNegotiation.getSelectedExtensions()) {
             Extension ext = extMap.get(e.getName());
-            if(ext == null) {
+            if (ext == null) {
                 throw JsrWebSocketMessages.MESSAGES.extensionWasNotPresentInClientHandshake(e.getName(), clientNegotiation.getSupportedExtensions());
             }
             extensions.add(ExtensionImpl.create(e));
@@ -424,9 +462,9 @@ public <T> T getEndpointInstance(final Class<T> endpointClass) throws Instantiat
 
     private static List<WebSocketExtension> toExtensionList(final List<Extension> extensions) {
         List<WebSocketExtension> ret = new ArrayList<WebSocketExtension>();
-        for(Extension e : extensions) {
+        for (Extension e : extensions) {
             final List<WebSocketExtension.Parameter> parameters = new ArrayList<WebSocketExtension.Parameter>();
-            for(Extension.Parameter p : e.getParameters()) {
+            for (Extension.Parameter p : e.getParameters()) {
                 parameters.add(new WebSocketExtension.Parameter(p.getName(), p.getValue()));
             }
             ret.add(new WebSocketExtension(e.getName(), parameters));
@@ -447,9 +485,9 @@ public ClientNegotiation(List<String> supportedSubProtocols, List<WebSocketExten
         public void afterRequest(final Map<String, String> headers) {
 
             ClientEndpointConfig.Configurator configurator = config.getConfigurator();
-            if(configurator != null) {
+            if (configurator != null) {
                 final Map<String, List<String>> newHeaders = new HashMap<String, List<String>>();
-                for(Map.Entry<String, String> entry : headers.entrySet()) {
+                for (Map.Entry<String, String> entry : headers.entrySet()) {
                     ArrayList<String> arrayList = new ArrayList<String>();
                     arrayList.add(entry.getValue());
                     newHeaders.put(entry.getKey(), arrayList);
@@ -466,17 +504,17 @@ public Map<String, List<String>> getHeaders() {
         @Override
         public void beforeRequest(Map<String, String> headers) {
             ClientEndpointConfig.Configurator configurator = config.getConfigurator();
-            if(configurator != null) {
+            if (configurator != null) {
                 final Map<String, List<String>> newHeaders = new HashMap<String, List<String>>();
-                for(Map.Entry<String, String> entry : headers.entrySet()) {
+                for (Map.Entry<String, String> entry : headers.entrySet()) {
                     ArrayList<String> arrayList = new ArrayList<String>();
                     arrayList.add(entry.getValue());
                     newHeaders.put(entry.getKey(), arrayList);
                 }
                 configurator.beforeRequest(newHeaders);
                 headers.clear(); //TODO: more efficient way
-                for(Map.Entry<String, List<String>> entry : newHeaders.entrySet()) {
-                    if(!entry.getValue().isEmpty()) {
+                for (Map.Entry<String, List<String>> entry : newHeaders.entrySet()) {
+                    if (!entry.getValue().isEmpty()) {
                         headers.put(entry.getKey(), entry.getValue().get(0));
                     }
                 }",2014-04-16T08:28:34Z,319
"@@ -67,7 +67,8 @@ private WebSocketContainer getDefaultContainer() {
                     //todo: what options should we use here?
                     XnioWorker worker = Xnio.getInstance().createWorker(OptionMap.create(Options.THREAD_DAEMON, true));
                     Pool<ByteBuffer> buffers = new ByteBufferSlicePool(1024, 10240);
-                    defaultContainer = new ServerWebSocketContainer(DefaultClassIntrospector.INSTANCE, worker, buffers, new CompositeThreadSetupAction(Collections.<ThreadSetupAction>emptyList()), true);
+                    defaultContainer = new ServerWebSocketContainer(DefaultClassIntrospector.INSTANCE, UndertowContainerProvider.class.getClassLoader(), worker, buffers, new CompositeThreadSetupAction(Collections.<ThreadSetupAction>emptyList()), true);
+
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }",2014-04-16T08:28:34Z,460
"@@ -0,0 +1,24 @@
+package io.undertow.websockets.jsr;
+
+import org.xnio.XnioWorker;
+import org.xnio.ssl.XnioSsl;
+
+import javax.websocket.ClientEndpointConfig;
+import javax.websocket.Endpoint;
+import java.net.URI;
+
+/**
+ * Interface that is loaded from a service loader, that allows
+ * you to configure SSL for web socket client connections.
+ *
+ * @author Stuart Douglas
+ */
+public interface WebsocketClientSslProvider {
+
+    XnioSsl getSsl(XnioWorker worker, final Class<?> annotatedEndpoint, URI uri);
+
+    XnioSsl getSsl(XnioWorker worker, final Object annotatedEndpointInstance, URI uri);
+
+    XnioSsl getSsl(XnioWorker worker, final Endpoint endpoint, final ClientEndpointConfig cec, URI uri);
+
+}",2014-04-16T08:28:34Z,461
"@@ -0,0 +1 @@
+io.undertow.websockets.jsr.DefaultWebSocketSslProvider
\ No newline at end of file",2014-04-16T08:28:34Z,462
"@@ -269,4 +269,10 @@ public interface UndertowMessages {
 
     @Message(id = 81, value = ""Bad request"")
     RuntimeException badRequest();
+
+    @Message(id = 82, value = ""Host %s already registered"")
+    RuntimeException hostAlreadyRegistered(Object host);
+
+    @Message(id = 83, value = ""Host %s has not been registered"")
+    RuntimeException hostHasNotBeenRegistered(Object host);
 }",2014-01-09T17:21:19Z,68
"@@ -46,7 +46,7 @@ public PathHandler() {
 
     @Override
     public void handleRequest(HttpServerExchange exchange) throws Exception {
-        final PathMatcher.PathMatch<HttpHandler> match = pathMatcher.match(exchange);
+        final PathMatcher.PathMatch<HttpHandler> match = pathMatcher.match(exchange.getRelativePath());
         if(match.getValue() == null) {
             ResponseCodeHandler.HANDLE_404.handleRequest(exchange);
             return;",2014-01-09T17:21:19Z,88
"@@ -0,0 +1,122 @@
+package io.undertow.server.handlers.proxy;
+
+import io.undertow.UndertowMessages;
+import io.undertow.util.CopyOnWriteMap;
+import io.undertow.util.PathMatcher;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/**
+ * Class that maintains a table of remote hosts that this proxy knows about.
+ *
+ * Basically this maps a virtual host + context path pair to a set of hosts.
+ *
+ * Note that this class does not have any knowledge of connection pooling
+ *
+ * @author Stuart Douglas
+ */
+public class HostTable<H> {
+
+    private final Map<H, Set<Target>> hosts = new CopyOnWriteMap<H, Set<Target>>();
+    private final Map<String, PathMatcher<Set<H>>> targets = new CopyOnWriteMap<String, PathMatcher<Set<H>>>();
+
+    public synchronized HostTable addHost(H host) {
+        if(hosts.containsKey(host)) {
+            throw UndertowMessages.MESSAGES.hostAlreadyRegistered(host);
+        }
+        hosts.put(host, new CopyOnWriteArraySet<Target>());
+        return this;
+    }
+
+    public synchronized HostTable removeHost(H host) {
+        Set<Target> targets = hosts.remove(host);
+        for(Target target : targets) {
+            removeRoute(host, target.virtualHost, target.contextPath);
+        }
+        return this;
+    }
+
+    public synchronized HostTable addRoute(H host, String virtualHost, String contextPath) {
+        Set<Target> hostData = hosts.get(host);
+        if(hostData == null) {
+            throw UndertowMessages.MESSAGES.hostHasNotBeenRegistered(host);
+        }
+        hostData.add(new Target(virtualHost, contextPath));
+        PathMatcher<Set<H>> paths = targets.get(virtualHost);
+        if(paths == null) {
+            paths = new PathMatcher<Set<H>>();
+            targets.put(virtualHost, paths);
+        }
+        Set<H> hostSet = paths.getPrefixPath(contextPath);
+        if(hostSet == null) {
+            hostSet = new CopyOnWriteArraySet<H>();
+            paths.addPrefixPath(contextPath, hostSet);
+        }
+        hostSet.add(host);
+        return this;
+    }
+
+    public synchronized HostTable removeRoute(H host, String virtualHost, String contextPath) {
+
+        Set<Target> hostData = hosts.get(host);
+        if(hostData != null) {
+            hostData.remove(new Target(virtualHost, contextPath));
+        }
+        PathMatcher<Set<H>> paths = targets.get(virtualHost);
+        if(paths == null) {
+            return this;
+        }
+        Set<H> hostSet = paths.getPrefixPath(contextPath);
+        if(hostSet == null) {
+            return this;
+        }
+        hostSet.remove(host);
+        if(hostSet.isEmpty()) {
+            paths.removePrefixPath(contextPath);
+        }
+        return this;
+    }
+
+    public Set<H> getHostsForTarget(final String hostName, final String path) {
+        PathMatcher<Set<H>> matcher = targets.get(hostName);
+        if(matcher == null) {
+            return null;
+        }
+        return matcher.match(path).getValue();
+    }
+
+    private static final class Target {
+        final String virtualHost;
+        final String contextPath;
+
+        private Target(String virtualHost, String contextPath) {
+            this.virtualHost = virtualHost;
+            this.contextPath = contextPath;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            Target target = (Target) o;
+
+            if (contextPath != null ? !contextPath.equals(target.contextPath) : target.contextPath != null)
+                return false;
+            if (virtualHost != null ? !virtualHost.equals(target.virtualHost) : target.virtualHost != null)
+                return false;
+
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = virtualHost != null ? virtualHost.hashCode() : 0;
+            result = 31 * result + (contextPath != null ? contextPath.hashCode() : 0);
+            return result;
+        }
+    }
+
+}",2014-01-09T17:21:19Z,6
"@@ -19,7 +19,6 @@
 package io.undertow.util;
 
 import io.undertow.UndertowMessages;
-import io.undertow.server.HttpServerExchange;
 
 import java.util.Collections;
 import java.util.Comparator;
@@ -58,11 +57,10 @@ public PathMatcher() {
 
     /**
      * Matches a path against the registered handlers.
-     * @param exchange The exchange
+     * @param path The relative path to match
      * @return The match match. This will never be null, however if none matched its value field will be
      */
-    public PathMatch<T> match(HttpServerExchange exchange){
-        final String path = exchange.getRelativePath();
+    public PathMatch<T> match(String path){
         if (!exactPathMatches.isEmpty()) {
             T match = exactPathMatches.get(path);
             if (match != null) {
@@ -90,7 +88,7 @@ public PathMatch<T> match(HttpServerExchange exchange){
                 }
             }
         }
-        return new PathMatch<T>(exchange.getRelativePath(), defaultHandler);
+        return new PathMatch<T>(path, defaultHandler);
     }
 
     /**
@@ -135,6 +133,22 @@ public synchronized PathMatcher addExactPath(final String path, final T handler)
         return this;
     }
 
+    public T getExactPath(final String path) {
+        if (path.charAt(0) != '/') {
+            return exactPathMatches.get(""/"" + path);
+        } else {
+            return exactPathMatches.get(path);
+        }
+    }
+
+    public T getPrefixPath(final String path) {
+        if (path.charAt(0) != '/') {
+            return paths.get(""/"" + path);
+        } else {
+            return paths.get(path);
+        }
+    }
+
     private void buildLengths() {
         final Set<Integer> lengths = new TreeSet<Integer>(new Comparator<Integer>() {
             @Override",2014-01-09T17:21:19Z,463
"@@ -152,8 +152,8 @@ private static void runInternal(final RunNotifier notifier) {
                         .set(Options.WORKER_READ_THREADS, 4)
                         .set(Options.CONNECTION_HIGH_WATER, 1000000)
                         .set(Options.CONNECTION_LOW_WATER, 1000000)
-                        .set(Options.WORKER_TASK_CORE_THREADS, 10)
-                        .set(Options.WORKER_TASK_MAX_THREADS, 12)
+                        .set(Options.WORKER_TASK_CORE_THREADS, 30)
+                        .set(Options.WORKER_TASK_MAX_THREADS, 30)
                         .set(Options.TCP_NODELAY, true)
                         .set(Options.CORK, true)
                         .getMap());",2013-01-14T02:29:45Z,76
"@@ -1,170 +0,0 @@
-package io.undertow.servlet.core;
-
-import java.io.PrintStream;
-import java.io.UnsupportedEncodingException;
-import java.util.Locale;
-
-import io.undertow.servlet.spec.ServletOutputStreamImpl;
-
-/**
- * Real servlet print writer functionality, that is not limited by extending
- * {@link java.io.PrintWriter}
- *
- * TODO: we really need to fix this, atm we need to flush every write so that we know when the response is complete
- * we can't just count the bytes because we don't know how they are going to be encoded
- *
- * @author Stuart Douglas
- */
-public class ServletPrintWriter {
-
-    private final PrintStream printStream;
-    private final Integer contentLength;
-
-    public ServletPrintWriter(final ServletOutputStreamImpl printStream, final String charset, final Integer contentLength) throws UnsupportedEncodingException {
-        this.contentLength = contentLength;
-        this.printStream = new PrintStream(printStream, false, charset);
-    }
-
-    public void flush() {
-        printStream.flush();
-    }
-
-    public void close() {
-        printStream.close();
-    }
-
-    public boolean checkError() {
-        return printStream.checkError();
-    }
-
-    public void write(final int c) {
-        printStream.write(c);
-    }
-
-    public void write(final char[] buf, final int off, final int len) {
-        printStream.append(new String(buf), off, len);
-    }
-
-    public void write(final char[] buf) {
-        printStream.append(new String(buf));
-    }
-
-    public void write(final String s, final int off, final int len) {
-        printStream.append(s, off, len);
-    }
-
-    public void write(final String s) {
-        printStream.append(s);
-    }
-
-    public void print(final boolean b) {
-        printStream.print(b);
-    }
-
-    public void print(final char c) {
-        printStream.print(c);
-    }
-
-    public void print(final int i) {
-        printStream.print(i);
-    }
-
-    public void print(final long l) {
-        printStream.print(l);
-    }
-
-    public void print(final float f) {
-        printStream.print(f);
-    }
-
-    public void print(final double d) {
-        printStream.print(d);
-    }
-
-    public void print(final char[] s) {
-        printStream.print(s);
-    }
-
-    public void print(final String s) {
-        printStream.print(s);
-    }
-
-    public void print(final Object obj) {
-        printStream.print(obj);
-    }
-
-    public void println() {
-        printStream.println();
-    }
-
-    public void println(final boolean x) {
-        printStream.println(x);
-    }
-
-    public void println(final char x) {
-        printStream.println(x);
-    }
-
-    public void println(final int x) {
-        printStream.println(x);
-    }
-
-    public void println(final long x) {
-        printStream.println(x);
-    }
-
-    public void println(final float x) {
-        printStream.println(x);
-    }
-
-    public void println(final double x) {
-        printStream.println(x);
-    }
-
-    public void println(final char[] x) {
-        printStream.println(x);
-    }
-
-    public void println(final String x) {
-        printStream.println(x);
-    }
-
-    public void println(final Object x) {
-        printStream.println(x);
-    }
-
-    public void printf(final String format, final Object... args) {
-        printStream.printf(format, args);
-    }
-
-
-    public void printf(final Locale l, final String format, final Object... args) {
-        printStream.printf(l, format, args);
-    }
-
-
-    public void format(final String format, final Object... args) {
-        printStream.format(format, args);
-    }
-
-
-    public void format(final Locale l, final String format, final Object... args) {
-        printStream.format(l, format, args);
-    }
-
-
-    public void append(final CharSequence csq) {
-        printStream.append(csq);
-    }
-
-
-    public void append(final CharSequence csq, final int start, final int end) {
-        printStream.append(csq, start, end);
-    }
-
-
-    public void append(final char c) {
-        printStream.append(c);
-    }
-
-}",2013-01-14T02:29:45Z,67
"@@ -38,8 +38,6 @@
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
 import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.core.ServletPrintWriter;
-import io.undertow.servlet.core.ServletPrintWriterDelegate;
 import io.undertow.servlet.handlers.ServletAttachments;
 import io.undertow.util.AttachmentKey;
 import io.undertow.util.AttachmentList;",2013-01-14T02:29:45Z,170
"@@ -123,14 +123,29 @@ public void write(final byte[] b, final int off, final int len) throws IOExcepti
         updateWritten(len);
     }
 
-    private void updateWritten(final int len) throws IOException {
+    void updateWritten(final int len) throws IOException {
         this.written += len;
         if (contentLength != null && this.written >= contentLength) {
             flush();
             close();
         }
     }
 
+    /**
+     * Returns the underlying buffer. If this has not been created yet then
+     * it is created.
+     *
+     * Callers that use this method must call {@link #updateWritten(int)} to update the written
+     * amount.
+     *
+     * This allows the buffer to be filled directly, which can be more efficient.
+     *
+     * @return The underlying buffer
+     */
+    ByteBuffer underlyingBuffer() {
+        return buffer();
+    }
+
     /**
      * {@inheritDoc}
      */",2013-01-14T02:29:45Z,193
"@@ -0,0 +1,224 @@
+package io.undertow.servlet.spec;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
+import java.util.Locale;
+
+/**
+ * Real servlet print writer functionality, that is not limited by extending
+ * {@link java.io.PrintWriter}
+ * <p/>
+ *
+ * @author Stuart Douglas
+ */
+public class ServletPrintWriter {
+
+    private final ServletOutputStreamImpl outputStream;
+    private final Integer contentLength;
+    private final CharsetEncoder charsetEncoder;
+    private boolean error = false;
+
+    public ServletPrintWriter(final ServletOutputStreamImpl outputStream, final String charset, final Integer contentLength) throws UnsupportedEncodingException {
+        this.contentLength = contentLength;
+        this.outputStream = outputStream;
+        this.charsetEncoder = Charset.forName(charset).newEncoder();
+    }
+
+    public void flush() {
+        try {
+            outputStream.flush();
+        } catch (IOException e) {
+            error = true;
+        }
+    }
+
+    public void close() {
+        try {
+            outputStream.close();
+        } catch (IOException e) {
+            error = true;
+        }
+    }
+
+    public boolean checkError() {
+        return error;
+    }
+
+    private void doWrite(final CharBuffer cb) {
+        ByteBuffer buffer = outputStream.underlyingBuffer();
+        try {
+            if (!buffer.hasRemaining()) {
+                outputStream.flush();
+            }
+            while (cb.hasRemaining()) {
+                int remaining = buffer.remaining();
+                CoderResult result = charsetEncoder.encode(cb, buffer, false);
+                outputStream.updateWritten(remaining - buffer.remaining());
+                if(result.isOverflow()) {
+                    outputStream.flush();
+                }
+            }
+        } catch (IOException e) {
+            error = true;
+        }
+    }
+
+    public void write(final int c) {
+        final CharBuffer cb = CharBuffer.wrap(Character.toString((char)c));
+        doWrite(cb);
+    }
+
+    public void write(final char[] buf, final int off, final int len) {
+        final CharBuffer cb = CharBuffer.wrap(buf, off, len);
+        doWrite(cb);
+    }
+
+    public void write(final char[] buf) {
+        final CharBuffer cb = CharBuffer.wrap(buf);
+        doWrite(cb);
+    }
+
+    public void write(final String s, final int off, final int len) {
+        final CharBuffer cb = CharBuffer.wrap(s, off, len);
+        doWrite(cb);
+    }
+
+    public void write(final String s) {
+        final CharBuffer cb = CharBuffer.wrap(s);
+        doWrite(cb);
+    }
+
+    public void print(final boolean b) {
+        final CharBuffer cb = CharBuffer.wrap(Boolean.toString(b));
+        doWrite(cb);
+    }
+
+    public void print(final char c) {
+        final CharBuffer cb = CharBuffer.wrap(Character.toString(c));
+        doWrite(cb);
+    }
+
+    public void print(final int i) {
+        final CharBuffer cb = CharBuffer.wrap(Integer.toString(i));
+        doWrite(cb);
+    }
+
+    public void print(final long l) {
+        final CharBuffer cb = CharBuffer.wrap(Long.toString(l));
+        doWrite(cb);
+    }
+
+    public void print(final float f) {
+        final CharBuffer cb = CharBuffer.wrap(Float.toString(f));
+        doWrite(cb);
+    }
+
+    public void print(final double d) {
+        final CharBuffer cb = CharBuffer.wrap(Double.toString(d));
+        doWrite(cb);
+    }
+
+    public void print(final char[] s) {
+        final CharBuffer cb = CharBuffer.wrap(s);
+        doWrite(cb);
+    }
+
+    public void print(final String s) {
+        final CharBuffer cb = CharBuffer.wrap(s);
+        doWrite(cb);
+    }
+
+    public void print(final Object obj) {
+        final CharBuffer cb = CharBuffer.wrap(obj == null ? ""null"" : obj.toString());
+        doWrite(cb);
+    }
+
+    public void println() {
+        final CharBuffer cb = CharBuffer.wrap(""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final boolean b) {
+        final CharBuffer cb = CharBuffer.wrap(Boolean.toString(b) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final char c) {
+        final CharBuffer cb = CharBuffer.wrap(Character.toString(c) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final int i) {
+        final CharBuffer cb = CharBuffer.wrap(Integer.toString(i) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final long l) {
+        final CharBuffer cb = CharBuffer.wrap(Long.toString(l) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final float f) {
+        final CharBuffer cb = CharBuffer.wrap(Float.toString(f) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final double d) {
+        final CharBuffer cb = CharBuffer.wrap(Double.toString(d) + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final char[] s) {
+        final CharBuffer cb = CharBuffer.wrap(s + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final String s) {
+        final CharBuffer cb = CharBuffer.wrap(s + ""\n"");
+        doWrite(cb);
+    }
+
+    public void println(final Object obj) {
+        final CharBuffer cb = CharBuffer.wrap(obj == null ? ""null\n"" : (obj.toString() + ""\n""));
+        doWrite(cb);
+    }
+
+    public void printf(final String format, final Object... args) {
+        print(String.format(format, args));
+    }
+
+    public void printf(final Locale l, final String format, final Object... args) {
+        print(String.format(l, format, args));
+    }
+
+
+    public void format(final String format, final Object... args) {
+        printf(format, args);
+    }
+
+    public void format(final Locale l, final String format, final Object... args) {
+        printf(l, format, args);
+    }
+
+    public void append(final CharSequence csq) {
+        if (csq == null)
+            write(""null"");
+        else
+            write(csq.toString());
+    }
+
+    public void append(final CharSequence csq, final int start, final int end) {
+        CharSequence cs = (csq == null ? ""null"" : csq);
+        write(cs.subSequence(start, end).toString());
+    }
+
+    public void append(final char c) {
+        write(c);
+    }
+
+}",2013-01-14T02:29:45Z,67
"@@ -1,4 +1,4 @@
-package io.undertow.servlet.core;
+package io.undertow.servlet.spec;
 
 import java.io.OutputStream;
 import java.io.PrintWriter;",2013-01-14T02:29:45Z,8
"@@ -148,7 +148,7 @@ public void dispatch() {
             ServletContainer container = deployment.getServletContainer();
             final String requestURI = ((HttpServletRequest) servletRequest).getRequestURI();
             DeploymentManager context = container.getDeploymentByPath(requestURI);
-            if(context == null) {
+            if (context == null) {
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
             String toDispatch = requestURI.substring(context.getDeployment().getServletContext().getContextPath().length());
@@ -162,7 +162,7 @@ public void dispatch() {
             //original request
             ServletContainer container = deployment.getServletContainer();
             DeploymentManager context = container.getDeploymentByPath(requestImpl.getOriginalContextPath());
-            if(context == null) {
+            if (context == null) {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
@@ -354,7 +354,7 @@ public void handleError(final Throwable error) {
         if (!dispatched) {
             servletRequest.setAttribute(RequestDispatcher.ERROR_EXCEPTION, error);
             try {
-                if(servletResponse instanceof HttpServletResponse) {
+                if (servletResponse instanceof HttpServletResponse) {
                     ((HttpServletResponse) servletResponse).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                 } else {
                     servletRequestContext.getOriginalResponse().sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
@@ -416,7 +416,7 @@ public void run() {
                     if (!dispatched) {
                         //servlet
                         try {
-                            if(servletResponse instanceof HttpServletResponse) {
+                            if (servletResponse instanceof HttpServletResponse) {
                                 ((HttpServletResponse) servletResponse).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                             } else {
                                 servletRequestContext.getOriginalResponse().sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
@@ -485,31 +485,53 @@ public void run() {
 
 
     private void onAsyncComplete() {
-        final ThreadSetupAction.Handle handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
+        final boolean setupRequired = ServletRequestContext.current() == null;
+        ThreadSetupAction.Handle handle = null;
+        if (setupRequired) {
+            handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
+        }
         try {
-            for (final BoundAsyncListener listener : asyncListeners) {
-                AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse);
-                try {
-                    listener.asyncListener.onComplete(event);
-                } catch (IOException e) {
-                    UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            //now run request listeners
+            if (setupRequired) {
+                servletRequestContext.getDeployment().getApplicationListeners().requestInitialized(servletRequest);
+            }
+            try {
+                for (final BoundAsyncListener listener : asyncListeners) {
+                    AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse);
+                    try {
+                        listener.asyncListener.onComplete(event);
+                    } catch (IOException e) {
+                        UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                    }
+                }
+            } finally {
+                if (setupRequired) {
+                    servletRequestContext.getDeployment().getApplicationListeners().requestDestroyed(servletRequest);
                 }
             }
         } finally {
-            handle.tearDown();
+            if (setupRequired) {
+                handle.tearDown();
+            }
         }
     }
 
     private void onAsyncTimeout() {
         final ThreadSetupAction.Handle handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
         try {
-            for (final BoundAsyncListener listener : asyncListeners) {
-                AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse);
-                try {
-                    listener.asyncListener.onTimeout(event);
-                } catch (IOException e) {
-                    UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            //now run request listeners
+            servletRequestContext.getDeployment().getApplicationListeners().requestInitialized(servletRequest);
+            try {
+                for (final BoundAsyncListener listener : asyncListeners) {
+                    AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse);
+                    try {
+                        listener.asyncListener.onTimeout(event);
+                    } catch (IOException e) {
+                        UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                    }
                 }
+            } finally {
+                servletRequestContext.getDeployment().getApplicationListeners().requestDestroyed(servletRequest);
             }
         } finally {
             handle.tearDown();
@@ -519,33 +541,55 @@ private void onAsyncTimeout() {
     private void onAsyncStart(AsyncContext newAsyncContext) {
         final ThreadSetupAction.Handle handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
         try {
-            for (final BoundAsyncListener listener : asyncListeners) {
-                //make sure we use the new async context
-                AsyncEvent event = new AsyncEvent(newAsyncContext, listener.servletRequest, listener.servletResponse);
-                try {
-                    listener.asyncListener.onStartAsync(event);
-                } catch (IOException e) {
-                    UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            //now run request listeners
+            servletRequestContext.getDeployment().getApplicationListeners().requestInitialized(servletRequest);
+            try {
+                for (final BoundAsyncListener listener : asyncListeners) {
+                    //make sure we use the new async context
+                    AsyncEvent event = new AsyncEvent(newAsyncContext, listener.servletRequest, listener.servletResponse);
+                    try {
+                        listener.asyncListener.onStartAsync(event);
+                    } catch (IOException e) {
+                        UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                    }
                 }
+            } finally {
+                servletRequestContext.getDeployment().getApplicationListeners().requestDestroyed(servletRequest);
             }
         } finally {
             handle.tearDown();
         }
     }
 
     private void onAsyncError(Throwable t) {
-        final ThreadSetupAction.Handle handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
+        final boolean setupRequired = ServletRequestContext.current() == null;
+        ThreadSetupAction.Handle handle = null;
+        if (setupRequired) {
+            handle = servletRequestContext.getDeployment().getThreadSetupAction().setup(exchange);
+        }
         try {
-            for (final BoundAsyncListener listener : asyncListeners) {
-                AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse, t);
-                try {
-                    listener.asyncListener.onError(event);
-                } catch (IOException e) {
-                    UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            //now run request listeners
+            if (setupRequired) {
+                servletRequestContext.getDeployment().getApplicationListeners().requestInitialized(servletRequest);
+            }
+            try {
+                for (final BoundAsyncListener listener : asyncListeners) {
+                    AsyncEvent event = new AsyncEvent(this, listener.servletRequest, listener.servletResponse, t);
+                    try {
+                        listener.asyncListener.onError(event);
+                    } catch (IOException e) {
+                        UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+                    }
+                }
+            } finally {
+                if (setupRequired) {
+                    servletRequestContext.getDeployment().getApplicationListeners().requestDestroyed(servletRequest);
                 }
             }
         } finally {
-            handle.tearDown();
+            if (setupRequired) {
+                handle.tearDown();
+            }
         }
     }
 ",2013-06-12T00:18:53Z,244
"@@ -114,7 +114,7 @@ public void testSimpleAsyncHttpServletWithoutDispatch() throws IOException {
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);
             Assert.assertEquals(AnotherAsyncServlet.class.getSimpleName(), response);
-            Assert.assertArrayEquals(new String[]{""created REQUEST"", ""destroyed REQUEST""}, TestListener.results().toArray());
+            Assert.assertArrayEquals(new String[]{""created REQUEST"", ""destroyed REQUEST"", ""created REQUEST"", ""destroyed REQUEST""}, TestListener.results().toArray());
         } finally {
             client.getConnectionManager().shutdown();
         }",2013-06-12T00:18:53Z,27
"@@ -67,4 +67,8 @@ public interface UndertowServletLogger extends BasicLogger {
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 15005, value = ""Error invoking method %s on listener %s"")
     void errorInvokingListener(final String method, Class<?> listenerClass, @Cause Exception e);
+
+    @LogMessage(level = Logger.Level.ERROR)
+    @Message(id = 15006, value = ""IOException dispatching async event"")
+    void ioExceptionDispatchingAsyncEvent(@Cause IOException e);
 }",2012-10-09T23:32:49Z,379
"@@ -153,7 +153,7 @@ private void handleFirstRequest(final BlockingHttpServerExchange exchange, final
                 }
             }
         } catch (Throwable t) {
-
+            HttpServletRequestImpl.getRequestImpl(exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY)).onAsyncError(t);
             if (!exchange.getExchange().isResponseStarted()) {
                 exchange.getExchange().setResponseCode(500);
                 exchange.getExchange().getResponseHeaders().clear();",2012-10-09T23:32:49Z,145
"@@ -38,6 +38,7 @@
 import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.api.Deployment;
+import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
 import io.undertow.servlet.handlers.ServletInitialHandler;
@@ -59,6 +60,7 @@ public class AsyncContextImpl implements AsyncContext {
     private final ServletResponse servletResponse;
     private final TimeoutTask timeoutTask = new TimeoutTask();
 
+
     //todo: make default configurable
     private volatile long timeout = 120000;
 
@@ -110,7 +112,7 @@ public void dispatch() {
         final ServletInitialHandler handler;
         Deployment deployment = requestImpl.getServletContext().getDeployment();
         if (servletRequest instanceof HttpServletRequest) {
-            handler = deployment.getServletPaths().getServletHandlerByPath(((HttpServletRequest) servletRequest).getRequestURI()).getHandler();
+            handler = deployment.getServletPaths().getServletHandlerByPath(((HttpServletRequest) servletRequest).getServletPath()).getHandler();
         } else {
             handler = deployment.getServletPaths().getServletHandlerByPath(exchange.getExchange().getRelativePath()).getHandler();
         }
@@ -217,6 +219,12 @@ public void dispatch(final ServletContext context, final String path) {
 
     @Override
     public synchronized void complete() {
+        HttpServletRequestImpl.getRequestImpl(servletRequest).onAsyncComplete();
+        completeInternal();
+    }
+
+    public synchronized void completeInternal() {
+
         if (!initialRequestDone && Thread.currentThread() == initiatingThread) {
             //the context was stopped in the same request context it was started, we don't do anything
             if (dispatched) {
@@ -268,17 +276,24 @@ public void run() {
 
     @Override
     public void addListener(final AsyncListener listener) {
-
+        HttpServletRequestImpl.getRequestImpl(servletRequest).addAsyncListener(listener);
     }
 
     @Override
     public void addListener(final AsyncListener listener, final ServletRequest servletRequest, final ServletResponse servletResponse) {
-
+        HttpServletRequestImpl.getRequestImpl(servletRequest).addAsyncListener(listener, servletRequest, servletResponse);
     }
 
     @Override
     public <T extends AsyncListener> T createListener(final Class<T> clazz) throws ServletException {
-        return null;
+        try {
+            InstanceFactory<T> factory = ((ServletContextImpl) this.servletRequest.getServletContext()).getDeployment().getDeploymentInfo().getClassIntrospecter().createInstanceFactory(clazz);
+            return factory.createInstance().getInstance();
+        } catch (NoSuchMethodException e) {
+            throw new ServletException(e);
+        } catch (InstantiationException e) {
+            throw new ServletException(e);
+        }
     }
 
     @Override
@@ -329,9 +344,11 @@ public void run() {
             synchronized (AsyncContextImpl.this) {
                 if (!dispatched) {
                     UndertowServletLogger.REQUEST_LOGGER.debug(""Async request timed out"");
-                    complete();
+                    HttpServletRequestImpl.getRequestImpl(servletRequest).onAsyncTimeout();
+                    completeInternal();
                 }
             }
         }
     }
+
 }",2012-10-09T23:32:49Z,244
"@@ -40,8 +40,11 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
 import javax.servlet.DispatcherType;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.ServletException;
@@ -62,6 +65,7 @@
 import io.undertow.server.handlers.form.MultiPartHandler;
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionManager;
+import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.util.EmptyEnumeration;
@@ -92,6 +96,7 @@ public class HttpServletRequestImpl implements HttpServletRequest {
     private final BlockingHttpServerExchange exchange;
     private ServletContextImpl servletContext;
 
+    private final List<BoundAsyncListener> asyncListeners = new CopyOnWriteArrayList<BoundAsyncListener>();
 
     private final HashMap<String, Object> attributes = new HashMap<String, Object>();
 
@@ -722,15 +727,18 @@ public AsyncContext startAsync() throws IllegalStateException {
         if (!isAsyncSupported()) {
             throw UndertowServletMessages.MESSAGES.startAsyncNotAllowed();
         }
+        onAsyncStart();
+        asyncListeners.clear();
         return asyncContext = new AsyncContextImpl(exchange, exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY), exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY));
     }
 
     @Override
     public AsyncContext startAsync(final ServletRequest servletRequest, final ServletResponse servletResponse) throws IllegalStateException {
-
         if (!isAsyncSupported()) {
             throw UndertowServletMessages.MESSAGES.startAsyncNotAllowed();
         }
+        onAsyncStart();
+        asyncListeners.clear();
         return asyncContext = new AsyncContextImpl(exchange, servletRequest, servletResponse);
     }
 
@@ -790,4 +798,69 @@ public static HttpServletRequestImpl getRequestImpl(final ServletRequest request
         }
         return requestImpl;
     }
+
+
+    public void addAsyncListener(final AsyncListener listener) {
+        asyncListeners.add(new BoundAsyncListener(listener, this, exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY)));
+    }
+
+    public void addAsyncListener(final AsyncListener listener, final ServletRequest servletRequest, final ServletResponse servletResponse) {
+        asyncListeners.add(new BoundAsyncListener(listener, servletRequest, servletResponse));
+    }
+
+    public void onAsyncComplete() {
+        for (final BoundAsyncListener listener : asyncListeners) {
+            AsyncEvent event = new AsyncEvent(asyncContext, listener.servletRequest, listener.servletResponse);
+            try {
+                listener.asyncListener.onComplete(event);
+            } catch (IOException e) {
+                UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            }
+        }
+    }
+
+    public void onAsyncTimeout() {
+        for (final BoundAsyncListener listener : asyncListeners) {
+            AsyncEvent event = new AsyncEvent(asyncContext, listener.servletRequest, listener.servletResponse);
+            try {
+                listener.asyncListener.onTimeout(event);
+            } catch (IOException e) {
+                UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            }
+        }
+    }
+
+    public void onAsyncStart() {
+        for (final BoundAsyncListener listener : asyncListeners) {
+            AsyncEvent event = new AsyncEvent(asyncContext, listener.servletRequest, listener.servletResponse);
+            try {
+                listener.asyncListener.onStartAsync(event);
+            } catch (IOException e) {
+                UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            }
+        }
+    }
+
+    public void onAsyncError(Throwable t) {
+        for (final BoundAsyncListener listener : asyncListeners) {
+            AsyncEvent event = new AsyncEvent(asyncContext, listener.servletRequest, listener.servletResponse, t);
+            try {
+                listener.asyncListener.onStartAsync(event);
+            } catch (IOException e) {
+                UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
+            }
+        }
+    }
+
+    private final class BoundAsyncListener {
+        final AsyncListener asyncListener;
+        final ServletRequest servletRequest;
+        final ServletResponse servletResponse;
+
+        private BoundAsyncListener(final AsyncListener asyncListener, final ServletRequest servletRequest, final ServletResponse servletResponse) {
+            this.asyncListener = asyncListener;
+            this.servletRequest = servletRequest;
+            this.servletResponse = servletResponse;
+        }
+    }
 }",2012-10-09T23:32:49Z,147
"@@ -47,6 +47,8 @@
 import org.xnio.Xnio;
 import org.xnio.XnioWorker;
 import org.xnio.channels.AcceptingChannel;
+import org.xnio.channels.SslConnection;
+import org.xnio.ssl.JsseXnioSsl;
 
 /**
  * Convenience class used to build an Undertow server.
@@ -114,8 +116,7 @@ public synchronized void start() {
         channels = new ArrayList<>();
         try {
             worker = xnio.createWorker(OptionMap.builder()
-                    .set(Options.WORKER_WRITE_THREADS, ioThreads)
-                    .set(Options.WORKER_READ_THREADS, ioThreads)
+                    .set(Options.WORKER_IO_THREADS, ioThreads)
                     .set(Options.CONNECTION_HIGH_WATER, 1000000)
                     .set(Options.CONNECTION_LOW_WATER, 1000000)
                     .set(Options.WORKER_TASK_CORE_THREADS, workerThreads)
@@ -125,7 +126,7 @@ public synchronized void start() {
                     .getMap());
 
             OptionMap serverOptions = OptionMap.builder()
-                    .set(Options.WORKER_ACCEPT_THREADS, ioThreads)
+                    .set(Options.WORKER_IO_THREADS, ioThreads)
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
                     .getMap();
@@ -149,8 +150,16 @@ public synchronized void start() {
                     AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, serverOptions);
                     server.resumeAccepts();
                     channels.add(server);
+                } else if (listener.type == ListenerType.HTTPS){
+                    HttpOpenListener openListener = new HttpOpenListener(buffers, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true), bufferSize);
+                    openListener.setRootHandler(rootHandler);
+                    ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);
+                    JsseXnioSsl xnioSsl = new JsseXnioSsl(worker.getXnio(),OptionMap.EMPTY);
+                    AcceptingChannel<SslConnection> sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, serverOptions);
+                    sslServer.resumeAccepts();
+                    channels.add(sslServer);
                 }
-                //TODO: https
+
             }
 
         } catch (Exception e) {",2013-04-08T22:04:13Z,400
"@@ -114,6 +114,7 @@ public static void renderDirectoryListing(HttpServerExchange exchange, Resource
 
         try {
             ByteBuffer output = ByteBuffer.wrap(builder.toString().getBytes(""UTF-8""));
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""text/html"");
             exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(output.limit()));
             Channels.writeBlocking(exchange.getResponseChannel(), output);
         } catch (UnsupportedEncodingException e) {",2013-04-08T22:04:13Z,374
"@@ -0,0 +1,97 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ * Copyright 2012 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.undertow.test.ssl;
+
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.GeneralSecurityException;
+
+import io.undertow.server.HttpHandler;
+import io.undertow.server.handlers.CanonicalPathHandler;
+import io.undertow.server.handlers.CookieHandler;
+import io.undertow.server.handlers.NameVirtualHostHandler;
+import io.undertow.server.handlers.PathHandler;
+import io.undertow.server.handlers.error.SimpleErrorPageHandler;
+import io.undertow.server.handlers.form.FormEncodedDataHandler;
+import io.undertow.server.handlers.form.MultiPartHandler;
+import io.undertow.server.handlers.resource.FileResourceManager;
+import io.undertow.server.handlers.resource.ResourceHandler;
+import io.undertow.test.handlers.file.FileHandlerTestCase;
+import io.undertow.test.utils.AjpIgnore;
+import io.undertow.test.utils.DefaultServer;
+import io.undertow.test.utils.HttpClientUtils;
+import io.undertow.util.TestHttpClient;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Stuart Douglas
+ */
+@AjpIgnore
+@RunWith(DefaultServer.class)
+public class ComplexSSLTestCase {
+
+    @Test
+    public void complexSSLTestCase() throws IOException, GeneralSecurityException, URISyntaxException {
+        final PathHandler pathHandler = new PathHandler();
+        Path rootPath = Paths.get(FileHandlerTestCase.class.getResource(""page.html"").toURI()).getParent();
+
+        final NameVirtualHostHandler virtualHostHandler = new NameVirtualHostHandler();
+        HttpHandler root = virtualHostHandler;
+        root = new CookieHandler(root);
+        root = new FormEncodedDataHandler(root);
+        root = new SimpleErrorPageHandler(root);
+        root = new CanonicalPathHandler(root);
+
+        MultiPartHandler hostHandler = new MultiPartHandler();
+        hostHandler.setNext(pathHandler);
+        virtualHostHandler.addHost(""default-host"", hostHandler);
+        virtualHostHandler.setDefaultHandler(hostHandler);
+
+        pathHandler.addPath(""/"", new ResourceHandler()
+                .setResourceManager(new FileResourceManager(rootPath))
+                .setDirectoryListingEnabled(true));
+
+        DefaultServer.setRootHandler(root);
+
+        DefaultServer.startSSLServer();
+        TestHttpClient client = new TestHttpClient();
+        client.setSSLContext(DefaultServer.getClientSSLContext());
+        try {
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + """");
+            HttpResponse result = client.execute(get);
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
+            final String response = HttpClientUtils.readResponse(result);
+            Header[] headers = result.getHeaders(""Content-Type"");
+            Assert.assertEquals(""text/html"", headers[0].getValue());
+            Assert.assertTrue(response, response.contains(""page.html""));
+        } finally {
+            client.getConnectionManager().shutdown();
+            DefaultServer.stopSSLServer();
+        }
+    }
+
+
+}",2013-04-08T22:04:13Z,133
"@@ -280,7 +280,7 @@ public static void startSSLServer() throws IOException {
      * @param options - Additional options to be passed to the JsseXnioSsl, this will be merged with the default options where
      *        applicable.
      */
-    public static void startSSLServer(final SSLContext context, final OptionMap options) throws IOException {
+    public static void  startSSLServer(final SSLContext context, final OptionMap options) throws IOException {
         OptionMap combined = OptionMap.builder().addAll(serverOptions).addAll(options).getMap();
 
         XnioSsl xnioSsl = new JsseXnioSsl(xnio, combined, context);",2013-04-08T22:04:13Z,76
