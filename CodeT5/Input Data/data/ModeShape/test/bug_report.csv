bug_report_id,bug_report_desc,bug_report_time
MODE-2031,"When modify custom node types in CND file which loaded at repository initialize,
throws exception:

ERROR jcr.RepositoryNodeTypeManager  - Node types were read from the system content, and appear to be inconsistent or invalid: Test Repository
Message: Supertype 'jj:name' from type 'jj:content' does not exist

Investigate method refreshFromSystem of RepositoryNodeTypeManager, it will also refresh the custom content type from the CND files, but the refresh do not maintain the dependencies of node type.",2013/09/06 1:17 PM
MODE-2030,"Indices seem not to be updated for folder's children nodes after it has been moved.

Test is attached in pull request.
Tried also explicitly specify ""sync"" and various index stores - didn't help.",2013/09/06 7:26 AM
MODE-2022,"If a repository has a {{tika-text-extractor}} configured and a binary file representing a Tika-recognized image is uploaded (e.g. JPEG, GIF, BMP), the text extraction fails with:

{code}
5:57:05,750 ERROR [org.modeshape.extractor.tika.TikaTextExtractor] (modeshape-text-extractor-5-thread-1) Error while extracting text : com/drew/metadata/MetadataException: java.lang.NoClassDefFoundError: com/drew/metadata/MetadataException
	at org.apache.tika.parser.jpeg.JpegParser.parse(JpegParser.java:56)
	at org.apache.tika.parser.CompositeParser.parse(CompositeParser.java:242)
	at org.modeshape.extractor.tika.TikaTextExtractor$1.execute(TikaTextExtractor.java:134)
	at org.modeshape.jcr.api.text.TextExtractor.processStream(TextExtractor.java:82) [modeshape-jcr-api-3.5-SNAPSHOT.jar:3.5-SNAPSHOT]
	at org.modeshape.extractor.tika.TikaTextExtractor.extractFrom(TikaTextExtractor.java:124)
	at org.modeshape.jcr.TextExtractors$Worker.run(TextExtractors.java:182) [modeshape-jcr-3.5-SNAPSHOT.jar:3.5-SNAPSHOT]
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895) [rt.jar:1.6.0_45]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918) [rt.jar:1.6.0_45]
	at java.lang.Thread.run(Thread.java:662) [rt.jar:1.6.0_45]
Caused by: java.lang.ClassNotFoundException: com.drew.metadata.MetadataException from [Module ""org.apache.tika:1.3"" from local module loader @3336a1a1 (finder: local module finder @47ad6b4b (roots: d:\Work\hchiorean.modeshape\integration\modeshape-jbossas-integration-tests\target\jboss-eap-6.1\modules,d:\Work\hchiorean.modeshape\integration\modeshape-jbossas-integration-tests\target\jboss-eap-6.1\modules\system\layers\base))]
	at org.jboss.modules.ModuleClassLoader.findClass(ModuleClassLoader.java:196) [jboss-modules.jar:1.2.0.Final-redhat-1]
	at org.jboss.modules.ConcurrentClassLoader.performLoadClassUnchecked(ConcurrentClassLoader.java:444) [jboss-modules.jar:1.2.0.Final-redhat-1]
	at org.jboss.modules.ConcurrentClassLoader.performLoadClassChecked(ConcurrentClassLoader.java:432) [jboss-modules.jar:1.2.0.Final-redhat-1]
	at org.jboss.modules.ConcurrentClassLoader.performLoadClassChecked(ConcurrentClassLoader.java:399) [jboss-modules.jar:1.2.0.Final-redhat-1]
	at org.jboss.modules.ConcurrentClassLoader.performLoadClass(ConcurrentClassLoader.java:374) [jboss-modules.jar:1.2.0.Final-redhat-1]
	at org.jboss.modules.ConcurrentClassLoader.loadClass(ConcurrentClassLoader.java:119) [jboss-modules.jar:1.2.0.Final-redhat-1]
	... 9 more
{code}

This is not only EAP specific, but generic and is caused by the fact that ModeShape's Tika dependency explicitly excludes the 3rd party library which is used to parse images.",2013/08/30 9:02 AM
MODE-2015,"The current repository JSON configuration provides an option for sequencers called {{removeDerivedContentWithOriginal}} which means that when an input node on which a sequencer has been run is removed from the repository, the sequenced content from that input node is also removed.

This option is parsed & present in the JSON configuration *but unused* atm. Also, the EAP kit *does not* expose this flag.",2013/08/28 6:09 AM
MODE-2012,"It seems MOODE-2009 isnt only about th workspace.delete, but also  the Workspace.clone() operations. 
It turns out that this also seems affected, as if I import a new workspace and then clone this into another workspace, the old content there isn't emptied correctly right before, leading to all kinds of stale data and JCR integrity exceptions (funny when you want to overwrite it...) or stale data returning as it seems some nodes then appear duplicate etc;
",2013/08/22 10:32 AM
MODE-2010,"I published a file using MS Tools and the 3.4 client jar. The method IRestClient.publish was used and the {{version}} flag was set to {{true}}. When I open a file system browser (Finder) and navigate to the workspace I just published the file to, I get the below warning/exception in the server console. I believe the file was successfully published as there is no error being thrown in the IRestClient.

{code}
09:43:49,236 WARN  [org.modeshape.webdav.methods.DoPropfind] (http-/127.0.0.1:8080-4) Sending internal error!: org.modeshape.webdav.exceptions.WebdavException: This method cannot be called on a property with multiple values
	at org.modeshape.web.jcr.webdav.ModeShapeWebdavServlet.translateError(ModeShapeWebdavServlet.java:152) [modeshape-web-jcr-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.web.jcr.webdav.ModeShapeWebdavStore.translate(ModeShapeWebdavStore.java:862) [modeshape-web-jcr-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.web.jcr.webdav.ModeShapeWebdavStore.getCustomProperties(ModeShapeWebdavStore.java:575) [modeshape-web-jcr-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.methods.DoPropfind.writeCustomProperties(DoPropfind.java:607) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.methods.DoPropfind.parseProperties(DoPropfind.java:372) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.methods.DoPropfind.recursiveParseProperties(DoPropfind.java:208) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.methods.DoPropfind.recursiveParseProperties(DoPropfind.java:222) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.methods.DoPropfind.execute(DoPropfind.java:157) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.webdav.WebDavServletBean.service(WebDavServletBean.java:141) [modeshape-webdav-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.web.jcr.webdav.ModeShapeWebdavServlet.service(ModeShapeWebdavServlet.java:129) [modeshape-web-jcr-webdav-3.4.0.Final.jar:3.4.0.Final]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:847) [jboss-servlet-api_3.0_spec-1.0.2.Final-redhat-1.jar:1.0.2.Final-redhat-1]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:295) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:214) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:230) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:149) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:481) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.jboss.as.web.security.SecurityContextAssociationValve.invoke(SecurityContextAssociationValve.java:169) [jboss-as-web-7.2.0.Final-redhat-4.jar:7.2.0.Final-redhat-4]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:145) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:97) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:102) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:336) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:856) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:653) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:920) [jbossweb-7.2.0.Final-redhat-1.jar:7.2.0.Final-redhat-1]
	at java.lang.Thread.run(Thread.java:680) [classes.jar:1.6.0_51]
Caused by: javax.jcr.ValueFormatException: This method cannot be called on a property with multiple values
	at org.modeshape.jcr.JcrMultiValueProperty.getString(JcrMultiValueProperty.java:114) [modeshape-jcr-3.4.0.Final.jar:3.4.0.Final]
	at org.modeshape.web.jcr.webdav.ModeShapeWebdavStore.getCustomProperties(ModeShapeWebdavStore.java:571) [modeshape-web-jcr-webdav-3.4.0.Final.jar:3.4.0.Final]
	... 22 more
{code}",2013/08/20 9:51 AM
MODE-2009,"Delete a workspace child nodes will node deleted, when re-create the workspace with same same all child nodes still exist.",2013/08/16 11:01 AM
MODE-2007,"As the title states, direct children of root node cannot be correctly cloned to another workspace.

This is a small regression introduced while fixing MODE-1972.

[This commit|https://github.com/ModeShape/modeshape/commit/1f0714eb0471153439109263d63097e0260b603e#modeshape-jcr/src/main/java/org/modeshape/jcr/JcrWorkspace.java] introduces a check for cloning into root node that is slightly incorrect.
{code}
-                // Use the JCR add child here to perform the parent validations
-                NodeKey cloneKey = parentNode.key().withId(sourceNode.key().getIdentifier());
-                parentNode.addChildNode(newNodeName, sourceNode.getPrimaryTypeName(), cloneKey, false);
-
+                NodeKey cloneKey = null;
+                if (!parentNode.isRoot()) {
+                    // Use the JCR add child here to perform the parent validations
+                    cloneKey = parentNode.key().withId(sourceNode.key().getIdentifier());
+                    parentNode.addChildNode(newNodeName, sourceNode.getPrimaryTypeName(), cloneKey, false);
+                } else {
+                    cloneKey = parentNode.key();
+                } 
{code}

The line 
{code}
if (!parentNode.isRoot()) {
{code}
changes the behavior not only for cloning the workspace root itself (as was apparently intended), but also for cloning children of workspace root as well.

The check should be replaced with
{code}
if (!destPath.isRoot()) {
{code}

Please find a pull request attached.",2013/08/08 2:29 PM
MODE-2006,Please see the forum post for more details.,2013/08/08 10:10 AM
MODE-2005,"When a merge operation on a versionable node fails, the {{jcr:mergeFailed}} property should be set with the ID of the offending node(s), leaving the rest unchanged. This should work even if the node is checked in.",2013/08/07 9:28 AM
MODE-2001,"The URLS (self, up, etc) do not appear to be encoded. Node names with embedded spaces or non-ascii characters do not work because the URL is not encoded.",2013/08/02 9:44 AM
MODE-1992,"Upon adding a node and calling save() on the JcrSession the following exception is thrown:

{code}
org.modeshape.jcr.value.binary.BinaryStoreException: java.sql.SQLException: Invalid operation for forward-only result set: first
    at org.modeshape.jcr.value.binary.Database.asString(Database.java:622)
    at org.modeshape.jcr.value.binary.DatabaseBinaryStore.getExtractedText(DatabaseBinaryStore.java:235)
    at org.modeshape.jcr.value.binary.AbstractBinaryStore.getText(AbstractBinaryStore.java:122)
    at org.modeshape.jcr.query.lucene.basic.BasicLuceneSchema.addDynamicField(BasicLuceneSchema.java:278)
    at org.modeshape.jcr.query.lucene.basic.BasicLuceneSchema.nodeInfo(BasicLuceneSchema.java:212)
    at org.modeshape.jcr.query.lucene.basic.BasicLuceneSchema.addToIndex(BasicLuceneSchema.java:406)
    at org.modeshape.jcr.JcrRepository$RepositoryMonitorFactory$2.recordAdd(JcrRepository.java:1875)
    at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1088)
    at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:544)
    at org.modeshape.jcr.JcrSession.save(JcrSession.java:1022)
{code}
",2013/07/15 2:24 AM
MODE-1990,"The Git connector is not properly using all of the remote names provided in the configuration, as described by the JavaDoc and [documentation|https://docs.jboss.org/author/display/MODE/Git+connector]. Instead, the connector appears to use just the first remote name and ignore the rest.",2013/07/09 10:25 AM
MODE-1978,"Tried upgrading from MS 3.2.0.Final to 3.3.0.Final and one of our (sramp) junit tests started failing with an NPE.  The test in question is for deleting an artifact from the sramp repo:

https://github.com/Governance/s-ramp/blob/master/s-ramp-repository-jcr/modeshape/src/test/java/org/overlord/sramp/repository/jcr/modeshape/JCRPersistenceTest.java#L518-544

When we delete an artifact we do two things:

1) Move the JCR node from /s-ramp/artifacts/UUID to /s-ramp-trash/artifacts/UUID
2) Remove the primary s-ramp mixin and replace it with sramp:deletedArtifact


The resulting exception is:

{code}
java.lang.NullPointerException
	at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1125)
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:544)
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1022)
	at org.overlord.sramp.repository.jcr.JCRPersistence.deleteArtifact(JCRPersistence.java:404)
	at org.overlord.sramp.repository.jcr.modeshape.JCRPersistenceTest.testDeleteArtifact(JCRPersistenceTest.java:534)
{code}
",2013/06/25 2:52 PM
MODE-1974,"I put a printout in and rebuilt standalone and installed in EAP 6.1. The stderr printout I inserted on line 513 of RepositoryStatistics.

{code}
17:03:58,959 ERROR [stderr] (HttpManagementService-threads - 4) startingIndex=25, size=24, numAfterStartingIndex=-1, numBeforeStartingIndex=25
17:03:58,959 ERROR [org.jboss.as.controller.management-operation] (HttpManagementService-threads - 4) JBAS014612: Operation (""read-attribute"") failed - address: ([
    {""subsystem"" => ""modeshape""},
    {""repository"" => ""sample""}
]): java.lang.ArrayIndexOutOfBoundsException
	at java.lang.System.arraycopy(Native Method) [classes.jar:1.6.0_45]
	at org.modeshape.jcr.RepositoryStatistics$MetricHistory.copyStatistics(RepositoryStatistics.java:514)
	at org.modeshape.jcr.RepositoryStatistics$MetricHistory.getHistory(RepositoryStatistics.java:488)
	at org.modeshape.jcr.RepositoryStatistics.getHistory(RepositoryStatistics.java:283)
	at org.modeshape.jboss.metric.GetDurationMetric.history(GetDurationMetric.java:62)
	at org.modeshape.jboss.metric.ModeShapeMetricHandler.executeRuntimeStep(ModeShapeMetricHandler.java:63)
{code}
",2013/06/24 5:22 PM
MODE-1972,"When performing a {{workspace.copy}} or a {{workspace.clone}} operation between 2 different workspaces, where the {{destAbsPath}} is {{/}}, a {{java.lang.NullPointerException}} is raised.",2013/06/24 7:05 AM
MODE-1971,"When connector to external source is used and document is being copied within this connector the Copy function does not work correctly.

For the source document with content repository does:
1. asks connector for new document's ID for copy to be created
2. generates new ID for document's copy content without asking connector for it
3. uses generated ID to store content into external source
4. fails as ID is not found

CmisConnector fails with ObjectNotFound error
FileSystem fails with incorrect id format as it expects to get key with slashes.

",2013/06/21 12:54 AM
MODE-1965,"Section 3.5.7.2 of the JSR-283 specification (aka, ""JCR 2.0"") states:
{quote}
A mixin node type may have one or more supertypes, which must also be mixin types.
{quote}

At the moment however, ModeShape does not perform any kind of validation in this regard, allowing a mixin type to inherit from a non-mixin type. 
We should add this validation so that an error is raised during type registration if the above case occurs.
",2013/06/17 10:11 AM
MODE-1963,"Register, unregister it and register the same mixin (via JCR) again results in a NPE.",2013/06/12 10:33 AM
MODE-1961,"After import of an workspace.xml file of a modeshape 2.8 repo into 3.3 following error is thrown:

{code}
javax.jcr.nodetype.ConstraintViolationException: No valid property definition on node '/brix:root/brix:web/brix:globalContainer' with primary type 'nt:file' and mixin types [] for the property: brix:nodeType=""brix:globalContainer""
     at org.modeshape.jcr.AbstractJcrNode.propertyDefinitionFor(AbstractJcrNode.java:479)
     at org.modeshape.jcr.AbstractJcrNode.createJcrProperty(AbstractJcrNode.java:395)
{code}

The same import into modeshape 2.x, or 3.1, 3.2 works as intended (though 3.1 and 3.2 have other flaws);

The reported error leads to wrong checking or wrong done import as the blamed resource above lists as follows in the workspace.xml (only beginning here, mixinTypes-def is line 3 as brix:node):

{code:xml}
<sv:node sv:name=""brix:globalContainer"">
<sv:property sv:name=""jcr:primaryType"" sv:type=""Name"">
<sv:value>nt:file</sv:value>
</sv:property>
<sv:property sv:name=""jcr:mixinTypes"" sv:type=""Name"" sv:multiple=""true"">
<sv:value>brix:node</sv:value>
</sv:property>
<sv:property sv:name=""jcr:uuid"" sv:type=""String"">
<sv:value>517326c9-05a5-462d-920f-5e730aaef6e6</sv:value>
</sv:property>
<sv:property sv:name=""brix:lastModifiedBy"" sv:type=""String"">
<sv:value><anonymous></sv:value>
</sv:property>
<sv:property sv:name=""jcr:createdBy"" sv:type=""String"">
<sv:value><anonymous></sv:value>
</sv:property>
.... 
{code}

",2013/06/11 8:15 AM
MODE-1950,"The existing REST service allows the update of mixins on a node, via the ""PUT"" method.  However, when an update causes mixins to be removed, the following problems may occur:

* because the mixins are processed first (before any properties) it is impossible to remove a mixin if the node has properties defined which belong to that mixin or an ancestor of that mixin. This is because a validation is performed when removing the mixins which would result in a {{ConstraintViolationException}}
* the existing REST service doesn't handle properly removing of properties via update, by passing in {{null}} values or empty arrays. This is needed in order to be able to remove properties from a node. 

Therefore, not only should the last point from above be implemented, but also the order in which mixins & properties are updated via the REST Service should be changed.",2013/05/29 11:54 AM
MODE-1949,"When a mixin is removed, there is code validation in place to ensure that if there are still public properties on that node which were brought in via the mixin, a {{ConstraintViolationException}} is thrown. 

The same validation should take place not only for the properties of the mixin type itself, but for all the properties of the ancestors of that mixin as well.

Currently, if {{mixinA}} inherits from {{mixinB}} and {{mixinB}} defines a public property which is set on a node, {{mixinA}} can be removed without a problem, even though it ""orphans"" the property.",2013/05/29 11:40 AM
MODE-1938,"{{WorkspaceCache}} instances are initialized lazily, when a client code first calls the {{RepositoryCache#workspace}} method. The whole initialization procedure is done inside a user transaction, so that entries in ISPN are correctly persited.

The current code has a bug in that if multiple threads call this method, the cache of workspace caches from {{RepositoryCache}} exposes a new {{WorkspaceCache}} instance *before* {{transaction.commit}} has occurred. 

In other words, a thread may get a {{WorkspaceCache}} reference even though the data corresponding to that workspace cache has not been persisted in ISPN.

This can be *seen sometimes* while running the tests, when error messages such as:

{code}
Exception in thread ""main"" javax.jcr.ItemNotFoundException: The node with key ee0a8387505d64/ no longer exists.
	at org.modeshape.jcr.AbstractJcrNode.node(AbstractJcrNode.java:216)
	at org.modeshape.jcr.AbstractJcrNode.path(AbstractJcrNode.java:236)
	at org.modeshape.jcr.AbstractJcrNode.addNode(AbstractJcrNode.java:1002)
	at org.modeshape.jcr.AbstractJcrNode.addNode(AbstractJcrNode.java:925)
{code}

pop up. They are caused by the asynchronous indexing threads ""colliding"" with the main test threads.",2013/05/17 4:05 AM
MODE-1935,"Our current support for clustering indexing via JMS is incomplete, because we're lacking a {{javax.jms.MessageListener}} implementation that would run on the ""master"" node and would process entries from the queue.

The [Hibernate Search Documentation|http://docs.jboss.org/hibernate/search/4.2/reference/en-US/html_single/#jms-backend] hints towards MDBs, but that's not an option because we are not using Hibernate.",2013/05/10 11:04 AM
MODE-1934,"The current 3.8 version of the POI libraries (used by the Tika text extractor and MS Office Sequencer) should be removed and/or downgraded.

For the sequencer, this means that we will be temporarily ""deactivating"" the sequencer.

See comment for more information",2013/05/10 9:12 AM
MODE-1933,"When attempting to start ModeShape in EAP with JMS configured for indexing, the following exception is raised:

{code}
Caused by: org.modeshape.jcr.cache.WrappedException: java.lang.NoClassDefFoundError: javax/jms/JMSException
        at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:449) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:347) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.cache.RepositoryCache.runOneTimeSystemInitializationOperation(RepositoryCache.java:472) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.JcrRepository$RunningState.completeInitialization(JcrRepository.java:1234) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.JcrRepository.doStart(JcrRepository.java:359) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:601) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        ... 54 more
Caused by: java.lang.NoClassDefFoundError: javax/jms/JMSException
        at org.hibernate.search.backend.BackendFactory.createBackend(BackendFactory.java:61) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.indexes.impl.DirectoryBasedIndexManager.createBackend(DirectoryBasedIndexManager.java:224) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.indexes.impl.DirectoryBasedIndexManager.initialize(DirectoryBasedIndexManager.java:103) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.indexes.impl.IndexManagerHolder.createIndexManager(IndexManagerHolder.java:227) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.indexes.impl.IndexManagerHolder.buildEntityIndexBinding(IndexManagerHolder.java:102) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.spi.SearchFactoryBuilder.initDocumentBuilders(SearchFactoryBuilder.java:414) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.spi.SearchFactoryBuilder.buildNewSearchFactory(SearchFactoryBuilder.java:222) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.hibernate.search.spi.SearchFactoryBuilder.buildSearchFactory(SearchFactoryBuilder.java:146) [hibernate-search-engine-4.2.0.Final.jar:4.2.0.Final]
        at org.modeshape.jcr.RepositoryQueryManager.queryEngine(RepositoryQueryManager.java:175) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.RepositoryQueryManager.getIndexes(RepositoryQueryManager.java:161) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.JcrRepository$RepositoryMonitorFactory.indexingMonitor(JcrRepository.java:1801) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.JcrRepository$RepositoryMonitorFactory.createMonitor(JcrRepository.java:1795) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.txn.Transactions.newMonitor(Transactions.java:229) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.txn.Transactions$BaseTransaction.createMonitor(Transactions.java:242) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:373) [modeshape-jcr-3.3-SNAPSHOT.jar:3.3-SNAPSHOT]
        ... 59 more
Caused by: java.lang.ClassNotFoundException: javax.jms.JMSException from [Module ""org.hibernate.search.engine:main"" from local module loader @c75e4fc (finder: local module finder @100c62c8 (roots: D:\Work\jboss-eap-6.1-ms-3.3.0\modules,D:\Work\jboss-eap-6.1-ms-3.3.0\modules\system\layers\base))]
        at org.jboss.modules.ModuleClassLoader.findClass(ModuleClassLoader.java:190) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        at org.jboss.modules.ConcurrentClassLoader.performLoadClassUnchecked(ConcurrentClassLoader.java:468) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        at org.jboss.modules.ConcurrentClassLoader.performLoadClassChecked(ConcurrentClassLoader.java:456) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        at org.jboss.modules.ConcurrentClassLoader.performLoadClassChecked(ConcurrentClassLoader.java:423) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        at org.jboss.modules.ConcurrentClassLoader.performLoadClass(ConcurrentClassLoader.java:398) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        at org.jboss.modules.ConcurrentClassLoader.loadClass(ConcurrentClassLoader.java:120) [jboss-modules.jar:1.2.0.CR1-redhat-1]
        ... 74 more
{code}",2013/05/09 6:01 AM
MODE-1932,"When configuring the ModeShape EAP kit to use JMS for indexing, the _path_ and _source-path_ attributes should always be relative to _jboss.server.data.dir_. 

However, atm, instead of resolving _jboss.server.data.dir_ correctly, ModeShape just creates folders like: _jboss.server.data.dirmodeshape_ in the current working directory.",2013/05/09 5:48 AM
MODE-1929,"In order to cluster ModeShape repositories in EAP, the {{cluster-name}} attribute needs to be specified in the repository configuration. 

Even though the current kit fully defines the attribute (marshaling from/to XML, setting & reading it), it *does not list it as a repository attribute*. This means that in effect, when configuring a repository, the value will always be {{undefined}}.

In effect, this prevents ModeShape from being clustered in EAP.",2013/05/08 6:11 AM
MODE-1919,"When publishing/uploading a file using IRestClient (via ModeShape Tools), if a workspace/publish area is used that currently does not exist, the node is created. However the created node does not have the ""mode:publishArea"" mixin. When a subsequent query is done requesting the same workspace's publish areas, this new node is not returned.

I guess another possibility is that the query ModeShape Tools is using to return the publish areas is wrong. Here is the query:

{code}
SELECT [jcr:path], [jcr:title] FROM [mode:publishArea]
{code}",2013/05/02 11:14 AM
MODE-1911,"Our current build systems has 2 profiles: {{preferIpv4}} and {{preferIpv6}} to control ipv4 / ipv6 parameters sent to the Surefire JVM when running the tests.

At the moment, they have the wrong values configured and by default no preferred profile is used. 

We should use by default ipv4 and overwrite it in exceptional cases.",2013/04/25 2:50 AM
MODE-1898,"I provided the Teiid Designer team with locally built alpha 3.2 jars and am helping them integrate their DDL importer with the new Teiid DDL parser. These jars replaced old 2.x jars so there were other changes they needed to make.

Here are the problems found so far:

- the visibility of TeiidDdlLexicon constants need to be public since the Designer importer needs to know the Teiid node type and mixin names. These constants are currently scoped package private.

- the TeiidDdlLexicon constants with names containing ""NODE_TYPE"" should be renamed to not include ""NODE_TYPE"" in their name. Those constants at one time represented node type names but now are mixin names. 

- the property ""teiidddl:canBeNull"" of the ""teiidddl:resultColumn"" mixin defined in the TeiidDdl.cnd can be deleted as it is not used. The ""ddl:nullable"" property is used instead.

- the Teiid DDL constraint type of ""INDEX"" can reference zero or more columns. The current TeiidDdl only considers the zero reference case where an expression is used. Both the CND and the parser need to be changed to fix this.",2013/04/11 11:31 AM
MODE-1883,"VersionManager can not restore a previously removed node with mix:versionable type. The result (of running the code listed in ""Steps to Reproduce"") is:

{code}
javax.jcr.ItemNotFoundException: 454d8227505d64f12f93a7-3c5e-47c7-bf7a-2c896327e489
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:425)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:407)
	at org.modeshape.jcr.JcrSession.getNonSystemNodeByIdentifier(JcrSession.java:727)
	at org.modeshape.jcr.JcrVersionManager.restore(JcrVersionManager.java:705)
	at org.modeshape.jcr.ModeShapeTckTest.testShouldRestoreDeletedNode(ModeShapeTckTest.java:995)
        ...
{code}",2013/04/05 12:42 AM
MODE-2685,"When attempting to reorder one or more SNS children of a parent which also have transient changes in a given JCR session, the following exception is raised:
{code}
Caused by: java.lang.ClassCastException: org.modeshape.jcr.cache.document.TransactionalWorkspaceCache cannot be cast to org.modeshape.jcr.cache.document.AbstractSessionCache
	at org.modeshape.jcr.cache.document.SessionNode.session(SessionNode.java:298)
	at org.modeshape.jcr.cache.document.SessionNode.getPath(SessionNode.java:480)
	at org.modeshape.jcr.cache.PathCache.getPath(PathCache.java:41)
	at org.modeshape.jcr.cache.document.WritableSessionCache.computePathChangesForSNS(WritableSessionCache.java:1476)
	at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1258)
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:690)
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1179)
	... 28 more
{code}

Note that this can happen in 2 cases:
# explicitly reordering transient SNS
# restoring a non existent version (from a JCR session point of view) using the {{JcrVersionManager}}",2017/04/13 3:55 AM
MODE-2683,"When running a query like {{SELECT * FROM [mix:title] WHERE UPPER([jcr:title]) LIKE '%TITLE%'}} against a Lucene index, this will not return the correct results even if it has the correct indexed data.

",2017/04/04 5:30 AM
MODE-2679,"Modeshape login fails with the following RepositoryException when running with the default Locale language set to Turkish (tr):
{code}
javax.jcr.RepositoryException: Error while starting 'simple' repository: null
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:631)
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:590)
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:136)
	at modeshape.TurkishLocaleBug.main(TurkishLocaleBug.java:31)
Caused by: java.lang.NullPointerException
	at org.modeshape.jcr.NodeTypes.<init>(NodeTypes.java:321)
	at org.modeshape.jcr.NodeTypes.with(NodeTypes.java:379)
	at org.modeshape.jcr.RepositoryNodeTypeManager.registerNodeTypes(RepositoryNodeTypeManager.java:529)
	at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:1132)
	at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:936)
	at org.modeshape.jcr.JcrRepository.doStart(JcrRepository.java:372)
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:629)
	... 3 more
{code}

The NPE is caused by a missing ntUnstructuredType.   

The ntUnstructuredType is missing because the jsr_283_builtins.cnd is failing to parse.

The parsing failure is getting masked by what looks like a recurrence of MODE-1400.  Basically, in JcrRepository fails to check the reported problems of the previous call to importBuiltins at line 1131.

The parsing failure itself is caused by an unknown token failure on the ""multiple"" token in the CND file.  This is due to the ""Turkish Locale Bug"" (http://mattryall.net/blog/2009/02/the-infamous-turkish-locale-bug).   The lowercase ""i"" (\u0069) in the Turkish locale does not map to the latin uppercase ""I"" (\u0049), but to \u0130.

Hacking a local versions of TokenStream and CndImporter to use String.toLowerCase(Locale.ENGLISH) and String.toUpperCase(Locale.ENGLISH) seem to allow Modeshape to at least startup and seems to work.

Probably a more thorough review of the Modeshape code base for use of these methods would need to be done to guarantee Modeshape truly works in the Turkish locale.

Attached is a sample gradle project showing the problem.

 ",2017/03/29 4:04 PM
MODE-2678,"ModeShape's {{DatabaseBinaryStore}} uses database connections in auto-commit mode for all of its operations. While this might work in practice for operations which involve a single query for example, it's likely that this is not a good approach for operations which write to the DB.

For example, when storing a new binary value, the {{storeValue}} method performs a number of database calls, including operations like searching for an existing value and doing something if that value does not exist.

Since binaries are not necessarily created inside of transactions (the default {{binaryValueFactory.createBinary}} is almost always called outside of a transaction unless user transactions are employed), the code should never rely in all cases on auto-commit mode. 

This is one possible explanation for the exception from the attached forum issue, where multiple cluster writers are simultaneously attempting to insert the same binary.",2017/03/28 5:57 AM
MODE-2677,"After updating to the latest version we were facing an ugly bug with the indices. 
After some time debugging and detect where it could come from we found the mistake.

In commit [9db7a79|https://github.com/ModeShape/modeshape/pull/1551/commits/9db7a79b98f4cd4ed12226c0eb3e4c250e91af9d] [~hchiorean] wanted to shorten the loadAll()-Method from the BufferingSequence. 
But the current code depend now on the order of batches to iterate. 

Example: 
Is the first batch empty (bacth.hasNext() == false) it wouldn't count any batchsize ever.
Before this change, the ""old"" while-loop tried all batches until any found to count. 

It could be fixed easily if you change line 140 to {{firstBatchCounted = batchSize != 0;}}",2017/03/22 2:33 AM
MODE-2676,"When using ModeShape's API and attempting to remove all the version histories of a node via the {{org.modeshape.jcr.api.version.VersionManager}} interface, a referential integrity constraint of the form:
{code}
org.modeshape.jcr.cache.ReferentialIntegrityException: Cannot remove some nodes because they are still strongly referred by existing nodes: {/{http://www.jcp.org/jcr/1.0}system/{http://www.jcp.org/jcr/1.0}versionStorage/{}53/{}63/{}2f/{}53632fb320c5312a4f98cfea0221d86bab739ec1=[/{http://www.jcp.org/jcr/1.0}system/{http://www.jcp.org/jcr/1.0}versionStorage/{}ef/{}d1/{}ce/{}efd1ce92b033299879aa009fabc40f49cc7f22d4/{}1.0/{http://www.jcp.org/jcr/1.0}frozenNode/{}testNeu, /{http://www.jcp.org/jcr/1.0}system/{http://www.jcp.org/jcr/1.0}versionStorage/{}ef/{}d1/{}ce/{}efd1ce92b033299879aa009fabc40f49cc7f22d4/{}1.1/{http://www.jcp.org/jcr/1.0}frozenNode/{}testNeu]}
    at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1433)
    at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:701)
    at org.modeshape.jcr.JcrVersionManager.remove(JcrVersionManager.java:1056)
{code}

is raised if the parent of the node in question is versionable and has multiple versions of the child subgraph.
",2017/03/16 4:40 AM
MODE-2673,"Using the [latest|https://github.com/ModeShape/modeshape/commit/a4a57252cc114fb65a7bbfaa57c33baea422d0ac] {{5.4-SNAPSHOT}} of ModeShape, I am getting the following exception when dealing with aborted user transactions, where transaction reaper terminates an active transaction from a background thread. It appears that the message used to warn the user about the problem is missing an argument (or it expects an extra one that should not be necessary):

{code}
LOGGER.warn(RelationalProviderI18n.threadAssociatedWithAnotherTransaction, activeTx, id);
{code}

{noformat}
java.lang.IllegalArgumentException: Internationalization field ""threadAssociatedWithAnotherTransaction"" in class org.modeshape.persistence.relational.RelationalProviderI18n: 2 parameters supplied, but 3 parameters required: ""The current thread '{0}' is already associated with transaction '{1}' instead of '{2}'; this may indicate a rollback was performed off another thread"" => ""The current thread '1a5496fb-183e-4241-9b99-f1fc8e617a71' is already associated with transaction '137021ee-0fd9-446c-9dd6-cf95d9a62c5f' instead of '{2}""
	at org.modeshape.common.i18n.I18n.text(I18n.java:414)
	at org.modeshape.common.logging.slf4j.SLF4JLoggerImpl.warn(SLF4JLoggerImpl.java:86)
	at org.modeshape.persistence.relational.RelationalDb.txStarted(RelationalDb.java:310)
	at org.modeshape.jcr.txn.Transactions$BaseTransaction.started(Transactions.java:429)
	at org.modeshape.jcr.txn.Transactions.begin(Transactions.java:183)
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:668)
	at org.modeshape.jcr.RepositoryLockManager.unlock(RepositoryLockManager.java:479)
	at org.modeshape.jcr.RepositoryLockManager.unlock(RepositoryLockManager.java:447)
	at org.modeshape.jcr.JcrLockManager.unlock(JcrLockManager.java:305)
	at org.modeshape.jcr.JcrLockManager.unlock(JcrLockManager.java:283)
{noformat}",2017/03/13 2:03 PM
MODE-2672,"h3. Problem

It is possible to get the node, which would be permanently locked, when stressed with multiple concurrent writes and, perhaps, unfortunate timing. For more details and a detailed explanation as to how to reproduce the issue, please refer to the following post:
* [https://developer.jboss.org/message/969456#969456]

As [suggested|https://developer.jboss.org/message/969464#969464] by [~hchiorean], once the MODE-2670 was resolved, I pulled in the latest code and gave the aforementioned test case another try. The results were surprising. Here is a comparison between what I saw before and what I see now.

*Before*:
# A few runs of the provided test case, using the same DB between runs, could result in the corruption of the originally locked node, where multiple attempts from multiple members of the cluster, performed after configured lock expiration, could not unlock the node.
# When corruption happens in the previous step, an attempt to run the same test again will fail right away for various underlying reasons, e.g. {{NullPointerException}}, {{DocumentAlreadyExistsException}}. Note that all members of the cluster could be stood up for actual test to begin, i.e. there were no problems getting members online.

*Now*:
* Every run of the test case hangs after {{~ 20}} seconds, i.e. there are some successful/failed actions taking place for some time, but after that everything freezes. The thread dump reveals plenty of threads waiting on a condition to happen, for instance:
{noformat}
""modeshape-event-dispatcher-17-thread-1"" #154 prio=5 os_prio=31 tid=0x00007fb8d349d000 nid=0x14d07 waiting on condition [0x000000012bb64000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000007710e3068> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at org.modeshape.common.collection.ring.BlockingWaitStrategy.waitFor(BlockingWaitStrategy.java:46)
	at org.modeshape.common.collection.ring.GarbageCollectingConsumer$1.waitFor(GarbageCollectingConsumer.java:61)
	at org.modeshape.common.collection.ring.GarbageCollectingConsumer.run(GarbageCollectingConsumer.java:87)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

""in-memory-corruption-25"" #95 daemon prio=5 os_prio=31 tid=0x00007fb8d405d800 nid=0xf903 waiting on condition [0x00000001293ef000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x0000000770d83250> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
{noformat}
* Eventually, the log gets filled with the following entries, but the process does not get terminated:
{noformat}
[in-memory-corruption-23] org.modeshape.jcr.cache.RepositoryCache - Repository '9f2434a6-4378-4fe7-a352-aea6c07f56b1' is still not fully initialized after 10 minutes. Aborting.
{noformat}
* If I terminate the Java process that was stuck and run the same test again without cleaning the H2 DB on the filesystem, I can never get to the actual execution of the test, because the members of the cluster necessary for testing cannot be stood up, i.e. two out of five members get started, but then nothing happens.

h3. Summary

The MODE-2670 did make a big difference, but in a clustered environment such a difference ended up having an unexpected outcome, assuming the provided test case is valid. I sincerely hope that I am doing something wrong and I would be thrilled to have a confirmation of that. Otherwise, this problem can result in very much undesired consequences for a production system that relies on ModeShape.

[~hchiorean], knowing the additional details and problems provided in this JIRA, would it be possible for you to revisit the following [decision|https://developer.jboss.org/message/969464#969464]?
{quote}
As far as I'm concerned, after I fix MODE-2670 I will focus on something else because these complex test cases simply take up too much of my time. If in the meantime someone else in the community proposes a fix, I'm more than happy to review any PRs.
{quote}

As far as complexity of the provided test case goes, unless I messed something up in terms of configuration, the presented scenario is fairly common in a clustered environment where multiple consumers work with a single node, e.g. creating files under a given folder. It is true that I had to manually craft the delay between retries for each thread, but that was done to make sure that the problem can be reproduced.

[~hchiorean] and [~rhauch], as always, your help is greatly appreciated. The turnaround time for various issues is simply amazing, especially for an open-source project. Once again, my apologies for so many questions, however, I hope that in the long run your answers will help the entire community.",2017/03/07 10:10 PM
MODE-2671,Database connection leaks when BinaryStoreException is thrown at DatabaseBinaryStore.getInputStream().,2017/03/06 2:34 AM
MODE-2670,"When user transactions are used with a repository and some transactions are rolled back, if the rollback operation is performed from another thread (which is the case with Arjuna for example), then any locks that might have been obtained by previously successful {{session.save}} operations are never released.

The reason is that internally ModeShape uses {{ReentrantLock}} to track locked node keys, so when a transaction is started and some {{session.save}} operations are performed on thread {{T1}}, node keys are locked for this thread. If a subsequent rollback happens from a separate thread - {{T2}} - these node keys will not be released because {{T2}} is not the owning thread.",2017/03/01 8:16 AM
MODE-2669,"When storing data in relational databases and using user transactions, if a user transaction is rolled back from *a different thread* than the thread which created the transaction and which was used by ModeShape to detect the transaction, the backend database connection and transient data is not cleared correctly.

This can be reproduced in a specific test case which uses Arjuna and forces the reaper thread to abort timed-out transactions. See linked forum issue for more details",2017/03/01 6:33 AM
MODE-2668,"When a series of JCR operations take place within a user transaction and this transaction expires before the operations can complete, instead of rolling back all the operations and raising an exception, a {{TimeoutException}} is raised.

See linked forum discussion for more detailed information.",2017/02/27 3:25 AM
MODE-2666,"When using a query with order by I get an error on query.execute()

{code}
java.io.NotSerializableException: org.modeshape.jcr.query.Tuples$Tuple3TypeFactory$1
	at org.mapdb.SerializerPojo.assertClassSerializable(SerializerPojo.java:324)
	at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:394)
	at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)
	at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)
	at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:430)
	at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)
	at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)
	at org.mapdb.SerializerPojo.serializeUnknownObject(SerializerPojo.java:430)
	at org.mapdb.SerializerBase.serialize2(SerializerBase.java:531)
	at org.mapdb.SerializerBase.serialize(SerializerBase.java:150)
	at org.mapdb.SerializerBase.serialize(SerializerBase.java:94)
	at org.mapdb.SerializerPojo.serialize(SerializerPojo.java:700)
	at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:397)
	at org.mapdb.BTreeMap$NodeSerializer.serialize(BTreeMap.java:288)
	at org.mapdb.Store.serialize(Store.java:154)
	at org.mapdb.StoreWAL.update(StoreWAL.java:371)
	at org.mapdb.Caches$HashTable.update(Caches.java:270)
	at org.mapdb.BTreeMap.put2(BTreeMap.java:746)
	at org.mapdb.BTreeMap.put(BTreeMap.java:643)
	at org.mapdb.DB.catPut(DB.java:105)
	at org.mapdb.DB.createTreeMap(DB.java:845)
	at org.mapdb.DB$BTreeMapMaker.make(DB.java:661)
	at org.modeshape.jcr.query.BufferManager$MakeSortingWithDuplicatesBuffer.make(BufferManager.java:948)
	at org.modeshape.jcr.query.engine.process.BufferingSequence.<init>(BufferingSequence.java:79)
	at org.modeshape.jcr.query.engine.process.SortingSequence.<init>(SortingSequence.java:49)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:925)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.executeOptimizedQuery(ScanningQueryEngine.java:507)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.execute(ScanningQueryEngine.java:325)
	at org.modeshape.jcr.RepositoryQueryManager$1.execute(RepositoryQueryManager.java:192)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:118)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:43)
	at com.assemblycms.core.cache.JCREmbeddedRepository.file(JCREmbeddedRepository.java:660)
	at com.assemblycms.core.cache.FederatedWebCacheRepository.file(FederatedWebCacheRepository.java:21)
	at com.assemblycms.core.URITemplateResolver.computeTemplateResource(URITemplateResolver.java:103)
	at org.thymeleaf.templateresolver.AbstractTemplateResolver.resolveTemplate(AbstractTemplateResolver.java:356)
	at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:840)
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:608)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1087)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1048)
	at com.assemblycms.core.RequestController.model(RequestController.java:440)
	at com.assemblycms.core.RequestController.html(RequestController.java:254)
	at com.assemblycms.core.RequestController.get(RequestController.java:132)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:114)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:622)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)
	at com.assemblycms.commons.servlet.JspDispatcherServlet.service(JspDispatcherServlet.java:36)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.filters.ExpiresFilter.doFilter(ExpiresFilter.java:1223)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at com.assemblycms.core.FrameworkFilter.doFilter(FrameworkFilter.java:63)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at com.assemblycms.core.ResourcePlaceholderFilter.doFilter(ResourcePlaceholderFilter.java:56)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at com.assemblycms.core.HtmlPageFilter.doFilter(HtmlPageFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:115)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:112)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:169)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:206)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.doFilter(AbstractPreAuthenticatedProcessingFilter.java:121)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:121)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:66)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.session.ConcurrentSessionFilter.doFilter(ConcurrentSessionFilter.java:134)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:106)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177)
	at org.springframework.security.web.debug.DebugFilter.invokeWithWrappedRequest(DebugFilter.java:90)
	at org.springframework.security.web.debug.DebugFilter.doFilter(DebugFilter.java:77)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262)
	at com.assemblycms.commons.security.SecurityFilterProxy.doFilter(SecurityFilterProxy.java:63)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at com.assemblycms.commons.servlet.RequestContextFilter.doFilter(RequestContextFilter.java:22)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.springframework.session.web.http.ScopedSessionRepositoryFilter.doFilterInternal(ScopedSessionRepositoryFilter.java:141)
	at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:65)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262)
	at com.assemblycms.commons.session.SessionFilterProxy.doFilter(SessionFilterProxy.java:63)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at com.assemblycms.core.BrowserFilter.doFilter(BrowserFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:521)
	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1096)
	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:674)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
{code}",2017/02/09 1:28 AM
MODE-2665,"I have multiple threads running the code below, calling into a cluster of the ModeShape repositories on an Oracle database:
{code}
session.getWorkspace().getLockManager().lock(parent.getPath(), ...);
try {
  parent.addNode(""child-"" + i);
} finally {
  session.getWorkspace().getLockManager().unlock(parent.getPath());
}
{code}

I noticed the database deadlock when I was investigating hung threads. After going through the logs from the {{WritableSessionCache}}, it looks like the order of the database locks is determined by {{RepositoryLockManager.lock(...)}} and {{RepositoryLockManager.unlock(...)}}), and are contributing to the database deadlock.

Here's the relevant output from {{WritableSessionCache}}'s logging that demonstrates the deadlock:
{quote}
2017-01-31 18:26:09,438-0600 \[add-node-parallel-10\] DEBUG org.modeshape.jcr.cache.document.WritableSessionCache - Locked the nodes: \[e60d4aa317f1e7mode:lock-e60d4aa7505d64e7751d4d-ff9a-45d3-8453-c51e87e4df36, e60d4aa317f1e7mode:locks\]
...
2017-01-31 18:26:09,439-0600 \[add-node-parallel-6\] DEBUG org.modeshape.jcr.cache.document.WritableSessionCache - Locked the nodes: \[e60d4aa7505d64e7751d4d-ff9a-45d3-8453-c51e87e4df36\]
...
2017-01-31 18:26:09,448-0600 \[add-node-parallel-10\] DEBUG org.modeshape.jcr.cache.document.WritableSessionCache - Attempting to the lock nodes: \[e60d4aa7505d64e7751d4d-ff9a-45d3-8453-c51e87e4df36\]
...
2017-01-31 18:26:09,449-0600 \[add-node-parallel-6\] DEBUG org.modeshape.jcr.cache.document.WritableSessionCache - Attempting to the lock nodes: \[e60d4aa317f1e7mode:locks, e60d4aa317f1e7mode:lock-e60d4aa7505d64e7751d4d-ff9a-45d3-8453-c51e87e4df36\]
...
{quote}

From looking through the source code in {{RepositoryLockManager}}, the lock(...) method [saves the lock in the system session first, then saves the node being lock.|https://github.com/ModeShape/modeshape/blob/master/modeshape-jcr/src/main/java/org/modeshape/jcr/RepositoryLockManager.java#L382]

While unlock(...) [saves the node being locked first, then deletes the lock itself|https://github.com/ModeShape/modeshape/blob/master/modeshape-jcr/src/main/java/org/modeshape/jcr/RepositoryLockManager.java#L478].

This means that when lock(...) and unlock(...) are called at around the same time, lock(...) would acquire a db lock for the JCR lock itself, and waits for the db lock to be released for the JCR node being locked.
unlock(...) would hold a db lock for the JCR node being locked and waits to acquire a db lock for the JCR lock itself.

*Proposed solution*:
I believe that changing the save order in {{RepositoryLockManager}}'s unlock(...) would resolve the deadlock. I forked ModeShape, made the change and wasn't seeing any more deadlocks or hung threads. I don't know enough context around why the save order is the way it is, so I am not sure if this is the best/correct solution.
",2017/02/03 4:12 PM
MODE-2664,"See community post relating to the error ModeShape 5.3 / 5.4 and SQL Server|https://developer.jboss.org/message/968016#968016]

Two problems were observed.
# *problem 1* The schema DDL script needs to be updated in sqlserver_database.properties, 
## Create_table,  CONTENT's  type should be changed from VARBINARY to VARBINARY(MAX).  Otherwise, the content table is getting created in SQL Server 2014 as VARBINARY(1)  which is too small to store almost anything. See revised file.
# *problem 2* When ModeShape starts up against a SQL Server database, it tries to create the necessary tables.  If it fails because the object already exists,  SQL Server's exception is not caught and the whole application exits.  We need similar changes to what were make for Oracle, to gracefully catch and ignore the exceptions when trying to create an object that already exists or trying to a delete a non-existent object / or permissions error. 
## Creation of a new class SQLServerStatements.java which handles the two exceptions in SQL Server.   This is modeled after OracleStatements.java
## ## RelationalDb,  to call SQLServerStatements if the database type is SQL Server.

When I applied these changes to the 5.3.0.Final modeshape-persistence-relational code, I was able to start up ModeShape against a SQL Server database, without exceptions stopping the application, on initial database creation, or subsequent startups.   The modeshape-persistence-relational 5.3.0.Final is identical to the 5.4 master branch, as of Feb 3, 2017, so this revised version could be applied to 5.4 w/o problem.  

I have not performed testing on the flow where it tries to delete a non-existent object or where the database user does not have permissions to do so.

ModeShape w/ SQL Server should ignore (or treat errors as warnings)  for these exceptions
2714/* object already exists*/,
3701/* object doesn't exist or cannot drop due to permissions*/


Error before bug fix

*Current errors*
09:12:10,024 DEBUG Looking for JBoss Standalone JTA...
09:12:10,027 DEBUG Looking for Atomikos JTA...
09:12:10,032 DEBUG No javax.transaction.TransactionManager was found; falling back to LocalTransactionManager. Enable DEBUG logging for more information.
09:12:10,087 DEBUG Creating table MODESHAPE_REPOSITORY...
09:12:10,105 DEBUG Shutting down locking service...
09:12:10,119 ERROR Cannot load the names of the available repositories.
javax.jcr.RepositoryException: org.modeshape.persistence.relational.RelationalProviderException: com.microsoft.sqlserver.jdbc.SQLServerException: There is already an object named 'MODESHAPE_REPOSITORY' in the database.       
at org.modeshape.jcr.JcrRepositoriesContainer$UrlRepositoryLookup.repository(JcrRepositoriesContainer.java:228)

",2017/02/03 1:31 PM
MODE-2663,When a MongoDB replicaset is used as binary storage than data can get corrupted when the replicaset changes the primary node. The corruption is caused in the {{org.modeshape.jcr.value.binary.MongodbBinaryStore}} file in the {{ChunkInputStream}} and {{ChunkOutputStream}} classes. The OutputStream creates small chunks from the bigger binary files. These chunks are stored and than read without any given sorting. If you don't give a sort than the order of the returned chunks is undefined. In my tests this was working for the primary node since MongoDB returned the chunks in the way they where written. However when we switched the primary node the former secondary returned the chunks in a different order and the files get corrupted. ,2017/02/01 3:04 AM
MODE-2658,"When the same input node (i.e. the same JCR path) is sequenced multiple times, ModeShape should remove each time the previous sequencing output. In other words, the expected behavior is for ModeShape to overwrite the sequencing output each time.

At the moment this is not happening, which results in {{same name siblings}} being created each time.

",2017/01/16 5:04 AM
MODE-2654,"When you have a parent node with locked child node and then you copy parent node, you will be not able to lock or unlock new copy of child node.

I was able to reproduce this defect with unit tests. Please find them in the attachments.",2016/12/26 10:34 AM
MODE-2649,NoData,2016/12/13 2:39 PM
MODE-2644,"Although runtime index configuration using index manager is correctly persisted inside repository, after restart of the engine, they are not recognized and enabled.
Even recreating them programmatically upon restart doesn't work.

This bug affects each of the three default index providers (local, Lucene, Elasticsearch)

A test case can be found at [https://github.com/lucapino/modeshape-indexes|https://github.com/lucapino/modeshape-indexes].",2016/11/21 5:01 AM
MODE-2643,"Reading files from git through Modeshape with help from the git connector is working fine for small files but for big files this is failing with the following error:
{code}
Caused by: org.modeshape.persistence.file.FileProviderException: An active transaction is required, but wasn't detected
  at org.modeshape.persistence.file.FileDb.transactionalContent(FileDb.java:251)
  at org.modeshape.persistence.file.FileDb.editContent(FileDb.java:131)
  at org.modeshape.jcr.cache.document.LocalDocumentStore.edit(LocalDocumentStore.java:178)
  at org.modeshape.jcr.federation.FederatedDocumentStore.edit(FederatedDocumentStore.java:348)
  at org.modeshape.jcr.cache.document.DocumentTranslator.incrementBinaryReferenceCount(DocumentTranslator.java:1249)
  at org.modeshape.jcr.cache.document.DocumentTranslator.valueToDocument(DocumentTranslator.java:1222)
  at org.modeshape.jcr.cache.document.DocumentTranslator.setProperty(DocumentTranslator.java:425)
  at org.modeshape.jcr.federation.FederatedDocumentWriter.addProperty(FederatedDocumentWriter.java:131)
  at org.modeshape.connector.git.GitTree.addInformationForPath(GitTree.java:239)
  at org.modeshape.connector.git.GitTree.execute(GitTree.java:128)
  at org.modeshape.connector.git.GitConnector.getDocumentById(GitConnector.java:233)
{code}

What I have seen in the source from the git connector is that it handles huge files differently from small files. Line 230 found here: [https://github.com/ModeShape/modeshape/blob/master/connectors/modeshape-connector-git/src/main/java/org/modeshape/connector/git/GitTree.java#L230]
I haven't found out what Git considers a huge file and what not. So far I have had it working with a 46MB file but not with a 126MB file.

The method values.binaryFrom(fileLoader.openStream()); attempts to create & store a ModeShape binary value for that particular Git value without an existing transaction (the entire flow is simply reading stuff from Git).",2016/11/11 4:58 AM
MODE-2642,NoData,2016/11/11 2:19 AM
MODE-2641,For an open-scoped lock which is created with timeout hint less than Long.MAX_VALUE Lock.getSecondsRemaining() returns Long.MAX_VALUE (for a Lock object obtained via the session that created the lock) or negative value (for a Lock object obtained via another session).,2016/11/10 9:00 AM
MODE-2637,"I encounter the following exception when copying nodes in the Workspace :
 
{code}
javax.jcr.RepositoryException: java.lang.NullPointerException
  at org.modeshape.jcr.JcrSession.save(JcrSession.java:1190) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.JcrWorkspace.copy(JcrWorkspace.java:240) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.JcrWorkspace.copy(JcrWorkspace.java:121) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at com.dooapp.dsdk.persistence.clone.JcrEntityDuplicator.duplicateNode(JcrEntityDuplicator.java:99) ~[classes/:na]
  at com.dooapp.dsdk.persistence.clone.JcrEntityDuplicator.duplicate(JcrEntityDuplicator.java:76) ~[classes/:na]
  at com.dooapp.dsdk.core.persistence.JcromServiceEntityDuplicator.duplicate(JcromServiceEntityDuplicator.java:41) [classes/:na]
  at com.dooapp.dsdk.core.persistence.JcromService.doDuplicate(JcromService.java:451) [classes/:na]
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_92]
  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_92]
  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_92]
  at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_92]
  at org.jrebirth.af.core.service.ServiceTaskBase.call(ServiceTaskBase.java:156) [core-8.0.5.jar:na]
  at javafx.concurrent.Task$TaskCallable.call(Task.java:1423) [jfxrt.jar:na]
  at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_92]
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_92]
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_92]
  at java.lang.Thread.run(Thread.java:745) [na:1.8.0_92]
Caused by: java.lang.NullPointerException: null
  at java.util.Objects.requireNonNull(Objects.java:203) ~[na:1.8.0_92]
  at java.util.Arrays$ArrayList.<init>(Arrays.java:3813) ~[na:1.8.0_92]
  at java.util.Arrays.asList(Arrays.java:3800) ~[na:1.8.0_92]
  at org.modeshape.jcr.spi.index.provider.IndexChangeAdapters$NodeTypesChangeAdapter.modifyProperties(IndexChangeAdapters.java:822) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.cache.change.ChangeSetAdapter.firePropertyChanges(ChangeSetAdapter.java:228) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.cache.change.ChangeSetAdapter.notify(ChangeSetAdapter.java:99) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.spi.index.provider.IndexProvider$AtomicIndex.notify(IndexProvider.java:1493) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.bus.RepositoryChangeBus.notify(RepositoryChangeBus.java:190) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.cache.document.WorkspaceCache.changed(WorkspaceCache.java:333) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.txn.SynchronizedTransactions.updateCache(SynchronizedTransactions.java:223) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:751) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  at org.modeshape.jcr.JcrSession.save(JcrSession.java:1171) ~[modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
  ... 16 common frames omitted
{code}
 
This exception is due to an empty multi-value ""jcr:mixinTypes"" property in one of the copied nodes (this happened after removing a mixin from this node using removeMixin on this node). The call to getValuesAsArray on this property returns a null value which leads to this exception.",2016/10/12 11:21 AM
MODE-2636,"The attribute ""table-name"" in the ""db-persistence"" repository configuration for the JBOSS subsystem isn't set properly during startup. The DB persistence always uses the default table name ""MODESHAPE_REPOSITORY"".

The cause of this bug is in the class org.modeshape.jboss.subsystem.AddDatabasePersistence in modeshape-jbossas-subsystem.
Within the method ""performRuntime"" all ModelAttributes for DatabasePersistence are set for the persistenceConfig - except TABLE_NAME.

The following code should be inserted to record the ModelAttributes.TABLE_NAME property:
{code:java}
ModelNode tableName = TABLE_NAME.resolveModelAttribute(context, operation);
if (tableName.isDefined()) {
      persistenceConfig.setString(TABLE_NAME.getFieldName(), tableName.asString());
}
{code}
 
",2016/10/07 6:18 AM
MODE-2633,"Based on the comment \[1], it appears that the following scenario should not result in errors:
# Obtain a shallow open-scoped lock on a node and set timeout hint to {{1 second}}.
# Wait for {{1 minute}} to ensure that the lock is expired.
# Lock the node without any errors.

However, the steps outlined above would result in the exception that looks like this:
{noformat}
Caused by: javax.jcr.lock.LockException: The node at '/6269cc6c-9253-4db8-bd16-b319a1bc779f' is already locked
	at org.modeshape.jcr.JcrLockManager.lock(JcrLockManager.java:267)
	at org.modeshape.jcr.JcrLockManager.lock(JcrLockManager.java:238)
{noformat}

If this is indeed a valid problem and it is addressed, it would effectively eliminate the need for \[2] and \[3].

\[1] [https://developer.jboss.org/message/963202#963202]
\[2] [https://issues.jboss.org/browse/MODE-2631]
\[3] [https://github.com/ModeShape/modeshape/pull/1596]",2016/09/22 5:13 PM
MODE-2629,"h3. Repository Layout

The layout of the test repository is presented below. Note, that {{appRoot}} and all its child nodes are versionable. By the way, I do understand that this kind of topology is far less than desirable, but unfortunately we have to maintain a repository (formerly running on Jackrabbit 1.x) which has some nodes with a ton of direct children.

{noformat}
- jcrRoot
-- appRoot
--- node1
---- child1
---- child2
---- ...
---- childN
--- node2
--- ...
--- nodeN
{noformat}

h4. Problem Creating a Node

Every time a new node, i.e. direct child, gets added to the {{appRoot}}, a certain SQL query receives more input parameters. Eventually, the number of parameters exceeds the limit allowed by the Oracle 11g DBMS and the query becomes syntactically incorrect. The table below represents the aforementioned query, where ""Node Index"" indicates the order in which nodes are added.

|| Node Index || SQL Query ||
| 1 | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?){code}
| 2 | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?,?,?){code}
| 3 | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?,?,?,?,?){code}

As you can see, the {{SELECT}} query that is issued to create the first node has {{6}} parameters in the {{IN}} clause. The second query adds {{2}} more parameters. The third one adds yet another {{2}} and so on. It appears that we have an arithmetic progression here. In Oracle 11g, the {{IN}} clause cannot have more than {{1000}} arguments. So, to count how many nodes we need to add to reach the limit, we can do the following:

{noformat}
a1 + (n - 1) * d = 6 + (498 - 1) * 2 = 1000
{noformat}

As a result, if we have more than {{498}} direct child nodes, the Oracle 11g refuses to invoke the constructed query. Here is a stack trace:

{noformat}
org.modeshape.persistence.relational.RelationalProviderException: java.sql.SQLSyntaxErrorException: ORA-01795: maximum number of expressions in a list is 1000

  at org.modeshape.persistence.relational.RelationalDb.runWithConnection(RelationalDb.java:370)
  at org.modeshape.persistence.relational.RelationalDb.load(RelationalDb.java:187)
  at org.modeshape.jcr.cache.document.LocalDocumentStore.load(LocalDocumentStore.java:83)
  at org.modeshape.jcr.cache.document.WorkspaceCache.loadFromDocumentStore(WorkspaceCache.java:335)
  at org.modeshape.jcr.cache.document.WritableSessionCache.lockNodes(WritableSessionCache.java:1613)
  at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:712)
  at org.modeshape.jcr.cache.SessionCacheWrapper.save(SessionCacheWrapper.java:96)
  at org.modeshape.jcr.JcrSession$SystemSessionCache.save(JcrSession.java:2482)
  at org.modeshape.jcr.JcrVersionManager.checkin(JcrVersionManager.java:373)
  at org.modeshape.jcr.JcrVersionManager.checkin(JcrVersionManager.java:295)
  
  ...

Caused by: java.sql.SQLSyntaxErrorException: ORA-01795: maximum number of expressions in a list is 1000

  at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:450)
  at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:399)
  at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1059)
  at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:522)
  at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:257)
  at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:587)
  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:225)
  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:53)
  at oracle.jdbc.driver.T4CPreparedStatement.executeForDescribe(T4CPreparedStatement.java:774)
  at oracle.jdbc.driver.OracleStatement.executeMaybeDescribe(OracleStatement.java:925)
  at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1111)
  at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:4798)
  at oracle.jdbc.driver.OraclePreparedStatement.executeQuery(OraclePreparedStatement.java:4845)
  at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeQuery(OraclePreparedStatementWrapper.java:1501)
  at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeQuery(ProxyPreparedStatement.java:52)
  at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeQuery(HikariProxyPreparedStatement.java)
  at org.modeshape.persistence.relational.DefaultStatements.loadIDs(DefaultStatements.java:138)
  at org.modeshape.persistence.relational.DefaultStatements.lambda$load$0(DefaultStatements.java:123)
  at org.modeshape.persistence.relational.DefaultStatements.runBatchOperation(DefaultStatements.java:261)
  at org.modeshape.persistence.relational.DefaultStatements.load(DefaultStatements.java:121)
  at org.modeshape.persistence.relational.RelationalDb.lambda$load$12(RelationalDb.java:187)
  at org.modeshape.persistence.relational.RelationalDb.runWithConnection(RelationalDb.java:362)
  ...
{noformat}

*Possible Solution*

Before sending the query for execution, it _may_ be possible to format it in a way that Oracle 11g will understand, e.g.:
{code:sql}
SELECT CONTENT
FROM MODESHAPE_REPOSITORY
WHERE ID IN ('entry-0', 'entry-1', ... 'entry-999')
   OR ID IN ('entry-1000', 'entry-1001', ... 'entry-1999')
   OR ID IN (...)
{code}

h4. Problem Deleting a Node 

Similarly to the problem related to node creation, we can get an invalid query when removing a node with a lot of children. The table below represents some of the queries that get sent to the DBMS upon request to delete a node, where ""Node Count"" represents the overall number of direct child nodes for a node to be deleted.

|| Node Count || SQL Query ||
| 1 | {code:sql}DELETE FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?){code}
|   | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?,?){code}
| 2 | {code:sql}DELETE FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?){code}
|   | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?,?,?,?,?){code}
| 3 | {code:sql}DELETE FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?){code}
|   | {code:sql}SELECT CONTENT FROM MODESHAPE_REPOSITORY WHERE ID IN (?,?,?,?,?,?,?,?,?,?,?,?,?){code}

Based on the results above (considering arithmetic progression {{a1 + (n - 1) * d}}):
* The {{SELECT}} query will fail on an attempt to delete a node with {{332}} child nodes, i.e. {{7 + (332 - 1) * 3 = 1000}}
* The {{DELETE}} query will fail on an attempt to delete a node with {{999}} child nodes, i.e. {{2 + (999 - 1) * 1 = 1000}}

h4. Questions

If an issue described here is a known problem, is there a possibility to release a fix for it in {{5.2}} version of the ModeShape? And if so, is {{5.2}} still targeted for this month, i.e. September, 2016? Thank you.

h4. Notes

* The queries provided here were obtained with YourKit profiling tool.
* A sample project that allows to demonstrate a problem is located [here|https://github.com/dnillia/modeshape-cluster-test#junit-tests-for-limitations]. By the way, it takes a while to create a lot of direct child nodes ({{~ 2h}} to get {{~ 490}} nodes).",2016/09/09 1:53 PM
MODE-2627,"getPolicies returns empty array, but acl was set before.",2016/09/02 7:18 AM
MODE-2626,"When attempting to configure a custom binary store via the Wildfly kit, this fails with an exception similar to:
{code}
11:35:01,154 ERROR [org.jboss.msc.service.fail] (MSC service thread 1-8) MSC000001: Failed to start service jboss.modeshape.customBinaryStorage.repository: org.jboss.msc.service.StartException in serv
ice jboss.modeshape.customBinaryStorage.repository: org.modeshape.jcr.ConfigurationException: The configuration for the 'customBinaryStorage' repository has problems: ERROR: Error at storage.binarySto
rage.type : The 'type' field on 'storage.binaryStorage' has a value of 'custom' that is not part of the enumeration: [transient]
ERROR: Error at storage.binaryStorage.minimum-binary-size : The 'minimum-binary-size' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.

ERROR: Error at storage.binaryStorage.minimum-string-size : The 'minimum-string-size' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.

ERROR: Error at storage.binaryStorage.classname : The 'classname' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.
ERROR: Error at storage.binaryStorage.classloader : The 'classloader' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.
ERROR: Error at storage.binaryStorage.store-name : The 'store-name' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.
ERROR: Error at storage.binaryStorage.mime-type-detection : The 'mime-type-detection' field on 'storage.binaryStorage' is not defined in the schema and the schema does not allow additional properties.

        at org.modeshape.jboss.service.RepositoryService.start(RepositoryService.java:221)
        at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1948)
        at org.jboss.msc.service.ServiceControllerImpl$StartTask.run(ServiceControllerImpl.java:1881)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
Caused by: org.modeshape.jcr.ConfigurationException: The configuration for the 'customBinaryStorage' repository has problems: ERROR: Error at storage.binaryStorage.type : The 'type' field on 'storage.
binaryStorage' has a value of 'custom' that is not part of the enumeration: [transient]
{code}",2016/08/31 4:35 AM
MODE-2622,"Multiple unit tests in the modeshape-jcr fail at the same line.  The problem appears to be related to the fact that system property  {{java.net.preferIPv6Addresses}} is returning true, but none of the available addresses are Inet6Addresss objects thus leading to the assertion failure below.

Tests run: 5, Failures: 5, Errors: 0, Skipped: 0, Time elapsed: 2.621 sec <<< FAILURE! - in org.modeshape.jcr.value.binary.CassandraBinaryStoreTest
{code}
shoudlRemoveExpiredContent(org.modeshape.jcr.value.binary.CassandraBinaryStoreTest)  Time elapsed: 0 sec  <<< FAILURE!
java.lang.AssertionError
	at org.modeshape.jcr.ClusteringHelper.getLocalHost(ClusteringHelper.java:59)
	at org.modeshape.jcr.value.binary.CassandraBinaryStoreTest.setUp(CassandraBinaryStoreTest.java:69)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:367)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:274)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:161)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:290)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:242)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:121)
{code}
",2016/08/17 12:56 AM
MODE-2620,"Repository configured with DB persistence and separated binary storage. Create node {{A}} under root node. Using FederationManager create external projection {{F}} under node {{A}}. Verify that parent of the node {{F}} is node {{A}}. Restart repository. All nodes are in place however {{F.getParent()}} throws {{NullPointerException}}

If database will be used as store for binary values as well the exception will be not thrown.
",2016/08/03 3:41 AM
MODE-2617,"*Setup*

Consider the following layout where all nodes except for {{<jcrRepositoryRoot>}} are versionable:
{noformat}
<jcrRepositoryRoot>
- <applicationRoot>
-- <parentNode1>
--- <childNode1>
-- <parentNode2>
--- <childNode2>

...

-- <parentNodeN>
--- <childNodeN>
{noformat}

The ModeShape is running in a clustered mode and there are two members in JGroups cluster (there is a custom JGroups configuration file, which is used in the test project \[1]). The members can reside either in a single JVM (as multiple {{javax.jcr.Repository}} instances deployed to the {{org.modeshape.jcr.ModeShapeEngine}}) or in multiple JVMs (i.e. one {{javax.jcr.Repository}} per JVM).

*Problem*

Say we have {{N}} {{java.util.concurrent.Callable<V>}} instances. When called, each one obtains a {{javax.jcr.Session}} from the first member of the cluster and updates a single {{<childNodeN>}} which exists under corresponding {{<parentNodeN>}} (i.e. no two instances are configured to update the same child or parent node). Now, an {{java.util.concurrent.ExecutorService}} gets to invoke all previously created tasks in parallel using {{N}} threads in the pool, which results in an exception that looks like this:

{noformat}
Caused by: org.modeshape.jcr.cache.NodeNotFoundInParentException: Cannot locate child node: 497b1b6317f1e7209d1359-9d56-4a28-8dd0-59749b1ea35c within parent: 497b1b6317f1e7135adb68-36ac-4057-a084-650ce1cf274a
	at org.modeshape.jcr.cache.document.SessionNode.getSegment(SessionNode.java:435)
	at org.modeshape.jcr.cache.document.SessionNode.getPath(SessionNode.java:466)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:553)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:518)
	at org.modeshape.jcr.JcrVersionManager.checkin(JcrVersionManager.java:378)
	at org.modeshape.jcr.JcrVersionManager.checkin(JcrVersionManager.java:295)
{noformat}

The problem does not happen if:
* there is only one member in the cluster
* having two cluster members, only one thread of execution performs the update using the first member of the cluster

Note, that any kind of write operation results in the same error (every child node is unique and exists under a unique parent):
* updating all child nodes in parallel
* creating all child nodes in parallel

*Possible Cause*

Potentially, the JGroups configuration file used to recreate the problem has some invalid configuration options. For what it is worth, when {{TRACE}} log level is enabled, I can see that members of the cluster communicate with each other, i.e. there are send/receive entries.

*How to Recreate the Failure*

I have created a test project \[1] that can be used to consistently cause the previously described problem. Please, read the documentation \[2] that should explain how to use the tools available in the project and it should also provide a better explanation of the problem and exact steps to take to reproduce it.

\[1] https://github.com/dnillia/modeshape-cluster-test
\[2] https://github.com/dnillia/modeshape-cluster-test/blob/master/README.md",2016/07/08 10:54 AM
MODE-2615,"We've been having the exception: {{java.nio.charset.MalformedInputException: Input length = 1}} come up in our application recently. It has been difficult to reproduce but after some digging I believe it is related to the position of some Unicode characters in our content. We have some very long strings translated to French. When this started showing up I found that simply adding a space (anywhere, randomly) would resolve the issue.

It seems to centre around the chunking that's done between the byte buffer and char buffer. If (in the above unit test) I increase the size of the string to 2 times the buffers min size and step through the readUTF method I can see the char buffer ends up with 1 remaining slot but is never filled. This goes on and on until the length is 0, at this point the decoder flags it as malformed input.

Any feedback on this would be great!",2016/06/28 10:42 PM
MODE-2611,"When creating a backup from our Modeshape-Datastore (it's postgres as db in the background) the system-node is written twice into the backup-file. 
Creating the backup file works like a charm.

But if we want to restore the backup, our database complains about a duplicate key, coming from the double system-node entry. 

If we now delete the second system-node entry in the backup file, we can restore the backup without any errors.


This issue can easily be fixed with removing the ""PHASE2"" in BackupService.execute() due to the system-node is already saved in ""PHASE1"".
[If you can see it, here is the commit in our fork|https://github.com/data-experts/modeshape/commit/dc6ca728c5ea009c5ab17d406858c1f49ac154c8]",2016/06/16 4:45 AM
MODE-2610,"0) Create node and add child node to it

Then in another transaction and in brand new session:
1) Load child node;
2) Update parent node;
3) Call session.save();
4) Remove child node;
5) Call session.save() and you will get exception.

This issue is really similar to https://issues.jboss.org/browse/MODE-2608, but fix for that issue didn't resolve this one. I'm still able to reproduce this issue using test, please see attachment.

Exception:
{code}
javax.jcr.InvalidItemStateException: This session tried to save changes to node with key 'Cannot locate child node: dbb11dd7505d64c117ec3f-18ae-4eb2-9d65-d762209e3b01 within parent: dbb11dd7505d642bdf0eb7-7e89-4a39-b3bd-287b6ebdf6fd', but it was removed by another session.
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1171)
Caused by: org.modeshape.jcr.cache.NodeNotFoundInParentException: Cannot locate child node: dbb11dd7505d64c117ec3f-18ae-4eb2-9d65-d762209e3b01 within parent: dbb11dd7505d642bdf0eb7-7e89-4a39-b3bd-287b6ebdf6fd
	at org.modeshape.jcr.cache.document.LazyCachedNode.parentReferenceToSelf(LazyCachedNode.java:238)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getSegment(LazyCachedNode.java:282)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:308)
	at org.modeshape.jcr.cache.PathCache.getPath(PathCache.java:41)
	at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1002)
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:716)
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1162)
	... 31 more 
{code}",2016/06/09 7:29 AM
MODE-2604,"[StandardDdlParser] isTableConstraint already handles PK, FK and UNIQUE constraints with optional constraint names, but only handles CHECK with constraint name present.

according to Oracle docs (https://docs.oracle.com/cd/B28359_01/server.111/b28286/clauses002.htm#CJAGIICD)
- ""... CONSTRAINT sth_name CHECK (check expr) ..."" is handled correctly
- ""... CHECK (check expr) ..."" is NOT handled correctly

If the same applies to other DB dialects this should be fixed in StandardDdlParser otherwise the method should be overloaded in OracleDdlParser.

",2016/05/24 4:22 AM
MODE-2603,"When running ModeShape at various times, I notice that during some hours in the evening (U.S. Eastern time) ModeShape5 will not start up. The issue appears to be coming from the updated logic in this commit:
https://github.com/ModeShape/modeshape/commit/bc574455aa7e0e7fa6f7a6e4820f5b777bfda3f1#diff-0bfcd93b5cc4efa01e1328b6fcb4c8c4L1987

..in JcrRepository.determineInitialDelay().

For example, with my local system clock set to EDT, running the following build command in the Modeshape codebase (73086b7289270827c2e5d95ddec8fc4107a8a3f1), produces the following results:
-----cmd
while true; do echo -n `date` >> compile.out; mvn clean test -s settings.xml -pl modeshape-jcr -Dtest=JcrRepositoryTest | grep ""\[INFO\] BUILD"" >> compile.out; sleep 1h; done
-----
-----results
Wed May 18 15:21:31 EDT 2016[INFO] BUILD SUCCESS
Wed May 18 16:22:25 EDT 2016[INFO] BUILD SUCCESS
Wed May 18 17:23:14 EDT 2016[INFO] BUILD SUCCESS
Wed May 18 18:24:07 EDT 2016[INFO] BUILD SUCCESS
Wed May 18 19:25:01 EDT 2016[INFO] BUILD SUCCESS
Wed May 18 20:25:48 EDT 2016[INFO] BUILD FAILURE
Wed May 18 21:26:47 EDT 2016[INFO] BUILD FAILURE
Wed May 18 22:27:35 EDT 2016[INFO] BUILD FAILURE
Wed May 18 23:28:15 EDT 2016[INFO] BUILD FAILURE
Thu May 19 00:28:54 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 01:29:41 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 02:30:28 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 03:31:13 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 04:31:58 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 05:32:44 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 06:33:28 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 07:34:15 EDT 2016[INFO] BUILD SUCCESS
Thu May 19 08:35:01 EDT 2016[INFO] BUILD SUCCESS
-----

See attached build-error.txt for full build output of one failure run.

The following pull-request includes a unit test that demonstrates one error and includes a fix.
https://github.com/ModeShape/modeshape/pull/1561
",2016/05/19 9:22 AM
MODE-2597,"The https://github.com/ModeShape/modeshape/blob/master/modeshape-jca-rar/src/main/assembly/COPYRIGHT.txt file incorrectly mentions the LGPL license, even though we've moved to the Apache License 2.0 years ago.

This needs to be fixed, and we need to verify that LGPL is no longer referenced in any other files.",2016/05/04 3:12 AM
MODE-2596,"I am calling org.modeshape.jcr.JcrSession.nodeExists. When the repository is empty I very often get this error:

{code:java}
Caused by: javax.jcr.ItemNotFoundException: The node with key 44804707505d64/ no longer exists.
        at org.modeshape.jcr.AbstractJcrNode.node(AbstractJcrNode.java:207)
        at org.modeshape.jcr.JcrSession.node(JcrSession.java:667)
        at org.modeshape.jcr.JcrSession.nodeExists(JcrSession.java:942)
{code}
I never saw this with ModeShape 4.2.0.Final (from which I am trying to migrate).

Is this a known issue? Is the workaround to catch this exception and treat this as though the node does not exist?",2016/04/27 9:02 AM
MODE-2594,"I've been playing around with modeshape, mostly hitting the rest API. I've discovered two problems with the results which i get from the rest API. In both cases, i'm making an ajax request (via jquery if its relevant) and accepting json.

First case (custom properties of objects):
consider a node which have the following custom properties:
{code:javascript}
property1: ""some string""
property2: { subObjectProperty1: ""some string2"", ...}
{code}
If i GET this node, the json which is returned to me is something like the following:
{code:javascript}
{
...
""property1"": ""some string"",
""property2"": ""{\""subObjectProperty1\"":\""some string2\""...}"",
...
}
{code}

the first property is what i would expect but not the second one. For the second, i'd expect the json to treat property two value as an object, not a string value ie
{code:javascript}
""property2"": { ""subObjectProperty1"": ""some string2""....},
{code}

this isn't that big of a deal as i can cleanup the code on the client side. it's fairly predictable. I looked into the modeshape source for a bit but the error seems like it may perhaps be with the json library which modeshape uses. 

Second case (query over property which is array):
Consider that I have a node with a property as follows:
{code:javascript}
""property1"": [""value1"", ""value2""]
{code}
If i invoke a GET on the rest API, i will get the expected JSON. However, if i return this column as a part of a query, I only get the first value. say i select the query as so:
{code:sql}
SELECT property1 from [nt:unstructured] WHERE [jcr:path] = '(put the path here)'. 
{code}
The resulting row will have the following json:
{code:javascript}
""rows"":[{""property1"":""value1"", ""mode:uri""...}]
{code}

as you can see, it does not return an array but rather a string value with the first element in the array. Digging into the code, {{RestQueryHandler.createRestRow}} gets the values for individual rows. it eventually calls {{.getString}} on the value which in fact returns just a string of the first element and not a string of the full array or anything else. 

The first issue is only slightly annoying. The second is actually problematic as I can't use the query functionality to retrieve node properties which are arrays. If i need these values, i'm forced to execute the query to get the relevant nodes and then perform an actual GET on each one.",2016/04/19 9:01 AM
MODE-2592,"When Oracle-based persistent repository is configured in WildFly, it doesn't survive WildFly restart with the following exception:

{noformat}
12:47:46,871 ERROR [stderr] (ServerService Thread Pool -- 75) javax.jcr.RepositoryException: Error while starting 'ora' repository: 1 parameter supplied, but 2 parameters required: ""Ignoring Oracle SQL exception for database {0} with error code {1}"" => ""Ignoring Oracle SQL exception for database 955 with error code {1}""
12:47:46,872 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:634)
12:47:46,872 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:598)
12:47:46,872 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:135)
...
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75) Caused by: java.lang.IllegalArgumentException: 1 parameter supplied, but 2 parameters required: ""Ignoring Oracle SQL exception for database {0} with error code {1}"" => ""Ignoring Oracle SQL exception for database 955 with error code {1}""
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.common.util.StringUtil.createString(StringUtil.java:188)
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.common.logging.slf4j.SLF4JLoggerImpl.debug(SLF4JLoggerImpl.java:126)
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.persistence.relational.OracleStatements.createTable(OracleStatements.java:45)
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.persistence.relational.RelationalDb.runWithConnection(RelationalDb.java:358)
12:47:46,886 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.persistence.relational.RelationalDb.start(RelationalDb.java:85)
12:47:46,887 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:1064)
12:47:46,887 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:936)
12:47:46,887 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository.doStart(JcrRepository.java:367)
12:47:46,887 ERROR [stderr] (ServerService Thread Pool -- 75)  at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:632)
12:47:46,887 ERROR [stderr] (ServerService Thread Pool -- 75)  ... 66 more
{noformat}
because of an attempt to create tables already created during first start with _ORA-00955 name is already used by an existing object_ Oracle response.",2016/04/08 4:04 PM
MODE-2589,"Attempt to rename zero-length file via WebDAV fails at least with ojdbc6.jar driver with the following log messages:

{noformat}
2016-04-05 10:19:31,662 ERROR [io.undertow.request] (default task-50) UT005023: Exception handling request to /modeshape-webdav/sample/default/a: javax.servlet.ServletException: org.modeshape.webdav.exceptions.WebdavException
            at org.modeshape.webdav.WebDavServletBean.service(WebDavServletBean.java:209) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.web.jcr.webdav.ModeShapeWebdavServlet.service(ModeShapeWebdavServlet.java:121) [modeshape-web-jcr-webdav-4.6.0.Final.jar:4.6.0.Final]
            at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
            at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:61) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
            at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:131) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:56) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:33) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:51) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:45) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:63) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:56) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:58) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:70) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.security.handlers.SecurityInitialHandler.handleRequest(SecurityInitialHandler.java:76) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
            at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:119) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:261) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:247) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:76) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:166) [undertow-servlet-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.Connectors.executeRootHandler(Connectors.java:197) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:759) [undertow-core-1.1.0.Final.jar:1.1.0.Final]
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_80]
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_80]
            at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_80]
    Caused by: org.modeshape.webdav.exceptions.WebdavException
            at org.modeshape.web.jcr.webdav.ModeShapeWebdavServlet.translateError(ModeShapeWebdavServlet.java:146) [modeshape-web-jcr-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.web.jcr.webdav.ModeShapeWebdavServlet.translate(ModeShapeWebdavServlet.java:129) [modeshape-web-jcr-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.webdav.WebDavServletBean.service(WebDavServletBean.java:197) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            ... 32 more
    Caused by: java.lang.NullPointerException
            at org.modeshape.jcr.value.binary.Database$DatabaseBinaryStream.read(Database.java:537) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.common.util.SelfClosingInputStream.read(SelfClosingInputStream.java:111) [modeshape-common-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.common.util.SecureHash$HashingInputStream.read(SecureHash.java:380) [modeshape-common-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.common.util.IoUtil.write(IoUtil.java:331) [modeshape-common-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.value.binary.FileSystemBinaryStore.storeValue(FileSystemBinaryStore.java:109) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.value.binary.DatabaseBinaryStore.storeValue(DatabaseBinaryStore.java:171) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:244) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:49) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.JcrValueFactory.createBinary(JcrValueFactory.java:141) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.jcr.JcrValueFactory.createBinary(JcrValueFactory.java:41) [modeshape-jcr-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.web.jcr.webdav.DefaultContentMapper.setContent(DefaultContentMapper.java:203) [modeshape-web-jcr-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.web.jcr.webdav.ModeShapeWebdavStore.setResourceContent(ModeShapeWebdavStore.java:446) [modeshape-web-jcr-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.webdav.methods.DoCopy.copy(DoCopy.java:227) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.webdav.methods.DoCopy.copyResource(DoCopy.java:173) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.webdav.methods.DoMove.execute(DoMove.java:79) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            at org.modeshape.webdav.WebDavServletBean.service(WebDavServletBean.java:157) [modeshape-webdav-4.6.0.Final.jar:4.6.0.Final]
            ... 32 more
{noformat}

",2016/04/06 4:45 AM
MODE-2584,"When a repository is restored from a backup, making a new backup of it results in a zip file where no binaries are included.",2016/03/15 12:28 PM
MODE-2583,Removing indexes definitions form WildFly configuration file doesn't give an effect - indexes are still in use.,2016/03/11 2:26 AM
MODE-2580,"When {{jcr:data}} property of {{nt:resource}} is set with the same value it already has, the property changed event is fired despite of there is no change. Probably this wrong behavior affects all {{BINARY}} properties, nor only the jar:data.",2016/03/04 1:06 PM
MODE-2577,"The documentation for configuring Elastic Search as an Index provider is incorrect when using WIldfly.

The example does not work and should actually be

{code:xml}
<index-provider name=""elastic"" classname=""org.modeshape.jcr.index.elasticsearch.EsIndexProvider"" module=""org.modeshape.index-provider.elasticsearch"" host=""localhost"" port=""9300"" />
{code}



There are also some formatting errors on the page.

It would also help to document the supported version(s) that the integration works with. After looking through the Modeshape code base I believe it is 2.1.0. I can confirm it does not work with Elastic Search 1.5.

It would also be nice if an alias was added to org.modeshape.jcr.RepositoryConfiguration.java as per local and lucene providers so you don't need to provide the full classname.",2016/03/03 3:45 PM
MODE-2573,"When running a query against an index which has more than 100 entries and using offset in that query to retrieve nodes that have an index greater than 99 in the result set, only nodes 0-99 will be returned i.e. offset 0 and offset 100 return the same node.",2016/02/25 7:03 PM
MODE-2565,The Lucene Index provider will re-index the entire repository when-ever the repository is restarted even if there are no changes to the repository. This does NOT happen when using the Local Index provider.,2016/02/03 4:26 PM
MODE-2564,"(!) Seems to affect all of 4.x (and possibly 5.0.0-Alpha1) versions.

{{org.modeshape.jcr.query.QueryBuilder}} does not register any LIMIT after the call to ""limit"" method. The same issue is with the ""offset"" method, as well.

The code in the method should probably be something like this:


{code:java}
public QueryBuilder limit( int rowLimit ) {
       // this.limit.withRowLimit(rowLimit);

this.limit = this.limit.withRowLimit(rowLimit);
        return this;
    }
{code}


This way LIMIT attribute of the builder is correctly reinitialized with the provided {{rowLimit}}.",2016/02/02 8:40 AM
MODE-2562,"If you create and then restore a backup using org.modeshape.jcr.api.RepositoryManager, all string properties containing two backslashes '&#92;&#92;', are replaced to contain a single backslash '&#92;'.

For example if you have a value ""foo&#92;&#92;bar"", after you backup and restore the value would be ""foo&#92;bar""

Here's a simple program, which shows the effect.

This is the output:
{noformat}
Jan 22, 2016 3:21:58 PM org.modeshape.common.logging.LogFactory <clinit>
INFO: No custom logger, SLF4J implementation or Log4j located in the classpath. ModeShape will use the JDK logger for logging.
Jan 22, 2016 3:21:59 PM org.modeshape.jcr.ModeShape <clinit>
INFO: ModeShape version 4.5.0.Final
Jan 22, 2016 3:22:00 PM org.infinispan.factories.GlobalComponentRegistry start
INFO: ISPN000128: Infinispan version: Infinispan 'Insanely Bad Elf' 7.2.4.Final
Jan 22, 2016 3:22:00 PM org.infinispan.transaction.lookup.GenericTransactionManagerLookup useDummyTM
WARN: ISPN000104: Falling back to DummyTransactionManager from Infinispan
Values before creating backup:
The value of 'oneBackslash' is 'one\backslash'
The value of 'twoBackslashes' is 'two\\backslashes'
The value of 'threeBackslashes' is 'three\\\backslashes'
Values after restoring backup:
The value of 'oneBackslash' is 'one\backslash'
The value of 'twoBackslashes' is 'two\backslashes'
The value of 'threeBackslashes' is 'three\\backslashes'
{noformat}

And here is the program itself
{code:java}
import java.io.File;
import java.net.URL;
import java.nio.file.Files;

import javax.jcr.Repository;
import javax.jcr.Session;

import org.infinispan.schematic.document.ParsingException;
import org.modeshape.common.collection.Problems;
import org.modeshape.jcr.ModeShapeEngine;
import org.modeshape.jcr.RepositoryConfiguration;
import org.modeshape.jcr.api.RepositoryManager;

public class ModeShapeBug {
    private static final String REPO_CONFIG_FILE = ""repo-config.json"";
    private static final String WORKSPACE_NAME = ""configuration"";

    private static URL repositoryUrl;
    private static ModeShapeEngine engine;
    private static RepositoryConfiguration config;

    public static void main(String[] args) throws Exception {
        repositoryUrl = ModeShapeBug.class.getClassLoader().getResource(REPO_CONFIG_FILE);
        engine = new ModeShapeEngine();

        engine.start();
        try {
            config = readConfig(repositoryUrl);
            engine.deploy(config);
            File tempDir = Files.createTempDirectory(""modeshape-restore-bug-"").toFile();

            String oneBackslash = ""oneBackslash"";
            String twoBackslashes = ""twoBackslashes"";
            String threeBackslashes = ""threeBackslashes"";

            setPropertyValue(oneBackslash, ""one\\backslash"");
            setPropertyValue(twoBackslashes, ""two\\\\backslashes"");
            setPropertyValue(threeBackslashes, ""three\\\\\\backslashes"");

            System.out.printf(""Values before creating backup:\n"");
            printPropertyValue(oneBackslash);
            printPropertyValue(twoBackslashes);
            printPropertyValue(threeBackslashes);

            createBackup(tempDir);
            restoreBackup(tempDir);

            System.out.printf(""Values after restoring backup:\n"");
            printPropertyValue(oneBackslash);
            printPropertyValue(twoBackslashes);
            printPropertyValue(threeBackslashes);
        } finally {
            engine.shutdown().get();
        }
    }

    private static String printPropertyValue(String property) throws Exception {
        Session session = startSession();
        try {
            String value = session.getRootNode().getProperty(property).getString();
            System.out.printf(""The value of '%s' is '%s'\n"", property, value);
            return value;
        } finally {
            session.logout();
        }
    }

    private static void setPropertyValue(String property, String value) throws Exception {
        Session session = startSession();
        try {
            session.getRootNode().setProperty(property, value);
            session.save();
        } finally {
            session.logout();
        }
    }

    private static void createBackup(File tempDir) throws Exception {
        Session session = startSession();
        try {
            RepositoryManager repositoryManager =
                    ((org.modeshape.jcr.api.Session)session).getWorkspace().getRepositoryManager();
            org.modeshape.jcr.api.Problems problems = repositoryManager.backupRepository(tempDir);
            if (problems.hasProblems()){
                throw new RuntimeException(""Problems creating backup: "" + problems);
            }
        } finally {
            session.logout();
        }
    }

    private static void restoreBackup(File tempDir) throws Exception {
        Session session = startSession();
        try {
            RepositoryManager repositoryManager =
                    ((org.modeshape.jcr.api.Session)session).getWorkspace().getRepositoryManager();
            org.modeshape.jcr.api.Problems problems = repositoryManager.restoreRepository(tempDir);
            if (problems.hasProblems()){
                throw new RuntimeException(""Problems restoring backup: "" + problems);
            }
        } finally {
            session.logout();
        }
    }

    private static RepositoryConfiguration readConfig(URL repositoryUrl) throws ParsingException {
        RepositoryConfiguration config = RepositoryConfiguration.read(repositoryUrl);
        Problems problems = config.validate();
        if (problems.hasErrors()) {
            throw new RuntimeException(""Problems starting the engine: "" + problems);
        }
        return config;
    }

    private static Session startSession()
            throws Exception {
        Repository repository = engine.getRepository(config.getName());
        Session session = repository.login(WORKSPACE_NAME);
        return session;
    }
}
{code}

I'm also going to attach it as a maven project, so you can take a better look at it if needed.",2016/01/22 8:57 AM
MODE-2560,As mentioned in https://developer.jboss.org/thread/267273 there is a failure if you try to delete all versions of a node with the which has been updated and copied. The copy has a strong reference to the versions of the original node.,2016/01/14 1:51 AM
MODE-2558,"I have created a sample application https://github.com/lucasweb78/modeshape-test-app that demonstrates a concurrency issue when multiple threads modify the same node structure using User Transactions. 

The issue only appears to happen when run inside of Wildfly, I have yet to re-create it outside of Wildfly.

It appears that under concurrent load a child node can be created and committed with a reference to a parent node, but the parent node does *not* contain a reference to the child, most likely because it was overwritten in a different thread. Once this happens any attempt to access the node  results in a NodeNotFoundInParentException

Strangely the issue only occurs if eviction is enabled in the Infinispan cache, even though the entry limit is not reached.",2016/01/08 7:04 PM
MODE-2548,"One of the logging statements from the Lucene index provider {{MultiColumnIndex}} has an incorrect number of parameters passed, causing an exception when the logging level is set to DEBUG (see linked forum issue)",2015/12/28 2:48 AM
MODE-2547,"Data corrupted when using JCR setProperty with BinaryValue.
{code}
node.setProperty (Property.JCR_DATA,session.getValueFactory().createBinary(file));
{code}

Putting db.requestStart()/db.requestDone() in     
org.modeshape.jcr.value.binary.MongodbBinaryStore.storeValue( InputStream stream,boolean markAsUnused )
surrounding the writing operation, could avoid the data corruption.

Please see https://developer.jboss.org/thread/266829",2015/12/20 9:25 PM
MODE-2539,"When attempting to restore a repository backup from {{3.8.1.Final}} into a {{4.5.0.Final}} repository which contains index definitions, the following exception is raised:
{code:java}
main 12:00:00,301  INFO SLF4J implementation located in the classpath. It will be used by ModeShape for logging.main 12:00:00,441  INFO ModeShape version 4.6-SNAPSHOT
main 12:00:01,694  INFO ARJUNA012163: Starting service com.arjuna.ats.arjuna.recovery.ActionStatusService on port 51302
main 12:00:01,697  INFO ARJUNA012337: TransactionStatusManagerItem host: 127.0.0.1 port: 51302
main 12:00:01,703  INFO ARJUNA012170: TransactionStatusManager started on port 51302 and host 127.0.0.1 with service com.arjuna.ats.arjuna.recovery.ActionStatusService
main 12:00:03,928 ERROR Error while refreshing index definitions for the ""Backup Repository"" repository
java.lang.NullPointerException
	at org.modeshape.jcr.SystemContent.indexesKey(SystemContent.java:154)
	at org.modeshape.jcr.SystemContent.indexesNode(SystemContent.java:202)
	at org.modeshape.jcr.SystemContent.readAllIndexDefinitions(SystemContent.java:565)
	at org.modeshape.jcr.RepositoryIndexManager.readIndexDefinitions(RepositoryIndexManager.java:819)
	at org.modeshape.jcr.RepositoryIndexManager.register(RepositoryIndexManager.java:325)
	at org.modeshape.jcr.RepositoryIndexManager.<init>(RepositoryIndexManager.java:135)
	at org.modeshape.jcr.RepositoryQueryManager.<init>(RepositoryQueryManager.java:101)
	at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:1208)
	at org.modeshape.jcr.JcrRepository$RunningState.<init>(JcrRepository.java:982)
	at org.modeshape.jcr.JcrRepository.doStart(JcrRepository.java:388)
	at org.modeshape.jcr.JcrRepository.start(JcrRepository.java:312)
	at org.modeshape.jcr.JcrRepository.completeRestore(JcrRepository.java:543)
	at org.modeshape.jcr.BackupService.restoreRepository(BackupService.java:161)
	at org.modeshape.jcr.JcrRepositoryManager.restoreRepository(JcrRepositoryManager.java:87)
	at org.modeshape.jcr.JcrRepositoryManager.restoreRepository(JcrRepositoryManager.java:81)
	at org.modeshape.jcr.RepositoryBackupAndRestoreTest.shouldRestoreLegacy381_2Repository(RepositoryBackupAndRestoreTest.java:149)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
{code} ",2015/11/30 5:04 AM
MODE-2537,"ModeShape spawns separate threads for a number of different things, including the repository statistics and the repository change bus. However, if an error occurs during the repository startup or while the repository attempts to initialize, some of the already started components & thread pools are not correctly shut down, leaving potential open resources.

The repository should make sure it correctly cleans up any active components in case of an unorderly shutdown.",2015/11/25 8:32 AM
MODE-2535,"I configure three users with roles :
userread=connect,readonly
userwrite=connect,readwrite
useradmin=connect,admin

userread is not allowed to read content through web explorer. We got this message in log :

{code:java}
javax.jcr.AccessDeniedException: Permission denied to perform actions ""[read]"" on path <unknown>
	at org.modeshape.jcr.JcrSession.checkPermission(JcrSession.java:1577) ~[modeshape-jcr-4.4.0.Final.jar:4.4.0.Final]
	at org.modeshape.jcr.JcrSession.checkWorkspacePermission(JcrSession.java:1582) ~[modeshape-jcr-4.4.0.Final.jar:4.4.0.Final]
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:706) ~[modeshape-jcr-4.4.0.Final.jar:4.4.0.Final]
{code}
And Web Explorer respond this message : ""Permission denied to perform actions ""read access control content"" on path /""

With WebDav or Rest, my user ""userread"" has no problem to read the content. ",2015/11/20 10:50 AM
MODE-2533,"Given a parent node type definition that allows SNS but is not a super-type of {{\[nt:unstructured\]}}, same name siblings are not correctly created under this parent, each child node with the same name having a non-indexed path. 

In other words, in this case all SNS will appear to have the same path.",2015/11/16 4:17 AM
MODE-2530,"There a two threads: 
* Thread A creates new nodes as children of node P and marks the created nodes as versionable.
* Thread B gets P and iterates over all children. For each child versionManager.getBaseVersion(child.getPath()) is called if the child is versionable.

When Thread A and B are running at the same time, the following error might occur:

{code}
javax.jcr.version.VersionException: Cannot find the base version with the key 'a69d00a317f1e709b57fe2-f3cf-420e-a33a-c2c40e770f14' for the node '/uploads/test7'. Make sure that any checkin/checkout operations are atomic for that node.
	at org.modeshape.jcr.AbstractJcrNode.getBaseVersion(AbstractJcrNode.java:3300)
	at org.modeshape.jcr.JcrVersionManager.getBaseVersion(JcrVersionManager.java:282)
	at de.doubleslash.modeshape.versionexceptionbug.impl.GetBaseVersionRunnable.run(GetBaseVersionRunnable.java:44)
	at java.lang.Thread.run(Thread.java:744)
Caused by: org.modeshape.jcr.cache.NodeNotFoundInParentException: Cannot locate child node: a69d00a317f1e710377623-b2bb-4808-ade4-c8730e8024aa within parent: a69d00a317f1e7jcr:versionStorage
	at org.modeshape.jcr.cache.document.LazyCachedNode.parentReferenceToSelf(LazyCachedNode.java:247)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getSegment(LazyCachedNode.java:284)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:293)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:292)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:292)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:292)
	at org.modeshape.jcr.cache.document.LazyCachedNode.getPath(LazyCachedNode.java:292)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:562)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:507)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:485)
	at org.modeshape.jcr.AbstractJcrNode.getBaseVersion(AbstractJcrNode.java:3296)
	... 3 more
{code}

Might be similiar to MODE-2418.",2015/11/11 9:31 AM
MODE-2517,"When a reindexing operation is performed either at startup or via an API method call (for example {{workspace.reindex}}), the indexing framework should make sure that the changes are committed to each {{ProvidedIndex}} via the {{commit}} method.

Otherwise it may happen in certain cases (see forum discussion) that the reindexed information is lost.",2015/10/30 2:01 AM
MODE-2514,"When configuring a FS connector with a filter and preconfigured projection which doesn't match the file filter:
{code:javascript}
 ""json-filter"" : {
            ""classname"" : ""filesystem"",
            ""directoryPath"" : ""target/federation/files-json-filter"",
            ""projections"" : [ ""default:/json_filter => /"" ],
            ""enableEvents"" : true,
            ""cacheTtlSeconds"" : 0,
            ""inclusionPattern"" : "".+[.]json$""
        }
{code}
the connector doesn't consider the preconfigured projection, failing with error messages like:
{code:java}
java.lang.AssertionError: Found a child reference in / to a non-existant child {}json_filter
	at org.modeshape.jcr.JcrSession.cachedNode(JcrSession.java:629)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:658)
	at org.modeshape.jcr.JcrSession.node(JcrSession.java:677)
	at org.modeshape.jcr.JcrSession.getNode(JcrSession.java:861)
	at org.modeshape.jcr.JcrSession.getNode(JcrSession.java:844)
	at org.modeshape.jcr.AbstractJcrRepositoryTest.assertNode(AbstractJcrRepositoryTest.java:119)
{code}
",2015/10/27 3:41 AM
MODE-2511,"Calling {{orderBefore}} on children of node which supports ordering but disallows same name siblings causes {{session.save()}} to fail (NPE on WritableSessionCache:1033).

The ""patch"" with test is attached.",2015/10/02 8:46 AM
MODE-2510,"If {{\[jcr:path\]}} indexes are defined for an index provider and node type and that node type supports SNS, reordering those same name sibling children is not reflected in the path indexes.

For example:
{code}
childA       (id=1)
childB       (id=2)
childC       (id=3)
childB[2]    (id=4)
childB[3]    (id=5)
childD       (id=6)
childE       (id=7)
childB[4]    (id=8)
{code}

reordering childB\[4\] before childC would result in:

{code}
childA       (id=1)
childB       (id=2)
childB[2]    (id=8)
childC       (id=3)
childB[3]    (id=4)
childB[4]    (id=5)
childD       (id=6)
childE       (id=7)
{code}

The current {{NodeReordered}} events do not contain enough information for an index to be able to perform the necessary changes, which affect not only the source and target node, but other nodes in the hierarchy as well.

See the discussion on https://github.com/ModeShape/modeshape/pull/1469 for more information.",2015/10/01 1:57 PM
MODE-2498,"I'm running into an issue with the following example node types, indexes and query:

{noformat}

mix:custom > mix:title
  - nt:a (string)
mix:custom2 > mix:title
  - nt:b (string)

<index name=""custom_names"" provider-name=""local"" synchronous=""true"" node-type=""mix:custom"" columns=""jcr:name(NAME)"" />
<index name=""custom2_names"" provider-name=""local"" synchronous=""true"" node-type=""mix:custom2"" columns=""jcr:name(NAME)"" />

SELECT * FROM [mix:custom] as custom where custom.[jcr:name] = 'myFirstBook'

{noformat}

This fails to find any nodes even though one exists. If I remove the 'custom2_names' index the query works. 

The plan for the failed query is

{noformat}
JCR-SQL2 -> SELECT * FROM [mix:custom] as custom where custom.[jcr:name] = 'myFirstBook'
AQM -> SELECT * FROM [mix:custom] AS custom WHERE custom.[jcr:name] = 'myFirstBook'
 plan -> Access [custom]
  Project [custom] <PROJECT_COLUMNS=[custom.[jcr:title], custom.[jcr:description], custom.[mode:localName], custom.[mode:id], custom.[mode:depth], custom.[jcr:score], custom.[jcr:path], custom.[jcr:name]], PROJECT_COLUMN_TYPES=[STRING, STRING, STRING, STRING, LONG, DOUBLE, STRING, STRING]>
    Select [custom] <SELECT_CRITERIA=NAME(custom) = 'myFirstBook'>
      Select [custom] <SELECT_CRITERIA=custom.[jcr:mixinTypes] = 'mix:custom'>
        Source [custom] <SOURCE_NAME=__ALLNODES__, SOURCE_ALIAS=custom, SOURCE_COLUMNS=[jcr:isCheckedOut(BOOLEAN), jcr:defaultPrimaryType(STRING), mode:uri(STRING), mode:lockingSession(STRING), jcr:etag(STRING), jcr:created(DATE), jcr:sameNameSiblings(BOOLEAN), jcr:encoding(STRING), jcr:workspace(STRING), jcr:activityTitle(STRING), jcr:mergeFailed(STRING), jcr:frozenMixinTypes(STRING), jcr:isQueryOrderable(BOOLEAN), jcr:lastModifiedBy(STRING), jcr:childVersionHistory(STRING), mode:synchronous(BOOLEAN), jcr:repository(STRING), mode:derivedAt(DATE), jcr:lastModified(DATE), jcr:successors(STRING), jcr:availableQueryOperators(STRING), mode:derivedFrom(STRING), jcr:primaryItemName(STRING), mode:isSessionScoped(BOOLEAN), jcr:frozenUuid(STRING), jcr:isFullTextSearchable(BOOLEAN), jcr:defaultValues(STRING), mode:sharedUuid(STRING), jcr:predecessors(STRING), jcr:content(STRING), mode:projectedNodeKey(STRING), jcr:language(STRING), jcr:valueConstraints(STRING), mode:sha1(STRING), jcr:activity(STRING), jcr:requiredPrimaryTypes(STRING), jcr:baseVersion(STRING), jcr:requiredType(STRING), jcr:autoCreated(BOOLEAN), jcr:isAbstract(BOOLEAN), mode:externalNodeKey(STRING), jcr:hasOrderableChildNodes(BOOLEAN), mode:lockToken(STRING), mode:kind(STRING), mode:alias(STRING), mode:columnTypeName(STRING), jcr:text(STRING), jcr:mimeType(STRING), mode:workspace(STRING), jcr:data(BINARY), jcr:port(STRING), jcr:protected(BOOLEAN), jcr:primaryType(STRING), mode:expirationDate(DATE), jcr:id(STRING), privileges(STRING), jcr:host(STRING), jcr:lifecyclePolicy(STRING), jcr:versionHistory(STRING), jcr:mixinTypes(STRING), jcr:isQueryable(BOOLEAN), jcr:mandatory(BOOLEAN), jcr:lockIsDeep(BOOLEAN), jcr:currentLifecycleState(STRING), jcr:nodeTypeName(STRING), jcr:isMixin(BOOLEAN), name(STRING), jcr:messageId(STRING), jcr:uuid(STRING), jcr:multiple(BOOLEAN), jcr:title(STRING), jcr:onParentVersion(STRING), mode:nodeTypeName(STRING), jcr:supertypes(STRING), jcr:protocol(STRING), mode:propertyName(STRING), jcr:frozenPrimaryType(STRING), jcr:lockOwner(STRING), jcr:createdBy(STRING), jcr:isDeep(BOOLEAN), jcr:hold(STRING), jcr:configuration(STRING), jcr:description(STRING), jcr:statement(STRING), mode:isHeldBySession(BOOLEAN), mode:workspaces(STRING), jcr:copiedFrom(STRING), jcr:retentionPolicy(STRING), jcr:root(STRING), jcr:versionableUuid(STRING), mode:generated(BOOLEAN), mode:localName(STRING), mode:id(STRING), mode:depth(LONG), jcr:score(DOUBLE), jcr:path(STRING), jcr:name(STRING)]>
          Index [custom] <INDEX_SPECIFICATION=custom2_names, provider=local, cost~=100, cardinality~=0, selectivity~=NaN, constraints=[NAME(custom) = 'myFirstBook'], INDEX_USED=true>
          Index [custom] <INDEX_SPECIFICATION=custom_names, provider=local, cost~=100, cardinality~=1, selectivity~=1.0, constraints=[NAME(custom) = 'myFirstBook']>

Result columns: 
 custom.[jcr:title]
 custom.[jcr:description]
 custom.[mode:localName]
 custom.[mode:id]
 custom.[mode:depth]
 custom.[jcr:score]
 custom.[jcr:path]
 custom.[jcr:name]
{noformat}

As you can see the plan is selecting the custom2_names index even though it is not the best one.",2015/08/12 6:25 PM
MODE-2497,"When performing SQL2 queries containing strings with the german  symbol, the query is not parsed correctly.

{noformat}
Exception when handling request.: javax.jcr.query.InvalidQueryException: The JCR-SQL2 query ""SELECT metadatanode.*, document.'jcr:created' FROM [tresorxml:element] AS metadatanode INNER JOIN [tresorxml:document] AS document ON ISDESCENDANTNODE(metadatanode, document) WHERE NAME(metadatanode) = 'xaip:metaDataSection' AND PATH(document) LIKE '/tresorxml:vault[5]/My Folders/?/%' AND DEPTH(document) = CAST(4 AS LONG) ORDER BY document.'jcr:created' DESC"" is not well-formed: Unexpected token 'AND' at line 1, column 250
{noformat}

The reason for this is that the tokeniser parses queries in a case-insensitive manner, and the JVM converts  to SS in upper-case (see e.g. http://www.the-interweb.com/serendipity/index.php?/archives/80-Converting-strings-to-upper-case-is-tricky.html ).

The result is the upper-case string is longer than the lower-case version. This sends the indexes out of kilter within the TokenStream class when using case insensitive tokenising.

The solution is to override the match method in the CaseInsensitiveToken to convert the current token to upper-case, rather than storing an upper-case version of the entire input string, which may not have the same indexes as the lower-case version.

",2015/08/03 8:50 AM
MODE-2495,"When using user transactions which are shared by multiple threads - i.e. one thread starts a transaction, makes some repository changes *but another thread* commits this transaction - the changes made by the ""owner"" thread are not visible to the outside.",2015/07/23 6:02 AM
MODE-2493,"ModeShape attempts to roll-back transactions whenever an unexpected exception is caught during a session save or during one of the operations executed at repository startup.

When using ModeShape managed transactions, if such a transaction throws an exception during {{tx.commit}}, depending on the case (see linked issue for an example) some other party (most notably AS or ISPN) can rollback the transaction in response.
 
If that is the case, ModeShape should not attempt to {{rollback}} the transaction again (which will fail) because this will hide the original cause of the failure. In such cases, ModeShape should make sure the original exception (which triggered the rollback in the first place) is sent back to the caller.",2015/07/09 5:31 AM
MODE-2485,"ModeShape uses several background GC tasks to cleanup repository data. One such task is the JCR lock garbage collector which cleans up orphaned locks from the repository. These tasks run periodically at either a preset or configured time interval. 

When running in a cluster however, it can very well happen that these GC jobs fire all at the same time (or very close together) so that essentially all compete for the same ISPN data. In the case of the Lock GC collector, all of these tasks will attempt to lock the {{mode:locks}} root parent key first. If this happens, depending on how long a job takes, ISPN may fire {{TimeoutExceptions}} for the competing locks:

{code:java}
00:05:47,157 ERROR [org.modeshape.jcr.RepositoryLockManager] (modeshape-gc-8-thread-1) Error while cleaning up locks for the ""dv"" repository: org.modeshape.jcr.cache.WrappedException: org.modeshape.jcr.TimeoutException: Unable to acquire storage locks: [d7d2e6b317f1e7mode:locks]
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:529) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:421) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.RepositoryLockManager.cleanupLocks(RepositoryLockManager.java:179) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.JcrRepository$RunningState.cleanUpLocks(JcrRepository.java:1797) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.JcrRepository$LockGarbageCollectionTask.doRun(JcrRepository.java:2132) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.JcrRepository$BackgroundRepositoryTask.run(JcrRepository.java:2102) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) [rt.jar:1.7.0_75]
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304) [rt.jar:1.7.0_75]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178) [rt.jar:1.7.0_75]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [rt.jar:1.7.0_75]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_75]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_75]
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_75]
Caused by: org.modeshape.jcr.TimeoutException: Unable to acquire storage locks: [d7d2e6b317f1e7mode:locks]
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:488) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	... 12 more
Caused by: org.infinispan.util.concurrent.TimeoutException: Unable to acquire storage locks: [d7d2e6b317f1e7mode:locks]
	at org.modeshape.jcr.cache.document.WritableSessionCache.lockNodes(WritableSessionCache.java:1449) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:451) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
	... 12 more
{code}

We should make sure that for the GC jobs, whenever a {{TimeoutException}} occurs due to ISPN not being able to lock an entry, the exception is only logged and does not break the underlying node. The GC job is then re-ran later on, based on the configured timing.",2015/07/01 5:01 AM
MODE-2484,"When setting binary values on properties, ModeShape uses a reference counting mechanism to optimize multiple properties using the same value.
This mechanism is implemented via ""special"" ISPN documents which hold the {{SHA1}} of the binary value and the {{BinaryKey}}. 

Currently, whenever a binary usage changes, ModeShape will attempt to read & update this document from ISPN *within the context of an existing transaction*. When making a set of changes, ModeShape preemptively locks *the nodes* in ISPN which are part of those changes to ensure strong serializable consistency. Those locks are places only on node keys however, not on *binary keys*. The binary keys are locked later, one by one, during the logic which processes the node changes.

The above means that there can be 2 transactions: T1 and T2, both operating on disjoint nodes keys which can intersect on the binary keys they lock later on. This intersection can lead to ISPN deadlocks, resulting in exceptions similar to:

{code:java}
00:00:01,117 ERROR [org.infinispan.interceptors.InvocationContextInterceptor] (OOB-6,shared=tcp) ISPN000136: Execution error: org.infinispan.util.concurrent.TimeoutException: Unable to acquire lock after [45 seconds] on key [9e504611ee3f17e8ab6265af313358d7ad487b5d-ref] for requestor [GlobalTransaction:<dvqe08:server08/modeshape>:288724:remote]! Lock held by [GlobalTransaction:<dvqe10:server10/modeshape>:59532:remote]
	at org.infinispan.util.concurrent.locks.LockManagerImpl.lock(LockManagerImpl.java:213)
	at org.infinispan.util.concurrent.locks.LockManagerImpl.acquireLock(LockManagerImpl.java:186)
	at org.infinispan.interceptors.locking.AbstractTxLockingInterceptor.lockKeyAndCheckOwnership(AbstractTxLockingInterceptor.java:192)
	at org.infinispan.interceptors.locking.AbstractTxLockingInterceptor.lockAndRegisterBackupLock(AbstractTxLockingInterceptor.java:129)
	at org.infinispan.interceptors.locking.PessimisticLockingInterceptor.visitLockControlCommand(PessimisticLockingInterceptor.java:253)
	at org.infinispan.commands.control.LockControlCommand.acceptVisitor(LockControlCommand.java:131)
	at org.infinispan.interceptors.base.CommandInterceptor.invokeNextInterceptor(CommandInterceptor.java:120)
	at org.infinispan.interceptors.base.CommandInterceptor.handleDefault(CommandInterceptor.java:134)
	at org.infinispan.commands.AbstractVisitor.visitLockControlCommand(AbstractVisitor.java:177)
	at org.infinispan.commands.control.LockControlCommand.acceptVisitor(LockControlCommand.java:131)
	at org.infinispan.interceptors.base.CommandInterceptor.invokeNextInterceptor(CommandInterceptor.java:120)
	at org.infinispan.interceptors.TxInterceptor.invokeNextInterceptorAndVerifyTransaction(TxInterceptor.java:128)
	at org.infinispan.interceptors.TxInterceptor.visitLockControlCommand(TxInterceptor.java:186)
	at org.infinispan.commands.control.LockControlCommand.acceptVisitor(LockControlCommand.java:131)
	at org.infinispan.interceptors.base.CommandInterceptor.invokeNextInterceptor(CommandInterceptor.java:120)
	at org.infinispan.interceptors.base.CommandInterceptor.handleDefault(CommandInterceptor.java:134)
{code}",2015/07/01 4:51 AM
MODE-2477,"Sequencing of the attached VDB fails with:
{code}
08:48:04,412 ERROR [org.modeshape.jcr.SequencingRunner] (modeshape-sequencer-6-thread-1) The 'teiid-vdb-sequencer' sequencer of repository 'dv' had an error while processing '/files/QT_Vanilla_Hive_Push.vdb/jcr:content/jcr:data' in workspace 'default' and generating output '/derived/teiid/vdbs/QT_Vanilla_Hive_Push.vdb': javax.jcr.nodetype.ConstraintViolationException: The mandatory property named 'vdb:path' defined in type 'vdb:marker' is missing from the node at '/derived/teiid/vdbs/QT_Vanilla_Hive_Push.vdb/Source.xmi/vdb:markers/vdb:marker'
{code}",2015/06/15 9:31 AM
MODE-2476,"When trying to sequence second (and later) XMI files, the sequencing fails with [1]. Attaching two xmi files that can be used to reproduce the bug.

Note no such problems arise with other sequencers (XML, CND etc.)

{code}
[1]
08:40:10,294 ERROR [org.modeshape.jcr.SequencingRunner] (modeshape-sequencer-6-thread-1) The 'teiid-model-sequencer' sequencer of repository 'dv' had an error while processing '/files/BQT1.xmi/jcr:content/jcr:data' in workspace 'default' and generating output '/derived/teiid/models/BQT1.xmi': javax.jcr.RepositoryException: The session with an ID of '275407465' has been closed and can no longer be used.
{code}

A more complete stacktrace looks like:
{code:java}
17:39:19,807 ERROR [org.modeshape.sequencer.teiid.VdbSequencer] (modeshape-sequencer-6-thread-4) Error reading VDB file ""/files/teiid-ms/TopPartsVDB.vdb/jcr:content/jcr:data"": The session with an ID o
f '2a8a8297f' has been closed and can no longer be used. : javax.jcr.RepositoryException: The session with an ID of '2a8a8297f' has been closed and can no longer be used.
        at org.modeshape.jcr.JcrSession.checkLive(JcrSession.java:321) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
        at org.modeshape.jcr.JcrSession.getValueFactory(JcrSession.java:1272) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
        at org.modeshape.jcr.JcrSession.getValueFactory(JcrSession.java:135) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
        at org.modeshape.sequencer.teiid.model.ModelNodeWriter.writeUnresolvedReferences(ModelNodeWriter.java:207)
        at org.modeshape.sequencer.teiid.model.ModelNodeWriter.write(ModelNodeWriter.java:161)
        at org.modeshape.sequencer.teiid.model.ModelSequencer.sequenceModel(ModelSequencer.java:187)
        at org.modeshape.sequencer.teiid.model.ModelSequencer.sequenceVdbModel(ModelSequencer.java:217)
        at org.modeshape.sequencer.teiid.VdbSequencer.execute(VdbSequencer.java:163)
        at org.modeshape.jcr.SequencingRunner.run(SequencingRunner.java:196) [modeshape-jcr-3.8.3.GA-redhat-3.jar:3.8.3.GA-redhat-3]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) [rt.jar:1.7.0_40]
        at java.util.concurrent.FutureTask.run(FutureTask.java:262) [rt.jar:1.7.0_40]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_40]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_40]
        at java.lang.Thread.run(Thread.java:724) [rt.jar:1.7.0_40]
{code}",2015/06/15 9:27 AM
MODE-2474,"When defining a binary store as follows in the WildFly configuration:

{code}
<file-binary-storage min-value-size=""40"" path=""data/odm"" relative-to=""/"" store-name=""default""/>
{code}

The configuration does not pick up on the binary store:

{code}
[standalone@localhost:9990 /] /subsystem=modeshape/repository=sample/configuration=binary-storage:read-resource
{
    ""outcome"" => ""success"",
    ""result"" => {""storage-type"" => {""file-binary-storage"" => undefined}}
}
{code}

Resulting in binaries being stored in /tmp/modeshape-binary-store

If the store-name is left out it works fine.",2015/06/12 5:49 AM
MODE-2473,"Hello modeshape team, 

since we've upgraded to modeshape 4.3 we're experiencing troubles using QueryResultIterator.skip(...), i.e. we get the following exception:

{code}
java.util.NoSuchElementException
	at org.modeshape.jcr.query.JcrQueryResult$QueryResultIterator.moveToNextRow(JcrQueryResult.java:249)
	at org.modeshape.jcr.query.JcrQueryResult$QueryResultIterator.skip(JcrQueryResult.java:270)
{code}
	
Originally our source looked like this (sql, offset, and maxResults are passed as parameters):
{code}
	final QueryManager queryManager = getSession().getWorkspace().getQueryManager();
	final Query query = queryManager.createQuery(sql, Query.JCR_SQL2);
	final QueryResult result = query.execute();

	final NodeIterator nodeIterator = result.getNodes();
	if (nodeIterator.getSize() > offset) {
		nodeIterator.skip(offset);
	}
	for (int i = 0; i < maxResults && nodeIterator.hasNext(); i++) {
		final Node node = (Node) nodeIterator.next();
		...
	}
{code}

Everything worked fine with modeshape 4.2, but with 4.3 we're getting a java.util.NoSuchElementException when calling nodeIterator.skip (not every time but in most of the cases). 

With some debugging we've identified the cause within org.modeshape.jcr.query.engine.process.new Batch().hasNext() which has been changed according to MODE-2435. 
{code}
@Override
    public boolean hasNext() {
-   	return remainingRowCount.get() > 0 && rows.hasNext();
+       return rowsLeftInBatch.get() > 0 && rows.hasNext();
    }
{code}
Currently we've implemented the following workaround which works as intended:
{code}
	final NodeIterator nodeIterator = result.getNodes();
	if (nodeIterator.getSize() > offset) {
		for (int i = 0; i < offset; i++) {
			if (nodeIterator.hasNext()) {
				nodeIterator.nextNode();
			}
		}
	}
	for (int i = 0; i < maxResults && nodeIterator.hasNext(); i++) {
		final Node node = (Node) nodeIterator.next();
		...
	}
{code}
It looks like currentBatch is not set to null by QueryResultIterator.hasNext() as org.modeshape.jcr.query.engine.process.new Batch().hasNext() is not using the variable 'remainingRowCount' anymore but  'rowsLeftInBatch' instead. 
",2015/06/11 9:08 AM
MODE-2467,"In the latest build of Modeshape 4.3-SNAPSHOT (commit aa7398f283b55ae2d5e40b07b84ef05fc383723c)

I am getting an ""Add mixin"" dialog when refreshing. Using Mozilla Firefox 38.0 on Ubuntu 15.04",2015/05/18 10:07 AM
MODE-2465,"DDL parser should treat dollar sign (""$"") as a valid name character.

This issue has been partialy addressed in MODE-1939 but id did not add dollar sign as a valid character in case of colum names.",2015/05/11 3:53 AM
MODE-2463,"The following scenario causes a disparity between String path = node.getPath() and session.getNode(path).

* Create a new session (session1)
* Add 'testNode' as a child of root
* Save the session
* Logout of the session

* Create a new session (session2)
* Get the node at the path '/testNode'
* Remove testNode
* Re-add the node as a child of root (effectively restoring it but lets call it newTestNode for clarity), using rootNode.addNode('testNode')

Observations:
* Calling newTestNode.getPath() should return '/testNode' but in fact returns '/testNode[2]'
* Calling session2.getNode('/testNode[2]') throws a PathNotFoundException
* Calling session2.getNode('/testNode') returns the newTestNode

It appears that the calculation for the newTestNode.getPath() is not correct for a mid-session use-case. Everything is sorted out if the session is saved after the removal and prior to the creation of newTestNode.







",2015/04/24 4:33 PM
MODE-2462,"Line 231 on org.modeshape.jboss.service.RepositoryService

{code}
                Problems problems = repositoryConfiguration.validate();
                if (problems.isEmpty()) {
                    LOG.debugv(""Problems with configuration for '{0}' repository: {1}"", repositoryName, problems);
                }
{code}",2015/04/24 2:58 AM
MODE-2460,"The {{modeshape-web-explorer}} artifact, which produces a web fragement jar, should list the gwt-servlet dependency as well since it cannot be run in any container without it. 
Currently this dependency is only listed for the explorer-war artifacts.",2015/04/22 2:52 AM
MODE-2457,"I am trying to copy a locked node using session.getWorkspace().copy(). From the documentation of copy, it is stated that:

{code:java}
* @throws LockException                if a lock prevents the copy.
{code}
It is not entirely clear to me what that means, but looking into the code for copy, I have deduced that you need to add the lock token (to the lock manager) of the node you wish to copy.

Not doing this, results in a NullPointerException (and not a LockException) because the token is not there:
{code:java}
Caused by: java.lang.NullPointerException
        at java.util.concurrent.ConcurrentHashMap.hash(ConcurrentHashMap.java:333) [rt.jar:1.7.0_65]
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:1016) [rt.jar:1.7.0_65]
        at java.util.Collections$SetFromMap.contains(Collections.java:3901) [rt.jar:1.7.0_65]
        at org.modeshape.jcr.JcrLockManager.hasLockToken(JcrLockManager.java:56) [modeshape-jcr-4.2.0.Final.jar:4.2.0.Final]
        at org.modeshape.jcr.JcrWorkspace.copy(JcrWorkspace.java:192) [modeshape-jcr-4.2.0.Final.jar:4.2.0.Final]
        at org.modeshape.jcr.JcrWorkspace.copy(JcrWorkspace.java:121) [modeshape-jcr-4.2.0.Final.jar:4.2.0.Final]
{code}
Adding the token still results in a NullPointerException and I believe it is because of this code in the copy method:
{code:java}
   /*
    * Find the source node and check if it is locked
    */
    JcrSession sourceSession = session.spawnSession(srcWorkspace, true);
    AbstractJcrNode sourceNode = sourceSession.node(srcPath);
    if (session.lockManager().isLocked(sourceNode) && !session.lockManager().hasLockToken(sourceNode.getLock().getLockToken())) {
      throw new LockException(srcAbsPath);
    }
{code}
The session.lockManager() has indeed the lock token. But sourceNode.getLock().getLockToken() is still null since its lock manager is associated to the spawned session (sourceSession).

So maybe the problem is that lock tokens in the lock manager of a spawned session are not inherited from the lock manager of the session it was spawned from?

",2015/04/13 7:16 AM
MODE-2448,"Hello modeshape team, 

we're having troubles with full-text search in combination with umlauts. 

Generally full-text search is case insensitive, but it looks like it's case sensitive for umlauts contained in the search text. 

Let's assume we have a content having a property called title with the value 'nderung'. 

Here is our example query: 
  select * from [content] where CONTAINS(title, $searchText) 

If searchText is replaced with 'nderung' then the query doesn't return any results. 
If we change the searchText to uppercase ('NDERUNG') or remove the umlaut ('nderung', 'NDERUNG') the query returns the expected results. 
",2015/03/19 11:16 AM
MODE-2447,"The removal of the public modeshape-distribution artifact (see https://issues.jboss.org/browse/MODE-2383 ) removed the possibility to automate download and installation of jboss-wf8-dist.zip. The public jboss-wf8-dist classifier should be reintroduced to simplify automatic download and installation of ModeShape in WildFly.
See https://developer.jboss.org/message/921526",2015/03/17 10:03 AM
MODE-2438,"*Short:* Method createPatternsFor(String...) in org.modeshape.jcr.AbstractJcrNode does not escape the ""+"" character.

*Full:* 
There are the nodes: 
/folder/node+1 
/folder/node+2 

The result of calling 

{code}
folder.getNodes(""node+*"")
{code} 

will be an empty iterator because createPatternsFor(String...) does not escape the ""+"" and the resulting regular expression would be 
{code}node+.*{code}
Instead it has to be {code}node\\+.*{code}",2015/03/05 9:43 AM
MODE-2436,"When using a /tree/<branch>/<path-to-commit> style path, then <branch> should be used and not HEAD. As long as <path-to-commit> exists in <branch> it should be returned.

I have encountered an issue that violates the above acceptance criteria. I have a commit that exists in branch A but not branch B.  Attempting to access a file added in this commit with branch A checked out working fine, however attempting to access the file with branch B checked out causes an exception.

{quote}
17:35:14,931 WARN  [org.modeshape.connector.git.GitConnector] (default task-22) Cannot read commit ""src/lib/jquery.min.js""
17:35:14,932 ERROR [stderr] (default task-22) javax.jcr.PathNotFoundException: The child ""jcr:content"" could not be found under ""/nogece/tree/master/src/lib/jquery.min.js"" in workspace ""default""
{quote}",2015/02/27 9:20 AM
MODE-2428,"When a property is updated (with property.setValue), the credentials are never checked. AbstractJcrProperty (or its set of sub-classes) seems to be missing any credential check.
 
I'm assuming this is by design, but this seems to be a security loophole.",2015/02/10 12:55 PM
MODE-2426,"I am having an issue where the GIT connector isn't showing changes to a federated GIT repository.

{code}
            <cache-container name=""modeshape"">
                <local-cache name=""nogece"">
                    <transaction mode=""NON_XA""/>
                    <file-store passivation=""false"" purge=""false"" relative-to=""jboss.server.data.dir"" path=""modeshape/store/nogece""/>
                </local-cache>
                <local-cache name=""carroll"">
                    <transaction mode=""NON_XA""/>
                    <file-store passivation=""false"" purge=""false"" relative-to=""jboss.server.data.dir"" path=""modeshape/store/carroll""/>
                </local-cache>
                <local-cache name=""zing"">
                    <transaction mode=""NON_XA""/>
                    <file-store passivation=""false"" purge=""false"" relative-to=""jboss.server.data.dir"" path=""modeshape/store/zing""/>
                </local-cache>
            </cache-container>
{code}

{code}
            <repository name=""carroll"">
                <external-sources>
                    <source name=""git"" classname=""org.modeshape.connector.git.GitConnector"" directoryPath=""C:\\CHP\\git\\carroll"">
                        <projection>
                            default:/carroll =&gt; /
                        </projection>
                    </source>
                </external-sources>
            </repository>
            <repository name=""nogece"">
                <external-sources>
                    <source name=""git"" classname=""org.modeshape.connector.git.GitConnector"" directoryPath=""C:\\CHP\\git\\nogece"" cacheTtlSeconds=""60"">
                        <projection>
                            default:/nogece =&gt; /
                        </projection>
                    </source>
                </external-sources>
            </repository>
            <repository name=""zing"">
                <external-sources>
                    <source name=""git"" classname=""org.modeshape.connector.git.GitConnector"" directoryPath=""C:\\CHP\\git\\zing"">
                        <projection>
                            default:/zing =&gt; /
                        </projection>
                    </source>
                </external-sources>
            </repository>
{code}
",2015/02/09 10:20 AM
MODE-2424,"Locking a node and trying to add a new mixin type while the node is locked results in a ConstraintViolationException.

There are a lock check in the addMixin(String mixinName) method which consider the lockowner and a lock check in the canAddMixin(String mixinName) method which only looks if the node is locked or not and returns false.

The lock check in the canAddMixin methods should also consider the lockowner.",2015/02/06 11:30 AM
MODE-2444,"When importing from an SAP HANA DB using the Teiid Connection importer in Designer, I get an ""Unparsable table body constraint error"". The highlighted row is: 

{code:sql}
INDEX string(1024) NOT NULL OPTIONS (NAMEINSOURCE '""INDEX""', NATIVE_TYPE 'NVARCHAR'),
{code}

for the CREATE statement:
{code:sql}
CREATE FOREIGN TABLE ""_SYS_STATISTICS.GLOBAL_COLUMN_TABLES_SIZE"" (
	SNAPSHOT_ID timestamp NOT NULL OPTIONS (NAMEINSOURCE '""SNAPSHOT_ID""', CHAR_OCTET_LENGTH 16, NATIVE_TYPE 'TIMESTAMP'),
	INDEX string(1024) NOT NULL OPTIONS (NAMEINSOURCE '""INDEX""', NATIVE_TYPE 'NVARCHAR'),
	SERVER_TIMESTAMP timestamp OPTIONS (NAMEINSOURCE '""SERVER_TIMESTAMP""', CHAR_OCTET_LENGTH 16, NATIVE_TYPE 'TIMESTAMP'),
	DATA_SEQ integer OPTIONS (NAMEINSOURCE '""DATA_SEQ""', CHAR_OCTET_LENGTH 4, NATIVE_TYPE 'INTEGER'),
	ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL long OPTIONS (NAMEINSOURCE '""ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	LAST_COMPRESSED_RECORD_COUNT long OPTIONS (NAMEINSOURCE '""LAST_COMPRESSED_RECORD_COUNT""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	MEMORY_SIZE_IN_DELTA long OPTIONS (NAMEINSOURCE '""MEMORY_SIZE_IN_DELTA""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	MEMORY_SIZE_IN_HISTORY_DELTA long OPTIONS (NAMEINSOURCE '""MEMORY_SIZE_IN_HISTORY_DELTA""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	MEMORY_SIZE_IN_HISTORY_MAIN long OPTIONS (NAMEINSOURCE '""MEMORY_SIZE_IN_HISTORY_MAIN""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	MEMORY_SIZE_IN_MAIN long OPTIONS (NAMEINSOURCE '""MEMORY_SIZE_IN_MAIN""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	MEMORY_SIZE_IN_TOTAL long OPTIONS (NAMEINSOURCE '""MEMORY_SIZE_IN_TOTAL""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	PART_COUNT long OPTIONS (NAMEINSOURCE '""PART_COUNT""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	RAW_RECORD_COUNT_IN_DELTA long OPTIONS (NAMEINSOURCE '""RAW_RECORD_COUNT_IN_DELTA""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	RAW_RECORD_COUNT_IN_HISTORY_DELTA long OPTIONS (NAMEINSOURCE '""RAW_RECORD_COUNT_IN_HISTORY_DELTA""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	RAW_RECORD_COUNT_IN_HISTORY_MAIN long OPTIONS (NAMEINSOURCE '""RAW_RECORD_COUNT_IN_HISTORY_MAIN""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	RAW_RECORD_COUNT_IN_MAIN long OPTIONS (NAMEINSOURCE '""RAW_RECORD_COUNT_IN_MAIN""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	RECORD_COUNT long OPTIONS (NAMEINSOURCE '""RECORD_COUNT""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	SCHEMA_NAME string(256) OPTIONS (NAMEINSOURCE '""SCHEMA_NAME""', NATIVE_TYPE 'NVARCHAR'),
	TABLE_COLUMN_COUNT long OPTIONS (NAMEINSOURCE '""TABLE_COLUMN_COUNT""', CHAR_OCTET_LENGTH 20, NATIVE_TYPE 'BIGINT'),
	TABLE_NAME string(256) OPTIONS (NAMEINSOURCE '""TABLE_NAME""', NATIVE_TYPE 'NVARCHAR')
) OPTIONS (NAMEINSOURCE '""_SYS_STATISTICS"".""GLOBAL_COLUMN_TABLES_SIZE""', UPDATABLE TRUE); 
{code}",2015/02/02 11:45 AM
MODE-2416,"For some weird reason, the SmartGWT dependency used by the {{web-explorer}} application uses the {{smartgwt}} groupId:
{code:xml}
<dependency>
  <groupId>smartgwt</groupId>
  <artifactId>smartgwt</artifactId>
  <version>${smartgwt.version}</version>
   <type>jar</type>
</dependency>
{code}

This is only available in the public JBoss Nexus via the Third-party uploads repository, but it's not the official/correct dependency (based on Maven Central).  The correct version should use the {{com.smartgwt}} groupId.",2015/01/28 6:14 AM
MODE-2414,"I create a subnode to a given major node with ""restrictive"" ACLs, so nobody (except the creator) should be allowed to read the node. Still any user can check the existence of the node via

node.hasNode(""foo"")

since the hasNode operation never actually checks the ACLs. See the attached forum reference.",2015/01/27 2:47 AM
MODE-2413,"The following exception is thrown when attempting {{session.exportSystemView()}} that includes a federated node which uses the {{FileSystemConnector}} and {{ignoreBinary}} is false.
{code}
javax.jcr.RepositoryException: java.io.IOException: Stream closed
	at org.modeshape.jcr.JcrSystemViewExporter.emitValue(JcrSystemViewExporter.java:281)
	at org.modeshape.jcr.JcrSystemViewExporter.emitProperty(JcrSystemViewExporter.java:239)
	at org.modeshape.jcr.JcrSystemViewExporter.exportProperty(JcrSystemViewExporter.java:185)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:146)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:156)
	at org.modeshape.jcr.JcrSystemViewExporter.exportNode(JcrSystemViewExporter.java:86)
	at org.modeshape.jcr.AbstractJcrExporter.exportView(AbstractJcrExporter.java:170)
	at org.modeshape.jcr.AbstractJcrExporter.exportView(AbstractJcrExporter.java:200)
	at org.modeshape.jcr.JcrSession.exportSystemView(JcrSession.java:1713)
	at org.modeshaope.connector.filesystem.FilsystemConnectorTest.shouldExportSystemView(FilsystemConnectorTest.java:24)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getBufIfOpen(BufferedInputStream.java:170)
	at java.io.BufferedInputStream.fill(BufferedInputStream.java:214)
	at java.io.BufferedInputStream.read(BufferedInputStream.java:265)
	at org.modeshape.common.util.SelfClosingInputStream.read(SelfClosingInputStream.java:129)
	at org.modeshape.common.util.Base64$InputStream.read(Base64.java:1673)
	at org.modeshape.common.util.Base64$InputStream.read(Base64.java:1774)
	at java.io.FilterInputStream.read(FilterInputStream.java:107)
	at org.modeshape.jcr.JcrSystemViewExporter.emitValue(JcrSystemViewExporter.java:274)
	... 51 more
{code}

",2015/01/23 8:29 PM
MODE-2412,"The binary storage doesn't check the length of the ext_text field, during indexing of new documents. This doesn't work with H2, as it will throw an exception if the stored text exceeds the length of the database field. The attached database properties fix this issue by trimming the length of the inserted data, but there should be at least a warning that additional data will get lost. This fix only works, as the distribution doesn't contain a binary_store_h2_database.properties in org.modeshape.jcr.database",2015/01/19 6:12 AM
MODE-2409,"Invoking checkin() in clustered mode throws an org.modeshape.jcr.cache.NodeNotFoundInParentException

Added two test cases to reproduce this bug:

https://github.com/ModeShape/modeshape/pull/1370",2015/01/09 11:46 AM
MODE-2408,"If a parent node does not have the JCR_MODIFY_ACCESS_CONTROL privilege, ACL modifications on child nodes should not be allowed.

If, however, a child node was added when the parent node had the JCR_MODIFY_ACCESS_CONTROL privilege, and at that time the child node was given an empty ACL list, it currently means that the ACLs can be modified on that child even after JCR_MODIFY_ACCESS_CONTROL was removed from the parent.

I believe the problematic place is in AccessControlManagerImpl.hasPrivileges where a node with an empty ACL list always has all privileges. ",2015/01/09 6:29 AM
MODE-2402,"Hi,
We configured MS 4.1 with an external resource as following:
{code}
    /subsystem=modeshape/repository=sample/source=ext01:add(classname=""org.modeshape.connector.filesystem.FileSystemConnector"",properties=[{""directoryPath""=>""/somwhere""}], readonly=""false"",projections=[""default:/ext => /""], cacheTtlSeconds=""5"")  
{code}

We create large number of nodes in the created external resource. Total size of all nodes are approximately 900 GB.

Although we cannot add any binary storage configuration to store binaries to the repository, in the Wildfly, it create /standalone/data/modeshape/sample/binaries folder and it stores ""some files/nodes"" under this path. The size of all content under this path is 770 GB. It stores 900 GB files on external file system resource, but totally it stores 1.6 GB files (under external path, and also server directory/internal).",2014/12/23 3:55 AM
MODE-2401,"After defining a node type, let's say 

[nt:noquery] > nt:folder noquery 

in Compact Node Type definitions, nodes of type [nt:noquery] still show up when querying for nt:folder.",2014/12/19 12:22 PM
MODE-2397,"Configuring the Web Explorer application with a repository defined in a JSON config doesn't work and prints out a popup with the message: {{org.modeshape.web.server.impl.JsonConnectorImpl}}.
There are no other sever errors.

To reproduce this issue perform the following:
1. Build a fresh {{modeshape-web-explorer-war}} module, which will produce an empty, standalone {{modeshape-explorer.war}} file.
2. Manually edit this war file and:
    2.1. add [this config|https://github.com/ModeShape/modeshape/blob/master/web/modeshape-web-jcr-rest-war/src/main/resources/repository-config.json] to the {{WEB-INF/classes}} folder
    2.2 add the following to the {{web.xml}} 
       {code}
       <context-param>
          <param-name>connector-class</param-name>
              <param value>org.modeshape.web.server.impl.JsonConnectorImpl</param-value>
         </context-param>
 
          <context-param>       
             <param-name>config-url</param-name>
             <param-value>repository-config.json</param-value>
           </context-param>
       {code}
3. Take this updated war and deploy it in a standalone container (I tested with a Tomcat 7 dist)
4. Access the Web Explorer webapp",2014/12/12 4:27 AM
MODE-2393,"ATM when issuing calls to {{workspace.reindex}}, none of the existing indexed values are removed. This means that duplicate indexes would grow out-of-control with each reindexing operation. 
-We need to update the SPI to make sure that when reindexing is performed (either for an entire workspace or a subgraph), the index providers are asked to first clear the values for the corresponding nodes.-",2014/12/09 10:08 AM
MODE-2392,"After updating to 4.1 I noticed a mayor delay at every startup. With 100k nodes about 90 seconds.

Is seems the LocalIndexProvider or any component feeding it nodes is triggering a reindex at every startup. The files on disc change their size quite a lot during that time.

So I went back to 4.0 and the behaviour is not existent there, a cleanly shutdown repository starts up fast without reindexing.

Both tests were done on a cleanly shutdown repository.",2014/12/09 2:35 AM
MODE-2385,"Hello modeshape team, 

we are using references and weak references in ordered collections (lists) like in the following example:

{code}
   @JcrReference(weak = true)
   private List<Content> contents;
{code}

@JcrReference is an annotation from the JCROM framework we are using for mapping repository representations to java objects (https://code.google.com/p/jcrom/).

We have discovered difficulties in reordering the elements in such lists. 
The elements of the list are stored in the correct order on initial save, but if we reorder the elements in the list and update the node (adding no additional elements and removing none of the existing elements) the indices of the list entries are not updated accordingly. 

The reason may be located in SessionNode.updateReferences - there is a comment 'if an existing reference property was just updated with the same value, it is a no-op so we should just remove it from the list of changed properties'. 
In our case the reference property has changed (even if it's only the indices of the collection elements that have changed) but the changes are not persisted as the collection elements are still the same. 

In our case, the list contains references to e.g. articles or documents and those lists can be edited/sorted by an author, hence the order of the references in the list is important for us.

See [discussion|https://developer.jboss.org/thread/250691].",2014/12/04 9:50 AM
MODE-2384,"When starting a single node using the default {{standalone-modeshape-ha.xml}} configuration (from the ModeShape Wildfly kit), the CMIS web-application shows no existing repositories when browsing or looking at endpoint configurations.

There are no explicit errors at startup and the web application is deployed fine.",2014/12/04 5:45 AM
MODE-2383,"While trying to perform a release (which eventually got stuck while uploading to Nexus) I noticed the following:

# the modeshape binary distribution (zip) *does not contain* any of the embedded examples (from {{/demos}})
# in order to build the above distribution, each module creates a zip assembly (e.g. component-with-dependencies) *which is incorrectly attached as a deploy artifact* resulting in Maven trying to upload GB worth of useless data to Nexus. 

The correct behavior is that during {{mvn deploy}} *only relevant Maven artifacts* - jars, test-jars, wars - should be uploaded to Nexus and nothing else.

Also, there are a number of modules that should not be deployed:

# {{demos}} - This directory in the source code contains Maven modules that are examples. But, they're designed to work only within our binary distribution, so they cannot be *used* as Maven dependencies
# {{modeshape-distribution}} - This creates our ZIP file distributions that are available via the project's download area on jboss.org.
# {{integration}} - This directory in the source code contains several Maven modules that are integration tests used during our build to verify functionality. There's no reason outside of the build process (that requires a local codebase) to depend upon or use these tests
# {{modeshape-performance-tests}} - These are performance tests that client applications would never use/need
# {{modeshape-jcr-tck}} - This is our version of the TCK test. Again, there's no reason any client would need/use these
# {{deploy}} - This directory in the source code contain the JBoss/Wildfly module and WARs. These are included in our Wildfly distribution (available on the project's downloads page), and there's no way to really use the artifacts that are in Maven",2014/12/03 7:20 AM
MODE-2381,"With the latest {{RepositoryChangeBus}} cleanup code, the current code incorrectly {{nulls}} out the queue when shutting down the bus. This can
produce exceptions like:
{code:java}
17:42:20,766 ERROR Error killing repository ""testRepo"": java.lang.NullPointerException
java.util.concurrent.ExecutionException: java.lang.NullPointerException
        at java.util.concurrent.FutureTask.report(FutureTask.java:122)
        at java.util.concurrent.FutureTask.get(FutureTask.java:188)
        at org.modeshape.jcr.TestingUtil.killRepository(TestingUtil.java:97)
        at org.modeshape.jcr.TestingUtil.killRepositories(TestingUtil.java:72)
        at org.modeshape.jcr.TestingUtil.killRepositories(TestingUtil.java:56)
        at org.modeshape.jcr.SingleUseAbstractTest.stopRepository(SingleUseAbstractTest.java:90)
        at org.modeshape.jcr.SingleUseAbstractTest.afterEach(SingleUseAbstractTest.java:111)
        at sun.reflect.GeneratedMethodAccessor81.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:33)
        at org.junit.rules.RunRules.evaluate(RunRules.java:20)
        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
        at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)
        at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:208)
        at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:159)
        at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:87)
        at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153)
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:95)
Caused by: java.lang.NullPointerException
        at org.modeshape.jcr.bus.RepositoryChangeBus$ChangeSetDispatcher.submit(RepositoryChangeBus.java:213)
        at org.modeshape.jcr.bus.RepositoryChangeBus.shutdown(RepositoryChangeBus.java:92)
        at org.modeshape.jcr.JcrRepository$RunningState.shutdown(JcrRepository.java:1643)
        at org.modeshape.jcr.JcrRepository.doShutdown(JcrRepository.java:434)
        at org.modeshape.jcr.JcrRepository$1.call(JcrRepository.java:343)
        at org.modeshape.jcr.JcrRepository$1.call(JcrRepository.java:340)
        at java.util.concurrent.FutureTask.run(FutureTask.java:262)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:724)
{code}

We should make sure this doesn't happen.",2014/12/02 10:48 AM
MODE-2375,"We have referenceable node, referrerFirst node and referrerTwo node.
referrerFirst and referrerTwo has references to referenceable node.After export and import this nodes, referenceable node lose referrerFirst.",2014/11/25 2:18 AM
MODE-2373,"Error on server when trying to publish VDB:

Error when publishing VDB:
{code}
09:16:26,882 ERROR [org.modeshape.sequencer.teiid.VdbSequencer] (modeshape-sequencer-6-thread-1) Error reading VDB file ""/files/PortfolioProject/Portfolio.vdb/jcr:content/jcr:data"": Cannot find a definition for a child named '{}ACCOUNT' on the node at '/derived/teiid/vdbs/Portfolio.vdb/Accounts.xmi' with primary type 'vdb:model' and mixin types: []: javax.jcr.nodetype.ConstraintViolationException: Cannot find a definition for a child named '{}ACCOUNT' on the node at '/derived/teiid/vdbs/Portfolio.vdb/Accounts.xmi' with primary type 'vdb:model' and mixin types: []
	at org.modeshape.jcr.AbstractJcrNode.nodeDefinition(AbstractJcrNode.java:2920) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.jcr.AbstractJcrNode.getDefinition(AbstractJcrNode.java:2843) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.jcr.AbstractJcrNode.isCheckedOut(AbstractJcrNode.java:3231) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.jcr.AbstractJcrNode.checkForCheckedOut(AbstractJcrNode.java:669) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.jcr.AbstractJcrNode.addMixin(AbstractJcrNode.java:2540) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.jcr.AbstractJcrNode.addMixin(AbstractJcrNode.java:2530) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at org.modeshape.sequencer.teiid.model.ModelExtensionDefinitionHelper.addMixin(ModelExtensionDefinitionHelper.java:223)
	at org.modeshape.sequencer.teiid.model.ModelExtensionDefinitionHelper.assignMedMixins(ModelExtensionDefinitionHelper.java:258)
	at org.modeshape.sequencer.teiid.model.ModelExtensionDefinitionHelper.assignModelNodeChildrenMedMixins(ModelExtensionDefinitionHelper.java:280)
	at org.modeshape.sequencer.teiid.model.ModelNodeWriter.write(ModelNodeWriter.java:164)
	at org.modeshape.sequencer.teiid.model.ModelSequencer.sequenceModel(ModelSequencer.java:187)
	at org.modeshape.sequencer.teiid.model.ModelSequencer.sequenceVdbModel(ModelSequencer.java:217)
	at org.modeshape.sequencer.teiid.VdbSequencer.execute(VdbSequencer.java:163)
	at org.modeshape.jcr.SequencingRunner.run(SequencingRunner.java:196) [modeshape-jcr-3.8.1.GA-redhat-5.jar:3.8.1.GA-redhat-5]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) [rt.jar:1.7.0_55]
	at java.util.concurrent.FutureTask.run(FutureTask.java:262) [rt.jar:1.7.0_55]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_55]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_55]
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_55]
{code}",2014/11/23 7:16 PM
MODE-2371,"ModeShape throws exception on login to non-default workspace, was not yet initialized, if transaction is active.
Default workspace initialized successfully when repository starts with suspend global transaction.
Affected only current 3.8-SNAPSHOT


{noformat}
JBossTransactionsTest
org.modeshape.jcr.JBossTransactionsTest
testStartRepositoryWithinTransaction(org.modeshape.jcr.JBossTransactionsTest)
org.modeshape.common.SystemFailureException: java.lang.IllegalStateException: Active transaction detected, but the Infinispan cache isn't aware of it
	at org.modeshape.jcr.cache.RepositoryCache.runInTransaction(RepositoryCache.java:490)
	at org.modeshape.jcr.cache.RepositoryCache.workspace(RepositoryCache.java:912)
	at org.modeshape.jcr.cache.RepositoryCache.getWorkspaceCache(RepositoryCache.java:1124)
	at org.modeshape.jcr.JcrSession.<init>(JcrSession.java:188)
	at org.modeshape.jcr.JcrXaSession.<init>(JcrXaSession.java:49)
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:700)
	at org.modeshape.jcr.JcrRepository.login(JcrRepository.java:626)
	at org.modeshape.jcr.JBossTransactionsTest.testStartRepositoryWithinTransaction(JBossTransactionsTest.java:23)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: java.lang.IllegalStateException: Active transaction detected, but the Infinispan cache isn't aware of it
	at org.modeshape.jcr.txn.SynchronizedTransactions.begin(SynchronizedTransactions.java:126)
	at org.modeshape.jcr.cache.RepositoryCache.runInTransaction(RepositoryCache.java:480)
	... 35 more
{noformat}


Before MODE-2364 it throws NPE.",2014/11/21 2:29 AM
MODE-2369,"Setting a STRING property with a length of 4096+ characters (i.e. {{""min-string-size""}}) generates an error:

{code:java}
2014-11-19 16:14:10,570 ERROR [org.modeshape.web.jcr.rest.ModeShapeExceptionMapper] (default task-13) Server error: javax.jcr.RepositoryException: org.modeshape.jcr.value.ValueFormatException: Error converting ""[117, 114, (xxx), 49, 50, 51]"" from byte[] to a BinaryValue
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1184) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.web.jcr.rest.handler.RestItemHandler.addItem(RestItemHandler.java:101) [modeshape-web-jcr-rest-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.web.jcr.rest.ModeShapeRestService.postItem(ModeShapeRestService.java:331) [modeshape-web-jcr-rest-4.0.0.Final.jar:4.0.0.Final]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [rt.jar:1.7.0_65]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) [rt.jar:1.7.0_65]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [rt.jar:1.7.0_65]
	at java.lang.reflect.Method.invoke(Method.java:606) [rt.jar:1.7.0_65]
	at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:137) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:296) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:250) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:237) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:179) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:220) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56) [resteasy-jaxrs-3.0.8.Final.jar:]
	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51) [resteasy-jaxrs-3.0.8.Final.jar:]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:113) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:27) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:51) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:45) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:58) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:70) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.security.handlers.SecurityInitialHandler.handleRequest(SecurityInitialHandler.java:76) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at org.wildfly.mod_cluster.undertow.metric.RunningRequestsHttpHandler.handleRequest(RunningRequestsHttpHandler.java:68)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:101) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:240) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:227) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:73) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:146) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.server.Connectors.executeRootHandler(Connectors.java:177) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:727) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_65]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_65]
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_65]
Caused by: org.modeshape.jcr.value.ValueFormatException: Error converting ""[117, 114, (xxx), 49, 50, 51]"" from byte[] to a BinaryValue
	at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:232) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:104) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:49) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.cache.document.DocumentTranslator.valueToDocument(DocumentTranslator.java:1123) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.cache.document.DocumentTranslator.setProperty(DocumentTranslator.java:422) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1032) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:596) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1165) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	... 47 more
Caused by: org.modeshape.jcr.value.binary.BinaryStoreException: Error at storing of binary value: aa7a5f7ba94ce08cc34fa9af94d1fccac3102d4b
	at org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore$LockFactory$ISPNLock.<init>(InfinispanBinaryStore.java:690) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore$LockFactory.writeLock(InfinispanBinaryStore.java:652) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore.storeValue(InfinispanBinaryStore.java:252) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:230) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	... 54 more
Caused by: javax.transaction.NotSupportedException: BaseTransaction.checkTransactionState - ARJUNA016051: thread is already associated with a transaction!
	at com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction.begin(BaseTransaction.java:72)
	at com.arjuna.ats.jbossatx.BaseTransactionManagerDelegate.begin(BaseTransactionManagerDelegate.java:65)
	at org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore$LockFactory$ISPNLock.<init>(InfinispanBinaryStore.java:682) [modeshape-jcr-4.0.0.Final.jar:4.0.0.Final]
	... 57 more
Caused by: java.lang.IllegalStateException: BaseTransaction.checkTransactionState - ARJUNA016051: thread is already associated with a transaction!
	at com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction.checkTransactionState(BaseTransaction.java:262)
	at com.arjuna.ats.internal.jta.transaction.arjunacore.BaseTransaction.begin(BaseTransaction.java:68)
	... 59 more
{code}

The message is quite verbose (all bytes are individually shown) so it might be a good idea to fix that by the way.

I could trigger the error using either {{modeshape-explorer}} or {{modeshape-rest}}, e.g.:

{code:bash}
curl -u admin:admin -H ""Content-Type: application/json"" -d @payload.json ""http://172.17.0.59:8080/modeshape-rest/acme/default/items/acme:node""
{code}",2014/11/19 4:26 PM
MODE-2367,"Dear Modeshape team,

As requested in forum (see https://developer.jboss.org/message/910481), I would like to report following error: 

It's not possible to access contents of older versions by using of CMIS interface (1.1) with ModeShape 4.0.0.Final 
Here the sequence of steps our code executes:
 
1. Connect to CMIS repo
2. Create a document
3. Do check in of new contents (2 times)
4. Try to access the older version using:
Document.getAllVersions() method
 
We figured out that the collection returned by this method contains 3 exactly the same documents with ID, content and properties of the latest version of the document,
 
In attachment the java program how to reproduce the problem (testVersionCMIS.zip, all needed jars are included). Simple download, extract and execute: ""java -jar testVersionCMIS.jar"" to reproduce the problem.
- runnable jar: ./testVersionCMIS.jar
- Source: ./src/TestVersioningTemp.java
- test files: ./testFiles
 
NOTE:
If we use JCR API everything works fins, it seems really to be a CMIS related problem.",2014/11/17 9:41 AM
MODE-2364,"The code added as part of MODE-2353 adds an Infinispan listener for each transaction. This does not scale. Instead, we should add a single listener and then use that listener for all transactions.

BTW, the ISPN transaction-related methods were considered internal implementations, and in Infinispan 7 were moved into non-API packages. I created ISPN-4983 to request some way to know when ISPN completes its work for a given user transaction; we'll eventually have to change this logic.",2014/11/14 12:08 PM
MODE-2362,"Teiid Designer's [Komodo|https://github.com/Teiid-Designer/komodo] stream is using modeshape as a backend artifact modelling repository. As such it is intended to import and add Vdb artifacts to a repository using the teiid modeshape sequencer.

The application is being built in an Eclipse RCP environment and at least one expected UI for the Komodo 'Engine' will be Eclipse in the same look/feel as Teiid Designer. Thus, the method of utilising Modeshape libraries has been to bring in the built jars from maven and export their packages in a modeshape.lib eclipse plugin. This has worked successfully so far.

However, the VdbSequencer fails to initialise correctly and returns the error:
{code}Unable to initialize the sequencer ""Test Repository -> org.modeshape.sequencer.teiid.VdbSequencer uuid=a16a1cbc-b1ee-4c2c-a8f7-90e733b42864 : VDB Sequencer"" for repository ""Test Repository"": The stream to the given cnd file is null{code}

The cnd file concerned is loaded by the Vdb Sequencer's component  [Model Sequencer|https://github.com/ModeShape/modeshape/blob/master/sequencers/modeshape-sequencer-teiid/src/main/java/org/modeshape/sequencer/teiid/model/ModelSequencer.java], which contains relative paths (starting at line 115) for its cnd files.

This fails in an OSGI environment since the vdb-sequencer library is a jar file and the resolved path 'org/modeshape/sequencer/teiid/model/../model.cnd' is invalid.

Can the sequencer be updated to use something like:
{code}VdbSequencer.class.getResourceAsStream(model.cnd){code}
and pass the resulting input stream into the equivalent registerNodeTypes method?

",2014/11/14 6:52 AM
MODE-2359,"We have a node A and node B which refers to the node A.
If import node B multiple times from xml, for node A increases the number of referrers count (document -> referrers -> strong -> keyNodeB -> CNT).

After remove node B, node A can not be removed.",2014/11/13 7:58 AM
MODE-2357,"When creating nodes & saving via the Repository Explorer, not all the newly created nodes are displayed.
Also, the fact that not all nodes are displayed seems to be independent of the fact that they are created via the Explorer UI: nodes with custom types (i.e. user defined types) are not always displayed in the explorer.",2014/11/10 4:52 AM
MODE-2355,"Using the new index feature of modeshape 4 we have detected some queries that do not behave like expected. Without the configured indices the queries work.
 
The following node types are defined:
{code}
[my:authored] mixin
- author (STRING) COPY
- coAuthors (STRING) multiple COPY
 
[my:content] > my:authored
- content (STRING) mandatory COPY
{code} 

With the following query we'd like to retrieve all contents that are either authored or co-authored by the same person(s):
{code}
select * from [my:content] where author in ($author) or coAuthors in ($author)
{code}

But instead of the correct results we always get duplicates of the same node entries.
",2014/11/07 1:29 AM
MODE-2353,"As discussed in the forums https://developer.jboss.org/thread/249779 I am seeing issues when concurrently creating multiple child nodes for the same parent node.

I have been unable to recreate this using the existing modeshape concurrency unit tests but have been able to re-create this with a slightly modified version of quick start/modeshape-cdi which I will make available on GitHub shortly.

Currently this issue has been observed under the following conditions:

1. Using the ModeShape subsystem in Wildfly 8.1 (I have tried both 4.0 and the latest 4.1 Snapshot from MASTER).
2. When multiple threads attempt to create child nodes at the same time for the same parent node.
3. An EJB is used to create the node (I have tried with both the REQUIRED and NEVER Transactional attributes on the EJB method).
4. Using both a local and replicated Infinispan cache (Transaction mode = NON_XA and locking = PESSIMISTIC).
5. When using both a File and JDBC store

The modified quick start uses the ManagedExecutorService to create 10 child nodes concurrently when a node is added via Web UI instead of just creating a single node.

I had to make a couple of changes to the standalone-modeshape.xml shipped with subsystem to enable the managed executor service and turn on PESSIMISTIC locking.",2014/10/29 4:30 PM
MODE-2352,"When browsing a repository with the Git connector configured via the REST service, accessing certain URLs raises unexpected exceptions:

1. {{http://localhost:8080/modeshape-rest/federatedRepository/default/items/gitRepo/tree/72ea74be3b3a50345a1b2f543f78fd6be00caa35}}

{code}
6:24:01,121 ERROR [org.modeshape.web.jcr.rest.ModeShapeExceptionMapper] (default task-26) Server error: javax.jcr.RepositoryException: No valid property definition on node '/gitRepo/tree/72ea74be3b3a50345a1b2f543f78fd6be00caa35' with primary type 'git:folder' and mixin types [] for the property: git:detail=""46f1a0beaa9871/commit/72ea74be3b3a50345a1b2f543f78fd6be00caa35""
       at org.modeshape.jcr.AbstractJcrNode.findJcrProperties(AbstractJcrNode.java:2035) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.jcr.AbstractJcrNode.getProperties(AbstractJcrNode.java:2043) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.web.jcr.rest.handler.AbstractHandler.createRestNode(AbstractHandler.java:304) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.web.jcr.rest.handler.AbstractHandler.createRestItem(AbstractHandler.java:243) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.web.jcr.rest.handler.RestItemHandler.item(RestItemHandler.java:67) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.web.jcr.rest.ModeShapeRestService.getItem(ModeShapeRestService.java:303) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at sun.reflect.GeneratedMethodAccessor27.invoke(Unknown Source) [:1.7.0_40]
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [rt.jar:1.7.0_40]
       at java.lang.reflect.Method.invoke(Method.java:606) [rt.jar:1.7.0_40]
       at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:137) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:296) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:250) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:237) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:179) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:220) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56) [resteasy-jaxrs-3.0.8.Final.jar:]
       at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51) [resteasy-jaxrs-3.0.8.Final.jar:]
       at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
       at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
       at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:113) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:27) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:51) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:45) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:58) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:70) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.security.handlers.SecurityInitialHandler.handleRequest(SecurityInitialHandler.java:76) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
       at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:101) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:240) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:227) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:73) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:146) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.Connectors.executeRootHandler(Connectors.java:177) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:727) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_40]
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_40]
       at java.lang.Thread.run(Thread.java:724) [rt.jar:1.7.0_40]
aused by: javax.jcr.nodetype.ConstraintViolationException: No valid property definition on node '/gitRepo/tree/72ea74be3b3a50345a1b2f543f78fd6be00caa35' with primary type 'git:folder' and mixin types [] for the property: git:detail=""46f1a0beaa9871/commit/72ea74be3b3a50345a1b2f543f78fd6be00caa35""
       at org.modeshape.jcr.AbstractJcrNode.propertyDefinitionFor(AbstractJcrNode.java:473) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.jcr.AbstractJcrNode.createJcrProperty(AbstractJcrNode.java:394) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.jcr.AbstractJcrNode.getProperty(AbstractJcrNode.java:358) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       at org.modeshape.jcr.AbstractJcrNode.findJcrProperties(AbstractJcrNode.java:2028) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
       ... 48 more
{code}

2. http://localhost:8080/modeshape-rest/federatedRepository/default/items/gitRepo/commits/d1f7daf32bd67edded7545221cd5c79d94813310

{code}
16:28:33,217 ERROR [org.modeshape.web.jcr.rest.ModeShapeExceptionMapper] (default task-33) Server error: org.modeshape.jcr.cache.DocumentStoreException: /commits
        at org.modeshape.connector.git.GitConnector.getChildren(GitConnector.java:252)
        at org.modeshape.jcr.federation.FederatedDocumentStore.getChildrenBlock(FederatedDocumentStore.java:407) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.jcr.cache.document.WorkspaceCache.blockFor(WorkspaceCache.java:195) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.jcr.cache.document.ImmutableChildReferences$Segment.next(ImmutableChildReferences.java:800) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.jcr.cache.document.ImmutableChildReferences$Segmented$2.hasNext(ImmutableChildReferences.java:596) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.jcr.JcrChildNodeIterator.hasNext(JcrChildNodeIterator.java:102) [modeshape-jcr-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.web.jcr.rest.handler.AbstractHandler.createRestNode(AbstractHandler.java:310) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.web.jcr.rest.handler.AbstractHandler.createRestItem(AbstractHandler.java:243) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.web.jcr.rest.handler.RestItemHandler.item(RestItemHandler.java:67) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at org.modeshape.web.jcr.rest.ModeShapeRestService.getItem(ModeShapeRestService.java:303) [modeshape-web-jcr-rest-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
        at sun.reflect.GeneratedMethodAccessor27.invoke(Unknown Source) [:1.7.0_40]
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [rt.jar:1.7.0_40]
        at java.lang.reflect.Method.invoke(Method.java:606) [rt.jar:1.7.0_40]
        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:137) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:296) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:250) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:237) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:179) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:220) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56) [resteasy-jaxrs-3.0.8.Final.jar:]
        at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51) [resteasy-jaxrs-3.0.8.Final.jar:]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
        at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:113) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:27) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:51) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:45) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:58) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:70) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.security.handlers.SecurityInitialHandler.handleRequest(SecurityInitialHandler.java:76) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:101) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:240) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:227) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:73) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:146) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.Connectors.executeRootHandler(Connectors.java:177) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:727) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_40]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_40]
        at java.lang.Thread.run(Thread.java:724) [rt.jar:1.7.0_40]
Caused by: org.eclipse.jgit.errors.AmbiguousObjectException: Object abbreviation 15 is ambiguous
        at org.eclipse.jgit.lib.Repository.resolveAbbreviation(Repository.java:774)
        at org.eclipse.jgit.lib.Repository.resolveSimple(Repository.java:714)
        at org.eclipse.jgit.lib.Repository.resolve(Repository.java:683)
        at org.eclipse.jgit.lib.Repository.resolve(Repository.java:383)
        at org.modeshape.connector.git.GitFunction.addCommitsAsPageOfChildren(GitFunction.java:272)
        at org.modeshape.connector.git.GitHistory.execute(GitHistory.java:138)
        at org.modeshape.connector.git.GitConnector.getChildren(GitConnector.java:250)
        ... 52 more
{code}",2014/10/29 10:30 AM
MODE-2348,"I've tried to configure this index:

{noformat}
<index name=""marketplaceSoftware"" provider-name=""local-index-provider"" kind=""ENUMERATED"" node-type=""imp:marketplace"" columns=""imp:software(STRING)""/>
{noformat}

But then ModeShape throws an error at launch time:

{noformat}
ERROR [org.jboss.as.server] (Controller Boot Thread) JBAS015956: Caught exception during boot: org.jboss.as.controller.persistence.ConfigurationPersistenceException: JBAS014676: Failed to parse configuration
        at org.jboss.as.controller.persistence.XmlConfigurationPersister.load(XmlConfigurationPersister.java:112) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.server.ServerService.boot(ServerService.java:331) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.controller.AbstractControllerService$1.run(AbstractControllerService.java:256) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
        at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_67]
Caused by: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[448,21]
Message: ""JBAS014839: Invalid value enumerated for kind; legal values are [TEXT, VALUE, ENUMERATED_VALUE, UNIQUE_VALUE, NODE_TYPE]""
        at org.jboss.as.controller.SimpleAttributeDefinition.parse(SimpleAttributeDefinition.java:346) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.controller.SimpleAttributeDefinition.parseAndSetParameter(SimpleAttributeDefinition.java:371) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
        at org.modeshape.jboss.subsystem.ModeShapeSubsystemXMLReader_2_0.parseIndex(ModeShapeSubsystemXMLReader_2_0.java:955)
        at org.modeshape.jboss.subsystem.ModeShapeSubsystemXMLReader_2_0.parseIndexes(ModeShapeSubsystemXMLReader_2_0.java:922)
        at org.modeshape.jboss.subsystem.ModeShapeSubsystemXMLReader_2_0.parseRepository(ModeShapeSubsystemXMLReader_2_0.java:258)
        at org.modeshape.jboss.subsystem.ModeShapeSubsystemXMLReader_2_0.readElement(ModeShapeSubsystemXMLReader_2_0.java:63)
        at org.modeshape.jboss.subsystem.ModeShapeSubsystemXMLReader_2_0.readElement(ModeShapeSubsystemXMLReader_2_0.java:34)
        at org.jboss.staxmapper.XMLMapperImpl.processNested(XMLMapperImpl.java:110) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
        at org.jboss.staxmapper.XMLExtendedStreamReaderImpl.handleAny(XMLExtendedStreamReaderImpl.java:69) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
        at org.jboss.as.server.parsing.StandaloneXml.parseServerProfile(StandaloneXml.java:1131) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.server.parsing.StandaloneXml.readServerElement_1_4(StandaloneXml.java:458) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.server.parsing.StandaloneXml.readElement(StandaloneXml.java:145) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.as.server.parsing.StandaloneXml.readElement(StandaloneXml.java:107) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
        at org.jboss.staxmapper.XMLMapperImpl.processNested(XMLMapperImpl.java:110) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
        at org.jboss.staxmapper.XMLMapperImpl.parseDocument(XMLMapperImpl.java:69) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
        at org.jboss.as.controller.persistence.XmlConfigurationPersister.load(XmlConfigurationPersister.java:104) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
{noformat}

So I followed the information message and changed to:{noformat}kind=""ENUMERATED_VALUE""{noformat}

Bad luck, I got another error:

{noformat}
JBAS014777:   Services which failed to start:      service jboss.modeshape.imarchespublics.indexes.marketplaceSoftware: org.jboss.msc.service.StartException in service jboss.modeshape.imarchespublics.indexes.marketplaceSoftware: The ""imarchespublics"" repository configuration has 1 error(s) and cannot be deployed: ERROR: Error at indexes.marketplaceSoftware.kind : The 'kind' field on 'indexes.marketplaceSoftware' has a value of 'ENUMERATED_VALUE' that is not part of the enumeration: [value, text, unique, nodetype, enumerated]
{noformat}

So what's the correct attribute value to use?

By the way, the same problem might also apply for the UNIQUE(_VALUE) I suppose.",2014/10/21 5:03 PM
MODE-2347,"Let's say we have nodetype A and nodetype B, where B has supertype A.

If nodetype B has property C, when selecting property C in a query with nodetype A, this throws an Exception stating the column cannot be found for A.

This works perfectly fine in JCR-SQL2.

I hope the problem is clear, if not let me know.",2014/10/21 10:12 AM
MODE-2346,"The following two plans are more or less the same, only difference is that in the second case there is no node matching the criteria.

The plan of the second query shows that an implicit path index is used instead of the more specialized index. 

This is leading to a 30 - 50 ms delay when trying to access the iterator (I guess because all 10k nodes of the path index have to be matched?). Node present: 1ms, node not present: 30ms access time.

{code}
Access [BASE]
  Project [BASE] <PROJECT_COLUMNS=[BASE.[jcr:uuid]], PROJECT_COLUMN_TYPES=[STRING]>
    Select [BASE] <SELECT_CRITERIA=BASE.rvgrpnr = '1014563'>
      Select [BASE] <SELECT_CRITERIA=ISDESCENDANTNODE(BASE,'/data/stand-2014-04[21]')>
        Select [BASE] <SELECT_CRITERIA=BASE.[jcr:primaryType] = 'nt:ag'>
          Source [BASE] <SOURCE_NAME=__ALLNODES__, SOURCE_ALIAS=BASE, SOURCE_COLUMNS=[jcr:frozenUuid(STRING), mode:sharedUuid(STRING), mode:nodeTypeName(STRING), jcr:defaultValues(STRING), mode:projectedNodeKey(STRING), jcr:mixinTypes(STRING), jcr:frozenPrimaryType(STRING), jcr:defaultPrimaryType(STRING), jcr:statement(STRING), jcr:lastModifiedBy(STRING), jcr:mimeType(STRING), jcr:hasOrderableChildNodes(BOOLEAN), jcr:etag(STRING), jcr:encoding(STRING), jcr:root(STRING), mode:kind(STRING), jcr:supertypes(STRING), jcr:successors(STRING), jcr:primaryItemName(STRING), jcr:hold(STRING), jcr:workspace(STRING), jcr:isDeep(BOOLEAN), jcr:primaryType(STRING), mode:externalNodeKey(STRING), mode:derivedFrom(STRING), mode:isHeldBySession(BOOLEAN), jcr:baseVersion(STRING), jcr:lastModified(DATE), jcr:mergeFailed(STRING), mode:derivedAt(DATE), jcr:requiredPrimaryTypes(STRING), jcr:multiple(BOOLEAN), mode:generated(BOOLEAN), jcr:activityTitle(STRING), jcr:lifecyclePolicy(STRING), jcr:isMixin(BOOLEAN), jcr:availableQueryOperators(STRING), jcr:childVersionHistory(STRING), jcr:content(STRING), jcr:autoCreated(BOOLEAN), mode:synchronous(BOOLEAN), name(STRING), mode:alias(STRING), jcr:createdBy(STRING), jcr:isFullTextSearchable(BOOLEAN), jcr:uuid(STRING), jcr:onParentVersion(STRING), mode:expirationDate(DATE), jcr:copiedFrom(STRING), mode:lockToken(STRING), jcr:title(STRING), jcr:isAbstract(BOOLEAN), jcr:versionableUuid(STRING), jcr:versionHistory(STRING), jcr:predecessors(STRING), jcr:lockIsDeep(BOOLEAN), jcr:lockOwner(STRING), mode:sha1(STRING), jcr:repository(STRING), mode:columnTypeName(STRING), jcr:created(DATE), jcr:frozenMixinTypes(STRING), jcr:description(STRING), jcr:text(STRING), jcr:host(STRING), jcr:configuration(STRING), jcr:port(STRING), mode:workspace(STRING), jcr:nodeTypeName(STRING), jcr:isQueryable(BOOLEAN), jcr:data(BINARY), jcr:language(STRING), jcr:isQueryOrderable(BOOLEAN), jcr:isCheckedOut(BOOLEAN), jcr:mandatory(BOOLEAN), jcr:protected(BOOLEAN), jcr:protocol(STRING), jcr:sameNameSiblings(BOOLEAN), jcr:requiredType(STRING), mode:lockingSession(STRING), jcr:messageId(STRING), jcr:id(STRING), mode:uri(STRING), mode:propertyName(STRING), mode:workspaces(STRING), privileges(STRING), mode:isSessionScoped(BOOLEAN), jcr:valueConstraints(STRING), jcr:retentionPolicy(STRING), jcr:activity(STRING), jcr:currentLifecycleState(STRING), jcr:score(DOUBLE), mode:depth(LONG), jcr:path(STRING), jcr:name(STRING), mode:localName(STRING), mode:id(STRING), jcr:uuid(STRING)]>
            Index [BASE] <INDEX_SPECIFICATION=SI_Ag_rvgrpnr, provider=local, cost~=100, cardinality~=8, selectivity~=1.2596838E-4, constraints=[BASE.rvgrpnr = '1014563'], INDEX_USED=true>
            Index [BASE] <INDEX_SPECIFICATION=DescendantsByPath, provider=<implicit>, cost~=1000, cardinality~=10000, selectivity~=?, constraints=[ISDESCENDANTNODE(BASE,'/data/stand-2014-04[21]')], path=/data/stand-2014-04[21]>
{code}

{code}
Access [BASE]
  Project [BASE] <PROJECT_COLUMNS=[BASE.[jcr:uuid]], PROJECT_COLUMN_TYPES=[STRING]>
    Select [BASE] <SELECT_CRITERIA=BASE.rvnr = '4606564'>
      Select [BASE] <SELECT_CRITERIA=ISDESCENDANTNODE(BASE,'/data/stand-2014-04[21]')>
        Select [BASE] <SELECT_CRITERIA=BASE.[jcr:primaryType] = 'nt:ai'>
          Source [BASE] <SOURCE_NAME=__ALLNODES__, SOURCE_ALIAS=BASE, SOURCE_COLUMNS=[jcr:frozenUuid(STRING), mode:sharedUuid(STRING), mode:nodeTypeName(STRING), jcr:defaultValues(STRING), mode:projectedNodeKey(STRING), jcr:mixinTypes(STRING), jcr:frozenPrimaryType(STRING), jcr:defaultPrimaryType(STRING), jcr:statement(STRING), jcr:lastModifiedBy(STRING), jcr:mimeType(STRING), jcr:hasOrderableChildNodes(BOOLEAN), jcr:etag(STRING), jcr:encoding(STRING), jcr:root(STRING), mode:kind(STRING), jcr:supertypes(STRING), jcr:successors(STRING), jcr:primaryItemName(STRING), jcr:hold(STRING), jcr:workspace(STRING), jcr:isDeep(BOOLEAN), jcr:primaryType(STRING), mode:externalNodeKey(STRING), mode:derivedFrom(STRING), mode:isHeldBySession(BOOLEAN), jcr:baseVersion(STRING), jcr:lastModified(DATE), jcr:mergeFailed(STRING), mode:derivedAt(DATE), jcr:requiredPrimaryTypes(STRING), jcr:multiple(BOOLEAN), mode:generated(BOOLEAN), jcr:activityTitle(STRING), jcr:lifecyclePolicy(STRING), jcr:isMixin(BOOLEAN), jcr:availableQueryOperators(STRING), jcr:childVersionHistory(STRING), jcr:content(STRING), jcr:autoCreated(BOOLEAN), mode:synchronous(BOOLEAN), name(STRING), mode:alias(STRING), jcr:createdBy(STRING), jcr:isFullTextSearchable(BOOLEAN), jcr:uuid(STRING), jcr:onParentVersion(STRING), mode:expirationDate(DATE), jcr:copiedFrom(STRING), mode:lockToken(STRING), jcr:title(STRING), jcr:isAbstract(BOOLEAN), jcr:versionableUuid(STRING), jcr:versionHistory(STRING), jcr:predecessors(STRING), jcr:lockIsDeep(BOOLEAN), jcr:lockOwner(STRING), mode:sha1(STRING), jcr:repository(STRING), mode:columnTypeName(STRING), jcr:created(DATE), jcr:frozenMixinTypes(STRING), jcr:description(STRING), jcr:text(STRING), jcr:host(STRING), jcr:configuration(STRING), jcr:port(STRING), mode:workspace(STRING), jcr:nodeTypeName(STRING), jcr:isQueryable(BOOLEAN), jcr:data(BINARY), jcr:language(STRING), jcr:isQueryOrderable(BOOLEAN), jcr:isCheckedOut(BOOLEAN), jcr:mandatory(BOOLEAN), jcr:protected(BOOLEAN), jcr:protocol(STRING), jcr:sameNameSiblings(BOOLEAN), jcr:requiredType(STRING), mode:lockingSession(STRING), jcr:messageId(STRING), jcr:id(STRING), mode:uri(STRING), mode:propertyName(STRING), mode:workspaces(STRING), privileges(STRING), mode:isSessionScoped(BOOLEAN), jcr:valueConstraints(STRING), jcr:retentionPolicy(STRING), jcr:activity(STRING), jcr:currentLifecycleState(STRING), jcr:score(DOUBLE), mode:depth(LONG), jcr:path(STRING), jcr:name(STRING), mode:localName(STRING), mode:id(STRING), jcr:uuid(STRING)]>
            Index [BASE] <INDEX_SPECIFICATION=DescendantsByPath, provider=<implicit>, cost~=1000, cardinality~=10000, selectivity~=?, constraints=[ISDESCENDANTNODE(BASE,'/data/stand-2014-04[21]')], path=/data/stand-2014-04[21], INDEX_USED=true>
            Index [BASE] <INDEX_SPECIFICATION=SI_Ai_rvnr, provider=local, cost~=100, cardinality~=0, selectivity~=0.0, constraints=[BASE.rvnr = '4606564']>
{code}

What also is VERY misleading is that the cardinality of the second index of the plan is logged to be 0, it seems to always be the number of results for that index, not the total number of elements in the index as one (or at least myself) would expect.",2014/10/17 11:42 AM
MODE-2344,"After the fix for MODE-2340, another bug shows up regarding credentials in the Repository Explorer webapp:
1) start the application & log in with a valid user, browse a repository
2) Logout from the app
3) Press ""Login"" and in the login form enter *any* username/password combination. 

Those credentials will be accepted and the application looks like *that* user is logged in (I haven't checked to see if this is just a UI problem or the actual runtime permissions are corrupted)",2014/10/16 3:49 AM
MODE-2343,"In our application, we're seeing run-away threads when using the ObservationManager. Our application creates a new session for every HTTP request, and uses the ObservationManager to register some contextual data. When we invoke Workspace#getObservationManager, it appears that we create a new modeshape-event-dispatcher thread that is not disposed off when Session#logout is called.

Not that this is a very good demo, but I hope it gets the point across:
{code}
    @Test
    @FixFor(""MODE-xxxx"")
    public void shouldNotLeakObservers() throws Exception {
        final int oldCount = Thread.activeCount();
        for (int i = 0; i < 1000; i++) {
            final Session newSession = newSession();
            newSession.getWorkspace().getObservationManager();
            newSession.logout();
        }
        final int newCount = Thread.activeCount();

        assertEquals(oldCount, newCount);
        /* After running the test, these counts are ~1000 different */
    }
{code}

Digging into the code, I suspect (though haven't confirmed) that the ObservationManager's own listener is not removed:

https://github.com/ModeShape/modeshape/blob/master/modeshape-jcr/src/main/java/org/modeshape/jcr/JcrObservationManager.java#L174",2014/10/15 11:53 AM
MODE-2342,"When a session has acquired an open-scoped lock on a resource and then ends via logout(), the session should disassociate itself from the lock so that another session can take over ownership of the lock via the lock token and {{JcrLockManager.addLockToken()}}.",2014/10/15 11:52 AM
MODE-2341,"After reindexing a repository with the API in org.modeshape.jcr.api.Workspace, updates to indexes are lost during the next restart of the repository. This has the effect that queries to nodes under FileSystemConnector stop returning results, the index is still used but it appears not to contain any data.

Additionally the file size on local-indexes.db.t keeps increasing rapidly with each subsequent reindex (this is reset during restart). 

This is what happens to Local Index Provider's index files (it seems like there is some issue with committing the changes to MapDB):

1) A fresh repository is started and some nodes are created under FileSystemConnector with the JCR API:
local-indexes.db 34168 B
local-indexes.db.p 2066288 B
local-indexes.db.t 16 B

2) After deleting the index files and restarting the repository
local-indexes.db 32968 B
local-indexes.db.p 184 B
local-indexes.db.t 54545 B

3) After reindexing the repository manually:
local-indexes.db 32968 B 
local-indexes.db.p 184 B
local-indexes.db.t 2758843 B

4) After restarting the repository index files revert back to state 2), before indexing",2014/10/14 8:17 AM
MODE-2340,"Install & start the repository explorer application in WF, log in and browse a repository. Then press ""logout"". The following exception is raised:
{code}
0:35,942 ERROR [io.undertow.servlet] (default task-55) Exception while dispatching incoming RPC call: com.google.gwt.user.server.rpc.UnexpectedException: Service method 'public abstract void org.modeshape.web.client.JcrService.login(java.lang.String,java.lang.String) throws org.modeshape.web.client.RemoteException' threw an unexpected exception: java.lang.NullPointerException
    at com.google.gwt.user.server.rpc.RPC.encodeResponseForFailure(RPC.java:389) [gwt-servlet-2.5.1.jar:]
    at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:579) [gwt-servlet-2.5.1.jar:]
    at com.google.gwt.user.server.rpc.RemoteServiceServlet.processCall(RemoteServiceServlet.java:208) [gwt-servlet-2.5.1.jar:]
    at com.google.gwt.user.server.rpc.RemoteServiceServlet.processPost(RemoteServiceServlet.java:248) [gwt-servlet-2.5.1.jar:]
    at com.google.gwt.user.server.rpc.AbstractRemoteServiceServlet.doPost(AbstractRemoteServiceServlet.java:62) [gwt-servlet-2.5.1.jar:]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:707) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [jboss-servlet-api_3.1_spec-1.0.0.Final.jar:1.0.0.Final]
    at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:130) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at org.modeshape.web.AuthFilter.doFilter(AuthFilter.java:61) [modeshape-web-explorer-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
    at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:60) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:132) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:85) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)
    at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:113) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:27) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:51) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:45) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:61) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:56) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:58) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:70) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.security.handlers.SecurityInitialHandler.handleRequest(SecurityInitialHandler.java:76) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
    at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:25) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:101) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:240) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:227) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:73) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:146) [undertow-servlet-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.Connectors.executeRootHandler(Connectors.java:177) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:727) [undertow-core-1.0.15.Final.jar:1.0.15.Final]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_40]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_40]
    at java.lang.Thread.run(Thread.java:724) [rt.jar:1.7.0_40]
ed by: java.lang.NullPointerException
    at javax.jcr.SimpleCredentials.<init>(SimpleCredentials.java:31) [jcr-2.0.jar:]
    at org.modeshape.web.server.impl.ConnectorImpl.login(ConnectorImpl.java:89) [modeshape-web-explorer-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
    at org.modeshape.web.server.JcrServiceImpl.login(JcrServiceImpl.java:132) [modeshape-web-explorer-4.1-SNAPSHOT.jar:4.1-SNAPSHOT]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [rt.jar:1.7.0_40]
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) [rt.jar:1.7.0_40]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [rt.jar:1.7.0_40]
    at java.lang.reflect.Method.invoke(Method.java:606) [rt.jar:1.7.0_40]
    at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:561) [gwt-servlet-2.5.1.jar:]
    ... 40 more
{code}",2014/10/14 7:43 AM
MODE-2339,"With the changes for MODE-2304, it seems that the only way the Repository Web-Explorer can discover repositories is via:
{code}
 InitialContext ic = new InitialContext();
 ModeShapeEngine engine = (ModeShapeEngine) ic.lookup(""jcr"");
{code}
This works fine OOTB for the WF subsystem (where this binding is done automatically behind the scenes) but it extremely limiting in *all other cases* because:
a) users need to run with a JNDI RW environment
b) they need to make the above binding themselves

We need to make sure the {{context-param}} discovery approach works as well, meaning that users should be able to add to their {{web.xml}} either:
{code}
    <context-param>
        <param-name>org.modeshape.jcr.URL</param-name>
        <param-value>jndi:jcr</param-value>
    </context-param>    
{code}
or 
{code}
    <context-param>
        <param-name>org.modeshape.jcr.URL</param-name>
        <param-value>file:/repo-config.json</param-value>
    </context-param>    
{code}

We should also update the default {{web.xml}} from the {{modeshape-web-explorer-war}} module to contain both the above approaches but commented out & documented, so that it's obvious how one can use this configuration. 
Since this most likely means using the {{ModeShapeJcrDeployer}} context listener, this should be part (by default) of the {{modeshape-explorer}} {{web-fragment.xml}} and we should make sure it works correctly even when *none* of the above context params are provided (i.e. it doesn't crash).",2014/10/14 4:22 AM
MODE-2338,"This test case causes a null-pointer error:

https://github.com/ModeShape/modeshape/pull/1293
{code}

    @Test
    @FixFor(""MODE-2338"")
    public void shouldReturnEmptyIteratorWithGlob() throws RepositoryException {
        Node jcrRootNode = session.getRootNode();
        Node rootNode = jcrRootNode.addNode(""someRandomNode"");
        rootNode.addNode(""newNode"");
        NodeIterator nodeIterator = rootNode.getNodes(""doesnotmatch*"");
        assertFalse(nodeIterator.hasNext());
    }
{code}

Here's the NPE stack trace:

{code}
java.lang.NullPointerException
	at org.modeshape.jcr.cache.ChildReferences$WithChanges.consume(ChildReferences.java:520)
	at org.modeshape.jcr.cache.document.AbstractChildReferences$1.next(AbstractChildReferences.java:102)
	at org.modeshape.jcr.cache.document.AbstractChildReferences$1.next(AbstractChildReferences.java:92)
	at org.modeshape.jcr.cache.document.UnionIterator.next(UnionIterator.java:60)
	at org.modeshape.jcr.cache.document.DelegatingIterator.next(DelegatingIterator.java:39)
	at org.modeshape.jcr.cache.document.PatternIterator.hasNext(PatternIterator.java:46)
	at org.modeshape.jcr.JcrChildNodeIterator.hasNext(JcrChildNodeIterator.java:102)
	at org.modeshape.jcr.JcrNodeTest.shouldReturnEmptyIteratorWithGlob(JcrNodeTest.java:761)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
{code}",2014/10/13 3:48 PM
MODE-2336,"When add nodes within transaction and has registered EventListener with nodeType restriction, sometimes happen exceptions logged by EventListenerAdapter (showcase in listenerAdapterExceptionTest):
{code}
org.modeshape.jcr.JcrObservationManager$ChangeSetConverter
acceptBasedOnNodeTypeName
SEVERE: Error checking primary type 'null' with mixins of 'null' against type names of '[nt:unstructured]'
javax.jcr.PathNotFoundException: No node exists at path '/folder1/node69' in workspace ""default""
     at org.modeshape.jcr.JcrSession.cachedNode(JcrSession.java:623)
     at org.modeshape.jcr.JcrSession.node(JcrSession.java:655)
     at org.modeshape.jcr.JcrSession.node(JcrSession.java:674)
     at
org.modeshape.jcr.JcrObservationManager$ChangeSetConverter.acceptBasedOnNodeTypeName(JcrObservationManager.java:1115)
     at
org.modeshape.jcr.JcrObservationManager$ChangeSetConverter.shouldRejectChange(JcrObservationManager.java:1043)
     at
org.modeshape.jcr.JcrObservationManager$ChangeSetConverter.processChange(JcrObservationManager.java:887)
     at
org.modeshape.jcr.JcrObservationManager$ChangeSetConverter.convert(JcrObservationManager.java:866)
     at
org.modeshape.jcr.JcrObservationManager$JcrListenerAdapter.notify(JcrObservationManager.java:374)
     at
org.modeshape.jcr.bus.RepositoryChangeBus$ChangeSetListenerConsumerAdapter.consume(RepositoryChangeBus.java:161)
     at
org.modeshape.jcr.bus.RepositoryChangeBus$ChangeSetListenerConsumerAdapter.consume(RepositoryChangeBus.java:155)
     at
org.modeshape.common.collection.ring.RingBuffer$ConsumerRunner.run(RingBuffer.java:462)
     at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
     at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
     at java.lang.Thread.run(Thread.java:745)
{code}


In the second test (catchExceptionTest) we catch exception in the event handler (onEvent);
",2014/10/10 9:58 AM
MODE-2330,"When trying to remove mix:lastModified from a node I get an exception (version 4.0.0):
{noformat}
Caused by: javax.jcr.nodetype.ConstraintViolationException: Cannot find a definition for the property named 'jcr:lastModifiedBy' on the node at '{some path}' with primary type '{my type}' and mixin types: []
    at org.modeshape.jcr.AbstractJcrNode.removeMixin(AbstractJcrNode.java:2594)
    ...
{noformat}",2014/10/03 9:24 AM
MODE-2328,"When using the CMIS web application to look at all the available repositories (via {{http://localhost:8080/modeshape-cmis/browser}}) instead of displaying repository names and information the application is displaying the workspace names of the first repository. 

See attached screenshot.",2014/10/03 3:58 AM
MODE-2322,"When setting (and saving) a STRING property than happens to be longer than the ""min-string-size"" configuration value, it fails with this exception:

{noformat}
21:01:18,790 DEBUG [org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore]  Binary value already exist.  
21:01:21,820 DEBUG [org.modeshape.jcr.value.binary.infinispan.InfinispanBinaryStore]  Store binary value into chunks.  
21:01:21,821 DEBUG [org.modeshape.jcr.value.binary.infinispan.ChunkOutputStream]  Close. Buffer size at close: 5127  
21:01:21,822 DEBUG [org.modeshape.jcr.value.binary.infinispan.ChunkOutputStream]  Store chunk 69b0c6dbf78e0eabaf558075f47f80c3debe5aad-data-0  
21:01:21,839 INFO [stdout] java.lang.ClassCastException: [B cannot be cast to [Ljava.lang.Object;  
21:01:21,839 INFO [stdout]  javax.jcr.RepositoryException: java.lang.ClassCastException: [B cannot be cast to [Ljava.lang.Object;  
21:01:21,839 INFO [stdout]         at org.modeshape.jcr.JcrSession.save(JcrSession.java:1184)  
...  
21:01:21,844 INFO  [stdout]  Caused by: java.lang.ClassCastException: [B cannot be cast to [Ljava.lang.Object;  
21:01:21,844 INFO  [stdout]         at org.modeshape.common.util.StringUtil.createString(StringUtil.java:169)  
21:01:21,844 INFO  [stdout]         at org.modeshape.common.i18n.I18n.text(I18n.java:412)  
21:01:21,844 INFO  [stdout]         at org.modeshape.common.i18n.I18n.text(I18n.java:397)  
21:01:21,844 INFO  [stdout]         at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:232)  
21:01:21,845 INFO  [stdout]         at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:104)  
21:01:21,845 INFO  [stdout]         at org.modeshape.jcr.value.binary.BinaryStoreValueFactory.create(BinaryStoreValueFactory.java:49)  
21:01:21,845 INFO  [stdout]         at org.modeshape.jcr.cache.document.DocumentTranslator.valueToDocument(DocumentTranslator.java:1090)  
21:01:21,845 INFO  [stdout]         at org.modeshape.jcr.cache.document.DocumentTranslator.setProperty(DocumentTranslator.java:421)  
21:01:21,846 INFO  [stdout]         at org.modeshape.jcr.cache.document.WritableSessionCache.persistChanges(WritableSessionCache.java:1006)  
21:01:21,846 INFO  [stdout]         at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:587)  
21:01:21,846 INFO  [stdout]         at org.modeshape.jcr.JcrSession.save(JcrSession.java:1165)  
21:01:21,846 INFO  [stdout]         ... 19 more 
{noformat}",2014/09/29 3:19 AM
MODE-2319,"When a user navigates via the repository explorer to a given path in a workspace (e.g. {{default -> files}}) and then changes from the dropdown to another workspace (e.g. artifacts) the repository explorer expects the same path to be present and if that is not the case will raise an exception like:

{code}
0:25:37,569 ERROR [stderr] (http-/127.0.0.1:8080-4) javax.jcr.PathNotFoundException: No node exists at path '/files' in workspace ""extra""
0:25:37,570 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.cachedNode(JcrSession.java:611)
0:25:37,571 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.node(JcrSession.java:641)
0:25:37,573 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.node(JcrSession.java:660)
0:25:37,577 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.getNode(JcrSession.java:844)
0:25:37,578 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.getNode(JcrSession.java:827)
0:25:37,580 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.jcr.JcrSession.getNode(JcrSession.java:134)
0:25:37,580 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.web.server.JcrServiceImpl.node(JcrServiceImpl.java:145)
0:25:37,583 ERROR [stderr] (http-/127.0.0.1:8080-4)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
0:25:37,583 ERROR [stderr] (http-/127.0.0.1:8080-4)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
0:25:37,588 ERROR [stderr] (http-/127.0.0.1:8080-4)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
0:25:37,589 ERROR [stderr] (http-/127.0.0.1:8080-4)    at java.lang.reflect.Method.invoke(Method.java:606)
0:25:37,590 ERROR [stderr] (http-/127.0.0.1:8080-4)    at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:561)
0:25:37,591 ERROR [stderr] (http-/127.0.0.1:8080-4)    at com.google.gwt.user.server.rpc.RemoteServiceServlet.processCall(RemoteServiceServlet.java:208)
0:25:37,594 ERROR [stderr] (http-/127.0.0.1:8080-4)    at com.google.gwt.user.server.rpc.RemoteServiceServlet.processPost(RemoteServiceServlet.java:248)
0:25:37,595 ERROR [stderr] (http-/127.0.0.1:8080-4)    at com.google.gwt.user.server.rpc.AbstractRemoteServiceServlet.doPost(AbstractRemoteServiceServlet.java:62)
0:25:37,597 ERROR [stderr] (http-/127.0.0.1:8080-4)    at javax.servlet.http.HttpServlet.service(HttpServlet.java:754)
0:25:37,597 ERROR [stderr] (http-/127.0.0.1:8080-4)    at javax.servlet.http.HttpServlet.service(HttpServlet.java:847)
0:25:37,597 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:295)
0:25:37,598 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:214)
0:25:37,599 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.modeshape.web.AuthFilter.doFilter(AuthFilter.java:61)
0:25:37,599 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:246)
0:25:37,599 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:214)
0:25:37,600 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:231)
0:25:37,600 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:149)
0:25:37,602 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:512)
0:25:37,602 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.jboss.as.web.security.SecurityContextAssociationValve.invoke(SecurityContextAssociationValve.java:169)
0:25:37,603 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:145)
0:25:37,605 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:97)
0:25:37,606 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:102)
0:25:37,607 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
0:25:37,608 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:856)
0:25:37,612 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:653)
0:25:37,613 ERROR [stderr] (http-/127.0.0.1:8080-4)    at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:926)
0:25:37,615 ERROR [stderr] (http-/127.0.0.1:8080-4)    at java.lang.Thread.run(Thread.java:724)
{code}

The expected behavior should be, IMO, to reset the navigation path to the root of a workspace whenever the user changes the workspace from the dropdown (of course, provided it selects *another* workspace than the current one)",2014/09/25 3:33 AM
MODE-2318,"This is the log output on every start when the repository is non empty:

{code}
948 DEBUG org.modeshape.jcr.index.local.LocalIndexProvider  - Initializing the local index provider 'local' in repository 'modeshapeRepository' at: /opt/storage/test-modeshape-4-local-index
4952 DEBUG org.modeshape.jcr.index.local.LocalIndexProvider  - Opening the local index provider database for repository 'modeshapeRepository' at: /opt/storage/test-modeshape-4-local-index/local-indexes.db
5291 TRACE org.modeshape.jcr.index.local.LocalIndexProvider  - Found the index files {ref1.comparator=org.modeshape.jcr.index.local.MapDB$UniqueKeyComparator@1, ref1.counterRecid=25, ref1.keySerializer=UniqueKeyBTreeSerializer<org.mapdb.Serializer$1@191d0f2c>, ref1.maxNodeSize=32, ref1.numberOfNodeMetas=0, ref1.rootRecidRef=27, ref1.type=TreeMap, ref1.valuesOutsideNodes=false, ref1/inverse.comparator=org.modeshape.jcr.index.local.MapDB$TupleComparator@1, ref1/inverse.counterRecid=0, ref1/inverse.keySerializer=org.modeshape.jcr.index.local.MapDB$LocalTuple2KeySerializer@a84da16, ref1/inverse.maxNodeSize=32, ref1/inverse.numberOfNodeMetas=0, ref1/inverse.rootRecidRef=29, ref1/inverse.type=TreeSet, ref1/options.counterRecid=0, ref1/options.hashSalt=-1634797605, ref1/options.segmentRecids=[J@11cf5577, ref1/options.type=HashMap, ref2.comparator=org.modeshape.jcr.index.local.MapDB$UniqueKeyComparator@1, ref2.counterRecid=46, ref2.keySerializer=UniqueKeyBTreeSerializer<org.mapdb.Serializer$1@191d0f2c>, ref2.maxNodeSize=32, ref2.numberOfNodeMetas=0, ref2.rootRecidRef=48, ref2.type=TreeMap, ref2.valuesOutsideNodes=false, ref2/inverse.comparator=org.modeshape.jcr.index.local.MapDB$TupleComparator@1, ref2/inverse.counterRecid=0, ref2/inverse.keySerializer=org.modeshape.jcr.index.local.MapDB$LocalTuple2KeySerializer@a84da16, ref2/inverse.maxNodeSize=32, ref2/inverse.numberOfNodeMetas=0, ref2/inverse.rootRecidRef=52, ref2/inverse.type=TreeSet, ref2/options.counterRecid=0, ref2/options.hashSalt=-1154882495, ref2/options.segmentRecids=[J@42f400c3, ref2/options.type=HashMap} in index database for repository 'modeshapeRepository' at: /opt/storage/test-modeshape-4-local-index/local-indexes.db
5314 DEBUG org.modeshape.jcr.index.local.LocalIndexProvider  - Index provider 'local' is creating index in workspace 'default': ref2@local nodeType=nt:unstructured column=ref2(STRING) kind=VALUE sync=true workspaces=*
5316 DEBUG org.modeshape.jcr.index.local.LocalDuplicateIndex  - Reopening storage for 'ref2' index in workspace 'default'
5335 DEBUG org.modeshape.jcr.index.local.LocalIndexProvider  - Index provider 'local' is creating index in workspace 'default': ref1@local nodeType=nt:unstructured column=ref1(STRING) kind=VALUE sync=true workspaces=*
5335 DEBUG org.modeshape.jcr.index.local.LocalDuplicateIndex  - Reopening storage for 'ref1' index in workspace 'default'
5350 INFO  org.erratic.cr.repository.repositoryProvider.RepositoryProvider  - [4/7] repository started (repository-config.json)
5364 INFO  org.infinispan.jmx.CacheJmxRegistration  - ISPN000031: MBeans were successfully registered to the platform MBean server.
5370 DEBUG org.modeshape.jcr.index  - Reindexing node '/' in workspace 'default' of repository 'modeshapeRepository': Node af55b687505d64/: { ""properties"" : { ""http://www.jcp.org/jcr/1.0"" : { ""primaryType"" : { ""$name"" : ""mode:root"" } , ""uuid"" : ""af55b687505d64/"" } } , ""children"" : [ { ""key"" : ""af55b68317f1e7jcr:system"" , ""name"" : ""jcr:system"" } , { ""key"" : ""af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823"" , ""name"" : ""nodeWithSysName"" } , { ""key"" : ""af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f"" , ""name"" : ""nodeWithSysName"" } ] , ""childrenInfo"" : { ""count"" : 3 } }
5374 DEBUG org.modeshape.jcr.index  - Reindexing node '/nodeWithSysName' in workspace 'default' of repository 'modeshapeRepository': Node af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823: { ""key"" : ""af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823"" , ""parent"" : ""af55b687505d64/"" , ""properties"" : { ""http://www.jcp.org/jcr/1.0"" : { ""primaryType"" : { ""$name"" : ""nt:unstructured"" } } , """" : { ""ref2"" : ""cccccccccccccccccccccc-0000-1111-1234-123456789abcd"" , ""ref1"" : ""cccccccccccccccccccccc-0000-1111-1234-123456789abcd"" } } }
5377 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Removing node 'af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823' from 'ref2' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5383 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Adding node 'af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823' to 'ref2' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5385 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Removing node 'af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823' from 'ref1' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5386 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Adding node 'af55b687505d648e4a88e5-324f-4a57-ad1c-ae15842dc823' to 'ref1' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5390 DEBUG org.modeshape.jcr.index  - Reindexing node '/nodeWithSysName[2]' in workspace 'default' of repository 'modeshapeRepository': Node af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f: { ""key"" : ""af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f"" , ""parent"" : ""af55b687505d64/"" , ""properties"" : { ""http://www.jcp.org/jcr/1.0"" : { ""primaryType"" : { ""$name"" : ""nt:unstructured"" } } , """" : { ""ref2"" : ""cccccccccccccccccccccc-0000-1111-1234-123456789abcd"" , ""ref1"" : ""cccccccccccccccccccccc-0000-1111-1234-123456789abcd"" } } }
5392 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Removing node 'af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f' from 'ref2' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5395 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Adding node 'af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f' to 'ref2' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5396 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Removing node 'af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f' from 'ref1' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'
5401 TRACE org.modeshape.jcr.index.local.LocalDuplicateIndex  - Adding node 'af55b687505d64f0e706ad-c4ed-4166-815a-d5929381b47f' to 'ref1' index with value 'cccccccccccccccccccccc-0000-1111-1234-123456789abcd'

{code}

No indexes are being deleted or added, it happens right after repo setup.

This is my config:

{code}
{
	""name"": ""modeshapeRepository"",
	""monitoring"": {
		""enabled"": true
	},
	""storage"": {
		""cacheName"": ""contentRepository"",
		""cacheConfiguration"": ""META-INF/infinispan-test-file-config-6.xml"",
		""binaryStorage"": {
			""type"": ""file"",
			""directory"": ""/opt/storage/test-modeshape-4-binaries""
		}
	},
	""workspaces"": {
		""default"": ""default"",
		""allowCreation"": true
	},
	""indexProviders"": {
		""local"": {
			""classname"": ""org.modeshape.jcr.index.local.LocalIndexProvider"",
			""directory"": ""/opt/storage/test-modeshape-4-local-index""
		}
	},
	""indexes"": {
	},
	""security"": {
		""anonymous"": {
			""roles"": [""readonly"", ""readwrite"", ""admin""],
			""useOnFailedLogin"": false
		}
	}

}
{code}",2014/09/23 9:09 AM
MODE-2317,"When a string comes from a JSON document containing an escaped {{u}} character, the {{JsonReader}} class incorrectly expects (always) a Unicode escape character. This is an incorrect assumption.

For example, the following is a legal path on Windows:
{code}
""url"" : ""jdbc:h2:file:path\\upstream.jboss-integration.modeshape\\modeshape-jcr\\target/db/h2/modeshape;DB_CLOSE_DELAY=-1""
{code}

while the JsonReader expects after {{\u}} a series of numbers, raising the following exception:
{code}
java.lang.NumberFormatException: For input string: ""pstr""
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.lang.Integer.parseInt(Integer.java:492)
at org.infinispan.schematic.internal.document.JsonReader$DateValueMatcher.unescapeValue(JsonReader.java:986)
at org.infinispan.schematic.internal.document.JsonReader$DateValueMatcher.parseValue(JsonReader.java:950)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseValue(JsonReader.java:517)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseDocument(JsonReader.java:420)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseValue(JsonReader.java:505)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseDocument(JsonReader.java:420)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseValue(JsonReader.java:505)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseDocument(JsonReader.java:420)
at org.infinispan.schematic.internal.document.JsonReader$Parser.parseDocument(JsonReader.java:364)
at org.infinispan.schematic.internal.document.JsonReader.read(JsonReader.java:211)
at org.infinispan.schematic.internal.document.JsonReader.read(JsonReader.java:196)
at org.infinispan.schematic.internal.document.JsonReader.read(JsonReader.java:180)
at org.infinispan.schematic.internal.document.JsonReader.read(JsonReader.java:115)
at org.infinispan.schematic.document.Json.read(Json.java:198)
{code}",2014/09/23 2:24 AM
MODE-2315,"The {{3.x}} and {{3.8.x-prod-ip6.1}} branches contain some invalid changes which have been cherry-picked from other branches using non Java 6 code.

We should make sure this branch can be built using JDK 6.",2014/09/22 10:15 AM
MODE-2314,"Edit: Ok I found the problem:

Assuming you have a node with a to be indexed property ""sysName""
Then the following code does NOT index the node

{code}

Node newNode1 = session1.getRootNode().addNode(""nodeWithSysName"",""nt:unstructured"");
		session1.save();

		newNode1.setProperty(""sysName"", ""foobar"");
		
		session1.save();

{code}

However this will index the node

{code}

Node newNode1 = session1.getRootNode().addNode(""nodeWithSysName"",""nt:unstructured"");

		newNode1.setProperty(""sysName"", ""foobar"");
		
		session1.save();

{code}",2014/09/22 7:54 AM
MODE-2313,"Occasionally I get this Exception during a query.

I wasn't able to track it down as it doesn't seem to happen during debugging, so I can't provide mote info at this time.

{code}
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:894)
	at java.util.HashMap$ValueIterator.next(HashMap.java:922)
	at org.modeshape.jcr.spi.index.provider.IndexProvider.onEachIndexInWorkspace(IndexProvider.java:436)
	at org.modeshape.jcr.spi.index.provider.IndexProvider$BasicPlanner.applyIndexes(IndexProvider.java:503)
	at org.modeshape.jcr.query.engine.IndexPlanners$2.applyIndexes(IndexPlanners.java:89)
	at org.modeshape.jcr.query.optimize.AddIndexes.execute(AddIndexes.java:270)
	at org.modeshape.jcr.query.optimize.RuleBasedOptimizer.optimize(RuleBasedOptimizer.java:46)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.execute(ScanningQueryEngine.java:245)
	at org.modeshape.jcr.RepositoryQueryManager$1.execute(RepositoryQueryManager.java:172)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:118)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:43)
{code}

What I can tell is this:

I created indexes in another session but in the same thread just before firing a query that causes the exception.
All Indexes are being defined before any >affected< nodes for that index get created.
Thread.sleep (tested up to 5000) in the Query thread (which is also the index definition thread in this case) doesn't help
Maybe it is related to defining an index on [jcr:uuid] because I didn't get this error previously.",2014/09/22 3:49 AM
MODE-2312,"When firing this query

{code}
SELECT A.* FROM [nt:someTypeWithMixReferencable] AS A
WHERE A.[jcr:uuid] = $uuid
{code}

There thould be an implicit index being used but it is not:

{code}
Access [A]
  Project [A] <PROJECT_COLUMNS=[A.[jcr:primaryType], A.[jcr:mixinTypes], A.[jcr:score], A.[mode:depth], A.[jcr:path], A.[jcr:name], A.[mode:localName], A.[mode:id]], PROJECT_COLUMN_TYPES=[STRING, STRING, DOUBLE, LONG, STRING, STRING, STRING, STRING]>
    Select [A] <SELECT_CRITERIA=A.[jcr:uuid] = $uuid>
      Select [A] <SELECT_CRITERIA=A.[jcr:primaryType] = 'nt:someTypeWithMixReferencable'>
        Source [A] <SOURCE_NAME=__ALLNODES__, SOURCE_ALIAS=A, SOURCE_COLUMNS=[jcr:frozenUuid(STRING), mode:sharedUuid(STRING), mode:nodeTypeName(STRING), jcr:defaultValues(STRING), mode:projectedNodeKey(STRING), jcr:mixinTypes(STRING), jcr:frozenPrimaryType(STRING), jcr:defaultPrimaryType(STRING), jcr:statement(STRING), jcr:lastModifiedBy(STRING), jcr:mimeType(STRING), jcr:hasOrderableChildNodes(BOOLEAN), jcr:etag(STRING), jcr:encoding(STRING), jcr:root(STRING), mode:kind(STRING), jcr:supertypes(STRING), jcr:successors(STRING), jcr:primaryItemName(STRING), jcr:hold(STRING), jcr:workspace(STRING), jcr:isDeep(BOOLEAN), jcr:primaryType(STRING), mode:externalNodeKey(STRING), mode:derivedFrom(STRING), mode:isHeldBySession(BOOLEAN), jcr:baseVersion(STRING), jcr:lastModified(DATE), jcr:mergeFailed(STRING), mode:derivedAt(DATE), jcr:requiredPrimaryTypes(STRING), jcr:multiple(BOOLEAN), mode:generated(BOOLEAN), jcr:activityTitle(STRING), jcr:lifecyclePolicy(STRING), jcr:isMixin(BOOLEAN), jcr:availableQueryOperators(STRING), jcr:childVersionHistory(STRING), jcr:content(STRING), jcr:autoCreated(BOOLEAN), mode:synchronous(BOOLEAN), name(STRING), mode:alias(STRING), jcr:createdBy(STRING), jcr:isFullTextSearchable(BOOLEAN), jcr:uuid(STRING), jcr:onParentVersion(STRING), mode:expirationDate(DATE), jcr:copiedFrom(STRING), mode:lockToken(STRING), jcr:title(STRING), jcr:isAbstract(BOOLEAN), jcr:versionableUuid(STRING), jcr:versionHistory(STRING), jcr:predecessors(STRING), jcr:lockIsDeep(BOOLEAN), jcr:lockOwner(STRING), mode:sha1(STRING), jcr:repository(STRING), mode:columnTypeName(STRING), jcr:created(DATE), jcr:frozenMixinTypes(STRING), jcr:description(STRING), jcr:text(STRING), jcr:host(STRING), jcr:configuration(STRING), jcr:port(STRING), mode:workspace(STRING), jcr:nodeTypeName(STRING), jcr:isQueryable(BOOLEAN), jcr:data(BINARY), jcr:language(STRING), jcr:isQueryOrderable(BOOLEAN), jcr:isCheckedOut(BOOLEAN), jcr:mandatory(BOOLEAN), jcr:protected(BOOLEAN), jcr:protocol(STRING), jcr:sameNameSiblings(BOOLEAN), jcr:requiredType(STRING), mode:lockingSession(STRING), jcr:messageId(STRING), jcr:id(STRING), mode:uri(STRING), mode:propertyName(STRING), mode:workspaces(STRING), privileges(STRING), mode:isSessionScoped(BOOLEAN), jcr:valueConstraints(STRING), jcr:retentionPolicy(STRING), jcr:activity(STRING), jcr:currentLifecycleState(STRING), jcr:score(DOUBLE), mode:depth(LONG), jcr:path(STRING), jcr:name(STRING), mode:localName(STRING), mode:id(STRING)]>
{code}

The query takes about 200 ms on a relatively empty repository. If I define an index on [jcr:uuid] myself, it takes under 20ms and I get this plan as a result:

{code}
Access [A]
  Project [A] <PROJECT_COLUMNS=[A.[jcr:primaryType], A.[jcr:mixinTypes], A.[jcr:score], A.[mode:depth], A.[jcr:path], A.[jcr:name], A.[mode:localName], A.[mode:id]], PROJECT_COLUMN_TYPES=[STRING, STRING, DOUBLE, LONG, STRING, STRING, STRING, STRING]>
    Select [A] <SELECT_CRITERIA=A.[jcr:uuid] = $uuid>
      Select [A] <SELECT_CRITERIA=A.[jcr:primaryType] = 'nt:someTypeWithMixReferencable'>
        Source [A] <SOURCE_NAME=__ALLNODES__, SOURCE_ALIAS=A, SOURCE_COLUMNS=[jcr:frozenUuid(STRING), mode:sharedUuid(STRING), mode:nodeTypeName(STRING), jcr:defaultValues(STRING), mode:projectedNodeKey(STRING), jcr:mixinTypes(STRING), jcr:frozenPrimaryType(STRING), jcr:defaultPrimaryType(STRING), jcr:statement(STRING), jcr:lastModifiedBy(STRING), jcr:mimeType(STRING), jcr:hasOrderableChildNodes(BOOLEAN), jcr:etag(STRING), jcr:encoding(STRING), jcr:root(STRING), mode:kind(STRING), jcr:supertypes(STRING), jcr:successors(STRING), jcr:primaryItemName(STRING), jcr:hold(STRING), jcr:workspace(STRING), jcr:isDeep(BOOLEAN), jcr:primaryType(STRING), mode:externalNodeKey(STRING), mode:derivedFrom(STRING), mode:isHeldBySession(BOOLEAN), jcr:baseVersion(STRING), jcr:lastModified(DATE), jcr:mergeFailed(STRING), mode:derivedAt(DATE), jcr:requiredPrimaryTypes(STRING), jcr:multiple(BOOLEAN), mode:generated(BOOLEAN), jcr:activityTitle(STRING), jcr:lifecyclePolicy(STRING), jcr:isMixin(BOOLEAN), jcr:availableQueryOperators(STRING), jcr:childVersionHistory(STRING), jcr:content(STRING), jcr:autoCreated(BOOLEAN), mode:synchronous(BOOLEAN), name(STRING), mode:alias(STRING), jcr:createdBy(STRING), jcr:isFullTextSearchable(BOOLEAN), jcr:uuid(STRING), jcr:onParentVersion(STRING), mode:expirationDate(DATE), jcr:copiedFrom(STRING), mode:lockToken(STRING), jcr:title(STRING), jcr:isAbstract(BOOLEAN), jcr:versionableUuid(STRING), jcr:versionHistory(STRING), jcr:predecessors(STRING), jcr:lockIsDeep(BOOLEAN), jcr:lockOwner(STRING), mode:sha1(STRING), jcr:repository(STRING), mode:columnTypeName(STRING), jcr:created(DATE), jcr:frozenMixinTypes(STRING), jcr:description(STRING), jcr:text(STRING), jcr:host(STRING), jcr:configuration(STRING), jcr:port(STRING), mode:workspace(STRING), jcr:nodeTypeName(STRING), jcr:isQueryable(BOOLEAN), jcr:data(BINARY), jcr:language(STRING), jcr:isQueryOrderable(BOOLEAN), jcr:isCheckedOut(BOOLEAN), jcr:mandatory(BOOLEAN), jcr:protected(BOOLEAN), jcr:protocol(STRING), jcr:sameNameSiblings(BOOLEAN), jcr:requiredType(STRING), mode:lockingSession(STRING), jcr:messageId(STRING), jcr:id(STRING), mode:uri(STRING), mode:propertyName(STRING), mode:workspaces(STRING), privileges(STRING), mode:isSessionScoped(BOOLEAN), jcr:valueConstraints(STRING), jcr:retentionPolicy(STRING), jcr:activity(STRING), jcr:currentLifecycleState(STRING), jcr:score(DOUBLE), mode:depth(LONG), jcr:path(STRING), jcr:name(STRING), mode:localName(STRING), mode:id(STRING)]>
          Index [A] <INDEX_SPECIFICATION=uuid, provider=local, cost~=100, cardinality~=0, selectivity~=0.0, constraints=[A.[jcr:uuid] = $uuid], INDEX_USED=true>
{code}

Testcase follows, it assumes there is one index being used without defining anything. Although I have never seen such in implicit index popping up in the plan.

{code}
@RunWith(CdiTestRunner.class)
@TestControl(startScopes = RequestScoped.class, projectStage = UnitTest.class)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
//@Ignore
public class WmModeshapeIndexWhenSearchingForUuidTest {

	
	@Inject
	private Session session;

	@Inject
	protected transient LogHelper logger;

	@Test
	public void test001CheckSomethingWithIndexes() throws RepositoryException, InterruptedException {

		regNodeType(session,""nt:someTypeWithMixReferencable"");
		//ensureIndex(indexManager(), ""uuid"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:someTypeWithMixReferencable"", """", null, ""jcr:uuid"", PropertyType.NAME);
		
		Node newNode1 = session.getRootNode().addNode(""nodeWithSysName"",""nt:someTypeWithMixReferencable"");
		newNode1.addMixin(""mix:referenceable"");
		
		session.save();
		
		Thread.sleep(500);

		
		Query q = session.getWorkspace().getQueryManager().createQuery(
		""SELECT A.* FROM [nt:someTypeWithMixReferencable] AS A\n"" +
		""WHERE A.[jcr:uuid] = $uuid"",Query.JCR_SQL2);
		q.bindValue(""uuid"", session.getValueFactory().createValue(UUID.randomUUID().toString()));
		
		logger.info(q.getStatement());
		
		QueryResult result = q.execute();
		
		String plan = ((org.modeshape.jcr.api.query.QueryResult)result).getPlan();
		logger.info(plan);
		
		Assert.assertEquals(1,countIndexes(plan));
		
	}
	
	private int countIndexes(String plan){
		
		Pattern p = Pattern.compile(""INDEX_USED=true"");
		Matcher m = p.matcher(plan);
		int count = 0;
		while (m.find()){
			count +=1;
		}
		return count;
	}
	
	protected IndexManager indexManager(){
		
		if (!(session instanceof org.modeshape.jcr.api.Session)){
			return null;
		}
		
		try {
			return ((org.modeshape.jcr.api.Session) session).getWorkspace().getIndexManager();
		} catch (RepositoryException ex) {
			logger.error(ex.toString(), ex);
		}
		return null;
	}
	
	protected void ensureIndex(IndexManager manager, String indexName, IndexDefinition.IndexKind kind, String providerName, String indexedNodeType, String desc, String workspaceNamePattern, String propertyName, int propertyType) throws RepositoryException {


		if (manager.getIndexDefinitions().containsKey(indexName)){
			return;
		}
		
		logger.info(""registering index on property ""+propertyName+"", type ""+indexedNodeType);
		
		// Create the index template ...
		IndexDefinitionTemplate template = manager.createIndexDefinitionTemplate();
		template.setName(indexName);
		template.setKind(kind);
		template.setNodeTypeName(indexedNodeType);
		template.setProviderName(providerName);
		if (workspaceNamePattern != null) {
			template.setWorkspaceNamePattern(workspaceNamePattern);
		} else {
			template.setAllWorkspaces();
		}
		if (desc != null) {
			template.setDescription(desc);
		}
		
		// Set up the columns ...
		IndexColumnDefinition colDefn = manager.createIndexColumnDefinitionTemplate().setPropertyName(propertyName).setColumnType(propertyType);
		template.setColumnDefinitions(colDefn);

		// Register the index ...
		manager.registerIndex(template, true);
	}
	
	private void regNodeType(Session repoSession, String typeName) throws RepositoryException{
			NodeTypeManager mgr = repoSession.getWorkspace().getNodeTypeManager();

			// Create a template for the node type ...
			NodeTypeTemplate type = mgr.createNodeTypeTemplate();
			type.setName(typeName);
			type.setDeclaredSuperTypeNames(new String[]{CrConstants.JCR_NT_UNSTRUCTURED});
			type.setAbstract(false);
			type.setOrderableChildNodes(true);
			type.setMixin(false);
			type.setQueryable(true);
			mgr.registerNodeType(type, true);
	}
}
{code}",2014/09/22 3:05 AM
MODE-2310,"When running unit tests such as: {{JcrVersioningTest}} or {{JcrNodeTypesTest}}, a lot of the time exceptions like this are seen in the console:

{code}
Running org.modeshape.jcr.JcrVersioningTest
modeshape-event-dispatcher-3321-thread-5 12:10:38,521 ERROR Error while refreshing index definitions for the ""testRepo"" repository
org.modeshape.jcr.cache.WorkspaceNotFoundException: The workspace The workspace ""system"" has been deleted. was not found
        at org.modeshape.jcr.cache.document.WorkspaceCache.checkNotClosed(WorkspaceCache.java:330)
        at org.modeshape.jcr.cache.document.WorkspaceCache.getRootKey(WorkspaceCache.java:217)
        at org.modeshape.jcr.cache.document.AbstractSessionCache.getRootKey(AbstractSessionCache.java:223)
        at org.modeshape.jcr.SystemContent.systemKey(SystemContent.java:132)
        at org.modeshape.jcr.SystemContent.systemNode(SystemContent.java:190)
        at org.modeshape.jcr.SystemContent.indexesKey(SystemContent.java:152)
        at org.modeshape.jcr.SystemContent.indexesNode(SystemContent.java:202)
        at org.modeshape.jcr.SystemContent.readAllIndexDefinitions(SystemContent.java:564)
        at org.modeshape.jcr.RepositoryIndexManager.readIndexDefinitions(RepositoryIndexManager.java:746)
        at org.modeshape.jcr.RepositoryIndexManager.notify(RepositoryIndexManager.java:509)
        at org.modeshape.jcr.RepositoryQueryManager.notify(RepositoryQueryManager.java:96)
        at org.modeshape.jcr.bus.RepositoryChangeBus$ChangeSetListenerConsumerAdapter.consume(RepositoryChangeBus.java:153)
        at org.modeshape.jcr.bus.RepositoryChangeBus$ChangeSetListenerConsumerAdapter.consume(RepositoryChangeBus.java:147)
        at org.modeshape.common.collection.ring.RingBuffer$ConsumerRunner.run(RingBuffer.java:462)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:724)
{code}

The exception(s) I'm seeing always involve the {{system}} workspace and don't prevent the test from passing since they are in the ""background""

Not sure if this due to the repository being shutdown by the test {{tearDown()}} or something else. IMO we should make the async index processing more robust. ",2014/09/19 5:18 AM
MODE-2309,"as recommended in MODE-2306 i've implemented a backup & restore functionality. that worked quite well but there is a problem with properties where the stored data contains newline characters.
The newlines get written to the exported JSON directly as for example CRLF. This makes the export file no longer readable for the import, it simply stopps importing when encountering such newline characters and only performs a partial (most of the time corrupted) import. It would be much appreciated if modeshape handles such special characters in a correct way during export / import (for example by escaping them).

forum discussion: https://developer.jboss.org/thread/248929",2014/09/17 10:17 AM
MODE-2307,"While trying to understand how indexes are working I found one new bug and one behaviour I would also consider a bug.

Please take a look at the attached testcase, I commented the failing statements.

Behaviour bug is that IMHO the following two queries should both use both defined indexes but only the subselect query is using both because of a different access order. The subselect query - and this is the real bug - doesn't return any rows. If I don't use indexes the subselect query is working.

Indexes have been defined on B.sysName and A.referenceId.

Query 1 using subselect: both indexes used but no results
{code}
SELECT A.* FROM [nt:typeWithReference] AS A
WHERE A.referenceId  IN (

SELECT B.[jcr:uuid] FROM [nt:typeWithSysName] AS B 
WHERE B.sysName = $sysName 
)
{code}

Query 2 using join: only one index is used, correct result but slow because the first access goes to A which is very slow without index. Imho the query optimizer should rewrite the query to first access B
{code}
SELECT A.* FROM [nt:typeWithReference] AS A
JOIN [nt:typeWithSysName] AS B ON A.referenceId  = B.[jcr:uuid] 
WHERE B.sysName = $sysName 
{code}

Testcase
{code}
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.erratic.rm.test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.jcr.Node;
import javax.jcr.PropertyType;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.nodetype.NodeTypeManager;
import javax.jcr.nodetype.NodeTypeTemplate;
import javax.jcr.query.Query;
import static org.apache.deltaspike.core.api.projectstage.ProjectStage.UnitTest;
import org.apache.deltaspike.testcontrol.api.TestControl;
import org.apache.deltaspike.testcontrol.api.junit.CdiTestRunner;
import org.junit.Assert;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.MethodSorters;
import org.modeshape.jcr.api.index.IndexColumnDefinition;
import org.modeshape.jcr.api.index.IndexDefinition;
import org.modeshape.jcr.api.index.IndexDefinitionTemplate;
import org.modeshape.jcr.api.index.IndexManager;
import javax.jcr.query.QueryResult;
import org.erratic.cr.commons.CrConstants;
import org.slf4j.Logger;

/**
 *
 * @author bschmidt
 */
@RunWith(CdiTestRunner.class)
@TestControl(startScopes = RequestScoped.class, projectStage = UnitTest.class)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
//@Ignore
public class WmModeshapeIndex4Test {

	
	@Inject
	private Session session;

	@Inject
	protected transient Logger logger;

	@Test
	public void test001CheckSomethingWithIndexes() throws RepositoryException, InterruptedException {
		
		regNodeType(session,""nt:typeWithReference"");
		ensureIndex(indexManager(), ""referenceId"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:typeWithReference"", """", null, ""referenceId"", PropertyType.STRING);
		
		regNodeType(session,""nt:typeWithSysName"");
		ensureIndex(indexManager(), ""sysName"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:typeWithSysName"", """", null, ""sysName"", PropertyType.STRING);
		
		Node newNode1 = session.getRootNode().addNode(""nodeWithSysName"",""nt:typeWithSysName"");
		newNode1.setProperty(""sysName"", ""X"");
		newNode1.addMixin(""mix:referenceable"");
		
		Node newNode2 = session.getRootNode().addNode(""nodeWithReference"",""nt:typeWithReference"");
		newNode2.setProperty(""referenceId"", newNode1.getIdentifier());
		
		session.save();
		
		Thread.sleep(500);

		
		Query q = session.getWorkspace().getQueryManager().createQuery(
		""SELECT A.* FROM [nt:typeWithReference] AS A\n"" +
		""WHERE A.referenceId  IN (\n"" +
		""\n"" +
		""SELECT B.[jcr:uuid] FROM [nt:typeWithSysName] AS B \n"" +
		""WHERE B.sysName = $sysName \n"" +
		"")"",Query.JCR_SQL2);
		q.bindValue(""sysName"", session.getValueFactory().createValue(""X""));
		
		logger.info(q.getStatement());
		
		QueryResult result = q.execute();
		
		String plan = ((org.modeshape.jcr.api.query.QueryResult)result).getPlan();
		logger.info(plan);
		
		Assert.assertEquals(2,countIndexes(plan));
		Assert.assertEquals(result.getNodes().hasNext(),true); // FAILS, so nothing found using subselect and indexes
		
		
		Query q2 = session.getWorkspace().getQueryManager().createQuery(
		""SELECT A.* FROM [nt:typeWithReference] AS A\n"" +
		""JOIN [nt:typeWithSysName] AS B ON A.referenceId  = B.[jcr:uuid] \n"" +
		""WHERE B.sysName = $sysName \n""
		,Query.JCR_SQL2);
		q2.bindValue(""sysName"", session.getValueFactory().createValue(""X""));
		
		logger.info(q2.getStatement());
		
		QueryResult result2 = q2.execute();
		
		String plan2 = ((org.modeshape.jcr.api.query.QueryResult)result2).getPlan();
		logger.info(plan2);
		
		Assert.assertEquals(2,countIndexes(plan2)); // FAILS, so index that should be used is not because of wrong access order
		Assert.assertEquals(true,result2.getNodes().hasNext());
	}
	
	private int countIndexes(String plan){
		
		Pattern p = Pattern.compile(""INDEX_USED=true"");
		Matcher m = p.matcher(plan);
		int count = 0;
		while (m.find()){
			count +=1;
		}
		return count;
	}
	
	protected IndexManager indexManager(){
		
		if (!(session instanceof org.modeshape.jcr.api.Session)){
			return null;
		}
		
		try {
			return ((org.modeshape.jcr.api.Session) session).getWorkspace().getIndexManager();
		} catch (RepositoryException ex) {
			logger.error(ex.toString(), ex);
		}
		return null;
	}
	
	protected void ensureIndex(IndexManager manager, String indexName, IndexDefinition.IndexKind kind, String providerName, String indexedNodeType, String desc, String workspaceNamePattern, String propertyName, int propertyType) throws RepositoryException {


		if (manager.getIndexDefinitions().containsKey(indexName)){
			return;
		}
		
		logger.info(""registering index on property ""+propertyName+"", type ""+indexedNodeType);
		
		// Create the index template ...
		IndexDefinitionTemplate template = manager.createIndexDefinitionTemplate();
		template.setName(indexName);
		template.setKind(kind);
		template.setNodeTypeName(indexedNodeType);
		template.setProviderName(providerName);
		if (workspaceNamePattern != null) {
			template.setWorkspaceNamePattern(workspaceNamePattern);
		} else {
			template.setAllWorkspaces();
		}
		if (desc != null) {
			template.setDescription(desc);
		}
		
		// Set up the columns ...
		IndexColumnDefinition colDefn = manager.createIndexColumnDefinitionTemplate().setPropertyName(propertyName).setColumnType(propertyType);
		template.setColumnDefinitions(colDefn);

		// Register the index ...
		manager.registerIndex(template, true);
	}
	
	private void regNodeType(Session repoSession, String typeName) throws RepositoryException{
			NodeTypeManager mgr = repoSession.getWorkspace().getNodeTypeManager();

			// Create a template for the node type ...
			NodeTypeTemplate type = mgr.createNodeTypeTemplate();
			type.setName(typeName);
			type.setDeclaredSuperTypeNames(new String[]{CrConstants.JCR_NT_UNSTRUCTURED});
			type.setAbstract(false);
			type.setOrderableChildNodes(true);
			type.setMixin(false);
			type.setQueryable(true);
			mgr.registerNodeType(type, true);
	}
}

{code}",2014/09/16 8:46 AM
MODE-2302,"When removing binary properties in a repository configured to use a {{FileSystemBinaryStore}}, ModeShape will not remove the binary value immediately from the binary store, but will rather move this binary content into a {{trash}} area. 
If at any time later the same binary value is reused and the value is still in the trash, this value is brought back from the trash into the main repository area. 

The entire used/unused cycle is ATM asynchronous (unfortunately) via a {{BinaryUsageChangeSetListener}}. Because of this, the {{FileSystemBinaryStore}} and possibly other stores as well have severe flaws manifesting as:

1. Exceptions like:
{code}
org.modeshape.jcr.value.binary.BinaryStoreException: Unable to find binary value with key ""92eb27d63a7c4432832e6406e01eaf130ceaa9ba"" within binary store at ""target\persistent_repository\binaries""
	at org.modeshape.jcr.value.binary.FileSystemBinaryStore.getStoredMimeType(FileSystemBinaryStore.java:478)
	at org.modeshape.jcr.value.binary.AbstractBinaryStore.getMimeType(AbstractBinaryStore.java:153)
	at org.modeshape.jcr.value.binary.StoredBinaryValue.getMimeType(StoredBinaryValue.java:63)
	at org.modeshape.jcr.JcrSession$JcrPreSave.process(JcrSession.java:2233)
	at org.modeshape.jcr.cache.document.WritableSessionCache.runPreSaveBeforeTransaction(WritableSessionCache.java:507)
	at org.modeshape.jcr.cache.document.WritableSessionCache.save(WritableSessionCache.java:565)
	at org.modeshape.jcr.JcrSession.save(JcrSession.java:1165)
	at org.modeshape.jcr.BinaryStorageIntegrationTest.shouldReuseBinariesFromTrashForFilesystemStore(BinaryStorageIntegrationTest.java:166)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
{code} 

2. Various assertion failures in the {{FileLocks}} class.
",2014/09/11 8:39 AM
MODE-2297,"If I fire the query below and then loop over the resultset using NodeIterator.hasnext() / NodeIterator.nextNode(), I get a java.util.NoSuchElementException at org.modeshape.jcr.query.NodeSequence$SingleWidthBatch.getNode(NodeSequence.java:1979)
	at org.modeshape.jcr.query.JcrQueryResult$QueryResultNodeIterator.nextNode(JcrQueryResult.java:292)


Edit: same happens if using UNION, INTERSECT works in this case but only because it returns an empty resultset. So I guess it always happens on non empty set

Code used to loop:
{code}
NodeIterator nodeIterator = query.execute().getNodes()
while (nodeIterator.hasNext()) {
              nodeIterator.nextNode();
            }
{code}

Query code:
{code}
SELECT BASE.* from [nt:unstructured] as BASE  

JOIN  [nt:unstructured] AS REF ON ISCHILDNODE(BASE,REF) 
JOIN [nt:unstructured] AS REF2 ON REF2.[jcr:uuid] = REF.[jcr:uuid] 


INTERSECT

SELECT BASE.* from [nt:unstructured] as BASE  
JOIN  [nt:unstructured] AS REF 
	ON REF.[jcr:uuid] = BASE.[jcr:uuid]
{code}",2014/09/08 8:41 AM
MODE-2296,"I wasn't able to create a neat test case for the problem, what's happening is, I get the following assert exception during one of my tests. I'm not sure if only during tests, but it might be (because of assert statement)

EDIT: was able to reproduce it, has something to do with joins, see testcase below.

The assert statement in BufferingSequence fails, If an index is chosen that doesn't contain the search value. But not always, that's why I was unable to create a test case. What I can tell is, that the same Query executes fine, if the search value is present in the index.

The last trace message prior to the exception is 

{code}
5930 TRACE org.modeshape.jcr.index.local.LocalIndexProvider  - Looking for index 'org.erratic.rm.model.RmRole-sysName' in 'local' provider for query in workspace 'default'
{code}

{code}
at org.modeshape.jcr.query.engine.process.BufferingSequence.<init>(BufferingSequence.java:61)
	at org.modeshape.jcr.query.engine.process.JoinSequence.<init>(JoinSequence.java:119)
	at org.modeshape.jcr.query.engine.process.HashJoinSequence.<init>(HashJoinSequence.java:61)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:706)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:579)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:579)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:579)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:579)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.createNodeSequence(ScanningQueryEngine.java:743)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.executeOptimizedQuery(ScanningQueryEngine.java:467)
	at org.modeshape.jcr.query.engine.ScanningQueryEngine.execute(ScanningQueryEngine.java:330)
	at org.modeshape.jcr.RepositoryQueryManager$1.execute(RepositoryQueryManager.java:171)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:118)
	at org.modeshape.jcr.query.JcrQuery.execute(JcrQuery.java:43)
{code}


{code}
public class WmModeshapeIndex3Test {

	
	@Inject
	private Session session;

	@Inject
	protected transient Logger logger;

	@Test
	public void test001CheckSomethingWithIndexes() throws RepositoryException, InterruptedException {
		
		
		
		ensureIndex(indexManager(), ""ntusysname"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:unstructured"", """", null, ""sysName"", PropertyType.STRING);
	
		Thread.sleep(500);
		
		Node newNode2 = session.getRootNode().addNode(""XNODE"",""nt:unstructured"");
		newNode2.setProperty(""sysName"", ""eUser"");
		
		Thread.sleep(500);
		
		Query q = session.getWorkspace().getQueryManager().createQuery(""select BASE.* FROM [nt:unstructured] as BASE JOIN [nt:unstructured] AS B ON B.sysName=BASE.sysName WHERE B.sysName=$sysName"",Query.JCR_SQL2);
		q.bindValue(""sysName"", session.getValueFactory().createValue(""eNonexistent""));
		QueryResult result = q.execute();
		
		String plan = ((org.modeshape.jcr.api.query.QueryResult)result).getPlan();
		logger.info(plan);
		
		Assert.assertEquals(true,plan.contains(""INDEX_USED=true""));
	}
	
	protected IndexManager indexManager(){
		
		if (!(session instanceof org.modeshape.jcr.api.Session)){
			return null;
		}
		
		try {
			return ((org.modeshape.jcr.api.Session) session).getWorkspace().getIndexManager();
		} catch (RepositoryException ex) {
			logger.error(ex.toString(), ex);
		}
		return null;
	}
	
	protected void ensureIndex(IndexManager manager, String indexName, IndexDefinition.IndexKind kind, String providerName, String indexedNodeType, String desc, String workspaceNamePattern, String propertyName, int propertyType) throws RepositoryException {


		if (manager.getIndexDefinitions().containsKey(indexName)){
			return;
		}
		
		logger.info(""registering index on property ""+propertyName+"", type ""+indexedNodeType);
		
		// Create the index template ...
		IndexDefinitionTemplate template = manager.createIndexDefinitionTemplate();
		template.setName(indexName);
		template.setKind(kind);
		template.setNodeTypeName(indexedNodeType);
		template.setProviderName(providerName);
		if (workspaceNamePattern != null) {
			template.setWorkspaceNamePattern(workspaceNamePattern);
		} else {
			template.setAllWorkspaces();
		}
		if (desc != null) {
			template.setDescription(desc);
		}
		
		// Set up the columns ...
		IndexColumnDefinition colDefn = manager.createIndexColumnDefinitionTemplate().setPropertyName(propertyName).setColumnType(propertyType);
		template.setColumnDefinitions(colDefn);

		// Register the index ...
		manager.registerIndex(template, true);
	}
	
	private void regNodeType(Session repoSession, String typeName) throws RepositoryException{
			NodeTypeManager mgr = repoSession.getWorkspace().getNodeTypeManager();

			// Create a template for the node type ...
			NodeTypeTemplate type = mgr.createNodeTypeTemplate();
			type.setName(typeName);
			type.setDeclaredSuperTypeNames(new String[]{CrConstants.JCR_NT_UNSTRUCTURED});
			type.setAbstract(false);
			type.setOrderableChildNodes(true);
			type.setMixin(false);
			type.setQueryable(true);
			mgr.registerNodeType(type, true);
	}
}
{code}",2014/09/05 6:43 AM
MODE-2295,"Please run this test on an empty repo, it will fail. I'm not sure if and how much this is related to MODE-2290, but indexing is still not working as expected.

I know that it doesn't make sense to register indexes like that, my real code differs a bit, but this test was the easiest way to reproduce the problem.

{code}
public class WmModeshapeIndex2Test {

	
	@Inject
	private Session session;

	@Inject
	protected transient Logger logger;

	@Test
	public void test001CheckSomethingWithIndexes() throws RepositoryException, InterruptedException {
		
		regNodeType(session,""nt:someType2"");

		ensureIndex(indexManager(), ""ntsome2sysname"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:someType2"", """", null, ""sysName"", PropertyType.STRING);
		
		Thread.sleep(500);
		
		Node newNode = session.getRootNode().addNode(""SOMENODE"",""nt:someType2"");
		newNode.setProperty(""sysName"", ""X"");
		
		Thread.sleep(500);
		
		ensureIndex(indexManager(), ""ntusysname"", IndexDefinition.IndexKind.VALUE, ""local"", ""nt:unstructured"", """", null, ""sysName"", PropertyType.STRING);
	
		Node newNode2 = session.getRootNode().addNode(""SOMENODE"",""nt:unstructured"");
		newNode2.setProperty(""sysName"", ""X"");
		
		Thread.sleep(500);
		
		Query q = session.getWorkspace().getQueryManager().createQuery(""select BASE.* FROM [nt:unstructured] as BASE WHERE BASE.sysName=$sysName"",Query.JCR_SQL2);
		q.bindValue(""sysName"", session.getValueFactory().createValue(""X""));
		QueryResult result = q.execute();
		
		String plan = ((org.modeshape.jcr.api.query.QueryResult)result).getPlan();
		logger.info(plan);
		
		Assert.assertEquals(true,plan.contains(""INDEX_USED=true""));
	}
	
	protected IndexManager indexManager(){
		
		if (!(session instanceof org.modeshape.jcr.api.Session)){
			return null;
		}
		
		try {
			return ((org.modeshape.jcr.api.Session) session).getWorkspace().getIndexManager();
		} catch (RepositoryException ex) {
			logger.error(ex.toString(), ex);
		}
		return null;
	}
	
	protected void ensureIndex(IndexManager manager, String indexName, IndexDefinition.IndexKind kind, String providerName, String indexedNodeType, String desc, String workspaceNamePattern, String propertyName, int propertyType) throws RepositoryException {


		if (manager.getIndexDefinitions().containsKey(indexName)){
			return;
		}
		
		logger.info(""registering index on property ""+propertyName+"", type ""+indexedNodeType);
		
		// Create the index template ...
		IndexDefinitionTemplate template = manager.createIndexDefinitionTemplate();
		template.setName(indexName);
		template.setKind(kind);
		template.setNodeTypeName(indexedNodeType);
		template.setProviderName(providerName);
		if (workspaceNamePattern != null) {
			template.setWorkspaceNamePattern(workspaceNamePattern);
		} else {
			template.setAllWorkspaces();
		}
		if (desc != null) {
			template.setDescription(desc);
		}
		
		// Set up the columns ...
		IndexColumnDefinition colDefn = manager.createIndexColumnDefinitionTemplate().setPropertyName(propertyName).setColumnType(propertyType);
		template.setColumnDefinitions(colDefn);

		// Register the index ...
		manager.registerIndex(template, true);
	}
	
	private void regNodeType(Session repoSession, String typeName) throws RepositoryException{
			NodeTypeManager mgr = repoSession.getWorkspace().getNodeTypeManager();

			// Create a template for the node type ...
			NodeTypeTemplate type = mgr.createNodeTypeTemplate();
			type.setName(typeName);
			type.setDeclaredSuperTypeNames(new String[]{CrConstants.JCR_NT_UNSTRUCTURED});
			type.setAbstract(false);
			type.setOrderableChildNodes(true);
			type.setMixin(false);
			type.setQueryable(true);
			mgr.registerNodeType(type, true);
	}
{code}",2014/09/05 6:27 AM
MODE-2293,"{{MapDB}} is used at the moment as a dependency for the indexing & journaling features from the {{modeshape-jcr}} artifact. 

When building the WF kit, this has been packaged & deployed as a separate, independent module on which the {{modeshape.main}} module depends. However, because of the way the MapDB serialization/deserialization mechanism works, it turns out that the {{mapdb}} module can't work class-loading wise without depending on {{modeshape.main}}. This would create a circular dependency which cannot exist.

To fix this, the MapDB module needs to be removed and MapDB used as an internal resource for the {{modeshape.main}} module. See the linked issue for a concrete example of a CL problem.",2014/09/05 3:13 AM
MODE-2292,"When *re*starting a repository after at least one index definition has been defined, the index definitions cannot be effectively read. Reading the nodes under ""{{/jcr:system/mode:indexes}}"" results in the following exception:

{code}
javax.jcr.RepositoryException: No valid property definition on node '/jcr:system/mode:indexes/local/ntusysname' with primary type 'mode:index' and mixin types [] for the property: mode:kind=""VALUE""
	at org.modeshape.jcr.AbstractJcrNode.findJcrProperties(AbstractJcrNode.java:2035)
	at org.modeshape.jcr.AbstractJcrNode.getProperties(AbstractJcrNode.java:2043)
	at org.modeshape.jcr.JcrSystemNode.getProperties(JcrSystemNode.java:25)
	at org.modeshape.jcr.api.JcrTools.printSubgraph(JcrTools.java:555)
{code}

There is a bug in the ""{{modeshape-builtins.cnd}}"" file, and the index-related node types do not match the structure written to the repository when index definitions are registered.

This prevents a repository from properly restarting.",2014/09/04 1:32 PM
MODE-2290,"None of the following queries uses (or even considers) an index, despite there being an index that is a perfect match (e.g., on {{nt:unstructured}} with column ""{{someProperty(STRING)}}""):
{code}
SELECT table.* FROM [nt:unstructured] AS table WHERE table.someProperty = $value
SELECT table.* FROM [nt:unstructured] AS table WHERE table.someProperty = 'literal'
SELECT * FROM [nt:unstructured] WHERE someProperty = $value
{code}

Interestingly, the following query *does* use the index:

{code}
SELECT * FROM [nt:unstructured] WHERE someProperty = 'literal'
{code}

So there appears to be a problem with properties on aliases and use of bind variables in constraints.
",2014/09/03 12:19 PM
MODE-2286,"Assume I only have the following nodes in the repo that need to be found

/a/b/c/d/e
/a/b/c/d[2]/e

According to XPathToQUeryTranslaterTest (Lines 66 ff) the following queries should deliver the same result:

/jcr:root/a/b/c/d/e
returns 2 results

SELECT * FROM [nt:base] AS BASE WHERE PATH(BASE) LIKE '/a/b/c/d[%]/e[%]'
returns no result at all

SELECT * FROM [nt:base] AS BASE WHERE PATH(BASE) LIKE '/a/b/c/d[%]/e%'
returns only /a/b/c/d[2]/e

SELECT * FROM [nt:base] AS BASE WHERE PATH(BASE) LIKE '/a/b/c/d%/e%'
returns 2 results

So the brackets don't work as expected, but omiting them solves the problem. Is this the expected behaviour or a bug?",2014/08/29 3:38 AM
MODE-2285,"I am currently unable to create indexes using the Wildfly 8.1 Modeshape sub-system.

Below is the configuration I used:

{noformat}
<subsystem xmlns=""urn:jboss:domain:modeshape:2.0"">  
  <repository name=""test-repo"" cache-name=""test-repo"" cache-container=""modeshape"" security-domain=""test-security"">  
  <workspaces>  
  <workspace name=""default"">  
  <initial-content>  
                            /apps/test/config/initial-test-content.xml  
                        </initial-content>  
  </workspace>  
  </workspaces>  
  <node-types>  
  <node-type>/apps/test/config/stock/schema.cnd</node-type>  
  </node-types>  
  <index-providers>  
  <index-provider name=""stock"" classname=""org.modeshape.jcr.index.local.LocalIndexProvider"" module=""org.modeshape"" path=""/apps/test/indexes""/>  
  </index-providers>  
  <indexes>  
  <index name=""assetName"" provider-name=""stock"" kind=""value"" node-type=""asset:stock"" columns=""asset:name(STRING)""/>  
  </indexes>  
  </repository>  
</subsystem>
{noformat}

The following error occurs attempting to parse the XML.

{noformat}
Message: JBAS014789: Unexpected element '{urn:jboss:domain:jaxrs:1.0}subsystem' encountered
  at org.jboss.as.controller.parsing.ParseUtils.unexpectedElement(ParseUtils.java:85) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
  at org.jboss.as.controller.parsing.ParseUtils.nextElement(ParseUtils.java:76) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
  at org.jboss.as.server.parsing.StandaloneXml.readServerElement_1_4(StandaloneXml.java:459) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
  at org.jboss.as.server.parsing.StandaloneXml.readElement(StandaloneXml.java:145) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
  at org.jboss.as.server.parsing.StandaloneXml.readElement(StandaloneXml.java:107) [wildfly-server-8.1.0.Final.jar:8.1.0.Final]
  at org.jboss.staxmapper.XMLMapperImpl.processNested(XMLMapperImpl.java:110) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
  at org.jboss.staxmapper.XMLMapperImpl.parseDocument(XMLMapperImpl.java:69) [staxmapper-1.1.0.Final.jar:1.1.0.Final]
  at org.jboss.as.controller.persistence.XmlConfigurationPersister.load(XmlConfigurationPersister.java:104) [wildfly-controller-8.1.0.Final.jar:8.1.0.Final]
  ... 3 more
{noformat}

 A full discussion can be found on the forum at:

https://developer.jboss.org/message/902328?et=watches.email.thread#902328

I was also able to recreate the issue using the ModeShape test suite, see steps below.",2014/08/28 6:14 PM
MODE-2284,"After import existing node tree from xml all imported nodes lose backreferences.

We write workaround helper which store existing backreferences before import and restore them after import:
{code}
// Find in imported xml all nodes that exists in the store and memorize backreferences for them
BackreferencesRestorerContentHandlerWrapper referrersHandler = new BackreferencesRestorerContentHandlerWrapper(nodeIdentifier, session);
parser.setContentHandler(referrersHandler);
parser.parse(new InputSource(new ByteArrayInputStream(buffer)));

// Do import after that we lose backreferences
session.importXML(path, new ByteArrayInputStream(buffer), ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING);

// Now we restore backreferences...
referrersHandler.restoreReferences();
{code}

But is bad workaround and not stable for production",2014/08/28 3:58 AM
MODE-2283,"After clear reference property value and again set it to same old value, referenced node lose backreference, method getReferences not return property.

{code}
Node referenceableNode = session.getRootNode().addNode(""referenceable"");
referenceableNode.addMixin(JcrMixLexicon.REFERENCEABLE.toString());

Node node1 = session.getRootNode().addNode(""node1"");
Property prop1 = node1.setProperty(""prop1"", session.getValueFactory().createValue(referenceableNode, false));

session.save();

// Do modifications
node1.setProperty(""prop1"", (Value) null);
node1.setProperty(""prop1"", session.getValueFactory().createValue(referenceableNode, false));

session.save();

PropertyIterator propertyIterator = referenceableNode.getReferences();
assertEquals(1, propertyIterator.getSize());
{code}
",2014/08/27 11:45 AM
MODE-2279,"The index {{kind}} attribute is defined in the JSON schema as an enumeration {{""unique"",""value"",""enumerated"",""text"",""nodetype""}} using *lowercase letters*.

However, when the configuration is parsed & a repository starts up, this is translated as-is to a {{IndexDefinition$IndexKind}} enum via {{valueOf}}, which will always fail ATM.",2014/08/25 9:52 AM
MODE-2278,"If I call NamespaceRegistry.registerNamespace(""stupid:namespace"") this is accepted AND working fine afterwars until I shutdown the repo.

But next time I try to acces the repo everything freaks out.

There should maybe be a NamespaceException in the first place.",2014/08/19 9:54 AM
MODE-2275,"I'm currently facing a porblem I'm unable to understand or solve:
 
If I create two new NodeTypes and then ask for the second one, I get a javax.jcr.query.InvalidQueryException.
 
Note that the first search works, only the second one fails.
 
If have no idea what is happening or what I maybe do wrong.
 
Any help is appreciated.
{code}
@RunWith( CdiTestRunner.class )
@TestControl( startScopes = ApplicationScoped.class )
@FixMethodOrder( MethodSorters.NAME_ASCENDING )
public class CDITest {
    @Inject
    private Session session;

    private void regNodeType( Session repoSession, String typeName ) throws RepositoryException {
        NodeTypeManager mgr = repoSession.getWorkspace().getNodeTypeManager();

        // Create a template for the node type ...
        NodeTypeTemplate type = mgr.createNodeTypeTemplate();
        type.setName(typeName);
        type.setDeclaredSuperTypeNames(new String[] { CrConstants.JCR_NT_UNSTRUCTURED });
        type.setAbstract(false);
        type.setOrderableChildNodes(true);
        type.setMixin(false);
        type.setQueryable(true);
        mgr.registerNodeType(type, true);
    }

    private void fireQuery( Session repoSession, String typeName ) throws RepositoryException {
        Query query = repoSession.getWorkspace().getQueryManager().createQuery(
                ""SELECT BASE.* FROM ["" + typeName + ""] AS BASE "", Query.JCR_SQL2);
        query.execute();
    }

    private Node saveNode( Session repoSession, String typeName ) throws RepositoryException {
        Node root = repoSession.getNode(""/"");
        Node x = root.addNode(""xyz:XYZ"", typeName);
        repoSession.save();
        return x;
    }

    private void regNs( Session repoSession ) throws RepositoryException {
        NamespaceRegistry reg = repoSession.getWorkspace().getNamespaceRegistry();
        reg.registerNamespace(""xyz"", ""org://some"");
    }

    @Test
    public void test000Schrott() throws RepositoryException {
        regNs(session);
        regNodeType(session, ""xyz:pommes"");
        fireQuery(session, ""xyz:pommes"");
        Node x = saveNode(session, ""xyz:pommes"");
        x.setProperty(""some"", ""thing"");
        regNodeType(session, ""xyz:mayo"");
        fireQuery(session, ""xyz:mayo"");
    }
}
{code}",2014/08/01 8:25 AM
MODE-2273,Provide repository navigation using browser's FORWARD/BACKWARD buttons,2014/07/30 12:12 PM
MODE-2272,The Java sequencer is not thread-safe and should be. See discussion and test case in MODE-2264.,2014/07/30 12:10 PM
MODE-2271,"When obtaining a path for a node, we have to walk up the ancestors and, for each, find the reference for the child within the parent node. Attached is a method call timing table that shows that several methods make this quite a bit more expensive than need be. In particular, a lot of time is spent inside the {{Matcher.matches(...)}} method within the {{NameValueFactory.create(...)}} method. And, when trying to find a child and its name within the parent, the {{LazyCachedNode.parentReferenceToSelf(WorkspaceCache)}} is getting the complete list of all child references via the {{LazyCachedNode.getChildReferences(...)}} method call.

Both of these need to be fixed.

{noformat}
org.modeshape.jcr.JcrNode.getPath()
  org.modeshape.jcr.AbstractJcrNode.path()
    org.modeshape.jcr.cache.document.LazyCachedNode.getPath(NodeCache)
      org.modeshape.jcr.cache.document.LazyCachedNode.getSegment(WorkspaceCache)
        org.modeshape.jcr.cache.document.LazyCachedNode.parentReferenceToSelf(WorkspaceCache)
          org.modeshape.jcr.cache.document.LazyCachedNode.getChildReferences(NodeCache)  <========
            org.modeshape.jcr.cache.document.DocumentTranslator.getChildReferences(WorkspaceCache, Document)
              org.modeshape.jcr.cache.document.DocumentTranslator.childReferencesListFromArray(List)
                org.modeshape.jcr.cache.document.DocumentTranslator.childReferenceFrom(Object)
                  org.modeshape.jcr.value.basic.NameValueFactory.create(String, TextDecoder)
                    org.modeshape.jcr.value.basic.NameValueFactory.create(String, TextDecoder)
                      java.util.regex.Matcher.matches()  <========
                      java.util.regex.Pattern.matcher(CharSequence)
                      org.modeshape.jcr.SystemNamespaceRegistry.getNamespaceForPrefix(String)
                      org.modeshape.jcr.value.basic.BasicName.<init>(String, String)
                  org.infinispan.schematic.internal.document.BasicDocument.getString(String)
                  org.modeshape.jcr.cache.ChildReference.<init>(NodeKey, Name, int)
              org.modeshape.jcr.cache.document.ImmutableChildReferences.create(List)
                org.modeshape.jcr.cache.document.ImmutableChildReferences$Medium.<init>(Iterable)
                  org.modeshape.common.collection.LinkedListMultimap.put(Object, Object)
                    org.modeshape.common.collection.LinkedListMultimap.addEntryFor(Object, Object)
                  java.util.HashMap.put(Object, Object)
{noformat}

",2014/07/29 11:22 AM
MODE-2268,"When adding an event listener to a session, if the {{noLocal}} filter is set to {{true}}, this listener *shouldn't* be notified with events generated from the ""owner"" session, but *should* be notified with events generated from the other active sessions.

This is not working atm. because of the fact that the {{processId}} of all the events in the system is the same for all active sessions, meaning there is not way to tell which event set belongs to which session.",2014/07/24 4:57 PM
MODE-2261,Modeshape returns an exception when trying to execute query with multiple selectors via REST API.,2014/07/22 11:39 AM
