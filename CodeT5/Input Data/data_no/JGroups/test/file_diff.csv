file_diff,commit_time,file_diff_id
"@@ -12,7 +12,6 @@
 import java.io.DataOutput;
 import java.io.InputStream;
 import java.util.Collection;
-import java.util.List;
 import java.util.Map;
 import java.util.TreeSet;
 
@@ -126,6 +125,23 @@ public String printRoutes() {
 
     public Object down(Event evt) {
         switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                Address dest=msg.getDest();
+                if(dest == null || !(dest instanceof SiteAddress))
+                    break; // todo: handle multicasts
+                SiteAddress target=(SiteAddress)dest;
+                // if(addr.getSite() == site_id) // same site: local; pass down
+                   // break;
+                byte[] buf=marshal(msg);
+                if(buf == null)
+                    return null; // don't pass down
+                SiteUUID sender=new SiteUUID((UUID)local_addr, site_id);
+                if(local_addr.equals(coord))
+                    route(target, sender, buf);
+                else
+                    forwardToCoordinator(target, sender, buf);
+                return null;
             case Event.SET_LOCAL_ADDRESS:
                 local_addr=(Address)evt.getArg();
                 break;
@@ -139,13 +155,92 @@ public Object down(Event evt) {
 
     public Object up(Event evt) {
         switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                Relay2Header hdr=(Relay2Header)msg.getHeader(id);
+                if(hdr == null)
+                    break;
+
+                System.out.println(""["" + local_addr + ""] received message with Relay2Header "" + hdr);
+                handleMessage(hdr, msg);
+                return null;
             case Event.VIEW_CHANGE:
                 handleView((View)evt.getArg());
                 break;
         }
         return up_prot.up(evt);
     }
 
+    /** Called to handle a received relay message */
+    protected void handleMessage(Relay2Header hdr, Message msg) {
+        System.out.println(""**** handleMessage()"");
+    }
+
+
+    protected void forwardToCoordinator(SiteAddress dest, Address sender, byte[] buf) {
+        Message msg=new Message(coord, buf);
+        Relay2Header hdr=new Relay2Header(Relay2Header.DATA, dest, sender);
+        msg.putHeader(id, hdr);
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+
+
+    /**
+     * Routes the message to the target destination, used by a site master (coordinator)
+     * @param dest
+     * @param buf
+     */
+    protected void route(SiteAddress dest, SiteUUID sender, byte[] buf) {
+        short target_site=dest.getSite();
+        if(target_site == site_id) {
+            deliverLocally(dest, sender, buf);
+            return;
+        }
+        Relayer tmp=relayer;
+        if(tmp == null) {
+            log.warn(""not site master; dropping message"");
+            return;
+        }
+        Relayer.Route route=relayer.getRoute(target_site);
+        relay(dest, sender, route, buf);
+    }
+
+    protected void deliverLocally(SiteAddress dest, SiteUUID sender, byte[] buf) {
+
+    }
+
+    protected void relay(SiteAddress to, SiteAddress from, Relayer.Route route, byte[] buf) {
+        if(route == null) {
+            log.warn(""route for site"" + to.getSite() + "" not found; dropping message"");
+            return;
+        }
+        RELAY2.Relay2Header hdr=new RELAY2.Relay2Header(RELAY2.Relay2Header.DATA, to, from);
+        Message msg=new Message(route.site_master, buf);
+        msg.putHeader(id, hdr);
+        try {
+            route.bridge.send(msg);
+        }
+        catch(Exception e) {
+            log.error(""failure relaying message"", e);
+        }
+    }
+
+
+    protected byte[] marshal(Message msg) {
+        Message tmp=msg.copy(true, Global.BLOCKS_START_ID); // // we only copy headers from building blocks
+        // setting dest and src to null reduces the serialized size of the message; we'll set dest/src from the header later
+        tmp.setDest(null);
+        tmp.setSrc(null);
+
+        try {
+            return Util.streamableToByteBuffer(tmp);
+        }
+        catch(Exception e) {
+            log.error(""marshalling failure"", e);
+            return null;
+        }
+    }
+
 
 
     protected void handleView(View view) {
@@ -159,7 +254,7 @@ protected void handleView(View view) {
         if(become_coord) {
             is_coord=true;
             String bridge_name=""_"" + UUID.get(local_addr);
-            relayer=new Relayer(site_config, bridge_name, log);
+            relayer=new Relayer(site_config, bridge_name, log, this);
             try {
                 if(log.isTraceEnabled())
                     log.trace(""I became site master; starting bridges"");",2012-08-06T10:31:30Z,1
"@@ -2,6 +2,7 @@
 
 import org.jgroups.*;
 import org.jgroups.logging.Log;
+import org.jgroups.protocols.RELAY;
 import org.jgroups.protocols.relay.config.RelayConfig;
 import org.jgroups.stack.AddressGenerator;
 import org.jgroups.util.UUID;
@@ -32,9 +33,12 @@ public class Relayer {
 
     protected final Log                    log;
 
+    protected final RELAY2                 relay;
 
-    public Relayer(RelayConfig.SiteConfig site_config, String local_name, Log log) {
+
+    public Relayer(RelayConfig.SiteConfig site_config, String local_name, Log log, RELAY2 relay) {
         this.site_config=site_config;
+        this.relay=relay;
         int num_routes=site_config.getBridges().size();
         my_site_id=site_config.getId();
         routes=new Route[num_routes];
@@ -118,6 +122,12 @@ protected Route removeRoute(short site) {
         return null;
     }
 
+    protected Route getRoute(short site) {
+        if(site <= routes.length -1)
+            return routes[site];
+        return null;
+    }
+
     protected void ensureCapacity(short site) {
         if(site >= routes.length-1) {
             Route[] tmp_routes=new Route[routes.length * 2];
@@ -168,7 +178,12 @@ protected void stop() {
         }
 
         public void receive(Message msg) {
-
+            RELAY2.Relay2Header hdr=(RELAY2.Relay2Header)msg.getHeader(relay.getId());
+            if(hdr == null) {
+                log.warn(""received a message without a relay header; discarding it"");
+                return;
+            }
+            relay.handleMessage(hdr, msg);
         }
 
         public void viewAccepted(View view) {",2012-08-06T10:31:30Z,2
"@@ -28,6 +28,7 @@ public int compareTo(Address other) {
         if(other instanceof UUID)
             return super.compareTo(other);
         SiteMaster tmp=(SiteMaster)other;
+        if(tmp == null) return 1;
         return site == tmp.site? 0 : site < tmp.site? -1 : 1;
     }
 ",2012-08-06T10:31:30Z,3
"@@ -0,0 +1,86 @@
+package org.jgroups.blocks.atomic;
+
+import java.util.concurrent.CompletionStage;
+
+/**
+ * An asynchronous counter interface.
+ *
+ * @author Pedro Ruivo
+ * @since 5.2
+ */
+public interface AsyncCounter {
+
+    /**
+     * @return The counter's name.
+     */
+    String getName();
+
+    /**
+     * Gets the current value of the counter.
+     *
+     * @return A {@link CompletionStage} that is completed with the counter's value.
+     */
+    default CompletionStage<Long> get() {
+        return addAndGet(0);
+    }
+
+    /**
+     * Sets the counter to a new value.
+     *
+     * @return A {@link CompletionStage} that is completed with the counter's value is updated.
+     */
+    CompletionStage<Void> set(long new_value);
+
+    /**
+     * Atomically updates the counter using a compare-and-set operation.
+     *
+     * @param expect The expected value of the counter
+     * @param update The new value of the counter
+     * @return A {@link CompletionStage} that is completed with {@code true} if the counter is updated and {@link false} otherwise.
+     */
+    default CompletionStage<Boolean> compareAndSet(long expect, long update) {
+        return compareAndSwap(expect, update).thenApply(value -> value == expect);
+    }
+
+    /**
+     * Atomically updates the counter using a compare-and-swap operation.
+     *
+     * @param expect The expected value of the counter
+     * @param update The new value of the counter
+     * @return A {@link CompletionStage} that is completed with the current counter's value.
+     */
+    CompletionStage<Long> compareAndSwap(long expect, long update);
+
+    /**
+     * Atomically increments the counter and returns the new value
+     *
+     * @return A {@link CompletionStage} that is completed with the new counter's value.
+     */
+    default CompletionStage<Long> incrementAndGet() {
+        return addAndGet(1);
+    }
+
+    /**
+     * Atomically decrements the counter and returns the new value
+     *
+     * @return A {@link CompletionStage} that is completed with the new counter's value.
+     */
+    default CompletionStage<Long> decrementAndGet() {
+        return addAndGet(-1);
+    }
+
+
+    /**
+     * Atomically adds the given value to the current value.
+     *
+     * @param delta the value to add
+     * @return A {@link CompletionStage} that is completed with the updated counter's value.
+     */
+    CompletionStage<Long> addAndGet(long delta);
+
+    /**
+     * @return a synchronous wrapper around this instance.
+     */
+    SyncCounter sync();
+
+}",2022-04-28T17:08:39Z,4
"@@ -3,51 +3,21 @@
 /**
  * @author Bela Ban
  * @since 3.0.0
+ * @deprecated Since 5.2 and to be removed in a future version. Use {@link SyncCounter} instead.
  */
-public interface Counter {
-
-    String getName();
-
-    /**
-     * Gets the current value of the counter
-     * @return The current value
-     */
-    long get();
-
-    /**
-     * Sets the counter to a new value
-     * @param new_value The new value
-     */
-    void set(long new_value);
-
-    /**
-     * Atomically updates the counter using a CAS operation
-     *
-     * @param expect The expected value of the counter
-     * @param update The new value of the counter
-     * @return True if the counter could be updated, false otherwise
-     */
-    boolean compareAndSet(long expect, long update);
-
-    /**
-     * Atomically increments the counter and returns the new value
-     * @return The new value
-     */
-    long incrementAndGet();
-
-    /**
-     * Atomically decrements the counter and returns the new value
-     * @return The new value
-     */
-    long decrementAndGet();
-
-
-    /**
-     * Atomically adds the given value to the current value.
-     *
-     * @param delta the value to add
-     * @return the updated value
-     */
-    long addAndGet(long delta);
+@Deprecated
+public interface Counter extends SyncCounter {
+
+    @Override
+    default long compareAndSwap(long expect, long update) {
+        // throw exception by default to keep backwards compatibility
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default AsyncCounter async() {
+        // throw exception by default to keep backwards compatibility
+        throw new UnsupportedOperationException();
+    }
 }
 ",2022-04-28T17:08:39Z,5
"@@ -1,7 +1,10 @@
 package org.jgroups.blocks.atomic;
 
+import java.util.concurrent.CompletionStage;
+
 import org.jgroups.JChannel;
 import org.jgroups.protocols.COUNTER;
+import org.jgroups.util.CompletableFutures;
 
 /**
  * Provides a distributed counter (similar to AtomicLong) which can be atomically updated across a cluster.
@@ -27,12 +30,29 @@ public void setChannel(JChannel ch) {
      * @param initial_value The initial value of a new counter if there is no existing counter. Ignored
      * if the counter already exists
      * @return The counter implementation
+     * @deprecated since 5.2. Use {@link #getOrCreateSyncCounter(String, long)} instead.
      */
+    @Deprecated
     public Counter getOrCreateCounter(String name, long initial_value) {
         return counter_prot.getOrCreateCounter(name, initial_value);
     }
 
-  
+    public SyncCounter getOrCreateSyncCounter(String name, long initial_value) {
+        return CompletableFutures.join(getOrCreateAsyncCounter(name, initial_value).thenApply(AsyncCounter::sync));
+    }
+
+    /**
+     * Returns an existing counter, or creates a new one if none exists
+     *
+     * @param name          Name of the counter, different counters have to have different names
+     * @param initial_value The initial value of a new counter if there is no existing counter. Ignored
+     *                      if the counter already exists
+     * @return A {@link CompletionStage} which is completed with the counter implementation.
+     */
+    public CompletionStage<AsyncCounter> getOrCreateAsyncCounter(String name, long initial_value) {
+        return counter_prot.getOrCreateAsyncCounter(name, initial_value);
+    }
+
     /**
      * Deletes a counter instance (on the coordinator)
      * @param name The name of the counter. No-op if the counter doesn't exist",2022-04-28T17:08:39Z,6
"@@ -0,0 +1,81 @@
+package org.jgroups.blocks.atomic;
+
+/**
+ * A synchronous counter interface
+ *
+ * @author Bela Ban
+ * @author Pedro Ruivo
+ * @since 5.2
+ */
+public interface SyncCounter {
+
+    String getName();
+
+    /**
+     * Gets the current value of the counter
+     *
+     * @return The current value
+     */
+    long get();
+
+    /**
+     * Sets the counter to a new value
+     *
+     * @param new_value The new value
+     */
+    void set(long new_value);
+
+
+    /**
+     * Atomically updates the counter using a CAS operation
+     *
+     * @param expect The expected value of the counter
+     * @param update The new value of the counter
+     * @return True if the counter could be updated, false otherwise
+     */
+    default boolean compareAndSet(long expect, long update) {
+        return compareAndSwap(expect, update) == expect;
+    }
+
+    /**
+     * Atomically updates the counter using a compare-and-swap operation.
+     *
+     * @param expect The expected value of the counter
+     * @param update The new value of the counter
+     * @return The current counter's value.
+     */
+    long compareAndSwap(long expect, long update);
+
+    /**
+     * Atomically increments the counter and returns the new value
+     *
+     * @return The new value
+     */
+    default long incrementAndGet() {
+        return addAndGet(1L);
+    }
+
+    /**
+     * Atomically decrements the counter and returns the new value
+     *
+     * @return The new value
+     */
+    default long decrementAndGet() {
+        return addAndGet(-1L);
+    }
+
+
+    /**
+     * Atomically adds the given value to the current value.
+     *
+     * @param delta the value to add
+     * @return the updated value
+     */
+    long addAndGet(long delta);
+
+    /**
+     * @return an asynchronous wrapper around this instance.
+     */
+    AsyncCounter async();
+
+}",2022-04-28T17:08:39Z,7
"@@ -2,14 +2,24 @@
 
 import org.jgroups.*;
 import org.jgroups.annotations.*;
+import org.jgroups.blocks.atomic.AsyncCounter;
 import org.jgroups.blocks.atomic.Counter;
+import org.jgroups.blocks.atomic.SyncCounter;
 import org.jgroups.conf.AttributeType;
 import org.jgroups.stack.Protocol;
+import org.jgroups.util.Bits;
 import org.jgroups.util.*;
 
 import java.io.*;
 import java.util.*;
-import java.util.concurrent.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiFunction;
+import java.util.function.Function;
 import java.util.function.Supplier;
 
 
@@ -21,6 +31,12 @@
 @MBean(description=""Protocol to maintain distributed atomic counters"")
 public class COUNTER extends Protocol {
 
+    private static final AtomicLong REQUEST_ID_GENERATOR = new AtomicLong();
+    //enum value() method is expensive since it creates a copy of the internal array every time it is invoked.
+    //we can cache it since we don't change it.
+    private static final RequestType[] REQUEST_TYPES_CACHED = RequestType.values();
+    private static final ResponseType[] RESPONSE_TYPES_CACHED = ResponseType.values();
+
     @Property(description=""Bypasses message bundling if true"")
     protected boolean bypass_bundling=true;
 
@@ -46,63 +62,98 @@ public class COUNTER extends Protocol {
     /** Backup coordinators. Only created if num_backups > 0 and coord=true */
     protected List<Address> backup_coords=null;
 
+    @GuardedBy(""this"")
     protected Future<?> reconciliation_task_future;
 
     protected ReconciliationTask reconciliation_task;
 
     // server side counters
-    protected final ConcurrentMap<String,VersionedValue> counters=Util.createConcurrentMap(20);
+    protected final Map<String, VersionedValue> counters = Util.createConcurrentMap(20);
 
     // (client side) pending requests
-    protected final Map<Owner,Tuple<Request,Promise>> pending_requests=Util.createConcurrentMap(20);
+    protected final Map<Owner, RequestCompletableFuture> pending_requests = Util.createConcurrentMap(20);
 
     protected static final byte REQUEST  = 1;
     protected static final byte RESPONSE = 2;
-    
+
+    private TP transport;
 
     protected enum RequestType {
-        GET_OR_CREATE,
-        DELETE,
-        SET,
-        COMPARE_AND_SET,
-        ADD_AND_GET,
-        UPDATE,
-        RECONCILE,
-        RESEND_PENDING_REQUESTS
-    }
+        GET_OR_CREATE {
+            @Override
+            Request create() {
+                return new GetOrCreateRequest();
+            }
+        },
+        DELETE {
+            @Override
+            Request create() {
+                return new DeleteRequest();
+            }
+        },
+        SET {
+            @Override
+            Request create() {
+                return new SetRequest();
+            }
+        },
+        COMPARE_AND_SET {
+            @Override
+            Request create() {
+                return new CompareAndSetRequest();
+            }
+        },
+        ADD_AND_GET {
+            @Override
+            Request create() {
+                return new AddAndGetRequest();
+            }
+        },
+        UPDATE {
+            @Override
+            Request create() {
+                return new UpdateRequest();
+            }
+        },
+        RECONCILE {
+            @Override
+            Request create() {
+                return new ReconcileRequest();
+            }
+        },
+        RESEND_PENDING_REQUESTS {
+            @Override
+            Request create() {
+                return new ResendPendingRequests();
+            }
+        };
 
-    protected enum ResponseType {
-        VOID,
-        GET_OR_CREATE,
-        BOOLEAN,
-        VALUE,
-        EXCEPTION,
-        RECONCILE
+        abstract Request create();
     }
 
-    protected static RequestType requestToRequestType(Request req) {
-        if(req instanceof GetOrCreateRequest)    return RequestType.GET_OR_CREATE;
-        if(req instanceof DeleteRequest)         return RequestType.DELETE;
-        if(req instanceof AddAndGetRequest)      return RequestType.ADD_AND_GET;
-        if(req instanceof UpdateRequest)         return RequestType.UPDATE;
-        if(req instanceof SetRequest)            return RequestType.SET;
-        if(req instanceof CompareAndSetRequest)  return RequestType.COMPARE_AND_SET;
-        if(req instanceof ReconcileRequest)      return RequestType.RECONCILE;
-        if(req instanceof ResendPendingRequests) return RequestType.RESEND_PENDING_REQUESTS;
-        throw new IllegalStateException(""request "" + req + "" cannot be mapped to request type"");
-    }
+    protected enum ResponseType {
+        VALUE {
+            @Override
+            Response create() {
+                return new ValueResponse();
+            }
+        },
+        EXCEPTION{
+            @Override
+            Response create() {
+                return new ExceptionResponse();
+            }
+        },
+        RECONCILE {
+            @Override
+            Response create() {
+                return new ReconcileResponse();
+            }
+        };
 
-    protected static ResponseType responseToResponseType(Response rsp) {
-        if(rsp instanceof GetOrCreateResponse) return ResponseType.GET_OR_CREATE;
-        if(rsp instanceof BooleanResponse) return ResponseType.BOOLEAN;
-        if(rsp instanceof ValueResponse) return ResponseType.VALUE;
-        if(rsp instanceof ExceptionResponse) return ResponseType.EXCEPTION;
-        if(rsp instanceof ReconcileResponse) return ResponseType.RECONCILE;
-        if(rsp != null) return ResponseType.VOID;
-        throw new IllegalStateException(""response "" + rsp + "" cannot be mapped to response type"");
+        abstract Response create();
     }
 
-
     public boolean getBypassBundling() {
         return bypass_bundling;
     }
@@ -112,7 +163,6 @@ public COUNTER setBypassBundling(boolean bypass_bundling) {
         return this;
     }
 
-
     @ManagedAttribute
     public String getView() {
         return view != null? view.toString() : null;
@@ -123,26 +173,35 @@ public String getBackupCoords() {
         return backup_coords != null? backup_coords.toString() : ""null"";
     }
 
+    @Override
+    public void init() throws Exception {
+        super.init();
+        transport = getTransport();
+    }
 
+    @Deprecated
     public Counter getOrCreateCounter(String name, long initial_value) {
+        CounterImpl counter = CompletableFutures.join(doGetOrCreateCounter(name, initial_value));
+        return counter.sync;
+    }
+
+    public CompletionStage<AsyncCounter> getOrCreateAsyncCounter(String name, long initial_value) {
+        return doGetOrCreateCounter(name, initial_value).thenApply(Function.identity());
+    }
+
+    private CompletionStage<CounterImpl> doGetOrCreateCounter(String name, long initial_value) {
+        Objects.requireNonNull(name);
         if(local_addr == null)
-            throw new IllegalArgumentException(""the channel needs to be connected before creating or getting a counter"");
+            throw new IllegalStateException(""the channel needs to be connected before creating or getting a counter"");
+        // is it safe?
+        if (counters.containsKey(name)) {
+            // if the counter exists, we do not need to send a request to the coordinator, right?
+            return CompletableFuture.completedFuture(new CounterImpl(name));
+        }
         Owner owner=getOwner();
         GetOrCreateRequest req=new GetOrCreateRequest(owner, name, initial_value);
-        Promise<long[]> promise=new Promise<>();
-        pending_requests.put(owner, new Tuple<>(req, promise));
-        sendRequest(coord, req);
-        long[] result=new long[0];
-        try {
-            result=promise.getResultWithTimeout(timeout);
-            long value=result[0], version=result[1];
-            if(!coord.equals(local_addr))
-                counters.put(name, new VersionedValue(value, version));
-            return new CounterImpl(name);
-        }
-        catch(TimeoutException e) {
-            throw new RuntimeException(e);
-        }
+        CompletableFuture<Long> rsp = sendRequestToCoordinator(owner, req);
+        return rsp.thenApply(aLong -> new CounterImpl(name));
     }
 
     /** Sent asynchronously - we don't wait for an ack */
@@ -154,8 +213,6 @@ public void deleteCounter(String name) {
             counters.remove(name);
     }
 
-
-
     public Object down(Event evt) {
         switch(evt.getType()) {
             case Event.VIEW_CHANGE:
@@ -166,209 +223,70 @@ public Object down(Event evt) {
     }
 
     public Object up(Event evt) {
-        switch(evt.getType()) {
-            case Event.VIEW_CHANGE:
-                handleView(evt.getArg());
-                break;
+        if (evt.getType() == Event.VIEW_CHANGE) {
+            handleView(evt.getArg());
         }
         return up_prot.up(evt);
     }
 
     public Object up(Message msg) {
-        CounterHeader hdr=msg.getHeader(id);
-        if(hdr == null)
+        CounterHeader hdr = msg.getHeader(id);
+        if (hdr == null)
             return up_prot.up(msg);
 
         try {
-            Object obj=streamableFromBuffer(msg.getArray(), msg.getOffset(), msg.getLength());
-            if(log.isTraceEnabled())
-                log.trace(""["" + local_addr + ""] <-- ["" + msg.getSrc() + ""] "" + obj);
-
-            if(obj instanceof Request) {
-                handleRequest((Request)obj, msg.getSrc());
-            }
-            else if(obj instanceof Response) {
-                handleResponse((Response)obj, msg.getSrc());
-            }
-            else {
-                log.error(Util.getMessage(""ReceivedObjectIsNeitherARequestNorAResponse"") + obj);
+            assert msg.hasArray();
+            DataInput in = new DataInputStream(new ByteArrayInputStream(msg.getArray(), msg.getOffset(), msg.getLength()));
+            switch (in.readByte()) {
+                case REQUEST:
+                    Request req = requestFromDataInput(in);
+                    if (log.isTraceEnabled())
+                        log.trace(""["" + local_addr + ""] <-- ["" + msg.getSrc() + ""] "" + req);
+                    req.execute(this, msg.getSrc());
+                    break;
+                case RESPONSE:
+                    Response rsp = responseFromDataInput(in);
+                    if (log.isTraceEnabled())
+                        log.trace(""["" + local_addr + ""] <-- ["" + msg.getSrc() + ""] "" + rsp);
+                    handleResponse(rsp, msg.getSrc());
+                    break;
+                default:
+                    log.error(Util.getMessage(""ReceivedObjectIsNeitherARequestNorAResponse""));
+                    break;
             }
-        }
-        catch(Exception ex) {
+        } catch (Exception ex) {
             log.error(Util.getMessage(""FailedHandlingMessage""), ex);
         }
         return null;
     }
 
-    
-    protected void handleRequest(Request req, Address sender) {
-        RequestType type=requestToRequestType(req);
-        switch(type) {
-            case GET_OR_CREATE:
-                if(!local_addr.equals(coord) || discard_requests)
-                    return;
-                GetOrCreateRequest tmp=(GetOrCreateRequest)req;
-                VersionedValue new_val=new VersionedValue(tmp.initial_value);
-                VersionedValue val=counters.putIfAbsent(tmp.name, new_val);
-                if(val == null)
-                    val=new_val;
-                Response rsp=new GetOrCreateResponse(tmp.owner, val.value, val.version);
-                sendResponse(sender,rsp);
-                if(backup_coords != null)
-                    updateBackups(tmp.name, val.value, val.version);
-                break;
-            case DELETE:
-                if(!local_addr.equals(coord) || discard_requests)
-                    return;
-                counters.remove(((SimpleRequest)req).name);
-                break;
-            case SET:
-                if(!local_addr.equals(coord) || discard_requests)
-                    return;
-                val=counters.get(((SimpleRequest)req).name);
-                if(val == null) {
-                    sendCounterNotFoundExceptionResponse(sender, ((SimpleRequest)req).owner, ((SimpleRequest)req).name);
-                    return;
-                }
-                long[] result=val.set(((SetRequest)req).value);
-                rsp=new ValueResponse(((SimpleRequest)req).owner, result[0], result[1]);
-                sendResponse(sender, rsp);
-                if(backup_coords != null)
-                    updateBackups(((SimpleRequest)req).name, result[0], result[1]);
-                break;
-            case COMPARE_AND_SET:
-                if(!local_addr.equals(coord) || discard_requests)
-                    return;
-                val=counters.get(((SimpleRequest)req).name);
-                if(val == null) {
-                    sendCounterNotFoundExceptionResponse(sender, ((SimpleRequest)req).owner, ((SimpleRequest)req).name);
-                    return;
-                }
-                result=val.compareAndSet(((CompareAndSetRequest)req).expected,((CompareAndSetRequest)req).update);
-                rsp=new ValueResponse(((SimpleRequest)req).owner, result == null? -1 : result[0], result == null? -1 : result[1]);
-                sendResponse(sender, rsp);
-                if(backup_coords != null) {
-                    VersionedValue value=counters.get(((SimpleRequest)req).name);
-                    updateBackups(((SimpleRequest)req).name, value.value, value.version);
-                }
-                break;
-            case ADD_AND_GET:
-                if(!local_addr.equals(coord) || discard_requests)
-                    return;
-                val=counters.get(((SimpleRequest)req).name);
-                if(val == null) {
-                    sendCounterNotFoundExceptionResponse(sender, ((SimpleRequest)req).owner, ((SimpleRequest)req).name);
-                    return;
-                }
-                result=val.addAndGet(((AddAndGetRequest)req).value);
-                rsp=new ValueResponse(((SimpleRequest)req).owner, result[0], result[1]);
-                sendResponse(sender, rsp);
-                if(backup_coords != null)
-                    updateBackups(((SimpleRequest)req).name, result[0], result[1]);
-                break;
-            case UPDATE:
-                String counter_name=((UpdateRequest)req).name;
-                long new_value=((UpdateRequest)req).value, new_version=((UpdateRequest)req).version;
-                VersionedValue current=counters.get(counter_name);
-                if(current == null)
-                    counters.put(counter_name, new VersionedValue(new_value, new_version));
-                else {
-                    current.updateIfBigger(new_value, new_version);
-                }
-                break;
-            case RECONCILE:
-                if(sender.equals(local_addr)) // we don't need to reply to our own reconciliation request
-                    break;
-
-                // return all values except those with lower or same versions than the ones in the ReconcileRequest
-                ReconcileRequest reconcile_req=(ReconcileRequest)req;
-                Map<String,VersionedValue> map=new HashMap<>(counters);
-                if(reconcile_req.names !=  null) {
-                    for(int i=0; i < reconcile_req.names.length; i++) {
-                        counter_name=reconcile_req.names[i];
-                        long version=reconcile_req.versions[i];
-                        VersionedValue my_value=map.get(counter_name);
-                        if(my_value != null && my_value.version <= version)
-                            map.remove(counter_name);
-                    }
-                }
-
-                int len=map.size();
-                String[] names=new String[len];
-                long[] values=new long[len];
-                long[] versions=new long[len];
-                int index=0;
-                for(Map.Entry<String,VersionedValue> entry: map.entrySet()) {
-                    names[index]=entry.getKey();
-                    values[index]=entry.getValue().value;
-                    versions[index]=entry.getValue().version;
-                    index++;
-                }
-
-                rsp=new ReconcileResponse(names, values, versions);
-                sendResponse(sender, rsp);
-                break;
-            case RESEND_PENDING_REQUESTS:
-                for(Tuple<Request,Promise> tuple: pending_requests.values()) {
-                    Request request=tuple.getVal1();
-                    if(log.isTraceEnabled())
-                        log.trace(""["" + local_addr + ""] --> ["" + coord + ""] resending "" + request);
-                    sendRequest(coord, request);
-                }
-                break;
-
-            default:
-                break;
-        }
-    }
-
-
     protected VersionedValue getCounter(String name) {
         VersionedValue val=counters.get(name);
         if(val == null)
             throw new IllegalStateException(""counter \"""" + name + ""\"" not found"");
         return val;
     }
 
-    @SuppressWarnings(""unchecked"")
     protected void handleResponse(Response rsp, Address sender) {
         if(rsp instanceof ReconcileResponse) {
-            if(log.isTraceEnabled() && ((ReconcileResponse)rsp).names != null && ((ReconcileResponse)rsp).names.length > 0)
-                log.trace(""["" + local_addr + ""] <-- ["" + sender + ""] RECONCILE-RSP: "" +
-                            dump(((ReconcileResponse)rsp).names, ((ReconcileResponse)rsp).values, ((ReconcileResponse)rsp).versions));
-            if(reconciliation_task != null)
-                reconciliation_task.add((ReconcileResponse)rsp, sender);
+            handleReconcileResponse((ReconcileResponse) rsp, sender);
             return;
         }
 
-        Tuple<Request,Promise> tuple=pending_requests.remove(((SimpleResponse)rsp).owner);
-        if(tuple == null) {
-            log.warn(""response for "" + ((SimpleResponse)rsp).owner + "" didn't have an entry"");
+        RequestCompletableFuture cf=pending_requests.remove(rsp.getOwner());
+        if(cf == null) {
+            log.warn(""response for "" + rsp.getOwner() + "" didn't have an entry"");
             return;
         }
-        Promise promise=tuple.getVal2();
-        if(rsp instanceof ValueResponse) {
-            ValueResponse tmp=(ValueResponse)rsp;
-            if(tmp.result == -1 && tmp.version == -1)
-                promise.setResult(null);
-            else {
-                long[] result={tmp.result,tmp.version};
-                promise.setResult(result);
-            }
-        }
-        else if(rsp instanceof BooleanResponse)
-            promise.setResult(((BooleanResponse)rsp).result);
-        else if(rsp instanceof ExceptionResponse) {
-            promise.setResult(new Throwable(((ExceptionResponse)rsp).error_message));
-        }
-        else
-            promise.setResult(null);
+        rsp.complete(cf);
     }
 
-
-    
-
-
+    private void handleReconcileResponse(ReconcileResponse rsp, Address sender) {
+        if(log.isTraceEnabled() && rsp.names != null && rsp.names.length > 0)
+            log.trace(""["" + local_addr + ""] <-- ["" + sender + ""] RECONCILE-RSP: "" + dump(rsp.names, rsp.values, rsp.versions));
+        if(reconciliation_task != null)
+            reconciliation_task.add(rsp, sender);
+    }
 
     @ManagedOperation(description=""Dumps all counters"")
     public String printCounters() {
@@ -381,9 +299,9 @@ public String printCounters() {
     @ManagedOperation(description=""Dumps all pending requests"")
     public String dumpPendingRequests() {
         StringBuilder sb=new StringBuilder();
-        for(Tuple<Request,Promise> tuple: pending_requests.values()) {
-            Request tmp=tuple.getVal1();
-            sb.append(tmp + "" ("" + tmp.getClass().getCanonicalName() + "") "");
+        for(RequestCompletableFuture cf: pending_requests.values()) {
+            Request tmp=cf.getRequest();
+            sb.append(tmp).append('(').append(tmp.getClass().getCanonicalName()).append("") "");
         }
         return sb.toString();
     }
@@ -419,22 +337,32 @@ protected void handleView(View view) {
         }
     }
 
-
     protected Owner getOwner() {
-        return new Owner(local_addr, Thread.currentThread().getId());
+        return new Owner(local_addr, REQUEST_ID_GENERATOR.incrementAndGet());
     }
 
+    protected void updateBackups(String name, long[] versionedValue) {
+        if (backup_coords == null || backup_coords.isEmpty()) {
+            return;
+        }
+        Request req=new UpdateRequest(name, versionedValue[0], versionedValue[1]);
+        try {
+            ByteArray buffer=requestToBuffer(req);
+            for(Address dst: backup_coords) {
+                logSending(dst, req);
+                send(dst, buffer);
+            }
+        }
+        catch(Exception ex) {
+            log.error(Util.getMessage(""FailedSending"") + req + "" to backup coordinator(s):"" + ex);
+        }
+    }
 
     protected void sendRequest(Address dest, Request req) {
         try {
             ByteArray buffer=requestToBuffer(req);
-            Message msg=new BytesMessage(dest, buffer).putHeader(id, new CounterHeader());
-            if(bypass_bundling)
-                msg.setFlag(Message.Flag.DONT_BUNDLE);
-            if(log.isTraceEnabled())
-                log.trace(""["" + local_addr + ""] --> ["" + (dest == null? ""ALL"" : dest) + ""] "" + req);
-
-            down_prot.down(msg);
+            logSending(dest, req);
+            send(dest, buffer);
         }
         catch(Exception ex) {
             log.error(Util.getMessage(""FailedSending"") + req + "" request: "" + ex);
@@ -445,34 +373,14 @@ protected void sendRequest(Address dest, Request req) {
     protected void sendResponse(Address dest, Response rsp) {
         try {
             ByteArray buffer=responseToBuffer(rsp);
-            Message rsp_msg=new BytesMessage(dest, buffer).putHeader(id, new CounterHeader());
-            if(bypass_bundling)
-                rsp_msg.setFlag(Message.Flag.DONT_BUNDLE);
-
-            if(log.isTraceEnabled())
-                log.trace(""["" + local_addr + ""] --> ["" + dest + ""] "" + rsp);
-
-            down_prot.down(rsp_msg);
+            logSending(dest, rsp);
+            send(dest, buffer);
         }
         catch(Exception ex) {
             log.error(Util.getMessage(""FailedSending"") + rsp + "" message to "" + dest + "": "" + ex);
         }
     }
 
-    protected void updateBackups(String name, long value, long version) {
-        Request req=new UpdateRequest(name, value, version);
-        try {
-            ByteArray buffer=requestToBuffer(req);
-            if(backup_coords != null && !backup_coords.isEmpty()) {
-                for(Address backup_coord: backup_coords)
-                    send(backup_coord, buffer);
-            }
-        }
-        catch(Exception ex) {
-            log.error(Util.getMessage(""FailedSending"") + req + "" to backup coordinator(s):"" + ex);
-        }
-    }
-
     protected void send(Address dest, ByteArray buffer) {
         try {
             Message rsp_msg=new BytesMessage(dest, buffer).putHeader(id, new CounterHeader());
@@ -485,18 +393,29 @@ protected void send(Address dest, ByteArray buffer) {
         }
     }
 
+    private void logSending(Address dst, Object data) {
+        if(log.isTraceEnabled())
+            log.trace(""["" + local_addr + ""] --> ["" + (dst == null? ""ALL"" : dst) + ""]: "" + data);
+    }
+
     protected void sendCounterNotFoundExceptionResponse(Address dest, Owner owner, String counter_name) {
         Response rsp=new ExceptionResponse(owner, ""counter \"""" + counter_name + ""\"" not found"");
         sendResponse(dest, rsp);
     }
 
+    private long updateCounter(ResponseData responseData) {
+        if(!coord.equals(local_addr)) {
+            counters.compute(responseData.counterName, responseData);
+        }
+        return responseData.value;
+    }
 
     protected static ByteArray requestToBuffer(Request req) throws Exception {
-        return streamableToBuffer(REQUEST,(byte)requestToRequestType(req).ordinal(), req);
+        return streamableToBuffer(REQUEST,(byte)req.getRequestType().ordinal(), req);
     }
 
     protected static ByteArray responseToBuffer(Response rsp) throws Exception {
-        return streamableToBuffer(RESPONSE,(byte)responseToResponseType(rsp).ordinal(), rsp);
+        return streamableToBuffer(RESPONSE,(byte)rsp.getResponseType().ordinal(), rsp);
     }
 
     protected static ByteArray streamableToBuffer(byte req_or_rsp, byte type, Streamable obj) throws Exception {
@@ -508,66 +427,22 @@ protected static ByteArray streamableToBuffer(byte req_or_rsp, byte type, Stream
         return new ByteArray(out.buffer(), 0, out.position());
     }
 
-    protected static Streamable streamableFromBuffer(byte[] buf, int offset, int length) throws Exception {
-        switch(buf[offset]) {
-            case REQUEST:
-                return requestFromBuffer(buf, offset+1, length-1);
-            case RESPONSE:
-                return responseFromBuffer(buf, offset+1, length-1);
-            default:
-                throw new IllegalArgumentException(""type "" + buf[offset] + "" is invalid (expected Request (1) or RESPONSE (2)"");
-        }
-    }
-
-    protected static final Request requestFromBuffer(byte[] buf, int offset, int length) throws Exception {
-        ByteArrayInputStream input=new ByteArrayInputStream(buf, offset, length);
-        DataInputStream in=new DataInputStream(input);
-        RequestType type=RequestType.values()[in.readByte()];
-        Request retval=createRequest(type);
+    protected static Request requestFromDataInput(DataInput in) throws Exception {
+        Request retval=REQUEST_TYPES_CACHED[in.readByte()].create();
         retval.readFrom(in);
         return retval;
     }
 
-    protected static Request createRequest(RequestType type) {
-        switch(type) {
-            case COMPARE_AND_SET:         return new CompareAndSetRequest();
-            case ADD_AND_GET:             return new AddAndGetRequest();
-            case UPDATE:                  return new UpdateRequest();
-            case GET_OR_CREATE:           return new GetOrCreateRequest();
-            case DELETE:                  return new DeleteRequest();
-            case SET:                     return new SetRequest();
-            case RECONCILE:               return new ReconcileRequest();
-            case RESEND_PENDING_REQUESTS: return new ResendPendingRequests();
-            default:                      throw new IllegalArgumentException(""failed creating a request from "" + type);
-        }
-    }
-
-    protected static final Response responseFromBuffer(byte[] buf, int offset, int length) throws Exception {
-        ByteArrayInputStream input=new ByteArrayInputStream(buf, offset, length);
-        DataInputStream in=new DataInputStream(input);
-        ResponseType type=ResponseType.values()[in.readByte()];
-        Response retval=createResponse(type);
+    protected static Response responseFromDataInput(DataInput in) throws Exception {
+        Response retval=RESPONSE_TYPES_CACHED[in.readByte()].create();
         retval.readFrom(in);
         return retval;
     }
 
-    protected static Response createResponse(ResponseType type) {
-        switch(type) {
-            case VOID:          return new SimpleResponse();
-            case GET_OR_CREATE: return new GetOrCreateResponse();
-            case BOOLEAN:       return new BooleanResponse();
-            case VALUE:         return new ValueResponse();
-            case EXCEPTION:     return new ExceptionResponse();
-            case RECONCILE:     return new ReconcileResponse();
-            default:            throw new IllegalArgumentException(""failed creating a response from "" + type);
-        }
-    }
-
-
     protected synchronized void startReconciliationTask() {
         if(reconciliation_task_future == null || reconciliation_task_future.isDone()) {
             reconciliation_task=new ReconciliationTask();
-            reconciliation_task_future=getTransport().getTimer().schedule(reconciliation_task, 0, TimeUnit.MILLISECONDS);
+            reconciliation_task_future=transport.getTimer().schedule(reconciliation_task, 0, TimeUnit.MILLISECONDS);
         }
     }
 
@@ -620,121 +495,61 @@ protected static String dump(String[] names, long[] values, long[] versions) {
     }
 
 
-    protected class CounterImpl implements Counter {
+    protected class CounterImpl implements AsyncCounter {
         protected final String  name;
+        final SyncCounterImpl sync;
 
         protected CounterImpl(String name) {
             this.name = name;
+            this.sync = new SyncCounterImpl(this);
         }
 
         public String getName() {
             return name;
         }
 
         @Override
-        public long get() {
-            return addAndGet(0);
-        }
-
-        @Override
-        public void set(long new_value) {
+        public CompletableFuture<Void> set(long new_value) {
             if(local_addr.equals(coord)) {
                 VersionedValue val=getCounter(name);
-                val.set(new_value);
-                if(backup_coords != null)
-                    updateBackups(name, val.value, val.version);
-                return;
+                long[] result = val.set(new_value);
+                updateBackups(name, result);
+                return CompletableFutures.completedNull();
             }
             Owner owner=getOwner();
             Request req=new SetRequest(owner, name, new_value);
-            Promise<long[]> promise=new Promise<>();
-            pending_requests.put(owner, new Tuple<>(req, promise));
-            sendRequest(coord, req);
-            Object obj=null;
-            try {
-                obj=promise.getResultWithTimeout(timeout);
-                if(obj instanceof Throwable)
-                    throw new IllegalStateException((Throwable)obj);
-                long[] result=(long[])obj;
-                long value=result[0], version=result[1];
-                if(!coord.equals(local_addr))
-                    counters.put(name, new VersionedValue(value, version));
-            }
-            catch(TimeoutException e) {
-                throw new RuntimeException(e);
-            }
+            return sendRequestToCoordinator(owner, req).thenAccept(CompletableFutures.voidConsumer());
         }
 
         @Override
-        public boolean compareAndSet(long expect, long update) {
+        public CompletableFuture<Long> compareAndSwap(long expect, long update) {
             if(local_addr.equals(coord)) {
                 VersionedValue val=getCounter(name);
-                boolean retval=val.compareAndSet(expect, update) != null;
-                if(backup_coords != null)
-                    updateBackups(name, val.value, val.version);
-                return retval;
+                long retval=val.compareAndSwap(expect, update)[0];
+                updateBackups(name, val.snapshot());
+                return CompletableFuture.completedFuture(retval);
             }
             Owner owner=getOwner();
             Request req=new CompareAndSetRequest(owner, name, expect, update);
-            Promise<long[]> promise=new Promise<>();
-            pending_requests.put(owner, new Tuple<>(req, promise));
-            sendRequest(coord, req);
-            Object obj=null;
-            try {
-                obj=promise.getResultWithTimeout(timeout);
-                if(obj instanceof Throwable)
-                    throw new IllegalStateException((Throwable)obj);
-                if(obj == null)
-                    return false;
-                long[] result=(long[])obj;
-                long value=result[0], version=result[1];
-                if(!coord.equals(local_addr))
-                    counters.put(name, new VersionedValue(value, version));
-                return true;
-            }
-            catch(TimeoutException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public long incrementAndGet() {
-            return addAndGet(1);
+            return sendRequestToCoordinator(owner, req);
         }
 
         @Override
-        public long decrementAndGet() {
-            return addAndGet(-1);
-        }
-
-        @Override
-        public long addAndGet(long delta) {
+        public CompletableFuture<Long> addAndGet(long delta) {
             if(local_addr.equals(coord)) {
                 VersionedValue val=getCounter(name);
-                long retval=val.addAndGet(delta)[0];
-                if(backup_coords != null)
-                    updateBackups(name, val.value, val.version);
-                return retval;
+                long[] result=val.addAndGet(delta);
+                updateBackups(name, result);
+                return CompletableFuture.completedFuture(result[0]);
             }
             Owner owner=getOwner();
             Request req=new AddAndGetRequest(owner, name, delta);
-            Promise<long[]> promise=new Promise<>();
-            pending_requests.put(owner, new Tuple<>(req, promise));
-            sendRequest(coord, req);
-            Object obj=null;
-            try {
-                obj=promise.getResultWithTimeout(timeout);
-                if(obj instanceof Throwable)
-                    throw new IllegalStateException((Throwable)obj);
-                long[] result=(long[])obj;
-                long value=result[0], version=result[1];
-                if(!coord.equals(local_addr))
-                    counters.put(name, new VersionedValue(value, version));
-                return value;
-            }
-            catch(TimeoutException e) {
-                throw new RuntimeException(e);
-            }
+            return sendRequestToCoordinator(owner, req);
+        }
+
+        @Override
+        public SyncCounter sync() {
+            return sync;
         }
 
         @Override
@@ -744,15 +559,67 @@ public String toString() {
         }
     }
 
+    private static class SyncCounterImpl implements Counter {
+
+        private final AsyncCounter counter;
+
+        private SyncCounterImpl(AsyncCounter counter) {
+            this.counter = counter;
+        }
+
+        @Override
+        public String getName() {
+            return counter.getName();
+        }
+
+        @Override
+        public long get() {
+            return CompletableFutures.join(counter.get());
+        }
 
+        @Override
+        public void set(long new_value) {
+            CompletableFutures.join(counter.set(new_value));
+        }
 
+        @Override
+        public long compareAndSwap(long expect, long update) {
+            return CompletableFutures.join(counter.compareAndSwap(expect, update));
+        }
+
+        @Override
+        public long addAndGet(long delta) {
+            return CompletableFutures.join(counter.addAndGet(delta));
+        }
+
+        @Override
+        public AsyncCounter async() {
+            return counter;
+        }
+    }
+
+    private CompletableFuture<Long> sendRequestToCoordinator(Owner owner, Request request) {
+        RequestCompletableFuture cf = new RequestCompletableFuture(request);
+        pending_requests.put(owner, cf);
+        sendRequest(coord, request);
+        return cf.orTimeout(timeout, TimeUnit.MILLISECONDS).thenApply(this::updateCounter);
+    }
+
+    private boolean skipRequest() {
+        return !local_addr.equals(coord) || discard_requests;
+    }
 
     protected interface Request extends Streamable {
 
+        String getCounterName();
+
+        RequestType getRequestType();
+
+        void execute(COUNTER protocol, Address sender);
     }
 
 
-    protected static class SimpleRequest implements Request {
+    protected abstract static class SimpleRequest implements Request {
         protected Owner   owner;
         protected String  name;
 
@@ -781,6 +648,11 @@ public void readFrom(DataInput in) throws IOException, ClassNotFoundException {
         public String toString() {
             return owner + "" ["" + name + ""]"";
         }
+
+        @Override
+        public String getCounterName() {
+            return name;
+        }
     }
 
     protected static class ResendPendingRequests implements Request {
@@ -789,6 +661,30 @@ public void writeTo(DataOutput out) throws IOException {}
         @Override
         public void readFrom(DataInput in) throws IOException {}
         public String toString() {return ""ResendPendingRequests"";}
+
+        @Override
+        public String getCounterName() {
+            return null;
+        }
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.RESEND_PENDING_REQUESTS;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            for(RequestCompletableFuture cf : protocol.pending_requests.values()) {
+                Request request=cf.getRequest();
+                protocol.traceResending(request);
+                protocol.sendRequest(protocol.coord, request);
+            }
+        }
+    }
+
+    private void traceResending(Request request) {
+        if(log.isTraceEnabled())
+            log.trace(""["" + local_addr + ""] --> ["" + coord + ""] resending "" + request);
     }
 
     protected static class GetOrCreateRequest extends SimpleRequest {
@@ -812,6 +708,24 @@ public void writeTo(DataOutput out) throws IOException {
             super.writeTo(out);
             Bits.writeLongCompressed(initial_value, out);
         }
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.GET_OR_CREATE;
+        }
+
+        public void execute(COUNTER protocol, Address sender) {
+            if(protocol.skipRequest())
+                return;
+            VersionedValue new_val=new VersionedValue(initial_value);
+            VersionedValue val=protocol.counters.putIfAbsent(name, new_val);
+            if(val == null)
+                val=new_val;
+            long[] result = val.snapshot();
+            Response rsp=new ValueResponse(owner, result);
+            protocol.sendResponse(sender,rsp);
+            protocol.updateBackups(name, result);
+        }
     }
 
 
@@ -824,6 +738,18 @@ protected DeleteRequest(Owner owner, String name) {
         }
 
         public String toString() {return ""DeleteRequest: "" + super.toString();}
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.DELETE;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            if(protocol.skipRequest())
+                return;
+            protocol.counters.remove(name);
+        }
     }
 
 
@@ -835,6 +761,29 @@ protected AddAndGetRequest(Owner owner, String name, long value) {
         }
 
         public String toString() {return ""AddAndGetRequest: "" + super.toString();}
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.ADD_AND_GET;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            if(protocol.skipRequest())
+                return;
+            VersionedValue val=protocol.counters.get(name);
+            if(val == null) {
+                protocol.sendCounterNotFoundExceptionResponse(sender, owner, name);
+                return;
+            }
+            long[] result=val.addAndGet(value);
+            Response rsp=new ValueResponse(owner, result);
+            protocol.sendResponse(sender, rsp);
+            if (value != 0) {
+                // value == 0 means it is a counter.get(); no backup update is required.
+                protocol.updateBackups(name, result);
+            }
+        }
     }
 
 
@@ -862,6 +811,26 @@ public void writeTo(DataOutput out) throws IOException {
         }
 
         public String toString() {return super.toString() + "": "" + value;}
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.SET;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            if(protocol.skipRequest())
+                return;
+            VersionedValue val=protocol.counters.get(name);
+            if(val == null) {
+                protocol.sendCounterNotFoundExceptionResponse(sender, owner, name);
+                return;
+            }
+            long[] result=val.set(value);
+            Response rsp=new ValueResponse(owner, result);
+            protocol.sendResponse(sender, rsp);
+            protocol.updateBackups(name, result);
+        }
     }
 
 
@@ -891,6 +860,26 @@ public void writeTo(DataOutput out) throws IOException {
         }
 
         public String toString() {return super.toString() + "", expected="" + expected + "", update="" + update;}
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.COMPARE_AND_SET;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            if(protocol.skipRequest())
+                return;
+            VersionedValue val=protocol.counters.get(name);
+            if(val == null) {
+                protocol.sendCounterNotFoundExceptionResponse(sender, owner, name);
+                return;
+            }
+            long[] result=val.compareAndSwap(expected, update);
+            Response rsp=new ValueResponse(owner, result);
+            protocol.sendResponse(sender, rsp);
+            protocol.updateBackups(name, val.snapshot());
+        }
     }
 
 
@@ -921,10 +910,53 @@ public void readFrom(DataInput in) throws IOException {
         }
 
         public String toString() {return ""ReconcileRequest ("" + names.length + "") entries"";}
+
+        @Override
+        public String getCounterName() {
+            return null;
+        }
+
+        @Override
+        public RequestType getRequestType() {
+            return RequestType.RECONCILE;
+        }
+
+        @Override
+        public void execute(COUNTER protocol, Address sender) {
+            if(sender.equals(protocol.local_addr)) // we don't need to reply to our own reconciliation request
+                return;
+
+            // return all values except those with lower or same versions than the ones in the ReconcileRequest
+            Map<String,VersionedValue> map=new HashMap<>(protocol.counters);
+            if(names !=  null) {
+                for(int i=0; i < names.length; i++) {
+                    String counter_name=names[i];
+                    long version=versions[i];
+                    VersionedValue my_value=map.get(counter_name);
+                    if(my_value != null && my_value.version <= version)
+                        map.remove(counter_name);
+                }
+            }
+
+            int len=map.size();
+            String[] names=new String[len];
+            long[] values=new long[len];
+            long[] versions=new long[len];
+            int index=0;
+            for(Map.Entry<String,VersionedValue> entry: map.entrySet()) {
+                names[index]=entry.getKey();
+                values[index]=entry.getValue().value;
+                versions[index]=entry.getValue().version;
+                index++;
+            }
+
+            Response rsp=new ReconcileResponse(names, values, versions);
+            protocol.sendResponse(sender, rsp);
+        }
     }
 
 
-    protected static class UpdateRequest implements Request {
+    protected static class UpdateRequest implements Request, BiFunction<String, VersionedValue, VersionedValue> {
         protected String name;
         protected long   value;
         protected long   version;
@@ -952,111 +984,115 @@ public void readFrom(DataInput in) throws IOException {
         }
 
         public String toString() {return ""UpdateRequest("" + name + "": ""+ value + "" ("" + version + "")"";}
-    }
-
-
-
-    protected interface Response extends Streamable {}
-
-    
-    /** Response without data */
-    protected static class SimpleResponse implements Response {
-        protected Owner owner;
-        protected long  version;
-
-        protected SimpleResponse() {}
 
-        protected SimpleResponse(Owner owner, long version) {
-            this.owner=owner;
-            this.version=version;
+        @Override
+        public String getCounterName() {
+            return name;
         }
 
         @Override
-        public void readFrom(DataInput in) throws IOException, ClassNotFoundException {
-            owner=new Owner();
-            owner.readFrom(in);
-            version=Bits.readLongCompressed(in);
+        public RequestType getRequestType() {
+            return RequestType.UPDATE;
         }
 
         @Override
-        public void writeTo(DataOutput out) throws IOException {
-            owner.writeTo(out);
-            Bits.writeLongCompressed(version, out);
+        public void execute(COUNTER protocol, Address sender) {
+            protocol.counters.compute(name, this);
         }
 
-        public String toString() {return ""Response"";}
+        @Override
+        public VersionedValue apply(String name, VersionedValue versionedValue) {
+            if (versionedValue == null) {
+                versionedValue = new VersionedValue(value, version);
+            } else {
+                versionedValue.updateIfBigger(value, version);
+            }
+            return versionedValue;
+        }
     }
 
+    private static abstract class Response implements Streamable {
 
-    protected static class BooleanResponse extends SimpleResponse {
-        protected boolean result;
+        private Owner owner;
 
-        protected BooleanResponse() {}
+        Response() {}
 
-        protected BooleanResponse(Owner owner, long version, boolean result) {
-            super(owner, version);
-            this.result=result;
+        Response(Owner owner) {
+            this.owner = owner;
         }
 
-        @Override
-        public void readFrom(DataInput in) throws IOException, ClassNotFoundException {
-            super.readFrom(in);
-            result=in.readBoolean();
+        abstract ResponseType getResponseType();
+
+        abstract void complete(RequestCompletableFuture completableFuture);
+
+        final Owner getOwner() {
+            return owner;
         }
 
         @Override
         public void writeTo(DataOutput out) throws IOException {
-            super.writeTo(out);
-            out.writeBoolean(result);
+            owner.writeTo(out);
         }
 
-        public String toString() {return ""BooleanResponse("" + result + "")"";}
+        @Override
+        public void readFrom(DataInput in) throws IOException, ClassNotFoundException {
+            owner = new Owner();
+            owner.readFrom(in);
+        }
     }
 
-    protected static class ValueResponse extends SimpleResponse {
+
+    protected static class ValueResponse extends Response {
         protected long result;
+        protected long version;
 
         protected ValueResponse() {}
 
+        ValueResponse(Owner owner, long[] versionedValue) {
+            this(owner, versionedValue[0], versionedValue[1]);
+        }
+
         protected ValueResponse(Owner owner, long result, long version) {
-            super(owner, version);
+            super(owner);
             this.result=result;
+            this.version=version;
         }
 
         @Override
         public void readFrom(DataInput in) throws IOException, ClassNotFoundException {
             super.readFrom(in);
             result=Bits.readLongCompressed(in);
+            version=Bits.readLongCompressed(in);
         }
 
         @Override
         public void writeTo(DataOutput out) throws IOException {
             super.writeTo(out);
             Bits.writeLongCompressed(result, out);
+            Bits.writeLongCompressed(version, out);
         }
 
         public String toString() {return ""ValueResponse("" + result + "")"";}
-    }
-
-
-    protected static class GetOrCreateResponse extends ValueResponse {
 
-        protected GetOrCreateResponse() {}
-
-        protected GetOrCreateResponse(Owner owner, long result, long version) {
-            super(owner,result, version);
+        @Override
+        public ResponseType getResponseType() {
+            return ResponseType.VALUE;
         }
 
-        public String toString() {return ""GetOrCreateResponse("" + result + "")"";}
+        @Override
+        void complete(RequestCompletableFuture cf) {
+            cf.requestCompleted(result, version);
+        }
     }
 
-    protected static class ExceptionResponse extends SimpleResponse {
+
+    protected static class ExceptionResponse extends Response {
         protected String error_message;
 
         protected ExceptionResponse() {}
 
         protected ExceptionResponse(Owner owner, String error_message) {
-            super(owner, 0);
+            super(owner);
             this.error_message=error_message;
         }
 
@@ -1073,11 +1109,19 @@ public void writeTo(DataOutput out) throws IOException {
         }
 
         public String toString() {return ""ExceptionResponse: "" + super.toString();}
-    }
 
+        @Override
+        public ResponseType getResponseType() {
+            return ResponseType.EXCEPTION;
+        }
 
-    
-    protected static class ReconcileResponse implements Response {
+        @Override
+        void complete(RequestCompletableFuture cf) {
+            cf.requestFailed(error_message);
+        }
+    }
+
+    protected static class ReconcileResponse extends Response {
         protected String[] names;
         protected long[]   values;
         protected long[]   versions;
@@ -1107,8 +1151,18 @@ public String toString() {
             int num=names != null? names.length : 0;
             return ""ReconcileResponse ("" + num + "") entries"";
         }
+
+        @Override
+        public ResponseType getResponseType() {
+            return ResponseType.RECONCILE;
+        }
+
+        @Override
+        void complete(RequestCompletableFuture cf) {
+            //no-op
+        }
     }
-    
+
 
 
     public static class CounterHeader extends Header {
@@ -1121,7 +1175,7 @@ public void writeTo(DataOutput out) {}
         @Override
         public void readFrom(DataInput in) {}
     }
-    
+
 
     protected static class VersionedValue {
         protected long value;
@@ -1145,10 +1199,13 @@ protected synchronized long[] set(long value) {
             return new long[]{this.value=value,++version};
         }
 
-        protected synchronized long[] compareAndSet(long expected, long update) {
-            if(value == expected)
-                return new long[]{value=update, ++version};
-            return null;
+        protected synchronized long[] compareAndSwap(long expected, long update) {
+            long oldValue = value;
+            if (oldValue == expected) {
+                value = update;
+                ++version;
+            }
+            return new long[]{oldValue, version};
         }
 
         /** Sets the value only if the version argument is greater than the own version */
@@ -1159,6 +1216,10 @@ protected synchronized void updateIfBigger(long value, long version) {
             }
         }
 
+        synchronized long[] snapshot() {
+            return new long[] {value, version};
+        }
+
         public String toString() {return value + "" (version="" + version + "")"";}
     }
 
@@ -1204,20 +1265,19 @@ protected void _run() {
                 if(entry.getKey().equals(local_addr))
                     continue;
                 ReconcileResponse rsp=entry.getValue();
-                if(rsp != null && rsp.names != null) {
-                    for(int i=0; i < rsp.names.length; i++) {
-                        String counter_name=rsp.names[i];
-                        long version=rsp.versions[i];
-                        long value=rsp.values[i];
-                        VersionedValue my_value=counters.get(counter_name);
-                        if(my_value == null) {
-                            counters.put(counter_name, new VersionedValue(value, version));
-                            continue;
-                        }
-                            
-                        if(my_value.version < version)
-                            my_value.updateIfBigger(value, version);
+                if (rsp == null || rsp.names == null) {
+                    continue;
+                }
+                for(int i=0; i < rsp.names.length; i++) {
+                    String counter_name=rsp.names[i];
+                    long version=rsp.versions[i];
+                    long value=rsp.values[i];
+                    VersionedValue my_value=counters.get(counter_name);
+                    if(my_value == null) {
+                        counters.put(counter_name, new VersionedValue(value, version));
+                        continue;
                     }
+                    my_value.updateIfBigger(value, version);
                 }
             }
         }
@@ -1238,4 +1298,49 @@ public String toString() {
         }
     }
 
+    private static class RequestCompletableFuture extends CompletableFuture<ResponseData> {
+
+        private final Request request;
+
+        private RequestCompletableFuture(Request request) {
+            this.request = request;
+        }
+
+        Request getRequest() {
+            return request;
+        }
+
+        void requestCompleted(long value, long version) {
+            this.complete(new ResponseData(request.getCounterName(), value, version));
+        }
+
+        void requestFailed(String errorMessage) {
+            this.completeExceptionally(new Throwable(errorMessage));
+        }
+    }
+
+    private static class ResponseData implements BiFunction<String, VersionedValue, VersionedValue> {
+        private final String counterName;
+        private final long value;
+        private final long version;
+
+        private ResponseData(String counterName, long value, long version) {
+            this.counterName = counterName;
+            this.value = value;
+            this.version = version;
+        }
+
+        /**
+         * Updates the VersionedValue if the version is bigger.
+         */
+        @Override
+        public VersionedValue apply(String s, VersionedValue versionedValue) {
+            if (versionedValue == null) {
+                versionedValue = new VersionedValue(value, version);
+            } else {
+                versionedValue.updateIfBigger(value, version);
+            }
+            return versionedValue;
+        }
+    }
 }",2022-04-28T17:08:39Z,8
"@@ -0,0 +1,70 @@
+package org.jgroups.util;
+
+import java.util.concurrent.*;
+import java.util.function.Consumer;
+
+/**
+ * Utility class with {@link CompletableFuture} and {@link CompletionStage} useful methods.
+ *
+ * @author Pedro Ruivo
+ * @since 5.2
+ */
+public enum CompletableFutures {
+    INSTANCE;
+
+    private static final CompletableFuture<?> NULL = CompletableFuture.completedFuture(null);
+    private static final Consumer<?> VOID_CONSUMER = o -> {
+    };
+
+    /**
+     * Same as {@link #join(CompletableFuture)} but it receives a {@link CompletionStage} as parameter.
+     *
+     * @see #join(CompletableFuture)
+     */
+    public static <T> T join(CompletionStage<T> cs) {
+        return join(cs.toCompletableFuture());
+    }
+
+    /**
+     * Waits for the {@link CompletableFuture} to complete.
+     * <p>
+     * Any non {@link RuntimeException} thrown is converted to a {@link RuntimeException}.
+     *
+     * @param cf  The {@link CompletableFuture}
+     * @param <T> The value type.
+     * @return The value of the completed {@link CompletableFuture}.
+     */
+    public static <T> T join(CompletableFuture<T> cf) {
+        try {
+            return cf.join();
+        } catch (CompletionException e) {
+            if (e.getCause() instanceof RuntimeException) {
+                throw (RuntimeException) e.getCause();
+            }
+            throw new RuntimeException(e.getCause());
+        }
+    }
+
+    /**
+     * A {@code null} completed {@link CompletableFuture}.
+     *
+     * @param <T> The value type.
+     * @return The {@link  CompletableFuture}.
+     */
+    public static <T> CompletableFuture<T> completedNull() {
+        //noinspection unchecked
+        return (CompletableFuture<T>) NULL;
+    }
+
+    /**
+     * Consumes any value and return a {@link Void}.
+     *
+     * @param <T> The value type.
+     * @return The {@link  Consumer}.
+     */
+    public static <T> Consumer<T> voidConsumer() {
+        //noinspection unchecked
+        return (Consumer<T>) VOID_CONSUMER;
+    }
+
+}",2022-04-28T17:08:39Z,9
"@@ -30,6 +30,7 @@ public class Global {
     public static final String BIND_ADDR=""jgroups.bind_addr"";
     public static final String EXTERNAL_ADDR=""jgroups.external_addr"";
     public static final String EXTERNAL_PORT=""jgroups.external_port"";
+    public static final String TCP_CLIENT_BIND_ADDR=""jgroups.tcp.client_bind_addr"";
 
     public static final String BIND_INTERFACE=""jgroups.bind_interface"";
     public static final String IGNORE_BIND_ADDRESS_PROPERTY=""jgroups.ignore.bind_addr"";",2012-12-13T10:28:10Z,10
"@@ -22,23 +22,25 @@
 
 public class TCPConnectionMap {
 
-    private final Mapper mapper;
-    private final InetAddress bind_addr;
-    private final Address local_addr; // bind_addr + port of srv_sock
-    private final ServerSocket srv_sock;
-    private Receiver receiver;
-    private final long conn_expire_time;
-    private final Log log=LogFactory.getLog(getClass());
-    private int recv_buf_size=120000;
-    private int send_buf_size=60000;
-    private int send_queue_size = 0;
-    private int sock_conn_timeout=1000; // max time in millis to wait for Socket.connect() to return    
-    private boolean tcp_nodelay=false;
-    private int linger=-1;    
-    private final Thread acceptor;
-    private final AtomicBoolean running = new AtomicBoolean(false);
-    private volatile boolean use_send_queues=false;
-    protected SocketFactory socket_factory=new DefaultSocketFactory();
+    protected final Mapper        mapper;
+    protected final InetAddress   bind_addr;
+    protected InetAddress         client_bind_addr;
+    protected int                 client_bind_port;
+    protected final Address       local_addr; // bind_addr + port of srv_sock
+    protected final ServerSocket  srv_sock;
+    protected Receiver            receiver;
+    protected final long          conn_expire_time;
+    protected final Log           log=LogFactory.getLog(getClass());
+    protected int                 recv_buf_size=120000;
+    protected int                 send_buf_size=60000;
+    protected int                 send_queue_size = 0;
+    protected int                 sock_conn_timeout=1000; // max time in millis to wait for Socket.connect() to return    
+    protected boolean             tcp_nodelay=false;
+    protected int                 linger=-1;    
+    protected final Thread        acceptor;
+    protected final AtomicBoolean running = new AtomicBoolean(false);
+    protected volatile boolean    use_send_queues=false;
+    protected SocketFactory       socket_factory=new DefaultSocketFactory();
 
 
     public TCPConnectionMap(String service_name,
@@ -102,25 +104,15 @@ else if(bind_addr != null)
         acceptor=f.newThread(new ConnectionAcceptor(),""ConnectionMap.Acceptor"");
     }
     
-    public Address getLocalAddress() {       
-        return local_addr;
-    }
-
-    public Receiver getReceiver() {
-        return receiver;
-    }
-
-    public void setReceiver(Receiver receiver) {
-        this.receiver=receiver;
-    }
-
-    public SocketFactory getSocketFactory() {
-        return socket_factory;
-    }
-
-    public void setSocketFactory(SocketFactory socket_factory) {
-        this.socket_factory=socket_factory;
-    }
+    public Address          getLocalAddress()                       {return local_addr;}
+    public Receiver         getReceiver()                           {return receiver;}
+    public void             setReceiver(Receiver receiver)          {this.receiver=receiver;}
+    public SocketFactory    getSocketFactory()                      {return socket_factory;}
+    public void             setSocketFactory(SocketFactory factory) {this.socket_factory=factory;}
+    public InetAddress      clientBindAddress()                     {return client_bind_addr;}
+    public TCPConnectionMap clientBindAddress(InetAddress addr)     {this.client_bind_addr=addr; return this;}
+    public int              clientBindPort()                        {return client_bind_port;}
+    public TCPConnectionMap clientBindPort(int port)                {this.client_bind_port=port; return this;}
 
     public void addConnectionMapListener(AbstractConnectionMap.ConnectionMapListener<TCPConnection> l) {
         mapper.addConnectionMapListener(l);
@@ -198,7 +190,7 @@ public void stop() {
 
 
     
-    private void setSocketParameters(Socket client_sock) throws SocketException {
+    protected void setSocketParameters(Socket client_sock) throws SocketException {
         try {
             client_sock.setSendBufferSize(send_buf_size);
         }
@@ -227,7 +219,7 @@ public interface Receiver {
         void receive(Address sender, byte[] data, int offset, int length);
     }
 
-    private class ConnectionAcceptor implements Runnable {
+    protected class ConnectionAcceptor implements Runnable {
 
         /**
          * Acceptor thread. Continuously accept new connections. Create a new
@@ -353,26 +345,26 @@ public String toString() {
     
     public class TCPConnection implements Connection {
 
-        private final Socket sock; // socket to/from peer (result of srv_sock.accept() or new Socket())
-        private final Lock send_lock=new ReentrantLock(); // serialize send()        
-        private final Log log=LogFactory.getLog(getClass());        
-        private final byte[] cookie= { 'b', 'e', 'l', 'a' };  
-        private final DataOutputStream out;
-        private final DataInputStream in;    
-        private final Address peer_addr; // address of the 'other end' of the connection
-        private final int peer_addr_read_timeout=2000; // max time in milliseconds to block on reading peer address
-        private long last_access=System.currentTimeMillis(); // last time a message was sent or received           
-        private Sender sender;
-        private ConnectionPeerReceiver connectionPeerReceiver;
-        private final AtomicBoolean active=new AtomicBoolean(false);
+        protected final Socket sock; // socket to/from peer (result of srv_sock.accept() or new Socket())
+        protected final Lock send_lock=new ReentrantLock(); // serialize send()        
+        protected final Log log=LogFactory.getLog(getClass());        
+        protected final byte[] cookie= { 'b', 'e', 'l', 'a' };  
+        protected final DataOutputStream out;
+        protected final DataInputStream in;    
+        protected final Address peer_addr; // address of the 'other end' of the connection
+        protected final int peer_addr_read_timeout=2000; // max time in milliseconds to block on reading peer address
+        protected long last_access=System.currentTimeMillis(); // last time a message was sent or received           
+        protected Sender sender;
+        protected ConnectionPeerReceiver connectionPeerReceiver;
+        protected final AtomicBoolean active=new AtomicBoolean(false);
 
         TCPConnection(Address peer_addr) throws Exception {
             if(peer_addr == null)
                 throw new IllegalArgumentException(""Invalid parameter peer_addr=""+ peer_addr);           
             SocketAddress destAddr=new InetSocketAddress(((IpAddress)peer_addr).getIpAddress(),((IpAddress)peer_addr).getPort());
             this.sock=socket_factory.createSocket(""jgroups.tcp.sock"");
             try {
-                this.sock.bind(new InetSocketAddress(bind_addr, 0));
+                this.sock.bind(new InetSocketAddress(client_bind_addr, client_bind_port));
                 if(this.sock.getLocalSocketAddress().equals(destAddr))
                     throw new IllegalStateException(""socket's bind and connect address are the same: "" + destAddr);
                 Util.connect(this.sock, destAddr, sock_conn_timeout);
@@ -398,15 +390,15 @@ public class TCPConnection implements Connection {
             this.sock=s;
         }  
         
-        private Address getPeerAddress() {
+        protected Address getPeerAddress() {
             return peer_addr;
         }
 
-        private void updateLastAccessed() {
+        protected void updateLastAccessed() {
             last_access=System.currentTimeMillis();
         }
 
-        private void start(ThreadFactory f) {
+        protected void start(ThreadFactory f) {
             //only start once....
             if(active.compareAndSet(false, true)) {
                 connectionPeerReceiver = new ConnectionPeerReceiver(f);            
@@ -419,11 +411,11 @@ private void start(ThreadFactory f) {
             }
         }
         
-        private boolean isSenderUsed(){
+        protected boolean isSenderUsed(){
             return getSenderQueueSize() > 0 && use_send_queues;
         }
 
-        private String getSockAddress() {
+        protected String getSockAddress() {
             StringBuilder sb=new StringBuilder();
             if(sock != null) {
                 sb.append(sock.getLocalAddress().getHostAddress())
@@ -445,7 +437,7 @@ private String getSockAddress() {
          * @param offset
          * @param length
          */
-        private void send(byte[] data, int offset, int length) throws Exception {
+        protected void send(byte[] data, int offset, int length) throws Exception {
             if (isSenderUsed()) {
                 // we need to copy the byte[] buffer here because the original buffer might get
                 // changed meanwhile
@@ -466,7 +458,7 @@ private void send(byte[] data, int offset, int length) throws Exception {
          * @param acquire_lock
          * @throws Exception 
          */
-        private void _send(byte[] data, int offset, int length, boolean acquire_lock) throws Exception {
+        protected void _send(byte[] data, int offset, int length, boolean acquire_lock) throws Exception {
             if(acquire_lock)
                 send_lock.lock();
 
@@ -483,7 +475,7 @@ private void _send(byte[] data, int offset, int length, boolean acquire_lock) th
             }
         }
 
-        private void doSend(byte[] data, int offset, int length) throws Exception {
+        protected void doSend(byte[] data, int offset, int length) throws Exception {
             out.writeInt(length); // write the length of the data buffer first
             out.write(data, offset, length);
             out.flush(); // may not be very efficient (but safe)           
@@ -493,7 +485,7 @@ private void doSend(byte[] data, int offset, int length) throws Exception {
          * Reads the peer's address. First a cookie has to be sent which has to
          * match my own cookie, otherwise the connection will be refused
          */
-        private Address readPeerAddress(Socket client_sock) throws Exception {                    
+        protected Address readPeerAddress(Socket client_sock) throws Exception {                    
             int timeout=client_sock.getSoTimeout();
             client_sock.setSoTimeout(peer_addr_read_timeout);
 
@@ -528,7 +520,7 @@ private Address readPeerAddress(Socket client_sock) throws Exception {
          * 
          * @throws Exception
          */
-        private void sendLocalAddress(Address local_addr) throws Exception {
+        protected void sendLocalAddress(Address local_addr) throws Exception {
             // write the cookie
             out.write(cookie, 0, cookie.length);
 
@@ -539,16 +531,16 @@ private void sendLocalAddress(Address local_addr) throws Exception {
             updateLastAccessed();
         }       
 
-        private boolean matchCookie(byte[] input) {
+        protected boolean matchCookie(byte[] input) {
             if(input == null || input.length < cookie.length) return false;
             for(int i=0; i < cookie.length; i++)
                 if(cookie[i] != input[i]) return false;
             return true;
         }
         
-        private class ConnectionPeerReceiver implements Runnable {
-            private final Thread recv;
-            private final AtomicBoolean receiving = new AtomicBoolean(false);
+        protected class ConnectionPeerReceiver implements Runnable {
+            protected final Thread recv;
+            protected final AtomicBoolean receiving = new AtomicBoolean(false);
 
 
             public ConnectionPeerReceiver(ThreadFactory f) {
@@ -602,11 +594,11 @@ public void run() {
             }
         }
         
-        private class Sender implements Runnable {
+        protected class Sender implements Runnable {
 
             final BlockingQueue<byte[]> send_queue;
             final Thread runner;
-            private final AtomicBoolean running= new AtomicBoolean(false);
+            protected final AtomicBoolean running= new AtomicBoolean(false);
 
             public Sender(ThreadFactory tf,int send_queue_size) {
                 this.runner=tf.newThread(this, ""Connection.Sender ["" + getSockAddress() + ""]"");
@@ -733,7 +725,7 @@ public void close() throws IOException {
         }
     }
     
-    private class Mapper extends AbstractConnectionMap<TCPConnection> {
+    protected class Mapper extends AbstractConnectionMap<TCPConnection> {
 
         public Mapper(ThreadFactory factory) {
             super(factory);            ",2012-12-13T10:28:10Z,11
"@@ -2,50 +2,64 @@
 
 import org.jgroups.Address;
 import org.jgroups.Event;
+import org.jgroups.Global;
 import org.jgroups.PhysicalAddress;
+import org.jgroups.annotations.LocalAddress;
 import org.jgroups.annotations.Property;
 
+import java.net.InetAddress;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  * Shared base class for TCP protocols
  * @author Scott Marlow
+ * @author Bela Ban
  */
 public abstract class BasicTCP extends TP {
 
     /* -----------------------------------------    Properties     -------------------------------------------------- */
     
     @Property(description=""Reaper interval in msec. Default is 0 (no reaping)"")
-    protected long reaper_interval=0; // time in msecs between connection reaps
+    protected long        reaper_interval=0; // time in msecs between connection reaps
 
     @Property(description=""Max time connection can be idle before being reaped (in ms)"")
-    protected long conn_expire_time=0; // max time a conn can be idle before being reaped
+    protected long        conn_expire_time=0; // max time a conn can be idle before being reaped
 
     @Property(description=""Should separate send queues be used for each connection"")
-    boolean use_send_queues=true;
+    protected boolean     use_send_queues=true;
     
     @Property(description=""Max number of messages in a send queue"")
-    int send_queue_size=10000;
+    protected int         send_queue_size=10000;
     
     @Property(description=""Receiver buffer size in bytes"")
-    int recv_buf_size=150000;
+    protected int         recv_buf_size=150000;
     
     @Property(description=""Send buffer size in bytes"")
-    int send_buf_size=150000;
+    protected int         send_buf_size=150000;
     
     @Property(description=""Max time allowed for a socket creation in connection table"")
-    int sock_conn_timeout=2000; // max time in millis for a socket creation in connection table
+    protected int         sock_conn_timeout=2000; // max time in millis for a socket creation in connection table
     
     @Property(description=""Max time to block on reading of peer address"")
-    int peer_addr_read_timeout=1000; // max time to block on reading of peer address
+    protected int         peer_addr_read_timeout=1000; // max time to block on reading of peer address
     
     @Property(description=""Should TCP no delay flag be turned on"")
-    boolean tcp_nodelay=true;
+    protected boolean     tcp_nodelay=true;
     
     @Property(description=""SO_LINGER in msec. Default of -1 disables it"")
-    int linger=-1; // SO_LINGER (number of ms, -1 disables it)
+    protected int         linger=-1; // SO_LINGER (number of ms, -1 disables it)
+
+    @LocalAddress
+    @Property(name=""client_bind_addr"",
+              description=""The address of a local network interface which should be used by client sockets to bind to. "" +
+                ""The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK"",
+              systemProperty={Global.TCP_CLIENT_BIND_ADDR},writable=false)
+    protected InetAddress client_bind_addr=null;
+
+    @Property(description=""The local port a client socket should bind to. If 0, an ephemeral port will be picked."")
+    protected int         client_bind_port=0;
 
 
     /* --------------------------------------------- Fields ------------------------------------------------------ */",2012-12-13T10:28:10Z,12
"@@ -135,7 +135,7 @@ protected TCPConnectionMap createConnectionMap(long reaperInterval,
                                         externalAddress,
                                         external_port,
                                         startPort,
-                                        endPort);
+                                        endPort).clientBindAddress(client_bind_addr).clientBindPort(client_bind_port);
         }
         else {
             if(reaperInterval == 0) {
@@ -158,7 +158,7 @@ protected TCPConnectionMap createConnectionMap(long reaperInterval,
                                         startPort,
                                         endPort,
                                         reaperInterval,
-                                        connExpireTime);
+                                        connExpireTime).clientBindAddress(client_bind_addr).clientBindPort(client_bind_port);
         }
 
         return cTable;",2012-12-13T10:28:10Z,13
"@@ -300,7 +300,8 @@ public void connectionClosed(Connection conn) {
 
     protected NioServer createServer(int[] bind_ports) {
         DefaultSocketFactory socket_factory=new DefaultSocketFactory();
-        ThreadFactory thread_factory=new DefaultThreadFactory(""nio"", false);
+        DefaultThreadFactory thread_factory=new DefaultThreadFactory(""nio"", false);
+        thread_factory.useFibers(getTransport().useFibers());
         for(int bind_port: bind_ports) {
             try {
                 return new NioServer(thread_factory, socket_factory, bind_addr, bind_port, bind_port,",2021-08-02T07:17:55Z,14
"@@ -2,7 +2,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP />
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,15
"@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <!-- Demo config showing how to configure ASYM_ENCRYPT with a keystore and certificates -->
-<config version=""${version}"">
+<config >
     <TCP bind_addr=""localhost"" bind_port=""7600""/>
     <TCPPING initial_hosts=""localhost[7600]"" port_range=""10""/>
     <MERGE3/> ",2020-11-10T13:19:51Z,16
"@@ -1,7 +1,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP/>
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,17
"@@ -1,7 +1,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP bind_addr=""localhost""
          bind_port=""1025""/>
     <PING            />",2020-11-10T13:19:51Z,18
"@@ -1,7 +1,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP/>
     <PING />
     <MERGE3 />",2020-11-10T13:19:51Z,19
"@@ -10,7 +10,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP/>
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,20
"@@ -2,7 +2,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP />
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,21
"@@ -10,7 +10,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP
          mcast_port=""${jgroups.udp.mcast_port:45588}""
          ip_ttl=""0""",2020-11-10T13:19:51Z,22
"@@ -8,7 +8,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP/>
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,23
"@@ -4,7 +4,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP />
     <PING/>
     <MERGE3/>",2020-11-10T13:19:51Z,24
"@@ -8,7 +8,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <TCP_NIO2 bind_port=""7800""
          recv_buf_size=""${tcp.recv_buf_size:130k}""
          send_buf_size=""${tcp.send_buf_size:130k}""",2020-11-10T13:19:51Z,25
"@@ -7,14 +7,12 @@
 -->
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
-        xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd"">
     <TCP bind_port=""7800""
          recv_buf_size=""${tcp.recv_buf_size:130k}""
          send_buf_size=""${tcp.send_buf_size:130k}""
          max_bundle_size=""64K""
          sock_conn_timeout=""300""
-
          thread_pool.min_threads=""0""
          thread_pool.max_threads=""20""
          thread_pool.keep_alive_time=""30000""/>",2020-11-10T13:19:51Z,26
"@@ -7,7 +7,7 @@
 <config xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xmlns=""urn:org:jgroups""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
   
     <TUNNEL gossip_router_hosts=""${jgroups.tunnel.gossip_router_hosts:localhost[12001]}""/>
     <PING/>",2020-11-10T13:19:51Z,27
"@@ -7,7 +7,7 @@
 <config xmlns=""urn:org:jgroups""
         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
         xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd""
-        version=""${version}"">
+        >
     <UDP
          mcast_port=""${jgroups.udp.mcast_port:45588}""
          ip_ttl=""4""",2020-11-10T13:19:51Z,28
"@@ -0,0 +1,15 @@
+package org.jgroups.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Protocols annotated with this annotation should upgrade to a newer version (e.g. UNICAST -> UNICAST3)
+ * @author Bela Ban
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface RecommendedForUpgrade {
+}",2020-11-10T13:19:51Z,29
"@@ -2,7 +2,6 @@
 package org.jgroups.conf;
 
 
-import org.jgroups.Version;
 import org.jgroups.logging.Log;
 import org.jgroups.logging.LogFactory;
 import org.jgroups.util.Util;
@@ -166,22 +165,6 @@ public static List<ProtocolConfiguration> parseProtocols(Element root_element) t
         if(!""config"".equals(root_name))
             throw new IOException(""the configuration does not start with a <config> element: "" + root_name);
 
-        // validate that version of config and JGroups match (https://issues.redhat.com/browse/JGRP-2401)
-        String version=root_element.getAttribute(""version"");
-        if(version != null && !version.isEmpty()) {
-            short ver=Version.parse(version);
-            if(!Version.isBinaryCompatible(ver)) {
-                String s=String.format(""the version of the config file (%s) doesn't match the version of JGroups (%s); "" +
-                                         ""this might lead to problems. Please use a config from the same JGroups version"",
-                                       Version.print(ver), Version.printVersion());
-
-                if(Version.getMajor() != Version.getMajor(ver))
-                    throw new IllegalArgumentException(s);
-                log.warn(s);
-            }
-        }
-        else
-            log.warn(""version is missing in the configuration file"");
         final List<ProtocolConfiguration> prot_data=new ArrayList<>();
         NodeList prots=root_element.getChildNodes();
         for(int i=0;i < prots.getLength();i++) {",2020-11-10T13:19:51Z,30
"@@ -42,6 +42,7 @@
  *
  * @author Bela Ban
  */
+@RecommendedForUpgrade
 @MBean(description=""Failure detection based on simple heartbeat protocol"")
 public class FD extends Protocol {
     ",2020-11-10T13:19:51Z,31
"@@ -6,6 +6,7 @@
 import org.jgroups.PhysicalAddress;
 import org.jgroups.annotations.LocalAddress;
 import org.jgroups.annotations.Property;
+import org.jgroups.annotations.RecommendedForUpgrade;
 import org.jgroups.conf.PropertyHelper;
 import org.jgroups.conf.ProtocolConfiguration;
 import org.jgroups.logging.Log;
@@ -180,14 +181,20 @@ protected static Protocol createLayer(ProtocolStack stack, ProtocolConfiguration
         if(protocol_name == null)
             return null;
         Class<? extends Protocol> clazz=Util.loadProtocolClass(protocol_name, stack != null? stack.getClass() : null);
+        if(clazz.getAnnotation(Deprecated.class) != null)
+            log.warn(""%s has been deprecated; please upgrade to a newer version of the protocol"", clazz.getSimpleName());
+        if(clazz.getAnnotation(RecommendedForUpgrade.class) != null)
+            log.warn(""there are more recent versions of %s present; "" +
+                       ""please upgrade to a newer version of the protocol"", clazz.getSimpleName());
         try {
             Protocol retval=clazz.getDeclaredConstructor().newInstance();
             if(stack != null)
                 retval.setProtocolStack(stack);
             return retval;
         }
         catch(InstantiationException inst_ex) {
-            throw new InstantiationException(String.format(Util.getMessage(""ProtocolCreateError""), protocol_name, inst_ex.getLocalizedMessage()));
+            throw new InstantiationException(String.format(Util.getMessage(""ProtocolCreateError""),
+                                                           protocol_name, inst_ex.getLocalizedMessage()));
         }
     }
 ",2020-11-10T13:19:51Z,32
"@@ -68,7 +68,6 @@ public static void main(String[] args) {
             xmldoc.getDocumentElement().setAttribute(""xmlns:tns"", ""urn:org:jgroups"");
             xmldoc.getDocumentElement().setAttribute(""elementFormDefault"", ""qualified"");
             xmldoc.getDocumentElement().setAttribute(""attributeFormDefault"", ""unqualified"");
-            xmldoc.getDocumentElement().setAttribute(""version"", version);
 
             Element complexType = xmldoc.createElement(""xs:complexType"");
             complexType.setAttribute(""name"", ""ConfigType"");
@@ -77,10 +76,6 @@ public static void main(String[] args) {
             Element allType = xmldoc.createElement(""xs:choice"");
             allType.setAttribute(""maxOccurs"", ""unbounded"");
             complexType.appendChild(allType);
-            Element attributeElement = xmldoc.createElement(""xs:attribute"");
-            attributeElement.setAttribute(""name"", ""version"");
-            attributeElement.setAttribute(""type"", ""xs:string"");
-            complexType.appendChild(attributeElement);
             generateProtocolSchema(xmldoc, allType, PACKAGES);
 
             Element xsElement = xmldoc.createElement(""xs:element"");",2020-11-10T13:19:51Z,33
"@@ -113,4 +113,4 @@ protected void sendMessageList(final Address dest, final Address src, final List
         tmp.add(msg);
         count+=size;
     }
-}
\ No newline at end of file
+}",2021-04-23T07:38:01Z,34
"@@ -61,6 +61,18 @@ public String toString() {
         return print(false);
     }
 
+    public int hashCode() {
+        int retval=super.hashCode();
+        byte[] site=get(SITE_NAME);
+        return site != null? Arrays.hashCode(site) + retval : retval;
+    }
+
+    public boolean equals(Object obj) {
+        if(!(obj instanceof SiteUUID))
+            return false;
+        return compareTo((SiteUUID)obj) == 0;
+    }
+
     @Override
     public int compareTo(Address other) {
         if (other instanceof SiteUUID) {",2021-04-23T07:38:01Z,35
"@@ -181,8 +181,7 @@ public int hashCode() {
     public boolean equals(Object obj) {
         if (!(obj instanceof UUID))
             return false;
-        UUID id = (UUID)obj;
-        return this == id || (mostSigBits == id.mostSigBits && leastSigBits == id.leastSigBits);
+        return compareTo((UUID)obj) == 0;
     }
 
 
@@ -197,11 +196,13 @@ public int compareTo(Address other) {
         UUID val=(UUID)other;
         if(this == val)
             return 0;
-        return (this.mostSigBits < val.mostSigBits ? -1 :
+        int most=Long.compare(this.mostSigBits, val.mostSigBits);
+        return most != 0? most : Long.compare(this.leastSigBits, val.leastSigBits);
+        /*return (this.mostSigBits < val.mostSigBits ? -1 :
                 (this.mostSigBits > val.mostSigBits ? 1 :
                         (this.leastSigBits < val.leastSigBits ? -1 :
                                 (this.leastSigBits > val.leastSigBits ? 1 :
-                                        0))));
+                                        0)))); */
     }
 
 ",2021-04-23T07:38:01Z,36
"@@ -1,23 +1,25 @@
 package org.jgroups.tests;
 
 import org.jgroups.*;
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
 import org.jgroups.protocols.*;
 import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK2;
-import org.jgroups.protocols.relay.RELAY2;
-import org.jgroups.protocols.relay.Route;
-import org.jgroups.protocols.relay.SiteMaster;
-import org.jgroups.protocols.relay.SiteMasterPicker;
+import org.jgroups.protocols.relay.*;
 import org.jgroups.protocols.relay.config.RelayConfig;
 import org.jgroups.stack.Protocol;
+import org.jgroups.util.MyReceiver;
 import org.jgroups.util.Util;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
 import java.net.InetAddress;
-import java.util.ArrayList;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
 
 /**
  * Various RELAY2-related tests
@@ -26,8 +28,11 @@
  */
 @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
 public class Relay2Test {
+    private static final Log log = LogFactory.getLog(Relay2Test.class);
+
     protected JChannel a, b, c;  // members in site ""lon""
     protected JChannel x, y, z;  // members in site ""sfo
+    protected JChannel m; // the only member in site ""pek""
 
     protected static final String      BRIDGE_CLUSTER = ""global"";
     protected static final String      LON_CLUSTER    = ""lon-cluster"";
@@ -40,7 +45,7 @@ public class Relay2Test {
     }
 
 
-    @AfterMethod protected void destroy() {Util.close(z,y,x,c,b,a);}
+    @AfterMethod protected void destroy() {Util.close(m,z,y,x,c,b,a);}
 
     /**
      * Test that RELAY2 can be added to an already connected channel.
@@ -255,14 +260,61 @@ public void testUnknownAndUpStateTransitions() throws Exception {
         assert route != null : ""route is "" + route + "" (expected to be UP)"";
     }
 
+    /** Tests https://issues.redhat.com/browse/JGRP-2554 */
+    public void testSiteUnreachableMessageBreaksSiteUUID() throws Exception {
+        a=createNode(LON, ""A"", LON_CLUSTER, null);
+        b=createNode(LON, ""B"", LON_CLUSTER, null);
+        c=createNode(LON, ""C"", LON_CLUSTER, null);
+        x=createNode(SFO, ""X"", SFO_CLUSTER, null);
+        waitForBridgeView(2, 20000, 500, a, x);
+
+        BlockingQueue<Message> received = new LinkedBlockingDeque<>();
+        UpHandler h = new UpHandler() {
+            @Override
+            public Object up(Event evt) {
+                if(evt.getType() == Event.SITE_UNREACHABLE)
+                    log.debug(""Site %s is unreachable"", (Object) evt.getArg());
+                return null;
+            }
+
+            @Override
+            public Object up(Message msg) {
+                log.debug(""Received %s from %s\n"", new String(msg.getBuffer(), StandardCharsets.UTF_8), msg.getSrc());
+                received.add(msg);
+                return null;
+            }
+        };
+        b.setUpHandler(h);
+
+        log.debug(""Disconnecting X"");
+        x.disconnect();
+        log.debug(""A: waiting for site SFO to be UNKNOWN"");
+        waitUntilRoute(SFO, false, 20000, 500, a);
+
+        for (int i = 0; i < 100; i++)
+            b.send(new SiteMaster(SFO), ""to-sfo"".getBytes(StandardCharsets.UTF_8));
+
+        log.debug(""Sending message from A to B"");
+        for (int i = 0; i < 100; i++) {
+            a.send(b.getAddress(), (""to-b-"" + i).getBytes(StandardCharsets.UTF_8));
+            Thread.sleep(0);
+        }
+
+        for (int i = 0; i < 100; i++) {
+            Message take = received.take();
+            assert !(take.src() instanceof SiteUUID) : ""Address was "" + take.src();
+        }
+    }
+
 
     /**
      * Cluster A,B,C in LON and X,Y,Z in SFO. A, B, X and Y are site masters (max_site_masters: 2).
      * Verifies that messages sent by C in the LON site are received in the correct order by all members of the SFO site
      * despite using multiple site masters. JIRA: https://issues.jboss.org/browse/JGRP-2112
      */
     public void testSenderOrderWithMultipleSiteMasters() throws Exception {
-        MyReceiver rx=new MyReceiver(), ry=new MyReceiver(), rz=new MyReceiver();
+        MyReceiver<Object> rx=new MyReceiver<>().rawMsgs(true).verbose(true),
+          ry=new MyReceiver<>().rawMsgs(true).verbose(true), rz=new MyReceiver<>().rawMsgs(true).verbose(true);
         final int NUM=512;
         final String sm_picker_impl=SiteMasterPickerImpl.class.getName();
         a=createNode(LON, ""A"", LON_CLUSTER, 2, sm_picker_impl, null);
@@ -288,18 +340,18 @@ public void testSenderOrderWithMultipleSiteMasters() throws Exception {
 
         boolean running=true;
         for(int i=0; running && i < 10; i++) {
-            for(MyReceiver r: Arrays.asList(rx,ry,rz)) {
-                if(r.getList().size() >= NUM) {
+            for(MyReceiver<Object> r: Arrays.asList(rx,ry,rz)) {
+                if(r.size() >= NUM) {
                     running=false;
                     break;
                 }
             }
             Util.sleep(1000);
         }
 
-        System.out.printf(""X: size=%d\nY: size=%d\nZ: size=%d\n"", rx.getList().size(), ry.getList().size(), rz.getList().size());
-        assert rx.getList().size() == NUM || ry.getList().size() == NUM;
-        assert rz.getList().isEmpty();
+        System.out.printf(""X: size=%d\nY: size=%d\nZ: size=%d\n"", rx.size(), ry.size(), rz.size());
+        assert rx.size() == NUM || ry.size() == NUM;
+        assert rz.size() == 0;
     }
 
     protected static class SiteMasterPickerImpl implements SiteMasterPicker {
@@ -317,15 +369,15 @@ public Route pickRoute(String site, List<Route> routes, Address original_sender)
     }
 
 
-    protected JChannel createNode(String site_name, String node_name, String cluster_name,
-                                      Receiver receiver) throws Exception {
+    protected static JChannel createNode(String site_name, String node_name, String cluster_name,
+                                         Receiver receiver) throws Exception {
         return createNode(site_name, node_name, cluster_name, 1, null, receiver);
     }
 
-    protected JChannel createNode(String site_name, String node_name, String cluster_name, int num_site_masters,
-                                  String sm_picker, Receiver receiver) throws Exception {
-        JChannel ch=new JChannel(new SHARED_LOOPBACK(),
-                                 new SHARED_LOOPBACK_PING(),
+    protected static JChannel createNode(String site_name, String node_name, String cluster_name, int num_site_masters,
+                                         String sm_picker, Receiver receiver) throws Exception {
+        JChannel ch=new JChannel(new UDP(),
+                                 new LOCAL_PING(),
                                  new MERGE3().setValue(""max_interval"", 3000).setValue(""min_interval"", 1000),
                                  new NAKACK2(),
                                  new UNICAST3(),
@@ -343,7 +395,7 @@ protected JChannel createNode(String site_name, String node_name, String cluster
 
 
 
-    protected RELAY2 createRELAY2(String site_name) {
+    protected static RELAY2 createRELAY2(String site_name) {
         RELAY2 relay=new RELAY2().site(site_name).enableAddressTagging(false).asyncRelayCreation(false);
 
         RelayConfig.SiteConfig lon_cfg=new RelayConfig.SiteConfig(LON),
@@ -376,7 +428,7 @@ protected static void createPartition(JChannel ... channels) {
     }
 
 
-    protected void waitForBridgeView(int expected_size, long timeout, long interval, JChannel ... channels) {
+    protected static void waitForBridgeView(int expected_size, long timeout, long interval, JChannel... channels) {
         long deadline=System.currentTimeMillis() + timeout;
 
         while(System.currentTimeMillis() < deadline) {
@@ -410,8 +462,8 @@ protected void waitForBridgeView(int expected_size, long timeout, long interval,
     }
 
 
-    protected void waitUntilRoute(String site_name, boolean present,
-                                  long timeout, long interval, JChannel ch) throws Exception {
+    protected static void waitUntilRoute(String site_name, boolean present,
+                                         long timeout, long interval, JChannel ch) throws Exception {
         RELAY2 relay=ch.getProtocolStack().findProtocol(RELAY2.class);
         if(relay == null)
             throw new IllegalArgumentException(""Protocol RELAY2 not found"");
@@ -426,22 +478,9 @@ protected void waitUntilRoute(String site_name, boolean present,
         assert (route != null && present) || (route == null && !present);
     }
 
-    protected Route getRoute(JChannel ch, String site_name) {
+    protected static Route getRoute(JChannel ch, String site_name) {
         RELAY2 relay=ch.getProtocolStack().findProtocol(RELAY2.class);
         return relay.getRoute(site_name);
     }
 
-
-    protected static class MyReceiver extends ReceiverAdapter {
-        protected final List<Integer> list=new ArrayList<>(512);
-
-        public List<Integer> getList()            {return list;}
-        public void          clear()              {list.clear();}
-
-        public void receive(Message msg) {
-            list.add(msg.getObject());
-            System.out.printf(""<-- %s from %s\n"", msg.getObject(), msg.src());
-        }
-    }
-
 }",2021-04-23T07:38:01Z,37
"@@ -27,7 +27,7 @@ if [ -f $HOME/logging.properties ]; then
     LOG=""$LOG -Djava.util.logging.config.file=$HOME/logging.properties""
 fi;
 
-JG_FLAGS=""-Djgroups.bind_addr=match-address:192.168.1.*""
+#JG_FLAGS=""-Djgroups.bind_addr=match-address:192.168.1.*""
 JG_FLAGS=""$JG_FLAGS -Djava.net.preferIPv4Stack=true""
 FLAGS=""-server -Xmx600M -Xms600M""
 FLAGS=""$FLAGS -XX:CompileThreshold=10000 -XX:ThreadStackSize=64K -XX:SurvivorRatio=8""",2015-12-24T10:15:46Z,38
"@@ -305,6 +305,12 @@ public void replaceConnection(Address address, Connection conn) {
         notifyConnectionEstablished(conn);
     }
 
+    public void closeConnection(Connection conn, Throwable ex) {
+        Util.close(conn);
+        notifyConnectionClosed(conn, ex.toString());
+        removeConnectionIfPresent(conn != null? conn.peerAddress() : null, conn);
+    }
+
 
     public synchronized void addConnection(Address peer_addr, Connection conn) throws Exception {
         boolean conn_exists=hasConnection(peer_addr),",2015-12-24T10:15:46Z,39
"@@ -4,7 +4,6 @@
 import org.jgroups.annotations.ManagedAttribute;
 import org.jgroups.annotations.ManagedOperation;
 import org.jgroups.util.ThreadFactory;
-import org.jgroups.util.Util;
 
 import java.nio.channels.*;
 import java.util.Iterator;
@@ -25,14 +24,13 @@ public abstract class NioBaseServer extends BaseServer {
     @ManagedAttribute(description=""Max number of send buffers. Changing this value affects new buffers only"",writable=true)
     protected int               max_send_buffers=5; // size of WriteBuffers send buffer array
 
-    @ManagedAttribute(description=""Max number of messages to read on an OP_READ"",writable=true)
-    protected int               max_read_batch_size=50;
-
     @ManagedAttribute(description=""Number of times select() was called"")
     protected int               num_selects;
 
     protected boolean           copy_on_partial_write=true;
 
+    protected long              reader_idle_time=20000;
+
 
 
     protected NioBaseServer(ThreadFactory f) {
@@ -43,12 +41,12 @@ protected NioBaseServer(ThreadFactory f) {
 
     public int            maxSendBuffers()              {return max_send_buffers;}
     public NioBaseServer  maxSendBuffers(int num)       {this.max_send_buffers=num; return this;}
-    public int            maxReadBatchSize()            {return max_read_batch_size;}
-    public NioBaseServer  maxReadBatchSize(int size)    {max_read_batch_size=size; return this;}
     public boolean        selectorOpen()                {return selector != null && selector.isOpen();}
     public boolean        acceptorRunning()             {return acceptor != null && acceptor.isAlive();}
     public int            numSelects()                  {return num_selects;}
     public boolean        copyOnPartialWrite()          {return copy_on_partial_write;}
+    public long           readerIdleTime()              {return reader_idle_time;}
+    public NioBaseServer  readerIdleTime(long t)        {reader_idle_time=t; return this;}
 
     public NioBaseServer  copyOnPartialWrite(boolean b) {
         this.copy_on_partial_write=b;
@@ -131,12 +129,8 @@ public void run() {
                     try {
                         if(!key.isValid())
                             continue;
-                        if(key.isReadable()) {
-                            if(max_read_batch_size > 1)
-                                conn.receive(max_read_batch_size);
-                            else
-                                conn.receive();
-                        }
+                        if(key.isReadable())
+                            conn.receive();
                         if(key.isWritable())
                             conn.send();
                         if(key.isAcceptable())
@@ -148,9 +142,7 @@ else if(key.isConnectable()) {
                         }
                     }
                     catch(Throwable ex) {
-                        Util.close(conn);
-                        notifyConnectionClosed(conn, ex.toString());
-                        removeConnectionIfPresent(conn != null? conn.peerAddress() : null, conn);
+                        closeConnection(conn, ex);
                     }
                 }
             }",2015-12-24T10:15:46Z,40
"@@ -5,10 +5,9 @@
 import org.jgroups.Version;
 import org.jgroups.nio.Buffers;
 import org.jgroups.stack.IpAddress;
-import org.jgroups.util.ByteArrayDataInputStream;
-import org.jgroups.util.ByteArrayDataOutputStream;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
@@ -33,15 +32,17 @@ public class NioConnection implements Connection {
     protected long                last_access;  // timestamp of the last access to this connection (read or write)
     protected final NioBaseServer server;
 
-    // {length, data} pair to send a message with a gathering write
-    protected final Buffers       send_buf;
+    protected final Buffers       send_buf;     // send messages via gathering writes
     protected boolean             write_interest_set; // set when a send() didn't manage to send all data
+    protected boolean             copy_on_partial_write=true;
+    protected int                 partial_writes; // number of partial writes (write which did not write all bytes)
     protected final Lock          send_lock=new ReentrantLock(); // serialize send()
 
     // creates an array of 2: length buffer (for reading the length of the following data buffer) and data buffer
-    protected Buffers             recv_buf=new Buffers(ByteBuffer.allocate(Global.INT_SIZE), null);
-    protected boolean             copy_on_partial_write=true;
-    protected int                 partial_writes; // number of partial writes (write which did not write all bytes)
+    protected Buffers             recv_buf=new Buffers(2).add(ByteBuffer.allocate(Global.INT_SIZE), null);
+    protected Reader              reader=new Reader(); // manages the thread which receives messages
+    protected long                reader_idle_time=20000; // number of ms a reader can be idle (no msgs) until it terminates
+
 
 
      /** Creates a connection stub and binds it, use {@link #connect(Address)} to connect */
@@ -106,19 +107,20 @@ public Address localAddress() {
     public NioConnection copyOnPartialWrite(boolean b) {this.copy_on_partial_write=b; return this;}
     public boolean       copyOnPartialWrite()          {return copy_on_partial_write;}
     public int           numPartialWrites()            {return partial_writes;}
+    public long          readerIdleTime()              {return reader_idle_time;}
+    public NioConnection readerIdleTime(long t)        {this.reader_idle_time=t; return this;}
+    public boolean       readerRunning()               {return this.reader.isRunning();}
 
-    public synchronized int registerSelectionKey(int interest_ops) {
+    public synchronized void registerSelectionKey(int interest_ops) {
         if(key == null)
-            return 0;
+            return;
         key.interestOps(key.interestOps() | interest_ops);
-        return key.interestOps();
     }
 
-    public synchronized int clearSelectionKey(int interest_ops) {
+    public synchronized void clearSelectionKey(int interest_ops) {
         if(key == null)
-            return 0;
+            return;
         key.interestOps(key.interestOps() & ~interest_ops);
-        return key.interestOps();
     }
 
 
@@ -208,21 +210,7 @@ public void send() throws Exception {
 
     /** Read the length first, then the actual data. This method is not reentrant and access must be synchronized */
     public void receive() throws Exception {
-        _receive(true);
-    }
-
-
-    /** Tries to receive up to max_msgs_to_receive messages in one go */
-    public void receive(int max_msgs_to_receive) throws Exception {
-        try {
-            while(max_msgs_to_receive-- > 0) {
-                if(!_receive(false))
-                    return;
-            }
-        }
-        finally {
-            updateLastAccessed();
-        }
+        reader.receive();
     }
 
 
@@ -252,7 +240,7 @@ public void close() throws IOException {
             if(send_buf.remaining() > 0) { // try to flush send buffer if it still has pending data to send
                 try {send();} catch(Throwable e) {}
             }
-            Util.close(channel);
+            Util.close(channel, reader);
         }
         finally {
             send_lock.unlock();
@@ -266,9 +254,9 @@ public String toString() {
         try {remote=channel != null? (InetSocketAddress)channel.getRemoteAddress() : null;} catch(Throwable t) {}
         String loc=local == null ? ""n/a"" : local.getHostString() + "":"" + local.getPort(),
           rem=remote == null? ""n/a"" : remote.getHostString() + "":"" + remote.getPort();
-        return String.format(""<%s --> %s> (%d secs old) [%s] [send_buf: %s, recv_buf: %s] [ops=%d]"",
+        return String.format(""<%s --> %s> (%d secs old) [%s] [recv_buf: %d, reader=%b]"",
                              loc, rem, TimeUnit.SECONDS.convert(getTimestamp() - last_access, TimeUnit.NANOSECONDS),
-                             status(), send_buf, recv_buf, key != null? key.interestOps() : -1);
+                             status(), recv_buf.get(1) != null? recv_buf.get(1).capacity() : 0, readerRunning());
     }
 
     protected String status() {
@@ -337,9 +325,7 @@ protected void sendLocalAddress(Address local_addr) throws Exception {
 
     protected Address readPeerAddress(ByteBuffer buf) throws Exception {
         ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf);
-
-        // then read the version
-        short version=in.readShort();
+        short version=in.readShort(); // version
         if(!Version.isBinaryCompatible(version))
             throw new IOException(""packet from "" + channel.getRemoteAddress() + "" has different version ("" + Version.print(version) +
                                     "") from ours ("" + Version.printVersion() + ""); discarding it"");
@@ -353,4 +339,119 @@ protected static ByteBuffer makeLengthBuffer(ByteBuffer buf) {
         return (ByteBuffer)ByteBuffer.allocate(Global.INT_SIZE).putInt(buf.remaining()).clear();
     }
 
+    protected enum State {reading, waiting_to_terminate, done}
+
+    protected class Reader implements Runnable, Closeable, Condition {
+        protected final Lock       lock=new ReentrantLock(); // to synchronize receive() and state transitions
+        protected State            state=State.done;
+        protected volatile boolean data_available=true;
+        protected final CondVar    data_available_cond=new CondVar();
+        protected volatile Thread  thread;
+        protected volatile boolean running;
+
+        protected void start() {
+            running=true;
+            thread=server.factory.newThread(this, String.format(""NioConnection.Reader [%s]"", peer_addr));
+            thread.setDaemon(true);
+            thread.start();
+        }
+
+
+        protected void stop() {
+            running=false;
+            data_available=true;
+            data_available_cond.signal(false);
+        }
+
+        public void    close() throws IOException {stop();}
+        public boolean isMet()                    {return data_available;}
+        public boolean isRunning()                {Thread tmp=thread; return tmp != null && tmp.isAlive();}
+
+        /** Called by the selector when data is ready to be read from the SocketChannel */
+        public void receive() {
+            lock.lock();
+            try {
+                data_available=true;
+                // only a single receive() at a time, until OP_READ is registered again (by the reader thread)
+                clear(SelectionKey.OP_READ);
+                switch(state) {
+                    case reading:
+                        break;
+                    case waiting_to_terminate:
+                        data_available_cond.signal(false); // only 1 consumer
+                        break;
+                    case done:
+                        // make sure the selector doesn't wake up for our connection while the reader is reading msgs
+                        state=State.reading;
+                        start();
+                        break;
+                }
+            }
+            finally {
+                lock.unlock();
+            }
+        }
+
+        public void run() {
+            try {
+                _run();
+            }
+            finally {
+                register(SelectionKey.OP_READ);
+            }
+        }
+
+        protected void _run() {
+            while(running) {
+                for(;;) { // try to receive as many msgs as possible, until no more msgs are ready or the conn is closed
+                    try {
+                        if(!_receive(false))
+                            break;
+                    }
+                    catch(Throwable ex) {
+                        server.closeConnection(NioConnection.this, ex);
+                        state(State.done);
+                        return;
+                    }
+                }
+                updateLastAccessed();
+
+                // Transition to state waiting_to_terminate and wait for server.readerIdleTime() ms
+                state(State.waiting_to_terminate);
+                data_available=false;
+                register(SelectionKey.OP_READ); // now we might get receive() calls again
+                if(data_available_cond.waitFor(this, server.readerIdleTime(), TimeUnit.MILLISECONDS))
+                    state(State.reading);
+                else {
+                    state(State.done);
+                    return;
+                }
+            }
+        }
+
+        protected void register(int op) {
+            try {
+                registerSelectionKey(op);
+                key.selector().wakeup(); // no-op if the selector is not blocked in select()
+            }
+            catch(Throwable t) {
+            }
+        }
+
+        protected void clear(int op) {
+            try {
+                clearSelectionKey(op);
+            }
+            catch(Throwable t) {
+            }
+        }
+
+        protected void state(State st) {
+            lock.lock();
+            try {this.state=st;}
+            finally {lock.unlock();}
+        }
+
+    }
+
 }",2015-12-24T10:15:46Z,41
"@@ -301,13 +301,9 @@ public Receiver stop() {
             return this;
         }
 
-        public boolean isRunning() {
-            return receiving;
-        }
-
-        public boolean canRun() {
-            return isRunning() && isConnected();
-        }
+        public boolean isRunning()  {return receiving;}
+        public boolean canRun()     {return isRunning() && isConnected();}
+        public int     bufferSize() {return buffer != null? buffer.length : 0;}
 
         public void run() {
             Throwable t=null;
@@ -409,10 +405,10 @@ public String toString() {
         InetAddress local=tmp_sock.getLocalAddress(), remote=tmp_sock.getInetAddress();
         String local_str=local != null? Util.shortName(local) : ""<null>"";
         String remote_str=remote != null? Util.shortName(remote) : ""<null>"";
-        return String.format(""%s:%s --> %s:%s (%d secs old) [%s]"",
+        return String.format(""%s:%s --> %s:%s (%d secs old) [%s] [recv_buf=%d]"",
                              local_str, tmp_sock.getLocalPort(), remote_str, tmp_sock.getPort(),
                              TimeUnit.SECONDS.convert(getTimestamp() - last_access, TimeUnit.NANOSECONDS),
-                             status());
+                             status(), receiver != null? receiver.bufferSize() : 0);
     }
 
     protected String status() {",2015-12-24T10:15:46Z,42
"@@ -82,6 +82,7 @@ public boolean hasRemaining() {
     public Buffers add(ByteBuffer ... buffers) {
         if(buffers == null)
             return this;
+        assertPositiveUnsignedShort(buffers.length);
         int len=buffers.length;
         if(spaceAvailable(len) || (makeSpace() && spaceAvailable(len))) {
             for(ByteBuffer buf: buffers)",2015-12-24T10:15:46Z,43
"@@ -44,6 +44,11 @@ public String printConnections() {
         return server.printConnections();
     }
 
+    @ManagedOperation(description=""Clears all connections (they will get re-established). For testing only, don't use !"")
+    public void clearConnections() {
+        server.clearConnections();
+    }
+
     public void setSocketFactory(SocketFactory factory) {
         super.setSocketFactory(factory);
         if(server != null)",2015-12-24T10:15:46Z,13
"@@ -29,16 +29,15 @@ public class TCP_NIO2 extends BasicTCP {
     @Property(description=""The max number of outgoing messages that can get queued for a given peer connection "" +
       ""(before dropping them). Most messages will ge retransmitted; this is mainly used at startup, e.g. to prevent "" +
       ""dropped discovery requests or responses (sent unreliably, without retransmission)."")
-    protected int max_send_buffers=10;
-
-    @Property(description=""Max number of messages a read will try to read from the socket. Setting this to a higher "" +
-      ""value will increase speed when receiving a lot of messages. However, all other reads and writes are delayed "" +
-      ""by the time the batch read takes."")
-    protected int max_read_batch_size=50;
+    protected int     max_send_buffers=10;
 
     @Property(description=""If true, a partial write will make a copy of the data so a buffer can be reused"")
     protected boolean copy_on_partial_write=true;
 
+    @Property(description=""Number of ms a reader thread on a given connection can be idle (not receiving any messages) "" +
+      ""until it terminates. New messages will start a new reader"")
+    protected long    reader_idle_time=5000;
+
 
     public TCP_NIO2() {}
 
@@ -57,19 +56,6 @@ public void clearConnections() {
         server.clearConnections();
     }
 
-    @ManagedAttribute
-    public int maxReadBatchSize() {
-        int tmp=server.maxReadBatchSize();
-        if(tmp != max_read_batch_size)
-            max_read_batch_size=tmp;
-        return max_read_batch_size;
-    }
-
-    @ManagedAttribute
-    public void maxReadBatchSize(int size) {
-        this.max_read_batch_size=size;
-        server.maxReadBatchSize(size);
-    }
 
     @ManagedAttribute(description=""Is the selector open"")
     public boolean isSelectorOpen() {return server != null && server.selectorOpen();}
@@ -83,6 +69,13 @@ public void maxReadBatchSize(int size) {
     @ManagedAttribute(description=""Number of partial writes for all connections (not all bytes were written)"")
     public int     numPartialWrites() {return server.numPartialWrites();}
 
+    @ManagedAttribute(description=""Number of ms a reader thread on a given connection can be idle (not receiving any messages) "" +
+      ""until it terminates. New messages will start a new reader"")
+    public void readerIdleTime(long t) {
+        this.reader_idle_time=t;
+        server.readerIdleTime(t);
+    }
+
 
     public void send(Address dest, byte[] data, int offset, int length) throws Exception {
         if(server != null) {
@@ -110,9 +103,9 @@ public void start() throws Exception {
           .tcpNodelay(tcp_nodelay).linger(linger)
           .clientBindAddress(client_bind_addr).clientBindPort(client_bind_port).deferClientBinding(defer_client_bind_addr)
           .log(this.log))
-          .maxSendBuffers(max_send_buffers).maxReadBatchSize(this.max_read_batch_size)
-          .usePeerConnections(true);
-        server.copyOnPartialWrite(this.copy_on_partial_write);
+          .maxSendBuffers(max_send_buffers).usePeerConnections(true);
+        server.copyOnPartialWrite(this.copy_on_partial_write)
+          .readerIdleTime(this.reader_idle_time);
 
         if(reaper_interval > 0 || conn_expire_time > 0) {
             if(reaper_interval == 0) {
@@ -126,7 +119,6 @@ public void start() throws Exception {
             server.connExpireTimeout(conn_expire_time).reaperInterval(reaper_interval);
         }
 
-        // we first start threads in TP (http://jira.jboss.com/jira/browse/JGRP-626)
         super.start();
     }
     ",2015-12-24T10:15:46Z,44
"@@ -60,7 +60,6 @@ public boolean waitFor(Condition condition, long timeout, TimeUnit unit) {
         try {
             for(long wait_time=timeout_ns, start=System.nanoTime(); wait_time > 0 && !condition.isMet();) {
                 try {
-                    // System.out.println(""wait("" + TimeUnit.MILLISECONDS.convert(wait_time,TimeUnit.NANOSECONDS) + "")"");
                     wait_time=cond.awaitNanos(wait_time);
                 }
                 catch(InterruptedException e) {",2015-12-24T10:15:46Z,45
"@@ -267,7 +267,7 @@ static void log(String msg) {
 
     protected static BaseServer create(boolean nio, int port) {
         try {
-            BaseServer retval=nio? new NioServer(bind_addr, port).maxSendBuffers(1024).maxReadBatchSize(20)
+            BaseServer retval=nio? new NioServer(bind_addr, port).maxSendBuffers(1024)
               : new TcpServer(bind_addr, port).useSendQueues(false);
             retval.usePeerConnections(true);
             retval.start();",2015-12-24T10:15:46Z,46
"@@ -5,6 +5,9 @@
             <!--PatternLayout pattern=""%-7d{HH:mm:ss,SSS} [%p] %c: %m%n""/-->
             <PatternLayout pattern=""%r [%p] %c{1}: %m%n""/> 
         </Console>
+        <File name=""File"" fileName=""test.log"">
+            <PatternLayout pattern=""%r [%p] %c{1}: %m%n""/>
+        </File>
     </appenders>
     <loggers>
         <root level=""warn"">",2018-11-23T11:44:25Z,47
"@@ -12,9 +12,7 @@
 import org.jgroups.stack.IpAddress;
 import org.jgroups.util.NameCache;
 import org.jgroups.util.Responses;
-import org.jgroups.util.Util;
 
-import java.io.Closeable;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -62,7 +60,7 @@ protected void validateProperties() {
 
     @Override
     public void destroy() {
-        Util.close((Closeable)dns_resolver);
+        dns_resolver.close();
     }
 
     @Override",2018-11-23T11:44:25Z,48
"@@ -1,11 +1,12 @@
 package org.jgroups.protocols;
 
-import org.jgroups.*;
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Global;
+import org.jgroups.View;
 import org.jgroups.annotations.LocalAddress;
 import org.jgroups.annotations.MBean;
 import org.jgroups.annotations.Property;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.stack.IpAddress;
 import org.jgroups.util.Runner;
 import org.jgroups.util.Tuple;
@@ -38,7 +39,6 @@
   ""(key server) to fetch a shared secret group key from the key server. That shared (symmetric) key is subsequently "" +
   ""used to encrypt communication between cluster members"")
 public class SSL_KEY_EXCHANGE extends KeyExchange {
-    protected static final short GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
 
     protected enum Type {
         SECRET_KEY_REQ,
@@ -57,17 +57,19 @@ public interface SessionVerifier {
         void verify(SSLSession session) throws SecurityException;
     }
 
-    @Property(description=""The port at which the key server is listening. If the port is not available, the next port "" +
-      ""will be probed, up to port+port_range. Used by the key server (server) to create an SSLServerSocket and "" +
-      ""by clients to connect to the key server."")
-    protected int             port=2157;
 
     @LocalAddress
     @Property(description=""Bind address for the server or client socket. "" +
       ""The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK"",
       systemProperty={Global.BIND_ADDR})
     protected InetAddress     bind_addr;
 
+    @Property(description=""The port at which the key server is listening. If the port is not available, the next port "" +
+      ""will be probed, up to port+port_range. Used by the key server (server) to create an SSLServerSocket and "" +
+      ""by clients to connect to the key server."")
+    protected int             port=2157;
+
+
     @Property(description=""The port range to probe"")
     protected int             port_range=5;
 
@@ -100,17 +102,43 @@ public interface SessionVerifier {
     protected String          session_verifier_arg;
 
 
+    protected SSLContext                   ssl_ctx;
     protected SSLServerSocket              srv_sock;
     protected Runner                       srv_sock_handler;
     protected KeyStore                     key_store;
     protected View                         view;
     protected SessionVerifier              session_verifier;
 
 
-    public SSL_KEY_EXCHANGE setKeystoreName(String name)    {this.keystore_name=name; return this;}
-    public SSL_KEY_EXCHANGE setKeystorePassword(String pwd) {this.keystore_password=pwd; return this;}
-    public SSL_KEY_EXCHANGE setPortRange(int r)             {this.port_range=r; return this;}
-    public SSL_KEY_EXCHANGE setPort(int p)                  {this.port=p; return this;}
+    public InetAddress      getBindAddress()                          {return bind_addr;}
+    public SSL_KEY_EXCHANGE setBindAddress(InetAddress a)             {this.bind_addr=a; return this;}
+    public int              getPort()                                 {return port;}
+    public SSL_KEY_EXCHANGE setPort(int p)                            {this.port=p; return this;}
+    public int              getPortRange()                            {return port_range;}
+    public SSL_KEY_EXCHANGE setPortRange(int r)                       {this.port_range=r; return this;}
+    public String           getKeystoreName()                         {return keystore_name;}
+    public SSL_KEY_EXCHANGE setKeystoreName(String name)              {this.keystore_name=name; return this;}
+    public String           getKeystoreType()                         {return keystore_type;}
+    public SSL_KEY_EXCHANGE setKeystoreType(String type)              {this.keystore_type=type; return this;}
+    public String           getKeystorePassword()                     {return keystore_password;}
+    public SSL_KEY_EXCHANGE setKeystorePassword(String pwd)           {this.keystore_password=pwd; return this;}
+    public String           getSecretKeyAlgorithm()                   {return secret_key_algorithm;}
+    public SSL_KEY_EXCHANGE setSecretKeyAlgorithm(String a)           {this.secret_key_algorithm=a; return this;}
+    public boolean          getRequireClientAuthentication()          {return require_client_authentication;}
+    public SSL_KEY_EXCHANGE setRequireClientAuthentication(boolean b) {require_client_authentication=b; return this;}
+    public int              getSocketTimeout()                        {return socket_timeout;}
+    public SSL_KEY_EXCHANGE setSocketTimeout(int timeout)             {this.socket_timeout=timeout; return this;}
+    public String           getSessionVerifierClass()                 {return session_verifier_class;}
+    public SSL_KEY_EXCHANGE setSessionVerifierClass(String cl)        {this.session_verifier_class=cl; return this;}
+    public String           getSessionVerifierArg()                   {return session_verifier_arg;}
+    public SSL_KEY_EXCHANGE setSessionVerifierArg(String arg)         {this.session_verifier_arg=arg; return this;}
+    public KeyStore         getKeystore()                             {return key_store;}
+    public SSL_KEY_EXCHANGE setKeystore(KeyStore ks)                  {this.key_store=ks; return this;}
+    public SessionVerifier  getSessionVerifier()                      {return session_verifier;}
+    public SSL_KEY_EXCHANGE setSessionVerifier(SessionVerifier s)     {this.session_verifier=s; return this;}
+    public SSLContext       getSSLContext()                           {return ssl_ctx;}
+    public SSL_KEY_EXCHANGE setSSLContext(SSLContext ssl_ctx)         {this.ssl_ctx=ssl_ctx; return this;}
+
 
     public Address getServerLocation() {
         return srv_sock == null? null : new IpAddress(getTransport().getBindAddress(), srv_sock.getLocalPort());
@@ -141,7 +169,7 @@ public void init() throws Exception {
         if(input == null)
             throw new FileNotFoundException(keystore_name);
         key_store.load(input, keystore_password.toCharArray());
-        if(session_verifier_class != null) {
+        if(session_verifier == null && session_verifier_class != null) {
             Class<? extends SessionVerifier> verifier_class=Util.loadClass(session_verifier_class, getClass());
             session_verifier=verifier_class.getDeclaredConstructor().newInstance();
             if(session_verifier_arg != null)
@@ -364,6 +392,8 @@ protected SSLSocket createSocketTo(IpAddress dest, SSLSocketFactory sslSocketFac
 
 
     protected SSLContext getContext() throws Exception {
+        if(this.ssl_ctx != null)
+            return this.ssl_ctx;
         // Create key manager
         KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
         keyManagerFactory.init(key_store, keystore_password.toCharArray());
@@ -378,7 +408,7 @@ protected SSLContext getContext() throws Exception {
         // Initialize SSLContext
         SSLContext sslContext=SSLContext.getInstance(""TLSv1"");
         sslContext.init(km, tm, null);
-        return sslContext;
+        return this.ssl_ctx=sslContext;
     }
 
 ",2019-06-04T12:48:00Z,49
"@@ -285,7 +285,7 @@
 
     <target name=""copy-conf-dir"" description=""Copies the relevant files from ./conf to ./classes"">
         <copy todir=""${compile.dir}/"">
-            <fileset dir=""${conf.dir}"" includes=""*.xml, *.properties, *.btm"">
+            <fileset dir=""${conf.dir}"" includes=""*.xml, *.properties, *.btm *.jks"">
                 <include name=""scripts/**""/>
                 <exclude name=""log4j*.xml""/>
                 <exclude name=""settings.xml""/>
@@ -358,7 +358,7 @@
              basedir=""${compile.dir}""
              manifest=""${conf.dir}/MANIFEST.MF""
              includes=""org/jgroups/**"">
-            <fileset dir=""${conf.dir}"" includes=""*.xml, jg-messages*.properties, JGROUPS_VERSION.properties"">
+            <fileset dir=""${conf.dir}"" includes=""*.xml, jg-messages*.properties, JGROUPS_VERSION.properties *.jks"">
                 <exclude name=""log4j*.xml""/>
                 <exclude name=""settings.xml""/>
             </fileset>",2018-06-13T11:31:31Z,50
"@@ -349,13 +349,13 @@ protected void suspect(List<Address> suspects) {
 
         num_suspect_events+=suspects.size();
 
-        final List<Address> eligible_mbrs=new ArrayList<>();
+        final List<Address> eligible_mbrs;
         synchronized(this) {
             for(Address suspect: suspects) {
                 suspect_history.add(new Tuple<>(suspect, System.currentTimeMillis())); // need wall clock time
                 suspected_mbrs.add(suspect);
             }
-            eligible_mbrs.addAll(members);
+            eligible_mbrs=new ArrayList<>(members);
             eligible_mbrs.removeAll(suspected_mbrs);
             has_suspected_mbrs=!suspected_mbrs.isEmpty();
         }",2018-06-13T11:31:31Z,51
"@@ -51,8 +51,10 @@ public class MERGE3 extends Protocol {
     protected int     max_participants_in_merge=100;
 
     @Property(description=""If true, only coordinators periodically check view consistency, otherwise everybody runs "" +
-      ""this task (https://issues.jboss.org/browse/JGRP-2092). Might get removed without notice."")
-    protected boolean only_coords_run_consistency_checker=false;
+      ""this task (https://issues.jboss.org/browse/JGRP-2092). Might get removed without notice."",
+      deprecatedMessage=""false by default; everybody runs periodic consistency checks"")
+    @Deprecated
+    protected boolean only_coords_run_consistency_checker;
 
     /* ---------------------------------------------- JMX -------------------------------------------------------- */
     @Property(description=""Interval (in ms) after which we check for view inconsistencies"")
@@ -245,18 +247,12 @@ public Object down(Event evt) {
                     max_participants_in_merge=Math.max(100, view.size() / 3);
 
                 startInfoSender();
-                if(only_coords_run_consistency_checker == false)
-                    startViewConsistencyChecker();
+                startViewConsistencyChecker();
 
                 Address coord=view.getCoord();
-                if(Objects.equals(coord, local_addr)) {
+                if(Objects.equals(coord, local_addr))
                     is_coord=true;
-                    if(only_coords_run_consistency_checker)
-                        startViewConsistencyChecker(); // start task if we became coordinator (doesn't start if already running)
-                }
                 else {
-                    // if we were coordinator, but are no longer, stop task. this happens e.g. when we merge and someone
-                    // else becomes the new coordinator of the merged group
                     is_coord=false;
                     clearViews();
                 }
@@ -440,31 +436,14 @@ public void run() {
         }
 
         protected void _run() {
-            SortedSet<Address> coords=new TreeSet<>();
-
-            // Only add view creators which *are* actually in the set as well, e.g.
-            // A|4: {A,B,C} and
-            // B|4: {D} would only add A to the coords list. A is a real coordinator
+            SortedSet<Address>       coords=new TreeSet<>();
             Map<ViewId,Set<Address>> converted_views=convertViews();
-            for(Map.Entry<ViewId,Set<Address>> entry: converted_views.entrySet()) {
-                Address coord=entry.getKey().getCreator();
-                Set<Address> members=entry.getValue();
-                if(only_coords_run_consistency_checker && members != null && members.contains(coord))
-                    coords.add(coord);
-                else
-                    coords.add(coord);
-            }
 
-            Address merge_leader=coords.isEmpty() ? null : coords.first();
-            if(merge_leader == null || local_addr == null || !merge_leader.equals(local_addr)) {
-                log.trace(""%s: I won't be the merge leader (merge leader is %s)"", local_addr, merge_leader);
-                return;
-            }
-
-            log.debug(""%s: I will be the merge leader"", local_addr);
+            converted_views.keySet().stream().map(ViewId::getCreator).forEach(coords::add);
 
             // add merge participants
-            coords.addAll(converted_views.values().stream().filter(set -> !set.isEmpty()).map(set -> set.iterator().next()).collect(Collectors.toList()));
+            coords.addAll(converted_views.values().stream().filter(set -> !set.isEmpty())
+                            .map(set -> set.iterator().next()).collect(Collectors.toList()));
 
             if(coords.size() <= 1) {
                 log.trace(""%s: cancelling merge as we only have 1 coordinator: %s"", local_addr, coords);
@@ -474,13 +453,7 @@ protected void _run() {
 
             if(max_participants_in_merge > 0 && coords.size() > max_participants_in_merge) {
                 int old_size=coords.size();
-                for(Iterator<Address> it=coords.iterator(); it.hasNext();) {
-                    Address next=it.next();
-                    if(next.equals(merge_leader))
-                        continue;
-                    if(coords.size() > max_participants_in_merge)
-                        it.remove();
-                }
+                coords.removeIf(next -> coords.size() > max_participants_in_merge);
                 log.trace(""%s: reduced %d coords to %d"", local_addr, old_size, max_participants_in_merge);
             }
 ",2018-06-13T11:31:31Z,52
"@@ -139,6 +139,8 @@ public void init() throws Exception {
         catch(FileNotFoundException not_found) {
             input=Util.getResourceAsStream(keystore_name, getClass());
         }
+        if(input == null)
+            throw new FileNotFoundException(keystore_name);
         key_store.load(input, keystore_password.toCharArray());
         if(session_verifier_class != null) {
             Class<? extends SessionVerifier> verifier_class=Util.loadClass(session_verifier_class, getClass());",2018-06-13T11:31:31Z,49
"@@ -239,9 +239,7 @@ protected static Map<Address,Collection<Address>> determineMergeCoords(Map<Addre
            Map<Address,Collection<Address>> retval=new HashMap<>();
            for(View view: views.values()) {
                Address coord=view.getCreator();
-               Collection<Address> members=retval.get(coord);
-               if(members == null)
-                   retval.put(coord, members=new ArrayList<>());
+               Collection<Address> members=retval.computeIfAbsent(coord, k -> new ArrayList<>());
                for(Address mbr: view.getMembersRaw())
                    if(!members.contains(mbr))
                        members.add(mbr);",2018-06-13T11:31:31Z,53
"@@ -2562,8 +2562,6 @@ public static Collection<Address> determineMergeCoords(Map<Address,View> map) {
     /**
      * Similar to {@link #determineMergeCoords(java.util.Map)} but only actual coordinators are counted: an actual
      * coord is when the sender of a view is the first member of that view
-     * @param map
-     * @return
      */
     public static Collection<Address> determineActualMergeCoords(Map<Address,View> map) {
         Set<Address> retval=new HashSet<>();
@@ -2620,6 +2618,18 @@ public static <T> T pickRandomElement(List<T> list) {
         return list.get(index);
     }
 
+    public static <T> T pickRandomElement(Set<T> set) {
+        if(set == null || set.isEmpty()) return null;
+        int size=set.size();
+        int random=(int)Util.random(size)-1;
+        for(Iterator<T> it=set.iterator(); it.hasNext();) {
+            T el=it.next();
+            if(random-- <= 0)
+                return el;
+        }
+        return null;
+    }
+
     public static <T> T pickRandomElement(T[] array) {
         if(array == null) return null;
         int size=array.length;",2018-06-13T11:31:31Z,54
"@@ -11,9 +11,6 @@
 import org.testng.annotations.Test;
 
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.util.Collections;
 
 /**
  * Tests graceful leaving of the coordinator and second-in-line in a 10 node cluster with ASYM_ENCRYPT configured
@@ -22,18 +19,16 @@
  */
 @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
 public class ASYM_ENCRYPT_LeaveTest {
-    // protected static final String CONFIG=""asym-ssl.xml"";
     protected static final String      KEYSTORE=""my-keystore.jks"";
     protected static final String      KEYSTORE_PWD=""password"";
     protected static final int         NUM=10;
-    protected static final int         BIND_PORT=7600;
     protected static final InetAddress LOOPBACK;
 
     static {
         try {
             LOOPBACK=Util.getLocalhost();
         }
-        catch(UnknownHostException e) {
+        catch(Exception e) {
             throw new RuntimeException(e);
         }
     }
@@ -47,9 +42,7 @@ public class ASYM_ENCRYPT_LeaveTest {
     protected void setup() throws Exception {
         for(int i=0; i < channels.length; i++) {
             channels[i]=create(String.valueOf(i+1)).connect(ASYM_ENCRYPT_LeaveTest.class.getSimpleName());
-            if(i == 0)
-                Util.sleep(2000);
-            else Util.sleep(500);
+            Util.sleep(i == 0? 2000 : 1000);
         }
         Util.waitUntilAllChannelsHaveSameView(10000, 1000, channels);
     }
@@ -71,15 +64,7 @@ public void testGracefulLeave() throws Exception {
         System.arraycopy(channels, 2, remaining_channels, 0, channels.length-2);
 
         Util.close(channels[0], channels[1]);
-
-       /* new Thread(() -> {
-            Util.sleep(500);
-            Util.close(channels[1]);
-        }).start();
-        Util.close(channels[0]);*/
-
-
-        Util.waitUntilAllChannelsHaveSameView(10000, 1000, remaining_channels);
+        Util.waitUntilAllChannelsHaveSameView(20000, 1000, remaining_channels);
         for(int i=0; i < remaining_channels.length; i++)
             System.out.printf(""%-4s: view is %s\n"", remaining_channels[i].getAddress(), remaining_channels[i].getView());
     }
@@ -89,11 +74,10 @@ public void testGracefulLeave() throws Exception {
 
     /** Creates a channel with a config similar to ./conf/asym-ssl.xml */
     protected static JChannel create(String name) throws Exception {
-        // return new JChannel(CONFIG).name(name);
         return new JChannel(
-          new TCP().setBindAddress(LOOPBACK).setBindPort(BIND_PORT),
-          new TCPPING().portRange(10).initialHosts(Collections.singleton(new InetSocketAddress(LOOPBACK, BIND_PORT))),
-          new MERGE3(),
+          new TCP().setBindAddress(LOOPBACK), // .setBindPort(BIND_PORT),
+          new MPING(), // new TCPPING().portRange(10).initialHosts(Collections.singleton(new InetSocketAddress(LOOPBACK, BIND_PORT))),
+          new MERGE3().setMinInterval(2000).setMaxInterval(5000),
           new FD_SOCK(),
           new FD_ALL(),
           new VERIFY_SUSPECT(),",2018-06-13T11:31:31Z,55
"@@ -4,7 +4,6 @@
 import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK2;
 import org.jgroups.protocols.pbcast.STABLE;
-import org.jgroups.stack.Protocol;
 import org.jgroups.stack.ProtocolStack;
 import org.jgroups.util.Util;
 import org.testng.annotations.AfterMethod;
@@ -37,10 +36,9 @@ private static JChannel createChannel(String channelName, String mech, String us
             sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
         }
         sasl.setLevel(""trace"");
-        GMS gms = new GMS();
-        gms.setJoinTimeout(3000);
-        return new JChannel(new Protocol[] { new SHARED_LOOPBACK(), new PING(), new MERGE3(), new NAKACK2(),
-                new UNICAST3(), new STABLE(), sasl, gms }).name(channelName);
+        GMS gms = new GMS().joinTimeout(3000);
+        return new JChannel(new SHARED_LOOPBACK(), new PING(), new MERGE3(), new NAKACK2(),
+                            new UNICAST3(), new STABLE(), sasl, gms).name(channelName);
     }
 
     public void testSASLDigestMD5() throws Exception {
@@ -76,28 +74,27 @@ public void testSASLDigestMD5Merge() throws Exception {
         assertTrue(checkViewSize(1, a, b));
         dropDiscard(a, b);
         mergePartitions(a, b);
-        for(int i = 0; i < 10 && !checkViewSize(2, a, b); i++) {
-            Util.sleep(500);
-        }
+        for(int i = 0; i < 10 && !checkViewSize(2, a, b); i++)
+            Util.sleep(1000);
         assertTrue(viewContains(a.getView(), a, b));
         assertTrue(viewContains(b.getView(), a, b));
     }
 
-    private boolean viewContains(View view, JChannel... channels) {
+    private static boolean viewContains(View view, JChannel... channels) {
         boolean b = true;
         for (JChannel ch : channels) {
             b = b && view.containsMember(ch.getAddress());
         }
         return b;
     }
 
-    private void dropDiscard(JChannel... channels) {
+    private static void dropDiscard(JChannel... channels) {
         for (JChannel ch : channels) {
             ch.getProtocolStack().removeProtocol(DISCARD.class);
         }
     }
 
-    private boolean checkViewSize(int expectedSize, JChannel... channels) {
+    private static boolean checkViewSize(int expectedSize, JChannel... channels) {
         boolean b = true;
         for (JChannel ch : channels) {
             b = b && ch.getView().size() == expectedSize;
@@ -113,33 +110,26 @@ public void cleanup() {
 
     private static void createPartitions(JChannel... channels) throws Exception {
         for (JChannel ch : channels) {
-            DISCARD discard = new DISCARD();
-            discard.setDiscardAll(true);
+            DISCARD discard = new DISCARD().setDiscardAll(true);
             ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
         }
 
         for (JChannel ch : channels) {
             View view = View.create(ch.getAddress(), 10, ch.getAddress());
-            GMS gms = (GMS) ch.getProtocolStack().findProtocol(GMS.class);
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
             gms.installView(view);
         }
     }
 
     private static void mergePartitions(JChannel... channels) throws Exception {
-        Membership membership = new Membership();
-        for (JChannel ch : channels) {
-            membership.add(ch.getAddress());
-        }
-        membership.sort();
-        Address leaderAddress = membership.elementAt(0);
-        JChannel leader = findChannelByAddress(leaderAddress, channels);
-        GMS gms = (GMS) leader.getProtocolStack().findProtocol(GMS.class);
-        gms.setLevel(""trace"");
         Map<Address, View> views =new HashMap<>();
-        for (JChannel ch : channels) {
+        for (JChannel ch : channels)
             views.put(ch.getAddress(), ch.getView());
+        for(JChannel ch: channels) {
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class).setLevel(""trace"");
+            gms.up(new Event(Event.MERGE, views));
+            Util.sleep(2000);
         }
-        gms.up(new Event(Event.MERGE, views));
     }
 
     private static JChannel findChannelByAddress(Address address, JChannel... channels) {
@@ -153,7 +143,7 @@ private static JChannel findChannelByAddress(Address address, JChannel... channe
 
     private static void print(JChannel... channels) {
         for (JChannel ch : channels) {
-            System.out.println(ch.getName() + "": "" + ch.getView());
+            System.out.println(ch.getAddress() + "": "" + ch.getView());
         }
     }
 ",2018-06-13T11:31:31Z,56
"@@ -77,7 +77,7 @@ public void testSplitWithNoCoordinator() throws Exception {
 
 
 
-    protected View createView(int id, JChannel ... mbrs) {
+    protected static View createView(int id, JChannel... mbrs) {
         Address[] members=new Address[mbrs.length];
         for(int i=0; i < mbrs.length; i++)
             members[i]=mbrs[i].getAddress();
@@ -86,7 +86,7 @@ protected View createView(int id, JChannel ... mbrs) {
 
 
 
-    protected JChannel createChannel(String name) throws Exception {
+    protected static JChannel createChannel(String name) throws Exception {
         return new JChannel(new SHARED_LOOPBACK(),
                             new SHARED_LOOPBACK_PING(),
                             new MERGE3().setValue(""min_interval"", 3000).setValue(""max_interval"", 4000).setValue(""check_interval"", 7000),
@@ -106,14 +106,14 @@ protected JChannel createChannel(String name) throws Exception {
 
 
 
-    protected void injectView(View view, JChannel ... channels) {
+    protected static void injectView(View view, JChannel... channels) {
         for(JChannel ch: channels) {
             GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
             gms.installView(view);
         }
     }
 
-    protected void checkInconsistencies(JChannel ... channels) {
+    protected static void checkInconsistencies(JChannel... channels) {
         for(JChannel ch: channels) {
             MERGE3 merge=ch.getProtocolStack().findProtocol(MERGE3.class);
             merge.checkInconsistencies();",2018-06-13T11:31:31Z,57
"@@ -19,7 +19,7 @@
 
 
 /**
- * Tests https://issues.jboss.org/browse/JGRP-2070:
+ * Tests merging with a dead merge leader https://issues.jboss.org/browse/JGRP-2276:
  */
 @Test(groups=Global.FUNCTIONAL,sequential=true)
 public class MergeTest6 {
@@ -58,9 +58,9 @@ public void testViewInconsistency() throws Exception {
             System.out.printf(""%s: %s\n"", ch.getAddress(), ch.getView());
 
         ProtocolStack stack=seven.getProtocolStack();
-        Protocol drop_view=new DropView();
+        Protocol drop_view=new DropView().setAddress(seven.getAddress());
 
-        stack.insertProtocol(drop_view, ProtocolStack.Position.BELOW, GMS.class);
+        stack.insertProtocol(drop_view, ProtocolStack.Position.BELOW, NAKACK2.class); // GMS.class);
 
         Util.close(two);
 
@@ -89,7 +89,8 @@ public void testViewInconsistency() throws Exception {
         stack.removeProtocol(drop_view);
 
         System.out.println(""-- waiting for merge to heal partition"");
-        Util.waitUntilAllChannelsHaveSameView(150000, 1000, three,four,five,six,seven);
+        Util.waitUntilAllChannelsHaveSameView(1500000, 1000, three,four,five,six,seven);
+        Stream.of(three,four,five,six,seven).forEach(ch -> System.out.printf(""%s: %s\n"", ch.getAddress(), ch.getView()));
     }
 
 
@@ -108,7 +109,6 @@ protected static JChannel createChannel(int num) throws Exception {
           new SHARED_LOOPBACK(),
           new SHARED_LOOPBACK_PING(),
           new MERGE3().setMinInterval(3000).setMaxInterval(4000).setValue(""check_interval"", 7000),
-
           new FD_ALL().setValue(""timeout"", 8000).setValue(""interval"", 3000)
             .setValue(""timeout_check_interval"", 10000),
 
@@ -124,6 +124,7 @@ protected static JChannel createChannel(int num) throws Exception {
             .setValue(""view_ack_collection_timeout"", 50)
             .setValue(""log_collect_msgs"", false))
           .name(String.valueOf(num));
+        // the address generator makes sure that 2's UUID is lower than 3's UUID, so 2 is chose as merge leader
         ch.addAddressGenerator(() -> new UUID(0, num));
         return ch.connect(""MergeTest6"");
     }
@@ -148,12 +149,25 @@ protected static void checkInconsistencies(JChannel... channels) {
 
     /** Drops a received VIEW message (needs to be placed below GMS) */
     protected static class DropView extends Protocol {
+        protected Address local_addr;
+        protected boolean first_view_received;
+
+        protected DropView setAddress(Address addr) {this.local_addr=addr; return this;}
+
+        public Object down(Event evt) {
+            if(evt.type() == Event.SET_LOCAL_ADDRESS)
+                local_addr=evt.arg();
+            return down_prot.down(evt);
+        }
 
         public Object up(Message msg) {
             GMS.GmsHeader hdr=msg.getHeader(GMS_ID); View view;
             if(hdr != null && hdr.getType() == GMS.GmsHeader.VIEW && (view=readView(msg)) != null) {
-                System.out.printf(""%s: dropped view %s\n"", getName(), view);
-                return null;
+                if(!first_view_received) {
+                    System.out.printf(""%s: dropped view %s\n"", local_addr, view);
+                    first_view_received=true;
+                    return null;
+                }
             }
             return up_prot.up(msg);
         }
@@ -163,8 +177,11 @@ public void up(MessageBatch batch) {
                 GMS.GmsHeader hdr=msg.getHeader(GMS_ID); View view;
                 if(hdr != null && hdr.getType() == GMS.GmsHeader.VIEW) {
                     view=readView(msg);
-                    batch.remove(msg);
-                    System.out.printf(""%s: dropped view %s (in message batch)\n"", getName(), view);
+                    if(!first_view_received) {
+                        first_view_received=true;
+                        batch.remove(msg);
+                        System.out.printf(""%s: dropped view %s (in message batch)\n"", local_addr, view);
+                    }
                 }
             }
             if(!batch.isEmpty())",2018-06-13T11:31:31Z,58
"@@ -41,7 +41,7 @@ public class OrderingTest {
         }
         Util.waitUntilAllChannelsHaveSameView(10000, 500, channels);
         for(JChannel ch: channels) {
-            SHUFFLE shuffle=new SHUFFLE();
+            SHUFFLE shuffle=new SHUFFLE(); // reorders messages
             ch.getProtocolStack().insertProtocol(shuffle, ProtocolStack.Position.ABOVE, Discovery.class);
             shuffle.init();
         }
@@ -56,7 +56,6 @@ public class OrderingTest {
     protected static JChannel createChannel(int index) throws Exception {
         return new JChannel(new SHARED_LOOPBACK(),
                             new SHARED_LOOPBACK_PING(),
-                            // new SHUFFLE(), // reorders messages and message batches
                             new NAKACK2().setValue(""use_mcast_xmit"", false).setValue(""discard_delivered_msgs"", true),
                             new UNICAST3(),
                             new STABLE().setValue(""max_bytes"", 50000).setValue(""desired_avg_gossip"", 1000),
@@ -68,6 +67,7 @@ protected static JChannel createChannel(int index) throws Exception {
     }
 
 
+    @Test(invocationCount=100)
     public void testMulticastFIFOOrdering() throws Exception {
         System.out.println(""\n-- sending "" + NUM_MSGS + "" messages"");
         final CountDownLatch latch=new CountDownLatch(1);",2018-06-13T11:31:31Z,59
"@@ -980,6 +980,17 @@ public void testPickRandomElement2() {
         assert list.isEmpty();
     }
 
+    public void testPickRandomElementFromSet() {
+        Set<Integer> set=new TreeSet<>();
+        for(int i=10; i > 0; i--)
+            set.add(i);
+
+        for(int i=0; i < 100; i++) {
+            Integer n=Util.pickRandomElement(set);
+            assert n >= 0 && n <= 10 : ""n: "" + n;
+        }
+    }
+
 
     public void testPickNext() {
         List<Integer> list=new ArrayList<>(10);",2018-06-13T11:31:31Z,60
"@@ -285,7 +285,7 @@
 
     <target name=""copy-conf-dir"" description=""Copies the relevant files from ./conf to ./classes"">
         <copy todir=""${compile.dir}/"">
-            <fileset dir=""${conf.dir}"" includes=""*.xml, *.properties, *.btm"">
+            <fileset dir=""${conf.dir}"" includes=""*.xml, *.properties, *.btm *.jks"">
                 <include name=""scripts/**""/>
                 <exclude name=""log4j*.xml""/>
                 <exclude name=""settings.xml""/>
@@ -358,7 +358,7 @@
              basedir=""${compile.dir}""
              manifest=""${conf.dir}/MANIFEST.MF""
              includes=""org/jgroups/**"">
-            <fileset dir=""${conf.dir}"" includes=""*.xml, jg-messages*.properties, JGROUPS_VERSION.properties"">
+            <fileset dir=""${conf.dir}"" includes=""*.xml, jg-messages*.properties, JGROUPS_VERSION.properties *.jks"">
                 <exclude name=""log4j*.xml""/>
                 <exclude name=""settings.xml""/>
             </fileset>",2018-06-13T11:31:31Z,50
"@@ -349,13 +349,13 @@ protected void suspect(List<Address> suspects) {
 
         num_suspect_events+=suspects.size();
 
-        final List<Address> eligible_mbrs=new ArrayList<>();
+        final List<Address> eligible_mbrs;
         synchronized(this) {
             for(Address suspect: suspects) {
                 suspect_history.add(new Tuple<>(suspect, System.currentTimeMillis())); // need wall clock time
                 suspected_mbrs.add(suspect);
             }
-            eligible_mbrs.addAll(members);
+            eligible_mbrs=new ArrayList<>(members);
             eligible_mbrs.removeAll(suspected_mbrs);
             has_suspected_mbrs=!suspected_mbrs.isEmpty();
         }",2018-06-13T11:31:31Z,51
"@@ -51,8 +51,10 @@ public class MERGE3 extends Protocol {
     protected int     max_participants_in_merge=100;
 
     @Property(description=""If true, only coordinators periodically check view consistency, otherwise everybody runs "" +
-      ""this task (https://issues.jboss.org/browse/JGRP-2092). Might get removed without notice."")
-    protected boolean only_coords_run_consistency_checker=false;
+      ""this task (https://issues.jboss.org/browse/JGRP-2092). Might get removed without notice."",
+      deprecatedMessage=""false by default; everybody runs periodic consistency checks"")
+    @Deprecated
+    protected boolean only_coords_run_consistency_checker;
 
     /* ---------------------------------------------- JMX -------------------------------------------------------- */
     @Property(description=""Interval (in ms) after which we check for view inconsistencies"")
@@ -245,18 +247,12 @@ public Object down(Event evt) {
                     max_participants_in_merge=Math.max(100, view.size() / 3);
 
                 startInfoSender();
-                if(only_coords_run_consistency_checker == false)
-                    startViewConsistencyChecker();
+                startViewConsistencyChecker();
 
                 Address coord=view.getCoord();
-                if(Objects.equals(coord, local_addr)) {
+                if(Objects.equals(coord, local_addr))
                     is_coord=true;
-                    if(only_coords_run_consistency_checker)
-                        startViewConsistencyChecker(); // start task if we became coordinator (doesn't start if already running)
-                }
                 else {
-                    // if we were coordinator, but are no longer, stop task. this happens e.g. when we merge and someone
-                    // else becomes the new coordinator of the merged group
                     is_coord=false;
                     clearViews();
                 }
@@ -440,31 +436,14 @@ public void run() {
         }
 
         protected void _run() {
-            SortedSet<Address> coords=new TreeSet<>();
-
-            // Only add view creators which *are* actually in the set as well, e.g.
-            // A|4: {A,B,C} and
-            // B|4: {D} would only add A to the coords list. A is a real coordinator
+            SortedSet<Address>       coords=new TreeSet<>();
             Map<ViewId,Set<Address>> converted_views=convertViews();
-            for(Map.Entry<ViewId,Set<Address>> entry: converted_views.entrySet()) {
-                Address coord=entry.getKey().getCreator();
-                Set<Address> members=entry.getValue();
-                if(only_coords_run_consistency_checker && members != null && members.contains(coord))
-                    coords.add(coord);
-                else
-                    coords.add(coord);
-            }
 
-            Address merge_leader=coords.isEmpty() ? null : coords.first();
-            if(merge_leader == null || local_addr == null || !merge_leader.equals(local_addr)) {
-                log.trace(""%s: I won't be the merge leader (merge leader is %s)"", local_addr, merge_leader);
-                return;
-            }
-
-            log.debug(""%s: I will be the merge leader"", local_addr);
+            converted_views.keySet().stream().map(ViewId::getCreator).forEach(coords::add);
 
             // add merge participants
-            coords.addAll(converted_views.values().stream().filter(set -> !set.isEmpty()).map(set -> set.iterator().next()).collect(Collectors.toList()));
+            coords.addAll(converted_views.values().stream().filter(set -> !set.isEmpty())
+                            .map(set -> set.iterator().next()).collect(Collectors.toList()));
 
             if(coords.size() <= 1) {
                 log.trace(""%s: cancelling merge as we only have 1 coordinator: %s"", local_addr, coords);
@@ -474,13 +453,7 @@ protected void _run() {
 
             if(max_participants_in_merge > 0 && coords.size() > max_participants_in_merge) {
                 int old_size=coords.size();
-                for(Iterator<Address> it=coords.iterator(); it.hasNext();) {
-                    Address next=it.next();
-                    if(next.equals(merge_leader))
-                        continue;
-                    if(coords.size() > max_participants_in_merge)
-                        it.remove();
-                }
+                coords.removeIf(next -> coords.size() > max_participants_in_merge);
                 log.trace(""%s: reduced %d coords to %d"", local_addr, old_size, max_participants_in_merge);
             }
 ",2018-06-13T11:31:31Z,52
"@@ -139,6 +139,8 @@ public void init() throws Exception {
         catch(FileNotFoundException not_found) {
             input=Util.getResourceAsStream(keystore_name, getClass());
         }
+        if(input == null)
+            throw new FileNotFoundException(keystore_name);
         key_store.load(input, keystore_password.toCharArray());
         if(session_verifier_class != null) {
             Class<? extends SessionVerifier> verifier_class=Util.loadClass(session_verifier_class, getClass());",2018-06-13T11:31:31Z,49
"@@ -239,9 +239,7 @@ protected static Map<Address,Collection<Address>> determineMergeCoords(Map<Addre
            Map<Address,Collection<Address>> retval=new HashMap<>();
            for(View view: views.values()) {
                Address coord=view.getCreator();
-               Collection<Address> members=retval.get(coord);
-               if(members == null)
-                   retval.put(coord, members=new ArrayList<>());
+               Collection<Address> members=retval.computeIfAbsent(coord, k -> new ArrayList<>());
                for(Address mbr: view.getMembersRaw())
                    if(!members.contains(mbr))
                        members.add(mbr);",2018-06-13T11:31:31Z,53
"@@ -2562,8 +2562,6 @@ public static Collection<Address> determineMergeCoords(Map<Address,View> map) {
     /**
      * Similar to {@link #determineMergeCoords(java.util.Map)} but only actual coordinators are counted: an actual
      * coord is when the sender of a view is the first member of that view
-     * @param map
-     * @return
      */
     public static Collection<Address> determineActualMergeCoords(Map<Address,View> map) {
         Set<Address> retval=new HashSet<>();
@@ -2620,6 +2618,18 @@ public static <T> T pickRandomElement(List<T> list) {
         return list.get(index);
     }
 
+    public static <T> T pickRandomElement(Set<T> set) {
+        if(set == null || set.isEmpty()) return null;
+        int size=set.size();
+        int random=(int)Util.random(size)-1;
+        for(Iterator<T> it=set.iterator(); it.hasNext();) {
+            T el=it.next();
+            if(random-- <= 0)
+                return el;
+        }
+        return null;
+    }
+
     public static <T> T pickRandomElement(T[] array) {
         if(array == null) return null;
         int size=array.length;",2018-06-13T11:31:31Z,54
"@@ -11,9 +11,6 @@
 import org.testng.annotations.Test;
 
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.util.Collections;
 
 /**
  * Tests graceful leaving of the coordinator and second-in-line in a 10 node cluster with ASYM_ENCRYPT configured
@@ -22,18 +19,16 @@
  */
 @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
 public class ASYM_ENCRYPT_LeaveTest {
-    // protected static final String CONFIG=""asym-ssl.xml"";
     protected static final String      KEYSTORE=""my-keystore.jks"";
     protected static final String      KEYSTORE_PWD=""password"";
     protected static final int         NUM=10;
-    protected static final int         BIND_PORT=7600;
     protected static final InetAddress LOOPBACK;
 
     static {
         try {
             LOOPBACK=Util.getLocalhost();
         }
-        catch(UnknownHostException e) {
+        catch(Exception e) {
             throw new RuntimeException(e);
         }
     }
@@ -47,9 +42,7 @@ public class ASYM_ENCRYPT_LeaveTest {
     protected void setup() throws Exception {
         for(int i=0; i < channels.length; i++) {
             channels[i]=create(String.valueOf(i+1)).connect(ASYM_ENCRYPT_LeaveTest.class.getSimpleName());
-            if(i == 0)
-                Util.sleep(2000);
-            else Util.sleep(500);
+            Util.sleep(i == 0? 2000 : 1000);
         }
         Util.waitUntilAllChannelsHaveSameView(10000, 1000, channels);
     }
@@ -71,15 +64,7 @@ public void testGracefulLeave() throws Exception {
         System.arraycopy(channels, 2, remaining_channels, 0, channels.length-2);
 
         Util.close(channels[0], channels[1]);
-
-       /* new Thread(() -> {
-            Util.sleep(500);
-            Util.close(channels[1]);
-        }).start();
-        Util.close(channels[0]);*/
-
-
-        Util.waitUntilAllChannelsHaveSameView(10000, 1000, remaining_channels);
+        Util.waitUntilAllChannelsHaveSameView(20000, 1000, remaining_channels);
         for(int i=0; i < remaining_channels.length; i++)
             System.out.printf(""%-4s: view is %s\n"", remaining_channels[i].getAddress(), remaining_channels[i].getView());
     }
@@ -89,11 +74,10 @@ public void testGracefulLeave() throws Exception {
 
     /** Creates a channel with a config similar to ./conf/asym-ssl.xml */
     protected static JChannel create(String name) throws Exception {
-        // return new JChannel(CONFIG).name(name);
         return new JChannel(
-          new TCP().setBindAddress(LOOPBACK).setBindPort(BIND_PORT),
-          new TCPPING().portRange(10).initialHosts(Collections.singleton(new InetSocketAddress(LOOPBACK, BIND_PORT))),
-          new MERGE3(),
+          new TCP().setBindAddress(LOOPBACK), // .setBindPort(BIND_PORT),
+          new MPING(), // new TCPPING().portRange(10).initialHosts(Collections.singleton(new InetSocketAddress(LOOPBACK, BIND_PORT))),
+          new MERGE3().setMinInterval(2000).setMaxInterval(5000),
           new FD_SOCK(),
           new FD_ALL(),
           new VERIFY_SUSPECT(),",2018-06-13T11:31:31Z,55
"@@ -4,7 +4,6 @@
 import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK2;
 import org.jgroups.protocols.pbcast.STABLE;
-import org.jgroups.stack.Protocol;
 import org.jgroups.stack.ProtocolStack;
 import org.jgroups.util.Util;
 import org.testng.annotations.AfterMethod;
@@ -37,10 +36,9 @@ private static JChannel createChannel(String channelName, String mech, String us
             sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
         }
         sasl.setLevel(""trace"");
-        GMS gms = new GMS();
-        gms.setJoinTimeout(3000);
-        return new JChannel(new Protocol[] { new SHARED_LOOPBACK(), new PING(), new MERGE3(), new NAKACK2(),
-                new UNICAST3(), new STABLE(), sasl, gms }).name(channelName);
+        GMS gms = new GMS().joinTimeout(3000);
+        return new JChannel(new SHARED_LOOPBACK(), new PING(), new MERGE3(), new NAKACK2(),
+                            new UNICAST3(), new STABLE(), sasl, gms).name(channelName);
     }
 
     public void testSASLDigestMD5() throws Exception {
@@ -76,28 +74,27 @@ public void testSASLDigestMD5Merge() throws Exception {
         assertTrue(checkViewSize(1, a, b));
         dropDiscard(a, b);
         mergePartitions(a, b);
-        for(int i = 0; i < 10 && !checkViewSize(2, a, b); i++) {
-            Util.sleep(500);
-        }
+        for(int i = 0; i < 10 && !checkViewSize(2, a, b); i++)
+            Util.sleep(1000);
         assertTrue(viewContains(a.getView(), a, b));
         assertTrue(viewContains(b.getView(), a, b));
     }
 
-    private boolean viewContains(View view, JChannel... channels) {
+    private static boolean viewContains(View view, JChannel... channels) {
         boolean b = true;
         for (JChannel ch : channels) {
             b = b && view.containsMember(ch.getAddress());
         }
         return b;
     }
 
-    private void dropDiscard(JChannel... channels) {
+    private static void dropDiscard(JChannel... channels) {
         for (JChannel ch : channels) {
             ch.getProtocolStack().removeProtocol(DISCARD.class);
         }
     }
 
-    private boolean checkViewSize(int expectedSize, JChannel... channels) {
+    private static boolean checkViewSize(int expectedSize, JChannel... channels) {
         boolean b = true;
         for (JChannel ch : channels) {
             b = b && ch.getView().size() == expectedSize;
@@ -113,33 +110,26 @@ public void cleanup() {
 
     private static void createPartitions(JChannel... channels) throws Exception {
         for (JChannel ch : channels) {
-            DISCARD discard = new DISCARD();
-            discard.setDiscardAll(true);
+            DISCARD discard = new DISCARD().setDiscardAll(true);
             ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
         }
 
         for (JChannel ch : channels) {
             View view = View.create(ch.getAddress(), 10, ch.getAddress());
-            GMS gms = (GMS) ch.getProtocolStack().findProtocol(GMS.class);
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
             gms.installView(view);
         }
     }
 
     private static void mergePartitions(JChannel... channels) throws Exception {
-        Membership membership = new Membership();
-        for (JChannel ch : channels) {
-            membership.add(ch.getAddress());
-        }
-        membership.sort();
-        Address leaderAddress = membership.elementAt(0);
-        JChannel leader = findChannelByAddress(leaderAddress, channels);
-        GMS gms = (GMS) leader.getProtocolStack().findProtocol(GMS.class);
-        gms.setLevel(""trace"");
         Map<Address, View> views =new HashMap<>();
-        for (JChannel ch : channels) {
+        for (JChannel ch : channels)
             views.put(ch.getAddress(), ch.getView());
+        for(JChannel ch: channels) {
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class).setLevel(""trace"");
+            gms.up(new Event(Event.MERGE, views));
+            Util.sleep(2000);
         }
-        gms.up(new Event(Event.MERGE, views));
     }
 
     private static JChannel findChannelByAddress(Address address, JChannel... channels) {
@@ -153,7 +143,7 @@ private static JChannel findChannelByAddress(Address address, JChannel... channe
 
     private static void print(JChannel... channels) {
         for (JChannel ch : channels) {
-            System.out.println(ch.getName() + "": "" + ch.getView());
+            System.out.println(ch.getAddress() + "": "" + ch.getView());
         }
     }
 ",2018-06-13T11:31:31Z,56
"@@ -77,7 +77,7 @@ public void testSplitWithNoCoordinator() throws Exception {
 
 
 
-    protected View createView(int id, JChannel ... mbrs) {
+    protected static View createView(int id, JChannel... mbrs) {
         Address[] members=new Address[mbrs.length];
         for(int i=0; i < mbrs.length; i++)
             members[i]=mbrs[i].getAddress();
@@ -86,7 +86,7 @@ protected View createView(int id, JChannel ... mbrs) {
 
 
 
-    protected JChannel createChannel(String name) throws Exception {
+    protected static JChannel createChannel(String name) throws Exception {
         return new JChannel(new SHARED_LOOPBACK(),
                             new SHARED_LOOPBACK_PING(),
                             new MERGE3().setValue(""min_interval"", 3000).setValue(""max_interval"", 4000).setValue(""check_interval"", 7000),
@@ -106,14 +106,14 @@ protected JChannel createChannel(String name) throws Exception {
 
 
 
-    protected void injectView(View view, JChannel ... channels) {
+    protected static void injectView(View view, JChannel... channels) {
         for(JChannel ch: channels) {
             GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
             gms.installView(view);
         }
     }
 
-    protected void checkInconsistencies(JChannel ... channels) {
+    protected static void checkInconsistencies(JChannel... channels) {
         for(JChannel ch: channels) {
             MERGE3 merge=ch.getProtocolStack().findProtocol(MERGE3.class);
             merge.checkInconsistencies();",2018-06-13T11:31:31Z,57
"@@ -19,7 +19,7 @@
 
 
 /**
- * Tests https://issues.jboss.org/browse/JGRP-2070:
+ * Tests merging with a dead merge leader https://issues.jboss.org/browse/JGRP-2276:
  */
 @Test(groups=Global.FUNCTIONAL,sequential=true)
 public class MergeTest6 {
@@ -58,9 +58,9 @@ public void testViewInconsistency() throws Exception {
             System.out.printf(""%s: %s\n"", ch.getAddress(), ch.getView());
 
         ProtocolStack stack=seven.getProtocolStack();
-        Protocol drop_view=new DropView();
+        Protocol drop_view=new DropView().setAddress(seven.getAddress());
 
-        stack.insertProtocol(drop_view, ProtocolStack.Position.BELOW, GMS.class);
+        stack.insertProtocol(drop_view, ProtocolStack.Position.BELOW, NAKACK2.class); // GMS.class);
 
         Util.close(two);
 
@@ -89,7 +89,8 @@ public void testViewInconsistency() throws Exception {
         stack.removeProtocol(drop_view);
 
         System.out.println(""-- waiting for merge to heal partition"");
-        Util.waitUntilAllChannelsHaveSameView(150000, 1000, three,four,five,six,seven);
+        Util.waitUntilAllChannelsHaveSameView(1500000, 1000, three,four,five,six,seven);
+        Stream.of(three,four,five,six,seven).forEach(ch -> System.out.printf(""%s: %s\n"", ch.getAddress(), ch.getView()));
     }
 
 
@@ -108,7 +109,6 @@ protected static JChannel createChannel(int num) throws Exception {
           new SHARED_LOOPBACK(),
           new SHARED_LOOPBACK_PING(),
           new MERGE3().setMinInterval(3000).setMaxInterval(4000).setValue(""check_interval"", 7000),
-
           new FD_ALL().setValue(""timeout"", 8000).setValue(""interval"", 3000)
             .setValue(""timeout_check_interval"", 10000),
 
@@ -124,6 +124,7 @@ protected static JChannel createChannel(int num) throws Exception {
             .setValue(""view_ack_collection_timeout"", 50)
             .setValue(""log_collect_msgs"", false))
           .name(String.valueOf(num));
+        // the address generator makes sure that 2's UUID is lower than 3's UUID, so 2 is chose as merge leader
         ch.addAddressGenerator(() -> new UUID(0, num));
         return ch.connect(""MergeTest6"");
     }
@@ -148,12 +149,25 @@ protected static void checkInconsistencies(JChannel... channels) {
 
     /** Drops a received VIEW message (needs to be placed below GMS) */
     protected static class DropView extends Protocol {
+        protected Address local_addr;
+        protected boolean first_view_received;
+
+        protected DropView setAddress(Address addr) {this.local_addr=addr; return this;}
+
+        public Object down(Event evt) {
+            if(evt.type() == Event.SET_LOCAL_ADDRESS)
+                local_addr=evt.arg();
+            return down_prot.down(evt);
+        }
 
         public Object up(Message msg) {
             GMS.GmsHeader hdr=msg.getHeader(GMS_ID); View view;
             if(hdr != null && hdr.getType() == GMS.GmsHeader.VIEW && (view=readView(msg)) != null) {
-                System.out.printf(""%s: dropped view %s\n"", getName(), view);
-                return null;
+                if(!first_view_received) {
+                    System.out.printf(""%s: dropped view %s\n"", local_addr, view);
+                    first_view_received=true;
+                    return null;
+                }
             }
             return up_prot.up(msg);
         }
@@ -163,8 +177,11 @@ public void up(MessageBatch batch) {
                 GMS.GmsHeader hdr=msg.getHeader(GMS_ID); View view;
                 if(hdr != null && hdr.getType() == GMS.GmsHeader.VIEW) {
                     view=readView(msg);
-                    batch.remove(msg);
-                    System.out.printf(""%s: dropped view %s (in message batch)\n"", getName(), view);
+                    if(!first_view_received) {
+                        first_view_received=true;
+                        batch.remove(msg);
+                        System.out.printf(""%s: dropped view %s (in message batch)\n"", local_addr, view);
+                    }
                 }
             }
             if(!batch.isEmpty())",2018-06-13T11:31:31Z,58
"@@ -41,7 +41,7 @@ public class OrderingTest {
         }
         Util.waitUntilAllChannelsHaveSameView(10000, 500, channels);
         for(JChannel ch: channels) {
-            SHUFFLE shuffle=new SHUFFLE();
+            SHUFFLE shuffle=new SHUFFLE(); // reorders messages
             ch.getProtocolStack().insertProtocol(shuffle, ProtocolStack.Position.ABOVE, Discovery.class);
             shuffle.init();
         }
@@ -56,7 +56,6 @@ public class OrderingTest {
     protected static JChannel createChannel(int index) throws Exception {
         return new JChannel(new SHARED_LOOPBACK(),
                             new SHARED_LOOPBACK_PING(),
-                            // new SHUFFLE(), // reorders messages and message batches
                             new NAKACK2().setValue(""use_mcast_xmit"", false).setValue(""discard_delivered_msgs"", true),
                             new UNICAST3(),
                             new STABLE().setValue(""max_bytes"", 50000).setValue(""desired_avg_gossip"", 1000),
@@ -68,6 +67,7 @@ protected static JChannel createChannel(int index) throws Exception {
     }
 
 
+    @Test(invocationCount=100)
     public void testMulticastFIFOOrdering() throws Exception {
         System.out.println(""\n-- sending "" + NUM_MSGS + "" messages"");
         final CountDownLatch latch=new CountDownLatch(1);",2018-06-13T11:31:31Z,59
"@@ -980,6 +980,17 @@ public void testPickRandomElement2() {
         assert list.isEmpty();
     }
 
+    public void testPickRandomElementFromSet() {
+        Set<Integer> set=new TreeSet<>();
+        for(int i=10; i > 0; i--)
+            set.add(i);
+
+        for(int i=0; i < 100; i++) {
+            Integer n=Util.pickRandomElement(set);
+            assert n >= 0 && n <= 10 : ""n: "" + n;
+        }
+    }
+
 
     public void testPickNext() {
         List<Integer> list=new ArrayList<>(10);",2018-06-13T11:31:31Z,60
"@@ -1,11 +1,12 @@
 package org.jgroups.protocols;
 
-import org.jgroups.*;
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Global;
+import org.jgroups.View;
 import org.jgroups.annotations.LocalAddress;
 import org.jgroups.annotations.MBean;
 import org.jgroups.annotations.Property;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.stack.IpAddress;
 import org.jgroups.util.Runner;
 import org.jgroups.util.Tuple;
@@ -38,7 +39,6 @@
   ""(key server) to fetch a shared secret group key from the key server. That shared (symmetric) key is subsequently "" +
   ""used to encrypt communication between cluster members"")
 public class SSL_KEY_EXCHANGE extends KeyExchange {
-    protected static final short GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
 
     protected enum Type {
         SECRET_KEY_REQ,
@@ -57,17 +57,19 @@ public interface SessionVerifier {
         void verify(SSLSession session) throws SecurityException;
     }
 
-    @Property(description=""The port at which the key server is listening. If the port is not available, the next port "" +
-      ""will be probed, up to port+port_range. Used by the key server (server) to create an SSLServerSocket and "" +
-      ""by clients to connect to the key server."")
-    protected int             port=2157;
 
     @LocalAddress
     @Property(description=""Bind address for the server or client socket. "" +
       ""The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK"",
       systemProperty={Global.BIND_ADDR})
     protected InetAddress     bind_addr;
 
+    @Property(description=""The port at which the key server is listening. If the port is not available, the next port "" +
+      ""will be probed, up to port+port_range. Used by the key server (server) to create an SSLServerSocket and "" +
+      ""by clients to connect to the key server."")
+    protected int             port=2157;
+
+
     @Property(description=""The port range to probe"")
     protected int             port_range=5;
 
@@ -100,17 +102,43 @@ public interface SessionVerifier {
     protected String          session_verifier_arg;
 
 
+    protected SSLContext                   ssl_ctx;
     protected SSLServerSocket              srv_sock;
     protected Runner                       srv_sock_handler;
     protected KeyStore                     key_store;
     protected View                         view;
     protected SessionVerifier              session_verifier;
 
 
-    public SSL_KEY_EXCHANGE setKeystoreName(String name)    {this.keystore_name=name; return this;}
-    public SSL_KEY_EXCHANGE setKeystorePassword(String pwd) {this.keystore_password=pwd; return this;}
-    public SSL_KEY_EXCHANGE setPortRange(int r)             {this.port_range=r; return this;}
-    public SSL_KEY_EXCHANGE setPort(int p)                  {this.port=p; return this;}
+    public InetAddress      getBindAddress()                          {return bind_addr;}
+    public SSL_KEY_EXCHANGE setBindAddress(InetAddress a)             {this.bind_addr=a; return this;}
+    public int              getPort()                                 {return port;}
+    public SSL_KEY_EXCHANGE setPort(int p)                            {this.port=p; return this;}
+    public int              getPortRange()                            {return port_range;}
+    public SSL_KEY_EXCHANGE setPortRange(int r)                       {this.port_range=r; return this;}
+    public String           getKeystoreName()                         {return keystore_name;}
+    public SSL_KEY_EXCHANGE setKeystoreName(String name)              {this.keystore_name=name; return this;}
+    public String           getKeystoreType()                         {return keystore_type;}
+    public SSL_KEY_EXCHANGE setKeystoreType(String type)              {this.keystore_type=type; return this;}
+    public String           getKeystorePassword()                     {return keystore_password;}
+    public SSL_KEY_EXCHANGE setKeystorePassword(String pwd)           {this.keystore_password=pwd; return this;}
+    public String           getSecretKeyAlgorithm()                   {return secret_key_algorithm;}
+    public SSL_KEY_EXCHANGE setSecretKeyAlgorithm(String a)           {this.secret_key_algorithm=a; return this;}
+    public boolean          getRequireClientAuthentication()          {return require_client_authentication;}
+    public SSL_KEY_EXCHANGE setRequireClientAuthentication(boolean b) {require_client_authentication=b; return this;}
+    public int              getSocketTimeout()                        {return socket_timeout;}
+    public SSL_KEY_EXCHANGE setSocketTimeout(int timeout)             {this.socket_timeout=timeout; return this;}
+    public String           getSessionVerifierClass()                 {return session_verifier_class;}
+    public SSL_KEY_EXCHANGE setSessionVerifierClass(String cl)        {this.session_verifier_class=cl; return this;}
+    public String           getSessionVerifierArg()                   {return session_verifier_arg;}
+    public SSL_KEY_EXCHANGE setSessionVerifierArg(String arg)         {this.session_verifier_arg=arg; return this;}
+    public KeyStore         getKeystore()                             {return key_store;}
+    public SSL_KEY_EXCHANGE setKeystore(KeyStore ks)                  {this.key_store=ks; return this;}
+    public SessionVerifier  getSessionVerifier()                      {return session_verifier;}
+    public SSL_KEY_EXCHANGE setSessionVerifier(SessionVerifier s)     {this.session_verifier=s; return this;}
+    public SSLContext       getSSLContext()                           {return ssl_ctx;}
+    public SSL_KEY_EXCHANGE setSSLContext(SSLContext ssl_ctx)         {this.ssl_ctx=ssl_ctx; return this;}
+
 
     public Address getServerLocation() {
         return srv_sock == null? null : new IpAddress(getTransport().getBindAddress(), srv_sock.getLocalPort());
@@ -141,7 +169,7 @@ public void init() throws Exception {
         if(input == null)
             throw new FileNotFoundException(keystore_name);
         key_store.load(input, keystore_password.toCharArray());
-        if(session_verifier_class != null) {
+        if(session_verifier == null && session_verifier_class != null) {
             Class<? extends SessionVerifier> verifier_class=Util.loadClass(session_verifier_class, getClass());
             session_verifier=verifier_class.getDeclaredConstructor().newInstance();
             if(session_verifier_arg != null)
@@ -364,6 +392,8 @@ protected SSLSocket createSocketTo(IpAddress dest, SSLSocketFactory sslSocketFac
 
 
     protected SSLContext getContext() throws Exception {
+        if(this.ssl_ctx != null)
+            return this.ssl_ctx;
         // Create key manager
         KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
         keyManagerFactory.init(key_store, keystore_password.toCharArray());
@@ -378,7 +408,7 @@ protected SSLContext getContext() throws Exception {
         // Initialize SSLContext
         SSLContext sslContext=SSLContext.getInstance(""TLSv1"");
         sslContext.init(km, tm, null);
-        return sslContext;
+        return this.ssl_ctx=sslContext;
     }
 
 ",2019-06-04T12:48:00Z,49
"@@ -0,0 +1,114 @@
+package org.jgroups.util;
+
+import java.net.*;
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Default implementation, ignores service names
+ * @author Bela Ban
+ * @version $Id: DefaultSocketFactory.java,v 1.1 2010/04/27 09:27:32 belaban Exp $
+ */
+public class DefaultSocketFactory implements SocketFactory {
+    // Maintains information about open sockets
+    protected final Map<Object,String> sockets=new ConcurrentHashMap<Object,String>();
+
+    public Socket createSocket(String service_name) throws IOException {
+        return add(new Socket(), service_name);
+    }
+
+    public Socket createSocket(String service_name, String host, int port) throws IOException {
+        return add(new Socket(host, port), service_name);
+    }
+
+    public Socket createSocket(String service_name, InetAddress address, int port) throws IOException {
+        return add(new Socket(address, port), service_name);
+    }
+
+    public Socket createSocket(String service_name, String host, int port, InetAddress localAddr, int localPort) throws IOException {
+        return add(new Socket(host, port, localAddr, localPort), service_name);
+    }
+
+    public Socket createSocket(String service_name, InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException {
+        return add(new Socket(address, port, localAddr, localPort), service_name);
+    }
+
+    public ServerSocket createServerSocket(String service_name) throws IOException {
+        return add(new ServerSocket(), service_name);
+    }
+
+    public ServerSocket createServerSocket(String service_name, int port) throws IOException {
+        return add(new ServerSocket(port), service_name);
+    }
+
+    public ServerSocket createServerSocket(String service_name, int port, int backlog) throws IOException {
+        return add(new ServerSocket(port, backlog), service_name);
+    }
+
+    public ServerSocket createServerSocket(String service_name, int port, int backlog, InetAddress bindAddr) throws IOException {
+        return add(new ServerSocket(port, backlog, bindAddr), service_name);
+    }
+
+    public DatagramSocket createDatagramSocket(String service_name) throws SocketException {
+        return add(new DatagramSocket(), service_name);
+    }
+
+    public DatagramSocket createDatagramSocket(String service_name, SocketAddress bindaddr) throws SocketException {
+        return add(new DatagramSocket(bindaddr), service_name);
+    }
+
+    public DatagramSocket createDatagramSocket(String service_name, int port) throws SocketException {
+        return add(new DatagramSocket(port), service_name);
+    }
+
+    public DatagramSocket createDatagramSocket(String service_name, int port, InetAddress laddr) throws SocketException {
+        return add(new DatagramSocket(port, laddr), service_name);
+    }
+
+    public MulticastSocket createMulticastSocket(String service_name) throws IOException {
+        return add(new MulticastSocket(), service_name);
+    }
+
+    public MulticastSocket createMulticastSocket(String service_name, int port) throws IOException {
+        return add(new MulticastSocket(port), service_name);
+    }
+
+    public MulticastSocket createMulticastSocket(String service_name, SocketAddress bindaddr) throws IOException {
+        return add(new MulticastSocket(bindaddr), service_name);
+    }
+
+    public void close(Socket sock) throws IOException {
+        remove(sock);
+        Util.close(sock);
+    }
+
+    public void close(ServerSocket sock) throws IOException {
+        remove(sock);
+        Util.close(sock);
+    }
+
+    public void close(DatagramSocket sock) {
+        remove(sock);
+        Util.close(sock);
+    }
+
+    public Map<Object, String> getSockets() {
+        return sockets;
+    }
+
+
+
+    protected <T> T add(T sock, String service_name) {
+        if(sock != null) {
+            String tmp=service_name == null? ""n/a"" : service_name;
+            sockets.put(sock, tmp);
+        }
+        return sock;
+    }
+
+    protected <T> void remove(T sock) {
+        if(sock != null)
+            sockets.remove(sock);
+    }
+}",2010-04-27T09:27:32Z,61
"@@ -0,0 +1,56 @@
+package org.jgroups.util;
+
+import java.net.*;
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Factory to create various types of sockets. For socket creation, a <em>service name</em> can be passed as argument:
+ * an implementation could look up a service description (e.g. port) and create the socket, ignoring the passed port and
+ * possibly also the bind address.<p/>
+ * Ephemeral ports can be created by passing 0 as port, or (if the port is ignored), an implementation could pass in
+ * a special service name (e.g. ""EPHEMERAL""), this is implementation dependent.<p/>
+ * The socket creation methods have the same parameter lists as the socket constructors, e.g.
+ * {@link #createServerSocket(String, int, int)} is the same as {@link java.net.ServerSocket(int,int)}. 
+ * @author Bela Ban
+ * @version $Id: SocketFactory.java,v 1.1 2010/04/27 09:27:32 belaban Exp $
+ */
+public interface SocketFactory {
+
+    // todo: should we include NIO socket channels too ?
+    // todo: how should service names be structured ? jgroups.udp.unicast_port ?
+
+    // todo: should we really include creation of java.net.Sockets ? They don't listen on incoming ports. This would only
+    // be for socket configuration....
+    Socket createSocket(String service_name) throws IOException;
+    Socket createSocket(String service_name, String host, int port) throws IOException;
+    Socket createSocket(String service_name, InetAddress address, int port) throws IOException;
+    Socket createSocket(String service_name, String host, int port, InetAddress localAddr, int localPort) throws IOException;
+    Socket createSocket(String service_name, InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException;
+
+    ServerSocket createServerSocket(String service_name) throws IOException;
+    ServerSocket createServerSocket(String service_name, int port) throws IOException;
+    ServerSocket createServerSocket(String service_name, int port, int backlog) throws IOException;
+    ServerSocket createServerSocket(String service_name, int port, int backlog, InetAddress bindAddr) throws IOException;
+
+    DatagramSocket createDatagramSocket(String service_name) throws SocketException;
+    DatagramSocket createDatagramSocket(String service_name, SocketAddress bindaddr) throws SocketException;
+    DatagramSocket createDatagramSocket(String service_name, int port) throws SocketException;
+    DatagramSocket createDatagramSocket(String service_name, int port, InetAddress laddr) throws SocketException;
+
+    MulticastSocket createMulticastSocket(String service_name) throws IOException;
+    MulticastSocket createMulticastSocket(String service_name, int port) throws IOException;
+    MulticastSocket createMulticastSocket(String service_name, SocketAddress bindaddr) throws IOException;
+
+    void close(Socket sock) throws IOException;
+    void close(ServerSocket sock) throws IOException;
+    void close(DatagramSocket sock);
+    
+
+    /**
+     * Returns all open sockets. This method can be used to list or close all open sockets.
+     * @return A map of open sockets; keys are Sockets, ServerSockets, DatagramSockets or MulticastSockets, values are
+     * the service names.
+     */
+    Map<Object,String> getSockets();
+}",2010-04-27T09:27:32Z,62
"@@ -35,7 +35,7 @@
 /**
  * Collection of various utility routines that can not be assigned to other classes.
  * @author Bela Ban
- * @version $Id: Util.java,v 1.259 2010/03/25 17:03:20 belaban Exp $
+ * @version $Id: Util.java,v 1.260 2010/04/27 09:27:32 belaban Exp $
  */
 public class Util {
 
@@ -83,6 +83,8 @@ public static ThreadGroup getGlobalThreadGroup() {
     private static Method NETWORK_INTERFACE_IS_LOOPBACK=null;
 
 
+    private static SocketFactory socket_factory=new DefaultSocketFactory();
+
     static {
         /* Trying to get value of resolve_dns. PropertyPermission not granted if
         * running in an untrusted environment  with JNLP */
@@ -121,6 +123,14 @@ public static ThreadGroup getGlobalThreadGroup() {
         }
     }
 
+    public static SocketFactory getSocketFactory() {
+        return socket_factory;
+    }
+
+    public static synchronized void setSocketFactory(SocketFactory factory) {
+        if(factory != null)
+            socket_factory=factory;
+    }
 
 
     public static void assertTrue(boolean condition) {",2010-04-27T09:27:32Z,54
"@@ -9,9 +9,7 @@
 import org.jgroups.logging.Log;
 import org.jgroups.logging.LogFactory;
 import org.jgroups.stack.IpAddress;
-import org.jgroups.util.ThreadFactory;
-import org.jgroups.util.TimeService;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -36,6 +34,7 @@ public abstract class BaseServer implements Closeable, ConnectionListener {
     protected final Map<Address,Connection>   conns=new HashMap<>();
     protected final Lock                      sock_creation_lock=new ReentrantLock(true); // syncs socket establishment
     protected final ThreadFactory             factory;
+    protected SocketFactory                   socket_factory=new DefaultSocketFactory();
     protected long                            reaperInterval;
     protected Reaper                          reaper;
     protected Receiver                        receiver;
@@ -59,8 +58,10 @@ public abstract class BaseServer implements Closeable, ConnectionListener {
     protected TimeService                     time_service;
 
 
-    protected BaseServer(ThreadFactory f) {
+    protected BaseServer(ThreadFactory f, SocketFactory sf) {
         this.factory=f;
+        if(sf != null)
+            this.socket_factory=sf;
     }
 
 
@@ -78,6 +79,8 @@ protected BaseServer(ThreadFactory f) {
     public BaseServer       clientBindPort(int port)                {this.client_bind_port=port; return this;}
     public boolean          deferClientBinding()                    {return defer_client_binding;}
     public BaseServer       deferClientBinding(boolean defer)       {this.defer_client_binding=defer; return this;}
+    public SocketFactory    socketFactory()                         {return socket_factory;}
+    public BaseServer       socketFactory(SocketFactory factory)    {this.socket_factory=factory; return this;}
     public boolean          usePeerConnections()                    {return use_peer_connections;}
     public BaseServer       usePeerConnections(boolean flag)        {this.use_peer_connections=flag; return this;}
     public int              socketConnectionTimeout()               {return sock_conn_timeout;}",2016-01-29T13:26:22Z,39
"@@ -3,6 +3,7 @@
 import org.jgroups.Address;
 import org.jgroups.annotations.ManagedAttribute;
 import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.util.SocketFactory;
 import org.jgroups.util.ThreadFactory;
 
 import java.nio.channels.*;
@@ -33,8 +34,8 @@ public abstract class NioBaseServer extends BaseServer {
 
 
 
-    protected NioBaseServer(ThreadFactory f) {
-        super(f);
+    protected NioBaseServer(ThreadFactory f, SocketFactory sf) {
+        super(f, sf);
     }
 
 ",2016-01-29T13:26:22Z,40
"@@ -2,9 +2,7 @@
 
 import org.jgroups.Address;
 import org.jgroups.stack.IpAddress;
-import org.jgroups.util.DefaultThreadFactory;
-import org.jgroups.util.ThreadFactory;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 
 import java.net.InetAddress;
 import java.nio.ByteBuffer;
@@ -48,13 +46,13 @@ public NioClient(IpAddress bind_addr, IpAddress server_addr) {
      * @throws Exception If the creation failed
     */
     public NioClient(InetAddress bind_addr, int bind_port, InetAddress server_addr, int server_port) {
-        this(new DefaultThreadFactory(""nio"", false));
+        this(new DefaultThreadFactory(""nio"", false), new DefaultSocketFactory());
         clientBindAddress(bind_addr).clientBindPort(bind_port);
         this.remote_addr=new IpAddress(server_addr, server_port);
     }
 
-    protected NioClient(ThreadFactory thread_factory) {
-        super(thread_factory);
+    protected NioClient(ThreadFactory thread_factory, SocketFactory sf) {
+        super(thread_factory, sf);
     }
 
 ",2016-01-29T13:26:22Z,63
"@@ -3,11 +3,10 @@
 import org.jgroups.Address;
 import org.jgroups.annotations.ManagedOperation;
 import org.jgroups.stack.IpAddress;
-import org.jgroups.util.DefaultThreadFactory;
-import org.jgroups.util.ThreadFactory;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 
 import java.net.InetAddress;
+import java.net.StandardSocketOptions;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.ServerSocketChannel;
@@ -46,7 +45,7 @@ public NioServer(IpAddress bind_addr) throws Exception {
      * @throws Exception Thrown if the creation failed
      */
     public NioServer(InetAddress bind_addr, int port) throws Exception {
-        this(new DefaultThreadFactory(""nio"", false), bind_addr, port, port+50, null, 0);
+        this(new DefaultThreadFactory(""nio"", false), new DefaultSocketFactory(), bind_addr, port, port+50, null, 0, true);
     }
 
 
@@ -55,35 +54,22 @@ public NioServer(InetAddress bind_addr, int port) throws Exception {
      * Creates an instance of {@link NioServer} that opens a server channel and listens for connections.
      * Needs to be started next.
      * @param thread_factory The thread factory used to create new threads
-     * @param bind_addr The local address to bind to. If null, the address will be picked by the OS
-     * @param end_port If srv_port is taken, the next port is tried, until end_port has been reached, in which case an
-     *                 exception will be thrown. If srv_port == end_port, only 1 port will be tried.
-     * @param external_addr The external address in case of NAT. Ignored if null.
-     * @throws Exception Thrown if the creation failed
-     */
-    public NioServer(ThreadFactory thread_factory, IpAddress bind_addr, int end_port, IpAddress external_addr) throws Exception {
-        this(thread_factory, bind_addr != null? bind_addr.getIpAddress() : null,
-             bind_addr != null? bind_addr.getPort() : 0, end_port,
-             external_addr != null? external_addr.getIpAddress() : null, external_addr != null? external_addr.getPort() : 0);
-    }
-
-
-    /**
-     * Creates an instance of {@link NioServer} that opens a server channel and listens for connections.
-     * Needs to be started next.
-     * @param thread_factory The thread factory used to create new threads
+     * @param socket_factory The socket factory used to create socket channels
      * @param bind_addr The local address to bind to. If null, the address will be picked by the OS
      * @param srv_port The local port to bind to If 0, the port will be picked by the OS.
      * @param end_port If srv_port is taken, the next port is tried, until end_port has been reached, in which case an
      *                 exception will be thrown. If srv_port == end_port, only 1 port will be tried.
      * @param external_addr The external address in case of NAT. Ignored if null.
      * @param external_port The external port on the NA. If 0, srv_port is used.
+     * @param reuse_addr sets server socket channel option SO_REUSEADDR
      * @throws Exception Thrown if the creation failed
      */
-    public NioServer(ThreadFactory thread_factory, InetAddress bind_addr, int srv_port, int end_port,
-                     InetAddress external_addr, int external_port) throws Exception {
-        super(thread_factory);
-        channel=Util.createServerSocketChannel(bind_addr, srv_port, end_port);
+    public NioServer(ThreadFactory thread_factory, SocketFactory socket_factory, InetAddress bind_addr, int srv_port, int end_port,
+                     InetAddress external_addr, int external_port, boolean reuse_addr) throws Exception {
+        super(thread_factory, socket_factory);
+        channel=this.socket_factory.createServerSocketChannel(""jgroups.nio.server"");
+        channel.setOption(StandardSocketOptions.SO_REUSEADDR, reuse_addr);
+        Util.bind(channel, bind_addr, srv_port, end_port);
         channel.configureBlocking(false);
         selector=Selector.open();
         acceptor=factory.newThread(new Acceptor(), ""NioServer.Selector ["" + channel.getLocalAddress() + ""]"");
@@ -92,8 +78,8 @@ public NioServer(ThreadFactory thread_factory, InetAddress bind_addr, int srv_po
     }
 
 
-    protected NioServer(ThreadFactory f) {
-        super(f);
+    protected NioServer(ThreadFactory f, SocketFactory sf) {
+        super(f, sf);
     }
 
 ",2016-01-29T13:26:22Z,64
"@@ -1,7 +1,6 @@
 package org.jgroups.blocks.cs;
 
 import org.jgroups.Address;
-import org.jgroups.util.DefaultSocketFactory;
 import org.jgroups.util.SocketFactory;
 import org.jgroups.util.ThreadFactory;
 
@@ -11,11 +10,10 @@
  * @since  3.6.5
  */
 public abstract class TcpBaseServer extends BaseServer {
-    protected SocketFactory     socket_factory=new DefaultSocketFactory();
     protected int               peer_addr_read_timeout=2000; // max time in milliseconds to block on reading peer address
 
-    protected TcpBaseServer(ThreadFactory f) {
-        super(f);
+    protected TcpBaseServer(ThreadFactory f, SocketFactory sf) {
+        super(f, sf);
     }
 
     @Override
@@ -26,6 +24,5 @@ protected TcpConnection createConnection(Address dest) throws Exception {
 
     public int           peerAddressReadTimeout()                {return peer_addr_read_timeout;}
     public TcpBaseServer peerAddressReadTimeout(int timeout)     {this.peer_addr_read_timeout=timeout; return this;}
-    public SocketFactory socketFactory()                         {return socket_factory;}
-    public TcpBaseServer socketFactory(SocketFactory factory)    {this.socket_factory=factory; return this;}
+
 }",2016-01-29T13:26:22Z,65
"@@ -52,7 +52,7 @@ public TcpClient(InetAddress bind_addr, int bind_port, InetAddress server_addr,
 
 
     protected TcpClient(ThreadFactory thread_factory, SocketFactory socket_factory) {
-        super(thread_factory);
+        super(thread_factory, socket_factory);
         this.socket_factory=socket_factory;
     }
 ",2016-01-29T13:26:22Z,66
"@@ -28,7 +28,7 @@ public class TcpServer extends TcpBaseServer {
      * @throws Exception Thrown if the creation failed
      */
     public TcpServer(InetAddress bind_addr, int port) throws Exception {
-        this(new DefaultThreadFactory(""tcp"", false), new DefaultSocketFactory(), bind_addr, port, port+50, null, 0);
+        this(new DefaultThreadFactory(""tcp"", false), new DefaultSocketFactory(), bind_addr, port, port+50, null, 0, true);
     }
 
     /**
@@ -39,22 +39,6 @@ public TcpServer(IpAddress bind_addr) throws Exception {
         this(bind_addr != null? bind_addr.getIpAddress() : null, bind_addr != null? bind_addr.getPort() : 0);
     }
 
-    /**
-     * Creates an instance of {@link TcpServer} that creates a server socket and listens for connections
-     * @param thread_factory The thread factory used to create new threads
-     * @param socket_factory The socket factory used to create sockets
-     * @param bind_addr The local address to bind to. If null, a bind address will be picked by the OS.
-     * @param end_port If srv_port is taken, the next port is tried, until end_port has been reached, in which case an
-     *                 exception will be thrown. If srv_port == end_port, only 1 port will be tried.
-     * @param external_addr The external address and port in case of NAT. Ignored if null.
-     * @throws Exception Thrown if the creation failed
-     */
-    public TcpServer(ThreadFactory thread_factory, SocketFactory socket_factory,
-                     IpAddress bind_addr, int end_port, IpAddress external_addr) throws Exception {
-        this(thread_factory, socket_factory, bind_addr != null? bind_addr.getIpAddress() : null,
-             bind_addr != null? bind_addr.getPort() : 0, end_port,
-             external_addr != null? external_addr.getIpAddress() : null, external_addr != null? external_addr.getPort() : 0);
-    }
 
     /**
      * Creates an instance of {@link TcpServer} that creates a server socket and listens for connections
@@ -67,22 +51,24 @@ public TcpServer(ThreadFactory thread_factory, SocketFactory socket_factory,
      *                 exception will be thrown. If srv_port == end_port, only 1 port will be tried.
      * @param external_addr The external address in case of NAT. Ignored if null.
      * @param external_port The external port on the NA. If 0, srv_port is used.
+     * @param reuse_addr sets server socket option SO_REUSEADDR
      * @throws Exception Thrown if the creation failed
      */
     public TcpServer(ThreadFactory thread_factory, SocketFactory socket_factory,
                      InetAddress bind_addr, int srv_port, int end_port,
-                     InetAddress external_addr, int external_port) throws Exception {
+                     InetAddress external_addr, int external_port, boolean reuse_addr) throws Exception {
         this(thread_factory, socket_factory);
-        this.srv_sock=Util.createServerSocket(this.socket_factory, ""jgroups.tcp.server"", bind_addr, srv_port, end_port);
+        this.srv_sock=this.socket_factory.createServerSocket(""jgroups.tcp.server"");
+        this.srv_sock.setReuseAddress(reuse_addr);
+        Util.bind(this.srv_sock, bind_addr, srv_port, end_port);
         acceptor=factory.newThread(new Acceptor(),""TcpServer.Acceptor ["" + srv_sock.getLocalPort() + ""]"");
         local_addr=localAddress(bind_addr, srv_sock.getLocalPort(), external_addr, external_port);
         addConnectionListener(this);
     }
 
 
     protected TcpServer(ThreadFactory thread_factory, SocketFactory socket_factory) {
-        super(thread_factory);
-        this.socket_factory=socket_factory;
+        super(thread_factory, socket_factory);
     }
 
 ",2016-01-29T13:26:22Z,67
"@@ -89,8 +89,7 @@ public void run() {
                     finally {
                         shutdownLock.unlock();
                     }
-                    _runnables.put(currentThread, new Holder<>(
-                            runnable));
+                    _runnables.put(currentThread, new Holder<>(runnable));
                     
                     Throwable throwable = null;
                     try {",2016-01-29T13:26:22Z,68
"@@ -48,6 +48,9 @@ public abstract class BasicTCP extends TP implements Receiver {
     @Property(description=""SO_LINGER in msec. Default of -1 disables it"")
     protected int         linger=-1; // SO_LINGER (number of ms, -1 disables it)
 
+    @Property(description=""Sets socket option SO_REUSEADDR (https://issues.jboss.org/browse/JGRP-2009)"")
+    protected boolean     reuse_addr;
+
     @LocalAddress
     @Property(name=""client_bind_addr"",
               description=""The address of a local network interface which should be used by client sockets to bind to. "" +
@@ -69,11 +72,13 @@ protected BasicTCP() {
         super();        
     }
 
-    public boolean supportsMulticasting()           {return false;}
-    public long    getReaperInterval()              {return reaper_interval;}
-    public void    setReaperInterval(long interval) {this.reaper_interval=interval;}
-    public long    getConnExpireTime()              {return conn_expire_time;}
-    public void    setConnExpireTime(long time)     {this.conn_expire_time=time;}
+    public boolean  supportsMulticasting()           {return false;}
+    public long     getReaperInterval()              {return reaper_interval;}
+    public void     setReaperInterval(long interval) {this.reaper_interval=interval;}
+    public long     getConnExpireTime()              {return conn_expire_time;}
+    public void     setConnExpireTime(long time)     {this.conn_expire_time=time;}
+    public boolean  getReuseAddress()                {return this.reuse_addr;}
+    public BasicTCP setReuseAddress(boolean b)       {this.reuse_addr=b; return this;}
 
 
     public void init() throws Exception {",2016-01-29T13:26:22Z,12
"@@ -65,18 +65,18 @@ public void retainAll(Collection<Address> members) {
     }
 
     public void start() throws Exception {
-        server=(TcpServer)((TcpServer)new TcpServer(getThreadFactory(), getSocketFactory(), bind_addr, bind_port, bind_port+port_range, external_addr, external_port)
-          .receiver(this)
+        server=new TcpServer(getThreadFactory(), getSocketFactory(), bind_addr, bind_port, bind_port+port_range, external_addr, external_port, reuse_addr);
+        server.receiver(this)
           .timeService(time_service)
           .receiveBufferSize(recv_buf_size)
           .sendBufferSize(send_buf_size)
           .socketConnectionTimeout(sock_conn_timeout)
           .tcpNodelay(tcp_nodelay).linger(linger)
           .clientBindAddress(client_bind_addr).clientBindPort(client_bind_port).deferClientBinding(defer_client_bind_addr)
-          .log(this.log))
-          .socketFactory(getSocketFactory())
-          .peerAddressReadTimeout(peer_addr_read_timeout)
-          .usePeerConnections(true);
+          .log(this.log);
+        server.peerAddressReadTimeout(peer_addr_read_timeout)
+          .usePeerConnections(true)
+          .socketFactory(getSocketFactory());
 
         if(reaper_interval > 0 || conn_expire_time > 0) {
             if(reaper_interval == 0) {",2016-01-29T13:26:22Z,13
"@@ -94,18 +94,17 @@ public void retainAll(Collection<Address> members) {
     }
 
     public void start() throws Exception {
-        server=(NioServer)((NioServer)new NioServer(getThreadFactory(), bind_addr, bind_port, bind_port+port_range, external_addr, external_port)
-          .receiver(this)
+        server=new NioServer(getThreadFactory(), getSocketFactory(), bind_addr, bind_port, bind_port+port_range, external_addr, external_port, reuse_addr);
+        server.receiver(this)
           .timeService(time_service)
           .receiveBufferSize(recv_buf_size)
           .sendBufferSize(send_buf_size)
           .socketConnectionTimeout(sock_conn_timeout)
           .tcpNodelay(tcp_nodelay).linger(linger)
           .clientBindAddress(client_bind_addr).clientBindPort(client_bind_port).deferClientBinding(defer_client_bind_addr)
-          .log(this.log))
-          .maxSendBuffers(max_send_buffers).usePeerConnections(true);
-        server.copyOnPartialWrite(this.copy_on_partial_write)
-          .readerIdleTime(this.reader_idle_time);
+          .log(this.log);
+        server.maxSendBuffers(max_send_buffers).usePeerConnections(true);
+        server.copyOnPartialWrite(this.copy_on_partial_write).readerIdleTime(this.reader_idle_time);
 
         if(reaper_interval > 0 || conn_expire_time > 0) {
             if(reaper_interval == 0) {",2016-01-29T13:26:22Z,44
"@@ -64,6 +64,8 @@ public class GossipRouter extends ReceiverAdapter implements ConnectionListener
 
     protected ThreadFactory                                     thread_factory=new DefaultThreadFactory(""gossip"", false, true);
 
+    protected SocketFactory                                     socket_factory=new DefaultSocketFactory();
+
     @Property(description=""The max queue size of backlogged connections"")
     protected int                                               backlog=1000;
 
@@ -106,6 +108,8 @@ public GossipRouter(String bind_addr, int local_port) {
     public GossipRouter  socketReadTimeout(long t)          {this.sock_read_timeout=t; return this;}
     public ThreadFactory threadPoolFactory()                {return thread_factory;}
     public GossipRouter  threadPoolFactory(ThreadFactory f) {this.thread_factory=f; return this;}
+    public SocketFactory socketFactory()                    {return socket_factory;}
+    public GossipRouter  socketFactory(SocketFactory sf)    {this.socket_factory=sf; return this;}
     public int           backlog()                          {return backlog;}
     public GossipRouter  backlog(int backlog)               {this.backlog=backlog; return this;}
     public boolean       jmx()                              {return jmx;}
@@ -135,8 +139,8 @@ public void start() throws Exception {
             JmxConfigurator.register(this, Util.getMBeanServer(), ""jgroups:name=GossipRouter"");
 
         InetAddress tmp=bind_addr != null? InetAddress.getByName(bind_addr) : null;
-        server=use_nio? new NioServer(thread_factory, tmp, port, port+50, null, 0)
-          : new TcpServer(thread_factory, new DefaultSocketFactory(), tmp, port, port+50, null, 0);
+        server=use_nio? new NioServer(thread_factory, socket_factory, tmp, port, port, null, 0, true)
+          : new TcpServer(thread_factory, socket_factory, tmp, port, port, null, 0, true);
         server.receiver(this);
         server.start();
         server.addConnectionListener(this);",2016-01-29T13:26:22Z,69
"@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 import java.net.*;
+import java.nio.channels.ServerSocketChannel;
 import java.util.Map;
 
 /**
@@ -46,6 +47,23 @@ public ServerSocket createServerSocket(String service_name, int port, int backlo
         return new ServerSocket(port, backlog, bindAddr);
     }
 
+    @SuppressWarnings(""UnusedParameters"")
+    public ServerSocketChannel createServerSocketChannel(String service_name) throws IOException {
+        return ServerSocketChannel.open();
+    }
+
+    public ServerSocketChannel createServerSocketChannel(String service_name, int port) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(port));
+    }
+
+    public ServerSocketChannel createServerSocketChannel(String service_name, int port, int backlog) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(port), backlog);
+    }
+
+    public ServerSocketChannel createServerSocketChannel(String service_name, int port, int backlog, InetAddress bindAddr) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(bindAddr, port), backlog);
+    }
+
     public DatagramSocket createDatagramSocket(String service_name) throws SocketException {
         return new DatagramSocket();
     }",2016-01-29T13:26:22Z,61
"@@ -17,8 +17,8 @@
 public class ResourceManager {
 	private static final IpAddressRep rep;
 	private static short mcast_port;
-	private static short tcp_port;
-    private static SocketFactory socket_factory=new DefaultSocketFactory();
+	private static int   tcp_port;
+    private static final SocketFactory socket_factory=new DefaultSocketFactory();
 
 	static {
 
@@ -68,34 +68,36 @@ public static synchronized short getNextMulticastPort(InetAddress bind_addr) thr
 		}
 	}
 
-	public static synchronized List<Short> getNextTcpPorts(InetAddress bind_addr, int num_requested_ports) throws Exception {
-		short port = tcp_port++;
-		List<Short> retval = new ArrayList<>(num_requested_ports);
+	public static synchronized List<Integer> getNextTcpPorts(InetAddress bind_addr, int num_requested_ports) throws Exception {
+		int port= tcp_port++;
+		List<Integer> retval = new ArrayList<>(num_requested_ports);
 
 		for (int i = 0; i < num_requested_ports; i++) {
-			ServerSocket sock = Util.createServerSocket(socket_factory, ""jgroups.temp.resourcemgr.srv_sock"", bind_addr, port);
-			port = (short) sock.getLocalPort();
-			retval.add(port);
-			tcp_port = ++port;
-			socket_factory.close(sock);
-		}
-		return retval;
+            port=getNextTCPPort(bind_addr, port);
+            retval.add(port);
+            tcp_port=++port;
+        }
+        return retval;
 	}
 
-    public static synchronized short getNextTcpPort(InetAddress bind_addr) throws Exception {
-        short port=tcp_port++;
-        ServerSocket sock=null;
+    public static synchronized int getNextTcpPort(InetAddress bind_addr) throws Exception {
+        int port=tcp_port++;
         try {
-            sock=Util.createServerSocket(socket_factory, ""jgroups.temp.resourcemgr.srv_sock"", bind_addr, port);
-            return (short) sock.getLocalPort();
-
+            return getNextTCPPort(bind_addr, port);
         }
         finally {
             tcp_port = ++port;
-            socket_factory.close(sock);
         }
 	}
 
+    protected static int getNextTCPPort(InetAddress bind_addr, int start_port) throws Exception {
+        try(ServerSocket sock=new ServerSocket()) {
+            sock.setReuseAddress(false);
+            Util.bind(sock, bind_addr, start_port, start_port+100);
+            return sock.getLocalPort();
+        }
+    }
+
     public static String getUniqueClusterName(String base_name) {
         return base_name != null ? base_name + ""-"" + UUID.randomUUID().toString()
           : UUID.randomUUID().toString();
@@ -106,10 +108,10 @@ public static String getUniqueClusterName() {
 	}
 
 	public static void main(String[] args) throws Exception {
-		List<Short> ports = getNextTcpPorts(InetAddress.getByName(""192.168.1.5""), 15);
+		List<Integer> ports = getNextTcpPorts(InetAddress.getByName(""192.168.1.3""), 15);
 		System.out.println(""ports = "" + ports);
 
-		ports = getNextTcpPorts(InetAddress.getByName(""192.168.1.5""), 5);
+		ports = getNextTcpPorts(InetAddress.getByName(""192.168.1.3""), 5);
 		System.out.println(""ports = "" + ports);
 
 	}
@@ -118,7 +120,7 @@ public static void main(String[] args) throws Exception {
 	 * Interface for IpAddress representations
 	 */
 	public interface IpAddressRep {
-		public String nextAddress();
+		String nextAddress();
 	}
 
 	/** Representation of an IPv4 address */",2016-01-29T13:26:22Z,70
"@@ -1,7 +1,8 @@
 package org.jgroups.util;
 
-import java.net.*;
 import java.io.IOException;
+import java.net.*;
+import java.nio.channels.ServerSocketChannel;
 import java.util.Map;
 
 /**
@@ -26,6 +27,23 @@ public interface SocketFactory {
     ServerSocket createServerSocket(String service_name, int port, int backlog) throws IOException;
     ServerSocket createServerSocket(String service_name, int port, int backlog, InetAddress bindAddr) throws IOException;
 
+    @SuppressWarnings(""UnusedParameters"")
+    default ServerSocketChannel createServerSocketChannel(String service_name) throws IOException {
+        return ServerSocketChannel.open();
+    }
+
+    default ServerSocketChannel createServerSocketChannel(String service_name, int port) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(port));
+    }
+
+    default ServerSocketChannel createServerSocketChannel(String service_name, int port, int backlog) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(port), backlog);
+    }
+
+    default ServerSocketChannel createServerSocketChannel(String service_name, int port, int backlog, InetAddress bindAddr) throws IOException {
+        return createServerSocketChannel(service_name).bind(new InetSocketAddress(bindAddr, port), backlog);
+    }
+
     DatagramSocket createDatagramSocket(String service_name) throws SocketException;
     DatagramSocket createDatagramSocket(String service_name, SocketAddress bindaddr) throws SocketException;
     DatagramSocket createDatagramSocket(String service_name, int port) throws SocketException;",2016-01-29T13:26:22Z,62
"@@ -2983,20 +2983,14 @@ public static <K,V> ConcurrentMap<K,V> createConcurrentMap() {
 
     public static ServerSocket createServerSocket(SocketFactory factory, String service_name, InetAddress bind_addr, int start_port) {
         ServerSocket ret=null;
-
-        while(true) {
-            try {
-                ret=factory.createServerSocket(service_name,start_port,50,bind_addr);
-            }
-            catch(BindException bind_ex) {
-                start_port++;
-                continue;
-            }
-            catch(IOException io_ex) {
-            }
-            break;
+        try {
+            ret=factory.createServerSocket(service_name);
+            Util.bind(ret, bind_addr, start_port, start_port+1000, 50);
+            return ret;
+        }
+        catch(Exception e) {
+            return null;
         }
-        return ret;
     }
 
 
@@ -3006,17 +3000,25 @@ public static ServerSocket createServerSocket(SocketFactory factory, String serv
      */
     public static ServerSocket createServerSocket(SocketFactory factory,String service_name,InetAddress bind_addr,
                                                   int start_port,int end_port) throws Exception {
-        ServerSocket ret=null;
+        ServerSocket ret=factory.createServerSocket(service_name);
+        bind(ret, bind_addr, start_port, end_port);
+        return ret;
+    }
+
+
+    public static void bind(ServerSocket srv_sock, InetAddress bind_addr,
+                            int start_port, int end_port) throws Exception {
+        bind(srv_sock, bind_addr, start_port, end_port, 50);
+    }
+
+    public static void bind(ServerSocket srv_sock, InetAddress bind_addr,
+                            int start_port, int end_port, int backlog) throws Exception {
         int original_start_port=start_port;
 
         while(true) {
             try {
-                if(bind_addr == null)
-                    ret=factory.createServerSocket(service_name,start_port);
-                else {
-                    // changed (bela Sept 7 2007): we accept connections on all NICs
-                    ret=factory.createServerSocket(service_name,start_port,50,bind_addr);
-                }
+                InetSocketAddress sock_addr=new InetSocketAddress(bind_addr, start_port);
+                srv_sock.bind(sock_addr, backlog);
             }
             catch(SocketException bind_ex) {
                 if(start_port == end_port)
@@ -3031,21 +3033,26 @@ public static ServerSocket createServerSocket(SocketFactory factory,String servi
             }
             break;
         }
-        return ret;
     }
 
+
     public static ServerSocketChannel createServerSocketChannel(InetAddress bind_addr,
-                                                         int start_port, int end_port) throws Exception {
+                                                                int start_port, int end_port) throws Exception {
         ServerSocketChannel channel=ServerSocketChannel.open();
-        int original_start_port=start_port;
+        bind(channel, bind_addr, start_port, end_port);
+        return channel;
+    }
+
+    public static void bind(final ServerSocketChannel ch, InetAddress bind_addr, int start_port, int end_port) throws Exception {
+        bind(ch, bind_addr, start_port, end_port, 50);
+    }
 
+
+    public static void bind(final ServerSocketChannel ch, InetAddress bind_addr, int start_port, int end_port, int backlog) throws Exception {
+        int original_start_port=start_port;
         while(true) {
             try {
-                if(bind_addr == null)
-                    channel.bind(new InetSocketAddress(start_port));
-                else {
-                    channel.bind(new InetSocketAddress(bind_addr, start_port));
-                }
+                ch.bind(new InetSocketAddress(bind_addr, start_port), backlog);
             }
             catch(SocketException bind_ex) {
                 if(start_port == end_port)
@@ -3060,8 +3067,6 @@ public static ServerSocketChannel createServerSocketChannel(InetAddress bind_add
             }
             break;
         }
-
-        return channel;
     }
 
 ",2016-01-29T13:26:22Z,54
"@@ -37,8 +37,6 @@ public void tearDown() {
     public void testDisconnect() throws Exception {
         JChannel channel1=new JChannel(Util.getTestStack(new CENTRAL_EXECUTOR()));
         JChannel channel2=new JChannel(Util.getTestStack(new CENTRAL_EXECUTOR()));
-        // channel1.getProtocolStack().addProtocol(new CENTRAL_EXECUTOR());
-        // channel2.getProtocolStack().addProtocol(new CENTRAL_EXECUTOR());
         channels.add(channel1);
         channels.add(channel2);
 ",2016-01-29T13:26:22Z,71
"@@ -196,7 +196,7 @@ protected void makeUnique(Channel channel, int num, String mcast_address) throws
                     ((UDP) transport).setMulticastAddress(InetAddress.getByName(mcast_addr));
                 }
             } else if (transport instanceof BasicTCP) {
-                List<Short> ports = ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);
+                List<Integer> ports = ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);
                 ((TP) transport).setBindPort(ports.get(0));
                 ((TP) transport).setPortRange(num);
 ",2016-01-29T13:26:22Z,72
"@@ -47,7 +47,7 @@ public class UnicastTestTcpSlow {
     public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {
         local=new InetSocketAddress(local_addr, local_port);
         remote=new InetSocketAddress(remote_addr, remote_port);
-        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), ""server"", local.getAddress(), local.getPort());
+        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), ""server"", local.getAddress(), local.getPort(), local.getPort());
         System.out.println(""Listening on "" + srv_sock.getLocalSocketAddress());
         acceptor=new Acceptor();
         acceptor.start();",2016-01-29T13:26:22Z,73
"@@ -44,12 +44,6 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     @Property(description=""Timeout (in ms) to complete merge"")
     long merge_timeout=5000; // time to wait for all MERGE_RSPS
 
-    @Property(description=""Max time (in ms) a merge is allowed to run before it will be force-killed"")
-    protected long merge_kill_timeout=2 * 60 * 1000; // 2 minutes by default
-
-    @Property(description=""Interval (in ms) the MergeKiller task runs at, must be less than merge_kill_timeout. 0 disables it."")
-    protected long merge_killer_interval=60 * 1000;
-
     @Property(description=""Print local address of this member after connect. Default is true"")
     private boolean print_local_addr=true;
 
@@ -85,8 +79,8 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     @Property(description=""Time in ms to wait for all VIEW acks (0 == wait forever. Default is 2000 msec"" )
     long view_ack_collection_timeout=2000;
  
-    @Property(description=""Timeout to resume ViewHandler. Default is 10000 msec"")
-    long resume_task_timeout=10000;
+    @Property(description=""Timeout to resume ViewHandler"")
+    long resume_task_timeout=20000;
 
     @Property(description=""Use flush for view changes. Default is true"")
     boolean use_flush_if_present=true;
@@ -119,8 +113,6 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     // Handles merge related tasks
     final Merger merger=new Merger(this, log);
 
-    protected Future<?> merge_killer;
-    
     protected Address local_addr=null;
     protected final Membership members=new Membership(); // real membership
     
@@ -137,8 +129,6 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
 
     protected View view=null;
     
-    protected ViewId view_id=null;
-    
     protected long ltime=0;
 
     protected TimeScheduler timer=null;    
@@ -155,12 +145,15 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     boolean flushProtocolInStack=false;
 
 
+
     public GMS() {
         initState();
     }
 
+    public ViewId getViewId() {return view != null? view.getViewId() : null;}
+
     @ManagedAttribute
-    public String getView() {return view_id != null? view_id.toString() : ""null"";}
+    public String getView() {return view != null? view.getViewId().toString() : ""null"";}
     @ManagedAttribute
     public int getNumberOfViews() {return num_views;}
     @ManagedAttribute
@@ -174,11 +167,6 @@ public GMS() {
     public long getMergeTimeout() {return merge_timeout;}
     public void setMergeTimeout(long timeout) {merge_timeout=timeout;}
 
-    @ManagedAttribute(description=""Whether the merge killer task is running"")
-    public boolean getMergeKillerRunning() {
-        return !(merge_killer.isCancelled() || merge_killer.isDone());
-    }
-
     @ManagedAttribute(description=""Stringified version of merge_id"")
     public String getMergeId() {return merger.getMergeIdAsString();}
 
@@ -239,7 +227,7 @@ public String dumpViewHandlerHistory() {
     }
     @ManagedOperation
     public void suspendViewHandler() {
-        view_handler.suspend(null);
+        view_handler.suspend();
     }
     @ManagedOperation
     public void resumeViewHandler() {
@@ -253,9 +241,8 @@ public void resumeViewHandler() {
     @ManagedOperation
     public String printPreviousViews() {
         StringBuilder sb=new StringBuilder();
-        for(Tuple<View,Long> tmp: prev_views) {
+        for(Tuple<View,Long> tmp: prev_views)
             sb.append(new Date(tmp.getVal2())).append("": "").append(tmp.getVal1()).append(""\n"");
-        }
         return sb.toString();
     }
 
@@ -325,9 +312,6 @@ public void init() throws Exception {
             throw new IllegalArgumentException(""view_ack_collection_timeout has to be greater than 0"");
         if(merge_timeout <= 0)
             throw new IllegalArgumentException(""merge_timeout has to be greater than 0"");
-        if(merge_kill_timeout > 0 && merge_kill_timeout < merge_timeout)
-            throw new IllegalArgumentException(""merge_kill_timeout ("" + merge_kill_timeout +
-                                                 "") needs to be greater than merge_timeout ("" +merge_timeout+"")"");
         prev_members=new BoundedList<Address>(num_prev_mbrs);
         prev_views=new BoundedList<Tuple<View,Long>>(num_prev_views);
         TP transport=getTransport();
@@ -341,29 +325,9 @@ public void init() throws Exception {
 
     public void start() throws Exception {
         if(impl != null) impl.start();
-        if(merge_killer_interval > 0) {
-            merge_killer=timer.scheduleWithFixedDelay(new Runnable() {
-                public void run() {
-                    try {
-                        long timestamp=merger.getMergeIdTimestamp();
-                        if(timestamp > 0) {
-                            long diff=System.currentTimeMillis() - timestamp;
-                            if(diff >= merge_kill_timeout) {
-                                if(merger.forceCancelMerge())
-                                    log.warn(""force-cancelled merge task after "" + diff + "" ms"");
-                            }
-                        }
-                    }
-                    catch(Throwable t) {
-                    }
-                }
-            },merge_killer_interval,merge_killer_interval, TimeUnit.MILLISECONDS);
-        }
     }
 
     public void stop() {
-        if(merge_killer != null)
-            merge_killer.cancel(true);
         view_handler.stop(true);
         if(impl != null) impl.stop();
         if(prev_members != null)
@@ -430,23 +394,23 @@ public void fixDigests() {
     }
 
     @ManagedOperation(description=""Forces cancellation of current merge task"")
-    public boolean cancelMerge() {
-        boolean result=merger.forceCancelMerge();
-        if(log.isDebugEnabled()) {
-            log.debug(result? ""Merge was cancelled"" : ""There was no merge to be cancelled"");
-        }
-        return result;
+    public void cancelMerge() {
+        merger.forceCancelMerge();
     }
 
     @ManagedAttribute(description=""Is the merge task running"")
     public boolean isMergeTaskRunning() {return merger.isMergeTaskRunning();}
 
+    @ManagedAttribute(description=""Is the merge killer task running"")
+    public boolean isMergeKillerRunning() {return merger.isMergeKillerTaskRunning();}
+
     /**
      * Computes the next view. Returns a copy that has <code>old_mbrs</code> and
      * <code>suspected_mbrs</code> removed and <code>new_mbrs</code> added.
      */
     public View getNextView(Collection<Address> new_mbrs, Collection<Address> old_mbrs, Collection<Address> suspected_mbrs) {
         synchronized(members) {
+            ViewId view_id=view != null? view.getViewId() : null;
             if(view_id == null) {
                 log.error(""view_id is null"");
                 return null; // this should *never* happen !
@@ -530,14 +494,14 @@ public void castViewChangeWithDest(View new_view, Digest digest, JoinRsp jr, Col
                 ack_collector.waitForAllAcks(view_ack_collection_timeout);
                 if(log.isTraceEnabled())
                     log.trace(local_addr + "": received all ACKs ("" + ack_collector.expectedAcks() +
-                            "") from existing members for view "" + new_view.getVid());
+                                "") from existing members for view "" + new_view.getVid());
             }
         }
         catch(TimeoutException e) {
             if(log_collect_msgs && log.isWarnEnabled()) {
                 log.warn(local_addr + "": failed to collect all ACKs (expected="" + ack_collector.expectedAcks()
-                        + "") for view "" + new_view + "" after "" + view_ack_collection_timeout + ""ms, missing ACKs from ""
-                        + ack_collector.printMissing());
+                        + "") for view "" + new_view.getViewId() + "" after "" + view_ack_collection_timeout + ""ms, missing ACKs from ""
+                           + ack_collector.printMissing());
             }
         }
 
@@ -580,22 +544,31 @@ public void installView(View new_view) {
      * of View), then digest will be non-null and has to be set before installing the view.
      */
     public void installView(View new_view, Digest digest) {
-        Address coord;
-        int rc;
         ViewId vid=new_view.getVid();
         List<Address> mbrs=new_view.getMembers();
+        ltime=Math.max(vid.getId(), ltime);  // compute the logical time, regardless of whether the view is accepted
 
-        // Discards view with id lower than our own. Will be installed without check if first view
-        if(view_id != null) {
-            rc=vid.compareTo(view_id);
+        // Discards view with id lower than or equal to our own. Will be installed without check if it is the first view
+        if(view != null) {
+            ViewId view_id=view.getViewId();
+            int rc=vid.compareToIDs(view_id);
             if(rc <= 0) {
-                if(log.isWarnEnabled() && rc < 0 && log_view_warnings) // only scream if view is smaller, silently discard same views
+                if(log.isWarnEnabled() && rc < 0 && log_view_warnings) { // only scream if view is smaller, silently discard same views
                     log.warn(local_addr + "": received view < current view;"" +
-                            "" discarding it (current vid: "" + view_id + "", new vid: "" + vid + ')');
+                               "" discarding it (current vid: "" + view_id + "", new vid: "" + vid + ')');
+                }
                 return;
             }
         }
 
+        /* Check for self-inclusion: if I'm not part of the new membership, I just discard it.
+           This ensures that messages sent in view V1 are only received by members of V1 */
+        if(checkSelfInclusion(mbrs) == false) {
+            if(log.isWarnEnabled() && log_view_warnings)
+                log.warn(local_addr + "": not member of view "" + new_view.getViewId() + ""; discarding it"");
+            return;
+        }
+
         if(digest != null) {
             if(new_view instanceof MergeView)
                 mergeDigest(digest);
@@ -604,30 +577,14 @@ public void installView(View new_view, Digest digest) {
         }
 
         if(log.isDebugEnabled()) log.debug(local_addr + "": view is "" + new_view);
-        if(stats) {
-            num_views++;
-            prev_views.add(new Tuple<View,Long>(new_view, System.currentTimeMillis()));
-        }
 
         ack_collector.handleView(new_view);
         merge_ack_collector.handleView(new_view);
 
-        ltime=Math.max(vid.getId(), ltime);  // compute Lamport logical time
-
-        /* Check for self-inclusion: if I'm not part of the new membership, I just discard it.
-           This ensures that messages sent in view V1 are only received by members of V1 */
-        if(checkSelfInclusion(mbrs) == false) {
-            if(log.isWarnEnabled() && log_view_warnings) log.warn(local_addr + "": not member of view "" + new_view + ""; discarding it"");
-            return;
-        }
-
-        synchronized(members) {   // serialize access to views
-            // assign new_view to view_id
-            if(new_view instanceof MergeView)
-                view=new View(new_view.getVid(), new_view.getMembers());
-            else
-                view=new_view;
-            view_id=vid.copy();
+        Event view_event;
+        synchronized(members) {
+            view=new View(new_view.getVid(), new_view.getMembers());
+            view_event=new Event(Event.VIEW_CHANGE, new_view);
 
             // Set the membership. Take into account joining members
             if(mbrs != null && !mbrs.isEmpty()) {
@@ -647,17 +604,7 @@ public void installView(View new_view, Digest digest) {
                 }
             }
 
-            // Send VIEW_CHANGE event up and down the stack:
-            Event view_event=new Event(Event.VIEW_CHANGE, new_view);
-            // changed order of passing view up and down (http://jira.jboss.com/jira/browse/JGRP-347)
-            // changed it back (bela Sept 4 2007): http://jira.jboss.com/jira/browse/JGRP-564
-            down_prot.down(view_event); // needed e.g. by failure detector or UDP
-            up_prot.up(view_event);
-
-
-            coord=determineCoordinator();
-            // if(coord != null && coord.equals(local_addr) && !(coord.equals(vid.getCoordAddress()))) {
-            // changed on suggestion by yaronr and Nicolas Piedeloupe
+            Address coord=determineCoordinator();
             if(coord != null && coord.equals(local_addr) && !haveCoordinatorRole()) {
                 becomeCoordinator();
             }
@@ -668,6 +615,20 @@ public void installView(View new_view, Digest digest) {
                 }
             }
         }
+
+        // - Changed order of passing view up and down (http://jira.jboss.com/jira/browse/JGRP-347)
+        // - Changed it back (bela Sept 4 2007): http://jira.jboss.com/jira/browse/JGRP-564
+        // - Moved sending up view_event out of the synchronized block (bela Nov 2011)
+        down_prot.down(view_event); // needed e.g. by failure detector or UDP
+        up_prot.up(view_event);
+
+        ack_collector.handleView(new_view);
+        merge_ack_collector.handleView(new_view);
+
+        if(stats) {
+            num_views++;
+            prev_views.add(new Tuple<View,Long>(new_view, System.currentTimeMillis()));
+        }
     }
 
 
@@ -680,13 +641,10 @@ protected Address determineCoordinator() {
 
     /** Checks whether the potential_new_coord would be the new coordinator (2nd in line) */
     protected boolean wouldBeNewCoordinator(Address potential_new_coord) {
-        Address new_coord;
-
         if(potential_new_coord == null) return false;
-
         synchronized(members) {
             if(members.size() < 2) return false;
-            new_coord=members.elementAt(1);  // member at 2nd place
+            Address new_coord=members.elementAt(1);  // member at 2nd place
             return new_coord != null && new_coord.equals(potential_new_coord);
         }
     }
@@ -842,7 +800,6 @@ public Object up(Event evt) {
                         return null; // don't pass further up
 
                     case GmsHeader.MERGE_REQ:
-                        down_prot.down(new Event(Event.SUSPEND_STABLE, 20000)); 
                         impl.handleMergeRequest(msg.getSrc(), hdr.merge_id, hdr.mbrs);
                         break;
 
@@ -857,7 +814,6 @@ public Object up(Event evt) {
 
                     case GmsHeader.INSTALL_MERGE_VIEW:
                         impl.handleMergeView(new MergeData(msg.getSrc(), hdr.view, hdr.my_digest), hdr.merge_id);
-                        down_prot.down(new Event(Event.RESUME_STABLE));
                         break;
 
                     case GmsHeader.INSTALL_DIGEST:
@@ -873,10 +829,15 @@ public Object up(Event evt) {
                     case GmsHeader.CANCEL_MERGE:
                         //[JGRP-524] - FLUSH and merge: flush doesn't wrap entire merge process                        
                         impl.handleMergeCancelled(hdr.merge_id);
-                        down_prot.down(new Event(Event.RESUME_STABLE));
                         break;
 
                     case GmsHeader.GET_DIGEST_REQ:
+                        // only handle this request if it was sent by the coordinator (or at least a member) of the current cluster
+                        synchronized(members) {
+                            if(!members.contains(msg.getSrc()))
+                                break;
+                        }
+
                         Digest digest=(Digest)down_prot.down(Event.GET_DIGEST_EVT);
                         if(digest != null) {
                             long[] entry=digest.get(local_addr);
@@ -1013,7 +974,6 @@ public String[] supportedKeys() {
 
     final void initState() {
         becomeClient();
-        view_id=null;
         view=null;
     }
 
@@ -1265,14 +1225,14 @@ class ViewHandler implements Runnable {
         /** Maintains a list of the last 20 requests */
         private final BoundedList<String>   history=new BoundedList<String>(20);
 
-        /** Map<Object,Future>. Keeps track of Resumer tasks which have not fired yet */
-        private final Map<MergeId, Future>  resume_tasks=new HashMap<MergeId,Future>();
+        /** Current Resumer task */
+        private Future<?>                   resumer;
 
 
         synchronized void add(Request req) {
             if(suspended) {
                 if(log.isTraceEnabled())
-                    log.trace(""queue is suspended; request "" + req + "" is discarded"");
+                    log.trace(local_addr + "": queue is suspended; request "" + req + "" is discarded"");
                 return;
             }
             start();
@@ -1299,8 +1259,7 @@ synchronized void waitUntilCompleted(long timeout, boolean resume) {
                 catch(InterruptedException e) {
                     Thread.currentThread().interrupt(); // set interrupt flag again
                 }
-                //Added after Brian noticed that ViewHandler leaks class loaders 
-                thread = null;
+                thread = null; // Added after Brian noticed that ViewHandler leaks class loaders
             }
             if(resume)
                 resumeForce();
@@ -1318,43 +1277,34 @@ synchronized void start() {
 
         synchronized void stop(boolean flush) {
             queue.close(flush);
-            synchronized(resume_tasks) {
-                for(Future<?> future: resume_tasks.values()) {
-                    future.cancel(true);
-        }
-                resume_tasks.clear();
-            }
+            if(resumer != null)
+                resumer.cancel(false);
         }
 
         /**
-         * Waits until the current request has been processed, then clears the queue and discards new
+         * Waits until the current requests in the queue have been processed, then clears the queue and discards new
          * requests from now on
          */
-        public synchronized void suspend(MergeId merge_id) {
+        public synchronized void suspend() {
             if(!suspended) {
                 suspended=true;
                 queue.clear();
                 waitUntilCompleted(MAX_COMPLETION_TIME);
                 queue.close(true);
-                Resumer resumer=new Resumer(merge_id, resume_tasks, this);
-                Future<?> future=timer.schedule(resumer, resume_task_timeout, TimeUnit.MILLISECONDS);
-                Future<?> old_future=resume_tasks.put(merge_id, future);
-                if(old_future != null)
-                    old_future.cancel(true);
+                resumer=timer.schedule(new Runnable() {
+                    public void run() {
+                        resume();
+                    }
+                }, resume_task_timeout, TimeUnit.MILLISECONDS);
             }
         }
 
 
-        public synchronized void resume(MergeId merge_id) {
+        public synchronized void resume() {
             if(!suspended)
                 return;
-
-            Future future;
-            synchronized(resume_tasks) {
-                future=resume_tasks.remove(merge_id);
-            }
-            if(future != null)
-                future.cancel(true);
+            if(resumer != null)
+                resumer.cancel(false);
             resumeForce();
         }
 
@@ -1449,44 +1399,4 @@ private void process(List<Request> requests) {
     }
 
 
-    /**
-     * Resumer is a second line of defense: when the ViewHandler is suspended, it will be resumed when the current
-     * merge is cancelled, or when the merge completes. However, in a case where this never happens (this
-     * shouldn't be the case !), the Resumer will nevertheless resume the ViewHandler.
-     * We chose this strategy because ViewHandler is critical: if it is suspended indefinitely, we would
-     * not be able to process new JOIN requests ! So, this is for peace of mind, although it most likely
-     * will never be used...
-     */
-    static class Resumer implements Runnable {
-        final MergeId                     token;
-        final Map<MergeId,Future>         tasks;
-        final ViewHandler                 handler;
-
-
-        Resumer(final MergeId token, final Map<MergeId,Future> t, final ViewHandler handler) {
-            this.token=token;
-            this.tasks=t;
-            this.handler=handler;
-}
-
-        public void run() {
-            boolean executed=true;
-            synchronized(tasks) {
-                Future future=tasks.get(token);
-                if(future != null) {
-                    future.cancel(false);
-                    executed=true;
-                }
-                else {
-                    executed=false;
-                }
-                tasks.remove(token);
-            }
-            if(executed) {
-                handler.resume(token);
-            }
-        }
-    }
-
-
 }
\ No newline at end of file",2011-11-15T15:09:54Z,74
"@@ -27,7 +27,7 @@ if [ -f $HOME/logging.properties ]; then
     LOG=""$LOG -Djava.util.logging.config.file=$HOME/logging.properties""
 fi;
 
-JG_FLAGS=""-Djgroups.bind_addr=match-address:192.168.1.*""
+#JG_FLAGS=""-Djgroups.bind_addr=match-address:192.168.1.*""
 JG_FLAGS=""$JG_FLAGS -Djava.net.preferIPv4Stack=true""
 FLAGS=""-server -Xmx600M -Xms600M""
 FLAGS=""$FLAGS -XX:CompileThreshold=10000 -XX:ThreadStackSize=64K -XX:SurvivorRatio=8""",2015-12-24T10:15:46Z,38
"@@ -305,6 +305,12 @@ public void replaceConnection(Address address, Connection conn) {
         notifyConnectionEstablished(conn);
     }
 
+    public void closeConnection(Connection conn, Throwable ex) {
+        Util.close(conn);
+        notifyConnectionClosed(conn, ex.toString());
+        removeConnectionIfPresent(conn != null? conn.peerAddress() : null, conn);
+    }
+
 
     public synchronized void addConnection(Address peer_addr, Connection conn) throws Exception {
         boolean conn_exists=hasConnection(peer_addr),",2015-12-24T10:15:46Z,39
"@@ -4,7 +4,6 @@
 import org.jgroups.annotations.ManagedAttribute;
 import org.jgroups.annotations.ManagedOperation;
 import org.jgroups.util.ThreadFactory;
-import org.jgroups.util.Util;
 
 import java.nio.channels.*;
 import java.util.Iterator;
@@ -25,14 +24,13 @@ public abstract class NioBaseServer extends BaseServer {
     @ManagedAttribute(description=""Max number of send buffers. Changing this value affects new buffers only"",writable=true)
     protected int               max_send_buffers=5; // size of WriteBuffers send buffer array
 
-    @ManagedAttribute(description=""Max number of messages to read on an OP_READ"",writable=true)
-    protected int               max_read_batch_size=50;
-
     @ManagedAttribute(description=""Number of times select() was called"")
     protected int               num_selects;
 
     protected boolean           copy_on_partial_write=true;
 
+    protected long              reader_idle_time=20000;
+
 
 
     protected NioBaseServer(ThreadFactory f) {
@@ -43,12 +41,12 @@ protected NioBaseServer(ThreadFactory f) {
 
     public int            maxSendBuffers()              {return max_send_buffers;}
     public NioBaseServer  maxSendBuffers(int num)       {this.max_send_buffers=num; return this;}
-    public int            maxReadBatchSize()            {return max_read_batch_size;}
-    public NioBaseServer  maxReadBatchSize(int size)    {max_read_batch_size=size; return this;}
     public boolean        selectorOpen()                {return selector != null && selector.isOpen();}
     public boolean        acceptorRunning()             {return acceptor != null && acceptor.isAlive();}
     public int            numSelects()                  {return num_selects;}
     public boolean        copyOnPartialWrite()          {return copy_on_partial_write;}
+    public long           readerIdleTime()              {return reader_idle_time;}
+    public NioBaseServer  readerIdleTime(long t)        {reader_idle_time=t; return this;}
 
     public NioBaseServer  copyOnPartialWrite(boolean b) {
         this.copy_on_partial_write=b;
@@ -131,12 +129,8 @@ public void run() {
                     try {
                         if(!key.isValid())
                             continue;
-                        if(key.isReadable()) {
-                            if(max_read_batch_size > 1)
-                                conn.receive(max_read_batch_size);
-                            else
-                                conn.receive();
-                        }
+                        if(key.isReadable())
+                            conn.receive();
                         if(key.isWritable())
                             conn.send();
                         if(key.isAcceptable())
@@ -148,9 +142,7 @@ else if(key.isConnectable()) {
                         }
                     }
                     catch(Throwable ex) {
-                        Util.close(conn);
-                        notifyConnectionClosed(conn, ex.toString());
-                        removeConnectionIfPresent(conn != null? conn.peerAddress() : null, conn);
+                        closeConnection(conn, ex);
                     }
                 }
             }",2015-12-24T10:15:46Z,40
"@@ -5,10 +5,9 @@
 import org.jgroups.Version;
 import org.jgroups.nio.Buffers;
 import org.jgroups.stack.IpAddress;
-import org.jgroups.util.ByteArrayDataInputStream;
-import org.jgroups.util.ByteArrayDataOutputStream;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
@@ -33,15 +32,17 @@ public class NioConnection implements Connection {
     protected long                last_access;  // timestamp of the last access to this connection (read or write)
     protected final NioBaseServer server;
 
-    // {length, data} pair to send a message with a gathering write
-    protected final Buffers       send_buf;
+    protected final Buffers       send_buf;     // send messages via gathering writes
     protected boolean             write_interest_set; // set when a send() didn't manage to send all data
+    protected boolean             copy_on_partial_write=true;
+    protected int                 partial_writes; // number of partial writes (write which did not write all bytes)
     protected final Lock          send_lock=new ReentrantLock(); // serialize send()
 
     // creates an array of 2: length buffer (for reading the length of the following data buffer) and data buffer
-    protected Buffers             recv_buf=new Buffers(ByteBuffer.allocate(Global.INT_SIZE), null);
-    protected boolean             copy_on_partial_write=true;
-    protected int                 partial_writes; // number of partial writes (write which did not write all bytes)
+    protected Buffers             recv_buf=new Buffers(2).add(ByteBuffer.allocate(Global.INT_SIZE), null);
+    protected Reader              reader=new Reader(); // manages the thread which receives messages
+    protected long                reader_idle_time=20000; // number of ms a reader can be idle (no msgs) until it terminates
+
 
 
      /** Creates a connection stub and binds it, use {@link #connect(Address)} to connect */
@@ -106,19 +107,20 @@ public Address localAddress() {
     public NioConnection copyOnPartialWrite(boolean b) {this.copy_on_partial_write=b; return this;}
     public boolean       copyOnPartialWrite()          {return copy_on_partial_write;}
     public int           numPartialWrites()            {return partial_writes;}
+    public long          readerIdleTime()              {return reader_idle_time;}
+    public NioConnection readerIdleTime(long t)        {this.reader_idle_time=t; return this;}
+    public boolean       readerRunning()               {return this.reader.isRunning();}
 
-    public synchronized int registerSelectionKey(int interest_ops) {
+    public synchronized void registerSelectionKey(int interest_ops) {
         if(key == null)
-            return 0;
+            return;
         key.interestOps(key.interestOps() | interest_ops);
-        return key.interestOps();
     }
 
-    public synchronized int clearSelectionKey(int interest_ops) {
+    public synchronized void clearSelectionKey(int interest_ops) {
         if(key == null)
-            return 0;
+            return;
         key.interestOps(key.interestOps() & ~interest_ops);
-        return key.interestOps();
     }
 
 
@@ -208,21 +210,7 @@ public void send() throws Exception {
 
     /** Read the length first, then the actual data. This method is not reentrant and access must be synchronized */
     public void receive() throws Exception {
-        _receive(true);
-    }
-
-
-    /** Tries to receive up to max_msgs_to_receive messages in one go */
-    public void receive(int max_msgs_to_receive) throws Exception {
-        try {
-            while(max_msgs_to_receive-- > 0) {
-                if(!_receive(false))
-                    return;
-            }
-        }
-        finally {
-            updateLastAccessed();
-        }
+        reader.receive();
     }
 
 
@@ -252,7 +240,7 @@ public void close() throws IOException {
             if(send_buf.remaining() > 0) { // try to flush send buffer if it still has pending data to send
                 try {send();} catch(Throwable e) {}
             }
-            Util.close(channel);
+            Util.close(channel, reader);
         }
         finally {
             send_lock.unlock();
@@ -266,9 +254,9 @@ public String toString() {
         try {remote=channel != null? (InetSocketAddress)channel.getRemoteAddress() : null;} catch(Throwable t) {}
         String loc=local == null ? ""n/a"" : local.getHostString() + "":"" + local.getPort(),
           rem=remote == null? ""n/a"" : remote.getHostString() + "":"" + remote.getPort();
-        return String.format(""<%s --> %s> (%d secs old) [%s] [send_buf: %s, recv_buf: %s] [ops=%d]"",
+        return String.format(""<%s --> %s> (%d secs old) [%s] [recv_buf: %d, reader=%b]"",
                              loc, rem, TimeUnit.SECONDS.convert(getTimestamp() - last_access, TimeUnit.NANOSECONDS),
-                             status(), send_buf, recv_buf, key != null? key.interestOps() : -1);
+                             status(), recv_buf.get(1) != null? recv_buf.get(1).capacity() : 0, readerRunning());
     }
 
     protected String status() {
@@ -337,9 +325,7 @@ protected void sendLocalAddress(Address local_addr) throws Exception {
 
     protected Address readPeerAddress(ByteBuffer buf) throws Exception {
         ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf);
-
-        // then read the version
-        short version=in.readShort();
+        short version=in.readShort(); // version
         if(!Version.isBinaryCompatible(version))
             throw new IOException(""packet from "" + channel.getRemoteAddress() + "" has different version ("" + Version.print(version) +
                                     "") from ours ("" + Version.printVersion() + ""); discarding it"");
@@ -353,4 +339,119 @@ protected static ByteBuffer makeLengthBuffer(ByteBuffer buf) {
         return (ByteBuffer)ByteBuffer.allocate(Global.INT_SIZE).putInt(buf.remaining()).clear();
     }
 
+    protected enum State {reading, waiting_to_terminate, done}
+
+    protected class Reader implements Runnable, Closeable, Condition {
+        protected final Lock       lock=new ReentrantLock(); // to synchronize receive() and state transitions
+        protected State            state=State.done;
+        protected volatile boolean data_available=true;
+        protected final CondVar    data_available_cond=new CondVar();
+        protected volatile Thread  thread;
+        protected volatile boolean running;
+
+        protected void start() {
+            running=true;
+            thread=server.factory.newThread(this, String.format(""NioConnection.Reader [%s]"", peer_addr));
+            thread.setDaemon(true);
+            thread.start();
+        }
+
+
+        protected void stop() {
+            running=false;
+            data_available=true;
+            data_available_cond.signal(false);
+        }
+
+        public void    close() throws IOException {stop();}
+        public boolean isMet()                    {return data_available;}
+        public boolean isRunning()                {Thread tmp=thread; return tmp != null && tmp.isAlive();}
+
+        /** Called by the selector when data is ready to be read from the SocketChannel */
+        public void receive() {
+            lock.lock();
+            try {
+                data_available=true;
+                // only a single receive() at a time, until OP_READ is registered again (by the reader thread)
+                clear(SelectionKey.OP_READ);
+                switch(state) {
+                    case reading:
+                        break;
+                    case waiting_to_terminate:
+                        data_available_cond.signal(false); // only 1 consumer
+                        break;
+                    case done:
+                        // make sure the selector doesn't wake up for our connection while the reader is reading msgs
+                        state=State.reading;
+                        start();
+                        break;
+                }
+            }
+            finally {
+                lock.unlock();
+            }
+        }
+
+        public void run() {
+            try {
+                _run();
+            }
+            finally {
+                register(SelectionKey.OP_READ);
+            }
+        }
+
+        protected void _run() {
+            while(running) {
+                for(;;) { // try to receive as many msgs as possible, until no more msgs are ready or the conn is closed
+                    try {
+                        if(!_receive(false))
+                            break;
+                    }
+                    catch(Throwable ex) {
+                        server.closeConnection(NioConnection.this, ex);
+                        state(State.done);
+                        return;
+                    }
+                }
+                updateLastAccessed();
+
+                // Transition to state waiting_to_terminate and wait for server.readerIdleTime() ms
+                state(State.waiting_to_terminate);
+                data_available=false;
+                register(SelectionKey.OP_READ); // now we might get receive() calls again
+                if(data_available_cond.waitFor(this, server.readerIdleTime(), TimeUnit.MILLISECONDS))
+                    state(State.reading);
+                else {
+                    state(State.done);
+                    return;
+                }
+            }
+        }
+
+        protected void register(int op) {
+            try {
+                registerSelectionKey(op);
+                key.selector().wakeup(); // no-op if the selector is not blocked in select()
+            }
+            catch(Throwable t) {
+            }
+        }
+
+        protected void clear(int op) {
+            try {
+                clearSelectionKey(op);
+            }
+            catch(Throwable t) {
+            }
+        }
+
+        protected void state(State st) {
+            lock.lock();
+            try {this.state=st;}
+            finally {lock.unlock();}
+        }
+
+    }
+
 }",2015-12-24T10:15:46Z,41
"@@ -301,13 +301,9 @@ public Receiver stop() {
             return this;
         }
 
-        public boolean isRunning() {
-            return receiving;
-        }
-
-        public boolean canRun() {
-            return isRunning() && isConnected();
-        }
+        public boolean isRunning()  {return receiving;}
+        public boolean canRun()     {return isRunning() && isConnected();}
+        public int     bufferSize() {return buffer != null? buffer.length : 0;}
 
         public void run() {
             Throwable t=null;
@@ -409,10 +405,10 @@ public String toString() {
         InetAddress local=tmp_sock.getLocalAddress(), remote=tmp_sock.getInetAddress();
         String local_str=local != null? Util.shortName(local) : ""<null>"";
         String remote_str=remote != null? Util.shortName(remote) : ""<null>"";
-        return String.format(""%s:%s --> %s:%s (%d secs old) [%s]"",
+        return String.format(""%s:%s --> %s:%s (%d secs old) [%s] [recv_buf=%d]"",
                              local_str, tmp_sock.getLocalPort(), remote_str, tmp_sock.getPort(),
                              TimeUnit.SECONDS.convert(getTimestamp() - last_access, TimeUnit.NANOSECONDS),
-                             status());
+                             status(), receiver != null? receiver.bufferSize() : 0);
     }
 
     protected String status() {",2015-12-24T10:15:46Z,42
"@@ -82,6 +82,7 @@ public boolean hasRemaining() {
     public Buffers add(ByteBuffer ... buffers) {
         if(buffers == null)
             return this;
+        assertPositiveUnsignedShort(buffers.length);
         int len=buffers.length;
         if(spaceAvailable(len) || (makeSpace() && spaceAvailable(len))) {
             for(ByteBuffer buf: buffers)",2015-12-24T10:15:46Z,43
"@@ -44,6 +44,11 @@ public String printConnections() {
         return server.printConnections();
     }
 
+    @ManagedOperation(description=""Clears all connections (they will get re-established). For testing only, don't use !"")
+    public void clearConnections() {
+        server.clearConnections();
+    }
+
     public void setSocketFactory(SocketFactory factory) {
         super.setSocketFactory(factory);
         if(server != null)",2015-12-24T10:15:46Z,13
"@@ -29,16 +29,15 @@ public class TCP_NIO2 extends BasicTCP {
     @Property(description=""The max number of outgoing messages that can get queued for a given peer connection "" +
       ""(before dropping them). Most messages will ge retransmitted; this is mainly used at startup, e.g. to prevent "" +
       ""dropped discovery requests or responses (sent unreliably, without retransmission)."")
-    protected int max_send_buffers=10;
-
-    @Property(description=""Max number of messages a read will try to read from the socket. Setting this to a higher "" +
-      ""value will increase speed when receiving a lot of messages. However, all other reads and writes are delayed "" +
-      ""by the time the batch read takes."")
-    protected int max_read_batch_size=50;
+    protected int     max_send_buffers=10;
 
     @Property(description=""If true, a partial write will make a copy of the data so a buffer can be reused"")
     protected boolean copy_on_partial_write=true;
 
+    @Property(description=""Number of ms a reader thread on a given connection can be idle (not receiving any messages) "" +
+      ""until it terminates. New messages will start a new reader"")
+    protected long    reader_idle_time=5000;
+
 
     public TCP_NIO2() {}
 
@@ -57,19 +56,6 @@ public void clearConnections() {
         server.clearConnections();
     }
 
-    @ManagedAttribute
-    public int maxReadBatchSize() {
-        int tmp=server.maxReadBatchSize();
-        if(tmp != max_read_batch_size)
-            max_read_batch_size=tmp;
-        return max_read_batch_size;
-    }
-
-    @ManagedAttribute
-    public void maxReadBatchSize(int size) {
-        this.max_read_batch_size=size;
-        server.maxReadBatchSize(size);
-    }
 
     @ManagedAttribute(description=""Is the selector open"")
     public boolean isSelectorOpen() {return server != null && server.selectorOpen();}
@@ -83,6 +69,13 @@ public void maxReadBatchSize(int size) {
     @ManagedAttribute(description=""Number of partial writes for all connections (not all bytes were written)"")
     public int     numPartialWrites() {return server.numPartialWrites();}
 
+    @ManagedAttribute(description=""Number of ms a reader thread on a given connection can be idle (not receiving any messages) "" +
+      ""until it terminates. New messages will start a new reader"")
+    public void readerIdleTime(long t) {
+        this.reader_idle_time=t;
+        server.readerIdleTime(t);
+    }
+
 
     public void send(Address dest, byte[] data, int offset, int length) throws Exception {
         if(server != null) {
@@ -110,9 +103,9 @@ public void start() throws Exception {
           .tcpNodelay(tcp_nodelay).linger(linger)
           .clientBindAddress(client_bind_addr).clientBindPort(client_bind_port).deferClientBinding(defer_client_bind_addr)
           .log(this.log))
-          .maxSendBuffers(max_send_buffers).maxReadBatchSize(this.max_read_batch_size)
-          .usePeerConnections(true);
-        server.copyOnPartialWrite(this.copy_on_partial_write);
+          .maxSendBuffers(max_send_buffers).usePeerConnections(true);
+        server.copyOnPartialWrite(this.copy_on_partial_write)
+          .readerIdleTime(this.reader_idle_time);
 
         if(reaper_interval > 0 || conn_expire_time > 0) {
             if(reaper_interval == 0) {
@@ -126,7 +119,6 @@ public void start() throws Exception {
             server.connExpireTimeout(conn_expire_time).reaperInterval(reaper_interval);
         }
 
-        // we first start threads in TP (http://jira.jboss.com/jira/browse/JGRP-626)
         super.start();
     }
     ",2015-12-24T10:15:46Z,44
"@@ -60,7 +60,6 @@ public boolean waitFor(Condition condition, long timeout, TimeUnit unit) {
         try {
             for(long wait_time=timeout_ns, start=System.nanoTime(); wait_time > 0 && !condition.isMet();) {
                 try {
-                    // System.out.println(""wait("" + TimeUnit.MILLISECONDS.convert(wait_time,TimeUnit.NANOSECONDS) + "")"");
                     wait_time=cond.awaitNanos(wait_time);
                 }
                 catch(InterruptedException e) {",2015-12-24T10:15:46Z,45
"@@ -267,7 +267,7 @@ static void log(String msg) {
 
     protected static BaseServer create(boolean nio, int port) {
         try {
-            BaseServer retval=nio? new NioServer(bind_addr, port).maxSendBuffers(1024).maxReadBatchSize(20)
+            BaseServer retval=nio? new NioServer(bind_addr, port).maxSendBuffers(1024)
               : new TcpServer(bind_addr, port).useSendQueues(false);
             retval.usePeerConnections(true);
             retval.start();",2015-12-24T10:15:46Z,46
"@@ -25,15 +25,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.net.URL;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
+import java.util.*;
 
 /**
  * Iterates over all concrete Protocol classes and creates XML schema used for validation of configuration files.
@@ -113,12 +105,7 @@ protected static void generateProtocolSchema(Document xmldoc, Element parent, St
             String package_name=PROT_PACKAGE + (suffix == null || suffix.isEmpty()? """" : ""."" + suffix);
             Set<Class<?>> classes=getClasses(Protocol.class, package_name);
             List<Class<?>> sortedClasses = new LinkedList<>(classes);
-            Collections.sort(sortedClasses, new Comparator<Class<?>>() {
-                @Override
-                public int compare(Class<?> o1, Class<?> o2) {
-                    return o1.getCanonicalName().compareTo(o2.getCanonicalName());
-                }
-            });
+            Collections.sort(sortedClasses, (o1, o2) -> o1.getCanonicalName().compareTo(o2.getCanonicalName()));
             for (Class<?> clazz : sortedClasses)
                 classToXML(xmldoc, parent, clazz, package_name);
         }
@@ -205,22 +192,19 @@ private static Element createXMLTree(final Document xmldoc, Class<?> clazz, Stri
             choice.appendChild(tmp);
         }
 
-        Map<String, DelayingElementWriter> sortedElements = new TreeMap<String, DelayingElementWriter>();
+        Map<String, DelayingElementWriter> sortedElements =new TreeMap<>();
 
         XmlAttribute xml_attr=Util.getAnnotation(clazz, XmlAttribute.class);
         if(xml_attr != null) {
             String[] attrs=xml_attr.attrs();
             if(attrs.length > 0) {
                 Set<String> set=new HashSet<>(Arrays.asList(attrs)); // to weed out dupes
                 for(final String attr: set) {
-                    sortedElements.put(attr, new DelayingElementWriter() {
-                        @Override
-                        public void writeElement() {
-                            Element attributeElement = xmldoc.createElement(""xs:attribute"");
-                            attributeElement.setAttribute(""name"", attr);
-                            attributeElement.setAttribute(""type"", ""xs:string"");
-                            complexType.appendChild(attributeElement);
-                        }
+                    sortedElements.put(attr, () -> {
+                        Element attributeElement = xmldoc.createElement(""xs:attribute"");
+                        attributeElement.setAttribute(""name"", attr);
+                        attributeElement.setAttribute(""type"", ""xs:string"");
+                        complexType.appendChild(attributeElement);
                     });
                 }
             }
@@ -243,26 +227,23 @@ public void writeElement() {
                     if(property == null || property.isEmpty()) {
                         throw new IllegalArgumentException(""Cannot create empty attribute name for element xs:attribute, field is "" + field);
                     }
-                    sortedElements.put(property, new DelayingElementWriter() {
-                        @Override
-                        public void writeElement() {
-                            Element attributeElement = xmldoc.createElement(""xs:attribute"");
-                            attributeElement.setAttribute(""name"", property);
-
-                            // Agreement with Bela Ban on Jan-20-2009 (Go Obama!!!) to treat all types as
-                            // xs:string since we do not know where users are going to use
-                            // replacement tokens in configuration files. Therefore, the type becomes
-                            // indeterminate.
-                            attributeElement.setAttribute(""type"", ""xs:string"");
-                            complexType.appendChild(attributeElement);
-
-                            Element annotationElement = xmldoc.createElement(""xs:annotation"");
-                            attributeElement.appendChild(annotationElement);
-
-                            Element documentationElement = xmldoc.createElement(""xs:documentation"");
-                            documentationElement.setTextContent(r.description());
-                            annotationElement.appendChild(documentationElement);
-                        }
+                    sortedElements.put(property, () -> {
+                        Element attributeElement = xmldoc.createElement(""xs:attribute"");
+                        attributeElement.setAttribute(""name"", property);
+
+                        // Agreement with Bela Ban on Jan-20-2009 (Go Obama!!!) to treat all types as
+                        // xs:string since we do not know where users are going to use
+                        // replacement tokens in configuration files. Therefore, the type becomes
+                        // indeterminate.
+                        attributeElement.setAttribute(""type"", ""xs:string"");
+                        complexType.appendChild(attributeElement);
+
+                        Element annotationElement = xmldoc.createElement(""xs:annotation"");
+                        attributeElement.appendChild(annotationElement);
+
+                        Element documentationElement = xmldoc.createElement(""xs:documentation"");
+                        documentationElement.setTextContent(r.description());
+                        annotationElement.appendChild(documentationElement);
                     });
                 }
             }
@@ -280,23 +261,20 @@ public void writeElement() {
                 } else {
                     name = annotation.name();
                 }
-                sortedElements.put(name, new DelayingElementWriter() {
-                    @Override
-                    public void writeElement() {
-                        Element attributeElement = xmldoc.createElement(""xs:attribute"");
-                        attributeElement.setAttribute(""name"", name);
-                        attributeElement.setAttribute(""type"", ""xs:string"");
-                        complexType.appendChild(attributeElement);
-
-                        String desc = annotation.description();
-                        if (!desc.isEmpty()) {
-                            Element annotationElement = xmldoc.createElement(""xs:annotation"");
-                            attributeElement.appendChild(annotationElement);
-
-                            Element documentationElement = xmldoc.createElement(""xs:documentation"");
-                            documentationElement.setTextContent(annotation.description());
-                            annotationElement.appendChild(documentationElement);
-                        }
+                sortedElements.put(name, () -> {
+                    Element attributeElement = xmldoc.createElement(""xs:attribute"");
+                    attributeElement.setAttribute(""name"", name);
+                    attributeElement.setAttribute(""type"", ""xs:string"");
+                    complexType.appendChild(attributeElement);
+
+                    String desc = annotation.description();
+                    if (!desc.isEmpty()) {
+                        Element annotationElement = xmldoc.createElement(""xs:annotation"");
+                        attributeElement.appendChild(annotationElement);
+
+                        Element documentationElement = xmldoc.createElement(""xs:documentation"");
+                        documentationElement.setTextContent(annotation.description());
+                        annotationElement.appendChild(documentationElement);
                     }
                 });
             }",2016-09-30T12:49:35Z,33
"@@ -398,7 +398,7 @@ protected void setKeys(SecretKey key, byte[] version) throws Exception {
     }
 
 
-    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {
+    protected void sendSecretKey(Key secret_key, PublicKey public_key, Address source) throws Exception {
         byte[] encryptedKey=encryptSecretKey(secret_key, public_key);
         Message newMsg=new Message(source, encryptedKey).src(local_addr)
           .putHeader(this.id, new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, symVersion()));
@@ -407,7 +407,7 @@ protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address
     }
 
     /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */
-    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {
+    protected byte[] encryptSecretKey(Key secret_key, PublicKey public_key) throws Exception {
         Cipher tmp;
         if (provider != null && !provider.trim().isEmpty())
             tmp=Cipher.getInstance(asym_algorithm, provider);",2017-01-12T09:23:25Z,75
"@@ -7,7 +7,7 @@
 import org.jgroups.util.*;
 
 import javax.crypto.Cipher;
-import javax.crypto.SecretKey;
+import java.security.Key;
 import java.security.MessageDigest;
 import java.util.Arrays;
 import java.util.Map;
@@ -70,7 +70,7 @@ public abstract class Encrypt extends Protocol {
     protected volatile byte[]               sym_version;
 
     // shared secret key to encrypt/decrypt messages
-    protected volatile SecretKey            secret_key;
+    protected volatile Key                  secret_key;
 
     // map to hold previous keys so we can decrypt some earlier messages if we need to
     protected Map<AsciiString,Cipher>       key_map;
@@ -81,8 +81,8 @@ public abstract class Encrypt extends Protocol {
     public <T extends Encrypt> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
     public int                      symKeylength()                  {return sym_keylength;}
     public <T extends Encrypt> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
-    public SecretKey                secretKey()                     {return secret_key;}
-    public <T extends Encrypt> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public Key                      secretKey()                     {return secret_key;}
+    public <T extends Encrypt> T    secretKey(Key key)              {this.secret_key=key; return (T)this;}
     public String                   symAlgorithm()                  {return sym_algorithm;}
     public <T extends Encrypt> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
     public String                   asymAlgorithm()                 {return asym_algorithm;}
@@ -189,7 +189,7 @@ public void up(MessageBatch batch) {
 
 
     /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
-    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+    protected synchronized void initSymCiphers(String algorithm, Key secret) throws Exception {
         if(secret == null)
             return;
         encoding_ciphers.clear();
@@ -210,7 +210,7 @@ protected synchronized void initSymCiphers(String algorithm, SecretKey secret) t
     }
 
 
-    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+    protected Cipher createCipher(int mode, Key secret_key, String algorithm) throws Exception {
         Cipher cipher=provider != null && !provider.trim().isEmpty()?
           Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
         cipher.init(mode, secret_key);",2017-01-12T09:23:25Z,76
"@@ -4,10 +4,10 @@
 import org.jgroups.annotations.Property;
 import org.jgroups.util.Util;
 
-import javax.crypto.SecretKey;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.security.Key;
 import java.security.KeyStore;
 import java.security.NoSuchAlgorithmException;
 import java.security.cert.CertificateException;
@@ -86,7 +86,7 @@ protected void readSecretKeyFromKeystore() throws Exception {
         // must not use default keystore type - as it does not support secret keys
         KeyStore store=KeyStore.getInstance(keystore_type != null? keystore_type : KeyStore.getDefaultType());
 
-        SecretKey tempKey=null;
+        Key tempKey=null;
         try {
             if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test
                 // load in keystore using this thread's classloader
@@ -100,7 +100,7 @@ protected void readSecretKeyFromKeystore() throws Exception {
                 try {
                     store.load(inputStream, store_password.toCharArray());
                     // loaded keystore - get the key
-                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());
+                    tempKey=store.getKey(alias, key_password.toCharArray());
                 }
                 catch(IOException e) {
                     throw new Exception(""Unable to load keystore "" + keystore_name + "": "" + e);",2017-01-12T09:23:25Z,77
"@@ -0,0 +1,437 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.BiConsumer;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class Encrypt extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO=""AES"";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description=""Cryptographic Service Provider"")
+    protected String                        provider;
+
+    @Property(description=""Cipher engine transformation for asymmetric algorithm. Default is RSA"")
+    protected String                        asym_algorithm=""RSA"";
+
+    @Property(description=""Cipher engine transformation for symmetric algorithm. Default is AES"")
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    @Property(description=""Initial public/private key length. Default is 512"")
+    protected int                           asym_keylength=512;
+
+    @Property(description=""Initial key length for matching symmetric algorithm. Default is 128"")
+    protected int                           sym_keylength=128;
+
+    @Property(description=""Number of ciphers in the pool to parallelize encrypt and decrypt requests"",writable=false)
+    protected int                           cipher_pool_size=8;
+
+    @Property(description=""If true, the entire message (including payload and headers) is encrypted, else only the payload"")
+    protected boolean                       encrypt_entire_message=true;
+
+    @Property(description=""If true, all messages are digitally signed by adding an encrypted checksum of the encrypted "" +
+      ""message to the header. Ignored if encrypt_entire_message is false"")
+    protected boolean                       sign_msgs=true;
+
+    @Property(description=""When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is "" +
+      ""true, Adler32 will be used"")
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();
+
+
+
+    public int                      asymKeylength()                 {return asym_keylength;}
+    public <T extends Encrypt> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
+    public int                      symKeylength()                  {return sym_keylength;}
+    public <T extends Encrypt> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
+    public SecretKey                secretKey()                     {return secret_key;}
+    public <T extends Encrypt> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public String                   symAlgorithm()                  {return sym_algorithm;}
+    public <T extends Encrypt> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
+    public String                   asymAlgorithm()                 {return asym_algorithm;}
+    public <T extends Encrypt> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}
+    public byte[]                   symVersion()                    {return sym_version;}
+    public <T extends Encrypt> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}
+    public <T extends Encrypt> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}
+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}
+    public <T extends Encrypt> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}
+    public boolean                  signMessages()                  {return this.sign_msgs;}
+    public <T extends Encrypt> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}
+    public boolean                  adler()                         {return use_adler;}
+    public <T extends Encrypt> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}
+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn(""%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation"", local_addr, cipher_pool_size, tmp);
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    if(secret_key == null) {
+                        log.trace(""%s: discarded %s message to %s as secret key is null, hdrs: %s"",
+                                  local_addr, msg.dest() == null? ""mcast"" : ""unicast"", msg.dest(), msg.printHeaders());
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: unable to send message down"", local_addr, e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=evt.getArg();
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: exception occurred decrypting message"", local_addr, e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    public void up(MessageBatch batch) {
+        Cipher cipher=null;
+        try {
+            if(secret_key == null) {
+                log.trace(""%s: discarded %s batch from %s as secret key is null"",
+                          local_addr, batch.dest() == null? ""mcast"" : ""unicast"", batch.sender());
+                return;
+            }
+            BiConsumer<Message,MessageBatch> decrypter=new Decrypter(cipher=decoding_ciphers.take());
+            batch.forEach(decrypter);
+        }
+        catch(InterruptedException e) {
+            log.error(""%s: failed processing batch; discarding batch"", local_addr, e);
+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages
+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption
+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted
+            return;
+        }
+        finally {
+            if(cipher != null)
+                decoding_ciphers.offer(cipher);
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance(""MD5"");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug(""%s: created %d symmetric ciphers with secret key (%d bytes)"", local_addr, cipher_pool_size, sym_version.length);
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(hdr == null) {
+            log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, msg.src());
+            return null;
+        }
+        switch(hdr.type()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn(""%s: unrecognized cipher; discarding message from %s"", local_addr, msg.src());
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(error_msg, sender, curr_view);
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(!Arrays.equals(hdr.version(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.version()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace(""%s: decrypting msg from %s using previous cipher version"", local_addr, msg.src());
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.signature();
+            if(signature == null) {
+                log.error(""%s: dropped message from %s as the header did not have a checksum"", local_addr, msg.src());
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error(""%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)"",
+                          local_addr, msg.src(), msg_checksum, actual_checksum);
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            Buffer serialized_msg=Util.streamableToBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.signature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from ""algorithm/mode/padding""  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
+    protected class Decrypter implements BiConsumer<Message,MessageBatch> {
+        protected final Cipher cipher;
+
+        public Decrypter(Cipher cipher) {
+            this.cipher=cipher;
+        }
+
+        public void accept(Message msg, MessageBatch batch) {
+            EncryptHeader hdr;
+            if((hdr=msg.getHeader(id)) == null) {
+                log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, batch.sender());
+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch
+                return;
+            }
+
+            if(hdr.type() == EncryptHeader.ENCRYPT) {
+                try {
+                    if(!process(msg)) {
+                        batch.remove(msg);
+                        return;
+                    }
+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
+                    if(tmpMsg != null)
+                        batch.replace(msg, tmpMsg);
+                    else
+                        batch.remove(msg);
+                }
+                catch(Exception e) {
+                    log.error(""%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s"",
+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
+                    batch.remove(msg);
+                }
+            }
+            else {
+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
+                handleUpEvent(msg, hdr);
+            }
+        }
+    }
+
+}",2016-06-14T06:16:20Z,76
"@@ -19,6 +19,7 @@
         <dependency org=""org.jboss.byteman""        name=""byteman-submit""          rev=""3.+""/>
         <dependency org=""org.apache.logging.log4j"" name=""log4j-api""               rev=""2.+""/>
         <dependency org=""org.apache.logging.log4j"" name=""log4j-core""              rev=""2.+""/>
+        <dependency org=""org.slf4j""                name=""slf4j-api""               rev=""1.7+""/>
         <dependency org=""org.testng""               name=""testng""                  rev=""6.9.+""/>
         <dependency org=""com.beust""                name=""jcommander""              rev=""1.+""/>
         <!--dependency org=""org.sonatype.nexus.ant""   name=""nexus-staging-ant-tasks"" rev=""1.6.3""/-->",2016-09-30T14:04:14Z,78
"@@ -114,6 +114,11 @@
             <version>(2,)</version>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>[1.7,)</version>
+        </dependency>
 
         <!-- Test dependencies -->
         <dependency>",2016-09-30T14:04:14Z,79
"@@ -54,6 +54,8 @@ public final class Global {
     public static final String IPV6_MCAST_PREFIX=""jgroups.ipmcast.prefix"";
 
     public static final String USE_JDK_LOGGER=""jgroups.use.jdk_logger""; // forces use of the JDK logger
+    public static final String LOG_CLASS=""jgroups.log_class""; // class of preferred logger
+
     /** System prop for defining the default number of headers in a Message */
     public static final String DEFAULT_HEADERS=""jgroups.msg.default_headers"";
 ",2016-09-30T14:04:14Z,10
"@@ -1,6 +1,9 @@
 package org.jgroups.logging;
 
 import org.jgroups.Global;
+import org.jgroups.util.Util;
+
+import java.lang.reflect.Constructor;
 
 
 /**
@@ -11,17 +14,34 @@
  * @since 4.0
  */
 public final class LogFactory {
-    public static final boolean       IS_LOG4J2_AVAILABLE; // log4j2 is the default
-    protected static boolean          use_jdk_logger;
-    protected static CustomLogFactory custom_log_factory=null;
+
+
+    public static final boolean                 IS_SLF4J_AVAILABLE;
+    public static final boolean                 IS_LOG4J2_AVAILABLE;  // log4j2 is the default logger
+    protected static boolean                    use_jdk_logger;
+    protected static CustomLogFactory           custom_log_factory=null;
+    protected static Constructor<? extends Log> ctor_class=null, ctor_str=null;
 
 	private LogFactory() {
 		throw new InstantiationError( ""Must not instantiate this class"" );
 	}
 
     static {
         use_jdk_logger=isPropertySet(Global.USE_JDK_LOGGER);
+
+        String classname=Util.getProperty(Global.LOG_CLASS);
+        if(classname != null) {
+            try {
+                ctor_class=findConstructor(classname, Class.class);
+                ctor_str=findConstructor(classname, String.class);
+            }
+            catch(Exception e) {
+                throw new IllegalArgumentException(String.format(""failed loading logger %s"", classname), e);
+            }
+        }
+
         IS_LOG4J2_AVAILABLE=isAvailable(""org.apache.logging.log4j.core.Logger"");
+        IS_SLF4J_AVAILABLE=isAvailable(""org.slf4j.Logger"");
     }
 
     public static CustomLogFactory getCustomLogFactory()                         {return custom_log_factory;}
@@ -30,8 +50,13 @@ private LogFactory() {
     public static void             useJdkLogger(boolean flag)                    {use_jdk_logger=flag;}
 
     public static String loggerType() {
+        if(ctor_class != null)
+            return ctor_class.getDeclaringClass().getSimpleName();
+        if(ctor_str != null)
+            ctor_str.getDeclaringClass().getSimpleName();
         if(use_jdk_logger)      return ""jdk"";
         if(IS_LOG4J2_AVAILABLE) return ""log4j2"";
+        if(IS_SLF4J_AVAILABLE)  return ""slf4j"";
         return ""jdk"";
     }
 
@@ -57,25 +82,54 @@ public static Log getLog(Class clazz) {
         if(custom_log_factory != null)
             return custom_log_factory.getLog(clazz);
 
+        if(ctor_class != null) {
+            try {
+                return ctor_class.newInstance(clazz);
+            }
+            catch(Throwable t) {
+                throw new RuntimeException(t);
+            }
+        }
+
         if(use_jdk_logger)
             return new JDKLogImpl(clazz);
 
         if(IS_LOG4J2_AVAILABLE)
             return new Log4J2LogImpl(clazz);
 
+        if (IS_SLF4J_AVAILABLE)
+            return new Slf4jLogImpl(clazz);
+
         return new JDKLogImpl(clazz);
     }
 
     public static Log getLog(String category) {
         if(custom_log_factory != null)
             return custom_log_factory.getLog(category);
 
+        if(ctor_str != null) {
+            try {
+                ctor_str.newInstance(category);
+            }
+            catch(Throwable t) {
+                throw new RuntimeException(t);
+            }
+        }
+
         if(use_jdk_logger)
             return new JDKLogImpl(category);
 
         if(IS_LOG4J2_AVAILABLE)
             return new Log4J2LogImpl(category);
 
+        if (IS_SLF4J_AVAILABLE)
+            return new Slf4jLogImpl(category);
+
         return new JDKLogImpl(category);
     }
+
+    protected static Constructor<? extends Log> findConstructor(String classname, Class arg) throws Exception {
+        Class<?> clazz=Util.loadClass(classname, (Class)null);
+        return (Constructor<? extends Log>)clazz.getDeclaredConstructor(arg);
+    }
 }",2016-09-30T14:04:14Z,80
"@@ -0,0 +1,191 @@
+package org.jgroups.logging;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.LinkedHashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.function.Function;
+
+/**
+ * Logger that delivers messages to a SLF4J logger
+ *
+ * @author Konstantin Gusarov
+ * @since 4.0.0
+ */
+public class Slf4jLogImpl implements Log {
+    private static final Map<Function<Logger, Boolean>, String> LEVELS = new LinkedHashMap<>();
+    private static final Locale                 LOCALE = new Locale(System.getProperty(""user.language""),
+                                                                    System.getProperty(""user.country""));
+
+    static {
+        LEVELS.put(Logger::isErrorEnabled, ""ERROR"");
+        LEVELS.put(Logger::isWarnEnabled, ""WARN"");
+        LEVELS.put(Logger::isInfoEnabled, ""INFO"");
+        LEVELS.put(Logger::isDebugEnabled, ""DEBUG"");
+        LEVELS.put(Logger::isTraceEnabled, ""TRACE"");
+    }
+
+    private final Logger logger;
+    private final Locale locale;
+
+    public Slf4jLogImpl(final Class<?> clazz) {
+        this(LOCALE, LoggerFactory.getLogger(clazz));
+    }
+
+    public Slf4jLogImpl(final String category) {
+        this(LOCALE, LoggerFactory.getLogger(category));
+    }
+
+    public Slf4jLogImpl(final Locale locale, final Logger logger) {
+        this.logger = logger;
+        this.locale = locale;
+    }
+
+    @Override
+    public boolean isFatalEnabled() {
+        return logger.isErrorEnabled();
+    }
+
+    @Override
+    public boolean isErrorEnabled() {
+        return logger.isErrorEnabled();
+    }
+
+    @Override
+    public boolean isWarnEnabled() {
+        return logger.isWarnEnabled();
+    }
+
+    @Override
+    public boolean isInfoEnabled() {
+        return logger.isInfoEnabled();
+    }
+
+    @Override
+    public boolean isDebugEnabled() {
+        return logger.isDebugEnabled();
+    }
+
+    @Override
+    public boolean isTraceEnabled() {
+        return logger.isTraceEnabled();
+    }
+
+    @Override
+    public void fatal(final String msg) {
+        logger.error(msg);
+    }
+
+    @Override
+    public void fatal(final String msg, final Object... args) {
+        final String formatted = String.format(locale, msg, args);
+        logger.error(formatted);
+    }
+
+    @Override
+    public void fatal(final String msg, final Throwable throwable) {
+        logger.error(msg, throwable);
+    }
+
+    @Override
+    public void error(final String msg) {
+        logger.error(msg);
+    }
+
+    @Override
+    public void error(final String format, final Object... args) {
+        final String formatted = String.format(locale, format, args);
+        logger.error(formatted);
+    }
+
+    @Override
+    public void error(final String msg, final Throwable throwable) {
+        logger.error(msg, throwable);
+    }
+
+    @Override
+    public void warn(final String msg) {
+        logger.warn(msg);
+    }
+
+    @Override
+    public void warn(final String msg, final Object... args) {
+        final String formatted = String.format(locale, msg, args);
+        logger.warn(formatted);
+    }
+
+    @Override
+    public void warn(final String msg, final Throwable throwable) {
+        logger.warn(msg, throwable);
+    }
+
+    @Override
+    public void info(final String msg) {
+        logger.info(msg);
+    }
+
+    @Override
+    public void info(final String msg, final Object... args) {
+        final String formatted = String.format(locale, msg, args);
+        logger.info(formatted);
+    }
+
+    @Override
+    public void debug(final String msg) {
+        logger.debug(msg);
+    }
+
+    @Override
+    public void debug(final String msg, final Object... args) {
+        final String formatted = String.format(locale, msg, args);
+        logger.info(formatted);
+    }
+
+    @Override
+    public void debug(final String msg, final Throwable throwable) {
+        logger.debug(msg, throwable);
+    }
+
+    @Override
+    public void trace(final Object msg) {
+        logger.trace(""{}"", msg);
+    }
+
+    @Override
+    public void trace(final String msg) {
+        logger.trace(msg);
+    }
+
+    @Override
+    public void trace(final String msg, final Object... args) {
+        final String formatted = String.format(locale, msg, args);
+        logger.info(formatted);
+    }
+
+    @Override
+    public void trace(final String msg, final Throwable throwable) {
+        logger.trace(msg, throwable);
+    }
+
+    @Override
+    public void setLevel(final String level) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getLevel() {
+        String result = ""NONE"";
+
+        for (final Map.Entry<Function<Logger, Boolean>, String> entry : LEVELS.entrySet()) {
+            if (entry.getKey().apply(logger)) {
+                result = entry.getValue();
+            } else {
+                break;
+            }
+        }
+
+        return result;
+    }
+}",2016-09-30T14:04:14Z,81
"@@ -54,23 +54,26 @@ public class StompConnection implements Runnable {
 
     protected String password;
 
+    protected boolean reconnect;
+
     protected final Log log=LogFactory.getLog(getClass());
 
     /**
      * @param dest IP address + ':' + port, e.g. ""192.168.1.5:8787""
      */
     public StompConnection(String dest) {
-        this(dest, null, null, false);
+        this(dest, null, null, false, false);
     }
 
-    public StompConnection(String dest, boolean ssl) {
-        this(dest, null, null, ssl);
+    public StompConnection(String dest, boolean reconnect, boolean ssl) {
+        this(dest, null, null, reconnect, ssl);
     }
 
-    public StompConnection(String dest, String userid, String password, boolean ssl) {
+    public StompConnection(String dest, String userid, String password, boolean reconnect, boolean ssl) {;
         server_destinations.add(dest);
         this.userid = userid;
         this.password = password;
+        this.reconnect = reconnect;
         if (ssl)
             socket_factory = SSLSocketFactory.getDefault();
         else
@@ -89,10 +92,6 @@ public void removeListener(Listener listener) {
             listeners.remove(listener);
     }
 
-    public void connect() {
-        startRunner();
-    }
-
     protected synchronized void startRunner() {
         if(runner == null || !runner.isAlive()) {
             running = true;
@@ -110,21 +109,16 @@ protected void sendConnect() {
             sb.append(""passcode: "").append(password).append(""\n"");
         sb.append(""\n"");
 
-        try{
+        try {
             out.write(sb.toString().getBytes());
             out.write(STOMP.NULL_BYTE);
             out.flush();
         }
         catch(IOException ex) {
-            log.error(""failed to send connect message: "" + ex);
+            log.error(""failed to send connect message:"", ex);
         }
     }
 
-    public void disconnect() {
-        running=false;
-        close();
-    }
-
     public void subscribe(String destination) {
         if(destination == null)
             return;
@@ -147,7 +141,7 @@ protected void sendSubscribe(String destination) {
             out.flush();
         }
         catch(IOException ex) {
-            log.error(""failed subscribing to "" + destination + "": "" + ex);
+            log.error(""failed subscribing to "" + destination + "": "", ex);
         }
     }
 
@@ -173,14 +167,11 @@ protected void sendUnsubscribe(String destination) {
             out.flush();
         }
         catch(IOException ex) {
-            log.error(""failed unsubscribing from "" + destination + "": "" + ex);
+            log.error(""failed unsubscribing from "" + destination + "": "", ex);
         }
     }
 
     public void send(String destination, byte[] buf, int offset, int length, String ... headers) {
-        if(!isConnected())
-            return;
-
         StringBuilder sb=new StringBuilder();
         sb.append(STOMP.ClientVerb.SEND.name()).append(""\n"");
         if(destination != null)
@@ -200,8 +191,8 @@ public void send(String destination, byte[] buf, int offset, int length, String
             out.write(STOMP.NULL_BYTE);
             out.flush();
         }
-        catch(IOException ex) {
-            log.error(""failed sending message to server: "" + ex);
+        catch (IOException e) {
+            log.error(""failed sending message to "" + destination + "": "", e);
         }
     }
 
@@ -224,8 +215,17 @@ public void run() {
         int timeout = 1;
         while(running) {
             try {
-                if(!isConnected()) {
-                    setupConnection();
+                if (!isConnected() && reconnect) {
+                    log.error(""Reconnecting in ""+timeout+""s."");
+                    try {
+                        Thread.sleep(timeout * 1000);
+                    }
+                    catch (InterruptedException e1) {
+                        // pass
+                    }
+                    timeout = timeout*2 > 60 ? 60 : timeout*2;
+
+                    connect();
                 }
 
                 // reset the connection backoff when we successfully connect.
@@ -269,15 +269,13 @@ public void run() {
                 }
             }
             catch(IOException e) {
-                log.error(""Connection closed unexpectedly, will attempt reconnect in ""+timeout+""s."", e);
-                close();
-                try {
-                    Thread.sleep(timeout * 1000);
+                log.error(""Connection closed unexpectedly:"", e);
+                if (reconnect) {
+                    closeConnections();
                 }
-                catch (InterruptedException e1) {
-                    // pass
+                else {
+                    disconnect();
                 }
-                timeout = timeout*2 > 60 ? 60 : timeout*2;
             }
             catch(Throwable t) {
                 log.error(""failure reading frame"", t);
@@ -307,7 +305,7 @@ protected void notifyListeners(Map<String,String> info) {
         }
     }
 
-    protected void setupConnection() throws IOException{
+    public void connect() throws IOException{
         for (String dest : server_destinations) {
             try {
                 connectToDestination(dest);
@@ -320,12 +318,19 @@ protected void setupConnection() throws IOException{
             }
             catch(IOException ex) {
                 if(log.isErrorEnabled())
-                    log.error(""failed connecting to "" + dest);
-                close();
+                    log.error(""failed connecting to "" + dest, ex);
+                closeConnections();
             }
         }
+
         if(!isConnected())
             throw new IOException(""no target server available"");
+
+        startRunner();
+    }
+
+    public void startReconnectingClient() {
+        startRunner();
     }
 
     protected void connectToDestination(String dest) throws IOException {
@@ -340,7 +345,12 @@ protected void connectToDestination(String dest) throws IOException {
         out=new DataOutputStream(sock.getOutputStream());
     }
 
-    protected void close() {
+    public void disconnect() {
+        running = false;
+        closeConnections();
+    }
+
+    protected void closeConnections() {
         Util.close(in);
         Util.close(out);
         Util.close(sock);
@@ -383,10 +393,6 @@ public void onInfo(Map<String, String> information) {
             }
         });
 
-        if(!conn.isConnected()) {
-            conn.setupConnection();
-        }
-
         conn.connect();
 
         while(conn.isConnected()) {",2011-05-30T18:01:56Z,82
"@@ -0,0 +1,437 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.BiConsumer;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class Encrypt extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO=""AES"";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description=""Cryptographic Service Provider"")
+    protected String                        provider;
+
+    @Property(description=""Cipher engine transformation for asymmetric algorithm. Default is RSA"")
+    protected String                        asym_algorithm=""RSA"";
+
+    @Property(description=""Cipher engine transformation for symmetric algorithm. Default is AES"")
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    @Property(description=""Initial public/private key length. Default is 512"")
+    protected int                           asym_keylength=512;
+
+    @Property(description=""Initial key length for matching symmetric algorithm. Default is 128"")
+    protected int                           sym_keylength=128;
+
+    @Property(description=""Number of ciphers in the pool to parallelize encrypt and decrypt requests"",writable=false)
+    protected int                           cipher_pool_size=8;
+
+    @Property(description=""If true, the entire message (including payload and headers) is encrypted, else only the payload"")
+    protected boolean                       encrypt_entire_message=true;
+
+    @Property(description=""If true, all messages are digitally signed by adding an encrypted checksum of the encrypted "" +
+      ""message to the header. Ignored if encrypt_entire_message is false"")
+    protected boolean                       sign_msgs=true;
+
+    @Property(description=""When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is "" +
+      ""true, Adler32 will be used"")
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();
+
+
+
+    public int                      asymKeylength()                 {return asym_keylength;}
+    public <T extends Encrypt> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
+    public int                      symKeylength()                  {return sym_keylength;}
+    public <T extends Encrypt> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
+    public SecretKey                secretKey()                     {return secret_key;}
+    public <T extends Encrypt> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public String                   symAlgorithm()                  {return sym_algorithm;}
+    public <T extends Encrypt> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
+    public String                   asymAlgorithm()                 {return asym_algorithm;}
+    public <T extends Encrypt> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}
+    public byte[]                   symVersion()                    {return sym_version;}
+    public <T extends Encrypt> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}
+    public <T extends Encrypt> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}
+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}
+    public <T extends Encrypt> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}
+    public boolean                  signMessages()                  {return this.sign_msgs;}
+    public <T extends Encrypt> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}
+    public boolean                  adler()                         {return use_adler;}
+    public <T extends Encrypt> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}
+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn(""%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation"", local_addr, cipher_pool_size, tmp);
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    if(secret_key == null) {
+                        log.trace(""%s: discarded %s message to %s as secret key is null, hdrs: %s"",
+                                  local_addr, msg.dest() == null? ""mcast"" : ""unicast"", msg.dest(), msg.printHeaders());
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: unable to send message down"", local_addr, e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=evt.getArg();
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: exception occurred decrypting message"", local_addr, e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    public void up(MessageBatch batch) {
+        Cipher cipher=null;
+        try {
+            if(secret_key == null) {
+                log.trace(""%s: discarded %s batch from %s as secret key is null"",
+                          local_addr, batch.dest() == null? ""mcast"" : ""unicast"", batch.sender());
+                return;
+            }
+            BiConsumer<Message,MessageBatch> decrypter=new Decrypter(cipher=decoding_ciphers.take());
+            batch.forEach(decrypter);
+        }
+        catch(InterruptedException e) {
+            log.error(""%s: failed processing batch; discarding batch"", local_addr, e);
+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages
+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption
+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted
+            return;
+        }
+        finally {
+            if(cipher != null)
+                decoding_ciphers.offer(cipher);
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance(""MD5"");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug(""%s: created %d symmetric ciphers with secret key (%d bytes)"", local_addr, cipher_pool_size, sym_version.length);
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(hdr == null) {
+            log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, msg.src());
+            return null;
+        }
+        switch(hdr.type()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn(""%s: unrecognized cipher; discarding message from %s"", local_addr, msg.src());
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(error_msg, sender, curr_view);
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(!Arrays.equals(hdr.version(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.version()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace(""%s: decrypting msg from %s using previous cipher version"", local_addr, msg.src());
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.signature();
+            if(signature == null) {
+                log.error(""%s: dropped message from %s as the header did not have a checksum"", local_addr, msg.src());
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error(""%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)"",
+                          local_addr, msg.src(), msg_checksum, actual_checksum);
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            Buffer serialized_msg=Util.streamableToBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.signature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from ""algorithm/mode/padding""  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
+    protected class Decrypter implements BiConsumer<Message,MessageBatch> {
+        protected final Cipher cipher;
+
+        public Decrypter(Cipher cipher) {
+            this.cipher=cipher;
+        }
+
+        public void accept(Message msg, MessageBatch batch) {
+            EncryptHeader hdr;
+            if((hdr=msg.getHeader(id)) == null) {
+                log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, batch.sender());
+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch
+                return;
+            }
+
+            if(hdr.type() == EncryptHeader.ENCRYPT) {
+                try {
+                    if(!process(msg)) {
+                        batch.remove(msg);
+                        return;
+                    }
+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
+                    if(tmpMsg != null)
+                        batch.replace(msg, tmpMsg);
+                    else
+                        batch.remove(msg);
+                }
+                catch(Exception e) {
+                    log.error(""%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s"",
+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
+                    batch.remove(msg);
+                }
+            }
+            else {
+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
+                handleUpEvent(msg, hdr);
+            }
+        }
+    }
+
+}",2016-06-14T06:16:20Z,76
"@@ -0,0 +1,437 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.BiConsumer;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class Encrypt extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO=""AES"";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description=""Cryptographic Service Provider"")
+    protected String                        provider;
+
+    @Property(description=""Cipher engine transformation for asymmetric algorithm. Default is RSA"")
+    protected String                        asym_algorithm=""RSA"";
+
+    @Property(description=""Cipher engine transformation for symmetric algorithm. Default is AES"")
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    @Property(description=""Initial public/private key length. Default is 512"")
+    protected int                           asym_keylength=512;
+
+    @Property(description=""Initial key length for matching symmetric algorithm. Default is 128"")
+    protected int                           sym_keylength=128;
+
+    @Property(description=""Number of ciphers in the pool to parallelize encrypt and decrypt requests"",writable=false)
+    protected int                           cipher_pool_size=8;
+
+    @Property(description=""If true, the entire message (including payload and headers) is encrypted, else only the payload"")
+    protected boolean                       encrypt_entire_message=true;
+
+    @Property(description=""If true, all messages are digitally signed by adding an encrypted checksum of the encrypted "" +
+      ""message to the header. Ignored if encrypt_entire_message is false"")
+    protected boolean                       sign_msgs=true;
+
+    @Property(description=""When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is "" +
+      ""true, Adler32 will be used"")
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();
+
+
+
+    public int                      asymKeylength()                 {return asym_keylength;}
+    public <T extends Encrypt> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
+    public int                      symKeylength()                  {return sym_keylength;}
+    public <T extends Encrypt> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
+    public SecretKey                secretKey()                     {return secret_key;}
+    public <T extends Encrypt> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public String                   symAlgorithm()                  {return sym_algorithm;}
+    public <T extends Encrypt> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
+    public String                   asymAlgorithm()                 {return asym_algorithm;}
+    public <T extends Encrypt> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}
+    public byte[]                   symVersion()                    {return sym_version;}
+    public <T extends Encrypt> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}
+    public <T extends Encrypt> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}
+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}
+    public <T extends Encrypt> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}
+    public boolean                  signMessages()                  {return this.sign_msgs;}
+    public <T extends Encrypt> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}
+    public boolean                  adler()                         {return use_adler;}
+    public <T extends Encrypt> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}
+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn(""%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation"", local_addr, cipher_pool_size, tmp);
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    if(secret_key == null) {
+                        log.trace(""%s: discarded %s message to %s as secret key is null, hdrs: %s"",
+                                  local_addr, msg.dest() == null? ""mcast"" : ""unicast"", msg.dest(), msg.printHeaders());
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: unable to send message down"", local_addr, e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=evt.getArg();
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn(""%s: exception occurred decrypting message"", local_addr, e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    public void up(MessageBatch batch) {
+        Cipher cipher=null;
+        try {
+            if(secret_key == null) {
+                log.trace(""%s: discarded %s batch from %s as secret key is null"",
+                          local_addr, batch.dest() == null? ""mcast"" : ""unicast"", batch.sender());
+                return;
+            }
+            BiConsumer<Message,MessageBatch> decrypter=new Decrypter(cipher=decoding_ciphers.take());
+            batch.forEach(decrypter);
+        }
+        catch(InterruptedException e) {
+            log.error(""%s: failed processing batch; discarding batch"", local_addr, e);
+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages
+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption
+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted
+            return;
+        }
+        finally {
+            if(cipher != null)
+                decoding_ciphers.offer(cipher);
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance(""MD5"");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug(""%s: created %d symmetric ciphers with secret key (%d bytes)"", local_addr, cipher_pool_size, sym_version.length);
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(hdr == null) {
+            log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, msg.src());
+            return null;
+        }
+        switch(hdr.type()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn(""%s: unrecognized cipher; discarding message from %s"", local_addr, msg.src());
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(error_msg, sender, curr_view);
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(!Arrays.equals(hdr.version(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.version()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace(""%s: decrypting msg from %s using previous cipher version"", local_addr, msg.src());
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.signature();
+            if(signature == null) {
+                log.error(""%s: dropped message from %s as the header did not have a checksum"", local_addr, msg.src());
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error(""%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)"",
+                          local_addr, msg.src(), msg_checksum, actual_checksum);
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            Buffer serialized_msg=Util.streamableToBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.signature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from ""algorithm/mode/padding""  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
+    protected class Decrypter implements BiConsumer<Message,MessageBatch> {
+        protected final Cipher cipher;
+
+        public Decrypter(Cipher cipher) {
+            this.cipher=cipher;
+        }
+
+        public void accept(Message msg, MessageBatch batch) {
+            EncryptHeader hdr;
+            if((hdr=msg.getHeader(id)) == null) {
+                log.error(""%s: received message without encrypt header from %s; dropping it"", local_addr, batch.sender());
+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch
+                return;
+            }
+
+            if(hdr.type() == EncryptHeader.ENCRYPT) {
+                try {
+                    if(!process(msg)) {
+                        batch.remove(msg);
+                        return;
+                    }
+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
+                    if(tmpMsg != null)
+                        batch.replace(msg, tmpMsg);
+                    else
+                        batch.remove(msg);
+                }
+                catch(Exception e) {
+                    log.error(""%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s"",
+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
+                    batch.remove(msg);
+                }
+            }
+            else {
+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
+                handleUpEvent(msg, hdr);
+            }
+        }
+    }
+
+}",2016-06-14T06:16:20Z,76
"@@ -15,8 +15,8 @@
  * @author Bela Ban
  */
 public class Membership {
-    /* private vector to hold all the addresses */
-    private final List<Address> members=new LinkedList<>();
+    /* holds all addresses */
+    protected final List<Address> members=new LinkedList<>();
 
     
    /**",2017-03-02T15:34:36Z,83
"@@ -0,0 +1,81 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.MessageBatch;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+
+/**
+ * Protocol which drops up or down messages according to user-defined filters
+ * @author Bela Ban
+ * @since  4.0.1
+ */
+@MBean(description=""Drops up or down messages according to user-defined filters"")
+public class DROP extends Protocol {
+    protected final List<Predicate<Message>> down_filters=new ArrayList<>(), up_filters=new ArrayList<>();
+
+    public DROP addDownFilter(Predicate<Message> filter) {
+        down_filters.add(filter);
+        return this;
+    }
+
+    public DROP addUpFilter(Predicate<Message> filter) {
+        up_filters.add(filter);
+        return this;
+    }
+
+    public DROP removeDownFilter(Predicate<Message> filter) {
+        down_filters.remove(filter);
+        return this;
+    }
+
+    public DROP removeUpFilter(Predicate<Message> filter) {
+        up_filters.remove(filter);
+        return this;
+    }
+
+    public DROP clearUpFilters()   {up_filters.clear(); return this;}
+    public DROP clearDownFilters() {down_filters.clear(); return this;}
+
+
+    public Object down(Message msg) {
+        for(Predicate<Message> pred: down_filters)
+            if(pred.test(msg)) {
+                dropped(msg, true);
+                return null;
+            }
+        return down_prot.down(msg);
+    }
+
+    public Object up(Message msg) {
+        for(Predicate<Message> pred: up_filters)
+            if(pred.test(msg)) {
+                dropped(msg, false);
+                return null;
+            }
+        return up_prot.up(msg);
+    }
+
+    public void up(MessageBatch batch) {
+        for(Message msg: batch) {
+            for(Predicate<Message> pred: up_filters) {
+                if(pred.test(msg)) {
+                    dropped(msg, false);
+                    batch.remove(msg);
+                    break;
+                }
+            }
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+    protected void dropped(Message msg, boolean down) {
+
+        log.trace(""dropped msg %s hdrs: %s\n"", down? ""to "" + msg.dest() : ""from "" + msg.src(), msg.printHeaders());
+    }
+}",2017-03-02T15:34:36Z,84
"@@ -1129,7 +1129,7 @@ protected Bundler createBundler(String type) {
     protected void loopback(Message msg, final boolean multicast) {
         final Message copy=loopback_copy? msg.copy() : msg;
         if(is_trace)
-            log.trace(""%s: looping back message %s"", local_addr, copy);
+            log.trace(""%s: looping back message %s, headers are %s"", local_addr, copy, copy.printHeaders());
 
         if(!loopback_separate_thread) {
             passMessageUp(copy, null, false, multicast, false);",2017-03-02T15:34:36Z,85
"@@ -238,10 +238,9 @@ protected static String print(Responses rsps) {
     }
 
     void sendJoinMessage(Address coord, Address mbr,boolean joinWithTransfer, boolean useFlushIfPresent) {
-        Message msg=new Message(coord).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL);
-        GMS.GmsHeader hdr=joinWithTransfer? new GMS.GmsHeader(GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER, mbr,useFlushIfPresent)
-          : new GMS.GmsHeader(GMS.GmsHeader.JOIN_REQ, mbr,useFlushIfPresent);
-        msg.putHeader(gms.getId(), hdr);
+        byte type=joinWithTransfer? GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER : GMS.GmsHeader.JOIN_REQ;
+        GMS.GmsHeader hdr=new GMS.GmsHeader(type, mbr, useFlushIfPresent);
+        Message msg=new Message(coord).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL).putHeader(gms.getId(), hdr);
         gms.getDownProtocol().down(msg);
     }
 ",2017-03-02T15:34:36Z,86
"@@ -199,8 +199,7 @@ public void handleMembershipChange(Collection<Request> requests) {
             sendLeaveResponses(leaving_mbrs); // no-op if no leaving members
 
             // we don't need to send the digest to existing members: https://issues.jboss.org/browse/JGRP-1317
-            gms.castViewChange(new_view, null, new_mbrs);
-            gms.sendJoinResponses(join_rsp, new_mbrs);
+            gms.castViewChangeAndSendJoinRsps(new_view, null, new_view.getMembers(), new_mbrs, join_rsp);
         }
         finally {
             if(hasJoiningMembers)",2017-03-02T15:34:36Z,87
"@@ -24,6 +24,9 @@
 import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 
+import static org.jgroups.Message.Flag.INTERNAL;
+import static org.jgroups.Message.Flag.OOB;
+
 
 /**
  * Group membership protocol. Handles joins/leaves/crashes (suspicions) and
@@ -101,9 +104,11 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     @Property(description=""Logs warnings for reception of views less than the current, and for views which don't include self"")
     protected boolean log_view_warnings=true;
 
+    /** @deprecated true by default */
     @Property(description=""Whether or not to install a new view locally first before broadcasting it "" +
-      ""(only done in coord role). Set to true if a state transfer protocol is detected"")
-    protected boolean install_view_locally_first=false;
+      ""(only done at the coord ). Set to true automatically if a state transfer protocol is detected"")
+    @Deprecated
+    protected boolean install_view_locally_first=true; // https://issues.jboss.org/browse/JGRP-1751
 
     /* --------------------------------------------- JMX  ---------------------------------------------- */
 
@@ -389,9 +394,6 @@ public void init() throws Exception {
 
     public void start() throws Exception {
         if(impl != null) impl.start();
-        Protocol state_transfer_prot=stack.findProtocol(STATE_TRANSFER.class, StreamingStateTransfer.class);
-        if(state_transfer_prot != null)
-            install_view_locally_first=true;
     }
 
     public void stop() {
@@ -557,21 +559,24 @@ protected List<Address> computeNewMembership(final Collection<Collection<Address
 
 
     /**
-     * Broadcasts the new view and digest as a VIEW message and waits for acks from existing members
+     * Broadcasts the new view and digest as VIEW messages, possibly sends JOIN-RSP messages to joiners and then
+     * waits for acks from expected_acks
+     * @param new_view the new view ({@link View} or {@link MergeView})
+     * @param digest the digest, can be null if new_view is not a MergeView
+     * @param expected_acks the members from which to wait for VIEW_ACKs (self will be excluded)
+     * @param joiners the list of members to which to send the join response (jr). If null, no JOIN_RSPs will be sent
+     * @param jr the {@link JoinRsp}. If null (or joiners is null), no JOIN_RSPs will be sent
      */
-    public void castViewChange(View new_view, Digest digest, Collection<Address> newMembers) {
-        log.trace(""%s: mcasting view %s (%d mbrs)\n"", local_addr, new_view, new_view.size());
+    public void castViewChangeAndSendJoinRsps(View new_view, Digest digest, Collection<Address> expected_acks,
+                                              Collection<Address> joiners, JoinRsp jr) {
+        log.trace(""%s: mcasting view %s"", local_addr, new_view);
 
         // Send down a local TMP_VIEW event. This is needed by certain layers (e.g. NAKACK) to compute correct digest
         // in case client's next request (e.g. getState()) reaches us *before* our own view change multicast.
         // Check NAKACK's TMP_VIEW handling for details
         up_prot.up(new Event(Event.TMP_VIEW, new_view));
         down_prot.down(new Event(Event.TMP_VIEW, new_view));
 
-        List<Address> ackMembers=new ArrayList<>(new_view.getMembers());
-        if(newMembers != null && !newMembers.isEmpty())
-            ackMembers.removeAll(newMembers);
-
         View full_view=new_view;
         if(use_delta_views && view != null && !(new_view instanceof MergeView)) {
             if(!first_view_sent) // send the first view as coord as *full* view
@@ -580,63 +585,53 @@ public void castViewChange(View new_view, Digest digest, Collection<Address> new
                 new_view=createDeltaView(view, new_view);
         }
 
-        // bcast to all members
         Message view_change_msg=new Message().putHeader(this.id, new GmsHeader(GmsHeader.VIEW))
-          .setBuffer(marshal(new_view, digest));
-
-        // Bypasses SEQUENCER, prevents having to forward a merge view to a remote coordinator
-        // (https://issues.jboss.org/browse/JGRP-1484)
-        if(new_view instanceof MergeView)
+          .setBuffer(marshal(new_view, digest)).setTransientFlag(Message.TransientFlag.DONT_LOOPBACK);
+        if(new_view instanceof MergeView) // https://issues.jboss.org/browse/JGRP-1484
             view_change_msg.setFlag(Message.Flag.NO_TOTAL_ORDER);
 
-        if(install_view_locally_first)
-            ackMembers.remove(local_addr); // remove self, as we'll install the view locally
-
-        if(!ackMembers.isEmpty())
-            ack_collector.reset(ackMembers);
-
-        if(install_view_locally_first)
-            impl.handleViewChange(full_view, digest); // install the view locally first
-
+        ack_collector.reset(expected_acks, local_addr); // exclude self, as we'll install the view locally
+        long start=System.currentTimeMillis();
+        impl.handleViewChange(full_view, digest); // install the view locally first
         down_prot.down(view_change_msg);
+        sendJoinResponses(jr, joiners);
         try {
-            if(!ackMembers.isEmpty()) {
+            if(ack_collector.size() > 0) {
                 ack_collector.waitForAllAcks(view_ack_collection_timeout);
-                log.trace(""%s: got all ACKs (%d) from members for view %s"", local_addr, ack_collector.expectedAcks(), new_view.getViewId());
+                log.trace(""%s: got all ACKs (%d) for view %s in %d ms"",
+                          local_addr, ack_collector.expectedAcks(), new_view.getViewId(), System.currentTimeMillis()-start);
             }
         }
         catch(TimeoutException e) {
-            if(log_collect_msgs)
+            if(log_collect_msgs);
                 log.warn(""%s: failed to collect all ACKs (expected=%d) for view %s after %dms, missing %d ACKs from %s"",
                          local_addr, ack_collector.expectedAcks(), new_view.getViewId(), view_ack_collection_timeout,
                          ack_collector.size(), ack_collector.printMissing());
         }
     }
 
-    public void sendJoinResponses(JoinRsp jr, Collection<Address> newMembers) {
-        if(jr != null && newMembers != null && !newMembers.isEmpty()) {
-            final ViewId view_id=jr.getView().getViewId();
-            ack_collector.reset(new ArrayList<>(newMembers));
-            for(Address joiner: newMembers) {
-                log.trace(""%s: sending join-rsp to %s: view=%s (%d mbrs)\n"", local_addr, joiner, jr.getView(), jr.getView().size());
-                sendJoinResponse(jr, joiner);
-            }
-            try {
-                ack_collector.waitForAllAcks(view_ack_collection_timeout);
-                log.trace(""%s: got all ACKs (%d) from joiners for view %s"", local_addr, ack_collector.expectedAcks(), view_id);
-            }
-            catch(TimeoutException e) {
-                if(log_collect_msgs)
-                    log.warn(""%s: failed to collect all ACKs (expected=%d) for unicast view %s after %dms, missing %d ACKs from %s"",
-                             local_addr, ack_collector.expectedAcks(), view_id, view_ack_collection_timeout,
-                             ack_collector.size(), ack_collector.printMissing());
-            }
+
+
+    protected void sendJoinResponses(JoinRsp jr, Collection<Address> joiners) {
+        if(jr == null || joiners == null || joiners.isEmpty())
+            return;
+
+        Buffer marshalled_jr=marshal(jr);
+        for(Address joiner: joiners) {
+            log.trace(""%s: sending join-rsp to %s: view=%s (%d mbrs)"", local_addr, joiner, jr.getView(), jr.getView().size());
+            sendJoinResponse(marshalled_jr, joiner);
         }
     }
 
     public void sendJoinResponse(JoinRsp rsp, Address dest) {
         Message m=new Message(dest).putHeader(this.id, new GmsHeader(GmsHeader.JOIN_RSP))
-          .setBuffer(marshal(rsp)).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL);
+          .setBuffer(marshal(rsp)).setFlag(OOB, INTERNAL);
+        getDownProtocol().down(m);
+    }
+
+    protected void sendJoinResponse(Buffer marshalled_rsp, Address dest) {
+        Message m=new Message(dest, marshalled_rsp).putHeader(this.id, new GmsHeader(GmsHeader.JOIN_RSP))
+          .setFlag(OOB, INTERNAL);
         getDownProtocol().down(m);
     }
 
@@ -910,6 +905,10 @@ public Object up(Message msg) {
                     catch(Throwable t) {
                         if(view != null)
                             log.warn(""%s: failed to create view from delta-view; dropping view: %s"", local_addr, t.toString());
+                        log.trace(""%s: sending request for full view to %s"", local_addr, msg.src());
+                        Message full_view_req=new Message(msg.src())
+                          .putHeader(id, new GmsHeader(GmsHeader.GET_CURRENT_VIEW)).setFlag(OOB, INTERNAL);
+                        down_prot.down(full_view_req);
                         return null;
                     }
                 }
@@ -989,7 +988,7 @@ public Object up(Message msg) {
                 Digest digest=(Digest)down_prot.down(new Event(Event.GET_DIGEST, local_addr));
                 if(digest != null) {
                     Message get_digest_rsp=new Message(msg.getSrc())
-                      .setFlag(Message.Flag.OOB,Message.Flag.INTERNAL)
+                      .setFlag(OOB, Message.Flag.INTERNAL)
                       .putHeader(this.id, new GmsHeader(GmsHeader.GET_DIGEST_RSP))
                       .setBuffer(marshal(null, digest));
                     down_prot.down(get_digest_rsp);
@@ -1013,8 +1012,9 @@ public Object up(Message msg) {
                         return null; // my view-id doesn't differ from sender's view-id; no need to send view
                 }
                 // either my view-id differs from sender's view-id, or sender's view-id is null: send view
+                log.trace(""%s: received request for full view from %s, sending view %s"", local_addr, msg.src(), view);
                 Message view_msg=new Message(msg.getSrc()).putHeader(id,new GmsHeader(GmsHeader.VIEW))
-                  .setBuffer(marshal(view, null)).setFlag(Message.Flag.OOB,Message.Flag.INTERNAL);
+                  .setBuffer(marshal(view, null)).setFlag(OOB, Message.Flag.INTERNAL);
                 down_prot.down(view_msg);
                 break;
 
@@ -1089,7 +1089,7 @@ public Object down(Event evt) {
                 if(coord != null) {
                     ViewId view_id=view != null? view.getViewId() : null;
                     Message msg=new Message(coord).putHeader(id, new GmsHeader(GmsHeader.GET_CURRENT_VIEW))
-                      .setBuffer(marshal(view_id)).setFlag(Message.Flag.OOB,Message.Flag.INTERNAL);
+                      .setBuffer(marshal(view_id)).setFlag(OOB, Message.Flag.INTERNAL);
                     down_prot.down(msg);
                 }
                 return null; // don't pass the event further down
@@ -1122,7 +1122,7 @@ final void initState() {
 
 
     private void sendViewAck(Address dest) {
-        Message view_ack=new Message(dest).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL)
+        Message view_ack=new Message(dest).setFlag(OOB, INTERNAL)
           .putHeader(this.id, new GmsHeader(GmsHeader.VIEW_ACK));
         down_prot.down(view_ack);
     }",2017-03-02T15:34:36Z,74
"@@ -141,11 +141,9 @@ public void handleMergeView(final MergeData data, final MergeId merge_id) {
 
         // only send to our *current* members, if we have A and B being merged (we are B), then we would *not*
         // want to block on a VIEW_ACK from A because A doesn't see us in the pre-merge view yet and discards the view
-        List<Address> newViewMembers=new ArrayList<>(data.view.getMembers());
-        newViewMembers.removeAll(gms.members.getMembers());
-
+        List<Address> expected_acks=gms.members.getMembers();
         try {
-            gms.castViewChange(data.view, data.digest, newViewMembers);
+            gms.castViewChangeAndSendJoinRsps(data.view, data.digest, expected_acks, null, null);
             // if we have flush in stack send ack back to merge coordinator
             if(gms.flushProtocolInStack) { //[JGRP-700] - FLUSH: flushing should span merge
                 Message ack=new Message(data.getSender()).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL)",2017-03-02T15:34:36Z,53
"@@ -109,7 +109,7 @@ public void handleMembershipChange(Collection<Request> requests) {
         suspectedMembers.stream().filter(mbr -> !suspected_mbrs.contains(mbr)).forEach(suspected_mbrs::add);
 
         if(wouldIBeCoordinator()) {
-            log.debug(""%s: members are %s, coord=%s: I'm the new coord !"", gms.local_addr, gms.members, gms.local_addr);
+            log.debug(""%s: members are %s, coord=%s: I'm the new coordinator"", gms.local_addr, gms.members, gms.local_addr);
 
             gms.becomeCoordinator();
             suspected_mbrs.forEach(mbr -> {",2017-03-02T15:34:36Z,88
"@@ -42,6 +42,22 @@ public synchronized void reset(Collection<Address> members) {
         all_acks_received.reset();
     }
 
+    public synchronized AckCollector reset(Collection<Address> expected_acks, Collection<Address> exclude) {
+        suspected_mbrs.clear();
+        missing_acks.clear();
+        addAll(expected_acks, exclude);
+        all_acks_received.reset();
+        return this;
+    }
+
+    public synchronized AckCollector reset(Collection<Address> expected_acks, Address ... exclude) {
+        suspected_mbrs.clear();
+        missing_acks.clear();
+        addAll(expected_acks, exclude);
+        all_acks_received.reset();
+        return this;
+    }
+
     public synchronized void destroy() {
         suspected_mbrs.clear();
         missing_acks.clear();
@@ -121,4 +137,22 @@ protected synchronized void addAll(Collection<Address> members) {
         members.stream().filter(member -> member != null && !missing_acks.contains(member)).forEach(missing_acks::add);
         expected_acks=missing_acks.size();
     }
+
+    protected synchronized void addAll(Collection<Address> members, Collection<Address> exclude) {
+        if(members == null)
+            return;
+        members.stream()
+          .filter(member -> member != null && !missing_acks.contains(member) && (exclude != null && !exclude.contains(member)))
+          .forEach(missing_acks::add);
+        expected_acks=missing_acks.size();
+    }
+
+    protected synchronized void addAll(Collection<Address> members, Address ... exclude) {
+        if(members == null)
+            return;
+        members.stream()
+          .filter(member -> member != null && !missing_acks.contains(member) && (exclude != null && !Util.contains(member, exclude)))
+          .forEach(missing_acks::add);
+        expected_acks=missing_acks.size();
+    }
 }",2017-03-02T15:34:36Z,89
"@@ -23,6 +23,41 @@ public class AckCollectorTest {
     final List<Address> list=Arrays.asList(one, two, three, four, five);
 
 
+    public void testAddAll() {
+        AckCollector coll=new AckCollector();
+        coll.reset(Arrays.asList(one,two,three,four), Collections.singletonList(five));
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 4;
+
+        Stream.of(one,two,three,four).forEach(coll::ack);
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 0;
+
+        coll.reset(Collections.singletonList(one), Collections.singletonList(one));
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 0;
+        boolean rc=coll.waitForAllAcks();
+        assert rc;
+    }
+
+
+    public void testAddAll2() {
+        AckCollector coll=new AckCollector();
+        coll.reset(Arrays.asList(one,two,three,four), five);
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 4;
+
+        Stream.of(one,two,three,four).forEach(coll::ack);
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 0;
+
+        coll.reset(Collections.singletonList(one), one);
+        System.out.println(""coll = "" + coll);
+        assert coll.size() == 0;
+        boolean rc=coll.waitForAllAcks();
+        assert rc;
+    }
+
     public void testConstructor() {
         AckCollector ac=new AckCollector(list);
         System.out.println(""AckCollector is "" + ac);
@@ -32,15 +67,13 @@ public void testConstructor() {
 
     public void testWaitForAllAcksNoTimeout() {
         final AckCollector ac=new AckCollector(list);
-        new Thread() {
-            public void run() {
-                for(Address member: list) {
-                    Util.sleep(100);
-                    ac.ack(member);
-                    System.out.println(""AckCollector: "" + ac);
-                }
+        new Thread(() -> {
+            for(Address member: list) {
+                Util.sleep(100);
+                ac.ack(member);
+                System.out.println(""AckCollector: "" + ac);
             }
-        }.start();
+        }).start();
         ac.waitForAllAcks();
         Assert.assertEquals(0, ac.size());
     }
@@ -53,15 +86,13 @@ public void testWaitForAllAcksWithTimeoutException() throws TimeoutException {
 
     public void testWaitForAllAcksWithTimeout() {
         final AckCollector ac=new AckCollector(list);
-        new Thread() {
-            public void run() {
-                for(Address member: list) {
-                    Util.sleep(100);
-                    ac.ack(member);
-                    System.out.println(""AckCollector: "" + ac);
-                }
+        new Thread(() -> {
+            for(Address member: list) {
+                Util.sleep(100);
+                ac.ack(member);
+                System.out.println(""AckCollector: "" + ac);
             }
-        }.start();
+        }).start();
         try {
             ac.waitForAllAcks(30000);
             assert true : ""we should not get a timeout exception here"";
@@ -76,15 +107,13 @@ public void run() {
     @Test(expectedExceptions=TimeoutException.class)
     public void testWaitForAllAcksWithTimeoutException2() throws TimeoutException {
         final AckCollector ac=new AckCollector(list);
-        new Thread() {
-            public void run() {
-                for(Address member: list) {
-                    Util.sleep(100);
-                    ac.ack(member);
-                    System.out.println(""AckCollector: "" + ac);
-                }
+        new Thread(() -> {
+            for(Address member: list) {
+                Util.sleep(100);
+                ac.ack(member);
+                System.out.println(""AckCollector: "" + ac);
             }
-        }.start();
+        }).start();
         ac.waitForAllAcks(10);
     }
 
@@ -94,14 +123,12 @@ public void testReset() throws TimeoutException {
         final Address six=Util.createRandomAddress(""six""), seven=Util.createRandomAddress(""seven""),
           eight=Util.createRandomAddress(""eight"");
         final List<Address> new_list=Arrays.asList(six, seven, eight);
-        new Thread() {
-            public void run() {
-                Util.sleep(500);
-                System.out.println(""resetting AckCollector"");
-                ac.reset(new_list);
-                System.out.println(""reset AckCollector: "" + ac);
-            }
-        }.start();
+        new Thread(() -> {
+            Util.sleep(500);
+            System.out.println(""resetting AckCollector"");
+            ac.reset(new_list);
+            System.out.println(""reset AckCollector: "" + ac);
+        }).start();
         System.out.println(""initial AckCollector: "" + ac);
         ac.waitForAllAcks(1000);
         System.out.println(""new AckCollector: "" + ac);
@@ -114,23 +141,21 @@ public void testReset2() throws TimeoutException {
           eight=Util.createRandomAddress(""eight"");
         final List<Address> new_list=Arrays.asList(six, seven, eight);
 
-        new Thread() {
-            public void run() {
-                Util.sleep(500);
-                System.out.println(""resetting AckCollector"");
-                ac.reset(new_list);
-                System.out.println(""reset AckCollector: "" + ac);
-                Util.sleep(100);
-                ac.ack(six);
-                System.out.println(""AckCollector: "" + ac);
-                Util.sleep(100);
-                ac.ack(seven);
-                System.out.println(""AckCollector: "" + ac);
-                Util.sleep(100);
-                ac.ack(eight);
-                System.out.println(""AckCollector: "" + ac);
-            }
-        }.start();
+        new Thread(() -> {
+            Util.sleep(500);
+            System.out.println(""resetting AckCollector"");
+            ac.reset(new_list);
+            System.out.println(""reset AckCollector: "" + ac);
+            Util.sleep(100);
+            ac.ack(six);
+            System.out.println(""AckCollector: "" + ac);
+            Util.sleep(100);
+            ac.ack(seven);
+            System.out.println(""AckCollector: "" + ac);
+            Util.sleep(100);
+            ac.ack(eight);
+            System.out.println(""AckCollector: "" + ac);
+        }).start();
         System.out.println(""initial AckCollector: "" + ac);
         ac.waitForAllAcks(30000);
         System.out.println(""new AckCollector: "" + ac);
@@ -150,12 +175,10 @@ public void testDestroy() throws TimeoutException {
         final AckCollector ac=new AckCollector(tmp_list);
         System.out.println(""ac = "" + ac);
         assert ac.size() == 5;
-        Thread thread=new Thread() {
-            public void run() {
-                Util.sleep(2000);
-                ac.destroy();
-            }
-        };
+        Thread thread=new Thread(() -> {
+            Util.sleep(2000);
+            ac.destroy();
+        });
         thread.start();
         boolean result=ac.waitForAllAcks(10000);
         System.out.println(""result = "" + result);
@@ -191,14 +214,12 @@ public void testRetainAll() throws TimeoutException {
         System.out.println(""ac="" + ac);
         assert ac.size() == 3;
 
-        new Thread() {
-            public void run() {
-                Util.sleep(1000);
-                ac.suspect(two);
-                Util.sleep(500);
-                ac.ack(three); ac.ack(one);
-            }
-        }.start();
+        new Thread(() -> {
+            Util.sleep(1000);
+            ac.suspect(two);
+            Util.sleep(500);
+            ac.ack(three); ac.ack(one);
+        }).start();
 
         boolean received_all=ac.waitForAllAcks(30000);
         System.out.println(""ac = "" + ac);
@@ -213,13 +234,11 @@ public void testRetainAll2() throws TimeoutException {
         ac.suspect(four);
         System.out.println(""ac = "" + ac);
 
-        new Thread() {
-            public void run() {
-                Util.sleep(1000);
-                ac.retainAll(Collections.singletonList(five));
-                System.out.println(""ac="" + ac);
-            }
-        }.start();
+        new Thread(() -> {
+            Util.sleep(1000);
+            ac.retainAll(Collections.singletonList(five));
+            System.out.println(""ac="" + ac);
+        }).start();
 
         boolean received_all=ac.waitForAllAcks(30000);
         System.out.println(""ac = "" + ac);",2017-03-02T15:34:36Z,90
"@@ -0,0 +1,206 @@
+package org.jgroups.tests;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.FRAG2;
+import org.jgroups.protocols.FRAG3;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.protocols.pbcast.ParticipantGmsImpl;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Digest;
+import org.jgroups.util.MessageBatch;
+import org.jgroups.util.Tuple;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Tests DeltaViews (https://issues.jboss.org/browse/JGRP-2159)
+ * @author Bela Ban
+ * @since  4.0.1
+ */
+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+public class DeltaViewTest {
+    protected JChannel                        j, k, l;
+    protected static final String             CLUSTER=DeltaViewTest.class.getSimpleName();
+    protected static final short              GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
+
+
+
+    @BeforeMethod protected void setup() throws Exception {
+        j=create(""J"");
+        k=create(""K"");
+        l=create(""L"");
+    }
+
+    @AfterMethod protected void destroy() {Util.close(l, k, j);}
+
+
+    public void testDeltaViews() throws Exception {
+        DelayViewsAndJoinRsps del=new DelayViewsAndJoinRsps(j);
+
+        j.connect(CLUSTER);
+        j.getProtocolStack().insertProtocol(del, ProtocolStack.Position.BELOW, GMS.class);
+
+        k.connect(CLUSTER);
+        Util.waitUntilAllChannelsHaveSameView(5000, 500, j,k);
+        System.out.printf(""\nJ: %s\nK: %s\n\n"", j.getView(), k.getView());
+
+        l.connect(CLUSTER);
+        Util.waitUntilAllChannelsHaveSameView(10000, 1000, j, k, l);
+        System.out.printf(""\nJ: %s\nK: %s\nL: %s\n"", j.getView(), k.getView(), l.getView());
+    }
+
+
+
+    protected JChannel create(String name) throws Exception {
+        JChannel ch=new JChannel(Util.getTestStack()).name(name);
+        ch.getProtocolStack().removeProtocol(STABLE.class, FRAG2.class, FRAG3.class);
+        GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
+        gms.setViewAckCollectionTimeout(1000);
+        gms.setValue(""join_timeout"", 1500);
+          //.setValue(""install_view_locally_first"", false); // setting this to true should fix the issue!
+        return ch;
+    }
+
+
+
+    // up first view: queue
+    // down JOIN-RSP: queue
+    // up second view: queue
+    // down JOIN-RSP:
+    // ==> send first and second JOIN-RSP
+    // ==> deliver first and second view (second should fail)
+    // ==> remove this protocol
+    protected class DelayViewsAndJoinRsps extends Protocol {
+        protected final List<Message> views=new ArrayList<>(2); // views to be delivered
+        protected final List<Message> join_rsps=new ArrayList<>(2); // JOIN-RSPS to be sent to K
+        protected final JChannel      ch;
+        protected boolean             removed;
+
+        public DelayViewsAndJoinRsps(JChannel ch) {
+            this.ch=ch;
+        }
+
+        public Object down(Message msg) {
+            if(isJoinRsp(msg)) {
+                checkDone(msg, join_rsps);
+                return null;
+            }
+            return down_prot.down(msg);
+        }
+
+        public Object up(Message msg) {
+            if(isView(msg)) {
+                checkDone(msg, views);
+                return null;
+            }
+            return up_prot.up(msg);
+        }
+
+        public void up(MessageBatch batch) {
+            for(Message msg: batch) {
+                if(isView(msg)) {
+                    batch.remove(msg);
+                    checkDone(msg, views);
+                }
+            }
+            if(!batch.isEmpty())
+                up_prot.up(batch);
+        }
+
+
+        protected synchronized void checkDone(Message msg, List<Message> list) {
+            list.add(msg);
+            if((join_rsps.size() >= 2 || views.size() >= 2) && !removed) {
+                flushMessages();
+                ch.getProtocolStack().removeProtocol(this);
+                removed=true;
+            }
+        }
+
+        protected void flushMessages() {
+            System.out.printf(""** flushing %d JOIN-RSPs and %d views:\n"", join_rsps.size(), views.size());
+            int count=1;
+            for(Message msg: join_rsps) {
+                try {
+                    JoinRsp join_rsp=Util.streamableFromBuffer(JoinRsp.class, msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+                    System.out.printf(""join-rsp #%d to %s: %s\n"", count++, msg.dest(), join_rsp.getView());
+                }
+                catch(Throwable t) {
+                    log.error(""failed unmarshalling JOIN-RSP"", t);
+                }
+            }
+
+            // deliver the views
+            count=1;
+            for(Message msg: views) {
+                try {
+                    Tuple<View,Digest> tuple=GMS._readViewAndDigest(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+                    System.out.printf(""view #%d: %s\n"", count++, tuple.getVal1());
+                }
+                catch(Throwable t) {
+                    log.error(""failed unmarshalling view"", t);
+                }
+            }
+            System.out.println(""\n"");
+
+            // send the JOIN-RSPs: the first JOIN-RSP neeeds to be handled by a client, the second by a participant: if we
+            // sent them right next to each other, then the second would not be installed if GMS.impl is still a client.
+            // We therefore need to wait until impl is a participant. This is a kludge, but better then using sleep()
+            Message join_rsp_msg=join_rsps.remove(0);
+            down_prot.down(join_rsp_msg);
+
+            join_rsp_msg=join_rsps.remove(0);
+            JoinRsp join_rsp=null;
+            try {
+                join_rsp=Util.streamableFromBuffer(JoinRsp.class, join_rsp_msg.getRawBuffer(), join_rsp_msg.getOffset(), join_rsp_msg.getLength());
+            }
+            catch(Exception e) {
+                throw new RuntimeException(e);
+            }
+            installJoinRspInParticipant(k, join_rsp);
+            join_rsps.clear();
+
+            // deliver the views
+            for(Message msg: views)
+                up_prot.up(msg);
+            views.clear();
+        }
+
+        // Waits until GMS.impl is ParticipantGmsImpl, then calls impl.handleJoinRsp()
+        protected void installJoinRspInParticipant(JChannel ch, JoinRsp rsp) {
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
+            for(int i=0; i < 10; i++) {
+                if(ParticipantGmsImpl.class.equals(gms.getImpl().getClass())) {
+                    gms.getImpl().handleJoinResponse(rsp);
+                    break;
+                }
+                Util.sleep(500);
+            }
+            if(!ParticipantGmsImpl.class.equals(gms.getImpl().getClass()))
+                throw new IllegalStateException(String.format(""GMS.impl is not participant: %s"", gms.getImpl().getClass().getSimpleName()));
+        }
+    }
+
+    protected static boolean isView(Message msg) {
+        GMS.GmsHeader hdr=msg.getHeader(GMS_ID);
+        return hdr != null && hdr.getType() == GMS.GmsHeader.VIEW;
+    };
+    protected static boolean isJoinRsp(Message msg) {
+        GMS.GmsHeader hdr=msg.getHeader(GMS_ID);
+        return hdr != null && hdr.getType() == GMS.GmsHeader.JOIN_RSP;
+    };
+
+}
+",2017-03-02T15:34:36Z,91
"@@ -139,14 +139,13 @@ public void testTaskCancellationAfterHasRun(TimeScheduler timer) throws Interrup
 
             Util.sleep(500); // wait until task has executed
             future.cancel(true);
-            int size=timer.size();
-            assert size == 1 : "" timer size should be 1, but is "" + size;
 
             int num_executions=task.getNumExecutions();
             System.out.println(""number of task executions="" + num_executions);
             assert num_executions >= 1 : ""task should have executed at least 1 time, as it was cancelled after 500ms"";
             Util.sleep(1000);
-            assert timer.size() == 0 : "" timer size should be 0, but is "" + size;
+            int size=timer.size();
+            assert size == 0 : "" timer size should be 0, but is "" + size;
         }
         finally {
             timer.stop();",2017-03-02T15:34:36Z,92
"@@ -34,11 +34,9 @@ public class TUNNELDeadLockTest extends ChannelTestBase {
 
     // the total number of the messages pumped down the channel
     private static final int msgCount=20000;
-    // the message payload size (in bytes);
-    private static final int payloadSize=32;
     // the time (in ms) the main thread waits for all the messages to arrive,
     // before declaring the test failed.
-    private static final int mainTimeout=60000;
+    private static final int mainTimeout=20000;
     GossipRouter             gossipRouter;
     private int              gossip_router_port;
     private String           gossip_router_hosts;
@@ -110,8 +108,8 @@ public void receive(Message msg) {
         // stress send messages - the sender thread
         new Thread(() -> {
             try {
-                for(int i=0; i < msgCount; i++) {
-                    channel.send(null, new byte[payloadSize]);
+                for(int i=1; i <= msgCount; i++) {
+                    channel.send(null, i);
                     if(i % 2000 == 0)
                         System.out.println(""-- sent "" + i);
                 }",2017-03-02T15:34:36Z,93
"@@ -1,40 +1,73 @@
 package org.jgroups.protocols.tom;
 
-import org.jgroups.Address;
-import org.jgroups.Message;
-
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.annotations.GuardedBy;
+
 /**
  * The implementation of the Delivery Manager
  *
  * @author Pedro Ruivo
  * @since 3.1
  */
 public class DeliveryManagerImpl implements DeliveryManager {
+    @GuardedBy(""deliverySet"")
     private final SortedSet<MessageInfo> deliverySet = new TreeSet<>();
-    private final ConcurrentMap<MessageID, MessageInfo> messageCache = new ConcurrentHashMap<>(8192, .75f, 64);
+    private final ConcurrentMap<MessageID, MessageInfo> messageCache = new ConcurrentHashMap<>();
+    @GuardedBy(""deliverySet"")
     private final SequenceNumberManager sequenceNumberManager = new SequenceNumberManager();
+    @GuardedBy(""deliverySet"")
+    private final Set<Address> currentView = new HashSet<>();
+
+    public final void handleView(View newView) {
+        List<MessageInfo> toRemove = new LinkedList<>();
+        synchronized (deliverySet) {
+            updateMembers(newView);
+            deliverySet.stream()
+                  .filter(this::shouldRemove)
+                  .forEach(toRemove::add);
+
+            deliverySet.removeAll(toRemove);
+            notifyIfNeeded();
+        }
+        for (MessageInfo removed : toRemove) {
+            messageCache.remove(removed.messageID);
+        }
+    }
 
-    public long addLocalMessageToDeliver(MessageID messageID, Message message, ToaHeader header) {
+    long addLocalMessageToDeliver(MessageID messageID, Message message, ToaHeader header) {
         MessageInfo messageInfo;
         long sequenceNumber;
         synchronized (deliverySet) {
             sequenceNumber = sequenceNumberManager.getAndIncrement();
-            header.setSequencerNumber(sequenceNumber);
             messageInfo = new MessageInfo(messageID, message, sequenceNumber);
             deliverySet.add(messageInfo);
         }
+        header.setSequencerNumber(sequenceNumber);
         messageCache.put(messageID, messageInfo);
         return sequenceNumber;
     }
 
-    public long addRemoteMessageToDeliver(MessageID messageID, Message message, long remoteSequenceNumber) {
+    long addRemoteMessageToDeliver(MessageID messageID, Message message, long remoteSequenceNumber) {
         MessageInfo messageInfo;
         long sequenceNumber;
         synchronized (deliverySet) {
+            if (!currentView.contains(message.getSrc())) {
+                return -1;
+            }
             sequenceNumber = sequenceNumberManager.updateAndGet(remoteSequenceNumber);
             messageInfo = new MessageInfo(messageID, message, sequenceNumber);
             deliverySet.add(messageInfo);
@@ -43,7 +76,7 @@ public long addRemoteMessageToDeliver(MessageID messageID, Message message, long
         return sequenceNumber;
     }
 
-    public void updateSequenceNumber(long sequenceNumber) {
+    void updateSequenceNumber(long sequenceNumber) {
         synchronized (deliverySet) {
             sequenceNumberManager.update(sequenceNumber);
         }
@@ -55,10 +88,36 @@ public void updateSequenceNumber(long sequenceNumber) {
      * @param messageID           the message ID
      * @param finalSequenceNumber the final sequence number
      */
-    public void markReadyToDeliver(MessageID messageID, long finalSequenceNumber) {
+    void markReadyToDeliver(MessageID messageID, long finalSequenceNumber) {
         markReadyToDeliverV2(messageID, finalSequenceNumber);
     }
 
+    /**
+     * delivers a message that has only as destination member this node
+     *
+     * @param msg the message
+     */
+    void deliverSingleDestinationMessage(Message msg, MessageID messageID) {
+        synchronized (deliverySet) {
+            long sequenceNumber = sequenceNumberManager.get();
+            MessageInfo messageInfo = new MessageInfo(messageID, msg, sequenceNumber);
+            messageInfo.updateAndMarkReadyToDeliver(sequenceNumber);
+            deliverySet.add(messageInfo);
+            notifyIfNeeded();
+        }
+    }
+
+    /**
+     * It is used for testing (see the messages in JMX)
+     *
+     * @return unmodifiable set of messages
+     */
+    Set<MessageInfo> getMessageSet() {
+        synchronized (deliverySet) {
+            return Collections.unmodifiableSet(deliverySet);
+        }
+    }
+
     private void markReadyToDeliverV2(MessageID messageID, long finalSequenceNumber) {
         MessageInfo messageInfo = messageCache.remove(messageID);
 
@@ -73,36 +132,19 @@ private void markReadyToDeliverV2(MessageID messageID, long finalSequenceNumber)
             sequenceNumberManager.update(finalSequenceNumber);
             if (needsUpdatePosition) {
                 deliverySet.remove(messageInfo);
-                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+                messageInfo.updateAndMarkReadyToDeliver(finalSequenceNumber);
                 deliverySet.add(messageInfo);
             } else {
-                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
-            }
-
-            if (deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notify();
+                messageInfo.updateAndMarkReadyToDeliver(finalSequenceNumber);
             }
+            notifyIfNeeded();
         }
     }
 
-    public final void removeLeavers(Collection<Address> leavers) {
-        if (leavers == null) {
-            return;
-        }
-        List<MessageInfo> toRemove = new LinkedList<>();
-        synchronized (deliverySet) {
-            deliverySet.stream()
-              .filter(messageInfo -> leavers.contains(messageInfo.getMessage().getSrc()) && !messageInfo.isReadyToDeliver())
-              .forEach(toRemove::add);
-
-            deliverySet.removeAll(toRemove);
-            if (!deliverySet.isEmpty() && deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notify();
-            }
-        }
-        for (MessageInfo removed : toRemove) {
-            messageCache.remove(removed.messageID);
-        }
+    @GuardedBy(""deliverySet"")
+    private void updateMembers(View newView) {
+        currentView.clear();
+        currentView.addAll(newView.getMembers());
     }
 
     //see the interface javadoc
@@ -129,6 +171,12 @@ public List<Message> getNextMessagesToDeliver() throws InterruptedException {
         return toDeliver;
     }
 
+    public List<MessageInfo> getAllMessages() {
+        synchronized (deliverySet) {
+            return new ArrayList<>(deliverySet);
+        }
+    }
+
     /**
      * remove all the pending messages
      */
@@ -139,34 +187,36 @@ public void clear() {
         }
     }
 
+    public SequenceNumberManager getSequenceNumberManager() {
+        return sequenceNumberManager;
+    }
+
     /**
-     * delivers a message that has only as destination member this node
-     *
-     * @param msg the message
+     * @return {@code true} if the source of the message left the view and the message isn't ready to be deliver.
      */
-    public void deliverSingleDestinationMessage(Message msg, MessageID messageID) {
-        synchronized (deliverySet) {
-            long sequenceNumber = sequenceNumberManager.get();
-            MessageInfo messageInfo = new MessageInfo(messageID, msg, sequenceNumber);
-            messageInfo.updateAndmarkReadyToDeliver(sequenceNumber);
-            deliverySet.add(messageInfo);
-            if (deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notify();
-            }
+    @GuardedBy(""deliverySet"")
+    private boolean shouldRemove(MessageInfo messageInfo) {
+        return !(currentView.contains(messageInfo.getMessage().getSrc()) || messageInfo.isReadyToDeliver());
+    }
+
+    @GuardedBy(""deliverySet"")
+    private void notifyIfNeeded() {
+        if (!deliverySet.isEmpty() && deliverySet.first().isReadyToDeliver()) {
+            deliverySet.notify();
         }
     }
 
     /**
      * Keeps the state of a message
      */
-    private static class MessageInfo implements Comparable<MessageInfo> {
+    public static class MessageInfo implements Comparable<MessageInfo> {
 
         private final MessageID messageID;
         private final Message message;
         private volatile long sequenceNumber;
         private volatile boolean readyToDeliver;
 
-        public MessageInfo(MessageID messageID, Message message, long sequenceNumber) {
+        MessageInfo(MessageID messageID, Message message, long sequenceNumber) {
             if (messageID == null) {
                 throw new NullPointerException(""Message ID can't be null"");
             }
@@ -177,16 +227,19 @@ public MessageInfo(MessageID messageID, Message message, long sequenceNumber) {
             this.message.setSrc(messageID.getAddress());
         }
 
+        public long getSequenceNumber() {
+            return sequenceNumber;
+        }
+
         private Message getMessage() {
             return message;
         }
 
-        private void updateAndmarkReadyToDeliver(long finalSequenceNumber) {
-            this.readyToDeliver = true;
-            this.sequenceNumber = finalSequenceNumber;
+        private boolean isUpdatePositionNeeded(long finalSequenceNumber) {
+            return sequenceNumber != finalSequenceNumber;
         }
 
-        private boolean isReadyToDeliver() {
+        public boolean isReadyToDeliver() {
             return readyToDeliver;
         }
 
@@ -229,8 +282,9 @@ public String toString() {
                     '}';
         }
 
-        public boolean isUpdatePositionNeeded(long finalSequenceNumber) {
-            return sequenceNumber != finalSequenceNumber;
+        private void updateAndMarkReadyToDeliver(long finalSequenceNumber) {
+            this.readyToDeliver = true;
+            this.sequenceNumber = finalSequenceNumber;
         }
 
         @Override
@@ -245,15 +299,4 @@ public int compareTo(MessageInfo o) {
             return sequenceNumber < o.sequenceNumber ? -1 : sequenceNumber == o.sequenceNumber ? sameId : 1;
         }
     }
-
-    /**
-     * It is used for testing (see the messages in JMX)
-     *
-     * @return unmodifiable set of messages
-     */
-    public Set<MessageInfo> getMessageSet() {
-        synchronized (deliverySet) {
-            return Collections.unmodifiableSet(deliverySet);
-        }
-    }
 }",2017-10-15T16:14:36Z,94
"@@ -149,12 +149,12 @@ private void handleViewChange(View view) {
         if (log.isTraceEnabled()) {
             log.trace(""Handle view %s"", view);
         }
-        View oldView = currentView;
+        final List<Address> leavers = View.leftMembers(currentView, view);
         currentView = view;
 
         //basis behavior: drop leavers message (as senders)
-        List<Address> leavers = View.leftMembers(oldView, view);
-        deliverManager.removeLeavers(leavers);
+
+        deliverManager.handleView(view);
 
         //basis behavior: avoid waiting for the acks
         Collection<MessageID> pendingSentMessages = senderManager.getPendingMessageIDs();
@@ -255,8 +255,7 @@ private void send(Collection<Address> destinations, Message msg, boolean sendToM
     }
 
     private void handleDataMessage(Message message, ToaHeader header) {
-        long startTime = statsCollector.now();
-        long duration = -1;
+        final long startTime = statsCollector.now();
 
         try {
             final MessageID messageID = header.getMessageID();
@@ -270,6 +269,11 @@ private void handleDataMessage(Message message, ToaHeader header) {
                           header, myProposeSequenceNumber);
             }
 
+            if (myProposeSequenceNumber == -1) {
+                //message discarded. not sending ack back.
+                return;
+            }
+
             //create a new message and send it back
             ToaHeader newHeader = ToaHeader.newProposeMessageHeader(messageID, myProposeSequenceNumber);
 
@@ -278,11 +282,10 @@ private void handleDataMessage(Message message, ToaHeader header) {
 
             //multicastSenderThread.addUnicastMessage(proposeMessage);
             down_prot.down(proposeMessage);
-            duration = statsCollector.now() - startTime;
         } catch (Exception e) {
             logException(""Exception caught while processing the data message "" + header.getMessageID(), e);
         } finally {
-            statsCollector.addDataMessageDuration(duration);
+            statsCollector.addDataMessageDuration(statsCollector.now() - startTime);
         }
     }
 
@@ -377,6 +380,10 @@ public String getMessageList() {
         return deliverManager.getMessageSet().toString();
     }
 
+    public DeliveryManager getDeliverManager() {
+        return deliverManager;
+    }
+
     @Override
     public void enableStats(boolean flag) {
         super.enableStats(flag);",2017-10-15T16:14:36Z,95
"@@ -0,0 +1,256 @@
+package org.jgroups.protocols;
+
+import static org.testng.AssertJUnit.assertEquals;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Global;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.tom.DeliveryManagerImpl;
+import org.jgroups.protocols.tom.MessageID;
+import org.jgroups.protocols.tom.SequenceNumberManager;
+import org.jgroups.protocols.tom.TOA;
+import org.jgroups.protocols.tom.ToaHeader;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Unit test for TOA protocol
+ *
+ * @author Pedro Ruivo
+ * @since 4.0
+ */
+@Test(groups = {Global.STACK_INDEPENDENT}, singleThreaded = true)
+public class TOA_UnitTest {
+
+   private static final short TOA_ID = ClassConfigurator.getProtocolId(TOA.class);
+
+   private final MockUpProtocol upProtocol;
+   private final MockDownProtocol downProtocol;
+   private final Address localAddress;
+   private TOA toa;
+
+   public TOA_UnitTest() {
+      upProtocol = new MockUpProtocol();
+      downProtocol = new MockDownProtocol();
+      localAddress = Util.createRandomAddress(""A"");
+   }
+
+   @BeforeMethod
+   public void setup() throws Exception {
+      toa = new TOA();
+      toa.setUpProtocol(upProtocol);
+      toa.setDownProtocol(downProtocol);
+      toa.start();
+      toa.stop(); //stops the deliver thread. it isn't needed
+      toa.down(new Event(Event.SET_LOCAL_ADDRESS, localAddress));
+      upProtocol.messages.clear();
+      downProtocol.messages.clear();
+   }
+
+   @AfterMethod
+   public void shutdown() {
+      toa = null;
+      upProtocol.messages.clear();
+      downProtocol.messages.clear();
+   }
+
+   public void testDataMessageFromNonMember() {
+      Address b = Util.createRandomAddress(""B"");
+      Address c = Util.createRandomAddress(""C"");
+
+      setInitialView(localAddress, localAddress, b);
+
+      ToaHeader header = ToaHeader.newDataMessageHeader(new MessageID(c, 1), Collections.singleton(localAddress));
+      Message message = newMessage(header, c, localAddress);
+
+      //Message from member C. it isn't in the view and the message should be discarded.
+      toa.up(message);
+
+      assertEquals(""Deliver Manager doesn't have an empty list"", Collections.emptyList(),
+            deliveryManager().getAllMessages());
+      assertDownMessagesEmpty();
+      assertUpMessagesEmpty();
+   }
+
+   public void testSameSequenceNumberMessage() {
+      Address b = Util.createRandomAddress(""B"");
+
+      setInitialView(localAddress, localAddress, b);
+      sequenceNumberManager().update(9); //it increments it to 10
+
+      ToaHeader header = ToaHeader.newDataMessageHeader(new MessageID(b, 1), Collections.singleton(localAddress));
+      header.setSequencerNumber(10);
+      Message message = newMessage(header, b, localAddress);
+
+      //Message from member C. it isn't in the view and the message should be discarded.
+      toa.up(message);
+
+      assertFirstMessage(10, false);
+      assertEquals(11, sequenceNumberManager().get());
+      assertProposedMessageSent(10);
+
+
+      header = ToaHeader.newFinalMessageHeader(new MessageID(b, 1), 15);
+      message = newMessage(header, b, localAddress);
+
+      toa.up(message);
+
+      assertFirstMessage(15, true);
+      assertEquals(16, sequenceNumberManager().get());
+
+      assertDownMessagesEmpty();
+      assertUpMessagesEmpty();
+   }
+
+   public void testLowerSequenceNumberMessage() {
+      Address b = Util.createRandomAddress(""B"");
+
+      setInitialView(localAddress, localAddress, b);
+      sequenceNumberManager().update(10); //next message will have 11
+
+      ToaHeader header = ToaHeader.newDataMessageHeader(new MessageID(b, 1), Collections.singleton(localAddress));
+      header.setSequencerNumber(2);
+      Message message = newMessage(header, b, localAddress);
+
+      //Message from member C. it isn't in the view and the message should be discarded.
+      toa.up(message);
+
+      assertFirstMessage(11, false);
+      assertEquals(12, sequenceNumberManager().get());
+      assertProposedMessageSent(11);
+
+
+      header = ToaHeader.newFinalMessageHeader(new MessageID(b, 1), 11);
+      message = newMessage(header, b, localAddress);
+
+      toa.up(message);
+
+      assertFirstMessage(11, true);
+      assertEquals(12, sequenceNumberManager().get());
+
+      assertDownMessagesEmpty();
+      assertUpMessagesEmpty();
+   }
+
+   public void testHigherSequenceNumberMessage() {
+      Address b = Util.createRandomAddress(""B"");
+
+      setInitialView(localAddress, localAddress, b);
+      sequenceNumberManager().update(10); //next message will have 11
+
+      ToaHeader header = ToaHeader.newDataMessageHeader(new MessageID(b, 1), Collections.singleton(localAddress));
+      header.setSequencerNumber(20);
+      Message message = newMessage(header, b, localAddress);
+
+      //Message from member C. it isn't in the view and the message should be discarded.
+      toa.up(message);
+
+      assertFirstMessage(20, false);
+      assertEquals(21, sequenceNumberManager().get());
+      assertProposedMessageSent(20);
+
+
+      header = ToaHeader.newFinalMessageHeader(new MessageID(b, 1), 20);
+      message = newMessage(header, b, localAddress);
+
+      toa.up(message);
+
+      assertFirstMessage(20, true);
+      assertEquals(21, sequenceNumberManager().get());
+
+      assertDownMessagesEmpty();
+      assertUpMessagesEmpty();
+   }
+
+   private DeliveryManagerImpl deliveryManager() {
+      return (DeliveryManagerImpl) toa.getDeliverManager();
+   }
+
+   private SequenceNumberManager sequenceNumberManager() {
+      return deliveryManager().getSequenceNumberManager();
+   }
+
+   private void assertProposedMessageSent(long expectedSequenceNumber) {
+      assertEquals(1, downProtocol.messages.size());
+      Message message = downProtocol.messages.remove(0);
+      ToaHeader header = message.getHeader(TOA_ID);
+      assertEquals(ToaHeader.PROPOSE_MESSAGE, header.getType());
+      assertEquals(expectedSequenceNumber, header.getSequencerNumber());
+   }
+
+   private void assertFirstMessage(long sequenceNumber, boolean isReady) {
+      List<DeliveryManagerImpl.MessageInfo> messages = deliveryManager().getAllMessages();
+      assertEquals(1, messages.size());
+      DeliveryManagerImpl.MessageInfo pending = messages.get(0);
+      assertEquals(sequenceNumber, pending.getSequenceNumber());
+      assertEquals(isReady, pending.isReadyToDeliver());
+   }
+
+   private void assertUpMessagesEmpty() {
+      assertEquals(""UP message list isn't empty."", Collections.emptyList(), upProtocol.messages);
+   }
+
+   private void assertDownMessagesEmpty() {
+      assertEquals(""DOWN message list isn't empty."", Collections.emptyList(), upProtocol.messages);
+   }
+
+   private void setInitialView(Address localAddress, Address... members) {
+      toa.down(new Event(Event.SET_LOCAL_ADDRESS, localAddress));
+      toa.down(new Event(Event.VIEW_CHANGE, View.create(localAddress, 1, members)));
+   }
+
+   private Message newMessage(ToaHeader header, Address from, Address to) {
+      return new Message(to).setSrc(from).putHeader(TOA_ID, header);
+   }
+
+   private static class MockUpProtocol extends Protocol {
+
+      private final List<Message> messages;
+
+      private MockUpProtocol() {
+         messages = Collections.synchronizedList(new LinkedList<>());
+      }
+
+      @Override
+      public Object up(Message msg) {
+         messages.add(msg);
+         return null;
+      }
+
+      @Override
+      public Object up(Event evt) {
+         return null; //no-op
+      }
+   }
+
+   private static class MockDownProtocol extends Protocol {
+
+      private final List<Message> messages;
+
+      private MockDownProtocol() {
+         messages = Collections.synchronizedList(new LinkedList<>());
+      }
+
+      @Override
+      public Object down(Event evt) {
+         return null; //no-op
+      }
+
+      @Override
+      public Object down(Message msg) {
+         messages.add(msg);
+         return null;
+      }
+   }
+
+}",2017-10-15T16:14:36Z,96
"@@ -171,9 +171,9 @@ public int size() {
 
     public String toString() {
         StringBuilder sb=new StringBuilder(64);
-        sb.append(view_id).append("" "");
+        sb.append(view_id);
         if(members != null)
-            sb.append(""["").append(Util.printListWithDelimiter(members, "", "", Util.MAX_LIST_PRINT_SIZE)).append(""]"");
+            sb.append("" ["").append(Util.printListWithDelimiter(members, "", "", Util.MAX_LIST_PRINT_SIZE)).append(""]"");
         return sb.toString();
     }
 
@@ -228,7 +228,7 @@ public static Address[][] diff(final View from, final View to) {
         Address[] joined=null, left=null;
         int num_joiners=0, num_left=0;
 
-        // determin joiners
+        // determine joiners
         for(Address addr: to)
             if(!from.containsMember(addr))
                 num_joiners++;
@@ -240,7 +240,7 @@ public static Address[][] diff(final View from, final View to) {
                     joined[index++]=addr;
         }
 
-        // determin leavers
+        // determine leavers
         for(Address addr: from)
             if(!to.containsMember(addr))
                 num_left++;
@@ -258,4 +258,5 @@ public static Address[][] diff(final View from, final View to) {
     public Iterator<Address> iterator() {
         return new ArrayIterator(this.members);
     }
+
 }",2013-09-16T11:44:49Z,97
"@@ -22,7 +22,7 @@
  * @author Bela Ban, Oct 17 2001
  */
 public class Draw extends ReceiverAdapter implements ActionListener, ChannelListener {
-    String                         groupname=""draw-cluster"";
+    protected String               cluster_name=""draw-cluster"";
     private JChannel               channel=null;
     private int                    member_size=1;
     private JFrame                 mainFrame=null;
@@ -38,11 +38,12 @@ public class Draw extends ReceiverAdapter implements ActionListener, ChannelList
     private boolean                use_state=false;
     private long                   state_timeout=5000;
     private boolean                use_unicasts=false;
+    protected boolean              send_own_state_on_merge=true;
     private final                  List<Address> members=new ArrayList<Address>();
 
 
     public Draw(String props, boolean no_channel, boolean jmx, boolean use_state, long state_timeout,
-                boolean use_unicasts, String name) throws Exception {
+                boolean use_unicasts, String name, boolean send_own_state_on_merge) throws Exception {
         this.no_channel=no_channel;
         this.jmx=jmx;
         this.use_state=use_state;
@@ -56,6 +57,7 @@ public Draw(String props, boolean no_channel, boolean jmx, boolean use_state, lo
             channel.setName(name);
         channel.setReceiver(this);
         channel.addChannelListener(this);
+        this.send_own_state_on_merge=send_own_state_on_merge;
     }
 
     public Draw(JChannel channel) throws Exception {
@@ -74,13 +76,13 @@ public Draw(JChannel channel, boolean use_state, long state_timeout) throws Exce
     }
 
 
-    public String getGroupName() {
-        return groupname;
+    public String getClusterName() {
+        return cluster_name;
     }
 
-    public void setGroupName(String groupname) {
-        if(groupname != null)
-            this.groupname=groupname;
+    public void setClusterName(String clustername) {
+        if(clustername != null)
+            this.cluster_name=clustername;
     }
 
 
@@ -94,6 +96,7 @@ public static void main(String[] args) {
         long             state_timeout=5000;
         boolean          use_unicasts=false;
         String           name=null;
+        boolean          send_own_state_on_merge=true;
 
         for(int i=0; i < args.length; i++) {
             if(""-help"".equals(args[i])) {
@@ -112,7 +115,7 @@ public static void main(String[] args) {
                 jmx=Boolean.parseBoolean(args[++i]);
                 continue;
             }
-            if(""-groupname"".equals(args[i])) {
+            if(""-clustername"".equals(args[i])) {
                 group_name=args[++i];
                 continue;
             }
@@ -136,15 +139,19 @@ public static void main(String[] args) {
                 name=args[++i];
                 continue;
             }
+            if(""-send_own_state_on_merge"".equals(args[i])) {
+                send_own_state_on_merge=Boolean.getBoolean(args[++i]);
+                continue;
+            }
 
             help();
             return;
         }
 
         try {
-            draw=new Draw(props, no_channel, jmx, use_state, state_timeout, use_unicasts, name);
+            draw=new Draw(props, no_channel, jmx, use_state, state_timeout, use_unicasts, name, send_own_state_on_merge);
             if(group_name != null)
-                draw.setGroupName(group_name);
+                draw.setClusterName(group_name);
             draw.go();
         }
         catch(Throwable e) {
@@ -156,8 +163,8 @@ public static void main(String[] args) {
 
     static void help() {
         System.out.println(""\nDraw [-help] [-no_channel] [-props <protocol stack definition>]"" +
-                "" [-groupname <name>] [-state] [-timeout <state timeout>] [-use_unicasts] "" +
-                ""[-bind_addr <addr>] [-jmx <true | false>] [-name <logical name>]"");
+                "" [-clustername <name>] [-state] [-timeout <state timeout>] [-use_unicasts] "" +
+                ""[-bind_addr <addr>] [-jmx <true | false>] [-name <logical name>] [-send_own_state_on_merge true|false]"");
         System.out.println(""-no_channel: doesn't use JGroups at all, any drawing will be relected on the "" +
                 ""whiteboard directly"");
         System.out.println(""-props: argument can be an old-style protocol stack specification, or it can be "" +
@@ -174,17 +181,14 @@ private Color selectColor() {
 
 
     private void sendToAll(byte[] buf) throws Exception {
-        for(Address mbr: members) {
-            Message msg=new Message(mbr, null, buf);
-            channel.send(msg);
-        }
+        for(Address mbr: members)
+            channel.send(new Message(mbr, buf));
     }
 
 
     public void go() throws Exception {
-        if(!no_channel && !use_state) {
-            channel.connect(groupname);            
-        }
+        if(!no_channel && !use_state)
+            channel.connect(cluster_name);
         mainFrame=new JFrame();
         mainFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
         panel=new DrawPanel(use_state);
@@ -208,7 +212,7 @@ public void go() throws Exception {
         mainFrame.setBounds(new Rectangle(250, 250));
 
         if(!no_channel && use_state) {
-            channel.connect(groupname, null, state_timeout);
+            channel.connect(cluster_name, null, state_timeout);
         }
         mainFrame.setVisible(true);
         setTitle();
@@ -285,8 +289,18 @@ public void viewAccepted(View v) {
                 Address local_addr=channel.getAddress();
                 if(local_addr != null && !local_addr.equals(coord)) {
                     try {
+
+                        // make a copy of our state first
+                        Map<Point,Color> copy=null;
+                        if(send_own_state_on_merge) {
+                            synchronized(panel.state) {
+                                copy=new LinkedHashMap<Point,Color>(panel.state);
+                            }
+                        }
                         System.out.println(""fetching state from "" + coord);
                         channel.getState(coord, 5000);
+                        if(copy != null)
+                            sendOwnState(copy); // multicast my own state so everybody else has it too
                     }
                     catch(Exception e) {
                         e.printStackTrace();
@@ -318,7 +332,6 @@ public void clearPanel() {
 
     public void sendClearPanelMsg() {
         DrawCommand comm=new DrawCommand(DrawCommand.CLEAR);
-
         try {
             byte[] buf=Util.streamableToByteBuffer(comm);
             if(use_unicasts)
@@ -362,6 +375,25 @@ public void stop() {
         mainFrame.dispose();
     }
 
+    protected void sendOwnState(final Map<Point,Color> copy) {
+        if(copy == null)
+            return;
+        for(Point point: copy.keySet()) {
+            // we don't need the color: it is our draw_color anyway
+            DrawCommand comm=new DrawCommand(DrawCommand.DRAW, point.x, point.y, draw_color.getRGB());
+            try {
+                byte[] buf=Util.streamableToByteBuffer(comm);
+                if(use_unicasts)
+                    sendToAll(buf);
+                else
+                    channel.send(new Message(null, buf));
+            }
+            catch(Exception ex) {
+                System.err.println(ex);
+            }
+        }
+    }
+
 
     /* ------------------------------ ChannelListener interface -------------------------- */
 
@@ -376,7 +408,7 @@ public void channelDisconnected(Channel channel) {
             MBeanServer server=Util.getMBeanServer();
             if(server != null) {
                 try {
-                    JmxConfigurator.unregisterChannel((JChannel)channel,server, groupname);
+                    JmxConfigurator.unregisterChannel((JChannel)channel,server,cluster_name);
                 }
                 catch(Exception e) {
                     e.printStackTrace();
@@ -394,12 +426,12 @@ public void channelClosed(Channel channel) {
 
 
 
-    private class DrawPanel extends JPanel implements MouseMotionListener {
-        final Dimension         preferred_size=new Dimension(235, 170);
-        Image                   img=null; // for drawing pixels
-        Dimension               d, imgsize=null;
-        Graphics                gr=null;
-        final Map<Point,Color>  state;
+    protected class DrawPanel extends JPanel implements MouseMotionListener {
+        protected final Dimension         preferred_size=new Dimension(235, 170);
+        protected Image                   img; // for drawing pixels
+        protected Dimension               d, imgsize;
+        protected Graphics                gr;
+        protected final Map<Point,Color>  state;
 
 
         public DrawPanel(boolean use_state) {
@@ -483,8 +515,7 @@ public void mouseMoved(MouseEvent e) {}
 
         public void mouseDragged(MouseEvent e) {
             int                 x=e.getX(), y=e.getY();
-            DrawCommand         comm=new DrawCommand(DrawCommand.DRAW, x, y,
-                                                     draw_color.getRed(), draw_color.getGreen(), draw_color.getBlue());
+            DrawCommand         comm=new DrawCommand(DrawCommand.DRAW, x, y, draw_color.getRGB());
 
             if(no_channel) {
                 drawPoint(comm);
@@ -514,7 +545,7 @@ public void mouseDragged(MouseEvent e) {
          */
         public void drawPoint(DrawCommand c) {
             if(c == null || gr == null) return;
-            Color col=new Color(c.r, c.g, c.b);
+            Color col=new Color(c.rgb);
             gr.setColor(col);
             gr.fillOval(c.x, c.y, 10, 10);
             repaint();
@@ -539,9 +570,6 @@ public void clear() {
         }
 
 
-
-
-
         /** Draw the entire panel from the state */
         public void drawState() {
             // clear();
@@ -576,26 +604,5 @@ public void paintComponent(Graphics g) {
 
     }
 
-
-   /* protected class MyPoint extends Point implements Comparable<Point> {
-        private static final long serialVersionUID=4171855995316340839L;
-
-        public MyPoint() {
-        }
-
-        public MyPoint(Point p) {
-            super(p);
-        }
-
-        public MyPoint(int x, int y) {
-            super(x,y);
-        }
-
-
-        public int compareTo(Point o) {
-            return x > o.x? 1 : x < o.x? -1 : y > o.y? 1 : y < o.y ? -1 :0;
-        }
-    }*/
-
 }
 ",2013-09-16T11:44:49Z,98
"@@ -15,11 +15,9 @@ public class DrawCommand implements Streamable {
     static final byte DRAW=1;
     static final byte CLEAR=2;
     byte mode;
-    int x=0;
-    int y=0;
-    int r=0;
-    int g=0;
-    int b=0;
+    int x;
+    int y;
+    int rgb;
 
     public DrawCommand() { // needed for streamable
     }
@@ -28,39 +26,33 @@ public DrawCommand() { // needed for streamable
         this.mode=mode;
     }
 
-    DrawCommand(byte mode, int x, int y, int r, int g, int b) {
+    DrawCommand(byte mode, int x, int y, int rgb) {
         this.mode=mode;
         this.x=x;
         this.y=y;
-        this.r=r;
-        this.g=g;
-        this.b=b;
+        this.rgb=rgb;
     }
 
 
     public void writeTo(DataOutput out) throws Exception {
         out.writeByte(mode);
         out.writeInt(x);
         out.writeInt(y);
-        out.writeInt(r);
-        out.writeInt(g);
-        out.writeInt(b);
+        out.writeInt(rgb);
     }
 
     public void readFrom(DataInput in) throws Exception {
         mode=in.readByte();
         x=in.readInt();
         y=in.readInt();
-        r=in.readInt();
-        g=in.readInt();
-        b=in.readInt();
+        rgb=in.readInt();
     }
 
 
     public String toString() {
         StringBuilder ret=new StringBuilder();
         switch(mode) {
-            case DRAW: ret.append(""DRAW("" + x + "", "" + y + "") ["" + r + '|' + g + '|' + b + ']');
+            case DRAW: ret.append(""DRAW("" + x + "", "" + y + "") ["" + rgb + ""]"");
                 break;
             case CLEAR: ret.append(""CLEAR"");
                 break;",2013-09-16T11:44:49Z,99
"@@ -401,8 +401,7 @@ public void mouseMoved(MouseEvent e) {}
 
         public void mouseDragged(MouseEvent e) {
             int                 x=e.getX(), y=e.getY();
-            DrawCommand         comm=new DrawCommand(DrawCommand.DRAW, x, y,
-                                                     draw_color.getRed(), draw_color.getGreen(), draw_color.getBlue());
+            DrawCommand         comm=new DrawCommand(DrawCommand.DRAW, x, y, draw_color.getRGB());
 
             try {
                 byte[] buf=Util.streamableToByteBuffer(comm);
@@ -424,7 +423,7 @@ public void mouseDragged(MouseEvent e) {
          */
         public void drawPoint(DrawCommand c) {
             if(c == null || gr == null) return;
-            Color col=new Color(c.r, c.g, c.b);
+            Color col=new Color(c.rgb);
             gr.setColor(col);
             gr.fillOval(c.x, c.y, 10, 10);
             repaint();",2013-09-16T11:44:49Z,100
"@@ -20,7 +20,7 @@
  * @author Bela Ban
  */
 public class CoordGmsImpl extends ServerGmsImpl {
-    private static final Long  MAX_SUSPEND_TIMEOUT=30000L;
+    protected static final Long  MAX_SUSPEND_TIMEOUT=30000L;
 
     public CoordGmsImpl(GMS g) {
         super(g);
@@ -113,12 +113,14 @@ public void handleMembershipChange(Collection<Request> requests) {
             switch(req.type) {
                 case Request.JOIN:
                     new_mbrs.add(req.mbr);
-                    useFlushIfPresent=req.useFlushIfPresent;
+                    if(req.useFlushIfPresent)
+                        useFlushIfPresent=true;
                     break;
                 case Request.JOIN_WITH_STATE_TRANSFER:
                     new_mbrs.add(req.mbr);
                     joinAndStateTransferInitiated=true;
-                    useFlushIfPresent=req.useFlushIfPresent;
+                    if(req.useFlushIfPresent)
+                        useFlushIfPresent=true;
                     break;
                 case Request.LEAVE:
                     if(req.suspected)
@@ -137,24 +139,23 @@ public void handleMembershipChange(Collection<Request> requests) {
         if(gms.getViewId() == null) {
             // we're probably not the coord anymore (we just left ourselves), let someone else do it
             // (client will retry when it doesn't get a response)
-            if(log.isDebugEnabled())
-                log.debug(""gms.view_id is null, I'm not the coordinator anymore (leaving="" + String.valueOf(leaving) +
-                        ""); the new coordinator will handle the leave request"");
+            log.debug(""gms.view_id is null, I'm not the coordinator anymore (leaving=%b); "" +
+                        ""the new coordinator will handle the leave request"", leaving);
             return;
         }
 
         List<Address> current_members=gms.members.getMembers();
         leaving_mbrs.retainAll(current_members); // remove all elements of leaving_mbrs which are not current members
-        if(suspected_mbrs.remove(gms.local_addr)) {
-            if(log.isWarnEnabled()) log.warn(""I am the coord and I'm being suspected -- will probably leave shortly"");
-        }
+        if(suspected_mbrs.remove(gms.local_addr))
+            log.warn(""I am the coord and I'm being suspected -- will probably leave shortly"");
+
         suspected_mbrs.retainAll(current_members); // remove all elements of suspected_mbrs which are not current members
 
         // for the members that have already joined, return the current digest and membership
         for(Iterator<Address> it=new_mbrs.iterator(); it.hasNext();) {
             Address mbr=it.next();
             if(gms.members.contains(mbr)) { // already joined: return current digest and membership
-                log.warn(""%s: %s already present; returning existing view %s"", gms.local_addr, mbr, gms.view);
+                log.trace(""%s: %s already present; returning existing view %s"", gms.local_addr, mbr, gms.view);
                 Tuple<View,Digest> tuple=gms.getViewAndDigest();
                 if(tuple != null)
                     gms.sendJoinResponse(new JoinRsp(tuple.getVal1(), tuple.getVal2()), mbr);
@@ -209,13 +210,14 @@ public void handleMembershipChange(Collection<Request> requests) {
                     join_rsp=new JoinRsp(new_view, join_digest);
                 else
                     log.warn(""%s: digest does not match view (missing seqnos for %s); dropping JOIN-RSP"",
-                             gms.local_addr, join_digest.getNonSetMembers());
+                             gms.local_addr, Arrays.toString(join_digest.getNonSetMembers()));
             }
 
             sendLeaveResponses(leaving_mbrs); // no-op if no leaving members
 
             // we don't need to send the digest to existing members: https://issues.jboss.org/browse/JGRP-1317
-            gms.castViewChange(new_view, null, join_rsp, new_mbrs);
+            gms.castViewChange(new_view, null, new_mbrs);
+            gms.sendJoinResponses(join_rsp, new_mbrs);
         }
         finally {
             if(hasJoiningMembers)",2013-09-16T11:44:49Z,87
"@@ -0,0 +1,87 @@
+package org.jgroups.protocols.pbcast;
+
+import org.jgroups.Address;
+import org.jgroups.View;
+import org.jgroups.ViewId;
+import org.jgroups.util.Util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.Arrays;
+
+/**
+ * Subclass of {@link org.jgroups.View} with a null members field. Adds an array for left members and one for joined
+ * members compared to the previous view. A recipient receiving a DeltaView can construct a new view by grabbing the
+ * view corresponding to {@link #view_id}, removing the left members and adding the new members.<p/>
+ * This class is only used with VIEW messages in GMS to install new views (not merge views). When a VIEW
+ * message is received, the DeltaView is read from the {@link org.jgroups.protocols.pbcast.GMS.GmsHeader}, a View is
+ * constructured and the header discarded. Therefore, the lifetime of a DeltaView is short: it is created and set in
+ * a GmsHeader, the header is then marshalled. On the receiving side, the DeltaView is created from the stream, a View
+ * is created and the DeltaView discarded again.<p/>
+ * Instances of this class are created by {@link CoordGmsImpl#handleMembershipChange(java.util.Collection)}.<p/>
+ * JIRA issue: https://issues.jboss.org/browse/JGRP-1354
+ * @author Bela Ban
+ * @since  3.4
+ */
+public class DeltaView extends View {
+    /** The fields left_members and new_members refer to the view corresponding to ref_view_id */
+    protected ViewId    ref_view_id;
+
+    /** Members which left the view corresponding to ref_view_id */
+    protected Address[] left_members;
+
+    /** Members which joined the view corresponding to ref_view_id */
+    protected Address[] new_members;
+
+    public DeltaView() {
+
+    }
+
+
+    public DeltaView(ViewId view_id, ViewId ref_view_id, Address[] left_members, Address[] new_members) {
+        this.view_id=view_id;
+        this.ref_view_id=ref_view_id;
+        this.left_members=left_members;
+        this.new_members=new_members;
+        if(view_id == null)      throw new IllegalArgumentException(""view_id cannot be null"");
+        if(ref_view_id == null) throw new IllegalArgumentException(""ref_view_id cannot be null"");
+    }
+
+    public ViewId    getRefViewId()     {return ref_view_id;}
+    public Address[] getLeftMembers()   {return left_members;}
+    public Address[] getNewMembers()    {return new_members;}
+
+
+    public int serializedSize() {
+        int retval=view_id.serializedSize() + ref_view_id.serializedSize();
+        retval+=Util.size(left_members);
+        retval+=Util.size(new_members);
+        return retval;
+    }
+
+
+    public void writeTo(DataOutput out) throws Exception {
+        view_id.writeTo(out);
+        ref_view_id.writeTo(out);
+        Util.writeAddresses(left_members, out);
+        Util.writeAddresses(new_members, out);
+    }
+
+    public void readFrom(DataInput in) throws Exception {
+        view_id=new ViewId();
+        view_id.readFrom(in);
+        ref_view_id=new ViewId();
+        ref_view_id.readFrom(in);
+        left_members=Util.readAddresses(in);
+        new_members=Util.readAddresses(in);
+    }
+
+    public String toString() {
+        StringBuilder sb=new StringBuilder(super.toString()).append("", ref-view="").append(ref_view_id);
+        if(left_members != null && left_members.length > 0)
+            sb.append("", left="").append(Arrays.toString(left_members));
+        if(new_members != null && new_members.length > 0)
+            sb.append("", joined="").append(Arrays.toString(new_members));
+        return sb.toString();
+    }
+}",2013-09-16T11:44:49Z,101
"@@ -73,14 +73,18 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     @Property(description=""View bundling toggle"")
     protected boolean view_bundling=true;
 
+    @Property(description=""If true, then GMS is allowed to send VIEW messages with delta views, otherwise "" +
+      ""it always sends full views. See https://issues.jboss.org/browse/JGRP-1354 for details."")
+    protected boolean use_delta_views=true;
+
     @Property(description=""Max view bundling timeout if view bundling is turned on. Default is 50 msec"")
     protected long max_bundling_time=50; // 50ms max to wait for other JOIN, LEAVE or SUSPECT requests
 
     @Property(description=""Max number of old members to keep in history. Default is 50"")
     protected int num_prev_mbrs=50;
 
     @Property(description=""Number of views to store in history"")
-    protected int num_prev_views=20;
+    protected int num_prev_views=10;
 
     @Property(description=""Time in ms to wait for all VIEW acks (0 == wait forever. Default is 2000 msec"" )
     protected long view_ack_collection_timeout=2000;
@@ -104,22 +108,22 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
     protected int num_views;
 
     /** Stores the last 20 views */
-    protected BoundedList<Tuple<View,Long>> prev_views;
+    protected BoundedList<String> prev_views;
 
 
     /* --------------------------------------------- Fields ------------------------------------------------ */
 
     @Property(converter=PropertyConverters.FlushInvoker.class,name=""flush_invoker_class"")
-    protected Class<Callable<Boolean>> flushInvokerClass;
+    protected Class<Callable<Boolean>>  flushInvokerClass;
 
-    protected GmsImpl impl;
-    protected final Object impl_mutex=new Object(); // synchronizes event entry into impl
+    protected GmsImpl                   impl;
+    protected final Object              impl_mutex=new Object(); // synchronizes event entry into impl
     protected final Map<String,GmsImpl> impls=new HashMap<String,GmsImpl>(3);
 
     // Handles merge related tasks
-    protected final Merger merger=new Merger(this);
+    protected final Merger         merger=new Merger(this);
 
-    protected Address local_addr;
+    protected Address              local_addr;
     protected final Membership     members=new Membership(); // real membership
 
     protected final Membership     tmp_members=new Membership(); // base for computing next view
@@ -153,6 +157,9 @@ public class GMS extends Protocol implements DiagnosticsHandler.ProbeHandler {
 
     protected boolean              flushProtocolInStack=false;
 
+    // Has this coord sent its first view since becoming coord ? Used to send a full- or delta- view */
+    protected boolean              first_view_sent;
+
 
 
     public GMS() {
@@ -293,8 +300,8 @@ public void resumeViewHandler() {
     @ManagedOperation
     public String printPreviousViews() {
         StringBuilder sb=new StringBuilder();
-        for(Tuple<View,Long> tmp: prev_views)
-            sb.append(new Date(tmp.getVal2())).append("": "").append(tmp.getVal1()).append(""\n"");
+        for(String view_rep: prev_views)
+            sb.append(view_rep).append(""\n"");
         return sb.toString();
     }
 
@@ -365,7 +372,7 @@ public void init() throws Exception {
         if(merge_timeout <= 0)
             throw new IllegalArgumentException(""merge_timeout has to be greater than 0"");
         prev_members=new BoundedList<Address>(num_prev_mbrs);
-        prev_views=new BoundedList<Tuple<View,Long>>(num_prev_views);
+        prev_views=new BoundedList<String>(num_prev_views);
         TP transport=getTransport();
         timer=transport.getTimer();
         if(timer == null)
@@ -394,6 +401,7 @@ public void becomeCoordinator() {
             impls.put(COORD, tmp);
         }
         try {
+            first_view_sent=false;
             tmp.init();
         }
         catch(Exception e) {
@@ -549,22 +557,28 @@ protected List<Address> computeNewMembership(final Collection<Collection<Address
 
 
     /**
-     * Broadcasts the new view and digest, and waits for acks from all members in the list given as argument.
-     * If the list is null, we take the members who are part of new_view
+     * Broadcasts the new view and digest as a VIEW message and waits for acks from existing members
      */
-    public void castViewChange(View new_view, Digest digest, JoinRsp jr, Collection<Address> newMembers) {
+    public void castViewChange(View new_view, Digest digest, Collection<Address> newMembers) {
         log.trace(""%s: mcasting view %s (%d mbrs)\n"", local_addr, new_view, new_view.size());
 
         // Send down a local TMP_VIEW event. This is needed by certain layers (e.g. NAKACK) to compute correct digest
         // in case client's next request (e.g. getState()) reaches us *before* our own view change multicast.
         // Check NAKACK's TMP_VIEW handling for details
-        up_prot.up(new Event(Event.TMP_VIEW,new_view));
+        up_prot.up(new Event(Event.TMP_VIEW, new_view));
         down_prot.down(new Event(Event.TMP_VIEW, new_view));
 
         List<Address> ackMembers=new ArrayList<Address>(new_view.getMembers());
         if(newMembers != null && !newMembers.isEmpty())
             ackMembers.removeAll(newMembers);
 
+        if(use_delta_views && view != null && !(new_view instanceof MergeView)) {
+            if(!first_view_sent) // send the first view as coord as *full* view
+                first_view_sent=true;
+            else
+                new_view=createDeltaView(view, new_view);
+        }
+
         // bcast to all members
         Message view_change_msg=new Message().putHeader(this.id, new GmsHeader(GmsHeader.VIEW, new_view, digest));
 
@@ -589,20 +603,22 @@ public void castViewChange(View new_view, Digest digest, JoinRsp jr, Collection<
                          local_addr, ack_collector.expectedAcks(), new_view.getViewId(), view_ack_collection_timeout,
                          ack_collector.printMissing());
         }
+    }
 
+    public void sendJoinResponses(JoinRsp jr, Collection<Address> newMembers) {
         if(jr != null && newMembers != null && !newMembers.isEmpty()) {
+            final ViewId view_id=jr.getView().getViewId();
             ack_collector.reset(new ArrayList<Address>(newMembers));
             for(Address joiner: newMembers)
                 sendJoinResponse(jr, joiner);
             try {
                 ack_collector.waitForAllAcks(view_ack_collection_timeout);
-                log.trace(""%s: got all ACKs (%d) from joiners for view %s"",
-                          local_addr, ack_collector.expectedAcks(), new_view.getViewId());
+                log.trace(""%s: got all ACKs (%d) from joiners for view %s"", local_addr, ack_collector.expectedAcks(), view_id);
             }
             catch(TimeoutException e) {
                 if(log_collect_msgs)
                     log.warn(""%s: failed to collect all ACKs (expected=%d) for unicast view %s after %dms, missing ACKs from %s"",
-                             local_addr, ack_collector.expectedAcks(), new_view, view_ack_collection_timeout,  ack_collector.printMissing());
+                             local_addr, ack_collector.expectedAcks(), view_id, view_ack_collection_timeout,  ack_collector.printMissing());
             }
         }
     }
@@ -697,7 +713,7 @@ public synchronized void installView(View new_view, Digest digest) {
 
         if(stats) {
             num_views++;
-            prev_views.add(new Tuple<View,Long>(new_view, System.currentTimeMillis()));
+            prev_views.add(new Date() + "": "" + new_view);
         }
     }
 
@@ -708,6 +724,13 @@ protected Address determineCoordinator() {
         }
     }
 
+    protected static View createDeltaView(final View current_view, final View next_view) {
+        final ViewId current_view_id=current_view.getViewId();
+        final ViewId next_view_id=next_view.getViewId();
+        Address[][] diff=View.diff(current_view, next_view);
+        return new DeltaView(next_view_id, current_view_id, diff[1], diff[0]);
+    }
+
 
     /** Checks whether the potential_new_coord would be the new coordinator (2nd in line) */
     protected boolean wouldBeNewCoordinator(Address potential_new_coord) {
@@ -841,6 +864,22 @@ public Object up(Event evt) {
                         if(new_view == null)
                             return null;
 
+                        // Discards view with id lower than or equal to our own. Will be installed without check if it is the first view
+                        if(view != null && new_view.getViewId().compareToIDs(view.getViewId()) <= 0)
+                            return null;
+                        if(new_view instanceof DeltaView) {
+                            try {
+                                log.trace(""%s: received delta view %s"", local_addr, new_view);
+                                new_view=createViewFromDeltaView(view,(DeltaView)new_view);
+                            }
+                            catch(Throwable t) {
+                                log.warn(""%s: failed to create view from delta-view; dropping view: %s"", local_addr, t);
+                                return null;
+                            }
+                        }
+                        else
+                            log.trace(""%s: received full view: %s"", local_addr, new_view);
+
                         Address coord=msg.getSrc();
                         if(!new_view.containsMember(coord)) {
                             sendViewAck(coord); // we need to send the ack first, otherwise the connection is removed
@@ -1026,6 +1065,7 @@ public String[] supportedKeys() {
     final void initState() {
         becomeClient();
         view=null;
+        first_view_sent=false;
     }
 
 
@@ -1035,6 +1075,25 @@ private void sendViewAck(Address dest) {
         down_prot.down(new Event(Event.MSG,view_ack));
     }
 
+
+    protected View createViewFromDeltaView(View current_view, DeltaView delta_view) {
+        if(current_view == null || delta_view == null)
+            return null;
+        ViewId current_view_id=current_view.getViewId(),
+          delta_ref_view_id=delta_view.getRefViewId(),
+          delta_view_id=delta_view.getViewId();
+        if(!current_view_id.equals(delta_ref_view_id))
+            throw new IllegalStateException(""the view-id of the delta view (""+delta_ref_view_id+"") doesn't match the "" +
+                                              ""current view-id (""+current_view_id+""); discarding delta view"");
+        List<Address> current_mbrs=current_view.getMembers();
+        List<Address> left_mbrs=Arrays.asList(delta_view.getLeftMembers());
+        List<Address> new_mbrs=Arrays.asList(delta_view.getNewMembers());
+
+
+        List<Address> new_mbrship=computeNewMembership(current_mbrs,new_mbrs,left_mbrs,Collections.<Address>emptyList());
+        return new View(delta_view_id, new_mbrship);
+    }
+
     /* --------------------------- End of Private Methods ------------------------------- */
 
     public static class DefaultMembershipPolicy implements MembershipChangePolicy {
@@ -1127,8 +1186,9 @@ public static class GmsHeader extends Header {
         public static final short MERGE_ID_PRESENT = 1 << 3;
         public static final short USE_FLUSH        = 1 << 4;
         public static final short MERGE_REJECTED   = 1 << 5;
-        public static final short MERGE_VIEW       = 1 << 6; // if a view is present, is it a View or a MergeView ?
-        public static final short READ_ADDRS       = 1 << 7; // if my_digest needs to read its own addresses (rather than that of view)
+        public static final short MERGE_VIEW       = 1 << 6; // if a view is present, is it a MergeView ?
+        public static final short DELTA_VIEW       = 1 << 7; // if a view is present, is it a DeltaView ?
+        public static final short READ_ADDRS       = 1 << 8; // if my_digest needs to read its own addresses (rather than that of view)
 
 
         protected byte    type;
@@ -1218,7 +1278,9 @@ public void readFrom(DataInput in) throws Exception {
             short flags=in.readShort();
 
             if((flags & VIEW_PRESENT) == VIEW_PRESENT) {
-                view=(flags & MERGE_VIEW) == MERGE_VIEW? new MergeView() : new View();
+                view=(flags & MERGE_VIEW) == MERGE_VIEW? new MergeView() :
+                  (flags & DELTA_VIEW) == DELTA_VIEW? new DeltaView() :
+                    new View();
                 view.readFrom(in);
             }
 
@@ -1278,6 +1340,8 @@ protected short determineFlags() {
                 retval|=VIEW_PRESENT;
                 if(view instanceof MergeView)
                     retval|=MERGE_VIEW;
+                else if(view instanceof DeltaView)
+                    retval|=DELTA_VIEW;
             }
             if(join_rsp != null)  retval|=JOIN_RSP_PRESENT;
             if(digest != null) retval|=DIGEST_PRESENT;",2013-09-16T11:44:49Z,74
"@@ -170,7 +170,7 @@ public void handleMergeView(final MergeData data, final MergeId merge_id) {
         newViewMembers.removeAll(gms.members.getMembers());
 
         try {
-            gms.castViewChange(data.view,data.digest,null,newViewMembers);
+            gms.castViewChange(data.view, data.digest, newViewMembers);
             // if we have flush in stack send ack back to merge coordinator
             if(gms.flushProtocolInStack) { //[JGRP-700] - FLUSH: flushing should span merge
                 Message ack=new Message(data.getSender()).setFlag(Message.Flag.OOB, Message.Flag.INTERNAL)",2013-09-16T11:44:49Z,53
"@@ -118,8 +118,7 @@ public void handleMembershipChange(Collection<Request> requests) {
                 suspected_mbrs.add(mbr);
 
         if(wouldIBeCoordinator()) {
-            if(log.isDebugEnabled())
-                log.debug(gms.local_addr + "": members are "" + gms.members + "", coord="" + gms.local_addr + "": I'm the new coord !"");
+            log.debug(""%s: members are %s, coord=%s: I'm the new coord !"", gms.local_addr, gms.members, gms.local_addr);
 
             gms.becomeCoordinator();
             for(Address mbr: suspected_mbrs) {",2013-09-16T11:44:49Z,88
"@@ -36,12 +36,10 @@ public class LargeMergeTest {
     static final int NUM=50; // number of members
     static final int MAX_PARTICIPANTS_IN_MERGE=NUM / 3;
 
-    protected final JChannel[] channels=new JChannel[NUM];
-
+    protected final JChannel[]     channels=new JChannel[NUM];
     protected MyDiagnosticsHandler handler;
-
-    protected ThreadPoolExecutor oob_thread_pool;
-    protected ThreadPoolExecutor thread_pool;
+    protected ThreadPoolExecutor   oob_thread_pool;
+    protected ThreadPoolExecutor   thread_pool;
 
 
 ",2013-09-16T11:44:49Z,102
"@@ -396,6 +396,37 @@ public static void testView() throws Exception {
         _testSize(v);
     }
 
+    public void testDeltaView() throws Exception {
+        Address[] prev_mbrs=Util.createRandomAddresses(4); // A,B,C,D
+        Address[] new_mbrs=Arrays.copyOf(prev_mbrs, prev_mbrs.length); // A,B,E,F (-CD +EF)
+        new_mbrs[2]=Util.createRandomAddress(""E"");
+        new_mbrs[3]=Util.createRandomAddress(""F"");
+
+        View v1=View.create(prev_mbrs[0], 1, prev_mbrs);
+        View v2=View.create(new_mbrs[0], 2, new_mbrs);
+
+        Address[][] diff=View.diff(v1,v2);
+
+        Address[] joined=diff[0], left=diff[1];
+        DeltaView dv=new DeltaView(v2.getViewId(), v1.getViewId(), left, joined);
+        System.out.println(""dv = "" + dv);
+        _testSize(dv, DeltaView.class);
+    }
+
+
+    public static void testLargeView() throws Exception {
+        Address[] members=Util.createRandomAddresses(1000);
+        View view=View.create(members[0], 1, members);
+        _testSize(view);
+
+
+        ViewId new_view_id=new ViewId(members[0], 2);
+        view=new DeltaView(new_view_id, view.getViewId(),
+                           new Address[]{members[4],members[5]},
+                           new Address[]{Util.createRandomAddress(""new-1""), Util.createRandomAddress(""new-2"")});
+        _testSize(view, DeltaView.class);
+    }
+
 
     public static void testMergeView() throws Exception {
         ViewId vid=new ViewId(UUID.randomUUID(), 322649);
@@ -887,10 +918,18 @@ private static void _testSize(MergeId id) throws Exception {
     }
 
     private static void _testSize(View v) throws Exception {
+        _testSize(v, View.class);
+    }
+
+    private static void _testSize(View v, Class<? extends Streamable> view_class) throws Exception {
         long size=v.serializedSize();
         byte[] serialized_form=Util.streamableToByteBuffer(v);
         System.out.println(""size="" + size + "", serialized size="" + serialized_form.length);
         Assert.assertEquals(serialized_form.length, size);
+
+        View view=(View)Util.streamableFromByteBuffer(view_class,serialized_form);
+        System.out.println(""old view: "" + v + ""\nnew view: "" + view);
+        Assert.assertEquals(view, v);
     }
 
     private static void _testSize(Collection<Address> coll) throws Exception {",2013-09-16T11:44:49Z,103
"@@ -80,7 +80,7 @@ private void markReadyToDeliverV2(MessageID messageID, long finalSequenceNumber)
             }
 
             if (deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notifyAll();
+                deliverySet.notify();
             }
         }
     }
@@ -97,7 +97,7 @@ public final void removeLeavers(Collection<Address> leavers) {
 
             deliverySet.removeAll(toRemove);
             if (!deliverySet.isEmpty() && deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notifyAll();
+                deliverySet.notify();
             }
         }
         for (MessageInfo removed : toRemove) {
@@ -151,7 +151,7 @@ public void deliverSingleDestinationMessage(Message msg, MessageID messageID) {
             messageInfo.updateAndmarkReadyToDeliver(sequenceNumber);
             deliverySet.add(messageInfo);
             if (deliverySet.first().isReadyToDeliver()) {
-                deliverySet.notifyAll();
+                deliverySet.notify();
             }
         }
     }",2016-02-05T10:56:11Z,94
"@@ -66,6 +66,7 @@
     <class id=""69"" name=""org.jgroups.protocols.GOOGLE_PING""/>
     <class id=""70"" name=""org.jgroups.protocols.SEQUENCER2""/>
     <class id=""71"" name=""org.jgroups.protocols.MERGE2""/>
+    <class id=""72"" name=""org.jgroups.protocols.FD_PING2""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2014-06-23T09:14:41Z,104
"@@ -0,0 +1,477 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.PhysicalAddress;
+import org.jgroups.View;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.IpAddress;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.InetAddress;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Failure detection protocol which detects the crash or hanging of entire hosts and suspects all cluster members
+ * on those hosts. This protocol would typically be used when multiple cluster members are running on the same box.
+ * <p/>
+ * JIRA:  https://issues.jboss.org/browse/JGRP-1855
+ * @author  Bela Ban
+ * @version 3.5
+ */
+@MBean(description=""Failure detection protocol which detects crashes or hangs of entire hosts and suspects "" +
+  ""all cluster members on those hosts"")
+public class FD_PING2 extends Protocol {
+
+    @Property(description=""The command used to check a given host for liveness. Example: \""ping\"". "" +
+      ""If null, InetAddress.isReachable() will be used by default"")
+    protected String                                     cmd=null;
+
+    @Property(description=""Max time (in ms) after which a host is suspected if it failed all liveness checks"")
+    protected long                                       timeout=60000;
+
+    @Property(description=""The interval (in ms) at which the hosts are checked for liveness"")
+    protected long                                       interval=20000;
+
+    @Property(description=""Max time (in ms) that a liveness check for a single host can take"")
+    protected long                                       check_timeout=3000;
+
+    @Property(description=""Uses TimeService to get the current time rather than System.currentTimeMillis. Might get "" +
+      ""removed soon, don't use !"")
+    protected boolean                                    use_time_service=true;
+
+    @ManagedAttribute(description=""Number of liveness checks"")
+    protected int                                        num_liveness_checks;
+
+    @ManagedAttribute(description=""Number of suspected events received"")
+    protected int                                        num_suspect_events;
+
+    protected final Set<Address>                         suspected_mbrs=new HashSet<Address>();
+
+    @ManagedAttribute(description=""Shows whether there are currently any suspected members"")
+    protected volatile boolean                           has_suspected_mbrs;
+
+    protected final BoundedList<Tuple<InetAddress,Long>> suspect_history=new BoundedList<Tuple<InetAddress,Long>>(20);
+
+    protected Address                                    local_addr;
+    protected InetAddress                                local_host;
+    protected final List<Address>                        members=new ArrayList<Address>();
+
+    /** The command to detect whether a target is alive */
+    protected PingCommand                                ping_command=new IsReachablePingCommand();
+
+    /** Map of hosts and their cluster members, updated on view changes. Used to suspect all members
+     of a suspected host */
+    protected final Map<InetAddress,List<Address>>       hosts=new HashMap<InetAddress,List<Address>>();
+
+    // Map of hosts and timestamps of last updates
+    protected final Map<InetAddress, Long>               timestamps=new ConcurrentHashMap<InetAddress,Long>();
+
+    /** Timer used to run the ping task on */
+    protected TimeScheduler                              timer;
+
+    protected TimeService                                time_service;
+
+    protected Future<?>                                  ping_task_future;
+
+
+
+    public FD_PING2 pingCommand(PingCommand cmd) {this.ping_command=cmd; return this;}
+
+    public void resetStats() {
+        num_suspect_events=num_liveness_checks=0;
+        suspect_history.clear();
+    }
+
+    public void setCommand(String command) {
+        this.cmd=command;
+        ping_command=this.cmd != null? new ExternalPingCommand(cmd) : new IsReachablePingCommand();
+    }
+
+    @ManagedOperation(description=""Prints history of suspected hosts"")
+    public String printSuspectHistory() {
+        StringBuilder sb=new StringBuilder();
+        for(Tuple<InetAddress,Long> tmp: suspect_history) {
+            sb.append(new Date(tmp.getVal2())).append("": "").append(tmp.getVal1()).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+    @ManagedOperation(description=""Prints timestamps"")
+    public String printTimestamps() {
+        return _printTimestamps();
+    }
+
+    @ManagedAttribute(description=""Whether the ping task is running"")
+    public boolean isPingerRunning() {
+        Future<?> future=ping_task_future;
+        return future != null && !future.isDone();
+    }
+
+    @ManagedOperation(description=""Prints the hosts and their associated cluster members"")
+    public String printHosts() {
+        StringBuilder sb=new StringBuilder();
+        synchronized(hosts) {
+            for(Map.Entry<InetAddress,List<Address>> entry: hosts.entrySet()) {
+                sb.append(entry.getKey()).append("": "").append(entry.getValue()).append(""\n"");
+            }
+        }
+        return sb.toString();
+    }
+
+    @ManagedOperation(description=""Checks whether the given host is alive"")
+    public boolean isAlive(String host) throws Exception {
+        return ping_command != null && ping_command.isAlive(InetAddress.getByName(host), check_timeout);
+    }
+
+    @ManagedAttribute(description=""Currently suspected members"")
+    public String getSuspectedMembers() {return suspected_mbrs.toString();}
+
+    public void init() throws Exception {
+        if(interval >= timeout)
+            throw new IllegalArgumentException(""interval ("" + interval + "") has to be less than timeout ("" + timeout + "")"");
+        super.init();
+        if(cmd != null)
+            ping_command=new ExternalPingCommand(cmd);
+        timer=getTransport().getTimer();
+        if(timer == null)
+            throw new Exception(""timer not set"");
+        time_service=getTransport().getTimeService();
+        if(time_service == null)
+            log.warn(""%s: time service is not available, using System.currentTimeMillis() instead"", local_addr);
+        else {
+            if(time_service.interval() > timeout) {
+                log.warn(""%s: interval of time service (%d) is greater than timeout (%d), disabling time service"",
+                         local_addr, time_service.interval(), timeout);
+                use_time_service=false;
+            }
+        }
+        suspected_mbrs.clear();
+        has_suspected_mbrs=false;
+    }
+
+    public void stop() {
+        super.stop();
+        stopPingerTask();
+        suspected_mbrs.clear();
+        has_suspected_mbrs=false;
+    }
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                View view=(View)evt.getArg();
+                handleView(view);
+                break;
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=(Address)evt.getArg();
+                break;
+            case Event.CONNECT:
+            case Event.CONNECT_USE_FLUSH:
+            case Event.CONNECT_WITH_STATE_TRANSFER:
+            case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:
+                local_host=getHostFor(local_addr);
+                break;
+            case Event.DISCONNECT:
+                Object retval=down_prot.down(evt);
+                local_host=null;
+                return retval;
+
+            case Event.UNSUSPECT:
+                Address mbr=(Address)evt.getArg();
+                unsuspect(mbr);
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    protected void handleView(View view) {
+        List<Address> view_mbrs=view.getMembers();
+        boolean is_pinger=false;
+        members.clear();
+        members.addAll(view_mbrs);
+        synchronized(hosts) {
+            hosts.clear();
+            for(Address mbr: view) {
+                InetAddress key=getHostFor(mbr);
+                if(key == null)
+                    continue;
+                List<Address> mbrs=hosts.get(key);
+                if(mbrs == null)
+                    hosts.put(key, mbrs=new ArrayList<Address>());
+                mbrs.add(mbr);
+            }
+            is_pinger=isPinger(local_addr);
+        }
+
+        if(suspected_mbrs.retainAll(view.getMembers()))
+            has_suspected_mbrs=!suspected_mbrs.isEmpty();
+
+        timestamps.keySet().removeAll(hosts.keySet());
+
+        if(is_pinger)
+            startPingerTask();
+        else
+            stopPingerTask();
+    }
+
+
+    protected PhysicalAddress getPhysicalAddress(Address logical_addr) {
+        return (PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, logical_addr));
+    }
+
+    protected InetAddress getHostFor(Address mbr) {
+        PhysicalAddress phys_addr=getPhysicalAddress(mbr);
+        return phys_addr instanceof IpAddress? ((IpAddress)phys_addr).getIpAddress() : null;
+    }
+
+    protected boolean isPinger(Address mbr) {
+        InetAddress host=getHostFor(mbr);
+        if(host == null) return false; // should not happen
+        List<Address> mbrs=hosts.get(host);
+        return mbrs != null && !mbrs.isEmpty() && mbrs.get(0).equals(mbr);
+    }
+
+    protected void startPingerTask() {
+        if(ping_task_future == null || ping_task_future.isDone())
+            ping_task_future=timer.scheduleAtFixedRate(new PingTask(), interval, interval, TimeUnit.MILLISECONDS);
+    }
+
+    protected void stopPingerTask() {
+        if(ping_task_future != null) {
+            ping_task_future.cancel(false);
+            ping_task_future=null;
+        }
+    }
+
+    /** Called by ping task; will result in all members of host getting suspected */
+    protected void suspect(InetAddress host) {
+        List<Address> suspects;
+        suspect_history.add(new Tuple<InetAddress,Long>(host, getTimestamp()));
+        synchronized(hosts) {
+            List<Address> tmp=hosts.get(host);
+            suspects=tmp != null? new ArrayList<Address>(tmp) : null;
+        }
+        if(suspects != null) {
+            log.debug(""%s: suspecting host %s; suspected members: %s"", local_addr, host, Util.printListWithDelimiter(suspects, "",""));
+            suspect(suspects);
+        }
+    }
+
+
+    protected void suspect(List<Address> suspects) {
+        if(suspects == null || suspects.isEmpty())
+            return;
+
+        num_suspect_events+=suspects.size();
+
+        final List<Address> eligible_mbrs=new ArrayList<Address>();
+        synchronized(this) {
+            suspected_mbrs.addAll(suspects);
+            eligible_mbrs.addAll(members);
+            eligible_mbrs.removeAll(suspected_mbrs);
+            has_suspected_mbrs=!suspected_mbrs.isEmpty();
+        }
+
+        // Check if we're coord, then send up the stack
+        if(local_addr != null && !eligible_mbrs.isEmpty()) {
+            Address first=eligible_mbrs.get(0);
+            if(local_addr.equals(first)) {
+                log.debug(""%s: suspecting %s"", local_addr, suspected_mbrs);
+                for(Address suspect: suspects) {
+                    up_prot.up(new Event(Event.SUSPECT, suspect));
+                    down_prot.down(new Event(Event.SUSPECT, suspect));
+                }
+            }
+        }
+    }
+
+   /* protected void unsuspect(InetAddress host) {
+        List<Address> suspects;
+        synchronized(hosts) {
+            List<Address> tmp=hosts.get(host);
+            suspects=tmp != null? new ArrayList<Address>(tmp) : null;
+        }
+        if(suspects != null) {
+            log.debug(""%s: unsuspecting host %s; unsuspected members: %s"", local_addr, host, Util.printListWithDelimiter(suspects, "",""));
+            for(Address unsuspect: suspects)
+                unsuspect(unsuspect);
+        }
+    }*/
+
+    protected boolean unsuspect(Address mbr) {
+        if(mbr == null) return false;
+        boolean do_unsuspect;
+        synchronized(this) {
+            do_unsuspect=!suspected_mbrs.isEmpty() && suspected_mbrs.remove(mbr);
+            if(do_unsuspect)
+                has_suspected_mbrs=!suspected_mbrs.isEmpty();
+        }
+        if(do_unsuspect) {
+            up_prot.up(new Event(Event.UNSUSPECT, mbr));
+            down_prot.down(new Event(Event.UNSUSPECT, mbr));
+        }
+        return do_unsuspect;
+    }
+
+
+    protected String _printTimestamps() {
+        StringBuilder sb=new StringBuilder();
+        long current_time=getTimestamp();
+        for(Map.Entry<InetAddress,Long> entry: timestamps.entrySet()) {
+            sb.append(entry.getKey()).append("": "");
+            sb.append((current_time - entry.getValue())/1000).append("" secs old\n"");
+        }
+        return sb.toString();
+    }
+
+    protected void updateTimestampFor(InetAddress host) {
+        timestamps.put(host, getTimestamp());
+    }
+
+    protected long getAgeOf(InetAddress host) {
+        Long ts=timestamps.get(host);
+        return ts != null? getTimestamp() - ts : -1;
+    }
+
+    protected long getTimestamp() {
+        return use_time_service && time_service != null? time_service.timestamp() : System.currentTimeMillis();
+    }
+
+
+
+
+
+
+    /** Selected members run this task periodically. The task pings all hosts except self using ping_command.
+     * When a host is not seen as alive, all members associated with that host are suspected */
+    protected class PingTask implements Runnable {
+
+        public void run() {
+            List<InetAddress> targets;
+            synchronized(hosts) {
+                targets=new ArrayList<InetAddress>(hosts.keySet());
+            }
+            targets.remove(local_host);
+
+            // 1. Ping each host
+            for(InetAddress target: targets) {
+                try {
+                    boolean is_alive=ping_command.isAlive(target, check_timeout);
+                    num_liveness_checks++;
+                    if(is_alive)
+                        updateTimestampFor(target);
+                    else
+                        log.trace(""%s: %s is not alive (age=%d secs)"", local_addr, target, getAgeOf(target) / 1000);
+                }
+                catch(Exception e) {
+                    log.error(""%s: ping command failed: %s"", local_addr, e);
+                }
+            }
+
+            // 2. Check timestamps
+            long current_time=getTimestamp();
+            for(Map.Entry<InetAddress,Long> entry: timestamps.entrySet()) {
+                InetAddress host=entry.getKey();
+                long timestamp=entry.getValue();
+                if(current_time - timestamp >= timeout)
+                    suspect(host);
+            }
+        }
+    }
+
+
+    /** Command used to check whether a given host is alive, periodically called */
+    public interface PingCommand {
+        /**
+         * Checks whether a given host is alive
+         * @param host The host to be checked for liveness
+         * @param timeout Number of milliseconds to wait for the check to complete
+         * @return true if the host is alive, else false
+         */
+        boolean isAlive(InetAddress host, long timeout) throws Exception;
+    }
+
+
+    public static class IsReachablePingCommand implements PingCommand {
+        public boolean isAlive(InetAddress host, long timeout) throws Exception {
+            return host.isReachable((int)timeout);
+        }
+    }
+
+    protected static class ExternalPingCommand implements PingCommand {
+        protected final String cmd;
+
+        public ExternalPingCommand(String cmd) {
+            this.cmd=cmd;
+        }
+
+        public boolean isAlive(InetAddress host, long timeout) throws Exception {
+            return CommandExecutor2.execute(cmd + "" "" + host.getHostAddress()) == 0;
+        }
+    }
+
+    public static class CommandExecutor {
+
+        public static int execute(String command) throws Exception {
+            Process p=Runtime.getRuntime().exec(command);
+            InputStream in=p.getInputStream(), err=p.getErrorStream();
+            try {
+                Reader in_reader, err_reader;
+                in_reader=new Reader(in);
+                err_reader=new Reader(err);
+                in_reader.start();
+                err_reader.start();
+                in_reader.join();
+                err_reader.join();
+                return p.exitValue();
+            }
+            finally {
+                Util.close(in);
+                Util.close(err);
+            }
+        }
+
+
+        static class Reader extends Thread {
+            InputStreamReader in;
+
+            Reader(InputStream in) {
+                this.in=new InputStreamReader(in);
+            }
+
+            public void run() {
+                int c;
+                while(true) {
+                    try {
+                        c=in.read();
+                        if(c == -1)
+                            break;
+                        // System.out.print((char)c);
+                    }
+                    catch(IOException e) {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    public static class CommandExecutor2 {
+        public static int execute(String command) throws Exception {
+            Process p=Runtime.getRuntime().exec(command);
+            return p.waitFor();
+        }
+    }
+}",2014-06-23T09:14:41Z,105
"@@ -0,0 +1,771 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.annotations.*;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.BoundedList;
+import org.jgroups.util.Util;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: FlowControl.java,v 1.1 2010/08/31 12:21:55 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public abstract class FlowControl extends Protocol {
+
+    protected final static FcHeader REPLENISH_HDR=new FcHeader(FcHeader.REPLENISH);
+    protected final static FcHeader CREDIT_REQUEST_HDR=new FcHeader(FcHeader.CREDIT_REQUEST);  
+
+    
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    
+    /**
+     * Max number of bytes to send per receiver until an ack must be received before continuing sending
+     */
+    @Property(description=""Max number of bytes to send per receiver until an ack must be received to proceed. Default is 500000 bytes"")
+    protected long max_credits=500000;
+
+    /**
+     * Max time (in milliseconds) to block. If credit hasn't been received after max_block_time, we send
+     * a REPLENISHMENT request to the members from which we expect credits. A value <= 0 means to wait forever.
+     */
+    @Property(description=""Max time (in milliseconds) to block. Default is 5000 msec"")
+    protected long max_block_time=5000;
+
+    /**
+     * Defines the max number of milliseconds for a message to block before being sent, based on the length of
+     * the message. The property is defined as a comma-separated list of values (separated by ':'), where the key
+     * is the size in bytes and the value is the number of milliseconds to block.
+     * Example: max_block_times=""50:1,500:3,1500:5,10000:10,100000:100"". This means that messages up to 50 bytes wait
+     * 1 ms max until they get sent, messages up to 500 bytes 3 ms, and so on.
+     * If a message's length (size of the payload in bytes) is for example 15'000 bytes,
+     * FlowControl blocks it for a max of 100 ms.
+     */
+    protected Map<Long,Long> max_block_times=null;
+
+    /** Keeps track of the end time after which a message should not get blocked anymore */
+    protected static final ThreadLocal<Long> end_time=new ThreadLocal<Long>();
+
+
+    /**
+     * If we've received (min_threshold * max_credits) bytes from P, we send more credits to P. Example: if
+     * max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits to P once we've
+     * received 250'000 bytes from P. 
+     */
+    @Property(description=""The threshold (as a percentage of max_credits) at which a receiver sends more credits to "" +
+            ""a sender. Example: if max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits "" +
+            ""to P once we've received 250'000 bytes from P"")
+    protected double min_threshold=0.60;
+
+    /**
+     * Computed as <tt>max_credits</tt> times <tt>min_theshold</tt>. If explicitly set, this will
+     * override the above computation
+     */
+    @Property(description=""Computed as max_credits x min_theshold unless explicitly set"")
+    protected long min_credits=0;
+    
+    /**
+     * Whether an up thread that comes back down should be allowed to
+     * bypass blocking if all credits are exhausted. Avoids JGRP-465.
+     * Set to false by default in 2.5 because we have OOB messages for credit replenishments - this flag should not be set
+     * to true if the concurrent stack is used
+     */
+    @Property(description=""Does not block a down message if it is a result of handling an up message in the"" +
+            ""same thread. Fixes JGRP-928"")
+    protected boolean ignore_synchronous_response=true;
+    
+    
+    
+    
+    /* ---------------------------------------------   JMX      ------------------------------------------------------ */
+    
+    
+    protected int num_blockings=0;
+    protected int num_credit_requests_received=0, num_credit_requests_sent=0;
+    protected int num_credit_responses_sent=0, num_credit_responses_received=0;
+    protected long total_time_blocking=0;
+
+    protected final BoundedList<Long> last_blockings=new BoundedList<Long>(50);
+    
+    
+    
+    /* --------------------------------------------- Fields ------------------------------------------------------ */
+    
+    
+    /**
+     * Map<Address,Long>: keys are members, values are credits left. For each send, the
+     * number of credits is decremented by the message size. A HashMap rather than a ConcurrentHashMap is
+     * currently used as there might be null values
+     */
+    @GuardedBy(""lock"")
+    protected final Map<Address,Credit> sent=new ConcurrentHashMap<Address,Credit>(11);
+
+    /**
+     * Keeps track of credits / member at the receiver's side. Keys are members, values are credits left (in bytes).
+     * For each receive, the credits for the sender are decremented by the size of the received message.
+     * When the credits fall below the threshold, we refill and send a REPLENISH message to the sender.
+     * The sender blocks until REPLENISH message is received.
+     */
+    protected final Map<Address,Credit> received=new ConcurrentHashMap<Address,Credit>(11);
+
+
+  
+    
+    /** Peers who have asked for credit that we didn't have */
+    protected final Set<Address> pending_requesters=new HashSet<Address>(11);
+
+    /**
+     * Whether FlowControl is still running, this is set to false when the protocol terminates (on stop())
+     */
+    protected volatile boolean running=true;
+
+
+    protected boolean frag_size_received=false;
+
+   
+
+    /** Lock protecting sent credits table and some other vars (creditors for example) */
+    // protected final Lock lock=new ReentrantLock();
+
+
+
+    /**
+     * Thread that carries messages through up() and shouldn't be blocked
+     * in down() if ignore_synchronous_response==true. JGRP-465.
+     */
+    protected final ThreadLocal<Boolean> ignore_thread=new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return false;
+        }
+    };   
+
+    /** Last time a credit request was sent. Used to prevent credit request storms */
+    @GuardedBy(""lock"")
+    protected long last_credit_request=0;   
+
+    public void resetStats() {
+        super.resetStats();
+        num_blockings=0;
+        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;
+        total_time_blocking=0;
+        last_blockings.clear();
+    }
+
+    public long getMaxCredits() {
+        return max_credits;
+    }
+
+    public void setMaxCredits(long max_credits) {
+        this.max_credits=max_credits;
+    }
+
+    public double getMinThreshold() {
+        return min_threshold;
+    }
+
+    public void setMinThreshold(double min_threshold) {
+        this.min_threshold=min_threshold;
+    }
+
+    public long getMinCredits() {
+        return min_credits;
+    }
+
+    public void setMinCredits(long min_credits) {
+        this.min_credits=min_credits;
+    }
+
+    @ManagedAttribute(description=""Number of times flow control blocks sender"")
+    public int getNumberOfBlockings() {
+        return num_blockings;
+    }
+
+    public long getMaxBlockTime() {
+        return max_block_time;
+    }
+
+    public void setMaxBlockTime(long t) {
+        max_block_time=t;
+    }
+
+    @Property(description=""Max times to block for the listed messages sizes (Message.getLength()). Example: \""1000:10,5000:30,10000:500\"""")
+    public void setMaxBlockTimes(String str) {
+        if(str == null) return;
+        Long prev_key=null, prev_val=null;
+        List<String> vals=Util.parseCommaDelimitedStrings(str);
+        if(max_block_times == null)
+            max_block_times=new TreeMap<Long,Long>();
+        for(String tmp: vals) {
+            int index=tmp.indexOf(':');
+            if(index == -1)
+                throw new IllegalArgumentException(""element '"" + tmp + ""'  is missing a ':' separator"");
+            Long key=Long.parseLong(tmp.substring(0, index).trim());
+            Long val=Long.parseLong(tmp.substring(index +1).trim());
+
+            // sanity checks:
+            if(key < 0 || val < 0)
+                throw new IllegalArgumentException(""keys and values must be >= 0"");
+
+            if(prev_key != null) {
+                if(key <= prev_key)
+                    throw new IllegalArgumentException(""keys are not sorted: "" + vals);
+            }
+            prev_key=key;
+
+            if(prev_val != null) {
+                if(val <= prev_val)
+                    throw new IllegalArgumentException(""values are not sorted: "" + vals);
+            }
+            prev_val=val;
+            max_block_times.put(key, val);
+        }
+        if(log.isDebugEnabled())
+            log.debug(""max_block_times: "" + max_block_times);
+    }
+
+    public String getMaxBlockTimes() {
+        if(max_block_times == null) return ""n/a"";
+        StringBuilder sb=new StringBuilder();
+        boolean first=true;
+        for(Map.Entry<Long,Long> entry: max_block_times.entrySet()) {
+            if(!first) {
+                sb.append("", "");
+            }
+            else {
+                first=false;
+            }
+            sb.append(entry.getKey()).append("":"").append(entry.getValue());
+        }
+        return sb.toString();
+    }
+    
+    @ManagedAttribute(description=""Total time (ms) spent in flow control block"")
+    public long getTotalTimeBlocked() {
+        return total_time_blocking;
+    }
+
+    @ManagedAttribute(description=""Average time spent in a flow control block"")
+    public double getAverageTimeBlocked() {
+        return num_blockings == 0? 0.0 : total_time_blocking / (double)num_blockings;
+    }
+
+    @ManagedAttribute(description=""Number of credit requests received"")
+    public int getNumberOfCreditRequestsReceived() {
+        return num_credit_requests_received;
+    }
+    
+    @ManagedAttribute(description=""Number of credit requests sent"")
+    public int getNumberOfCreditRequestsSent() {
+        return num_credit_requests_sent;
+    }
+
+    @ManagedAttribute(description=""Number of credit responses received"")
+    public int getNumberOfCreditResponsesReceived() {
+        return num_credit_responses_received;
+    }
+
+    @ManagedAttribute(description=""Number of credit responses sent"")
+    public int getNumberOfCreditResponsesSent() {
+        return num_credit_responses_sent;
+    }
+
+    @ManagedOperation(description=""Print sender credits"")
+    public String printSenderCredits() {
+        return printMap(sent);
+    }
+
+    @ManagedOperation(description=""Print receiver credits"")
+    public String printReceiverCredits() {
+        return printMap(received);
+    }
+
+    @ManagedOperation(description=""Print credits"")
+    public String printCredits() {
+        StringBuilder sb=new StringBuilder();
+        sb.append(""senders:\n"").append(printMap(sent)).append(""\n\nreceivers:\n"").append(printMap(received));
+        return sb.toString();
+    }
+
+    public Map<String, Object> dumpStats() {
+        Map<String, Object> retval=super.dumpStats();      
+        retval.put(""senders"", printMap(sent));
+        retval.put(""receivers"", printMap(received));
+        return retval;
+    }
+
+    @ManagedOperation(description=""Print last blocking times"")
+    public String showLastBlockingTimes() {
+        return last_blockings.toString();
+    }
+
+
+    protected long getMaxBlockTime(long length) {
+        if(max_block_times == null)
+            return 0;
+        Long retval=null;
+        for(Map.Entry<Long,Long> entry: max_block_times.entrySet()) {
+            retval=entry.getValue();
+            if(length <= entry.getKey())
+                break;
+        }
+
+        return retval != null? retval : 0;
+    }
+
+
+    /**
+     * Whether the protocol handles message with dest == null || dest.isMulticastAddress()
+     * @return
+     */
+    protected abstract boolean handleMulticastMessage();
+
+    protected abstract Credit createCredit(long credits);
+
+    protected abstract void handleCredit(Address sender, Number increase);
+
+
+    /**
+     * Allows to unblock a blocked sender from an external program, e.g. JMX
+     */
+    @ManagedOperation(description=""Unblock a sender"")
+    public void unblock() {
+        ;
+    }
+
+    public void init() throws Exception {
+        boolean min_credits_set = min_credits != 0;
+        if(!min_credits_set)
+            min_credits=(long)(max_credits * min_threshold);
+    }
+
+    public void start() throws Exception {
+        super.start();
+        if(!frag_size_received) {
+            log.warn(""No fragmentation protocol was found. When flow control is used, we recommend "" +
+                    ""a fragmentation protocol, due to http://jira.jboss.com/jira/browse/JGRP-590"");
+        }
+
+        running=true;
+
+    }
+
+    public void stop() {
+        super.stop();
+        running=false;
+        ignore_thread.set(false);
+    }
+
+
+    @SuppressWarnings(""unchecked"")
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                Address dest=msg.getDest();
+                boolean multicast=dest == null || dest.isMulticastAddress();
+                boolean handle_multicasts=handleMulticastMessage();
+                boolean process=(handle_multicasts && multicast) || (!handle_multicasts && !multicast);
+                if(!process)
+                    break;
+
+                if(msg.isFlagSet(Message.NO_FC))
+                    break;
+                int length=msg.getLength();
+                if(length == 0)
+                    break;
+                return handleDownMessage(evt, msg, length);
+            case Event.CONFIG:
+                handleConfigEvent((Map<String,Object>)evt.getArg()); 
+                break;
+            case Event.VIEW_CHANGE:
+                handleViewChange(((View)evt.getArg()).getMembers());
+                break;
+        }
+        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block
+    }
+
+
+    @SuppressWarnings(""unchecked"")
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+
+            case Event.MSG:
+
+                // JGRP-465. We only deal with msgs to avoid having to use a concurrent collection; ignore views,
+                // suspicions, etc which can come up on unusual threads.
+                Message msg=(Message)evt.getArg();
+                Address dest=msg.getDest();
+                boolean multicast=dest == null || dest.isMulticastAddress();
+                boolean handle_multicasts=handleMulticastMessage();
+                boolean process=(handle_multicasts && multicast) || (!handle_multicasts && !multicast);
+                if(!process)
+                    break;
+
+                if(msg.isFlagSet(Message.NO_FC))
+                    break;
+                
+                FcHeader hdr=(FcHeader)msg.getHeader(this.id);
+                if(hdr != null) {
+                    switch(hdr.type) {
+                        case FcHeader.REPLENISH:
+                            num_credit_responses_received++;
+                            handleCredit(msg.getSrc(), (Number)msg.getObject());
+                            break;
+                        case FcHeader.CREDIT_REQUEST:
+                            num_credit_requests_received++;
+                            Address sender=msg.getSrc();
+                            Long sent_credits=(Long)msg.getObject();
+                            if(sent_credits != null)
+                                handleCreditRequest(received, sender, sent_credits.longValue());
+                            break;
+                        default:
+                            log.error(""header type "" + hdr.type + "" not known"");
+                            break;
+                    }
+                    return null; // don't pass message up
+                }
+
+                Address sender=msg.getSrc();
+                long new_credits=adjustCredit(received, sender, msg.getLength());
+                
+                // JGRP-928: changed ignore_thread to a ThreadLocal: multiple threads can access it with the
+                // introduction of the concurrent stack
+                if(ignore_synchronous_response)
+                    ignore_thread.set(true);
+                try {
+                    return up_prot.up(evt);
+                }
+                finally {
+                    if(ignore_synchronous_response)
+                        ignore_thread.set(false); // need to revert because the thread is placed back into the pool
+                    if(new_credits > 0) {
+                        if(log.isTraceEnabled()) log.trace(""sending "" + new_credits + "" credits to "" + sender);
+                        sendCredit(sender, new_credits);
+                    }
+                }
+
+            case Event.VIEW_CHANGE:
+                handleViewChange(((View)evt.getArg()).getMembers());
+                break;
+
+            case Event.CONFIG:
+                Map<String,Object> map=(Map<String,Object>)evt.getArg();
+                handleConfigEvent(map);
+                break;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    protected void handleConfigEvent(Map<String,Object> info) {
+        if(info != null) {
+            Integer frag_size=(Integer)info.get(""frag_size"");
+            if(frag_size != null) {
+                if(frag_size > max_credits) {
+                    log.warn(""The fragmentation size of the fragmentation protocol is "" + frag_size +
+                            "", which is greater than the max credits. While this is not incorrect, "" +
+                            ""it may lead to long blockings. Frag size should be less than max_credits "" +
+                            ""(http://jira.jboss.com/jira/browse/JGRP-590)"");
+                }
+                frag_size_received=true;
+            }
+        }
+    }
+
+    
+    protected abstract Object handleDownMessage(final Event evt, final Message msg, int length);
+
+
+
+
+
+
+    /**
+     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast
+     * or unicast message. No need to acquire mutex (must already be held when this method is called)
+     * @param dest
+     * @param credits
+     * @return The lowest number of credits left, or -1 if a unicast member was not found
+     */
+    protected long decrementCredit(Map<Address,Credit> map, Address dest, long credits) {
+        if(dest == null || dest.isMulticastAddress()) {
+            if(map.isEmpty())
+                return -1;
+            long lowest=max_credits;
+            for(Credit cred: map.values())
+                lowest=Math.min(cred.decrement(credits), lowest);
+            return lowest;
+        }
+        else {
+            Credit cred=map.get(dest);
+            if(cred != null)
+                return cred.decrement(credits);
+            }
+        return -1;
+    }
+
+
+
+
+   
+
+
+    /**
+     * Check whether sender has enough credits left. If not, send it some more
+     * @param map The hashmap to use
+     * @param sender The address of the sender
+     * @param length The number of bytes received by this message. We don't care about the size of the headers for
+     * the purpose of flow control
+     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise
+     */
+    protected long adjustCredit(Map<Address,Credit> map, Address sender, int length) {
+        if(sender == null || length == 0)
+            return 0;
+
+        Credit cred=map.get(sender);
+        if(cred == null)
+            return 0;
+
+        if(log.isTraceEnabled())
+            log.trace(""sender "" + sender + "" minus "" + length + "" credits, "" + (cred.get() - length) + "" remaining"");
+
+        return cred.decrementAndGet(length);
+    }
+
+    /**
+     * @param map The map to modify
+     * @param sender The sender who requests credits
+     * @param left_credits Number of bytes that the sender has left to send messages to us
+     */
+    protected void handleCreditRequest(Map<Address,Credit> map, Address sender, long left_credits) {
+        if(sender == null) return;
+        long credit_response=0;
+        Credit cred=map.get(sender);
+
+        long old_credit=cred != null? cred.get() : 0;
+        if(old_credit > 0)
+            credit_response=Math.min(max_credits, max_credits - old_credit);
+
+        if(credit_response > 0) {
+            if(log.isTraceEnabled())
+                log.trace(""received credit request from "" + sender + "": sending "" + credit_response + "" credits"");
+            if(cred != null)
+                cred.set(max_credits);
+            else
+                map.put(sender, createCredit(max_credits));
+            pending_requesters.remove(sender);
+        }
+        else {
+            if(pending_requesters.contains(sender)) {
+                // a sender might have negative credits, e.g. -20000. If we subtracted -20000 from max_credits,
+                // we'd end up with max_credits + 20000, and send too many credits back. So if the sender's
+                // credits is negative, we simply send max_credits back
+                long credits_left=Math.max(0, left_credits);
+                credit_response=max_credits - credits_left;
+                // credit_response = max_credits;
+                if(cred != null)
+                    cred.set(max_credits);
+                else
+                    map.put(sender, createCredit(max_credits));
+                pending_requesters.remove(sender);
+                if(log.isWarnEnabled())
+                    log.warn(""Received two credit requests from "" + sender +
+                            "" without any intervening messages; sending "" + credit_response + "" credits"");
+            }
+            else {
+                pending_requesters.add(sender);
+                if(log.isTraceEnabled())
+                    log.trace(""received credit request from "" + sender + "" but have no credits available"");
+            }
+        }
+
+
+        if(credit_response > 0)
+            sendCredit(sender, credit_response);
+    }
+
+
+    protected void sendCredit(Address dest, long credit) {
+        if(log.isTraceEnabled())
+            log.trace(""replenishing "" + dest + "" with "" + credit	+ "" credits"");
+        Number number;
+        if(credit < Integer.MAX_VALUE)
+            number=(int)credit;
+        else
+            number=credit;
+        Message msg=new Message(dest, null, number);
+        msg.setFlag(Message.OOB);
+        msg.putHeader(this.id, REPLENISH_HDR);
+        down_prot.down(new Event(Event.MSG, msg));
+        num_credit_responses_sent++;
+    }
+
+    /**
+     * We cannot send this request as OOB messages, as the credit request needs to queue up behind the regular messages;
+     * if a receiver cannot process the regular messages, that is a sign that the sender should be throttled !
+     * @param dest The member to which we send the credit request
+     * @param credits_left The number of bytes (of credits) left for dest
+     */
+    protected void sendCreditRequest(final Address dest, Long credits_left) {
+        if(log.isTraceEnabled())
+            log.trace(""sending credit request to "" + dest);
+        Message msg=new Message(dest, null, credits_left);
+        msg.putHeader(this.id, CREDIT_REQUEST_HDR);
+        down_prot.down(new Event(Event.MSG, msg));
+        num_credit_requests_sent++;
+    }
+
+
+    protected void handleViewChange(Vector<Address> mbrs) {
+        Address addr;
+        if(mbrs == null) return;
+        if(log.isTraceEnabled()) log.trace(""new membership: "" + mbrs);
+
+
+        // add members not in membership to received and sent hashmap (with full credits)
+        for(int i=0; i < mbrs.size(); i++) {
+            addr=mbrs.elementAt(i);
+            if(!received.containsKey(addr))
+                received.put(addr, createCredit(max_credits));
+            if(!sent.containsKey(addr))
+                sent.put(addr, createCredit(max_credits));
+        }
+        // remove members that left
+        for(Iterator<Address> it=received.keySet().iterator(); it.hasNext();) {
+            addr=it.next();
+            if(!mbrs.contains(addr))
+                it.remove();
+        }
+
+        // remove members that left
+        for(Iterator<Address> it=sent.keySet().iterator(); it.hasNext();) {
+            addr=it.next();
+            if(!mbrs.contains(addr))
+                it.remove(); // modified the underlying map
+        }
+
+      
+    }
+
+    protected static long computeLowestCredit(Map<Address,Credit> m) {
+        Collection<Credit> credits=m.values();
+        return Collections.min(credits).get();
+    }
+
+    protected static String printMap(Map<Address,Credit> m) {
+        StringBuilder sb=new StringBuilder();
+        for(Map.Entry<Address,Credit> entry: m.entrySet()) {
+            sb.append(entry.getKey()).append("": "").append(entry.getValue()).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+
+
+    protected abstract class Credit implements Comparable {
+        protected long credits_left;
+
+        protected Credit(long credits) {
+            this.credits_left=credits;
+        }
+
+        protected synchronized long decrementAndGet(long credits) {
+            credits_left=Math.max(0, credits_left - credits);
+            long credit_response=max_credits - credits_left;
+            if(credit_response >= min_credits) {
+                credits_left=max_credits;
+                return credit_response;
+            }
+            return 0;
+        }
+
+        protected synchronized long decrement(long credits) {
+            return credits_left=Math.max(0, credits_left - credits);
+        }
+
+        
+
+        protected synchronized long get() {return credits_left;}
+
+        protected synchronized void set(long new_credits) {credits_left=Math.min(max_credits, new_credits);}
+
+        protected synchronized long increment(long credits) {
+            return credits_left=Math.min(max_credits, credits_left + credits);
+        }
+
+        public String toString() {
+            return String.valueOf(credits_left);
+        }
+
+        public int compareTo(Object o) {
+            Credit other=(Credit)o;
+            return credits_left < other.credits_left ? -1 : credits_left > other.credits_left ? 1 : 0;
+        }
+    }
+
+
+   /* protected abstract class Credit implements Comparable {
+        protected long credits_left;
+
+        protected Credit(long credits) {
+            this.credits_left=credits;
+        }
+
+        protected long decrementAndGet(long credits) {
+            credits_left=Math.max(0, credits_left - credits);
+            long credit_response=max_credits - credits_left;
+            if(credit_response >= min_credits) {
+                credits_left=max_credits;
+                return credit_response;
+            }
+            return 0;
+        }
+
+        protected long decrement(long credits) {
+            return credits_left=Math.max(0, credits_left - credits);
+        }
+
+        protected long get() {return credits_left;}
+
+        protected void set(long new_credits) {credits_left=Math.min(max_credits, new_credits);}
+
+        protected long increment(long credits) {
+            return credits_left=Math.min(max_credits, credits_left + credits);
+        }
+
+        public String toString() {
+            return String.valueOf(credits_left);
+        }
+
+        public int compareTo(Object o) {
+            Credit other=(Credit)o;
+            return credits_left < other.credits_left ? -1 : credits_left > other.credits_left ? 1 : 0;
+        }
+       
+    }*/
+
+
+}",2010-08-31T12:21:54Z,106
"@@ -0,0 +1,330 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.*;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.BoundedList;
+import org.jgroups.util.Util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: MFC.java,v 1.1 2010/08/31 12:21:55 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public class MFC extends FlowControl {
+
+    
+    
+    /* --------------------------------------------- Fields ------------------------------------------------------ */
+    
+    
+  
+    /**
+     * the lowest credits of any destination (sent_msgs)
+     */
+    @GuardedBy(""lock"")
+    private long lowest_credit=max_credits;
+
+    /** Lock protecting sent credits table and some other vars (creditors for example) */
+    private final Lock lock=new ReentrantLock();
+
+
+    /** List of members from whom we expect credits */
+    @GuardedBy(""lock"")
+    protected final Set<Address> creditors=new HashSet<Address>(11);
+
+
+    /** Mutex to block on down() */
+    private final Condition credits_available=lock.newCondition();
+   
+
+    /**
+     * Allows to unblock a blocked sender from an external program, e.g. JMX
+     */
+    @ManagedOperation(description=""Unblock a sender"")
+    public void unblock() {
+        lock.lock();
+        try {
+            if(log.isTraceEnabled())
+                log.trace(""unblocking the sender and replenishing all members"");
+
+            for(Map.Entry<Address,Credit> entry: sent.entrySet())
+                entry.getValue().set(max_credits);
+
+            lowest_credit=computeLowestCredit(sent);
+            creditors.clear();
+            credits_available.signalAll();
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+    
+
+    public void init() throws Exception {
+        super.init();
+        lowest_credit=max_credits;
+    }
+
+    public void start() throws Exception {
+        super.start();
+        lowest_credit=max_credits;
+    }
+
+    public void stop() {
+        super.stop();
+        lock.lock();
+        try {
+            running=false;
+            ignore_thread.set(false);
+            credits_available.signalAll(); // notify all threads waiting on the mutex that we are done
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+    protected boolean handleMulticastMessage() {
+        return true;
+    }
+
+    protected Credit createCredit(long credits) {
+        return new MfcCredit(credits);
+    }
+
+
+
+
+    protected Object handleDownMessage(final Event evt, final Message msg, int length) {
+        Address dest=msg.getDest();
+
+        if(max_block_times != null) {
+            long tmp=getMaxBlockTime(length);
+            if(tmp > 0)
+                end_time.set(System.currentTimeMillis() + tmp);
+        }
+
+        lock.lock();
+        try {
+            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available
+                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465
+                    if(log.isTraceEnabled())
+                        log.trace(""bypassing blocking to avoid deadlocking "" + Thread.currentThread());
+                }
+                else {
+                    determineCreditors(dest, length);
+                    long start_blocking=System.currentTimeMillis();
+                    num_blockings++; // we count overall blockings, not blockings for *all* threads
+                    if(log.isTraceEnabled())
+                        log.trace(""Starting blocking. lowest_credit="" + lowest_credit + ""; msg length ="" + length);
+
+                    while(length > lowest_credit && running) {
+                        try {
+                            long block_time=max_block_time;
+                            if(max_block_times != null) {
+                                Long tmp=end_time.get();
+                                if(tmp != null) {
+                                    // A negative block_time means we don't wait at all ! If the end_time already elapsed
+                                    // (because we waited for other threads to get processed), the message will not
+                                    // block at all and get sent immediately
+                                    block_time=tmp - start_blocking;
+                                }
+                            }
+
+                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);
+                            if(length <= lowest_credit || rc || !running)
+                                break;
+
+                            // if we use max_block_times, then we do *not* send credit requests, even if we run
+                            // into timeouts: in this case, it is up to the receivers to send new credits
+                            if(!rc && max_block_times != null)
+                                break;
+
+                            long wait_time=System.currentTimeMillis() - last_credit_request;
+                            if(wait_time >= max_block_time) {
+
+                                // we have to set this var now, because we release the lock below (for sending a
+                                // credit request), so all blocked threads would send a credit request, leading to
+                                // a credit request storm
+                                last_credit_request=System.currentTimeMillis();
+
+                                // we need to send the credit requests down *without* holding the lock, otherwise we might
+                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292
+                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);
+                                sent_copy.keySet().retainAll(creditors);
+                                lock.unlock();
+                                try {
+                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())
+                                        sendCreditRequest(entry.getKey(), entry.getValue().get());
+                                }
+                                finally {
+                                    lock.lock();
+                                }
+                            }
+                        }
+                        catch(InterruptedException e) {
+                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!
+                            // (http://jira.jboss.com/jira/browse/JGRP-536)
+                            // Thread.currentThread().interrupt();
+                        }
+                    }
+                    long block_time=System.currentTimeMillis() - start_blocking;
+                    if(log.isTraceEnabled())
+                        log.trace(""total time blocked: "" + block_time + "" ms"");
+                    total_time_blocking+=block_time;
+                    last_blockings.add(block_time);
+                }
+            }
+
+            long tmp=decrementCredit(sent, dest, length);
+            if(tmp != -1)
+                lowest_credit=Math.min(tmp, lowest_credit);
+        }
+        finally {
+            lock.unlock();
+        }
+
+        // send message - either after regular processing, or after blocking (when enough credits available again)
+        return down_prot.down(evt);
+    }
+
+    /**
+     * Checks whether one member (unicast msg) or all members (multicast msg) have enough credits. Add those
+     * that don't to the creditors list. Called with lock held
+     * @param dest
+     * @param length
+     */
+    protected void determineCreditors(Address dest, int length) {
+        boolean multicast=dest == null || dest.isMulticastAddress();
+        if(multicast) {
+            for(Map.Entry<Address,Credit> entry: sent.entrySet()) {
+                if(entry.getValue().get() <= length)
+                    creditors.add(entry.getKey());
+            }
+        }
+        else {
+            Credit cred=sent.get(dest);
+            if(cred != null && cred.get() <= length)
+                creditors.add(dest);
+        }
+    }
+
+
+  
+
+    /**
+     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast
+     * or unicast message. No need to acquire mutex (must already be held when this method is called)
+     * @param dest
+     * @param credits
+     * @return The lowest number of credits left, or -1 if a unicast member was not found
+     */
+    protected long decrementCredit(Map<Address,Credit> map, Address dest, long credits) {
+        boolean multicast=dest == null || dest.isMulticastAddress();
+        long lowest=max_credits;
+
+        if(multicast) {
+            if(map.isEmpty())
+                return -1;
+            for(Credit cred: map.values())
+                lowest=Math.min(cred.decrement(credits), lowest);
+            return lowest;
+        }
+        else {
+            Credit cred=map.get(dest);
+            if(cred != null)
+                return lowest=cred.decrement(credits);
+            }
+        return -1;
+    }
+
+    protected void handleCredit(Address sender, Number increase) {
+        if(sender == null) return;
+        StringBuilder sb=null;
+
+        lock.lock();
+        try {
+            Credit cred=sent.get(sender);
+            if(cred == null)
+                return;
+            long new_credit=Math.min(max_credits, cred.get() + increase.longValue());
+
+            if(log.isTraceEnabled()) {
+                sb=new StringBuilder();
+                sb.append(""received "" + increase + "" credits from "").append(sender).append("", old credits: "").append(cred)
+                        .append("", new credits: "").append(new_credit).append("".\nCreditors before are: "").append(creditors);
+                log.trace(sb);
+            }
+
+            cred.increment(increase.longValue());
+
+            lowest_credit=computeLowestCredit(sent);
+            if(!creditors.isEmpty() && creditors.remove(sender) && creditors.isEmpty())
+                credits_available.signalAll();
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+
+    protected void handleViewChange(Vector<Address> mbrs) {
+        super.handleViewChange(mbrs);
+
+        lock.lock();
+        try {
+            // fixed http://jira.jboss.com/jira/browse/JGRP-754 (CCME)
+            for(Iterator<Address> it=creditors.iterator(); it.hasNext();) {
+                Address creditor=it.next();
+                if(!mbrs.contains(creditor))
+                    it.remove();
+            }
+
+            if(log.isTraceEnabled()) log.trace(""creditors are "" + creditors);
+            if(creditors.isEmpty()) {
+                lowest_credit=computeLowestCredit(sent);
+                credits_available.signalAll();
+            }
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+    protected class MfcCredit extends Credit {
+
+        protected MfcCredit(long credits) {
+            super(credits);
+        }
+    }
+
+
+}",2010-08-31T12:21:54Z,107
"@@ -0,0 +1,225 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: UFC.java,v 1.1 2010/08/31 12:21:54 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public class UFC extends FlowControl {
+
+    
+
+    protected boolean handleMulticastMessage() {
+        return false;
+    }
+
+
+    protected Credit createCredit(long credits) {
+        return new UfcCredit(credits);
+    }
+
+    public void unblock() {
+        super.unblock();
+    }
+
+    public double getAverageTimeBlocked() {
+        int    blockings=0;
+        long   total_time_blocked=0;
+
+        for(Credit cred: sent.values()) {
+            blockings+=((UfcCredit)cred).getNumBlockings();
+            total_time_blocked=((UfcCredit)cred).getTotalBlockingTime();
+        }
+
+        return blockings > 0? total_time_blocked / (double)blockings : 0.0; // prevent div-by-zero
+    }
+
+
+    public int getNumberOfBlockings() {
+        int retval=0;
+        for(Credit cred: sent.values())
+            retval+=((UfcCredit)cred).getNumBlockings();
+        return retval;
+    }
+
+    public long getTotalTimeBlocked() {
+        long retval=0;
+        for(Credit cred: sent.values())
+            retval+=((UfcCredit)cred).getTotalBlockingTime();
+        return retval;
+    }
+
+    public void stop() {
+        super.stop();
+        for(final Credit cred: sent.values()) {
+            synchronized(cred) {
+                cred.notifyAll();
+            }
+        }
+    }
+
+
+
+
+    protected Object handleDownMessage(final Event evt, final Message msg, int length) {
+        Address dest=msg.getDest();
+        if(dest == null || dest.isMulticastAddress()) {
+            log.error(getClass().getSimpleName() + "" doesn't handle multicast messages; passing message down"");
+            return down_prot.down(evt);
+        }
+
+        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465
+            if(log.isTraceEnabled())
+                log.trace(""bypassing blocking to avoid deadlocking "" + Thread.currentThread());
+            return down_prot.down(evt);
+        }
+
+        if(max_block_times != null) {
+            long tmp=getMaxBlockTime(length);
+            if(tmp > 0)
+                end_time.set(System.currentTimeMillis() + tmp);
+        }
+
+        UfcCredit cred=(UfcCredit)sent.get(dest);
+        if(cred == null) {
+            log.error(""destination "" + dest + "" not found; passing message down"");
+            return down_prot.down(evt);
+        }
+
+        while(running) {
+            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block
+                break;
+
+            long start_blocking=System.currentTimeMillis();
+            long block_time=max_block_time;
+            if(max_block_times != null) {
+                Long tmp=end_time.get();
+                if(tmp != null) {
+                    // A negative block_time means we don't wait at all ! If the end_time already elapsed
+                    // (because we waited for other threads to get processed), the message will not
+                    // block at all and get sent immediately
+                    block_time=tmp - start_blocking;
+                }
+            }
+
+            if(log.isTraceEnabled())
+                log.trace(""blocking for credits (for "" + block_time + "" ms)"");
+            boolean rc=cred.decrementIfEnoughCredits(length, block_time);
+            if(rc && log.isTraceEnabled())
+                log.trace(""unblocking (received credits)"");
+            last_blockings.add(System.currentTimeMillis() - start_blocking);
+            
+            if(rc || !running || max_block_times != null)
+                break;
+
+            if(cred.sendCreditRequest(System.currentTimeMillis()))
+                sendCreditRequest(dest, cred.get());
+        }
+
+        // send message - either after regular processing, or after blocking (when enough credits available again)
+        return down_prot.down(evt);
+    }
+    
+
+
+    protected void handleCredit(Address sender, Number increase) {
+        if(sender == null) return;
+        StringBuilder sb=null;
+
+        Credit cred=sent.get(sender);
+        if(cred == null)
+            return;
+        long new_credit=Math.min(max_credits, cred.get() + increase.longValue());
+
+        if(log.isTraceEnabled()) {
+            sb=new StringBuilder();
+            sb.append(""received "" + increase + "" credits from "").append(sender).append("", old credits: "").append(cred)
+                    .append("", new credits: "").append(new_credit);
+            log.trace(sb);
+        }
+
+        cred.increment(increase.longValue());
+    }
+    
+
+    protected class UfcCredit extends Credit {
+        int num_blockings=0;
+        long total_blocking_time=0;
+        long last_credit_request=0;
+
+        protected UfcCredit(long credits) {
+            super(credits);
+        }
+
+        protected synchronized boolean decrementIfEnoughCredits(long credits, long timeout) {
+            if(credits <= credits_left) {
+                credits_left-=credits;
+                return true;
+            }
+
+            if(timeout <= 0)
+                return false;
+
+            long start=System.currentTimeMillis();
+            try {
+                this.wait(timeout);
+            }
+            catch(InterruptedException e) {
+            }
+            finally {
+                total_blocking_time+=System.currentTimeMillis() - start;
+                num_blockings++;
+            }
+
+            if(credits <= credits_left) {
+                credits_left-=credits;
+                return true;
+            }
+            return false;
+        }
+
+        protected synchronized long increment(long credits) {
+            long retval=super.increment(credits);
+            notifyAll();
+            return retval;
+        }
+
+        protected synchronized boolean sendCreditRequest(long current_time) {
+            if(current_time - last_credit_request >= max_block_time) {
+                // we have to set this var now, because we release the lock below (for sending a credit request), so
+                // all blocked threads would send a credit request, leading to a credit request storm
+                last_credit_request=System.currentTimeMillis();
+                return true;
+            }
+            return false;
+        }
+
+        protected int getNumBlockings() {return num_blockings;}
+
+        protected long getTotalBlockingTime() {return total_blocking_time;}
+    }
+
+
+}",2010-08-31T12:21:54Z,108
"@@ -269,24 +269,32 @@ static class PreSignedUrlParser {
         public PreSignedUrlParser(String preSignedUrl) {
             try {
                 URL url = new URL(preSignedUrl);
+                this.bucket = parseBucketFromHost(url.getHost());
                 String path = url.getPath();
                 String[] pathParts = path.split(""/"");
                 
-                if (pathParts.length < 3) {
+                if (pathParts.length < 2) {
                     throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" must point to a file within a bucket"");
                 }
-                if (pathParts.length > 4) {
+                if (pathParts.length > 3) {
                     throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" may only have only subdirectory under a bucket"");
                 }
-                this.bucket = pathParts[1];
-                if (pathParts.length > 3) {
-                    this.prefix = pathParts[2];
+                if (pathParts.length > 2) {
+                    this.prefix = pathParts[1];
                 }
             } catch (MalformedURLException ex) {
                 throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" is not a valid url"");
             }
         }
 
+        private String parseBucketFromHost(String host) {
+            int s3Index = host.lastIndexOf("".s3."");
+            if (s3Index > 0) {
+                host = host.substring(0, s3Index);
+            }
+            return host;
+        }
+
         public String getBucket() {
             return bucket;
         }
@@ -1811,7 +1819,7 @@ public static String generateQueryStringAuthentication(String awsAccessKey, Stri
             String canonicalString =
                 makeCanonicalString(method, bucket, key, pathArgs, headers, """" + expirationDate);
             String encodedCanonical = encode(awsSecretAccessKey, canonicalString, true);
-            return ""http://"" + DEFAULT_HOST + ""/"" + bucket + ""/"" + key + ""?"" +
+            return ""http://"" + bucket + ""."" + DEFAULT_HOST + ""/"" + key + ""?"" +
                 ""AWSAccessKeyId="" + awsAccessKey + ""&Expires="" + expirationDate +
                 ""&Signature="" + encodedCanonical;
         }",2014-02-07T19:45:51Z,109
"@@ -5,6 +5,7 @@
 import java.util.Map;
 
 import org.jgroups.Global;
+import org.jgroups.protocols.S3_PING.PreSignedUrlParser;
 import org.jgroups.protocols.S3_PING.Utils;
 import org.testng.Assert;
 import org.testng.annotations.BeforeMethod;
@@ -40,29 +41,29 @@ public void testValidatePropertiesWithBothPreSignedSetButNoBucket() {
     
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testValidatePropertiesWithBothPreSignedSetButNoFile() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/"";
         ping.validateProperties();
     }
     
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testValidatePropertiesWithBothPreSignedSetButTooManySubdirectories() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/subdir/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/subdir/DemoCluster/node1"";
         ping.validateProperties();
     }
     
     @Test
     public void testValidatePropertiesWithBothPreSignedSetToValid() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/node1"";
         ping.validateProperties();
     }
     
     @Test
     public void testValidatePropertiesWithBothPreSignedSetToValidSubdirectory() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/DemoCluster/node1"";
         ping.validateProperties();
     }
     
@@ -73,13 +74,13 @@ public void testUsingPreSignedUrlWhenNotSet() {
     
     @Test
     public void testUsingPreSignedUrlWhenSet() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/node1"";
         Assert.assertTrue(ping.usingPreSignedUrls());
     }
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicGet() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""get"",
                                                     ""test-bucket"", ""node1"",
@@ -90,7 +91,7 @@ public void testGenerateQueryStringAuthenticationWithBasicGet() {
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicPost() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""POST"",
                                                     ""test-bucket"", ""node1"",
@@ -103,7 +104,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPost() {
     public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
         Map headers = new HashMap();
         headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""put"",
                                                     ""test-bucket"", ""subdir/node1"",
@@ -114,7 +115,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
     
     @Test
     public void testGeneratePreSignedUrlForPut() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
         String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
                                                            ""test-bucket"", ""subdir/node1"",
                                                            1234567890);
@@ -123,10 +124,31 @@ public void testGeneratePreSignedUrlForPut() {
     
     @Test
     public void testGeneratePreSignedUrlForDelete() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
         String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
                                                            ""test-bucket"", ""subdir/node1"",
                                                            1234567890);
         Assert.assertEquals(preSignedUrl, expectedUrl);
     }
-}
\ No newline at end of file
+
+    @Test
+    public void testPreSignedUrlParserNoPrefix() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.amazonaws.com/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket"");
+        Assert.assertEquals(parser.getPrefix(), """");
+    }
+
+    @Test
+    public void testPreSignedUrlParserWithPrefix() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.amazonaws.com/subdir/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket"");
+        Assert.assertEquals(parser.getPrefix(), ""subdir"");
+    }
+
+    @Test
+    public void testPreSignedUrlParserWithComplexBucketName() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.foo-bar.s3.amazonaws.com/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket.s3.foo-bar"");
+        Assert.assertEquals(parser.getPrefix(), """");
+    }
+}",2014-02-07T19:45:51Z,110
"@@ -1,19 +1,16 @@
 package org.jgroups.protocols;
 
-import org.jgroups.Event;
-import org.jgroups.Message;
-import org.jgroups.PhysicalAddress;
+import org.jgroups.*;
 import org.jgroups.annotations.Property;
 import org.jgroups.annotations.Experimental;
 import org.jgroups.util.UUID;
 import org.jgroups.util.Util;
 import org.jgroups.util.Promise;
 
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Collection;
+import java.util.*;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
 
 
 /**
@@ -22,7 +19,7 @@
  * added to our transport's UUID-PhysicalAddress cache.<p/>
  * The design is at doc/design/FILE_PING.txt
  * @author Bela Ban
- * @version $Id: FILE_PING.java,v 1.16 2010/06/16 08:48:32 belaban Exp $
+ * @version $Id: FILE_PING.java,v 1.17 2010/06/16 11:21:38 belaban Exp $
  */
 @Experimental
 public class FILE_PING extends Discovery {
@@ -34,10 +31,14 @@ public class FILE_PING extends Discovery {
     @Property(description=""The absolute path of the shared file"")
     protected String location=File.separator + ""tmp"" + File.separator + ""jgroups"";
 
+    @Property(description=""Interval (in milliseconds) at which the own address is written to the file system. 0 disables it."")
+    protected long interval=60000;
+
 
     /* --------------------------------------------- Fields ------------------------------------------------------ */
     protected File root_dir=null;
     protected FilenameFilter filter;
+    private ScheduledFuture<?> writer_future;
 
 
     public void init() throws Exception {
@@ -58,9 +59,23 @@ public boolean accept(File dir, String name) {
                 return name.endsWith(SUFFIX);
             }
         };
+
+
     }
 
+    public void start() throws Exception {
+        super.start();
+        if(interval > 0)
+            writer_future=timer.scheduleWithFixedDelay(new WriterTask(), interval, interval, TimeUnit.MILLISECONDS);
+    }
 
+    public void stop() {
+        if(writer_future != null) {
+            writer_future.cancel(false);
+            writer_future=null;
+        }
+        super.stop();
+    }
 
     public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception{
         List<PingData> existing_mbrs=readAll(cluster_name);
@@ -112,6 +127,47 @@ public void run() {
     }
 
 
+    public Object down(Event evt) {
+        Object retval=super.down(evt);
+        if(evt.getType() == Event.VIEW_CHANGE)
+            handleView((View)evt.getArg());
+        return retval;
+    }
+
+    // remove all files which are not from the current members
+    protected void handleView(View view) {
+        Collection<Address> mbrs=view.getMembers();
+        boolean is_coordinator=!mbrs.isEmpty() && mbrs.iterator().next().equals(local_addr);
+        if(is_coordinator) {
+            List<PingData> data=readAll(group_addr);
+            for(PingData entry: data) {
+                Address addr=entry.getAddress();
+                if(addr != null && !mbrs.contains(addr)) {
+                    remove(group_addr, addr);
+                }
+            }
+        }
+    }
+
+    protected void remove(String clustername, Address addr) {
+        if(clustername == null || addr == null)
+            return;
+
+        File dir=new File(root_dir, clustername);
+        if(!dir.exists())
+            return;
+
+        try {
+            String filename=addr instanceof UUID? ((UUID)addr).toStringLong() : addr.toString();
+            File file=new File(dir, filename + SUFFIX);
+            if(log.isTraceEnabled())
+                log.trace(""removing "" + file);
+            file.delete();
+        }
+        catch(Throwable e) {
+            log.error(""failure removing data"", e);
+        }
+    }
 
     /**
      * Reads all information from the given directory under clustername
@@ -171,5 +227,15 @@ protected void writeToFile(PingData data, String clustername) {
     }
 
 
+    protected class WriterTask implements Runnable {
+        public void run() {
+            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));
+            List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);
+            PingData data=new PingData(local_addr, null, false, UUID.get(local_addr), physical_addrs);
+            writeToFile(data, group_addr);
+        }
+    }
+
+
 
 }
\ No newline at end of file",2010-06-16T11:21:38Z,111
"@@ -1,9 +1,10 @@
 package org.jgroups.protocols;
 
-import org.jgroups.util.*;
-import org.jgroups.annotations.Property;
+import org.jgroups.Address;
 import org.jgroups.annotations.Experimental;
+import org.jgroups.annotations.Property;
 import org.jgroups.annotations.Unsupported;
+import org.jgroups.util.Util;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
@@ -17,7 +18,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
-import static java.lang.String.valueOf;
 import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
 import java.net.URL;
@@ -27,14 +27,15 @@
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.*;
-import java.util.UUID;
+
+import static java.lang.String.valueOf;
 
 
 /**
  * Discovery protocol using Amazon's S3 storage. The S3 access code reuses the example shipped by Amazon.
  * This protocol is unsupported and experimental !
  * @author Bela Ban
- * @version $Id: S3_PING.java,v 1.5 2010/06/16 08:48:32 belaban Exp $
+ * @version $Id: S3_PING.java,v 1.6 2010/06/16 11:21:38 belaban Exp $
  */
 @Experimental @Unsupported
 public class S3_PING extends FILE_PING {
@@ -47,8 +48,6 @@ public class S3_PING extends FILE_PING {
 
     protected AWSAuthConnection conn=null;
 
-    protected final Set<Entry> keys=new HashSet<Entry>();
-
 
   
     public void init() throws Exception {
@@ -63,36 +62,11 @@ public void init() throws Exception {
 
         Runtime.getRuntime().addShutdownHook(new Thread() {
             public void run() {
-                Set<Entry> copy;
-                synchronized(keys) {
-                    copy=new HashSet<Entry>(keys);
-                    keys.clear();
-                }
-
-                for(Entry entry : copy) {
-                    remove(entry.cluster, entry.data);
-                }
+                remove(group_addr, local_addr);
             }
         });
     }
 
-    public void stop() {
-        if(group_addr != null && local_addr != null) {
-            // remove from keys:
-            synchronized(keys) {
-                for(Iterator<Entry> it=keys.iterator(); it.hasNext();) {
-                    Entry entry=it.next();
-                    if(group_addr.equals(entry.cluster) && local_addr.equals(entry.data.getAddress())) {
-                        it.remove();
-                    }
-                }
-            }
-
-            PingData data=new PingData(local_addr, null, false, org.jgroups.util.UUID.get(local_addr), null);
-            remove(group_addr, data);
-        }
-        super.stop();
-    }
 
 
     protected List<PingData> readAll(String clustername) {
@@ -140,46 +114,35 @@ protected void writeToFile(PingData data, String clustername) {
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
             byte[] buf=Util.objectToByteBuffer(data);
             S3Object val=new S3Object(buf, null);
-            String response=conn.put(location, key, val, headers).connection.getResponseMessage();
-            if(log.isTraceEnabled())
-                log.trace(""response: "" + response);
-            synchronized(keys) {
-                keys.add(new Entry(clustername, data));
-            }
+            conn.put(location, key, val, headers).connection.getResponseMessage();
         }
         catch(Exception e) {
             log.error(""failed marshalling "" + data + "" to buffer"", e);
         }
     }
 
 
-    protected void remove(String clustername, PingData data) {
-        if(clustername == null || data == null)
+    protected void remove(String clustername, Address addr) {
+        if(clustername == null || addr == null)
             return;
-        String filename=local_addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)local_addr).toStringLong() : local_addr.toString();
+        String filename=addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)addr).toStringLong() : addr.toString();
         String key=clustername + ""/"" + filename;
         try {
             Map headers=new TreeMap();
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
-            String response=conn.delete(location, key, headers).connection.getResponseMessage();
+            conn.delete(location, key, headers).connection.getResponseMessage();
             if(log.isTraceEnabled())
-                log.trace(""response: "" + response);
+                log.trace(""removing "" + location + ""/"" + key);
         }
         catch(Exception e) {
-            log.error(""failed marshalling "" + data + "" to buffer"", e);
+            log.error(""failure removing data"", e);
         }
     }
 
 
-    private static class Entry {
-        final String cluster;
-        final PingData data;
 
-        Entry(String cluster, PingData data) {
-            this.cluster=cluster;
-            this.data=data;
-        }
-    }
+
+    
 
 
     /**",2010-06-16T11:21:38Z,109
"@@ -89,7 +89,7 @@ private static <T> Iterator<T> getFactories(Class<T> type, ClassLoader classLoad
 
             Provider[] providers = Security.getProviders();
             for (Provider currentProvider : providers) {
-                final ClassLoader cl = currentProvider.getClass().getClassLoader();
+                final ClassLoader cl = Thread.currentThread().getContextClassLoader();
                 for (Object currentKey : currentProvider.keySet()) {
                     if (currentKey instanceof String && ((String) currentKey).startsWith(filter)
                             && ((String) currentKey).indexOf(' ') < 0) {
@@ -111,7 +111,7 @@ private static <T> Iterator<T> getFactories(Class<T> type, ClassLoader classLoad
     }
 
     public static SaslServerFactory getSaslServerFactory(String mech, Map<String, ?> props) {
-        Iterator<SaslServerFactory> saslFactories = SaslUtils.getSaslServerFactories(SaslUtils.class.getClassLoader(), true);
+        Iterator<SaslServerFactory> saslFactories = SaslUtils.getSaslServerFactories(Thread.currentThread().getContextClassLoader(), true);
         while (saslFactories.hasNext()) {
             SaslServerFactory saslFactory = saslFactories.next();
             for (String supportedMech : saslFactory.getMechanismNames(props)) {
@@ -124,7 +124,7 @@ public static SaslServerFactory getSaslServerFactory(String mech, Map<String, ?>
     }
 
     public static SaslClientFactory getSaslClientFactory(String mech, Map<String, ?> props) {
-        Iterator<SaslClientFactory> saslFactories = SaslUtils.getSaslClientFactories(SaslUtils.class.getClassLoader(), true);
+        Iterator<SaslClientFactory> saslFactories = SaslUtils.getSaslClientFactories(Thread.currentThread().getContextClassLoader(), true);
         while (saslFactories.hasNext()) {
             SaslClientFactory saslFactory = saslFactories.next();
             for (String supportedMech : saslFactory.getMechanismNames(props)) {",2016-01-12T23:03:14Z,112
"@@ -168,7 +168,7 @@ public static Class<?> get(short magic) {
      * @return a Class object that represents a class that implements java.io.Externalizable
      */
     public static Class get(String clazzname, ClassLoader loader) throws ClassNotFoundException {
-        return Util.loadClass(clazzname, loader != null? loader : ClassConfigurator.class.getClassLoader());
+        return Util.loadClass(clazzname, loader != null? loader : Thread.currentThread().getContextClassLoader());
     }
 
     public static Class get(String clazzname) throws ClassNotFoundException {",2016-01-12T23:03:14Z,113
"@@ -47,11 +47,11 @@ public ProtocolConfiguration(String config_str) throws Exception {
             }
         }
         parsePropertiesString(properties);
-        this.loader = ProtocolConfiguration.class.getClassLoader();
+        this.loader = Thread.currentThread().getContextClassLoader();
     }
 
     public ProtocolConfiguration(String protocol_name, Map<String,String> properties) {
-        this(protocol_name, properties, ProtocolConfiguration.class.getClassLoader());
+        this(protocol_name, properties, Thread.currentThread().getContextClassLoader());
     }
 
     public ProtocolConfiguration(String protocol_name, Map<String,String> properties, ClassLoader loader) {",2016-01-12T23:03:14Z,114
"@@ -179,7 +179,7 @@ private static InputStream getAsInputStreamFromClassLoader(String filename) {
         InputStream is = cl == null ? null : cl.getResourceAsStream(filename);
         if (is == null) {
             // check system class loader
-            is = XmlConfigurator.class.getClassLoader().getResourceAsStream(filename);
+            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(filename);
         }
         return is;
     }",2016-01-12T23:03:14Z,30
"@@ -101,7 +101,7 @@ public enum AddressScope {GLOBAL,SITE_LOCAL,LINK_LOCAL,LOOPBACK,NON_LOOPBACK}
 
 
     static {
-        resource_bundle=ResourceBundle.getBundle(""jg-messages"",Locale.getDefault(),Util.class.getClassLoader());
+        resource_bundle=ResourceBundle.getBundle(""jg-messages"",Locale.getDefault(),Thread.currentThread().getContextClassLoader());
 
         /* Trying to get value of resolve_dns. PropertyPermission not granted if
         * running in an untrusted environment with JNLP */",2016-01-12T23:03:14Z,54
"@@ -0,0 +1,13 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+
+/**
+ * FileObserver. A callback that is invoked when a file is changed. {@link FileWatchTask}
+ *
+ * @author Tristan Tarrant
+ * @since 8.0
+ */
+public interface FileObserver {
+   void fileChanged(File file);
+}",2015-05-26T06:22:12Z,115
"@@ -0,0 +1,35 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+import java.util.TimerTask;
+
+/**
+ * FileWatchTask. Polls a file for modifications and invokes a provided {@link FileObserver}
+ *
+ * @author Tristan Tarrant
+ * @since 8.0
+ */
+public class FileWatchTask extends TimerTask {
+   private final File file;
+   private long modified;
+   private final FileObserver observer;
+
+   public FileWatchTask(File file, FileObserver observer) {
+      if (!file.exists()) {
+         throw new IllegalArgumentException(""File '"" + file + ""' does not exist"");
+      }
+      this.file = file;
+      this.modified = file.lastModified();
+      this.observer = observer;
+   }
+
+   @Override
+   public void run() {
+      long modified = file.lastModified();
+      if (this.modified != modified) {
+         this.modified = modified;
+         observer.fileChanged(file);
+      }
+   }
+
+}",2015-05-26T06:22:12Z,116
"@@ -7,6 +7,7 @@
 import javax.security.auth.callback.NameCallback;
 import javax.security.auth.callback.PasswordCallback;
 import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.RealmCallback;
 
 /**
  * SaslClientCallbackHandler.
@@ -17,9 +18,12 @@ public class SaslClientCallbackHandler implements CallbackHandler {
 
     private final String name;
     private final char[] password;
+    private final String realm;
 
     public SaslClientCallbackHandler(String name, char[] password) {
-        this.name = name;
+        int realmSep = name.indexOf('@');
+        this.realm = realmSep < 0 ? """" : name.substring(realmSep+1);
+        this.name = realmSep < 0 ? name : name.substring(0, realmSep);
         this.password = password;
     }
 
@@ -28,6 +32,8 @@ public void handle(Callback[] callbacks) throws IOException, UnsupportedCallback
         for (Callback callback : callbacks) {
             if (callback instanceof PasswordCallback) {
                 ((PasswordCallback) callback).setPassword(password);
+            } else if (callback instanceof RealmCallback) {
+                ((RealmCallback) callback).setText(realm);
             } else if (callback instanceof NameCallback) {
                 ((NameCallback) callback).setName(name);
             }",2015-05-26T06:22:12Z,117
"@@ -0,0 +1,42 @@
+package org.jgroups.auth.sasl;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Properties;
+
+/**
+ * SecurityActions for the org.jgroups.auth.sasl package.
+ *
+ * Do not move. Do not change class and method visibility to avoid being called from other
+ * {@link java.security.CodeSource}s, thus granting privilege escalation to external code.
+ *
+ * @author Tristan Tarrant
+ * @since 3.6
+ */
+final class SecurityActions {
+   private static <T> T doPrivileged(PrivilegedAction<T> action) {
+      if (System.getSecurityManager() != null) {
+         return AccessController.doPrivileged(action);
+      } else {
+         return action.run();
+      }
+   }
+
+   static String getSystemProperty(final String name) {
+      return doPrivileged(new PrivilegedAction<String>() {
+         @Override
+         public String run() {
+            return System.getProperty(name);
+         }
+      });
+   }
+
+   public static Properties getSystemProperties() {
+      return doPrivileged(new PrivilegedAction<Properties>() {
+         @Override
+         public Properties run() {
+            return System.getProperties();
+         }
+      });
+   }
+}",2015-05-26T06:22:12Z,118
"@@ -0,0 +1,186 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Properties;
+import java.util.Timer;
+import java.util.concurrent.TimeUnit;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.util.Util;
+
+/**
+ * SimpleAuthorizingCallbackHandler. This class implements a simple callback handler which can be
+ * used to configure cluster authentication for the JGroups transport. It is configured via system
+ * properties. The following properties are available:
+ *
+ * <ul>
+ * <li>sasl.credentials.properties - the path to a property file which contains principal/credential
+ * mappings represented as principal=password</li>
+ * <li>sasl.local.principal - the name of the principal that is used to identify the local node. It
+ * must exist in the sasl.credentials.properties file</li>
+ * <li>sasl.roles.properties - (optional) the path to a property file which contains principal/roles
+ * mappings represented as principal=role1,role2,role3</li>
+ * <li>sasl.role - (optional) if present, authorizes joining nodes only if their principal is
+ * <li>sasl.realm - (optional) the name of the realm to use for the SASL mechanisms that require it
+ * </li>
+ * </ul>
+ *
+ * @author Tristan Tarrant
+ * @since 3.6
+ */
+public class SimpleAuthorizingCallbackHandler implements CallbackHandler {
+    private static final Log log = LogFactory.getLog(SimpleAuthorizingCallbackHandler.class);
+    private final Properties credentials;
+    private final Properties roles;
+    private final Timer timer;
+    private final String localPrincipal;
+    private final String role;
+    private final String realm;
+
+    public SimpleAuthorizingCallbackHandler() {
+        this(SecurityActions.getSystemProperties());
+    }
+
+    public SimpleAuthorizingCallbackHandler(Properties properties) {
+        this.credentials = new Properties();
+        this.roles = new Properties();
+
+        localPrincipal = requireProperty(properties, ""sasl.local.principal"");
+        String credentialsFile = requireProperty(properties, ""sasl.credentials.properties"");
+        timer = new Timer();
+        File fCredentials = new File(credentialsFile);
+        timer.scheduleAtFixedRate(
+                new FileWatchTask(fCredentials, new PropertiesReloadFileObserver(fCredentials, credentials)), 0,
+                TimeUnit.SECONDS.toMillis(10));
+        role = properties.getProperty(""sasl.role"");
+        String rolesFile = properties.getProperty(""sasl.roles.properties"");
+        if (role != null) {
+            if (rolesFile == null) {
+                throw new IllegalStateException(
+                        ""To enable role authorization, both sasl.role and sasl.roles.properties system properties must be set"");
+            } else {
+                File fRoles = new File(rolesFile);
+                timer.scheduleAtFixedRate(
+                        new FileWatchTask(fRoles, new PropertiesReloadFileObserver(fRoles, roles)), 0,
+                        TimeUnit.SECONDS.toMillis(10));
+            }
+        }
+        realm = properties.getProperty(""sasl.realm"");
+    }
+
+    private String requireProperty(Properties properties, String propertyName) {
+        String value = properties.getProperty(propertyName);
+        if (value == null) {
+            throw new IllegalStateException(""The required system property "" + propertyName + "" has not been set"");
+        } else {
+            return value;
+        }
+    }
+
+    @Override
+    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+        List<Callback> responseCallbacks = new LinkedList<>();
+
+        String remotePrincipal = null;
+        boolean remotePrincipalFound = false;
+
+        for (Callback current : callbacks) {
+            if (current instanceof AuthorizeCallback) {
+                responseCallbacks.add(current);
+            } else if (current instanceof NameCallback) {
+                NameCallback nameCallback = (NameCallback) current;
+                remotePrincipal = nameCallback.getDefaultName();
+                if (remotePrincipal != null) { // server
+                    remotePrincipalFound = credentials.containsKey(remotePrincipal);
+                } else { // client, we need to respond
+                    responseCallbacks.add(current);
+                }
+            } else if (current instanceof PasswordCallback) {
+                responseCallbacks.add(current);
+            } else if (current instanceof RealmCallback) {
+                String realm = ((RealmCallback) current).getDefaultText();
+                if (realm != null) {
+                    if (this.realm.equals(realm) == false) {
+                        throw new IOException(""Invalid realm "" + realm);
+                    }
+                }
+                responseCallbacks.add(current);
+            } else {
+                throw new UnsupportedCallbackException(current);
+            }
+        }
+
+        for (Callback current : responseCallbacks) {
+            if (current instanceof NameCallback) {
+                ((NameCallback) current).setName(localPrincipal);
+            } else if (current instanceof AuthorizeCallback) {
+                AuthorizeCallback acb = (AuthorizeCallback) current;
+                String authenticationId = acb.getAuthenticationID();
+                String authorizationId = acb.getAuthorizationID();
+                acb.setAuthorized(authenticationId.equals(authorizationId));
+                if (role != null) {
+                    String principalRoleNames = roles.getProperty(acb.getAuthorizationID());
+                    List<String> principalRoles = (List<String>) (principalRoleNames != null
+                            ? Arrays.asList(principalRoleNames.split(""\\s*,\\s*"")) : Collections.emptyList());
+                    if (!principalRoles.contains(role)) {
+                        throw new IOException(""Unauthorized user "" + authorizationId);
+                    }
+                }
+            } else if (current instanceof PasswordCallback) {
+                String password;
+                if (remotePrincipal == null) { // client, send our password
+                    password = credentials.getProperty(localPrincipal);
+                } else if (remotePrincipalFound) { // server, validate incoming password
+                    password = credentials.getProperty(remotePrincipal);
+                } else {
+                    throw new IOException(""Unauthorized user "" + remotePrincipal);
+                }
+                ((PasswordCallback) current).setPassword(password.toCharArray());
+            } else if (current instanceof RealmCallback) {
+                ((RealmCallback)current).setText(realm);
+            }
+        }
+    }
+
+    public static class PropertiesReloadFileObserver implements FileObserver {
+
+        private final Properties properties;
+
+        PropertiesReloadFileObserver(File file, Properties properties) {
+            this.properties = properties;
+            loadProperties(file);
+        }
+
+        private void loadProperties(File file) {
+            FileInputStream fis = null;
+            try {
+                fis = new FileInputStream(file);
+                properties.load(fis);
+            } catch (IOException e) {
+                log.error(""An error occurred while loading properties from "" + file, e);
+            } finally {
+                Util.close(fis);
+            }
+        }
+
+        @Override
+        public void fileChanged(File file) {
+            loadProperties(file);
+        }
+    }
+}",2015-05-26T06:22:12Z,119
"@@ -0,0 +1,89 @@
+package org.jgroups.protocols;
+
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Properties;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.auth.sasl.SimpleAuthorizingCallbackHandler;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+@Test(groups = Global.FUNCTIONAL, singleThreaded = true)
+public class SASL_SimpleAuthorizingCallbackTest {
+    private static final String REALM = ""MyRealm"";
+    private JChannel a;
+    private JChannel b;
+    File credentialsFile;
+    File rolesFile;
+
+    @BeforeClass
+    public void initialize() throws Exception {
+        Properties credentials = new Properties();
+        credentials.put(""jack"", ""brokehiscrown"");
+        credentials.put(""jill"", ""cametumblingafter"");
+        credentials.put(""jane"", ""whatsyourname"");
+        credentialsFile = File.createTempFile(""sasl_credentials"", "".properties"");
+        credentials.store(new FileOutputStream(credentialsFile), null);
+
+        Properties roles = new Properties();
+        roles.put(""jack"", ""mycluster"");
+        roles.put(""jill"", ""mycluster"");
+        roles.put(""jane"", ""othercluster"");
+        rolesFile = File.createTempFile(""sasl_roles"", "".properties"");
+        roles.store(new FileOutputStream(rolesFile), null);
+    }
+
+    private JChannel createChannel(String channelName, String mech, String principal) throws Exception {
+        Properties properties = new Properties();
+        properties.put(""sasl.local.principal"", principal);
+        properties.put(""sasl.credentials.properties"", credentialsFile.getAbsolutePath());
+        properties.put(""sasl.role"", ""mycluster"");
+        properties.put(""sasl.roles.properties"", rolesFile.getAbsolutePath());
+        properties.put(""sasl.realm"", REALM);
+        SASL sasl = new SASL();
+        sasl.setMech(mech);
+        sasl.setClientCallbackHandler(new SimpleAuthorizingCallbackHandler(properties));
+        sasl.setServerCallbackHandler(new SimpleAuthorizingCallbackHandler(properties));
+        sasl.setTimeout(5000);
+        sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
+        return new JChannel(new Protocol[] { new SHARED_LOOPBACK(), new PING(), new NAKACK2(), new UNICAST3(),
+                new STABLE(), sasl, new GMS() }).name(channelName);
+    }
+
+    public void testSASLDigestMD5() throws Exception {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jill"");
+        a.connect(""SaslTest"");
+        b.connect(""SaslTest"");
+        assertTrue(b.isConnected());
+    }
+
+    @Test(expectedExceptions = SecurityException.class)
+    public void testSASLDigestMD5Failure() throws Throwable {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jane"");
+        a.connect(""SaslTest"");
+        try {
+            b.connect(""SaslTest"");
+        } catch (Exception e) {
+            if (e.getCause() != null)
+                throw e.getCause();
+        }
+    }
+
+    @AfterMethod
+    public void cleanup() {
+        a.close();
+        b.close();
+    }
+}",2015-05-26T06:22:12Z,120
"@@ -158,7 +158,7 @@ public static String type2String(int t) {
 
     public String toString() {
         StringBuilder ret=new StringBuilder(64);
-        ret.append(""Event[type="" + type2String(type) + "", arg="" + arg + ']');
+        ret.append(type2String(type)).append("", arg="").append(arg);
         if(type == MSG)
             ret.append("" (headers="").append(((Message)arg).printHeaders()).append("")"");
         return ret.toString();",2014-01-10T16:46:08Z,121
"@@ -1578,21 +1578,27 @@ else if(internal)
     }
 
     /**
-     * Removes messages with flag DONT_BUNDLE set and executes them in the oob or internal thread pool. JGRP-1737
+     * Removes messages with flags DONT_BUNDLE and OOB set and executes them in the oob or internal thread pool. JGRP-1737
      */
     protected void removeAndDispatchNonBundledMessages(MessageBatch ... oob_batches) {
         for(MessageBatch oob_batch: oob_batches) {
             if(oob_batch == null)
                 continue;
 
             for(Message msg: oob_batch) {
-                if(msg.isFlagSet(Message.Flag.DONT_BUNDLE)) {
+                if(msg.isFlagSet(Message.Flag.DONT_BUNDLE) && msg.isFlagSet(Message.Flag.OOB)) {
                     boolean oob=msg.isFlagSet(Message.Flag.OOB), internal=msg.isFlagSet(Message.Flag.INTERNAL);
                     msg.putHeader(id, new TpHeader(oob_batch.clusterName()));
                     Executor pool=pickThreadPool(oob, internal);
-                    pool.execute(new SingleMessageHandler(msg));
-                    oob_batch.remove(msg);
-                    num_oob_msgs_received++;
+                    try {
+                        pool.execute(new SingleMessageHandler(msg));
+                        oob_batch.remove(msg);
+                        num_oob_msgs_received++;
+                    }
+                    catch(Throwable t) {
+                        log.error(""%s: failed submitting DONT_BUNDLE message to thread pool: %s. Msg: %s"",
+                                  local_addr, t, msg.printHeaders());
+                    }
                 }
             }
         }",2014-01-10T16:46:08Z,85
"@@ -12,6 +12,7 @@
 import java.io.DataOutput;
 import java.util.*;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -26,7 +27,7 @@
  */
 @MBean(description=""Reliable unicast layer"")
 public class UNICAST3 extends Protocol implements AgeOutCache.Handler<Address> {
-    public static final long DEFAULT_FIRST_SEQNO=Global.DEFAULT_FIRST_UNICAST_SEQNO;
+    protected static final long DEFAULT_FIRST_SEQNO=Global.DEFAULT_FIRST_UNICAST_SEQNO;
 
 
     /* ------------------------------------------ Properties  ------------------------------------------ */
@@ -95,27 +96,31 @@ public class UNICAST3 extends Protocol implements AgeOutCache.Handler<Address> {
     protected final ConcurrentMap<Address, SenderEntry>   send_table=Util.createConcurrentMap();
     protected final ConcurrentMap<Address, ReceiverEntry> recv_table=Util.createConcurrentMap();
 
-    protected final ReentrantLock      recv_table_lock=new ReentrantLock();
+    protected final ReentrantLock          recv_table_lock=new ReentrantLock();
 
     /** Used by the retransmit task to keep the last retransmitted seqno per sender (https://issues.jboss.org/browse/JGRP-1539) */
-    protected final Map<Address,Long>  xmit_task_map=new HashMap<Address,Long>();
+    protected final Map<Address,Long>      xmit_task_map=new HashMap<Address,Long>();
 
     /** RetransmitTask running every xmit_interval ms */
-    protected Future<?>                xmit_task;
+    protected Future<?>                    xmit_task;
 
-    protected volatile List<Address>   members=new ArrayList<Address>(11);
+    protected volatile List<Address>       members=new ArrayList<Address>(11);
 
-    protected Address                  local_addr;
+    protected Address                      local_addr;
 
-    protected TimeScheduler            timer; // used for retransmissions (passed to AckSenderWindow)
+    protected TimeScheduler                timer; // used for retransmissions
 
-    protected volatile boolean         running=false;
+    protected volatile boolean             running=false;
 
-    protected short                    last_conn_id;
+    protected short                        last_conn_id;
 
-    protected AgeOutCache<Address>     cache;
+    protected AgeOutCache<Address>         cache;
 
+    protected static final Message         DUMMY_OOB_MSG=new Message(false).setFlag(Message.Flag.OOB);
 
+    protected static final Filter<Message> drop_oob_msgs_filter=new Filter<Message>() {
+        public boolean accept(Message msg) {return msg != null && msg.hashCode() != DUMMY_OOB_MSG.hashCode();}
+    };
 
 
     public void setMaxMessageBatchSize(int size) {
@@ -663,7 +668,7 @@ public void expired(Address key) {
      * e.received_msgs is null and <code>first</code> is true: create a new AckReceiverWindow(seqno) and
      * add message. Set e.received_msgs to the new window. Else just add the message.
      */
-    protected void handleDataReceived(Address sender, long seqno, short conn_id,  boolean first, final Message msg, Event evt) {
+    protected void handleDataReceived(final Address sender, long seqno, short conn_id,  boolean first, final Message msg, Event evt) {
         if(log.isTraceEnabled())
             log.trace(""%s <-- DATA(%s: #%d, conn_id=%d%s)"", local_addr, sender, seqno, conn_id, first? "", first"" : """");
 
@@ -675,10 +680,8 @@ protected void handleDataReceived(Address sender, long seqno, short conn_id,  bo
         if(entry.state() == State.CLOSING)
             entry.state(State.OPEN);
         boolean oob=msg.isFlagSet(Message.Flag.OOB);
-        if(oob) // done so this thread delivers the message and no work stealing for OOB msgs is performed (JGRP-1733)
-            msg.setTransientFlag(Message.TransientFlag.OOB_DELIVERED);
-        Table<Message> win=entry.received_msgs;
-        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here
+        final Table<Message> win=entry.received_msgs;
+        boolean added=win.add(seqno, oob? DUMMY_OOB_MSG : msg); // adding the same dummy OOB msg saves space (we won't remove it)
         num_msgs_received++;
 
         if(ack_threshold <= 1)
@@ -688,21 +691,25 @@ protected void handleDataReceived(Address sender, long seqno, short conn_id,  bo
 
         // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !
         // http://jira.jboss.com/jira/browse/JGRP-377
-        if(oob && added) {
-            if(log.isTraceEnabled())
-                log.trace(""%s: delivering %s#%s"", local_addr, sender, seqno);
-            try {
-                up_prot.up(evt);
-            }
-            catch(Throwable t) {
-                log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-            }
-        }
+        if(oob && added)
+            deliverMessage(evt, sender, seqno);
 
         // we don't steal work if the message is internal (https://issues.jboss.org/browse/JGRP-1733)
         // we also don't care if the message was added successfully or not
-        if(oob && msg.isFlagSet(Message.Flag.INTERNAL))
+        if(oob && msg.isFlagSet(Message.Flag.INTERNAL)) {
+            // If there are other msgs, tell the regular thread pool to handle them (https://issues.jboss.org/browse/JGRP-1732)
+            final AtomicBoolean processing=win.getProcessing();
+            if(!win.isEmpty() && !processing.get() && seqno < win.getHighestReceived()) {
+                Executor pool=getTransport().getDefaultThreadPool();
+                pool.execute(new Runnable() {
+                    public void run() {
+                        if(processing.compareAndSet(false, true))
+                            removeAndDeliver(processing, win, sender);
+                    }
+                });
+            }
             return;
+        }
 
         final AtomicBoolean processing=win.getProcessing();
         if(processing.compareAndSet(false, true))
@@ -718,7 +725,9 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
         int batch_size=msgs.size();
         Table<Message> win=entry.received_msgs;
         num_msgs_received+=batch_size;
-        boolean added=oob ? win.add(msgs, true) : win.add(msgs);
+
+        // adds all messages to the table, removing messages from 'msgs' which could not be added (already present)
+        boolean added=win.add(msgs, oob, oob? DUMMY_OOB_MSG : null);
 
         if(conn_expiry_timeout > 0)
             entry.update();
@@ -732,20 +741,11 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
 
         // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379
         if(added && oob) {
-            for(Tuple<Long,Message> tuple: msgs) {
-                long    seq=tuple.getVal1();
-                Message msg=tuple.getVal2();
-                if(msg.isFlagSet(Message.Flag.OOB) && msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED)) {
-                    if(log.isTraceEnabled())
-                        log.trace(""%s: delivering %s#%s"", local_addr, sender, seq);
-                    try {
-                        up_prot.up(new Event(Event.MSG, msg));
-                    }
-                    catch(Throwable t) {
-                        log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-                    }
-                }
-            }
+            MessageBatch oob_batch=new MessageBatch(local_addr, sender, null, false, MessageBatch.Mode.OOB, msgs.size());
+            for(Tuple<Long,Message> tuple: msgs)
+                oob_batch.add(tuple.getVal2());
+
+            deliverBatch(oob_batch);
         }
 
         final AtomicBoolean processing=win.getProcessing();
@@ -763,47 +763,22 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
      * delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered in the
      * order in which they were sent
      */
-    protected int removeAndDeliver(final AtomicBoolean processing, Table<Message> win, Address sender) {
-        int retval=0;
+    protected void removeAndDeliver(final AtomicBoolean processing, Table<Message> win, Address sender) {
         boolean released_processing=false;
         try {
             while(true) {
-                List<Message> list=win.removeMany(processing, true, max_msg_batch_size);
-                if(list == null) {
+                List<Message> list=win.removeMany(processing, true, max_msg_batch_size, drop_oob_msgs_filter);
+                if(list != null) // list is guaranteed to NOT contain any OOB messages as the drop_oob_msgs_filter removed them
+                    deliverBatch(new MessageBatch(local_addr, sender, null, false, list));
+                else {
                     released_processing=true;
-                    return retval;
-                }
-
-                MessageBatch batch=new MessageBatch(local_addr, sender, null, false, list);
-                for(Message msg_to_deliver: batch) {
-                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)
-                    if(msg_to_deliver.isFlagSet(Message.Flag.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
-                        batch.remove(msg_to_deliver);
-                }
-                if(batch.isEmpty())
-                    continue;
-
-                try {
-                    if(log.isTraceEnabled()) {
-                        Message first=batch.first(), last=batch.last();
-                        StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
-                        if(first != null && last != null) {
-                            Header hdr1=(Header)first.getHeader(id), hdr2=(Header)last.getHeader(id);
-                            sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
-                        }
-                        sb.append("" ("" + batch.size()).append("" messages)"");
-                        log.trace(sb);
-                    }
-                    up_prot.up(batch);
-                }
-                catch(Throwable t) {
-                    log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+                    return;
                 }
             }
         }
         finally {
             // processing is always set in win.remove(processing) above and never here ! This code is just a
-            // 2nd line of defense should there be an exception before win.remove(processing) sets processing
+            // 2nd line of defense should there be an exception before win.removeMany(processing) sets processing
             if(!released_processing)
                 processing.set(false);
         }
@@ -944,6 +919,40 @@ protected void handleXmitRequest(Address sender, SeqnoList missing) {
         }
     }
 
+    protected void deliverMessage(final Event evt, final Address sender, final long seqno) {
+        if(log.isTraceEnabled())
+            log.trace(""%s: delivering %s#%s"", local_addr, sender, seqno);
+        try {
+            up_prot.up(evt);
+        }
+        catch(Throwable t) {
+            Message msg=(Message)evt.getArg();
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, msg.isFlagSet(Message.Flag.OOB) ?
+              ""OOB message"" : ""message"", msg, t);
+        }
+    }
+
+    protected void deliverBatch(MessageBatch batch) {
+        try {
+            if(batch.isEmpty())
+                return;
+            if(log.isTraceEnabled()) {
+                Message first=batch.first(), last=batch.last();
+                StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
+                if(first != null && last != null) {
+                    Header hdr1=(Header)first.getHeader(id), hdr2=(Header)last.getHeader(id);
+                    sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
+                }
+                sb.append("" ("" + batch.size()).append("" messages)"");
+                log.trace(sb);
+            }
+            up_prot.up(batch);
+        }
+        catch(Throwable t) {
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+        }
+    }
+
 
 
     protected void startRetransmitTask() {",2014-01-10T16:46:08Z,122
"@@ -652,7 +652,7 @@ public void up(MessageBatch batch) {
 
         // Process (new and retransmitted) messages:
         if(msgs != null)
-            handleMessages(batch.sender(), msgs, batch.mode() == MessageBatch.Mode.OOB, batch.clusterName());
+            handleMessages(batch.dest(), batch.sender(), msgs, batch.mode() == MessageBatch.Mode.OOB, batch.clusterName());
 
         // received XMIT-RSPs:
         if(got_retransmitted_msg && rebroadcasting)
@@ -784,7 +784,7 @@ protected void handleMessage(Message msg, NakAckHeader2 hdr) {
     }
 
 
-    protected void handleMessages(Address sender, List<Tuple<Long,Message>> msgs, boolean oob, String cluster_name) {
+    protected void handleMessages(Address dest, Address sender, List<Tuple<Long,Message>> msgs, boolean oob, String cluster_name) {
         Table<Message> buf=xmit_table.get(sender);
         if(buf == null) {  // discard message if there is no entry for sender
             if(leaving)
@@ -810,22 +810,14 @@ protected void handleMessages(Address sender, List<Tuple<Long,Message>> msgs, bo
 
         // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379
         if(added && oob) {
+            MessageBatch oob_batch=new MessageBatch(dest, sender, null, dest == null, MessageBatch.Mode.OOB, msgs.size());
             for(Tuple<Long,Message> tuple: msgs) {
                 long    seq=tuple.getVal1();
                 Message msg=loopback? buf.get(seq) : tuple.getVal2(); // we *have* to get the message, because loopback means we didn't add it to win !
-                if(msg != null && msg.isFlagSet(Message.Flag.OOB)) {
-                    if(msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED)) {
-                        if(log.isTraceEnabled())
-                            log.trace(""%s: delivering %s#%d"", local_addr, sender, seq);
-                        try {
-                            up_prot.up(new Event(Event.MSG, msg));
-                        }
-                        catch(Throwable t) {
-                            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-                        }
-                    }
-                }
+                if(msg != null && msg.isFlagSet(Message.Flag.OOB) && msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
+                    oob_batch.add(msg);
             }
+            deliverBatch(oob_batch);
         }
 
         removeAndPassUp(buf,sender,loopback,cluster_name); // at most 1 thread will execute this at any given time
@@ -859,25 +851,7 @@ protected void removeAndPassUp(Table<Message> buf, Address sender, boolean loopb
                     if(msg_to_deliver.isFlagSet(Message.Flag.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
                         batch.remove(msg_to_deliver);
                 }
-                if(batch.isEmpty())
-                    continue;
-
-                try {
-                    if(log.isTraceEnabled()) {
-                        Message first=batch.first(), last=batch.last();
-                        StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
-                        if(first != null && last != null) {
-                            NakAckHeader2 hdr1=(NakAckHeader2)first.getHeader(id), hdr2=(NakAckHeader2)last.getHeader(id);
-                            sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
-                        }
-                        sb.append("" ("" + batch.size()).append("" messages)"");
-                        log.trace(sb);
-                    }
-                    up_prot.up(batch);
-                }
-                catch(Throwable t) {
-                    log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
-                }
+                deliverBatch(batch);
             }
         }
         finally {
@@ -922,6 +896,27 @@ protected void handleXmitReq(Address xmit_requester, SeqnoList missing_msgs, Add
         }
     }
 
+    protected void deliverBatch(MessageBatch batch) {
+        try {
+            if(batch.isEmpty())
+                return;
+            if(log.isTraceEnabled()) {
+                Message first=batch.first(), last=batch.last();
+                StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
+                if(first != null && last != null) {
+                    NakAckHeader2 hdr1=(NakAckHeader2)first.getHeader(id), hdr2=(NakAckHeader2)last.getHeader(id);
+                    sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
+                }
+                sb.append("" ("" + batch.size()).append("" messages)"");
+                log.trace(sb);
+            }
+            up_prot.up(batch);
+        }
+        catch(Throwable t) {
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+        }
+    }
+
 
     /**
      * Flushes the queue. Done in a separate thread as we don't want to block the",2014-01-10T16:46:08Z,123
"@@ -52,5 +52,7 @@ public void clear() {
             samples[i]=-1;
     }
 
-
+    public String toString() {
+        return String.valueOf(getAverage());
+    }
 }",2014-01-10T16:46:08Z,124
"@@ -0,0 +1,9 @@
+package org.jgroups.util;
+
+/**
+ * @author Bela Ban
+ * @since  3.5
+ */
+public interface Filter<T> {
+    boolean accept(T element);
+}",2014-01-10T16:46:08Z,125
"@@ -92,6 +92,7 @@ public MessageBatch(Address dest, Address sender, String cluster_name, boolean m
     public MessageBatch clusterName(String name) {this.cluster_name=name; return this;}
     public boolean      multicast()              {return multicast;}
     public Mode         mode()                   {return mode;}
+    public MessageBatch mode(Mode mode)          {this.mode=mode; return this;}
     public int          capacity()               {return messages.length;}
 
 
@@ -250,6 +251,17 @@ public String toString() {
         return sb.toString();
     }
 
+    public String printHeaders() {
+        StringBuilder sb=new StringBuilder().append(""dest="" + dest);
+        if(sender != null)
+            sb.append("", sender="").append(sender);
+        sb.append(""\n"").append(size()).append("":\n"");
+        int count=1;
+        for(Message msg: this)
+            sb.append(""#"").append(count++).append("": "").append(msg.printHeaders()).append(""\n"");
+        return sb.toString();
+    }
+
     protected void resize() {
         Message[] tmp=new Message[messages.length + INCR];
         System.arraycopy(messages,0,tmp,0,messages.length);",2014-01-10T16:46:08Z,126
"@@ -106,7 +106,7 @@ public Table(int num_rows, int elements_per_row, long offset, double resize_fact
     /**
      * Creates a new table
      * @param num_rows the number of rows in the matrix
-     * @param elements_per_row the number of messages per row
+     * @param elements_per_row the number of elements per row
      * @param offset the seqno before the first seqno to be inserted. E.g. if 0 then the first seqno will be 1
      * @param resize_factor teh factor with which to increase the number of rows
      * @param max_compaction_time the max time in milliseconds after we attempt a compaction
@@ -151,7 +151,7 @@ public void setMaxCompactionTime(long max_compaction_time) {
     public void resetStats()             {num_compactions=num_moves=num_resizes=num_purges=0;}
 
     /** Returns the highest deliverable (= removable) seqno. This may be higher than {@link #getHighestDelivered()},
-     * e.g. if messages have been added but not yet removed */
+     * e.g. if elements have been added but not yet removed */
     public long getHighestDeliverable() {
         HighestDeliverable visitor=new HighestDeliverable();
         lock.lock();
@@ -190,41 +190,59 @@ public void setHighestDelivered(long seqno) {
     public boolean add(long seqno, T element) {
         lock.lock();
         try {
-            return _add(seqno, element);
+            return _add(seqno, element, true);
         }
         finally {
             lock.unlock();
         }
     }
 
     /**
-     * Adds messages from list to the table
+     * Adds elements from list to the table
      * @param list
-     * @return True if at least 1 message was added successfully
+     * @return True if at least 1 element was added successfully
      */
     public boolean add(final List<Tuple<Long,T>> list) {
        return add(list, false);
     }
 
 
     /**
-     * Adds messages from list to the table, removes messages from list that were not added to the table
+     * Adds elements from list to the table, removes elements from list that were not added to the table
      * @param list
-     * @return True if at least 1 message was added successfully. This guarantees that the list has at least 1 message
+     * @return True if at least 1 element was added successfully. This guarantees that the list has at least 1 element
      */
-    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_msgs) {
-        if(list == null)
+    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_elements) {
+        return add(list, remove_added_elements, null);
+    }
+
+    /**
+     * Adds elements from the list to the table
+     * @param list The list of tuples of seqnos and elements. If remove_added_elements is true, if elements could
+     *             not be added to the table (e.g. because they were already present or the seqno was < HD), those
+     *             elements will be removed from list
+     * @param remove_added_elements If true, elements that could not be added to the table are removed from list
+     * @param const_value If non-null, this value should be used rather than the values of the list tuples
+     * @return True if at least 1 element was added successfully, false otherwise.
+     */
+    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_elements, T const_value) {
+        if(list == null || list.isEmpty())
             return false;
         boolean added=false;
         lock.lock();
         try {
+            // find the highest seqno (unfortunately, the list is not ordered by seqno)
+            long highest_seqno=findHighestSeqno(list);
+            if(highest_seqno != -1 && computeRow(highest_seqno) >= matrix.length)
+                resize(highest_seqno);
+
             for(Iterator<Tuple<Long,T>> it=list.iterator(); it.hasNext();) {
                 Tuple<Long,T> tuple=it.next();
                 long seqno=tuple.getVal1();
-                T element=tuple.getVal2();
-                if(_add(seqno, element))
+                T element=const_value != null? const_value : tuple.getVal2();
+                if(_add(seqno, element, false))
                     added=true;
-                else if(remove_added_msgs)
+                else if(remove_added_elements)
                     it.remove();
             }
             return added;
@@ -339,11 +357,22 @@ public List<T> removeMany(boolean nullify, int max_results) {
         return removeMany(null, nullify, max_results);
     }
 
-
     public List<T> removeMany(final AtomicBoolean processing, boolean nullify, int max_results) {
+        return removeMany(processing, nullify, max_results, null);
+    }
+
+
+    /**
+     * Removes between 0 and max_results elements from the table and returns them in a list. If filter is non-null,
+     * only elements which the filter accepts are returned. Note that elements are always removed from the table,
+     * but may or may not get added to the returned list.
+     * @return A list of element. A null list means no more elements are in the table and processing (if set)
+     * will be set to false
+     */
+    public List<T> removeMany(final AtomicBoolean processing, boolean nullify, int max_results, Filter<T> filter) {
         lock.lock();
         try {
-            Remover remover=new Remover(nullify, max_results);
+            Remover remover=new Remover(nullify, max_results, filter);
             forEach(hd+1, hr, remover);
             List<T> retval=remover.getList();
             if(processing != null && (retval == null || retval.isEmpty()))
@@ -459,12 +488,12 @@ public void forEach(long from, long to, Visitor<T> visitor) {
         }
     }
 
-    protected boolean _add(long seqno, T element) {
+    protected boolean _add(long seqno, T element, boolean check_if_resize_needed) {
         if(seqno <= hd)
             return false;
 
         int row_index=computeRow(seqno);
-        if(row_index >= matrix.length) {
+        if(check_if_resize_needed && row_index >= matrix.length) {
             resize(seqno);
             row_index=computeRow(seqno);
         }
@@ -481,6 +510,17 @@ protected boolean _add(long seqno, T element) {
         return false;
     }
 
+    // list must not be null or empty
+    protected long findHighestSeqno(List<Tuple<Long,T>> list) {
+        long seqno=-1;
+        for(Tuple<Long,T> tuple: list) {
+            Long val=tuple.getVal1();
+            if(val != null && val > seqno)
+                seqno=val;
+        }
+        return seqno;
+    }
+
     /** Moves rows down the matrix, by removing purged rows. If resizing to accommodate seqno is still needed, computes
      * a new size. Then either moves existing rows down, or copies them into a new array (if resizing took place).
      * The lock must be held by the caller of resize(). */
@@ -563,7 +603,7 @@ public int getNumMissing() {
 
 
     /**
-     * Returns a list of missing (= null) messages
+     * Returns a list of missing (= null) elements
      * @return
      */
     public SeqnoList getMissing() {
@@ -681,33 +721,45 @@ public boolean visit(long seqno, T element, int row, int column) {
 
 
     protected class Remover implements Visitor<T> {
-        protected final boolean nullify;
-        protected final int     max_results;
-        protected List<T>       list;
-        protected int           num_results;
+        protected final boolean      nullify;
+        protected final int          max_results;
+        protected List<T>            list;
+        protected int                num_results;
+        protected final Filter<T>    filter;
 
         public Remover(boolean nullify, int max_results) {
+            this(nullify, max_results, null);
+        }
+
+        public Remover(boolean nullify, int max_results, Filter<T> filter) {
             this.nullify=nullify;
             this.max_results=max_results;
+            this.filter=filter;
         }
 
         public List<T> getList() {return list;}
 
         @GuardedBy(""lock"")
         public boolean visit(long seqno, T element, int row, int column) {
             if(element != null) {
-                if(list == null)
-                    list=new LinkedList<T>();
-                list.add(element);
+                if(filter == null || filter.accept(element)) {
+                    if(list == null)
+                        list=new LinkedList<T>();
+                    list.add(element);
+                    num_results++;
+                }
                 if(seqno > hd)
                     hd=seqno;
                 size=Math.max(size-1, 0); // cannot be < 0 (well that would be a bug, but let's have this 2nd line of defense !)
                 if(nullify) {
                     matrix[row][column]=null;
+                    // if we're nulling the last element of a row, null the row as well
+                    if(column == elements_per_row-1)
+                        matrix[row]=null;
                     if(seqno > low)
                         low=seqno;
                 }
-                return max_results == 0 || ++num_results < max_results;
+                return max_results == 0 || num_results < max_results;
             }
             return false;
         }",2014-01-10T16:46:08Z,127
"@@ -1,10 +1,7 @@
 package org.jgroups.tests;
 
 import org.jgroups.Global;
-import org.jgroups.util.SeqnoList;
-import org.jgroups.util.Table;
-import org.jgroups.util.Tuple;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 import org.testng.annotations.Test;
 
 import java.util.ArrayList;
@@ -44,6 +41,25 @@ public void testAddList() {
         assert buf.size() == 2;
     }
 
+    public void testAddListWithConstValue() {
+        Table<Integer> buf=new Table<Integer>(3, 10, 0);
+        List<Tuple<Long,Integer>> msgs=createList(1,2,3,4,5,6,7,8,9,10);
+        final Integer DUMMY=0;
+        boolean rc=buf.add(msgs, false, DUMMY);
+        System.out.println(""buf = "" + buf);
+        assert rc;
+        assert buf.size() == 10;
+        List<Integer> list=buf.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {
+                return element.hashCode() == DUMMY.hashCode();
+            }
+        });
+        System.out.println(""list = "" + list);
+        assert list.size() == 10;
+        for(int num: list)
+            assert num == DUMMY;
+    }
+
     public void testAddListWithRemoval() {
         Table<Integer> buf=new Table<Integer>(3, 10, 0);
         List<Tuple<Long,Integer>> msgs=createList(1,2,3,4,5,6,7,8,9,10);
@@ -126,6 +142,29 @@ public static void testAdditionListWithOffset() {
     }
 
 
+    public static void testAddListWithResizing() {
+        Table<Integer> table=new Table<Integer>(3, 5, 0);
+        List<Tuple<Long,Integer>> msgs=new ArrayList<Tuple<Long,Integer>>();
+        for(int i=1; i < 100; i++)
+            msgs.add(new Tuple<Long,Integer>((long)i,i));
+        table.add(msgs, false);
+        System.out.println(""table = "" + table);
+        int num_resizes=table.getNumResizes();
+        System.out.println(""num_resizes = "" + num_resizes);
+        assert num_resizes == 1 : ""number of resizings="" + num_resizes + "" (expected 1)"";
+    }
+
+    public static void testAddListWithResizing2() {
+        Table<Integer> table=new Table<Integer>(3, 500, 0);
+        List<Tuple<Long,Integer>> msgs=new ArrayList<Tuple<Long,Integer>>();
+        for(int i=1; i < 100; i++)
+            msgs.add(new Tuple<Long,Integer>((long)i,i));
+        table.add(msgs, false);
+        System.out.println(""table = "" + table);
+        int num_resizes=table.getNumResizes();
+        System.out.println(""num_resizes = "" + num_resizes);
+        assert num_resizes == 0 : ""number of resizings="" + num_resizes + "" (expected 0)"";
+    }
 
     public static void testAdditionWithOffset2() {
         Table<Integer> table=new Table<Integer>(3, 10, 2);
@@ -540,6 +579,60 @@ public static void testRemoveManyWithWrapping2() {
         assert table.size() == 6 && table.getNumMissing() == 2;
     }
 
+    public static void testRemoveManyWithFilter() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {
+                return element % 2 == 0;
+            }
+        });
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 5;
+        assert table.isEmpty();
+        for(Integer num: Arrays.asList(2,4,6,8,10))
+            assert list.contains(num);
+    }
+
+    public static void testRemoveManyWithFilterAcceptAll() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {return true;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 10;
+        assert table.isEmpty();
+    }
+
+    public static void testRemoveManyWithFilterAcceptNone() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {return false;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list == null;
+        assert table.isEmpty();
+    }
+
+    public static void testRemoveManyWithFilterAcceptNone2() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,3,new Filter<Integer>() {
+            int cnt=0;
+            public boolean accept(Integer element) {return ++cnt <= 2;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 2;
+        assert table.isEmpty();
+    }
+
 
     public static void testForEach() {
         class MyVisitor<T> implements Table.Visitor<T> {
@@ -804,10 +897,10 @@ public static void testResize() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
         addAndGet(table, 30);
-        addAndGet(table, 35);
-        assertCapacity(table.capacity(), table.getNumRows(), 10);
-        addAndGet(table, 500);
+        addAndGet(table,35);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
+        addAndGet(table,500);
+        assertCapacity(table.capacity(),table.getNumRows(),10);
 
         addAndGet(table, 515);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
@@ -828,7 +921,7 @@ public void testResizeWithPurge() {
 
         table.purge(50);
         System.out.println(""now triggering a resize() by addition of seqno=120"");
-        addAndGet(table, 120);
+        addAndGet(table,120);
         
     }
 
@@ -888,7 +981,7 @@ public void testResizeWithPurge2() {
         assertIndices(table, 0, 43, 50);
         table.purge(43);
         System.out.println(""table = "" + table);
-        assertIndices(table, 43, 43, 50);
+        assertIndices(table,43,43,50);
         addAndGet(table, 52);
         assert table.get(43) == null;
 
@@ -919,10 +1012,10 @@ public static void testMove() {
     public static void testMove2() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         for(int i=1; i < 30; i++)
-            table.add(i, i);
+            table.add(i,i);
         table.removeMany(true, 23);
         System.out.println(""table = "" + table);
-        table.add(35, 35); // triggers a resize() --> move()
+        table.add(35,35); // triggers a resize() --> move()
         for(int i=1; i <= 23; i++)
             assert table._get(i) == null;
         for(int i=24; i < 30; i++)
@@ -1017,7 +1110,7 @@ public void testPurge4() {
         for(int i=1; i <= 100; i++)
             table.add(i, i);
         System.out.println(""table = "" + table);
-        table.removeMany(false, 53);
+        table.removeMany(false,53);
         table.purge(53);
         for(int i=54; i <= 100; i++)
             assert table.get(i) == i;
@@ -1057,7 +1150,7 @@ public void testPurgeForce() {
         for(int i=1; i <= 30; i++)
             table.add(i, i);
         System.out.println(""table = "" + table);
-        table.purge(15, true);
+        table.purge(15,true);
         System.out.println(""table = "" + table);
         assertIndices(table, 15, 15, 30);
         for(int i=1; i <= 15; i++)
@@ -1089,20 +1182,20 @@ public void testPurgeForce() {
     public void testCompact() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         for(int i=1; i <= 80; i++)
-            addAndGet(table, i);
+            addAndGet(table,i);
         assert table.size() == 80;
-        assertIndices(table, 0, 0, 80);
+        assertIndices(table,0,0,80);
         List<Integer> list=table.removeMany(false,60);
         assert list.size() == 60;
         assert list.get(0) == 1 && list.get(list.size() -1) == 60;
         assertIndices(table, 0, 60, 80);
         table.purge(60);
-        assertIndices(table, 60, 60, 80);
+        assertIndices(table,60,60,80);
         assert table.size() == 20;
         table.compact();
-        assertIndices(table, 60, 60, 80);
+        assertIndices(table,60,60,80);
         assert table.size() == 20;
-        assertCapacity(table.capacity(), table.getNumRows(), 10);
+        assertCapacity(table.capacity(),table.getNumRows(),10);
     }
 
 ",2014-01-10T16:46:08Z,128
"@@ -763,6 +763,27 @@ public void readFrom(DataInput in) throws Exception {
             if(type == DATA)
                 seqno=Util.readLong(in);
         }
+
+        public String toString() {
+            return typeToString(type) + (seqno > 0? seqno : """");
+        }
+
+        protected static String typeToString(byte type) {
+            switch(type) {
+                case DATA:          return ""DATA"";
+                case START_SENDING: return ""START_SENDING"";
+                case SENDING_DONE:  return ""SENDING_DONE"";
+                case RESULT:        return ""RESULT"";
+                case CLEAR_RESULTS: return ""CLEAR_RESULTS"";
+                case CONFIG_CHANGE: return ""CONFIG_CHANGE"";
+                case CONFIG_REQ:    return ""CONFIG_REQ"";
+                case CONFIG_RSP:    return ""CONFIG_RSP"";
+                case EXIT:          return ""EXIT"";
+                case NEW_CONFIG:    return ""NEW_CONFIG"";
+                case ACK:           return ""ACK"";
+                default:            return ""n/a"";
+            }
+        }
     }
 
 ",2014-01-10T16:46:08Z,129
"@@ -45,6 +45,7 @@ public class UPerf extends ReceiverAdapter {
     @Property protected boolean use_anycast_addrs;
     @Property protected boolean msg_bundling=true;
     @Property protected double  read_percentage=0.8; // 80% reads, 20% writes
+    @Property protected boolean get_before_put=false; // invoke a sync GET before a PUT
     // ... add your own here, just don't forget to annotate them with @Property
     // =======================================================
 
@@ -172,7 +173,7 @@ public Results startTest() throws Throwable {
         }
 
         long total_time=System.currentTimeMillis() - start;
-        System.out.println(""done (in "" + total_time + "" ms)"");
+        System.out.println(""\ndone (in "" + total_time + "" ms)"");
         return new Results(total_gets, total_puts, total_time);
     }
 
@@ -227,7 +228,7 @@ public void eventLoop() throws Throwable {
                               ""[8] Set msg size ("" + Util.printBytes(msg_size) + "")"" +
                               "" [9] Set anycast count ("" + anycast_count + "")"" +
                               ""\n[o] Toggle OOB ("" + oob + "") [s] Toggle sync ("" + sync +
-                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") "" +
+                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") [g] get_before_put ("" + get_before_put + "") "" +
                               ""\n[a] Toggle use_anycast_addrs ("" + use_anycast_addrs + "") [b] Toggle msg_bundling ("" +
                               (msg_bundling? ""on"" : ""off"") + "")"" +
                               ""\n[q] Quit\n"");
@@ -271,6 +272,9 @@ public void eventLoop() throws Throwable {
                 case 'b':
                     changeFieldAcrossCluster(""msg_bundling"", !msg_bundling);
                     break;
+                case 'g':
+                    changeFieldAcrossCluster(""get_before_put"", !get_before_put);
+                    break;
                 case 'q':
                     channel.close();
                     return;
@@ -286,7 +290,7 @@ public void eventLoop() throws Throwable {
 
     /** Kicks off the benchmark on all cluster nodes */
     void startBenchmark() {
-        RspList<Object> responses=null;
+        RspList<Results> responses=null;
         try {
             RequestOptions options=new RequestOptions(ResponseMode.GET_ALL, 0);
             options.setFlags(Message.Flag.OOB, Message.Flag.DONT_BUNDLE, Message.Flag.NO_FC);
@@ -301,10 +305,10 @@ void startBenchmark() {
         long total_time=0;
 
         System.out.println(""\n======================= Results: ==========================="");
-        for(Map.Entry<Address,Rsp<Object>> entry: responses.entrySet()) {
+        for(Map.Entry<Address,Rsp<Results>> entry: responses.entrySet()) {
             Address mbr=entry.getKey();
-            Rsp rsp=entry.getValue();
-            Results result=(Results)rsp.getValue();
+            Rsp<Results> rsp=entry.getValue();
+            Results result=rsp.getValue();
             total_reqs+=result.num_gets + result.num_puts;
             total_time+=result.time;
             System.out.println(mbr + "": "" + result);
@@ -381,12 +385,14 @@ private class Invoker extends Thread {
         private final AtomicInteger  num_msgs_sent;
         private int                  num_gets=0;
         private int                  num_puts=0;
+        private final int            PRINT;
 
 
         public Invoker(Collection<Address> dests, int num_msgs_to_send, AtomicInteger num_msgs_sent) {
             this.num_msgs_sent=num_msgs_sent;
             this.dests.addAll(dests);
             this.num_msgs_to_send=num_msgs_to_send;
+            PRINT=num_msgs_to_send / 10;
             setName(""Invoker-"" + COUNTER.getAndIncrement());
         }
 
@@ -403,6 +409,7 @@ public void run() {
             MethodCall put_call=new MethodCall(PUT, put_args);
             RequestOptions get_options=new RequestOptions(ResponseMode.GET_ALL, 40000, false, null);
             RequestOptions put_options=new RequestOptions(sync ? ResponseMode.GET_ALL : ResponseMode.GET_NONE, 40000, true, null);
+            RequestOptions get_before_put_options=new RequestOptions(ResponseMode.GET_FIRST, 40000, true, null, Message.Flag.DONT_BUNDLE, Message.Flag.OOB);
 
             if(oob) {
                 get_options.setFlags(Message.Flag.OOB);
@@ -419,6 +426,8 @@ public void run() {
                 long i=num_msgs_sent.getAndIncrement();
                 if(i >= num_msgs_to_send)
                     break;
+                if(i > 0 && i % PRINT == 0)
+                    System.out.print(""."");
                 
                 boolean get=Util.tossWeightedCoin(read_percentage);
 
@@ -430,7 +439,13 @@ public void run() {
                         num_gets++;
                     }
                     else {    // sync or async (based on value of 'sync') PUT
-                        Collection<Address> targets=pickAnycastTargets();
+                        final Collection<Address> targets=pickAnycastTargets();
+                        if(get_before_put) {
+                            // sync GET
+                            get_args[0]=i;
+                            disp.callRemoteMethods(targets, get_call, get_before_put_options);
+                            num_gets++;
+                        }
                         put_args[0]=i;
                         disp.callRemoteMethods(targets, put_call, put_options);
                         num_puts++;",2014-01-10T16:46:08Z,130
"@@ -1,835 +0,0 @@
-package org.jgroups.tests.perf;
-
-import org.jgroups.*;
-import org.jgroups.blocks.*;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.jmx.JmxConfigurator;
-import org.jgroups.protocols.UNICAST;
-import org.jgroups.protocols.UNICAST2;
-import org.jgroups.protocols.relay.RELAY2;
-import org.jgroups.protocols.relay.SiteMaster;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.*;
-
-import javax.management.MBeanServer;
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.lang.reflect.Method;
-import java.nio.ByteBuffer;
-import java.text.NumberFormat;
-import java.util.*;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Tests the UNICAST by invoking unicast RPCs between a sender and a receiver. Mimicks the DIST mode in Infinispan
- *
- * @author Bela Ban
- */
-public class UPerf2 extends ReceiverAdapter {
-    private JChannel               channel;
-    private Address                local_addr;
-    private RpcDispatcher          disp;
-    static final String            groupname=""uperf"";
-    protected final List<Address>  members=new ArrayList<Address>();
-    protected final List<Address>  site_masters=new ArrayList<Address>();
-    public static Random random = new Random();
-
-
-    // ============ configurable properties ==================
-    private boolean sync=false, oob=false;
-    private int num_threads=1;
-    private int num_msgs=5000, msg_size=1000;
-    private int anycast_count=2;
-    private boolean use_anycast_addrs;
-    private boolean msg_bundling=true;
-    private double read_percentage=0; // 80% reads, 20% writes
-    // =======================================================
-
-    private static final Method[] METHODS=new Method[16];
-
-    private static final short START                 =  0;
-    private static final short SET_OOB               =  1;
-    private static final short SET_SYNC              =  2;
-    private static final short SET_NUM_MSGS          =  3;
-    private static final short SET_NUM_THREADS       =  4;
-    private static final short SET_MSG_SIZE          =  5;
-    private static final short SET_ANYCAST_COUNT     =  6;
-    private static final short SET_USE_ANYCAST_ADDRS =  7;
-    private static final short SET_READ_PERCENTAGE   =  8;
-    private static final short GET                   =  9;
-    private static final short PUT                   = 10;
-    private static final short GET_CONFIG            = 11;
-    private static final short SET_MSB_BUNDLING      = 12;
-
-    private final AtomicInteger COUNTER=new AtomicInteger(1);
-    private byte[] GET_RSP=new byte[msg_size];
-
-    static NumberFormat f;
-
-
-    static {
-        try {
-            METHODS[START]                 = UPerf2.class.getMethod(""startTest"");
-            METHODS[SET_OOB]               = UPerf2.class.getMethod(""setOOB"", boolean.class);
-            METHODS[SET_SYNC]              = UPerf2.class.getMethod(""setSync"", boolean.class);
-            METHODS[SET_NUM_MSGS]          = UPerf2.class.getMethod(""setNumMessages"", int.class);
-            METHODS[SET_NUM_THREADS]       = UPerf2.class.getMethod(""setNumThreads"", int.class);
-            METHODS[SET_MSG_SIZE]          = UPerf2.class.getMethod(""setMessageSize"", int.class);
-            METHODS[SET_ANYCAST_COUNT]     = UPerf2.class.getMethod(""setAnycastCount"", int.class);
-            METHODS[SET_USE_ANYCAST_ADDRS] = UPerf2.class.getMethod(""setUseAnycastAddrs"", boolean.class);
-            METHODS[SET_READ_PERCENTAGE]   = UPerf2.class.getMethod(""setReadPercentage"", double.class);
-            METHODS[GET]                   = UPerf2.class.getMethod(""get"", long.class);
-            METHODS[PUT]                   = UPerf2.class.getMethod(""put"", long.class, byte[].class);
-            METHODS[GET_CONFIG]            = UPerf2.class.getMethod(""getConfig"");
-            METHODS[SET_MSB_BUNDLING]       = UPerf2.class.getMethod(""setMsgBundling"", boolean.class);
-
-            ClassConfigurator.add((short)11000, Results.class);
-            f=NumberFormat.getNumberInstance();
-            f.setGroupingUsed(false);
-            f.setMinimumFractionDigits(2);
-            f.setMaximumFractionDigits(2);
-        }
-        catch(NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-
-    public void init(String props, String name, boolean xsite) throws Throwable {
-        channel=new JChannel(props);
-        if(name != null)
-            channel.setName(name);
-        disp=new RpcDispatcher(channel, null, this, this);
-        disp.setMethodLookup(new MethodLookup() {
-            public Method findMethod(short id) {
-                return METHODS[id];
-            }
-        });
-        disp.setRequestMarshaller(new CustomMarshaller());
-        channel.connect(groupname);
-        local_addr=channel.getAddress();
-
-        if(xsite) {
-            List<String> site_names=getSites(channel);
-            for(String site_name: site_names) {
-                try {
-                    SiteMaster sm=new SiteMaster(site_name);
-                    site_masters.add(sm);
-                }
-                catch(Throwable t) {
-                    System.err.println(""failed creating site master: "" + t);
-                }
-            }
-        }
-
-        try {
-            MBeanServer server=Util.getMBeanServer();
-            JmxConfigurator.registerChannel(channel, server, ""jgroups"", channel.getClusterName(), true);
-        }
-        catch(Throwable ex) {
-            System.err.println(""registering the channel in JMX failed: "" + ex);
-        }
-
-        if(members.size() < 2)
-            return;
-        Address coord=members.get(0);
-        ConfigOptions config=(ConfigOptions)disp.callRemoteMethod(coord, new MethodCall(GET_CONFIG), new RequestOptions(ResponseMode.GET_ALL, 5000));
-        if(config != null) {
-            this.oob=config.oob;
-            this.msg_bundling=config.msg_bundling;
-            this.sync=config.sync;
-            this.num_threads=config.num_threads;
-            this.num_msgs=config.num_msgs;
-            this.msg_size=config.msg_size;
-            this.anycast_count=config.anycast_count;
-            this.use_anycast_addrs=config.use_anycast_addrs;
-            this.read_percentage=config.read_percentage;
-            System.out.println(""Fetched config from "" + coord + "": "" + config);
-        }
-        else
-            System.err.println(""failed to fetch config from "" + coord);
-    }
-
-    void stop() {
-        if(disp != null)
-            disp.stop();
-        Util.close(channel);
-    }
-
-    public void viewAccepted(View new_view) {
-        System.out.println(""** view: "" + new_view);
-        members.clear();
-        members.addAll(new_view.getMembers());
-        addSiteMastersToMembers();
-    }
-
-    protected void addSiteMastersToMembers() {
-        if(!site_masters.isEmpty()) {
-            for(Address sm: site_masters)
-                if(!members.contains(sm))
-                    members.add(sm);
-        }
-    }
-
-    // =================================== callbacks ======================================
-
-    public Results startTest() throws Throwable {
-
-        addSiteMastersToMembers();
-
-        System.out.println(""invoking "" + num_msgs + "" RPCs of "" + Util.printBytes(msg_size) + "", sync="" + sync +
-                             "", oob="" + oob + "", msg_bundling="" + msg_bundling + "", use_anycast_addrs="" + use_anycast_addrs);
-        int total_gets=0, total_puts=0;
-        final AtomicInteger num_msgs_sent=new AtomicInteger(0);
-
-        Invoker[] invokers=new Invoker[num_threads];
-        for(int i=0; i < invokers.length; i++)
-            invokers[i]=new Invoker(members, num_msgs, num_msgs_sent);
-
-        long start=System.currentTimeMillis();
-        for(Invoker invoker: invokers)
-            invoker.start();
-
-        for(Invoker invoker: invokers) {
-            invoker.join();
-            total_gets+=invoker.numGets();
-            total_puts+=invoker.numPuts();
-        }
-
-        long total_time=System.currentTimeMillis() - start;
-        System.out.println(""\ndone (in "" + total_time + "" ms)"");
-        return new Results(total_gets, total_puts, total_time);
-    }
-
-
-    public void setOOB(boolean oob) {
-        this.oob=oob;
-        System.out.println(""oob="" + oob);
-    }
-
-    public void setMsgBundling(boolean msg_bundling) {
-        this.msg_bundling=msg_bundling;
-        System.out.println(""msg_bundling = "" + this.msg_bundling);
-      }
-
-    public void setSync(boolean val) {
-        this.sync=val;
-        System.out.println(""sync="" + sync);
-    }
-
-    public void setNumMessages(int num) {
-        num_msgs=num;
-        System.out.println(""num_msgs = "" + num_msgs);
-    }
-
-    public void setNumThreads(int num) {
-        num_threads=num;
-        System.out.println(""num_threads = "" + num_threads);
-    }
-
-    public void setMessageSize(int num) {
-        msg_size=num;
-        System.out.println(""msg_size = "" + msg_size);
-    }
-
-    public void setAnycastCount(int num) {
-        anycast_count=num;
-        System.out.println(""anycast_count = "" + anycast_count);
-    }
-
-    public void setUseAnycastAddrs(boolean flag) {
-        use_anycast_addrs=flag;
-        System.out.println(""use_anycast_addrs = "" + use_anycast_addrs);
-    }
-
-    public void setReadPercentage(double val) {
-        this.read_percentage=val;
-        System.out.println(""read_percentage = "" + read_percentage);
-    }
-
-    public byte[] get(long key) {
-        return GET_RSP;
-    }
-
-
-    public void put(long key, byte[] val) {
-        
-    }
-
-    public ConfigOptions getConfig() {
-        return new ConfigOptions(oob, sync,msg_bundling,
-                                 num_threads, num_msgs, msg_size, anycast_count, use_anycast_addrs, read_percentage);
-    }
-
-    // ================================= end of callbacks =====================================
-
-
-    public void eventLoop() throws Throwable {
-        int c;
-
-        addSiteMastersToMembers();
-
-        while(true) {
-            c=Util.keyPress(""[1] Send msgs [2] Print view [3] Print conns "" +
-                              ""[4] Trash conn [5] Trash all conns"" +
-                              ""\n[6] Set sender threads ("" + num_threads + "") [7] Set num msgs ("" + num_msgs + "") "" +
-                              ""[8] Set msg size ("" + Util.printBytes(msg_size) + "")"" +
-                              "" [9] Set anycast count ("" + anycast_count + "")"" +
-                              ""\n[o] Toggle OOB ("" + oob + "") [s] Toggle sync ("" + sync +
-                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") "" +
-                              ""\n[a] Toggle use_anycast_addrs ("" + use_anycast_addrs + "") [b] Toggle msg_bundling ("" +
-                              (msg_bundling? ""on"" : ""off"") + "")"" +
-                              ""\n[q] Quit\n"");
-            switch(c) {
-                case -1:
-                    break;
-                case '1':
-                    try {
-                        startBenchmark();
-                    }
-                    catch(Throwable t) {
-                        System.err.println(t);
-                    }
-                    break;
-                case '2':
-                    printView();
-                    break;
-                case '3':
-                    printConnections();
-                    break;
-                case '4':
-                    removeConnection();
-                    break;
-                case '5':
-                    removeAllConnections();
-                    break;
-                case '6':
-                    setSenderThreads();
-                    break;
-                case '7':
-                    setNumMessages();
-                    break;
-                case '8':
-                    setMessageSize();
-                    break;
-                case '9':
-                    setAnycastCount();
-                    break;
-                case 'a':
-                    boolean new_value=!use_anycast_addrs;
-                    disp.callRemoteMethods(null, new MethodCall(SET_USE_ANYCAST_ADDRS, new_value), RequestOptions.SYNC());
-                    break;
-                case 'o':
-                    new_value=!oob;
-                    disp.callRemoteMethods(null, new MethodCall(SET_OOB, new_value), RequestOptions.SYNC());
-                    break;
-                case 's':
-                    boolean new_val=!sync;
-                    disp.callRemoteMethods(null, new MethodCall(SET_SYNC, new_val), RequestOptions.SYNC());
-                    break;
-                case 'r':
-                    setReadPercentage();
-                    break;
-                case 'b':
-                    new_value=!msg_bundling;
-                    disp.callRemoteMethods(null, new MethodCall(SET_MSB_BUNDLING, new_value), RequestOptions.SYNC());
-                    break;
-                case 'q':
-                    channel.close();
-                    return;
-                case '\n':
-                case '\r':
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    private void printConnections() {
-        Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-        if(prot instanceof UNICAST)
-            System.out.println(""connections:\n"" + ((UNICAST)prot).printConnections());
-        else if(prot instanceof UNICAST2)
-            System.out.println(""connections:\n"" + ((UNICAST2)prot).printConnections());
-    }
-
-    private void removeConnection() {
-       Address member=getReceiver();
-        if(member != null) {
-            Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-            if(prot instanceof UNICAST)
-                ((UNICAST)prot).removeConnection(member);
-            else if(prot instanceof UNICAST2)
-                ((UNICAST2)prot).removeConnection(member);
-        }
-    }
-
-    private void removeAllConnections() {
-        Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-        if(prot instanceof UNICAST)
-            ((UNICAST)prot).removeAllConnections();
-        else if(prot instanceof UNICAST2)
-            ((UNICAST2)prot).removeAllConnections();
-    }
-
-
-    /** Kicks off the benchmark on all cluster nodes */
-    void startBenchmark() throws Throwable {
-        RequestOptions options=new RequestOptions(ResponseMode.GET_ALL, 0);
-        options.setFlags(Message.Flag.OOB, Message.Flag.DONT_BUNDLE, Message.Flag.NO_FC);
-        RspList<Object> responses=disp.callRemoteMethods(null, new MethodCall(START), options);
-
-        long total_reqs=0;
-        long total_time=0;
-
-        System.out.println(""\n======================= Results: ==========================="");
-        for(Map.Entry<Address,Rsp<Object>> entry: responses.entrySet()) {
-            Address mbr=entry.getKey();
-            Rsp rsp=entry.getValue();
-            Results result=(Results)rsp.getValue();
-            total_reqs+=result.num_gets + result.num_puts;
-            total_time+=result.time;
-            System.out.println(mbr + "": "" + result);
-        }
-        double total_reqs_sec=total_reqs / ( total_time/ 1000.0);
-        double throughput=total_reqs_sec * msg_size;
-        double ms_per_req=total_time / (double)total_reqs;
-        Protocol prot=channel.getProtocolStack().findProtocol(new Class[]{UNICAST.class, UNICAST2.class});
-        System.out.println(""\n"");
-        System.out.println(Util.bold(""Average of "" + f.format(total_reqs_sec) + "" requests / sec ("" +
-                                       Util.printBytes(throughput) + "" / sec), "" +
-                                       f.format(ms_per_req) + "" ms /request (prot="" + (prot != null? prot.getName() : ""n/a"") + "")""));
-        System.out.println(""\n\n"");
-    }
-    
-
-    void setSenderThreads() throws Exception {
-        int threads=Util.readIntFromStdin(""Number of sender threads: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_NUM_THREADS, threads), RequestOptions.SYNC());
-    }
-
-    void setNumMessages() throws Exception {
-        int tmp=Util.readIntFromStdin(""Number of RPCs: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_NUM_MSGS, tmp), RequestOptions.SYNC());
-    }
-
-    void setMessageSize() throws Exception {
-        int tmp=Util.readIntFromStdin(""Message size: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_MSG_SIZE, tmp), RequestOptions.SYNC());
-    }
-
-    void setReadPercentage() throws Exception {
-        double tmp=Util.readDoubleFromStdin(""Read percentage: "");
-        if(tmp < 0 || tmp > 1.0) {
-            System.err.println(""read percentage must be >= 0 or <= 1.0"");
-            return;
-        }
-        disp.callRemoteMethods(null, new MethodCall(SET_READ_PERCENTAGE, tmp), RequestOptions.SYNC());
-    }
-
-    void setAnycastCount() throws Exception {
-        int tmp=Util.readIntFromStdin(""Anycast count: "");
-        View view=channel.getView();
-        if(tmp > view.size()) {
-            System.err.println(""anycast count must be smaller or equal to the view size ("" + view + "")\n"");
-            return;
-        }
-        disp.callRemoteMethods(null, new MethodCall(SET_ANYCAST_COUNT, tmp), RequestOptions.SYNC());
-    }
-
-
-
-    void printView() {
-        System.out.println(""\n-- view: "" + members + '\n');
-        try {
-            System.in.skip(System.in.available());
-        }
-        catch(Exception e) {
-        }
-    }
-
-    protected static List<String> getSites(JChannel channel) {
-        RELAY2 relay=(RELAY2)channel.getProtocolStack().findProtocol(RELAY2.class);
-        return new ArrayList<String>(0);
-    }
-
-    /** Picks the next member in the view */
-    private Address getReceiver() {
-        try {
-            List<Address> mbrs=channel.getView().getMembers();
-            int index=mbrs.indexOf(local_addr);
-            int new_index=index + 1 % mbrs.size();
-            return mbrs.get(new_index);
-        }
-        catch(Exception e) {
-            System.err.println(""UPerf.getReceiver(): "" + e);
-            return null;
-        }
-    }
-
-    private class Invoker extends Thread {
-        private final List<Address>  dests=new ArrayList<Address>();
-        private final int            num_msgs_to_send;
-        private final AtomicInteger  num_msgs_sent;
-        private final int            PRINT;
-        private int                  num_gets=0;
-        private int                  num_puts=0;
-
-
-        public Invoker(Collection<Address> dests, int num_msgs_to_send, AtomicInteger num_msgs_sent) {
-            this.num_msgs_sent=num_msgs_sent;
-            this.dests.addAll(dests);
-            this.num_msgs_to_send=num_msgs_to_send;
-            PRINT=num_msgs_to_send / 10;
-            setName(""Invoker-"" + COUNTER.getAndIncrement());
-        }
-
-        
-        public int numGets() {return num_gets;}
-        public int numPuts() {return num_puts;}
-
-
-        public void run() {
-            final byte[] buf=new byte[msg_size];
-            Object[] put_args={0, buf};
-            Object[] get_args={0};
-            MethodCall get_call=new MethodCall(GET, get_args);
-            MethodCall put_call=new MethodCall(PUT, put_args);
-            RequestOptions get_options=new RequestOptions(ResponseMode.GET_ALL, 40000, false, null);
-            RequestOptions put_options=new RequestOptions(sync ? ResponseMode.GET_ALL : ResponseMode.GET_NONE, 40000, true, null);
-            RequestOptions get_before_put_options = new RequestOptions(ResponseMode.GET_FIRST, 40000, true, null);
-
-            if(oob) {
-                get_options.setFlags(Message.Flag.OOB);
-                put_options.setFlags(Message.Flag.OOB);
-            }
-            get_before_put_options.setFlags(Message.Flag.OOB);
-
-            if(!msg_bundling) {
-                get_options.setFlags(Message.Flag.DONT_BUNDLE);
-                put_options.setFlags(Message.Flag.DONT_BUNDLE);
-            }
-            get_before_put_options.setFlags(Message.Flag.DONT_BUNDLE);
-
-            if(use_anycast_addrs)
-                put_options.useAnycastAddresses(true);
-            get_before_put_options.setFlags(Message.Flag.DONT_BUNDLE);
-
-            while(true) {
-                long i=num_msgs_sent.getAndIncrement();
-                if(i >= num_msgs_to_send)
-                    break;
-                if(i % PRINT == 0)
-                    System.out.print(""."");
-                
-                try {
-                    // sync GET
-                    Collection<Address> targets=pickAnycastTargets();
-                    get_args[0]=i;
-                    //System.out.println(""GET: targets="" + targets);
-                    disp.callRemoteMethods(targets, get_call, get_before_put_options);
-                    num_gets++;
-
-                    // sync or async (based on value of 'sync') PUT
-                    put_args[0]=i;
-                    //System.out.println(""PUT: targets="" + targets);
-                    disp.callRemoteMethods(targets, put_call, put_options);
-                    num_puts++;
-                }
-                catch(Throwable throwable) {
-                    throwable.printStackTrace();
-                }
-            }
-        }
-
-        private Address pickTarget() {
-            int index=dests.indexOf(local_addr);
-            int new_index=(index +1) % dests.size();
-            return dests.get(new_index);
-        }
-
-        private Collection<Address> pickAnycastTargets() {
-            Collection<Address> anycast_targets=new ArrayList<Address>(anycast_count);
-            int index=dests.indexOf(local_addr);
-            for(int i=index + 1; i < index + 1 + anycast_count; i++) {
-                int new_index=i % dests.size();
-                Address tmp=dests.get(new_index);
-                if(!anycast_targets.contains(tmp))
-                    anycast_targets.add(tmp);
-            }
-            return anycast_targets;
-        }
-
-        private List<Address> pickGetTargets() {
-            List<Address> members = dests;
-            int size = members.size() - 1;
-            int startIndex = random.nextInt(size);
-
-            // self also has the keys for the previous numOwners - 1 nodes
-            if (startIndex >= members.size() - anycast_count)
-                return null;
-
-            int numTargets = Math.min(anycast_count, members.size() - 1);
-            List<Address> targets = new ArrayList<Address>(numTargets);
-            for (int i = 0; i < numTargets; ++i) {
-                targets.add(members.get((startIndex + i) % size));
-            }
-            return targets;
-        }
-
-        private Collection<Address> pickPutTargets() {
-            List<Address> members = dests;
-            int size = members.size() - 1;
-            int startIndex = random.nextInt(size);
-
-            Collection<Address> targets = new ArrayList<Address>(anycast_count);
-            for (int i = 0; i < anycast_count; i++) {
-                int newIndex = (startIndex + i) % size;
-
-                if (newIndex == members.size() - 1)
-                    continue;
-
-                targets.add(members.get(newIndex));
-            }
-            return targets;
-        }
-
-    }
-
-
-    public static class Results implements Streamable {
-        long num_gets=0;
-        long num_puts=0;
-        long time=0;
-
-        public Results() {
-            
-        }
-
-        public Results(int num_gets, int num_puts, long time) {
-            this.num_gets=num_gets;
-            this.num_puts=num_puts;
-            this.time=time;
-        }
-
-
-
-
-        public void writeTo(DataOutput out) throws Exception {
-            out.writeLong(num_gets);
-            out.writeLong(num_puts);
-            out.writeLong(time);
-        }
-
-        public void readFrom(DataInput in) throws Exception {
-            num_gets=in.readLong();
-            num_puts=in.readLong();
-            time=in.readLong();
-        }
-
-        public String toString() {
-            long total_reqs=num_gets + num_puts;
-            double total_reqs_per_sec=total_reqs / (time / 1000.0);
-
-            return f.format(total_reqs_per_sec) + "" reqs/sec ("" + num_gets + "" GETs, "" + num_puts + "" PUTs total)"";
-        }
-    }
-
-
-    public static class ConfigOptions implements Streamable {
-        private boolean sync, oob, msg_bundling;
-        private int     num_threads;
-        private int     num_msgs, msg_size;
-        private int     anycast_count;
-        private boolean use_anycast_addrs;
-        private double  read_percentage;
-
-        public ConfigOptions() {
-        }
-
-        public ConfigOptions(boolean oob, boolean sync, boolean msg_bundling, int num_threads, int num_msgs, int msg_size,
-                             int anycast_count, boolean use_anycast_addrs,
-                             double read_percentage) {
-            this.oob=oob;
-            this.msg_bundling=msg_bundling;
-            this.sync=sync;
-            this.num_threads=num_threads;
-            this.num_msgs=num_msgs;
-            this.msg_size=msg_size;
-            this.anycast_count=anycast_count;
-            this.use_anycast_addrs=use_anycast_addrs;
-            this.read_percentage=read_percentage;
-        }
-
-
-        public void writeTo(DataOutput out) throws Exception {
-            out.writeBoolean(oob);
-            out.writeBoolean(msg_bundling);
-            out.writeBoolean(sync);
-            out.writeInt(num_threads);
-            out.writeInt(num_msgs);
-            out.writeInt(msg_size);
-            out.writeInt(anycast_count);
-            out.writeBoolean(use_anycast_addrs);
-            out.writeDouble(read_percentage);
-        }
-
-        public void readFrom(DataInput in) throws Exception {
-            oob=in.readBoolean();
-            msg_bundling=in.readBoolean();
-            sync=in.readBoolean();
-            num_threads=in.readInt();
-            num_msgs=in.readInt();
-            msg_size=in.readInt();
-            anycast_count=in.readInt();
-            use_anycast_addrs=in.readBoolean();
-            read_percentage=in.readDouble();
-        }
-
-        public String toString() {
-            return ""oob="" + oob + "", sync="" + sync + "", msg_bundling="" + msg_bundling + "", anycast_count="" + anycast_count +
-              "", use_anycast_addrs="" + use_anycast_addrs +
-              "", num_threads="" + num_threads + "", num_msgs="" + num_msgs + "", msg_size="" + msg_size +
-              "", read percentage="" + read_percentage;
-        }
-    }
-
-
-    static class CustomMarshaller implements RpcDispatcher.Marshaller {
-
-        public Buffer objectToBuffer(Object obj) throws Exception {
-            MethodCall call=(MethodCall)obj;
-            ByteBuffer buf;
-            switch(call.getId()) {
-                case START:
-                case GET_CONFIG:
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE);
-                    buf.put((byte)call.getId());
-                    return new Buffer(buf.array());
-                case SET_OOB:
-                case SET_SYNC:
-                case SET_MSB_BUNDLING:
-                case SET_USE_ANYCAST_ADDRS:
-                    return new Buffer(booleanBuffer(call.getId(), (Boolean)call.getArgs()[0]));
-                case SET_NUM_MSGS:
-                case SET_NUM_THREADS:
-                case SET_MSG_SIZE:
-                case SET_ANYCAST_COUNT:
-                    return new Buffer(intBuffer(call.getId(), (Integer)call.getArgs()[0]));
-                case GET:
-                    return new Buffer(longBuffer(call.getId(), (Long)call.getArgs()[0]));
-                case PUT:
-                    Long long_arg=(Long)call.getArgs()[0];
-                    byte[] arg2=(byte[])call.getArgs()[1];
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.INT_SIZE + Global.LONG_SIZE + arg2.length);
-                    buf.put((byte)call.getId()).putLong(long_arg).putInt(arg2.length).put(arg2, 0, arg2.length);
-                    return new Buffer(buf.array());
-                case SET_READ_PERCENTAGE:
-                    Double double_arg=(Double)call.getArgs()[0];
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.DOUBLE_SIZE);
-                    buf.put((byte)call.getId()).putDouble(double_arg);
-                    return new Buffer(buf.array());
-                default:
-                    throw new IllegalStateException(""method "" + call.getMethod() + "" not known"");
-            }
-        }
-
-
-
-        public Object objectFromBuffer(byte[] buffer, int offset, int length) throws Exception {
-            ByteBuffer buf=ByteBuffer.wrap(buffer, offset, length);
-
-            byte type=buf.get();
-            switch(type) {
-                case START:
-                case GET_CONFIG:
-                    return new MethodCall(type);
-                case SET_OOB:
-                case SET_SYNC:
-                case SET_MSB_BUNDLING:
-                case SET_USE_ANYCAST_ADDRS:
-                    return new MethodCall(type, buf.get() == 1);
-                case SET_NUM_MSGS:
-                case SET_NUM_THREADS:
-                case SET_MSG_SIZE:
-                case SET_ANYCAST_COUNT:
-                    return new MethodCall(type, buf.getInt());
-                case GET:
-                    return new MethodCall(type, buf.getLong());
-                case PUT:
-                    Long longarg=buf.getLong();
-                    int len=buf.getInt();
-                    byte[] arg2=new byte[len];
-                    buf.get(arg2, 0, arg2.length);
-                    return new MethodCall(type, longarg, arg2);
-                case SET_READ_PERCENTAGE:
-                    return new MethodCall(type, buf.getDouble());
-                default:
-                    throw new IllegalStateException(""type "" + type + "" not known"");
-            }
-        }
-
-        private static byte[] intBuffer(short type, Integer num) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.INT_SIZE);
-            buf.put((byte)type).putInt(num);
-            return buf.array();
-        }
-
-        private static byte[] longBuffer(short type, Long num) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.LONG_SIZE);
-            buf.put((byte)type).putLong(num);
-            return buf.array();
-        }
-
-        private static byte[] booleanBuffer(short type, Boolean arg) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE *2);
-            buf.put((byte)type).put((byte)(arg? 1 : 0));
-            return buf.array();
-        }
-    }
-
-
-    public static void main(String[] args) {
-        String  props=null;
-        String  name=null;
-        boolean xsite=true;
-
-
-        for(int i=0; i < args.length; i++) {
-            if(""-props"".equals(args[i])) {
-                props=args[++i];
-                continue;
-            }
-            if(""-name"".equals(args[i])) {
-                name=args[++i];
-                continue;
-            }
-            if(""-xsite"".equals(args[i])) {
-                xsite=Boolean.valueOf(args[++i]);
-                continue;
-            }
-            help();
-            return;
-        }
-
-        UPerf2 test=null;
-        try {
-            test=new UPerf2();
-            test.init(props, name, xsite);
-            test.eventLoop();
-        }
-        catch(Throwable ex) {
-            ex.printStackTrace();
-            if(test != null)
-                test.stop();
-        }
-    }
-
-    static void help() {
-        System.out.println(""UPerf [-props <props>] [-name name] [-xsite <true | false>]"");
-    }
-
-
-}
\ No newline at end of file",2014-01-10T16:46:08Z,131
"@@ -149,7 +149,8 @@ protected boolean addDiscoveryResponseToCaches(Address mbr, String logical_name,
 
     protected static String addressToFilename(Address mbr) {
         String logical_name=UUID.get(mbr);
-        return addressAsString(mbr) + (logical_name != null? ""."" + logical_name + SUFFIX : SUFFIX);
+        return (addressAsString(mbr) + (logical_name != null? ""."" + logical_name + SUFFIX : SUFFIX))
+            .replace(File.separatorChar, '-');
     }
 
     protected void createRootDir() {
@@ -364,4 +365,4 @@ public void run() {
     }
 
 
-}
\ No newline at end of file
+}",2015-06-19T13:46:53Z,111
"@@ -12,6 +12,7 @@
 
 import javax.crypto.*;
 import javax.crypto.spec.SecretKeySpec;
+
 import java.io.*;
 import java.security.*;
 import java.security.cert.CertificateException;
@@ -144,6 +145,9 @@ interface Observer {
     @Property(name=""sym_init"", description=""Initial key length for matching symmetric algorithm. Default is 128"")
     int symInit=128;
 
+    @Property(name=""change_keys"", description=""Generate new symmetric keys on every view change. Default is false"")
+    boolean changeKeysOnViewChange=false;
+
     // properties for functioning in supplied key mode
     private boolean suppliedKey=false;
 
@@ -524,6 +528,10 @@ public Object passItUp(Event evt) {
 
     private synchronized void handleViewChange(View view, boolean makeServer) {
 
+    	if ( makeServer) {
+    		initializeNewSymmetricKey();
+    	}
+    	
         // if view is a bit broken set me as keyserver
         List<Address> members = view.getMembers();
         if (members == null || members.isEmpty() || members.get(0) == null) { 
@@ -533,21 +541,36 @@ private synchronized void handleViewChange(View view, boolean makeServer) {
         // otherwise get keyserver from view controller
         Address tmpKeyServer=view.getMembers().get(0);
 
-        //I am new keyserver - either first member of group or old key server is no more and
+        //I am  keyserver - either first member of group or old key server is no more and
         // I have been voted new controller
-        if(makeServer || (tmpKeyServer.equals(local_addr) && (keyServerAddr == null || (!tmpKeyServer.equals(keyServerAddr))))) {
+        if(makeServer || (tmpKeyServer.equals(local_addr))) {
             becomeKeyServer(tmpKeyServer, makeServer);
-            // a new keyserver has been set and it is not me
-        }
-        else if(keyServerAddr == null || (!tmpKeyServer.equals(keyServerAddr)) || (keyServer && !tmpKeyServer.equals(local_addr))) {
-            handleNewKeyServer(tmpKeyServer);
         }
         else {
-            if(log.isDebugEnabled())
-                log.debug(""Membership has changed but I do not care"");
+            handleNewKeyServer(tmpKeyServer);
         }
     }
 
+	private void initializeNewSymmetricKey() {
+		try {
+			if ( changeKeysOnViewChange || !keyServer) {
+				if ( log.isDebugEnabled()) {
+					log.debug(""Initalizing new ciphers"");
+				}
+				initSymKey();
+				initSymCiphers(getSymAlgorithm(), getSecretKey());
+			}
+
+		} catch (Exception e) {
+			log.error(""Could not initialize new ciphers: {}"", e.getMessage());
+			if ( e instanceof RuntimeException) {
+				throw (RuntimeException)e;
+			} else {
+				throw new IllegalStateException(e);
+			}
+		}
+	}
+
     /**
      * Handles becoming server - resetting queue settings and setting keyserver
      * address to be local address.
@@ -571,20 +594,28 @@ private void becomeKeyServer(Address tmpKeyServer, boolean forced) {
      * @param newKeyServer
      */
     private void handleNewKeyServer(Address newKeyServer) {
-        // start queueing until we have new key
-        // to make sure we are not sending with old key
-        queue_up=true;
-        queue_down=true;
-        // set new keyserver address
-        keyServerAddr=newKeyServer;
-        keyServer=false;
-        if(log.isDebugEnabled())
-            log.debug(""["" + local_addr + ""] "" + keyServerAddr + "" has become the new key server, sending key request to it"");
+    	
+    	if ( changeKeysOnViewChange || keyServerChanged(newKeyServer)) {
+            // start queueing until we have new key
+            // to make sure we are not sending with old key
+            queue_up=true;
+            queue_down=true;
+            // set new keyserver address
+            keyServerAddr=newKeyServer;
+            keyServer=false;
+            if(log.isDebugEnabled())
+                log.debug(""["" + local_addr + ""] "" + keyServerAddr + "" has become the new key server, sending key request to it"");
 
-        // create a key request message
-        sendKeyRequest();
+            // create a key request message
+            sendKeyRequest();
+    		
+    	}
     }
 
+	private boolean keyServerChanged(Address newKeyServer) {
+		return keyServerAddr == null || !keyServerAddr.equals(newKeyServer);
+	}
+
 
     private void handleUpMessage(Event evt) throws Exception {
         Message msg=(Message)evt.getArg();",2013-12-20T17:17:31Z,132
"@@ -12,10 +12,12 @@
 import org.jgroups.protocols.ENCRYPT.EncryptHeader;
 import org.jgroups.stack.Protocol;
 import org.jgroups.util.Util;
+import org.testng.Assert;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.crypto.Cipher;
+
 import java.io.*;
 import java.security.MessageDigest;
 import java.security.Security;
@@ -197,11 +199,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
         Address serverAddress=new MockAddress(""server"");
 
         server.setLocal_addr(serverAddress);
-        //set the server up as keyserver
-        List<Address> serverVector=new ArrayList<Address>();
-        serverVector.add(serverAddress);
-        View tempView=new View(new ViewId(serverAddress, 1), serverVector);
-        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+        Event serverEvent = createViewChange( 1, serverAddress);
         server.up(serverEvent);
 
         // set up peer
@@ -306,11 +304,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Address serverAddress=new MockAddress(""server"");
         server.setLocal_addr(serverAddress);
 
-        //	set the server up as keyserver
-        List<Address> serverVector=new ArrayList<Address>() ;
-        serverVector.add(serverAddress);
-        View tempView=new View(new ViewId(serverAddress, 1), serverVector);
-        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+        Event serverEvent = createViewChange(1, serverAddress);
         server.up(serverEvent);
 
         // set up peer as if it has started but not recieved view change
@@ -345,12 +339,10 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
 
         //assert that message is queued as we have no key from server
         Util.assertTrue(peerObserver.getUpMessages().isEmpty());
-
-        // send a view change to peer where peer2 is  controller
-        List<Address> peerVector=new ArrayList<Address>() ;
-        peerVector.add(peer2Address);
-        View tempPeerView=new View(new ViewId(peer2Address, 1), peerVector);
-        Event event=new Event(Event.VIEW_CHANGE, tempPeerView);
+        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
+        Util.assertFalse(peerObserver.getUpMessages().isEmpty());
+        
+        Event event = createViewChange(2, peer2Address);
 
         // send to peer - should set peer2 as keyserver
         peer.up(event);
@@ -365,18 +357,9 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
 
-        //assume that server is no longer available and peer2 is new server
-        // but did not get the key from server before assuming role
-        // send this event to peer2
-//		 send a view change to trigger the become key server
-        // we use the fact that our address is now the controller one
-        // send a view change where we are not the controller
-        List<Address> peer2Vector=new ArrayList<Address>() ;
-        peer2Vector.add(peer2Address);
-        View tempPeer2View=new View(new ViewId(peer2Address, 1), peer2Vector);
-        Event event2=new Event(Event.VIEW_CHANGE, tempPeer2View);
+        
         // this should have changed us to the key server
-        peer2.up(event2);
+        peer2.up(event);
 
         peer2.up(sent);
 
@@ -390,6 +373,8 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         assert !server.getDesKey().equals(peer2.getDesKey());
 
         // now send back to peer
+        // TODO: The encrypted message encrypted by server secret key cannot be decrypted
+        // since peer does not have server's key
         peer.up(reply);
 
         // assert that both now have same key
@@ -409,17 +394,126 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
 
         peer.up(Evt2);
         // make sure we have the events now in the up layers
-        Util.assertEquals(2, peerObserver.getUpMessages().size());
+        Util.assertEquals(4, peerObserver.getUpMessages().size());
 
-        Event tempEvt=(Event)peerObserver.getUpMessages().get(""message2"");
+        Event tempEvt=getLatestUpMessage(peerObserver);
 
 
         Util.assertEquals(""hello2"", new String(((Message)tempEvt.getArg()).getBuffer()));
 
 
     }
 
+    public static void testKeyChangesDuringKeyServerChange() throws Exception {
+        // create peers and server
+        ENCRYPT peer=new ENCRYPT();
+        peer.init();
+
+        ENCRYPT server=new ENCRYPT();
+        server.init();
+
+        ENCRYPT peer2=new ENCRYPT();
+        peer2.init();
+
+        // set up server
+        server.keyServer=true;
+        MockObserver serverObserver=new MockObserver();
+        server.setObserver(serverObserver);
+
+        //set the local address and view change to simulate a started instance
+        Address serverAddress=new MockAddress(""server"");
+        server.setLocal_addr(serverAddress);
+
+        //	set the server up as keyserver
+        Event serverEvent = createViewChange(1, serverAddress);
+        server.up(new Event(Event.TMP_VIEW, serverEvent.getArg()));
+        server.up(serverEvent);
+
+        Address peerAddress=new MockAddress(""peer"");
+        peer.setLocal_addr(peerAddress);
+        MockObserver peerObserver=new MockObserver();
+        peer.setObserver(peerObserver);
+        peer.keyServer=false;
+        
+        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
+        
+
+        // set up peer2 with server as key server
+        Address peer2Address=new MockAddress(""peer2"");
+        peer2.setLocal_addr(peer2Address);
+        MockObserver peer2Observer=new MockObserver();
+        peer2.setObserver(peer2Observer);
+        peer2.keyServer=false;
+        updateViewFor(peer2, server, serverObserver, serverEvent, peer2Observer);
 
+        Assert.assertEquals(server.getDesKey(), peer.getDesKey());
+        Assert.assertEquals(server.getDesKey(), peer2.getDesKey());
+
+        // send an encrypted message from the server
+        Message msg=new Message();
+        msg.setBuffer(""hello"".getBytes());
+
+        Event viewChange2 = createViewChange(2, peer2Address);
+        peer2.up(new Event(Event.TMP_VIEW, viewChange2.getArg()));
+        peer2.up(viewChange2);
+
+        updateViewFor(peer, peer2, peer2Observer, viewChange2, peerObserver);
+
+        Assert.assertFalse(server.getDesKey().equals(peer.getDesKey()));
+        Assert.assertEquals(peer.getDesKey(), peer2.getDesKey());
+
+    }
+
+	private static void updateViewFor(ENCRYPT peer, ENCRYPT keyServer,
+			MockObserver serverObserver, Event serverEvent,
+			MockObserver peerObserver) {
+		peer.up(serverEvent);
+        Event peerKeyRequest = getLatestDownMessage(peerObserver);
+        keyServer.up(peerKeyRequest);
+        Event serverKeyToPeer = getLatestDownMessage(serverObserver);
+        peer.up(serverKeyToPeer);
+	}
+
+	private static Event createViewChange(int id, Address serverAddress, Address...addresses ) {
+		List<Address> serverVector=new ArrayList<Address>() ;
+        serverVector.add(serverAddress);
+        for ( Address a : addresses) {
+        	serverVector.add(a);
+        }
+        View tempView=new View(new ViewId(serverAddress, id), serverVector);
+        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+		return serverEvent;
+	}
+    
+    
+    static Event getLatestDownMessage(MockObserver observer) {
+    	Event latest = null;
+    	Map map = observer.getDownMessages();
+    	int counter = observer.counter-1;
+    	while ( latest == null && counter >= 0) {
+    		latest = (Event) map.get(""message"" + counter);
+    		counter--;
+    	}
+    	if ( latest == null) {
+    		throw new IllegalStateException(""Could not find latest down message"");
+    	}
+    	return latest;
+    }
+    
+    static Event getLatestUpMessage(MockObserver observer) {
+    	Event latest = null;
+    	Map map = observer.getUpMessages();
+    	int counter = observer.counter-1;
+    	while ( latest == null && counter >= 0) {
+    		latest = (Event) map.get(""message"" + counter);
+    		counter--;
+    	}
+    	if ( latest == null) {
+    		throw new IllegalStateException(""Could not find latest down message"");
+    	}
+    	return latest;
+    }
+    
     static class MockObserver implements ENCRYPT.Observer {
         private Map upMessages=new HashMap();
         private Map downMessages=new HashMap();",2013-12-20T17:17:31Z,132
"@@ -300,15 +300,41 @@ that node.
                 
 When the coordinator changes, or members not listed in the file join, the current coordinator
 writes the file again, so all members have access to the updated information when needed.
-                
 
 If a bootstrap discovery file is to be used, it needs to be placed into the file system or cloud
 store in the correct location and with the right name (see the Discovery section for naming details).
-                
 
 The design is discussed in more detail in
 link:$$https://github.com/belaban/JGroups/blob/master/doc/design/CloudBasedDiscovery.txt$$[CloudBasedDiscovery.txt]
-                
+
+
+===== Removal of zombie files
+
+By default, a new coordinator C never removes a file created by an old coordinator `A`. E.g. in `{A,B,C,D}` (with
+coordinator `A`), if `C` becomes coordinator on a split `{A,B} | {C,D}`, then `C` doesn't remove `A`'s file, as there
+is no way for `C` to know whether `A` crashed or whether `A` was partitioned away.
+
+Every coordinator `P` installs a shutdown hook which removes `P`'s file on termination. However, this doesn't apply
+to a process killed ungracefully, e.g. by `kill -9`. In this case, no shutdown hook will get called. If we had view
+`{A,B,C}`, and `A` was killed via kill -9, and `B` takes over, we'd have files `A.list` and `B.list`.
+
+To change this, attribute `remove_old_coords_on_view_change` can be set to true. In this case, files created by old
+coordinators will be removed. In the scenario above, where `A` crashed, `B` would remove `A.list`.
+
+However, if we have a split between `{A,B}` and `{C,D}`, `C` would remove `A.list`. To prevent this, every coordinator
+writes its file again on a view change that has left members or in which the coordinator changed.
+
+There is still a case which can end up with a zombie file that's never removed: when we have a single member `A` and
+it is killed via `kill -9`. In this case, file `A.list` will never get cleaned up and subsequent joiners will ask
+`A` to join, up to `GMS.max_join_attempts` times.
+
+Zombie cleanup can be solved by setting `remove_all_files_on_view_change` to true. In this case, a coordinator
+removes _all files_ on a view change that has members leaving or changes the coordinator.
+
+NOTE: Setting `remove_old_coords_on_view_change` or `remove_all_files_on_view_change` to true generates more traffic
+to the file system or cloud store. If members are always shut down gracefully, or never killed via `kill -9`, then
+it is recommended to set both attributes to false.
+
 
 ${FILE_PING}
 ",2015-03-03T11:16:01Z,133
"@@ -5,8 +5,10 @@
 import org.jgroups.PhysicalAddress;
 import org.jgroups.View;
 import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
 import org.jgroups.annotations.Property;
 import org.jgroups.util.Responses;
+import org.jgroups.util.TimeScheduler;
 import org.jgroups.util.UUID;
 import org.jgroups.util.Util;
 
@@ -15,6 +17,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 
 
 /**
@@ -36,6 +39,19 @@ public class FILE_PING extends Discovery {
     @Deprecated @Property(description=""Interval (in milliseconds) at which the own Address is written. 0 disables it."")
     protected long interval=60000;
 
+    @Property(description=""If true, on a view change, the new coordinator removes files from old coordinators"")
+    protected boolean remove_old_coords_on_view_change=false;
+
+    @Property(description=""If true, on a view change, the new coordinator removes all files except its own"")
+    protected boolean remove_all_files_on_view_change=false;
+
+    @Property(description=""The max number of times my own information should be written to the DB after a view change"")
+    protected int info_writer_max_writes_after_view=2;
+
+    @Property(description=""Interval (in ms) at which the info writer should kick in"")
+    protected long info_writer_sleep_time=10000;
+
+
     @ManagedAttribute(description=""Number of writes to the file system or cloud store"")
     protected int writes;
 
@@ -49,9 +65,16 @@ public class FILE_PING extends Discovery {
         public boolean accept(File dir, String name) {return name.endsWith(SUFFIX);}
     };
     protected volatile View               prev_view;
+    protected Future<?>                   info_writer;
 
     public boolean isDynamic() {return true;}
 
+    @ManagedAttribute(description=""Whether the InfoWriter task is running"")
+    public synchronized boolean isInfoWriterRunning() {return info_writer != null && !info_writer.isDone();}
+
+    @ManagedOperation(description=""Causes the member to write its own information into the DB, replacing an existing entry"")
+    public void writeInfo() {if(is_coord) writeAll();}
+
     public void init() throws Exception {
         super.init();
         createRootDir();
@@ -144,12 +167,24 @@ protected void createRootDir() {
 
     // remove all files which are not from the current members
     protected void handleView(View new_view, View old_view, boolean coord_changed) {
-        if(coord_changed) {
-            if(is_coord)
+        if(is_coord) {
+            if(coord_changed) {
+                if(remove_all_files_on_view_change)
+                    removeAll(cluster_name);
+                else if(remove_old_coords_on_view_change) {
+                    Address old_coord=old_view != null? old_view.getCreator() : null;
+                    if(old_coord != null)
+                        remove(cluster_name, old_coord);
+                }
+            }
+            if(coord_changed || View.diff(old_view, new_view)[1].length > 0) {
                 writeAll();
-            else
-                remove(cluster_name, local_addr);
+                if(remove_all_files_on_view_change || remove_old_coords_on_view_change)
+                    startInfoWriter();
+            }
         }
+        else if(coord_changed) // I'm no longer the coordinator
+            remove(cluster_name, local_addr);
     }
 
     protected void remove(String clustername, Address addr) {
@@ -167,6 +202,18 @@ protected void remove(String clustername, Address addr) {
         deleteFile(file);
     }
 
+    /** Removes all files except the member passed as argument (can be null) */
+    protected void removeAll(String clustername) {
+        if(clustername == null)
+            return;
+        File dir=new File(root_dir, clustername);
+        if(!dir.exists())
+            return;
+        File[] files=dir.listFiles(filter); // finds all files ending with '.list'
+        for(File file: files)
+            file.delete();
+    }
+
 
 
     protected void readAll(List<Address> members, String clustername, Responses responses) {
@@ -281,5 +328,40 @@ protected boolean deleteFile(File file) {
         return result;
     }
 
+    protected synchronized void startInfoWriter() {
+        if(info_writer == null || info_writer.isDone())
+            info_writer=timer.scheduleWithDynamicInterval(new InfoWriter(info_writer_max_writes_after_view, info_writer_sleep_time));
+    }
+
+    protected synchronized void stopInfoWriter() {
+        if(info_writer != null)
+            info_writer.cancel(false);
+    }
+
+
+    /** Class which calls writeAll() a few times. Started after a view change in which an old coord left */
+    protected class InfoWriter implements TimeScheduler.Task {
+        protected final int  max_writes;
+        protected int        num_writes;
+        protected final long sleep_interval;
+
+        public InfoWriter(int max_writes, long sleep_interval) {
+            this.max_writes=max_writes;
+            this.sleep_interval=sleep_interval;
+        }
+
+        @Override
+        public long nextInterval() {
+            if(++num_writes > max_writes)
+                return 0; // discontinues this task
+            return Math.max(1000, Util.random(sleep_interval));
+        }
+
+        @Override
+        public void run() {
+            writeAll();
+        }
+    }
+
 
 }
\ No newline at end of file",2015-03-03T11:16:01Z,111
"@@ -1,7 +1,5 @@
 package org.jgroups.protocols;
 
-import org.jgroups.annotations.Property;
-
 /**
  * Discovery protocol for Google Cloud Storage. Very simple first shot at an impl, based on a simple migration of
  * S3_PING, as discussed in [1].<p/>
@@ -12,15 +10,15 @@
  */
 public class GOOGLE_PING extends S3_PING {
 
-    @Property(description=""The name of the Google Cloud Storage server"")
-    protected String host=""storage.googleapis.com"";
-
     public void init() throws Exception {
+        if(host == null)
+            host=""storage.googleapis.com"";
         super.init();
     }
 
     protected AWSAuthConnection createConnection() {
-        return new AWSAuthConnection(access_key, secret_access_key, false, host);
+        return port > 0? new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, port)
+          : new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, Utils.INSECURE_PORT);
     }
 }
 ",2015-03-03T11:16:01Z,134
"@@ -112,6 +112,13 @@ protected void remove(String clustername, Address addr) {
         rackspaceClient.deleteObject(container, fileName);
     }
 
+    @Override
+    protected void removeAll(String clustername) {
+        List<String> objects = rackspaceClient.listObjects(container);
+        for(String objName: objects) {
+            rackspaceClient.deleteObject(container, objName);
+        }
+    }
 
     /**
      * A thread safe Rackspace ReST client",2015-03-03T11:16:01Z,135
"@@ -32,6 +32,15 @@
  */
 public class S3_PING extends FILE_PING {
 
+    @Property(description=""The name of the AWS server"")
+    protected String host;
+
+    @Property(description=""The port at which AWS is listening"")
+    protected int port;
+
+    @Property(description=""Whether or not to use SSL to connect to host:port"")
+    protected boolean use_ssl=true;
+
     @Property(description=""The access key to AWS (S3)"",exposeAsManagedAttribute=false)
     protected String access_key;
 
@@ -56,9 +65,9 @@ public class S3_PING extends FILE_PING {
   
     public void init() throws Exception {
         super.init();
-
+        if(host == null)
+            host=Utils.DEFAULT_HOST;
         validateProperties();
-
         conn=createConnection();
 
         if(prefix != null && !prefix.isEmpty()) {
@@ -92,7 +101,8 @@ public void init() throws Exception {
     }
 
     protected AWSAuthConnection createConnection() {
-        return new AWSAuthConnection(access_key, secret_access_key);
+        return port > 0? new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, port)
+          : new AWSAuthConnection(access_key, secret_access_key, use_ssl, host);
     }
 
     @Override
@@ -207,6 +217,36 @@ protected void remove(String clustername, Address addr) {
         }
     }
 
+    @Override
+    protected void removeAll(String clustername) {
+        if(clustername == null)
+            return;
+
+        try {
+            Map headers=new TreeMap();
+            headers.put(""Content-Type"", Arrays.asList(""text/plain""));
+            clustername=sanitize(clustername);
+            ListBucketResponse rsp=conn.listBucket(location, clustername, null, null, null);
+            if(rsp.entries != null) {
+                for(Iterator<ListEntry> it=rsp.entries.iterator(); it.hasNext();) {
+                    ListEntry key=it.next();
+                    try {
+                        if (usingPreSignedUrls())
+                            conn.delete(pre_signed_delete_url).connection.getResponseMessage();
+                        else
+                            conn.delete(location, key.key, headers).connection.getResponseMessage();
+                        log.trace(""removing %s/%s"", location, key.key);
+                    }
+                    catch(Throwable t) {
+                        log.error(""failed deleting object %s/%s: %s"", location, key.key, t);
+                    }
+                }
+            }
+        }
+        catch(IOException ex) {
+            log.error(""failed deleting all objects"", ex);
+        }
+    }
 
     protected void validateProperties() {
         if (pre_signed_put_url != null && pre_signed_delete_url != null) {",2015-03-03T11:16:01Z,109
"@@ -151,6 +151,18 @@ protected void remove(String clustername, Address addr) {
     }
 
 
+    @Override
+    protected void removeAll(String clustername) {
+        try {
+            List<String> objects=swiftClient.listObjects(container);
+            for(String objName : objects) {
+                swiftClient.deleteObject(container, objName);
+            }
+        }
+        catch(Exception t) {
+            log.error(""failed removing objects"", t);
+        }
+    }
 
 
 ",2015-03-03T11:16:01Z,136
"@@ -1,17 +1,5 @@
 package org.jgroups.protocols;
 
-import static org.testng.AssertJUnit.assertTrue;
-
-import java.io.IOException;
-
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.NameCallback;
-import javax.security.auth.callback.PasswordCallback;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.sasl.AuthorizeCallback;
-import javax.security.sasl.RealmCallback;
-
 import org.jgroups.Global;
 import org.jgroups.JChannel;
 import org.jgroups.protocols.pbcast.GMS;
@@ -21,13 +9,20 @@
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
+import javax.security.auth.callback.*;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+import java.io.IOException;
+
+import static org.testng.AssertJUnit.assertTrue;
+
 @Test(groups = Global.FUNCTIONAL, singleThreaded = true)
 public class SASLTest {
     private static final String REALM = ""MyRealm"";
     private JChannel a;
     private JChannel b;
 
-    private JChannel createChannel(String channelName, String mech, String username) throws Exception {
+    private static JChannel createChannel(String channelName,String mech,String username) throws Exception {
         SASL sasl = new SASL();
         sasl.setMech(mech);
         sasl.setCallbackHandler(new MyCallbackHandler(username));",2014-03-29T07:50:42Z,56
"@@ -44,7 +44,7 @@
  * The {@link #receive(Address, byte[], int, int)} method must
  * be called by subclasses when a unicast or multicast message has been received.
  * @author Bela Ban
- * @version $Id: TP.java,v 1.276 2009/11/05 08:44:22 belaban Exp $
+ * @version $Id: TP.java,v 1.277 2009/11/12 09:07:42 belaban Exp $
  */
 @MBean(description=""Transport protocol"")
 @DeprecatedProperty(names={""bind_to_all_interfaces"", ""use_incoming_packet_handler"", ""use_outgoing_packet_handler"",
@@ -99,6 +99,9 @@ public abstract class TP extends Protocol {
                       description=""Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on"")
     protected List<NetworkInterface> receive_interfaces=null;
 
+    @Property
+    @Deprecated
+    int marshaller_pool_size=0;
 
 
     /** The port to which the transport binds. 0 means to bind to any (ephemeral) port */
@@ -157,8 +160,8 @@ public abstract class TP extends Protocol {
 
     @ManagedAttribute
     @Property(name=""oob_thread_pool.rejection_policy"",
-                      description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Run"")
-    String oob_thread_pool_rejection_policy=""Run"";
+              description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Discard"")
+    String oob_thread_pool_rejection_policy=""discard"";
 
     @ManagedAttribute(description=""Minimum thread pool size for regular messages. Default is 2"")
     @Property(name=""thread_pool.min_threads"",description=""Minimum thread pool size for regular messages. Default is 2"")
@@ -190,8 +193,8 @@ public abstract class TP extends Protocol {
 
     @ManagedAttribute
     @Property(name=""thread_pool.rejection_policy"",
-                      description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run Default is Run"")
-    protected String thread_pool_rejection_policy=""Run"";
+              description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Discard"")
+    protected String thread_pool_rejection_policy=""Discard"";
 
     @ManagedAttribute(description=""Number of threads to be used by the timer thread pool"")
     @Property(name=""timer.num_threads"",description=""Number of threads to be used by the timer thread pool. Default is 4"")",2009-11-12T09:07:42Z,85
"@@ -74,7 +74,7 @@ public Object up(Event evt) {
                 if(hdr.fork_stack_id == null)
                     throw new IllegalArgumentException(""header has a null fork_stack_id"");
                 Protocol bottom_prot=get(hdr.fork_stack_id);
-                return bottom_prot.up(evt);
+                return bottom_prot != null? bottom_prot.up(evt) : null;
 
             case Event.VIEW_CHANGE:
                 for(Protocol bottom: fork_stacks.values())
@@ -105,6 +105,8 @@ public void up(MessageBatch batch) {
             String fork_stack_id=entry.getKey();
             List<Message> list=entry.getValue();
             Protocol bottom_prot=get(fork_stack_id);
+            if(bottom_prot == null)
+                continue;
             MessageBatch mb=new MessageBatch(batch.dest(), batch.sender(), batch.clusterName(), batch.multicast(), list);
             try {
                 bottom_prot.up(mb);",2014-06-10T06:31:57Z,137
"@@ -72,4 +72,6 @@
     <class id=""109"" name=""org.jgroups.protocols.PERF$PerfHeader""/>
     <class id=""110"" name=""org.jgroups.blocks.MethodCall""/>
     <class id=""111"" name=""org.jgroups.util.ExtendedUUID""/>
+    <class id=""112"" name=""org.jgroups.protocols.SaslHeader""/>
 </magic-number-class-mapping>
+",2014-03-27T08:30:01Z,138
"@@ -62,6 +62,7 @@
     <class id=""65"" name=""org.jgroups.protocols.FORK""/>
     <class id=""66"" name=""org.jgroups.protocols.PERF""/>
     <class id=""67"" name=""org.jgroups.protocols.SHARED_LOOPBACK_PING""/>
+    <class id=""68"" name=""org.jgroups.protocols.SASL""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2014-03-27T08:30:01Z,104
"@@ -0,0 +1,81 @@
+package org.jgroups.auth.sasl;
+
+import java.util.Map;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.Sasl;
+import javax.security.sasl.SaslClient;
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SASL;
+import org.jgroups.protocols.SaslHeader;
+import org.jgroups.protocols.SaslHeader.Type;
+
+public class SaslClientContext implements SaslContext {
+    private static final byte[] EMPTY_CHALLENGE = new byte[0];
+    SaslClient client;
+
+    public SaslClientContext(String mech, Address local_addr, CallbackHandler callback_handler, Map<String, String> props) throws SaslException {
+        client = Sasl.createSaslClient(new String[] { mech }, null, ""jgroups"", local_addr.toString(), props,
+                callback_handler);
+    }
+
+    @Override
+    public boolean isSuccessful() {
+        return client.isComplete();
+    }
+
+    @Override
+    public boolean needsWrapping() {
+        if (client.isComplete()) {
+            String qop = (String) client.getNegotiatedProperty(Sasl.QOP);
+            return (qop != null && (qop.equalsIgnoreCase(""auth-int"") || qop.equalsIgnoreCase(""auth-conf"")));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException {
+        return client.wrap(outgoing, offset, len);
+    }
+
+    @Override
+    public byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException {
+        return client.unwrap(incoming, offset, len);
+    }
+
+    @Override
+    public Message nextMessage(Address address, SaslHeader header) throws SaslException {
+        Message message = new Message(address).setFlag(Message.Flag.OOB);
+        return addHeader(message, header.getPayload());
+    }
+
+    @Override
+    public void dispose() {
+        try {
+            client.dispose();
+        } catch (SaslException e) {
+        }
+    }
+
+    public Message addHeader(Message msg, byte[] payload) throws SaslException {
+        byte[] response;
+        if (payload == null) {
+            if (client.hasInitialResponse()) {
+                response = client.evaluateChallenge(EMPTY_CHALLENGE);
+            } else {
+                response = EMPTY_CHALLENGE;
+            }
+        } else {
+            response = client.evaluateChallenge(payload);
+        }
+        if (response != null) {
+            return msg.putHeader(SASL.SASL_ID, new SaslHeader(Type.RESPONSE, response));
+        } else {
+            return null;
+        }
+    }
+}",2014-03-27T08:30:01Z,139
"@@ -0,0 +1,21 @@
+package org.jgroups.auth.sasl;
+
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SaslHeader;
+
+public interface SaslContext {
+    boolean isSuccessful();
+
+    boolean needsWrapping();
+
+    byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException;
+
+    byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException;
+
+    void dispose();
+
+    Message nextMessage(Address address, SaslHeader saslHeader) throws SaslException;
+}",2014-03-27T08:30:01Z,140
"@@ -0,0 +1,80 @@
+package org.jgroups.auth.sasl;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SASL;
+import org.jgroups.protocols.SaslHeader;
+import org.jgroups.protocols.SaslHeader.Type;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.Sasl;
+import javax.security.sasl.SaslException;
+import javax.security.sasl.SaslServer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public class SaslServerContext implements SaslContext {
+    SaslServer server;
+    CountDownLatch latch = new CountDownLatch(1);
+
+    public SaslServerContext(String mech, Address local_addr, CallbackHandler callback_handler, Map<String, String> props) throws SaslException {
+        server = Sasl.createSaslServer(mech, ""jgroups"", local_addr.toString(), props, callback_handler);
+    }
+
+    @Override
+    public boolean isSuccessful() {
+        return server.isComplete();
+    }
+
+    @Override
+    public boolean needsWrapping() {
+        if (server.isComplete()) {
+            String qop = (String) server.getNegotiatedProperty(Sasl.QOP);
+            return (qop != null && (qop.equalsIgnoreCase(""auth-int"") || qop.equalsIgnoreCase(""auth-conf"")));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException {
+        return server.wrap(outgoing, offset, len);
+    }
+
+    @Override
+    public byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException {
+        return server.unwrap(incoming, offset, len);
+    }
+
+    @Override
+    public Message nextMessage(Address address, SaslHeader header) throws SaslException {
+        Message message = new Message(address).setFlag(Message.Flag.OOB);
+        byte[] challenge = server.evaluateResponse(header.getPayload());
+        if (server.isComplete()) {
+            latch.countDown();
+        }
+        if (challenge != null) {
+            return message.putHeader(SASL.SASL_ID, new SaslHeader(Type.RESPONSE, challenge));
+        } else {
+            return null;
+        }
+    }
+
+    public void awaitCompletion(long timeout) throws InterruptedException {
+        latch.await(timeout, TimeUnit.MILLISECONDS);
+    }
+
+    public String getAuthorizationID() {
+        return server.getAuthorizationID();
+    }
+
+    @Override
+    public void dispose() {
+        try {
+            server.dispose();
+        } catch (SaslException e) {
+        }
+    }
+
+}
\ No newline at end of file",2014-03-27T08:30:01Z,141
"@@ -14,16 +14,18 @@
 import java.util.Collection;
 import java.util.Enumeration;
 import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.Callable;
 
 /**
  * Groups a set of standard PropertyConverter(s) supplied by JGroups.
- * 
+ *
  * <p>
  * Third parties can provide their own converters if such need arises by implementing
  * {@link PropertyConverter} interface and by specifying that converter as converter on a specific
  * Property annotation of a field or a method instance.
- * 
+ *
  * @author Vladimir Blagojevic
  */
 public class PropertyConverters {
@@ -39,7 +41,7 @@ public String toString(Object value) {
             return Util.print(list);
         }
     }
-    
+
     public static class FlushInvoker implements PropertyConverter {
 
 		public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
@@ -55,7 +57,7 @@ public Object convert(Object obj, Class<?> propertyFieldType, String propertyNam
 		public String toString(Object value) {
 			return value.getClass().getName();
 		}
-    	
+
     }
 
     public static class InitialHosts implements PropertyConverter {
@@ -82,15 +84,15 @@ public String toString(Object value) {
             else
                 return value.getClass().getName();
 		}
-		
+
         private static int getPortRange(Protocol protocol) throws Exception {
             Field f = protocol.getClass().getDeclaredField(""port_range"") ;
             return ((Integer) Util.getField(f,protocol)).intValue();
 		}
     }
-    
+
     public static class InitialHosts2 implements PropertyConverter {
-    	
+
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String prop_val, boolean check_scope) throws Exception {
 			// port range is 1
             return Util.parseCommaDelimitedHosts2(prop_val, 1);
@@ -114,35 +116,35 @@ public String toString(Object value) {
                 return value.getClass().getName();
         }
     }
-    
+
     public static class BindInterface implements PropertyConverter {
 
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
-       	
+
         	// get the existing bind address - possibly null
         	InetAddress	old_bind_addr = (InetAddress)Configurator.getValueFromProtocol((Protocol)obj, ""bind_addr"");
-        	
+
         	// apply a bind interface constraint
             InetAddress new_bind_addr = Util.validateBindAddressFromInterface(old_bind_addr, propertyValue);
-            
+
             if (new_bind_addr != null)
             	setBindAddress((Protocol)obj, new_bind_addr) ;
 
             // if no bind_interface specified, set it to the empty string to avoid exception
             // from @Property processing
             if (propertyValue != null)
             	return propertyValue ;
-            else 
+            else
             	return """" ;
         }
 
-        
+
         private static void setBindAddress(Protocol protocol, InetAddress bind_addr) throws Exception {
             Field f=Util.getField(protocol.getClass(), ""bind_addr"");
 			Util.setField(f, protocol, bind_addr) ;
 		}
-        
-        
+
+
         // return a String version of the converted value
         public String toString(Object value) {
             return (String) value ;
@@ -176,7 +178,7 @@ public String toString(Object value) {
             return sb.toString();
         }
     }
-    
+
     public static class LongArray implements PropertyConverter {
 
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
@@ -206,6 +208,32 @@ public String toString(Object value) {
         }
     }
 
+    public static class StringProperties implements PropertyConverter {
+
+        @Override
+        public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
+            return Util.parseCommaDelimitedProps(propertyValue);
+        }
+
+        @Override
+        public String toString(Object value) {
+            if (value == null)
+                return null;
+            Map<String, String> v = (Map<String, String>) value;
+            StringBuilder sb = new StringBuilder();
+            boolean first = true;
+            for(Entry<String, String> entry : v.entrySet()) {
+                if (!first)
+                    sb.append("","");
+                else
+                    first = false;
+                sb.append(entry.getKey()).append(""="").append(entry.getValue());
+            }
+            return sb.toString();
+        }
+
+    }
+
 
     public static class Default implements PropertyConverter {
         static final String prefix;",2014-03-27T08:30:01Z,142
"@@ -0,0 +1,322 @@
+package org.jgroups.protocols;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.Property;
+import org.jgroups.auth.sasl.SaslClientContext;
+import org.jgroups.auth.sasl.SaslContext;
+import org.jgroups.auth.sasl.SaslServerContext;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.conf.PropertyConverters;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.GMS.GmsHeader;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.MessageBatch;
+
+/**
+ * The SASL protocol implements authentication and, if requested by the mech, encryption
+ *
+ * @author Tristan Tarrant
+ */
+@MBean(description = ""Provides SASL authentication"")
+public class SASL extends Protocol {
+    public static final short GMS_ID = ClassConfigurator.getProtocolId(GMS.class);
+    public static final short SASL_ID = ClassConfigurator.getProtocolId(SASL.class);
+
+    @Property(name = ""mech"", description = ""The name of the mech to require for authentication. Can be any mech supported by your local SASL provider. The JDK comes standard with CRAM-MD5, DIGEST-MD5, GSSAPI, NTLM"")
+    protected String mech;
+
+    @Property(name = ""sasl_props"", description = ""Properties specific to the chosen mech"", converter = PropertyConverters.StringProperties.class)
+    protected Map<String, String> sasl_props = new HashMap<String, String>();
+
+    @Property(name = ""timeout"", description = ""How long to wait (in ms) for a response to a challenge"")
+    protected long timeout = 5000;
+
+    protected CallbackHandler callback_handler;
+
+    protected Address local_addr;
+    protected final Map<Address, SaslContext> sasl_context = new HashMap<Address, SaslContext>();
+
+
+
+    public SASL() {
+        name = this.getClass().getSimpleName();
+    }
+
+    @Property(name = ""callback_handler_class"")
+    public void setCallbackHandlerClass(String handlerClass) throws Exception {
+        callback_handler = Class.forName(handlerClass).asSubclass(CallbackHandler.class).newInstance();
+    }
+
+    public String getCallbackHandlerClass() {
+        return callback_handler != null ? callback_handler.getClass().getName() : null;
+    }
+
+    public CallbackHandler getCallbackHandler() {
+        return callback_handler;
+    }
+
+    public void setCallbackHandler(CallbackHandler callback_handler) {
+        this.callback_handler = callback_handler;
+    }
+
+    public void setMech(String mech) {
+        this.mech = mech;
+    }
+
+    public String getMech() {
+        return mech;
+    }
+
+    public void setSaslProps(Map<String, String> sasl_props) {
+        this.sasl_props = sasl_props;
+    }
+
+    public Map<String, String> getSaslProps() {
+        return sasl_props;
+    }
+
+    public void setTimeout(long timeout) {
+        this.timeout = timeout;
+    }
+
+    public long getTimeout() {
+        return timeout;
+    }
+
+    public Address getAddress() {
+        return local_addr;
+    }
+
+    @Override
+    public void init() throws Exception {
+        super.init();
+    }
+
+    @Override
+    public void stop() {
+        super.stop();
+        cleanup();
+    }
+
+    @Override
+    public void destroy() {
+        super.destroy();
+        cleanup();
+    }
+
+    private void cleanup() {
+        for(SaslContext context : sasl_context.values()) {
+            context.dispose();
+        }
+        sasl_context.clear();
+    }
+
+    @Override
+    public Object up(Event evt) {
+        if (evt.getType() == Event.MSG) {
+            Message msg = (Message) evt.getArg();
+            SaslHeader saslHeader = (SaslHeader) msg.getHeader(SASL_ID);
+            GmsHeader gmsHeader = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(gmsHeader)) {
+                if (saslHeader == null)
+                    throw new IllegalStateException(""Found GMS join or merge request but no SASL header"");
+                if (!serverChallenge(gmsHeader, saslHeader, msg))
+                    return null; // failed auth, don't pass up
+            } else if (saslHeader != null) {
+                Address remoteAddress = msg.getSrc();
+                SaslContext saslContext = sasl_context.get(remoteAddress);
+                if (saslContext == null) {
+                    throw new IllegalStateException(String.format(
+                            ""Cannot find server context to challenge SASL request from %s"", remoteAddress.toString()));
+                }
+                switch (saslHeader.getType()) {
+                case CHALLENGE:
+                    try {
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: received CHALLENGE from %s"", getAddress(), remoteAddress);
+                        Message response = saslContext.nextMessage(remoteAddress, saslHeader);
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: sending RESPONSE to %s"", getAddress(), remoteAddress);
+                        down_prot.down(new Event(Event.MSG, response));
+                    } catch (SaslException e) {
+                        disposeContext(remoteAddress);
+                        if (log.isWarnEnabled()) {
+                            log.warn(""failed to validate CHALLENGE from "" + remoteAddress + "", token"", e);
+                        }
+                        sendRejectionMessage(gmsHeader.getType(), remoteAddress, ""authentication failed"");
+                    }
+                    break;
+                case RESPONSE:
+                    try {
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: received RESPONSE from %s"", getAddress(), remoteAddress);
+                        Message challenge = saslContext.nextMessage(remoteAddress, saslHeader);
+                        if (challenge != null) {
+                            if (log.isTraceEnabled())
+                                log.trace(""%s: sending CHALLENGE to %s"", getAddress(), remoteAddress);
+
+                            down_prot.down(new Event(Event.MSG, challenge));
+                        } else {
+                            if (log.isTraceEnabled())
+                                log.trace(""%s: authentication complete from %s"", getAddress(), remoteAddress);
+                        }
+                    } catch (SaslException e) {
+                        disposeContext(remoteAddress);
+                        if (log.isWarnEnabled()) {
+                            log.warn(""failed to validate RESPONSE from "" + remoteAddress + "", token"", e);
+                        }
+                    }
+                    break;
+                }
+                return null;
+            }
+        }
+
+        return up_prot.up(evt);
+    }
+
+    private void disposeContext(Address address) {
+        SaslContext context = sasl_context.remove(address);
+        if (context != null) {
+            context.dispose();
+        }
+    }
+
+    @Override
+    public void up(MessageBatch batch) {
+        for (Message msg : batch) {
+            // If we have a join or merge request --> authenticate, else pass up
+            GmsHeader gmsHeader = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(gmsHeader)) {
+                SaslHeader saslHeader = (SaslHeader) msg.getHeader(id);
+                if (saslHeader == null) {
+                    log.warn(""Found GMS join or merge request but no SASL header"");
+                    sendRejectionMessage(gmsHeader.getType(), batch.sender(), ""join or merge without an SASL header"");
+                    batch.remove(msg);
+                } else if (!serverChallenge(gmsHeader, saslHeader, msg)) // authentication failed
+                    batch.remove(msg); // don't pass up
+            }
+        }
+
+        if (!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+    @Override
+    public Object down(Event evt) {
+        switch (evt.getType()) {
+        case Event.SET_LOCAL_ADDRESS:
+            local_addr = (Address) evt.getArg();
+            break;
+        case Event.MSG:
+            Message msg = (Message) evt.getArg();
+            GmsHeader hdr = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(hdr)) {
+                // We are a client who needs to authenticate
+                SaslClientContext ctx = null;
+                Address remoteAddress = msg.getDest();
+                try {
+                    ctx = new SaslClientContext(mech, remoteAddress, callback_handler, sasl_props);
+                    sasl_context.put(remoteAddress, ctx);
+                    ctx.addHeader(msg, null);
+                } catch (SaslException e) {
+                    if (ctx != null) {
+                        disposeContext(remoteAddress);
+                    }
+                    throw new SecurityException(e);
+                }
+            }
+            break;
+        }
+
+        return down_prot.down(evt);
+    }
+
+    protected static boolean needsAuthentication(GmsHeader hdr) {
+        return (hdr != null)
+                && (hdr.getType() == GmsHeader.JOIN_REQ || hdr.getType() == GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER || hdr
+                        .getType() == GmsHeader.MERGE_REQ);
+    }
+
+    protected boolean serverChallenge(GmsHeader gmsHeader, SaslHeader saslHeader, Message msg) {
+        switch (gmsHeader.getType()) {
+        case GmsHeader.JOIN_REQ:
+        case GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+        case GmsHeader.MERGE_REQ:
+            Address remoteAddress = msg.getSrc();
+            SaslServerContext ctx = null;
+            try {
+                ctx = new SaslServerContext(mech, local_addr, callback_handler, sasl_props);
+                sasl_context.put(remoteAddress, ctx);
+                this.getDownProtocol().down(new Event(Event.MSG, ctx.nextMessage(remoteAddress, saslHeader)));
+                ctx.awaitCompletion(timeout);
+                if (ctx.isSuccessful()) {
+                    if (log.isDebugEnabled()) {
+                        log.debug(""Authorization successful for %s"", ctx.getAuthorizationID());
+                    }
+                    return true;
+                } else {
+                    log.warn(""failed to validate SaslHeader from %s, header: %s"", msg.getSrc(), saslHeader);
+                    sendRejectionMessage(gmsHeader.getType(), msg.getSrc(), ""authentication failed"");
+                    return false;
+                }
+            } catch (SaslException e) {
+                log.warn(""failed to validate SaslHeader from %s, header: %s"", msg.getSrc(), saslHeader);
+                sendRejectionMessage(gmsHeader.getType(), msg.getSrc(), ""authentication failed"");
+            } catch (InterruptedException e) {
+                return false;
+            } finally {
+                if (ctx != null && !ctx.needsWrapping()) {
+                    disposeContext(remoteAddress);
+                }
+            }
+        default:
+            return true; // pass up
+        }
+    }
+
+    protected void sendRejectionMessage(byte type, Address dest, String error_msg) {
+        switch (type) {
+        case GmsHeader.JOIN_REQ:
+        case GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            sendJoinRejectionMessage(dest, error_msg);
+            break;
+        case GmsHeader.MERGE_REQ:
+            sendMergeRejectionMessage(dest);
+            break;
+        default:
+            log.error(""type "" + type + "" unknown"");
+            break;
+        }
+    }
+
+    protected void sendJoinRejectionMessage(Address dest, String error_msg) {
+        if (dest == null)
+            return;
+
+        JoinRsp joinRes = new JoinRsp(error_msg); // specify the error message on the JoinRsp
+        Message msg = new Message(dest).putHeader(GMS_ID, new GmsHeader(GmsHeader.JOIN_RSP)).setBuffer(
+                GMS.marshal(joinRes));
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+
+    protected void sendMergeRejectionMessage(Address dest) {
+        Message msg = new Message(dest).setFlag(Message.Flag.OOB);
+        GmsHeader hdr = new GmsHeader(GmsHeader.MERGE_RSP);
+        hdr.setMergeRejected(true);
+        msg.putHeader(GMS_ID, hdr);
+        if (log.isDebugEnabled())
+            log.debug(""merge response="" + hdr);
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+}",2014-03-27T08:30:01Z,143
"@@ -0,0 +1,76 @@
+package org.jgroups.protocols;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+import org.jgroups.Header;
+import org.jgroups.util.Util;
+
+public class SaslHeader extends Header {
+    public enum Type {
+        CHALLENGE, RESPONSE
+    };
+
+    private Type type;
+    private byte[] payload;
+
+    public SaslHeader() {
+    }
+
+    public SaslHeader(Type type, byte[] payload) {
+        this.type = type;
+        this.payload = payload;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+
+    public void setPayload(byte[] payload) {
+        this.payload = payload;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public SaslHeader payload(byte[] payload) {
+        this.payload = payload;
+        return this;
+    }
+
+    public byte[] token() {
+        return payload;
+    }
+
+    public SaslHeader type(Type type) {
+        this.type = type;
+        return this;
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type.ordinal());
+        Util.writeByteBuffer(payload, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        type = Type.values()[in.readByte()];
+        payload = Util.readByteBuffer(in);
+    }
+
+    @Override
+    public int size() {
+        return Util.size(payload);
+    }
+
+    @Override
+    public String toString() {
+        return ""payload="" + payload;
+    }
+}",2014-03-27T08:30:01Z,144
"@@ -17,6 +17,7 @@
 
 import javax.management.MBeanServer;
 import javax.management.MBeanServerFactory;
+
 import java.io.*;
 import java.lang.annotation.Annotation;
 import java.lang.management.ManagementFactory;
@@ -313,20 +314,20 @@ public static short getScope(Message msg) {
         SCOPE.ScopeHeader hdr=(SCOPE.ScopeHeader)msg.getHeader(Global.SCOPE_ID);
         return hdr != null? hdr.getScope() : 0;
     }
-    
+
    public static byte[] createAuthenticationDigest(String passcode, long t1, double q1) throws IOException,
             NoSuchAlgorithmException {
       ByteArrayOutputStream baos = new ByteArrayOutputStream(512);
       DataOutputStream out = new DataOutputStream(baos);
       byte[] digest = createDigest(passcode, t1, q1);
       out.writeLong(t1);
-      out.writeDouble(q1);      
+      out.writeDouble(q1);
       out.writeInt(digest.length);
       out.write(digest);
       out.flush();
       return baos.toByteArray();
    }
-   
+
     public static byte[] createDigest(String passcode, long t1, double q1)
       throws IOException, NoSuchAlgorithmException {
         MessageDigest md = MessageDigest.getInstance(""SHA"");
@@ -402,12 +403,12 @@ public static void shutdown(Channel ch) throws Exception {
         ProtocolStack stack=ch.getProtocolStack();
         TP transport=stack.getTransport();
         stack.insertProtocol(discard,  ProtocolStack.ABOVE, transport.getClass());
-        
+
         //abruptly shutdown FD_SOCK just as in real life when member gets killed non gracefully
         FD_SOCK fd = (FD_SOCK) ch.getProtocolStack().findProtocol(FD_SOCK.class);
         if(fd != null)
             fd.stopServerSocket(false);
-        
+
         View view=ch.getView();
         if (view != null) {
             ViewId vid = view.getViewId();
@@ -499,7 +500,7 @@ public static Object objectFromByteBuffer(byte[] buffer, int offset, int length)
 
     /**
      * Serializes/Streams an object into a byte buffer.
-     * The object has to implement interface Serializable or Externalizable or Streamable. 
+     * The object has to implement interface Serializable or Externalizable or Streamable.
      */
     public static byte[] objectToByteBuffer(Object obj) throws Exception {
         if(obj == null)
@@ -1145,7 +1146,7 @@ public static Object readObject(DataInput in) throws Exception {
         int len=in.readInt();
         if(len == -1)
             return readGenericStreamable(in);
-        
+
         byte[] buf=new byte[len];
         in.readFully(buf, 0, len);
         return objectFromByteBuffer(buf);
@@ -2091,7 +2092,7 @@ public static <T> T pickNext(List<T> list, T obj) {
         return null;
     }
 
-    /** Returns the next min(N,list.size()) elements after obj */ 
+    /** Returns the next min(N,list.size()) elements after obj */
     public static <T> List<T> pickNext(List<T> list, T obj, int num) {
         List<T> retval=new ArrayList<T>();
         if(list == null || list.size() < 2)
@@ -2651,6 +2652,16 @@ public static List<String> parseStringList(String l, String separator) {
          return tmp;
      }
 
+    public static Map<String, String> parseCommaDelimitedProps(String s) {
+        Map<String, String> props = new HashMap<String, String>();
+        Pattern p = Pattern.compile(""\\s*([^=\\s]+)\\s*=\\s*([^=\\s,]+)\\s*,?""); //Pattern.compile(""\\s*([^=\\s]+)\\s*=\\s([^=\\s]+)\\s*,?"");
+        Matcher matcher = p.matcher(s);
+        while(matcher.find()) {
+            props.put(matcher.group(1), matcher.group(2));
+        }
+        return props;
+    }
+
 
     /**
      * Reads and discards all characters from the input stream until a \r\n or EOF is encountered
@@ -2967,7 +2978,7 @@ public static MulticastSocket createMulticastSocket(SocketFactory factory, Strin
                 String type=mcast_addr != null ? mcast_addr instanceof Inet4Address? ""IPv4"" : ""IPv6"" : ""n/a"";
                 sb.append(""could not bind to "" + mcast_addr + "" ("" + type + "" address)"");
                 sb.append(""; make sure your mcast_addr is of the same type as the preferred IP stack (IPv4 or IPv6)"");
-                sb.append("" by checking the value of the system properties java.net.preferIPv4Stack and java.net.preferIPv6Addresses."");                
+                sb.append("" by checking the value of the system properties java.net.preferIPv4Stack and java.net.preferIPv6Addresses."");
                 sb.append(""\nWill ignore mcast_addr, but this may lead to cross talking "" +
                         ""(see http://www.jboss.org/community/docs/DOC-9469 for details). "");
                 sb.append(""\nException was: "" + ex);
@@ -2983,16 +2994,16 @@ public static MulticastSocket createMulticastSocket(SocketFactory factory, Strin
 
     /**
      * Method used by PropertyConverters.BindInterface to check that a bind_address is
-     * consistent with a specified interface 
-     * 
+     * consistent with a specified interface
+     *
      * Idea:
      * 1. We are passed a bind_addr, which may be null
-     * 2. If non-null, check that bind_addr is on bind_interface - if not, throw exception, 
+     * 2. If non-null, check that bind_addr is on bind_interface - if not, throw exception,
      * otherwise, return the original bind_addr
      * 3. If null, get first non-loopback address on bind_interface, using stack preference to
      * get the IP version. If no non-loopback address, then just return null (i.e. the
      * bind_interface did not influence the decision).
-     * 
+     *
      */
     public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr, String bind_interface_str) throws UnknownHostException, SocketException {
     	NetworkInterface bind_intf=null;
@@ -3003,10 +3014,10 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     	// 1. if bind_interface_str is null, or empty, no constraint on bind_addr
     	if (bind_interface_str == null || bind_interface_str.trim().isEmpty())
     		return bind_addr;
-    	
-    	// 2. get the preferred IP version for the JVM - it will be IPv4 or IPv6 
+
+    	// 2. get the preferred IP version for the JVM - it will be IPv4 or IPv6
     	StackType ip_version = getIpStackType();
-    	
+
     	// 3. if bind_interface_str specified, get interface and check that it has correct version
     	bind_intf=Util.getByName(bind_interface_str); // NetworkInterface.getByName(bind_interface_str);
     	if(bind_intf != null) {
@@ -3033,7 +3044,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     			InetAddress address = (InetAddress) addresses.nextElement() ;
 
     			// check if address is on interface
-    			if (bind_addr.equals(address)) { 
+    			if (bind_addr.equals(address)) {
     				hasAddress = true ;
     				break ;
     			}
@@ -3045,7 +3056,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     		}
 
     	}
-    	// 4. if only interface is specified, get first non-loopback address on that interface, 
+    	// 4. if only interface is specified, get first non-loopback address on that interface,
     	else {
     		bind_addr = getAddress(bind_intf, AddressScope.NON_LOOPBACK) ;
     	}
@@ -3058,7 +3069,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     	if(bind_addr != null && NetworkInterface.getByInetAddress(bind_addr) == null) {
     		throw new UnknownHostException(""Invalid bind address "" + bind_addr);
     	}
-    	
+
     	// if bind_addr == null, we have tried to obtain a bind_addr but were not successful
     	// in such a case, return the original value of null so the default will be applied
 
@@ -3092,7 +3103,7 @@ public static boolean checkForLinux() {
     public static boolean checkForHp() {
        return checkForPresence(""os.name"", ""hp"");
     }
- 
+
     public static boolean checkForSolaris() {
         return checkForPresence(""os.name"", ""sun"");
     }
@@ -3270,13 +3281,13 @@ public static InetAddress getAddress(NetworkInterface intf, AddressScope scope)
         return null ;
     }
 
-    
+
 
 
     /**
-     * A function to check if an interface supports an IP version (i.e has addresses 
+     * A function to check if an interface supports an IP version (i.e has addresses
      * defined for that IP version).
-     * 
+     *
      * @param intf
      * @return
      */
@@ -3301,8 +3312,8 @@ public static boolean interfaceHasIPAddresses(NetworkInterface intf, StackType i
             throw new UnknownHostException(""network interface "" + intf + "" not found"") ;
         }
         return supportsVersion ;
-    }         
-        
+    }
+
     public static StackType getIpStackType() {
        return ip_stack_type;
     }
@@ -3344,7 +3355,7 @@ else if (isIPv4StackAvailable && isIPv6StackAvailable) {
 		}
 		return StackType.Unknown;
     }
-    
+
 
 
 	public static boolean isStackAvailable(boolean ipv4) {
@@ -3354,8 +3365,8 @@ public static boolean isStackAvailable(boolean ipv4) {
                 return true;
         return false;
     }
-    
-	
+
+
     public static List<NetworkInterface> getAllAvailableInterfaces() throws SocketException {
         List<NetworkInterface> retval=new ArrayList<NetworkInterface>(10);
         NetworkInterface intf;
@@ -3384,7 +3395,7 @@ public static Collection<InetAddress> getAllAvailableAddresses() {
         catch(SocketException e) {
             e.printStackTrace();
         }
-        
+
         return retval;
     }
 
@@ -3398,7 +3409,7 @@ public static void checkIfValidAddress(InetAddress bind_addr, String prot_name)
         }
         throw new BindException(""["" + prot_name + ""] "" + bind_addr + "" is not a valid address on any local network interface"");
     }
-    
+
 
 
     /**",2014-03-27T08:30:01Z,54
"@@ -0,0 +1,106 @@
+package org.jgroups.protocols;
+
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.io.IOException;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.Test;
+
+@Test(groups = Global.FUNCTIONAL, singleThreaded = true)
+public class SASLTest {
+    private static final String REALM = ""MyRealm"";
+    private JChannel a;
+    private JChannel b;
+
+    private JChannel createChannel(String channelName, String mech, String username) throws Exception {
+        SASL sasl = new SASL();
+        sasl.setMech(mech);
+        sasl.setCallbackHandler(new MyCallbackHandler(username));
+        sasl.setTimeout(5000);
+        sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
+        return new JChannel(
+                new Protocol[] {
+                        new SHARED_LOOPBACK(),
+                        new PING(),
+                        new NAKACK2(),
+                        new UNICAST3(),
+                        new STABLE(),
+                        sasl,
+                        new GMS() }
+                ).name(channelName);
+    }
+
+    public void testSASLDigestMD5() throws Exception {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jack"");
+        a.connect(""SaslTest"");
+        b.connect(""SaslTest"");
+        assertTrue(b.isConnected());
+    }
+
+
+    @Test(expectedExceptions=SecurityException.class)
+    public void testSASLDigestMD5Failure() throws Throwable {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jill"");
+        a.connect(""SaslTest"");
+        try {
+            b.connect(""SaslTest"");
+        } catch (Exception e) {
+            if (e.getCause() != null)
+                throw e.getCause();
+        }
+    }
+
+    @AfterMethod
+    public void cleanup() {
+        a.close();
+        b.close();
+    }
+
+
+    public static class MyCallbackHandler implements CallbackHandler {
+        final private String password;
+
+        public MyCallbackHandler(String password) {
+            this.password = password;
+        }
+
+        @Override
+        public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+            for(Callback callback : callbacks) {
+                if (callback instanceof NameCallback) {
+                    NameCallback nameCallback = (NameCallback)callback;
+                    nameCallback.setName(""user"");
+                } else if (callback instanceof PasswordCallback) {
+                    PasswordCallback passwordCallback = (PasswordCallback)callback;
+                    passwordCallback.setPassword(password.toCharArray());
+                } else if (callback instanceof AuthorizeCallback) {
+                    AuthorizeCallback authorizeCallback = (AuthorizeCallback)callback;
+                    authorizeCallback.setAuthorized(authorizeCallback.getAuthenticationID().equals(authorizeCallback.getAuthorizationID()));
+                } else if (callback instanceof RealmCallback) {
+                    RealmCallback realmCallback = (RealmCallback) callback;
+                    realmCallback.setText(REALM);
+                } else {
+                    throw new UnsupportedCallbackException(callback);
+                }
+            }
+        }
+
+    }
+}",2014-03-27T08:30:01Z,56
"@@ -11,6 +11,7 @@
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.List;
+import java.util.Map;
 
 /**
  * @author Bela Ban
@@ -59,6 +60,15 @@ public static void testNetworkList() throws Exception {
         assert str.equals(loopback_name) || str.equals(""lo0"");
     }
 
+    public static void testStringProperties() throws Exception {
+        PropertyConverter c = new PropertyConverters.StringProperties();
+
+        String value = ""com.sun.security.sasl.digest.realm=MyRealm,qop=true"";
+        Map<String, String> map = (Map<String, String>) c.convert(null, Map.class, ""props"", value, false);
+        assert map.size() == 2;
+        assert map.get(""qop"").equals(""true"");
+        assert map.get(""com.sun.security.sasl.digest.realm"").equals(""MyRealm"");
+    }
 
     private static void check(Protocol protocol, Class<?> type, String prop, Object result, PropertyConverter converter) throws Exception {
         Object tmp=converter.convert(protocol, type, ""bela"", prop, false);
@@ -87,4 +97,5 @@ private static String getLoopbackName() throws SocketException {
         }
         return null;
     }
+
 }",2014-03-27T08:30:01Z,145
"@@ -35,7 +35,7 @@
  * Discovery protocol using Amazon's S3 storage. The S3 access code reuses the example shipped by Amazon.
  * This protocol is unsupported and experimental !
  * @author Bela Ban
- * @version $Id: S3_PING.java,v 1.12 2010/09/16 14:57:17 belaban Exp $
+ * @version $Id: S3_PING.java,v 1.13 2010/09/17 19:36:37 benbrowning Exp $
  */
 @Experimental
 public class S3_PING extends FILE_PING {
@@ -49,6 +49,12 @@ public class S3_PING extends FILE_PING {
     @Property(description=""When non-null, we set location to prefix-UUID"")
     protected String prefix=null;
 
+    @Property(description=""When non-null, we use this pre-signed URL for PUTs"")
+    protected String pre_signed_put_url=null;
+
+    @Property(description=""When non-null, we use this pre-signed URL for DELETEs"")
+    protected String pre_signed_delete_url=null;
+
     protected AWSAuthConnection conn=null;
 
 
@@ -58,6 +64,8 @@ public void init() throws Exception {
         //if(access_key == null || secret_access_key == null)
           //  throw new IllegalArgumentException(""access_key and secret_access_key must be non-null"");
 
+        validateProperties();
+
         conn=new AWSAuthConnection(access_key, secret_access_key);
 
         if(prefix != null && prefix.length() > 0) {
@@ -80,6 +88,10 @@ public void init() throws Exception {
             }
         }
 
+        if(usingPreSignedUrls()) {
+            PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+            location = parsedPut.getBucket();
+        }
 
         if(!conn.checkBucketExists(location)) {
             conn.createBucket(location, AWSAuthConnection.LOCATION_DEFAULT, null).connection.getResponseMessage();
@@ -102,6 +114,10 @@ protected List<PingData> readAll(String clustername) {
 
         List<PingData> retval=new ArrayList<PingData>();
         try {
+            if (usingPreSignedUrls()) {
+                PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+                clustername = parsedPut.getPrefix();
+            }
             ListBucketResponse rsp=conn.listBucket(location, clustername, null, null, null);
             if(rsp.entries != null) {
                 for(Iterator<ListEntry> it=rsp.entries.iterator(); it.hasNext();) {
@@ -137,11 +153,18 @@ protected void writeToFile(PingData data, String clustername) {
         String filename=local_addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)local_addr).toStringLong() : local_addr.toString();
         String key=clustername + ""/"" + filename;
         try {
-            Map headers=new TreeMap();
-            headers.put(""Content-Type"", Arrays.asList(""text/plain""));
             byte[] buf=Util.objectToByteBuffer(data);
             S3Object val=new S3Object(buf, null);
-            conn.put(location, key, val, headers).connection.getResponseMessage();
+
+            if (pre_signed_put_url != null) {
+                Map headers = new TreeMap();
+                headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+                conn.put(pre_signed_put_url, val, headers).connection.getResponseMessage();
+            } else {
+                Map headers=new TreeMap();
+                headers.put(""Content-Type"", Arrays.asList(""text/plain""));
+                conn.put(location, key, val, headers).connection.getResponseMessage();
+            }
         }
         catch(Exception e) {
             log.error(""failed marshalling "" + data + "" to buffer"", e);
@@ -157,7 +180,11 @@ protected void remove(String clustername, Address addr) {
         try {
             Map headers=new TreeMap();
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
-            conn.delete(location, key, headers).connection.getResponseMessage();
+            if (pre_signed_delete_url != null) {
+                conn.delete(pre_signed_delete_url).connection.getResponseMessage();
+            } else {
+                conn.delete(location, key, headers).connection.getResponseMessage();
+            }
             if(log.isTraceEnabled())
                 log.trace(""removing "" + location + ""/"" + key);
         }
@@ -167,7 +194,103 @@ protected void remove(String clustername, Address addr) {
     }
 
 
+    protected void validateProperties() {
+        if (pre_signed_put_url != null && pre_signed_delete_url != null) {
+            PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+            PreSignedUrlParser parsedDelete = new PreSignedUrlParser(pre_signed_delete_url);
+            if (!parsedPut.getBucket().equals(parsedDelete.getBucket()) ||
+                    !parsedPut.getPrefix().equals(parsedDelete.getPrefix())) {
+                throw new IllegalArgumentException(""pre_signed_put_url and pre_signed_delete_url must have the same path"");
+            }
+        } else if (pre_signed_put_url != null || pre_signed_delete_url != null) {
+            throw new IllegalArgumentException(""pre_signed_put_url and pre_signed_delete_url must both be set or both unset"");
+        }
+    }
+    
+    protected boolean usingPreSignedUrls() {
+        return pre_signed_put_url != null;
+    }
+
+
+    /**
+     * Use this helper method to generate pre-signed S3 urls for use with S3_PING.
+     * You'll need to generate urls for both the put and delete http methods.
+     * Example:
+     * Your AWS Access Key is ""abcd"".
+     * Your AWS Secret Access Key is ""efgh"".
+     * You want this node to write its information to ""/S3_PING/DemoCluster/node1"".
+     * So, your bucket is ""S3_PING"" and your key is ""DemoCluster/node1"".
+     * You want this to expire one year from now, or
+     *   (System.currentTimeMillis / 1000) + (60 * 60 * 24 * 365)
+     *   Let's assume that this equals 1316286684
+     * 
+     * Here's how to generate the value for the pre_signed_put_url property:
+     * String putUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
+     *                                              ""S3_Ping"", ""DemoCluster/node1"",
+     *                                              1316286684);
+     *                                              
+     * Here's how to generate the value for the pre_signed_delete_url property:
+     * String deleteUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
+     *                                                 ""S3_Ping"", ""DemoCluster/node1"",
+     *                                                 1316286684);
+     * 
+     * @param awsAccessKey Your AWS Access Key
+     * @param awsSecretAccessKey Your AWS Secret Access Key
+     * @param method The HTTP method - use ""put"" or ""delete"" for use with S3_PING
+     * @param bucket The S3 bucket you want to write to
+     * @param key The key within the bucket to write to
+     * @param expirationDate The date this pre-signed url should expire, in seconds since epoch
+     * @return The pre-signed url to be used in pre_signed_put_url or pre_signed_delete_url properties
+     */
+    public static String generatePreSignedUrl(String awsAccessKey, String awsSecretAccessKey, String method,
+                                       String bucket, String key, long expirationDate) {
+        Map headers = new HashMap();
+        if (method.equalsIgnoreCase(""PUT"")) {
+            headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+        }
+        return Utils.generateQueryStringAuthentication(awsAccessKey, awsSecretAccessKey, method,
+                                                       bucket, key, new HashMap(), headers,
+                                                       expirationDate);
+    }
+
+
+
+    /**
+     * Utility class to parse S3 pre-signed URLs
+     */
+    static class PreSignedUrlParser {
+        String bucket = """";
+        String prefix = """";
+
+        public PreSignedUrlParser(String preSignedUrl) {
+            try {
+                URL url = new URL(preSignedUrl);
+                String path = url.getPath();
+                String[] pathParts = path.split(""/"");
+                
+                if (pathParts.length < 3) {
+                    throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" must point to a file within a bucket"");
+                }
+                if (pathParts.length > 4) {
+                    throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" may only have only subdirectory under a bucket"");
+                }
+                this.bucket = pathParts[1];
+                if (pathParts.length > 3) {
+                    this.prefix = pathParts[2];
+                }
+            } catch (MalformedURLException ex) {
+                throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" is not a valid url"");
+            }
+        }
 
+        public String getBucket() {
+            return bucket;
+        }
+        
+        public String getPrefix() {
+            return prefix;
+        }
+    }
 
     
 
@@ -355,6 +478,14 @@ public Response put(String bucket, String key, S3Object object, Map headers) thr
             return new Response(request);
         }
 
+        public Response put(String preSignedUrl, S3Object object, Map headers) throws IOException {
+            HttpURLConnection request = makePreSignedRequest(""PUT"", preSignedUrl, headers);
+            request.setDoOutput(true);
+            request.getOutputStream().write(object.data == null? new byte[]{} : object.data);
+
+            return new Response(request);
+        }
+
         /**
          * Creates a copy of an existing S3 Object.  In this signature, we will copy the
          * existing metadata.  The default access control policy is private; if you want
@@ -444,6 +575,10 @@ public Response delete(String bucket, String key, Map headers) throws IOExceptio
             return new Response(makeRequest(""DELETE"", bucket, Utils.urlencode(key), null, headers));
         }
 
+        public Response delete(String preSignedUrl) throws IOException {
+            return new Response(makePreSignedRequest(""DELETE"", preSignedUrl, null));
+        }
+
         /**
          * Get the requestPayment xml document for a given bucket
          * @param bucket  The name of the bucket
@@ -642,6 +777,16 @@ private HttpURLConnection makeRequest(String method, String bucket, String key,
             return connection;
         }
 
+        private HttpURLConnection makePreSignedRequest(String method, String preSignedUrl, Map headers) throws IOException {
+            URL url = new URL(preSignedUrl);
+            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod(method);
+
+            addHeaders(connection, headers);
+
+            return connection;
+        }
+
         /**
          * Add the given headers to the HttpURLConnection.
          * @param connection The HttpURLConnection to which the headers will be added.
@@ -1644,6 +1789,30 @@ static CallingFormat getCallingFormatForBucket(CallingFormat desiredFormat, Stri
             }
             return callingFormat;
         }
+
+        public static String generateQueryStringAuthentication(String awsAccessKey, String awsSecretAccessKey,
+                                                               String method, String bucket, String key,
+                                                               Map pathArgs, Map headers) {
+            int defaultExpiresIn = 300; // 5 minutes
+            long expirationDate = (System.currentTimeMillis() / 1000) + defaultExpiresIn;
+            return generateQueryStringAuthentication(awsAccessKey, awsSecretAccessKey,
+                                                     method, bucket, key,
+                                                     pathArgs, headers, expirationDate);
+        }
+
+        public static String generateQueryStringAuthentication(String awsAccessKey, String awsSecretAccessKey,
+                                                               String method, String bucket, String key,
+                                                               Map pathArgs, Map headers, long expirationDate) {
+            method = method.toUpperCase(); // Method should always be uppercase
+            String canonicalString =
+                makeCanonicalString(method, bucket, key, pathArgs, headers, """" + expirationDate);
+            String encodedCanonical = encode(awsSecretAccessKey, canonicalString, true);
+            return ""http://"" + DEFAULT_HOST + ""/"" + bucket + ""/"" + key + ""?"" +
+                ""AWSAccessKeyId="" + awsAccessKey + ""&Expires="" + expirationDate +
+                ""&Signature="" + encodedCanonical;
+            // connection.setRequestProperty(""Authorization"",
+            //                               ""AWS "" + this.awsAccessKeyId + "":"" + encodedCanonical);
+        }
     }
 
 ",2010-09-17T19:36:37Z,109
"@@ -0,0 +1,132 @@
+package org.jgroups.protocols;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.jgroups.Global;
+import org.jgroups.protocols.S3_PING.Utils;
+import org.testng.Assert;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+@Test(groups={Global.STACK_INDEPENDENT})
+public class S3_PINGTest {
+    private S3_PING ping;
+
+    @BeforeMethod
+    public void setUp() {
+        ping = new S3_PING();
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithPreSignedPutSet() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithPreSignedDeleteSet() {
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButNoBucket() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButNoFile() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButTooManySubdirectories() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testValidatePropertiesWithBothPreSignedSetToValid() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testValidatePropertiesWithBothPreSignedSetToValidSubdirectory() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testUsingPreSignedUrlWhenNotSet() {
+        Assert.assertFalse(ping.usingPreSignedUrls());
+    }
+    
+    @Test
+    public void testUsingPreSignedUrlWhenSet() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        Assert.assertTrue(ping.usingPreSignedUrls());
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicGet() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""get"",
+                                                    ""test-bucket"", ""node1"",
+                                                    new HashMap(), new HashMap(),
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicPost() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""POST"",
+                                                    ""test-bucket"", ""node1"",
+                                                    new HashMap(), new HashMap(),
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
+        Map headers = new HashMap();
+        headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""put"",
+                                                    ""test-bucket"", ""subdir/node1"",
+                                                    new HashMap(), headers,
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGeneratePreSignedUrlForPut() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
+                                                           ""test-bucket"", ""subdir/node1"",
+                                                           1234567890);
+        Assert.assertEquals(preSignedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGeneratePreSignedUrlForDelete() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
+        String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
+                                                           ""test-bucket"", ""subdir/node1"",
+                                                           1234567890);
+        Assert.assertEquals(preSignedUrl, expectedUrl);
+    }
+}
\ No newline at end of file",2010-09-17T19:36:37Z,110
"@@ -0,0 +1,167 @@
+
+New UNICAST design
+==================
+(see UNICAST.txt for the old design)
+
+Author: Bela Ban
+Version: $Id: UNICAST.new.txt,v 1.2 2009/04/24 14:49:44 belaban Exp $
+
+Motivation
+----------
+
+UNICAST has issues when one end of the connnection unilaterally closes the connection and discards the state in
+the connection table.
+
+Example: we have a conn between A and B. There's a partition such that A sees {A,B} but B sees only {B}.
+B will clear its connection table for A on reception of the view, whereas A will keep it.
+
+Now the partition heals and A and B can communicate again.
+
+Assuming A's next seqno to B is #25 (and #7 for receiving messages from B),
+B will store the message because it expects #1 from A (new connection). As a matter of fact, B will store *and not
+deliver* all subsequent messages from A !
+
+The reverse direction is also bad: B will send #1 to A, but A expects #7, so A will discard the message. The first 6
+messages from B are discarded at A !
+
+
+Goals
+-----
+
+#1 Handle the above scenarios
+
+#2 Handle the scenario where a member communicates with a non-member (get rid of enabled_mbrs and prev_mbrs)
+
+#3 Handle the scenario where a member talks to a non existing (or previous) member. Get rid of
+   ENABLE_UNICASTS_TO and age out connections to non existing members after some time (JGRP-942)
+
+#4 Should be usable without group communication ('Unicast JGroups')
+
+
+Design
+------
+
+As example we have a unicast connection between A and B. A is the sender and B the receiver:
+
+             A <-------------------------------------------------> B
+
+             B:entry.seqno=#25                                     A:entry.seqno=#7
+                     recv_win=#7                                           recv_win=#25
+                     send-conn-id=322649                                   send-conn-id=101200
+                     recv-conn-id=101200                                   recv-conn-id=322649
+
+A has an entry in the connection table for B, and B has an entry for A. Each connection has a connection ID (conn-id).
+Each entry also has a seqno which is the highest seqno sent to the peer so far, and a recv_win which has the highest
+seqno received from the peer so far. For example, A's next message to B will be #25, and the next seqno expected
+from B is #7.
+
+
+
+A sends a message to B:
+- If the entry for B is null, or the seqno=0:
+    - Create an entry, set the seqno to 1 and set send-conn-id to the current time (needs to be unique, could also use UUIDs)
+    - Add send-conn-id to the UnicastHeader and send the message
+- Else
+    - Send the message with the next seqno (and conn-id=0)
+
+B receives a message from A:
+- If conn-id == 0
+    - If entry.recv_win != null:
+        - Add message to entry.recv_win
+    - Else
+        - Discard message
+        - Send GET_FIRST_SEQNO to A
+- Else
+    - If entry or entry.recv_win for B is null
+        - Create a new entry.recv_win with msg.seqno
+        - Set entry.recv-conn-id to conn-id
+    - Else:
+        - If conn-id != entry.recv-conn-id:
+            - Create a new entry.recv_win with msg.seqno
+            - Set entry.recv-conn-id to conn-id
+        - Else
+            - NOP (prevents duplicate connection establishments)
+
+
+
+A receives GET_FIRST_SEQNO from B:
+- A grabs the first message in its sent_win
+- A adds the entry.send-conn-id to the UnicastHeader (if not yet present) and sends the message to B
+
+
+
+Scenarios
+---------
+
+#1 A creates new connection to B:
+- The entry for B is null, a new entry is created and added to the connection table
+- Entry.send-conn-id is set and sent with the message
+- Entry.seqno now is 1
+
+
+#2 B receives new connection:
+- B creates a new entry and entry.recv_win (with msg.seqno) for A
+- B sets entry.recv-conn-id to msg.conn-id
+- B adds the message to entry.recv_win
+
+
+#3 A and B close connection (e.g. based on a view change (partition)):
+- Both A and B reset (cancelling pending retransmissions) and remove the entry for their peer from the connection table
+
+
+#4 A closes the connection unilaterally (B keeps it open), then reopens it and sends a message:
+- A removes the entry for B from its connection table, cancelling all pending retransmissions
+- (Assuming that B's entry.recv_win for A is at #25)
+- A creates a new entry for B in its connection table
+- Entry.send-conn-id is set and sent with the message
+- Entry.seqno now is 1
+- B receives the message with a new conn-id
+- B does have an entry for A, but entry.recv-conn-id doesn't match msg.conn-id
+- B creates a new entry.recv_win, sets it to msg.seqno
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+#5 B closes its connection unilaterally, then A sends a message to B:
+- B doesn't find an entry for A in its connection table
+- B discards the message and sends a SEND-FIRST-SEQNO to A
+- A receives the SEND-FIRST-SEQNO message. It grabs the message with the lowest seqno
+  in its entry.send_win, adds a UnicastHeader with entry.send-conn-id and sends the
+  message to B
+- B receive the message and creates a new entry and entry.recv_win (with msg.seqno)
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+#6 Merge where A and B are in different partitions:
+- Both A and B removes the entries for each other in their respective connection tables
+- When the partition heals, both A and B will create new entries (see scenario #2)
+
+
+#7 Merge where A and B are in overlapping partitions A: {A}, B: {A,B}:
+- (This case is currently handled by shunning, not merging)
+- A sends a message to B
+- A removed its entry for B, but B kept its entry for A
+- A new creates a new connection to B (scenario #1) and sends the message
+- B receives the message, but entry.recv-conn-id doesn't match msg.conn-id, so B
+  removes entry.recv_win, sets entry.recv-conn-id to msg.conn-id and creates a new
+  entry.recv_win with msg.seqno (same as second half of scenario #4)
+
+
+#8 Merge where A and B are in overlapping partitions A: {A,B}, B: {B}:
+- A sends a message to B (msg.seqno=25)
+- B doesn't have an entry for A
+- B discards the message and sends a SEND-FIRST-SEQNO to A
+- A receives the SEND-FIRST-SEQNO message. It grabs the message with the lowest seqno
+  in its entry.send_win, adds a UnicastHeader with entry.send-conn-id and sends the
+  message to B
+- B receive the message and creates a new entry and entry.recv_win (with msg.seqno)
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+Issues
+------
+- How do we handle retransmissions of the first message (first=true) ? We *cannot* create a new entry.recv_win, or
+  else we trash already received msgs ! Use a UUID (as connection-ID) instead of first=true ? Maybe the system time
+  is sufficient ? After all, the ID only has to be unique between A and B !
+  ==> Solved by using connection IDs (see above)
+
+",2009-04-24T14:48:33Z,146
"@@ -0,0 +1,365 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.FD;
+import org.jgroups.protocols.FD_ALL;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Digest;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.AfterTest;
+
+import java.util.*;
+
+/**
+ * Tests overlapping merges, e.g. A: {A,B}, B: {A,B} and C: {A,B,C}. Tests unicast as well as multicast seqno tables.<br/>
+ * Related JIRA: https://jira.jboss.org/jira/browse/JGRP-940
+ * @author Bela Ban
+ * @version $Id: OverlappingMergeTest.java,v 1.2 2009/04/24 14:48:33 belaban Exp $
+ */
+@Test(groups=Global.STACK_DEPENDENT,sequential=true)
+public class OverlappingMergeTest extends ChannelTestBase {
+    private JChannel a, b, c;
+    private MyReceiver ra, rb, rc;
+
+    @BeforeTest
+    protected void start() throws Exception {
+        ra=new MyReceiver(""A""); rb=new MyReceiver(""B""); rc=new MyReceiver(""C"");
+        a=createChannel(true, 3);
+        a.setReceiver(ra);
+
+        b=createChannel(a);
+        b.setReceiver(rb);
+
+        c=createChannel(a); 
+        c.setReceiver(rc);
+        modifyConfigs(a, b, c);
+
+        a.connect(""OverlappingMergeTest"");
+        b.connect(""OverlappingMergeTest"");
+        c.connect(""OverlappingMergeTest"");
+        View view=c.getView();
+        assert view.size() == 3 : ""view is "" + view;
+    }
+
+    @AfterTest
+    protected void stop() throws Exception {
+        Util.close(c,b,a);
+        ra.clear(); rb.clear(); rc.clear();
+    }
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}, disable shunning in all members. A is the coordinator
+     * <li/>MERGE2 is removed from all members
+     * <li/>VERIFY_SUSPECT is removed from all members
+     * <li/>Everyone sends 5 unicast messages to everyone else
+     * <li/>Everyone sends 5 multicasts
+     * <li/>A SUSPECT(A) event is injected into B's stack (GMS). This causes a new view {B,C} to be multicast by B
+     * <li/>B and C install {B,C}
+     * <li/>B and C trash the connection table for A in UNICAST
+     * <li/>A ignores the view, it still has view {A,B,C} and all connection tables intact in UNICAST
+     * <li/>We now inject a MERGE(A,B) event into A. This should ause A and B as coords to create a new MergeView {A,B,C}
+     * <li/>The merge already fails because the unicast between A and B fails due to the reason given below !
+     *      Once this is fixed, the next step below should work, too !
+     * <li/>A sends a unicast to B and C. This should fail until JGRP-940 has been fixed !
+     * <li/>Reason: B and C trashed A's conntables in UNICAST, but A didn't trash its conn tables for B and C, so
+     * we have non-matching seqnos !
+     * </ol>
+     */
+    public void testOverlappingMergeWithBC() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // Inject view {B,C} into B and C:
+        View new_view=Util.createView(b.getLocalAddress(), 10, b.getLocalAddress(), c.getLocalAddress());
+        System.out.println(""\n ==== Injecting view "" + new_view + "" into B and C ===="");
+        injectView(new_view, b, c);
+        makeCoordinator(b);
+        assert Util.isCoordinator(a);
+        assert Util.isCoordinator(b);
+        assert !Util.isCoordinator(c);
+
+        System.out.println(""A's view: "" + a.getView());
+        System.out.println(""B's view: "" + b.getView());
+        System.out.println(""C's view: "" + c.getView());
+        assert a.getView().size() == 3 : ""A's view is "" + a.getView();
+        assert b.getView().size() == 2 : ""B's view is "" + b.getView();
+        assert c.getView().size() == 2 : ""C's view is "" + c.getView();
+
+        System.out.println(""\n==== Sending messages while the cluster is partitioned ===="");
+        sendAndCheckMessages(5, a, b, c);
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // start merging
+        Vector<Address> coords=new Vector<Address>(2);
+        coords.add(a.getLocalAddress()); coords.add(b.getLocalAddress());
+        Event merge_evt=new Event(Event.MERGE, coords);
+        JChannel merge_leader=determineMergeLeader(a, b);
+        System.out.println(""\n==== Injecting a merge event (leader="" + merge_leader.getLocalAddress() + "") ===="");
+        injectMergeEvent(merge_evt, merge_leader);
+
+        System.out.println(""\n==== checking views after merge ====:"");
+        for(int i=0; i < 20; i++) {
+            if(a.getView().size() == 3 && b.getView().size() == 3 && c.getView().size() == 3) {
+                System.out.println(""views are correct: all views have a size of 3"");
+                break;
+            }
+            System.out.print(""."");
+            Util.sleep(500);
+        }
+
+        System.out.println(""\n ==== Digests after the merge:\n"" + dumpDigests(a,b,c));
+
+        View va=a.getView(), vb=b.getView(), vc=c.getView();
+        System.out.println(""\nA's view: "" + va);
+        System.out.println(""B's view: "" + vb);
+        System.out.println(""C's view: "" + vc);
+        assert va.size() == 3 : ""A's view is "" + va;
+        assert vb.size() == 3 : ""B's view is "" + vb;
+        assert vc.size() == 3 : ""C's view is "" + vc;
+
+        System.out.println(""\n==== Sending messages after merge ===="");
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}
+     * <li/>Install view {A,C} in A and {A,B,C} in B and C
+     * <li/>Try to initiate a merge. This should FAIL until https://jira.jboss.org/jira/browse/JGRP-937 has
+     *      been implemented: B and C's MERGE2 protocols will never send out merge requests as they see A as coord 
+     * </ol>
+     */
+    public void testOverlappingMergeWithABC() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // Inject view {A,C} into A:
+        View new_view=Util.createView(a.getLocalAddress(), 4, a.getLocalAddress(), c.getLocalAddress());
+        System.out.println(""\n ==== Injecting view "" + new_view + "" into A ===="");
+        injectView(new_view, a);
+        assertTrue(Util.isCoordinator(a));
+        assertFalse(Util.isCoordinator(b));
+        assertFalse(Util.isCoordinator(c));
+
+        System.out.println(""A's view: "" + a.getView());
+        System.out.println(""B's view: "" + b.getView());
+        System.out.println(""C's view: "" + c.getView());
+        assertEquals(""A's view is "" + a.getView(), 2, a.getView().size());
+        assertEquals(""B's view is "" + b.getView(), 3, b.getView().size());
+        assertEquals(""C's view is "" + c.getView(), 3, c.getView().size());
+
+
+        // start merging
+        Vector<Address> coords=new Vector<Address>(2);
+        coords.add(a.getLocalAddress());
+        Event merge_evt=new Event(Event.MERGE, coords);
+        System.out.println(""\n==== Injecting a merge event (leader="" + a + "") ===="");
+        injectMergeEvent(merge_evt, a);
+
+        System.out.println(""\n==== checking views after merge ====:"");
+        for(int i=0; i < 20; i++) {
+            if(a.getView().size() == 3 && b.getView().size() == 3 && c.getView().size() == 3) {
+                System.out.println(""views are correct: all views have a size of 3"");
+                break;
+            }
+            System.out.print(""."");
+            Util.sleep(500);
+        }
+
+        System.out.println(""\n ==== Digests after the merge:\n"" + dumpDigests(a,b,c));
+
+        View va=a.getView(), vb=b.getView(), vc=c.getView();
+        System.out.println(""\nA's view: "" + va);
+        System.out.println(""B's view: "" + vb);
+        System.out.println(""C's view: "" + vc);
+        assertEquals(""A's view is "" + va, 3, va.size());
+        assertEquals(""B's view is "" + vb, 3, vb.size());
+        assertEquals(""C's view is "" + vc, 3, vc.size());
+
+        System.out.println(""\n==== Sending messages after merge ===="");
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    private static void makeCoordinator(JChannel ch) {
+        GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+        gms.becomeCoordinator();
+    }
+
+
+    private static String dumpDigests(JChannel ... channels) {
+        StringBuilder sb=new StringBuilder();
+        for(JChannel ch: channels) {
+            sb.append(ch.getLocalAddress()).append("": "");
+            NAKACK nakack=(NAKACK)ch.getProtocolStack().findProtocol(NAKACK.class);
+            Digest digest=nakack.getDigest();
+            sb.append(digest).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+    private static JChannel determineMergeLeader(JChannel ... coords) {
+        Membership tmp=new Membership();
+        for(JChannel ch: coords) {
+            tmp.add(ch.getLocalAddress());
+        }
+        tmp.sort();
+        Address  merge_leader=tmp.elementAt(0);
+        for(JChannel ch: coords) {
+            if(ch.getLocalAddress().equals(merge_leader))
+                return ch;
+        }
+        return null;
+    }
+
+    private static void injectView(View view, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ch.down(new Event(Event.VIEW_CHANGE, view));
+            ch.up(new Event(Event.VIEW_CHANGE, view));
+        }
+        for(JChannel ch: channels) {
+            MyReceiver receiver=(MyReceiver)ch.getReceiver();
+            System.out.println(""["" + receiver.name + ""] view="" + ch.getView());
+        }
+    }
+
+
+    private static void injectMergeEvent(Event evt, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.up(evt);
+        }
+    }
+
+
+    private void sendAndCheckMessages(int num_msgs, JChannel ... channels) throws Exception {
+        ra.clear(); rb.clear(); rc.clear();
+
+        Set<Address> mbrs=new HashSet<Address>(channels.length);
+        for(JChannel ch: channels)
+            mbrs.add(ch.getLocalAddress());
+
+        // 1. send multicast messages
+        for(JChannel ch: channels) {
+            for(int i=1; i <= 5; i++)
+                ch.send(null, null, ""#"" + i);
+        }
+
+        // 2. send unicast messages
+        for(JChannel ch: channels) {
+            for(Address dest: mbrs) {
+                for(int i=1; i <= num_msgs; i++) {
+                    ch.send(dest, null, ""#"");
+                }
+            }
+        }
+        Util.sleep(2000);
+        MyReceiver[] receivers=new MyReceiver[channels.length];
+        for(int i=0; i < channels.length; i++)
+            receivers[i]=(MyReceiver)channels[i].getReceiver();
+        checkReceivedMessages(num_msgs, receivers);
+    }
+    
+
+    private static void checkReceivedMessages(int num_msgs, MyReceiver ... receivers) {
+        for(MyReceiver receiver: receivers) {
+            List<Message> mcasts=receiver.getMulticasts();
+            List<Message> ucasts=receiver.getUnicasts();
+            int mcasts_received=mcasts.size();
+            int ucasts_received=ucasts.size();
+            System.out.println(""receiver "" + receiver + "": mcasts="" + mcasts_received + "", ucasts="" + ucasts_received);
+        }
+        int total_unicasts=receivers.length * num_msgs;
+        for(MyReceiver receiver: receivers) {
+            List<Message> mcasts=receiver.getMulticasts();
+            List<Message> ucasts=receiver.getUnicasts();
+            int mcasts_received=mcasts.size();
+            int ucasts_received=ucasts.size();
+            int total_mcasts=receiver.view.size() * num_msgs;
+            assert ucasts_received == total_unicasts : ""ucasts: "" + print(ucasts);
+            assert mcasts_received == total_mcasts : ""num_mcasts="" + print(mcasts);
+        }
+    }
+
+    private static String print(List<Message> msgs) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: msgs) {
+            sb.append(msg.getSrc()).append("": "").append(msg.getObject()).append("" "");
+        }
+        return sb.toString();
+    }
+
+
+    private static void modifyConfigs(JChannel ... channels) throws Exception {
+        for(JChannel ch: channels) {
+            ProtocolStack stack=ch.getProtocolStack();
+
+            FD fd=(FD)stack.findProtocol(FD.class);
+            if(fd != null)
+                fd.setShun(false);
+
+            FD_ALL fd_all=(FD_ALL)stack.findProtocol(FD_ALL.class);
+            if(fd_all != null)
+                fd_all.setShun(false);
+
+            stack.removeProtocol(""MERGE2"");
+            stack.removeProtocol(""FC"");
+            stack.removeProtocol(""VERIFY_SUSPECT"");
+
+            /*DELAY delay=new DELAY();
+            delay.setOutDelay(500);
+            stack.insertProtocol(delay, ProtocolStack.ABOVE, stack.getTransport());*/
+        }
+    }
+
+
+
+    private static class MyReceiver extends ReceiverAdapter {
+        final String name;
+        View view=null;
+        final List<Message> mcasts=new ArrayList<Message>(20);
+        final List<Message> ucasts=new ArrayList<Message>(20);
+
+        public MyReceiver(String name) {
+            this.name=name;
+        }
+
+        public void receive(Message msg) {
+            Address dest=msg.getDest();
+            boolean mcast=dest == null;
+            if(mcast)
+                mcasts.add(msg);
+            else
+                ucasts.add(msg);
+            // System.out.println(""received "" + (mcast? ""mcast"" : ""ucast"") + "" msg from "" + msg.getSrc());
+        }
+
+        public void viewAccepted(View new_view) {
+            // System.out.println(""["" + name + ""] "" + new_view);
+            view=new_view;
+        }
+
+        public List<Message> getMulticasts() { return mcasts; }
+        public List<Message> getUnicasts() { return ucasts; }
+        public void clear() {mcasts.clear(); ucasts.clear();}
+
+        public String toString() {
+            return name;
+        }
+    }
+
+
+
+}
\ No newline at end of file",2009-04-24T14:48:33Z,147
"@@ -0,0 +1,209 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.FD;
+import org.jgroups.protocols.FD_ALL;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.AfterTest;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Tests overlapping merges, e.g. A: {A,B}, B: {A,B} and C: {A,B,C}. Tests unicast tables<br/>
+ * Related JIRA: https://jira.jboss.org/jira/browse/JGRP-940
+ * @author Bela Ban
+ * @version $Id: OverlappingUnicastMergeTest.java,v 1.2 2009/04/24 14:48:33 belaban Exp $
+ */
+@Test(groups=Global.STACK_DEPENDENT,sequential=true)
+public class OverlappingUnicastMergeTest extends ChannelTestBase {
+    private JChannel a, b, c;
+    private MyReceiver ra, rb, rc;
+
+    @BeforeTest
+    void start() throws Exception {
+        ra=new MyReceiver(""A""); rb=new MyReceiver(""B""); rc=new MyReceiver(""C"");
+        a=createChannel(true, 3);
+        a.setReceiver(ra);
+
+        b=createChannel(a);
+        b.setReceiver(rb);
+
+        c=createChannel(a); 
+        c.setReceiver(rc);
+
+        modifyConfigs(a, b, c);
+
+        a.connect(""OverlappingUnicastMergeTest"");
+        b.connect(""OverlappingUnicastMergeTest"");
+        c.connect(""OverlappingUnicastMergeTest"");
+
+        View view=c.getView();
+        assertEquals(""view is "" + view, 3, view.size());
+    }
+
+    @AfterTest
+    void tearDown() throws Exception {
+        Util.close(c,b,a);
+    }
+
+
+    public void testWithAllViewsInSync() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}, disable shunning in all members. A is the coordinator
+     * <li/>MERGE2 is removed from all members
+     * <li/>VERIFY_SUSPECT is removed from all members
+     * <li/>Everyone sends 5 unicast messages to everyone else
+     * <li/>A VIEW(B,C) is injected into B and C
+     * <li/>B and C install {B,C}
+     * <li/>B and C trash the connection table for A in UNICAST
+     * <li/>A still has view {A,B,C} and all connection tables intact in UNICAST
+     * <li/>We now send N unicasts from everyone to everyone else, all the unicasts should be received.
+     * </ol>
+     */
+    public void testWithViewBC() throws Exception {
+        // Inject view {B,C} into B and C:
+        View new_view=Util.createView(b.getLocalAddress(), 10, b.getLocalAddress(), c.getLocalAddress());
+        injectView(new_view, b, c);
+        assertEquals(""A's view is "" + a.getView(), 3, a.getView().size());
+        assertEquals(""B's view is "" + b.getView(), 2, b.getView().size());
+        assertEquals(""C's view is "" + c.getView(), 2, c.getView().size());
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithViewA() throws Exception {
+        // Inject view {A} into A, B and C:
+        View new_view=Util.createView(a.getLocalAddress(), 10, a.getLocalAddress());
+        injectView(new_view, a, b, c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithViewC() throws Exception {
+        // Inject view {A} into A, B and C:
+        View new_view=Util.createView(c.getLocalAddress(), 10, c.getLocalAddress());
+        injectView(new_view, a, b, c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithEveryoneHavingASingletonView() throws Exception {
+        // Inject view {A} into A, B and C:
+        injectView(Util.createView(a.getLocalAddress(), 10, a.getLocalAddress()), a);
+        injectView(Util.createView(b.getLocalAddress(), 10, b.getLocalAddress()), b);
+        injectView(Util.createView(c.getLocalAddress(), 10, c.getLocalAddress()), c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    private static void injectView(View view, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ch.down(new Event(Event.VIEW_CHANGE, view));
+            ch.up(new Event(Event.VIEW_CHANGE, view));
+        }
+        for(JChannel ch: channels) {
+            MyReceiver receiver=(MyReceiver)ch.getReceiver();
+            System.out.println(""["" + receiver.name + ""] view="" + ch.getView());
+        }
+    }
+
+
+    private void sendAndCheckMessages(int num_msgs, JChannel ... channels) throws Exception {
+        ra.clear(); rb.clear(); rc.clear();
+        // 1. send unicast messages
+        Set<Address> mbrs=new HashSet<Address>(channels.length);
+        for(JChannel ch: channels)
+            mbrs.add(ch.getLocalAddress());
+
+        for(JChannel ch: channels) {
+            Address addr=ch.getLocalAddress();
+            for(Address dest: mbrs) {
+                for(int i=1; i <= num_msgs; i++) {
+                    ch.send(dest, null, ""unicast msg #"" + i + "" from "" + addr);
+                }
+            }
+        }
+        Util.sleep(1000);
+        int total_msgs=num_msgs * channels.length;
+        MyReceiver[] receivers=new MyReceiver[channels.length];
+        for(int i=0; i < channels.length; i++)
+            receivers[i]=(MyReceiver)channels[i].getReceiver();
+        checkReceivedMessages(total_msgs, receivers);
+    }
+
+    private static void checkReceivedMessages(int num_ucasts, MyReceiver ... receivers) {
+        for(MyReceiver receiver: receivers) {
+            List<Message> ucasts=receiver.getUnicasts();
+            int ucasts_received=ucasts.size();
+            System.out.println(""receiver "" + receiver + "": ucasts="" + ucasts_received);
+            assertEquals(""ucasts for "" + receiver + "": "" + print(ucasts), num_ucasts, ucasts_received);
+        }
+    }
+
+    public static String print(List<Message> list) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: list) {
+            sb.append(msg.getSrc()).append("": "").append(msg.getObject()).append("" "");
+        }
+        return sb.toString();
+    }
+
+    private static void modifyConfigs(JChannel ... channels) throws Exception {
+        for(JChannel ch: channels) {
+            ProtocolStack stack=ch.getProtocolStack();
+
+            FD fd=(FD)stack.findProtocol(FD.class);
+            if(fd != null)
+                fd.setShun(false);
+
+            FD_ALL fd_all=(FD_ALL)stack.findProtocol(FD_ALL.class);
+            if(fd_all != null)
+                fd_all.setShun(false);
+
+            stack.removeProtocol(""MERGE2"");
+            stack.removeProtocol(""VERIFY_SUSPECT"");
+            stack.removeProtocol(""FC"");
+        }
+    }
+
+
+
+    private static class MyReceiver extends ReceiverAdapter {
+        final String name;
+        final List<Message> ucasts=new ArrayList<Message>(20);
+
+        public MyReceiver(String name) {
+            this.name=name;
+        }
+
+        public void receive(Message msg) {
+            Address dest=msg.getDest();
+            boolean mcast=dest == null;
+            if(!mcast)
+                ucasts.add(msg);
+        }
+
+        public void viewAccepted(View new_view) {
+            // System.out.println(""["" + name + ""] "" + new_view);
+        }
+
+        public List<Message> getUnicasts() { return ucasts; }
+        public void clear() {ucasts.clear();}
+
+        public String toString() {
+            return name;
+        }
+    }
+
+
+
+}
\ No newline at end of file",2009-04-24T14:48:33Z,148
"@@ -10,9 +10,7 @@
 import org.jgroups.protocols.TP;
 import org.jgroups.stack.Protocol;
 import org.jgroups.tests.ChannelTestBase;
-import org.jgroups.util.Rsp;
-import org.jgroups.util.RspList;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
@@ -42,7 +40,7 @@
  * This also applies to the return value of callRemoteMethod(...).
  * 
  * @author Bela Ban
- * @version $Id: RpcDispatcherTest.java,v 1.29 2010/01/17 11:29:56 belaban Exp $
+ * @version $Id: RpcDispatcherTest.java,v 1.30 2010/01/17 12:07:43 belaban Exp $
  */
 @Test(groups=Global.STACK_DEPENDENT,sequential=true)
 public class RpcDispatcherTest extends ChannelTestBase {
@@ -109,7 +107,7 @@ public void testEmptyConstructor() throws Exception {
             System.out.println(""view channel 1= "" + view);
 
             assert view.size() == 2;
-            RspList rsps=d1.callRemoteMethods(null, ""foo"", null, (Class[])null, Request.GET_ALL, 5000);
+            RspList rsps=d1.callRemoteMethods(null, ""foo"", null, null, new RequestOptions(Request.GET_ALL, 5000));
             System.out.println(""rsps:\n"" + rsps);
             assert rsps.size() == 2;
             for(Rsp rsp: rsps.values()) {
@@ -127,7 +125,7 @@ public long foobar() {
             d1.setServerObject(server_object);
             d2.setServerObject(server_object);
 
-            rsps=d2.callRemoteMethods(null, ""foobar"", null, (Class[])null, Request.GET_ALL, 5000);
+            rsps=d2.callRemoteMethods(null, ""foobar"", null, null, new RequestOptions(Request.GET_ALL, 5000));
             System.out.println(""rsps:\n"" + rsps);
             assert rsps.size() == 2;
             for(Rsp rsp: rsps.values()) {
@@ -158,23 +156,23 @@ public long foobar() {
     public void testResponseFilter() {
     	
     	final long timeout = 10 * 1000 ;
+
+        RequestOptions options=new RequestOptions(Request.GET_ALL, timeout, false,
+                                                  new RspFilter() {
+                                                      int num=0;
+                                                      public boolean isAcceptable(Object response, Address sender) {
+                                                          boolean retval=((Integer)response).intValue() > 1;
+                                                          if(retval)
+                                                              num++;
+                                                          return retval;
+                                                      }
+
+                                                      public boolean needMoreResponses() {
+                                                          return num < 2;
+                                                      }
+                                                  });
     	
-        RspList rsps=disp1.callRemoteMethods(null, ""foo"", null, null,Request.GET_ALL, timeout, false,
-                                             new RspFilter() {
-                                                 int num=0;
-                                                 public boolean isAcceptable(Object response, Address sender) {
-                                                     boolean retval=((Integer)response).intValue() > 1;
-                                                     // System.out.println(""-- received "" + response + "" from "" +
-                                                     // sender + "": "" + (retval ? ""OK"" : ""NOTOK""));
-                                                     if(retval)
-                                                         num++;
-                                                     return retval;
-                                                 }
-
-                                                 public boolean needMoreResponses() {
-                                                     return num < 2;
-                                                 }
-                                             });
+        RspList rsps=disp1.callRemoteMethods(null, ""foo"", null, null, options);
         System.out.println(""responses are:\n"" + rsps);
         assertEquals(""there should be three response values"", 3, rsps.size());
         assertEquals(""number of responses received should be 2"", 2, rsps.numReceived());
@@ -184,7 +182,7 @@ public boolean needMoreResponses() {
     public void testFuture() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
         Future<RspList> future;
-        future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 5000L, false, false, null);
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
         assert !future.isDone();
         assert !future.isCancelled();
         try {
@@ -205,14 +203,52 @@ public void testFuture() throws Exception {
     }
 
 
+    public void testNotifyingFuture() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
+        NotifyingFuture<RspList> future;
+        MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
+        future.setListener(listener);
+        assert !future.isDone();
+        assert !future.isCancelled();
+        assert !listener.isDone();
+        Util.sleep(2000);
+        assert listener.isDone();
+        RspList result=future.get(1L, TimeUnit.MILLISECONDS);
+        System.out.println(""result:\n"" + result);
+        assert result != null;
+        assert result.size() == 3;
+        assert future.isDone();
+    }
+
+    public void testNotifyingFutureWithDelayedListener() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
+        NotifyingFuture<RspList> future;
+        MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
+        assert !future.isDone();
+        assert !future.isCancelled();
+
+        Util.sleep(2000);
+        future.setListener(listener);
+        assert listener.isDone();
+        RspList result=future.get(1L, TimeUnit.MILLISECONDS);
+        System.out.println(""result:\n"" + result);
+        assert result != null;
+        assert result.size() == 3;
+        assert future.isDone();
+    }
+
+
     public void testMultipleFutures() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{100L}, new Class[]{long.class});
         List<Future<RspList>> futures=new ArrayList<Future<RspList>>();
         long target=System.currentTimeMillis() + 30000L;
 
         Future<RspList> future;
+        RequestOptions options=new RequestOptions(Request.GET_ALL, 30000L, false, null);
         for(int i=0; i < 10; i++) {
-            future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 30000L, false, false, null);
+            future=disp1.callRemoteMethodsWithFuture(null, sleep, options);
             futures.add(future);
         }
 
@@ -234,13 +270,44 @@ public void testMultipleFutures() throws Exception {
         }
     }
 
+    public void testMultipleNotifyingFutures() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{100L}, new Class[]{long.class});
+        List<MyFutureListener> listeners=new ArrayList<MyFutureListener>();
+        RequestOptions options=new RequestOptions(Request.GET_ALL, 30000L, false, null);
+        for(int i=0; i < 10; i++) {
+            MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+            listeners.add(listener);
+            disp1.callRemoteMethodsWithFuture(null, sleep, options).setListener(listener);
+        }
+
+        Util.sleep(1000);
+        for(int i=0; i < 10; i++) {
+            boolean all_done=true;
+            for(MyFutureListener listener: listeners) {
+                boolean done=listener.isDone();
+                System.out.print(done? ""+ "" : ""- "");
+                if(!listener.isDone())
+                    all_done=false;
+            }
+            if(all_done)
+                break;
+            Util.sleep(500);
+            System.out.println("""");
+        }
+        
+        for(MyFutureListener listener: listeners) {
+            assert listener.isDone();
+        }
+
+    }
+
 
 
 
     public void testFutureCancel() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
         Future<RspList> future;
-        future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 5000L, false, false, null);
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L));
         assert !future.isDone();
         assert !future.isCancelled();
         future.cancel(true);
@@ -309,7 +376,7 @@ public void testMethodInvocationToNonExistingMembers() {
         
         // make an RPC call using C's now outdated view of membership
         System.out.println(""calling method foo() in "" + members + "" (view="" + c2.getView() + "")"");
-        RspList rsps=disp1.callRemoteMethods(members, ""foo"", null, (Class[])null, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(members, ""foo"", null, null, new RequestOptions(Request.GET_ALL, timeout));
         
         // all responses 
         System.out.println(""responses:\n"" + rsps);
@@ -370,7 +437,8 @@ void _testLargeValue(int size) {
     	final long timeout = 20 * 1000 ;
     		
         System.out.println(""\ntesting with "" + size + "" bytes"");
-        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
         System.out.println(""rsps:"");
         assert rsps.size() == 3 : ""there should be three responses to the RPC call but only "" + rsps.size() +
                 "" were received: "" + rsps;
@@ -405,7 +473,8 @@ void _testHugeValue(int size) {
     	final long timeout = 20 * 1000 ;
     	
         System.out.println(""\ntesting with "" + size + "" bytes"");
-        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
         System.out.println(""rsps:"");
         assert rsps != null;
         assert rsps.size() == 3 : ""there should be three responses to the RPC call but only "" + rsps.size() +
@@ -458,7 +527,8 @@ void _testLargeValueUnicastCall(Address dst, int size) throws Throwable {
         System.out.println(""\ntesting unicast call with "" + size + "" bytes"");
         assertNotNull(dst);
         
-        Object retval=disp1.callRemoteMethod(dst, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        Object retval=disp1.callRemoteMethod(dst, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
 
     	// it's possible that an exception was raised
         if (retval instanceof java.lang.Throwable) {
@@ -490,6 +560,7 @@ public ServerObject(int i) {
             this.i=i;
         }
         public int foo() {return i;}
+        
         public static long sleep(long timeout) {
             // System.out.println(""sleep()"");
             long start=System.currentTimeMillis();
@@ -503,5 +574,15 @@ public static byte[] largeReturnValue(int size) {
         }
     }
 
+    private static class MyFutureListener<T> implements FutureListener<T> {
+        private boolean done;
+
+        public void futureDone(Future<T> future) {
+            done=true;
+        }
+
+        public boolean isDone() {return done;}
+    }
+
 
 }
\ No newline at end of file",2010-01-17T12:07:43Z,149
"@@ -2,20 +2,18 @@
 package org.jgroups.tests;
 
 import org.jgroups.*;
-import org.jgroups.debug.Simulator;
+import org.jgroups.protocols.*;
+import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.UUID;
-import org.jgroups.util.MutableDigest;
-import org.jgroups.util.Digest;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.ProtocolStack;
 import org.testng.Assert;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import java.util.Hashtable;
-import java.util.Vector;
-import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * Tests the reliable FIFO (NAKACK) protocol
@@ -40,7 +38,6 @@
  */
 @Test(groups=Global.FUNCTIONAL, sequential=true)
 public class NakackTest {
-
     final static int NUM_PEERS=3;
     final static int NUM_MSGS=1000;
     final static int WAIT_TIMEOUT=10; // secs
@@ -50,124 +47,61 @@ public class NakackTest {
     static boolean notFIFO=false;
     static boolean allMsgsReceived=false;
 
-    Address[] addresses=new Address[NUM_PEERS];
-    Vector<Address> members=null;
-    View view;
-    Simulator[] simulators=new Simulator[NUM_PEERS];
-    NAKACK[] layers=new NAKACK[NUM_PEERS];
-    Protocol[][] stacks=new Protocol[NUM_PEERS][];
+    JChannel[] channels=new JChannel[NUM_PEERS];
     Thread[] threads=new Thread[NUM_PEERS];
 
     //define senders and receivers
-    boolean[] isSender=new boolean[NUM_PEERS];
+    boolean[] isSender={false, true,true};
 
     // used to wait for signal that all messages received
     static final Object all_msgs_recd=new Object();
 
+
+
+
+
     /**
      * Set up a number of simulator instances wrapping NAKACK
      */
     @BeforeMethod
     public void setUp() throws Exception {
 
-        // define the senders and the receivers
-        isSender[0]=false;
-        isSender[1]=true;
-        isSender[2]=true;
-
-        // dummy IP addresses and ports
-        for(int i=0; i < addresses.length; i++) {
-            UUID uuid=UUID.randomUUID();
-            UUID.add(uuid, ""node-"" + i);
-            addresses[i]=uuid;
-        }
-
-        // dummy set of members which works for all three simulators
-        members=new Vector<Address>();
-        members.addAll(Arrays.asList(addresses).subList(0, NUM_PEERS));
-
-        // create a dummy View(creator, timestamp, member set)
-        view=new View(addresses[0], 1, members);
-
         // create new simulator instances
         for(int i=0; i < NUM_PEERS; i++) {
-
-            // create the simulator instance
-
-            // at this stage, the ProtocolAdapter should be created and the timer present
-            simulators[i]=new Simulator();
-            simulators[i].setLocalAddress(addresses[i]);
-            simulators[i].setView(view);
-
-            // set up the protocol under test
-            layers[i]=new NAKACK();
-
-            // set up its properties
-            layers[i].setUseMcastXmit(true);
-
-            // our protocol stack under test consists of one protocol
-            stacks[i]=new Protocol[]{layers[i]};
-
-            // initalise the protocol stack
-            simulators[i].setProtocolStack(stacks[i]);
-        }
-
-        // describe the configuration of the three simulators
-        for(int i=0; i < NUM_PEERS; i++) {
-            for(int j=0; j < NUM_PEERS; j++) {
-                if(i == j)
-                    simulators[i].addMember(addresses[j]);
-                else
-                    simulators[i].addMember(addresses[j], simulators[j]);
-            }
+            channels[i]=createChannel();
+            channels[i].setName(Character.toString((char)(i + 'A')));
+            channels[i].connect(""NakackTest"");
         }
 
         // set up the receiver callbacks for each simulator
-        Simulator.Receiver[] receivers=new Simulator.Receiver[NUM_PEERS];
+        Receiver[] receivers=new Receiver[NUM_PEERS];
 
-        // set up the sender and the receiver callbacks, according to whether
-        // the peer is a sender or a receiver
+        // set up the sender and the receiver callbacks, according to whether the peer is a sender or a receiver
         for(int i=0; i < NUM_PEERS; i++) {
-
             if(isSender[i])
-                receivers[i]=new SenderPeer(simulators[i]);
+                receivers[i]=new ReceiverPeer(channels[i]);
             else
-                receivers[i]=new ReceiverPeer(simulators[i]);
-
-            simulators[i].setReceiver(receivers[i]);
-        }
-
-        // start the simulators
-        for(int i=0; i < NUM_PEERS; i++)
-            simulators[i].start();
-
-        MutableDigest digest=new MutableDigest(NUM_PEERS);
-        for(Address addr: addresses)
-            digest.add(new Digest(addr, 0, 0));
-        for(int i=0; i < NUM_PEERS; i++) {
-            layers[i].down(new Event(Event.SET_DIGEST, digest));
+                receivers[i]=new ReceiverPeer(channels[i]);
+            channels[i].setReceiver(receivers[i]);
         }
-
     }
 
     @AfterMethod
     public void tearDown() throws Exception {
-
-        // stop the simulators
         for(int i=0; i < NUM_PEERS; i++)
-            simulators[i].stop();
+            channels[i].close();
     }
 
     /**
      * Test to see thyat NAKACK delivery is reliable and FIFO.
      */
     public void testReceptionOfAllMessages() {
-
+        for(JChannel ch: channels)
+          assert ch.getView().size() == NUM_PEERS;
 
         // start the NAKACK peers and let them exchange messages
         for(int i=0; i < NUM_PEERS; i++) {
-
-            threads[i]=new MyNAKACKPeer(simulators[i], isSender[i]);
+            threads[i]=new MyNAKACKPeer(channels[i], isSender[i]);
             threads[i].start();
         }
 
@@ -197,163 +131,124 @@ public void testReceptionOfAllMessages() {
         Assert.assertFalse(notFIFO, ""Sequenece numbers for a peer not in correct order"");
     }
 
-    /**
-     * This is called by the Simulator when a message comes back up the stack.
-     * Used by message senders to simply display messages received from other peers.
-     */
-    static class SenderPeer implements Simulator.Receiver {
-        Simulator simulator=null;
-        int num_mgs_received=0;
-
-        SenderPeer(Simulator s) {
-            this.simulator=s;
-        }
-
-        // keep track of how many messages were received
-        public void receive(Event evt) {
-            if(evt.getType() == Event.MSG) {
-                num_mgs_received++;
-                if(num_mgs_received % MSGS_PER_STATUS_LINE == 0)
-                    System.out.println(""<"" + simulator.getLocalAddress() + "">:"" + ""<== "" + num_mgs_received);
-            }
-        }
-
-        public int getNumberOfReceivedMessages() {
-            return num_mgs_received;
-        }
+    protected static JChannel createChannel() throws Exception {
+        JChannel ch=new JChannel(false);
+        ProtocolStack stack=new ProtocolStack();
+        ch.setProtocolStack(stack);
+        stack.addProtocol(new SHARED_LOOPBACK())
+          .addProtocol(new PING())
+          .addProtocol(new NAKACK().setValue(""use_mcast_xmit"", false))
+          .addProtocol(new UNICAST2())
+          .addProtocol(new STABLE().setValue(""max_bytes"", 50000))
+          .addProtocol(new GMS().setValue(""print_local_addr"", false))
+          .addProtocol(new UFC())
+          .addProtocol(new MFC())
+          .addProtocol(new FRAG2());
+        stack.init();
+        return ch;
     }
 
+   
+
     /**
      * This is called by the Simulator when a message comes back up the stack.
      * This method should do the following:
      * - receive messages from senders
      * - check that sequence numbers for each sender are in order (with no gaps)
      * - terminate when correct number of messages have been received
      */
-    static class ReceiverPeer implements Simulator.Receiver {
-        Simulator simulator=null;
+    static class ReceiverPeer extends ReceiverAdapter {
+        final JChannel channel;
         int num_mgs_received=0;
-        long starting_seqno=1;
-        long last_seqno=starting_seqno;
-
-        Hashtable<Address, Long> senders=new Hashtable<Address, Long>();
-        Message msg;
-        Address sender;
-        Long s;
-        long received_seqno;
+        ConcurrentMap<Address, Long> senders=new ConcurrentHashMap<Address, Long>();
 
-        ReceiverPeer(Simulator s) {
-            this.simulator=s;
+        public ReceiverPeer(JChannel channel) {
+            this.channel=channel;
         }
 
-        public synchronized void receive(Event evt) {
-
-            if(evt.getType() == Event.MSG) {
+        /**
+         * Receive() is concurrent for different senders, but sequential per sender
+         * @param msg
+         */
+        public void receive(Message msg) {
+            // keep track of seqno ordering of messages received
+            Address sender=msg.getSrc();
+
+            // get the expected next seqno for this sender
+            Long num=senders.get(sender);
+            if(num == null) {
+                num=new Long(1);
+                senders.putIfAbsent(sender, num);
+            }
+            long last_seqno=num.longValue();
 
-                // keep track of seqno ordering of messages received
-                msg=(Message)evt.getArg();
-                sender=msg.getSrc();
+            try {
+                num=(Long)msg.getObject();
+                long received_seqno=num.longValue();
+                num_mgs_received++;
 
-                // get the expected next seqno for this sender
-                s=senders.get(sender);
-                if(s == null) {
-                    s=new Long(starting_seqno);
-                    senders.put(sender, s);
+                // 1. check if sequence numbers are in sequence
+                if(received_seqno == last_seqno) { // correct - update with next expected seqno
+                    senders.put(sender, new Long(last_seqno + 1));
+                }
+                else {
+                    // error, terminate test
+                    notFIFO=true;
+                    Assert.fail(""FAIL: received msg #"" + received_seqno + "", expected "" + last_seqno);
                 }
-                last_seqno=s.longValue();
-
-                try {
-                    s=(Long)msg.getObject();
-                    received_seqno=s.longValue();
-
-                    num_mgs_received++;
-
-                    // 1. check if sequence numbers are in sequence
-                    if(received_seqno == last_seqno) {
-                        // correct - update with next expected seqno
-                        senders.put(sender, new Long(last_seqno + 1));
-                    }
-                    else {
-                        // error, terminate test
-                        notFIFO=true;
-                        Assert.fail(""FAIL: received msg #"" + received_seqno + "", expected "" + last_seqno);
-                    }
-
-                    Address address=simulator.getLocalAddress();
-
-                    if(received_seqno % MSGS_PER_STATUS_LINE == 0 && received_seqno > 0)
-                        System.out.println(""<"" + address + "">:"" + ""PASS: received msg #"" + received_seqno + "" from "" + sender);
 
+                Address address=channel.getAddress();
+                if(received_seqno % MSGS_PER_STATUS_LINE == 0 && received_seqno > 0)
+                    System.out.println(""<"" + address + "">:"" + ""PASS: received msg #"" + received_seqno + "" from "" + sender);
 
-                    // condition to terminate the test - all messages received (whether in
-                    // correct order or not)
-                    if(num_mgs_received >= NakackTest.NUM_MSGS * (NUM_PEERS - 1)) {
 
+                // condition to terminate the test - all messages received (whether in correct order or not)
+                if(num_mgs_received >= NakackTest.NUM_MSGS * (NUM_PEERS - 1)) {
+                    // signal that all messages have been received - this will allow the receiver
+                    // thread to terminate normally
+                    synchronized(all_msgs_recd) {
                         // indicate that we have received the required number of messages
                         // to differentiate between timeout and notifyAll cases on monitor
                         allMsgsReceived=true;
-
-                        // signal that all messages have been received - this will allow the receiver
-                        // thread to terminate normally
-                        synchronized(all_msgs_recd) {
-                            all_msgs_recd.notifyAll();
-                        }
+                        all_msgs_recd.notifyAll();
                     }
                 }
-                catch(Exception ex) {
-                    System.out.println(ex.toString());
-                    // log.error(""NakackTest.CheckNoGaps.up()"", ex);
-                }
+            }
+            catch(Exception ex) {
+                System.err.println(ex.toString());
             }
         }
 
+
         public int getNumberOfReceivedMessages() {
             return num_mgs_received;
         }
     }
 
 
     static class MyNAKACKPeer extends Thread {
-
-        Simulator s=null;
+        JChannel ch=null;
         boolean sender=false;
 
-        public MyNAKACKPeer(Simulator s, boolean sender) {
-            this.s=s;
+        public MyNAKACKPeer(JChannel ch, boolean sender) {
+            this.ch=ch;
             this.sender=sender;
         }
 
         public void run() {
 
             // senders send NUM_MSGS messages to all peers, beginning with seqno 1
             if(sender) {
-
-                Address address=s.getLocalAddress();
-
-                // send a collection of dummy messages by mcast to the stack under test
+                Address address=ch.getAddress();
                 for(int i=1; i <= NUM_MSGS; i++) {
-
-                    Message msg=new Message(null, address, new Long(i));
-                    Event evt=new Event(Event.MSG, msg);
-
-                    // call Simulator.send() to introduce the event into the stack under test
-                    s.send(evt);
-
-                    // status indicator
-                    if(i % MSGS_PER_STATUS_LINE == 0)
-                        System.out.println(""<"" + address + "">:"" + "" ==> "" + i);
-                }
-            }
-
-            if(!sender) {
-                // wait for the receiver callback to signal that it has received messages, or timeout
-                // this just causes this thread to block until its receiver has finished
-                synchronized(all_msgs_recd) {
                     try {
-                        all_msgs_recd.wait(WAIT_TIMEOUT * 1000);
+                        Message msg=new Message(null, address, new Long(i));
+                        ch.send(msg);
+                        if(i % MSGS_PER_STATUS_LINE == 0) // status indicator
+                            System.out.println(""<"" + address + "">:"" + "" ==> "" + i);
                     }
-                    catch(InterruptedException e) {
-                        System.out.println(""main thread interrupted"");
+                    catch(Exception e) {
+                        e.printStackTrace();
                     }
                 }
             }",2011-04-12T09:10:20Z,150
"@@ -1,8 +1,6 @@
 package org.jgroups.util;
 
-import org.testng.ITestContext;
-import org.testng.ITestListener;
-import org.testng.ITestResult;
+import org.testng.*;
 
 import java.io.*;
 import java.util.*;
@@ -13,7 +11,7 @@
  * 
  * @author Bela Ban
  */
-public class JUnitXMLReporter implements ITestListener {
+public class JUnitXMLReporter implements ITestListener, IConfigurationListener2 {
     protected String output_dir=null;
 
     protected static final String XML_DEF=""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>"";
@@ -68,20 +66,7 @@ public void onFinish(ITestContext context) {
 
     /* Invoked at the start of each test method in a test class */
     public void onTestStart(ITestResult result) {
-        String test_name=result.getTestClass().getName();
-        File dir=new File(output_dir + File.separator + test_name);
-        if(!dir.exists())
-            dir.mkdirs();
-        File _tests=new File(dir, TESTS), _stdout=new File(dir, STDOUT), _stderr=new File(dir, STDERR);
-        try {
-            tests.set(new DataOutputStream(new FileOutputStream(_tests, true)));
-            stdout.set(new PrintStream(new FileOutputStream(_stdout, true)));
-            stderr.set(new PrintStream(new FileOutputStream(_stderr, true)));
-            stdout.get().println(""\n\n------------- "" + getMethodName(result) + "" -----------"");
-        }
-        catch(IOException e) {
-            error(e.toString());
-        }
+        setupStreams(result, true);
     }
 
 
@@ -92,35 +77,75 @@ public void onTestSuccess(ITestResult tr) {
 
 
     public void onTestFailedButWithinSuccessPercentage(ITestResult tr) {
-        onTestCompleted(tr,""OK:   "",old_stdout);
+        onTestCompleted(tr, ""OK:   "",old_stdout);
     }
 
     /** Invoked each time a test method fails */
     public void onTestFailure(ITestResult tr) {
-        onTestCompleted(tr,""FAIL: "",old_stderr);
+        onTestCompleted(tr, ""FAIL: "",old_stderr);
     }
 
     /** Invoked each time a test method is skipped */
     public void onTestSkipped(ITestResult tr) {
-        onTestCompleted(tr,""SKIP: "",old_stderr);
+        onTestCompleted(tr, ""SKIP: "",old_stderr);
+    }
+
+    public void beforeConfiguration(ITestResult tr) {
+        setupStreams(tr, false);
+    }
+
+    public void onConfigurationSuccess(ITestResult tr) {
+
+    }
+
+    public void onConfigurationFailure(ITestResult tr) {
+        error(""failed config: "" + tr.getThrowable());
+        onTestCompleted(tr, ""FAIL: "", old_stderr);
     }
 
-    public String toString() {
-        return ""bla"";
+    public void onConfigurationSkip(ITestResult tr) {
     }
 
+
     protected void onTestCompleted(ITestResult tr, String message, PrintStream out) {
         Class<?> real_class=tr.getTestClass().getRealClass();
         addTest(real_class, tr);
         print(out, message , real_class.getName(), getMethodName(tr));
-        stdout.get().close();
-        stderr.get().close();
-        Util.close(tests.get());
+        closeStreams();
+    }
+
+    protected void setupStreams(ITestResult result, boolean printMethodName) {
+        String test_name=result.getTestClass().getName();
+        File dir=new File(output_dir + File.separator + test_name);
+        if(!dir.exists())
+            dir.mkdirs();
+        File _tests=new File(dir, TESTS), _stdout=new File(dir, STDOUT), _stderr=new File(dir, STDERR);
+        try {
+            if(tests.get() == null)
+                tests.set(new DataOutputStream(new FileOutputStream(_tests, true)));
+            if(stdout.get() == null)
+                stdout.set(new PrintStream(new FileOutputStream(_stdout, true)));
+            if(stderr.get() == null)
+                stderr.set(new PrintStream(new FileOutputStream(_stderr, true)));
+            if(printMethodName)
+                stdout.get().println(""\n\n------------- "" + getMethodName(result) + "" -----------"");
+        }
+        catch(IOException e) {
+            error(e.toString());
+        }
     }
 
+    protected static void closeStreams() {
+        Util.close(stdout.get());
+        stdout.set(null);
+        Util.close(stderr.get());
+        stderr.set(null);
+        Util.close(tests.get());
+        tests.set(null);
+    }
 
     protected static void print(PrintStream out, String msg, String classname, String method_name) {
-        out.println(msg + ""["" + Thread.currentThread().getId() + ""] "" + classname + "".""  + method_name + ""()"");
+        out.println(msg + ""["" + Thread.currentThread().getId() + ""] "" + classname + ""."" + method_name + ""()"");
     }
 
     protected void error(String msg) {
@@ -146,7 +171,7 @@ protected void addTest(Class<?> clazz, ITestResult result) {
                         test_case.setFailure(failure_type, failure_msg, stack_trace);
                     }
                     else
-                        test_case.setFailure(""SKIP"", null, null);
+                        test_case.setFailure(""exception"", ""SKIPPED"", null);
                     break;
             }
 
@@ -163,8 +188,13 @@ protected static String getMethodName(ITestResult tr) {
         String method_name=tr.getName();
         Object[] params=tr.getParameters();
         if(params != null && params.length > 0) {
-            String tmp=params[0] != null? params[0].getClass().getSimpleName() : null;
-            method_name=method_name + ""-"" + tmp;
+            String tmp=null;
+            if(params[0] instanceof Class<?>)
+                tmp=((Class<?>)params[0]).getSimpleName();
+            else if(params[0] != null)
+                tmp=params[0].getClass().getSimpleName();
+            if(tmp != null)
+                method_name=method_name + ""-"" + tmp;
         }
         return method_name;
     }
@@ -250,15 +280,13 @@ protected static void generateReport(Writer out, String classname, List<TestCase
         try {
             out.write(XML_DEF + ""\n"");
 
-            out.write(""\n<testsuite "" + "" failures=\""""
-                      + num_failures
-                      + ""\"" errors=\""""
-                      + num_errors
-                      + ""\"" skips=\""""
-                      + num_skips
-                      + ""\"" name=\""""
-                      + classname);
-            out.write(""\"" tests=\"""" + results.size() + ""\"" time=\"""" + (total_time / 1000.0) + ""\"">"");
+            out.write(""\n<testsuite ""
+                        + ""name=\""""   + classname + ""\"" ""
+                        + ""tests=\""""  + results.size() + ""\"" ""
+                        + ""failures=\"""" + num_failures + ""\"" ""
+                        + ""errors=\"""" + num_errors + ""\"" ""
+                        + ""skips=\""""  + num_skips + ""\"" ""
+                        + ""time=\""""    + (total_time / 1000.0) + ""\"">"");
 
             out.write(""\n<properties>"");
             Properties props=System.getProperties();
@@ -500,6 +528,8 @@ public void println(Object obj) {
 
         protected synchronized void append(String x, boolean newline) {
             PrintStream tmp=type == 1? stdout.get() : stderr.get();
+            if(tmp == null)
+                return;
             if(newline)
                 tmp.println(x);
             else
@@ -509,7 +539,7 @@ protected synchronized void append(String x, boolean newline) {
 
     public static void main(String[] args) throws IOException {
         JUnitXMLReporter reporter=new JUnitXMLReporter();
-        reporter.output_dir=""/home/bela/JGroups/tmp/test-results/xml/tcp"";
+        reporter.output_dir=""/home/bela/JGroups/tmp/test-results/xml/udp"";
         reporter.generateReports();
     }
 ",2012-02-09T10:30:19Z,151
"@@ -5,26 +5,23 @@
 import org.jgroups.logging.LogFactory;
 import org.jgroups.protocols.*;
 import org.jgroups.protocols.pbcast.FLUSH;
+import org.jgroups.stack.IpAddress;
 import org.jgroups.stack.Protocol;
 import org.jgroups.stack.ProtocolStack;
-import org.jgroups.stack.IpAddress;
 import org.jgroups.util.ResourceManager;
-import org.jgroups.util.Util;
 import org.jgroups.util.StackType;
+import org.jgroups.util.Util;
 import org.testng.AssertJUnit;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Optional;
-import org.testng.annotations.Parameters;
-import org.testng.annotations.Test;
+import org.testng.annotations.*;
 
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.net.InetAddress;
-import java.util.*;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
@@ -46,11 +43,12 @@ public class ChannelTestBase {
 
     private String bind_addr = null;
 
-    protected final Log log = LogFactory.getLog(this.getClass());
+    protected Log log;
 
     @BeforeClass
     @Parameters(value = { ""channel.conf"", ""use_blocking"" })
     protected void initializeBase(@Optional(""udp.xml"") String chconf, @Optional(""false"") String use_blocking) throws Exception {
+        log=LogFactory.getLog(this.getClass());
         Test annotation = this.getClass().getAnnotation(Test.class);
         // this should never ever happen!
         if (annotation == null)",2012-02-09T10:30:19Z,72
"@@ -10,32 +10,28 @@
 
 import java.io.*;
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * Tests state transfer API (including exception handling)
  * @author Bela Ban
  */
 @Test(groups=Global.STACK_DEPENDENT,sequential=true)
 public class StateTransferTest2 extends ChannelTestBase {
+    JChannel c1, c2;
 
 
     @DataProvider(name=""createChannels"")
-    protected Iterator<JChannel[]> createChannels() {
-        return new MyIterator(new Class[]{STATE_TRANSFER.class, STATE.class,
-          STATE_SOCK.class});
+    protected Iterator<Class<?>[]> createChannels() {
+        return new MyIterator(new Class<?>[]{STATE_TRANSFER.class, STATE.class, STATE_SOCK.class});
     }
 
-   /* @DataProvider(name=""createChannels"")
-    protected Iterator<JChannel[]> createChannels() {
-        return new MyIterator(new Class[]{STATE.class});
-    }*/
-
-
 
    
     @Test(dataProvider=""createChannels"")
-    public void testSuccessfulStateTransfer(final JChannel c1, final JChannel c2) throws Exception {
+    public void testSuccessfulStateTransfer(final Class<?> state_transfer_class) throws Exception {
         try {
+            createStateProviderAndRequesterChannels(state_transfer_class);
             StateHandler sh1=new StateHandler(""Bela"", false, false), sh2=new StateHandler(null, false, false);
             c1.setReceiver(sh1);
             c2.setReceiver(sh2);
@@ -50,8 +46,9 @@ public void testSuccessfulStateTransfer(final JChannel c1, final JChannel c2) th
     }
 
     @Test(dataProvider=""createChannels"")
-    public void testUnsuccessfulStateTransferFailureAtStateProvider(final JChannel c1, final JChannel c2) throws Exception {
+    public void testUnsuccessfulStateTransferFailureAtStateProvider(final Class<?> state_transfer_class) throws Exception {
         try {
+            createStateProviderAndRequesterChannels(state_transfer_class);
             StateHandler sh1=new StateHandler(""Bela"", true, false), sh2=new StateHandler(null, false, false);
             c1.setReceiver(sh1);
             c2.setReceiver(sh2);
@@ -73,7 +70,8 @@ public void testUnsuccessfulStateTransferFailureAtStateProvider(final JChannel c
 
 
     @Test(dataProvider=""createChannels"")
-    public void testUnsuccessfulStateTransferFailureAtStateRequester(final JChannel c1, final JChannel c2) throws Exception {
+    public void testUnsuccessfulStateTransferFailureAtStateRequester(final Class<?> state_transfer_class) throws Exception {
+        createStateProviderAndRequesterChannels(state_transfer_class);
         StateHandler sh1=new StateHandler(""Bela"", false, false), sh2=new StateHandler(null, false, true);
         c1.setReceiver(sh1);
         c2.setReceiver(sh2);
@@ -90,62 +88,51 @@ public void testUnsuccessfulStateTransferFailureAtStateRequester(final JChannel
     }
 
 
+    protected void createStateProviderAndRequesterChannels(Class state_transfer_class) throws Exception {
+        c1=createChannel(true, 2, ""Provider"");
+        replaceStateTransferProtocolWith(c1, state_transfer_class);
+        c2=createChannel(c1, ""Requester"");
+        c1.connect(""StateTransferTest2"");
+        c2.connect(""StateTransferTest2"");
+    }
 
-    protected class MyIterator implements Iterator<JChannel[]> {
-        protected final Class[] stream_transfer_prots;
-        protected int           index=0;
-
-        public MyIterator(Class[] stream_transfer_prots) {
-            this.stream_transfer_prots=stream_transfer_prots;
+    protected void replaceStateTransferProtocolWith(JChannel ch, Class<?> state_transfer_class) throws Exception {
+        ProtocolStack stack=ch.getProtocolStack();
+        if(stack.findProtocol(state_transfer_class) != null)
+            return; // protocol of the right class is already in stack
+        Protocol prot=stack.findProtocol(STATE_TRANSFER.class, StreamingStateTransfer.class);
+        Protocol new_state_transfer_protcol=(Protocol)state_transfer_class.newInstance();
+        if(prot != null) {
+            stack.replaceProtocol(prot, new_state_transfer_protcol);
+        }
+        else { // no state transfer protocol found in stack
+            Protocol flush=stack.findProtocol(FLUSH.class);
+            if(flush != null)
+                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
+            else
+                stack.insertProtocolAtTop(new_state_transfer_protcol);
         }
+    }
 
-        public boolean hasNext() {
-            return index < stream_transfer_prots.length;
-        }
 
-        public JChannel[] next() {
-            try {
-                Class next_class=stream_transfer_prots[index++];
-                System.out.println(""State transfer protocol used: "" + next_class);
-                return createStateProviderAndRequesterChannels(next_class);
-            }
-            catch(Exception e) {
-                throw new RuntimeException(""failed creating a new channel"", e);
-            }
-        }
 
-        public void remove() {
-        }
+    protected static class MyIterator implements Iterator<Class<?>[]> {
+        protected final Class<?>[] stream_transfer_prots;
+        protected int              index=0;
 
+        public MyIterator(Class<?>[] stream_transfer_prots) {
+            this.stream_transfer_prots=stream_transfer_prots;
+        }
 
+        public boolean hasNext() {return index < stream_transfer_prots.length;}
 
-        protected JChannel[] createStateProviderAndRequesterChannels(Class state_transfer_class) throws Exception {
-            JChannel[] retval=new JChannel[2];
-            retval[0]=createChannel(true, 2, ""Provider"");
-            replaceStateTransferProtocolWith(retval[0], state_transfer_class);
-            retval[1]=createChannel(retval[0], ""Requester"");
-            for(JChannel ch: retval)
-                ch.connect(""StateTransferTest2"");
-            return retval;
+        public Class<?>[] next() {
+            if(index+1 > stream_transfer_prots.length)
+                throw new NoSuchElementException();
+            return new Class<?>[]{stream_transfer_prots[index++]};
         }
 
-        protected void replaceStateTransferProtocolWith(JChannel ch, Class state_transfer_class) throws Exception {
-            ProtocolStack stack=ch.getProtocolStack();
-            if(stack.findProtocol(state_transfer_class) != null)
-                return; // protocol of the right class is already in stack
-            Protocol prot=stack.findProtocol(STATE_TRANSFER.class, StreamingStateTransfer.class);
-            Protocol new_state_transfer_protcol=(Protocol)state_transfer_class.newInstance();
-            if(prot != null) {
-                stack.replaceProtocol(prot, new_state_transfer_protcol);
-            }
-            else { // no state transfer protocol found in stack
-                Protocol flush=stack.findProtocol(FLUSH.class);
-                if(flush != null)
-                    stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
-                else
-                    stack.insertProtocolAtTop(new_state_transfer_protcol);
-            }
-        }
+        public void remove() {}
     }
 
 ",2012-02-09T10:30:19Z,152
"@@ -11,7 +11,7 @@
 RULE SendNewMessages
 CLASS SEQUENCER
 METHOD resend
-HELPER org.jgroups.tests.byteman.SequencerFailoverTestHelper
+HELPER org.jgroups.tests.helpers.SequencerFailoverTestHelper
 AFTER WRITE resending ALL
 BIND local_addr_name=org.jgroups.util.UUID.get($0.local_addr);
      map:java.util.Map=$0.forward_table;",2012-06-08T11:31:41Z,153
"@@ -1,5 +1,5 @@
 <!DOCTYPE suite SYSTEM ""http://testng.org/testng-1.0.dtd"">
-<!--<suite name=""byteman""
+<suite name=""byteman""
        parallel=""false""
        thread-count=""1"" >
 
@@ -14,19 +14,4 @@
             <package name=""org.jgroups.tests.byteman.*""/>
         </packages>
     </test>
-</suite>-->
-
-
-<suite name=""byteman"" parallel=""false"" thread-count=""1"">
-  <test name=""byteman"" junit=""false"" time-out=""120000"">
-
-      <!--
-      Due to classloader issues with TestNG, classes have to be listed individually (groups cannot be used)
-      -->
-      <classes>
-          <class name=""org.jgroups.tests.byteman.SequencerFailoverTest""/>
-          <class name=""org.jgroups.tests.byteman.RingBufferTest""/>
-      </classes>
-
-  </test>
 </suite>",2012-06-08T11:31:41Z,154
"@@ -1,4 +1,4 @@
-package org.jgroups.tests.byteman;
+package org.jgroups.tests.helpers;
 
 import org.jboss.byteman.rule.Rule;
 import org.jboss.byteman.rule.helper.Helper;",2012-06-08T11:31:41Z,155
"@@ -12,7 +12,7 @@
  * Keeps track of a range of messages to be retransmitted. A bit set is used to represent missing messages.
  * Every non-received message has a corresponding bit set to 0, every received message is 1.
  * @author Bela Ban
- * @version $Id: XmitRange.java,v 1.5 2009/11/25 08:51:54 belaban Exp $
+ * @version $Id: XmitRange.java,v 1.6 2009/11/25 08:55:32 belaban Exp $
  */
 public class XmitRange implements Comparable<XmitRange> {
     final long low;
@@ -54,45 +54,30 @@ public boolean contains(long num) {
     }
 
     public boolean get(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            return bits.get(index);
-        }
+        return bits.get(getIndex((int)num));
     }
 
     public void set(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            bits.set(index);
-        }
+        bits.set(getIndex((int)num));
     }
 
     public void set(long ... nums) {
-        if(nums == null)
-            return;
-        synchronized(this) {
+        if(nums != null)
             for(long num: nums)
                 set(num);
-        }
     }
 
     public void clear(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            bits.clear(index);
-        }
+        bits.clear(getIndex((int)num));
     }
 
     public void clear(long ... nums) {
-        if(nums == null)
-            return;
-        synchronized(this) {
+        if(nums != null)
             for(long num: nums)
                 clear(num);
-        }
     }
 
-    public synchronized int getNumberOfReceivedMessages() {
+    public int getNumberOfReceivedMessages() {
         return bits.cardinality();
     }
 
@@ -180,7 +165,7 @@ public String printBits(boolean value) {
      * @param value If true, returns all bits set to 1, else 0
      * @return
      */
-    public synchronized Collection<Range> getBits(boolean value) {
+    public Collection<Range> getBits(boolean value) {
         int index=0;
         int start_range=0, end_range=0;
         int size=(int)((high - low) + 1);
@@ -202,52 +187,5 @@ public synchronized Collection<Range> getBits(boolean value) {
         return retval;
     }
     
-
-    public static void main(String[] args) throws IOException, ChannelException {
-        XmitRange range=new XmitRange(10,20);
-        System.out.println(""range = "" + range.print());
-
-        range.set(12);
-        range.set(17);
-        range.set(10);
-        range.set(11);
-        System.out.println(""range = "" + range.print());
-
-        boolean set=range.get(12);
-        System.out.println(""set = "" + set);
-
-        set=range.get(17);
-        System.out.println(""set = "" + set);
-
-        System.out.println(""msgs to retransmit: "" + range.printBits(false));
-
-
-
-       /* TreeMap<MyRange,MyRange> map=new TreeMap<MyRange,MyRange>();
-
-        MyRange[] ranges=new MyRange[]{new MyRange(23,200), new MyRange(222,222), new MyRange(700,800), new MyRange(900,905)};
-
-        for(MyRange range: ranges)
-            map.put(range, range);
-
-
-        System.out.println(""map = "" + map.keySet());
-
-
-        for(long num: new long[]{0, 1, 23, 100, 200, 201, 202, 222, 223, 750, 899, 905, 1000}) {
-            MyRange range=get(num, map);
-            if(range != null && range.contains(num))
-                System.out.println(""range for "" + num + "": "" + range);
-            else
-                System.out.println(""range for "" + num + "": "" + range);
-        }*/
-    }
-
-
-    public static XmitRange get(long num, Map<XmitRange, XmitRange> map) {
-        XmitRange range=map.get(new XmitRange(num, true));
-        if(range != null && range.contains(num))
-            return range;
-        return null;
-    }
+  
 }",2009-11-25T08:55:32Z,156
"@@ -0,0 +1,60 @@
+#!/bin/bash
+
+#Author: Pedro Ruivo
+#Since: 3.1
+#Note: I'm assuming that jgroups-<version>.jar is in the same directory as this script. The same applies for
+#      for the log4j.properties
+
+WORKING_DIR=`cd $(dirname $0); pwd`
+HOSTNAME=`hostname`
+CP=""${WORKING_DIR}/jgroups*.jar""
+
+#enable remote JMX
+JMX=""-Dcom.sun.management.jmxremote.port=8081 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false""
+
+#jgroups flags
+JG_FLAGS=""-Dresolve.dns=false -Djgroups.bind_addr=${HOSTNAME} -Djava.net.preferIPv4Stack=true -Djgroups.timer.num_threads=4""
+
+#log4j
+LOG4J=""-Dlog4j.configuration=file:${WORKING_DIR}/log4j.properties""
+
+#java flags
+JAVA_FLAGS=""-server -Xmx7G -Xms7G""
+
+while [ -n ""$1"" ]; do
+case $1 in
+  -h) HELP=""1""; break;;
+  -test-order) ORDER=""1""; shift 1; break;;
+  -nr-nodes) NR_NODES=$2; shift 2;;
+  -nr-messages) NR_MESSAGES=$2; shift 2;;
+  -config) CONFIG=$2; shift 2;;
+  -*) echo ""unknown option $1""; shift 1;;
+  *) echo ""unknown argument $1""; shift 1;;
+esac;
+done
+
+if [ -n ""${HELP}"" ]; then
+ARGS=""-h""
+else if [ -n ""${ORDER}"" ]; then
+CMD=""java ${JAVA_FLAGS} -cp ${CP} ${JMX} ${JG_FLAGS} ${LOG4J} org.jgroups.tests.CheckGroupMulticastOrder $*""
+echo ${CMD}
+${CMD} > ${WORKING_DIR}/check_std_out_${HOSTNAME}.out 2>&1 &
+exit 0
+ARGS=""-test-order $*""
+else
+if [ -n ""${NR_NODES}"" ]; then
+ARGS=""-nr-nodes ${NR_NODES}""
+fi
+if [ -n ""${NR_MESSAGES}"" ]; then
+ARGS=""${ARGS} -nr-messages ${NR_MESSAGES}""
+fi
+if [ -n ""${CONFIG}"" ]; then
+ARGS=""${ARGS} -config ${CONFIG}""
+fi
+fi
+fi
+
+CMD=""java ${JAVA_FLAGS} -cp ${CP} ${JMX} ${JG_FLAGS} ${LOG4J} org.jgroups.tests.TestGroupMulticastOrder ${ARGS}""
+
+echo ${CMD}
+${CMD} > ${WORKING_DIR}/std_out_${HOSTNAME}.out 2>&1 &",2012-03-23T12:18:00Z,157
"@@ -0,0 +1,73 @@
+<config
+        xmlns=""urn:org:jgroups""
+        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+        xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/JGroups-3.0.xsd"">
+    <TCP
+            bind_port=""7800""
+            loopback=""false""
+            recv_buf_size=""${tcp.recv_buf_size:20M}""
+            send_buf_size=""${tcp.send_buf_size:640K}""
+            discard_incompatible_packets=""true""
+            max_bundle_size=""64K""
+            max_bundle_timeout=""2""
+            enable_bundling=""true""
+            use_send_queues=""true""
+            sock_conn_timeout=""300""
+            thread_naming_pattern=""cl""
+
+            timer_type=""new""
+            timer.min_threads=""4""
+            timer.max_threads=""10""
+            timer.keep_alive_time=""3000""
+            timer.queue_max_size=""500""
+
+            thread_pool.enabled=""true""
+            thread_pool.min_threads=""8""
+            thread_pool.max_threads=""64""
+            thread_pool.keep_alive_time=""50000""
+            thread_pool.queue_enabled=""true""
+            thread_pool.queue_max_size=""1000""
+            thread_pool.rejection_policy=""discard""
+
+            oob_thread_pool.enabled=""true""
+            oob_thread_pool.min_threads=""8""
+            oob_thread_pool.max_threads=""64""
+            oob_thread_pool.keep_alive_time=""5000""
+            oob_thread_pool.queue_enabled=""false""
+            oob_thread_pool.queue_max_size=""1000""
+            oob_thread_pool.rejection_policy=""discard"" />
+    <TCPGOSSIP
+            initial_hosts=""${jgroups.gossip_host:localhost}[12001]""/>
+    <MERGE2
+            max_interval=""30000""
+            min_interval=""10000""/>
+    <FD_SOCK/>
+    <BARRIER/>
+    <pbcast.NAKACK
+            exponential_backoff=""300""
+            use_mcast_xmit=""false""
+            xmit_stagger_timeout=""200""
+            discard_delivered_msgs=""true""/>
+    <UNICAST2
+            exponential_backoff=""500""/>
+    <pbcast.STABLE
+            stability_delay=""2000""
+            desired_avg_gossip=""10000""
+            max_bytes=""4M""
+            cap=""0.1""/>
+    <pbcast.GMS
+            print_local_addr=""true""
+            join_timeout=""3000""
+            max_bundling_time=""500""
+            view_bundling=""true""/>
+    <UFC
+            max_credits=""4M""
+            min_threshold=""0.4""/>
+    <MFC
+            max_credits=""4M""
+            min_threshold=""0.4""/>
+    <FRAG2
+            frag_size=""60K""/>
+    <pmcast.GROUP_MULTICAST />
+    <pbcast.STATE_TRANSFER/>
+</config>
\ No newline at end of file",2012-03-23T12:18:00Z,158
"@@ -55,4 +55,5 @@
     <class id=""92"" name=""org.jgroups.tests.perf.MPerf$MPerfHeader""/>
     <class id=""93"" name=""org.jgroups.protocols.pbcast.NakAckHeader2""/>
     <class id=""94"" name=""org.jgroups.util.SeqnoList""/>
+    <class id=""95"" name=""org.jgroups.protocols.pmcast.header.GroupMulticastHeader""/>
 </magic-number-class-mapping>",2012-03-23T12:18:00Z,138
"@@ -54,6 +54,7 @@
     <class id=""55"" name=""org.jgroups.protocols.RSVP""/>
     <class id=""56"" name=""org.jgroups.protocols.RACKSPACE_PING""/>
     <class id=""57"" name=""org.jgroups.protocols.pbcast.NAKACK2""/>
+    <class id=""58"" name=""org.jgroups.protocols.pmcast.GROUP_MULTICAST""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2012-03-23T12:18:00Z,104
"@@ -0,0 +1,18 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Message;
+
+/**
+ * The interface that the Total Order Multicast protocol must implement. This is invoked by the deliver thread
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public interface DeliverProtocol {
+
+    /**
+     * deliver a message
+     * @param message   message to deliver
+     */
+    void deliver(Message message);
+}",2012-03-23T12:18:00Z,159
"@@ -0,0 +1,454 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.protocols.pmcast.header.GroupMulticastHeader;
+import org.jgroups.protocols.pmcast.manager.DeliverManagerImpl;
+import org.jgroups.protocols.pmcast.manager.SenderManager;
+import org.jgroups.protocols.pmcast.manager.SequenceNumberManager;
+import org.jgroups.protocols.pmcast.stats.StatsCollector;
+import org.jgroups.protocols.pmcast.threading.DeliverThread;
+import org.jgroups.protocols.pmcast.threading.SenderThread;
+import org.jgroups.stack.Protocol;
+
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**  
+ * Total Order Multicast with three communication steps (based on Skeen's Algorithm)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+@MBean(description = ""Implementation of Total Order Multicast based on Skeen's Algorithm"")
+public class GROUP_MULTICAST extends Protocol implements DeliverProtocol {
+    //managers
+    private DeliverManagerImpl deliverManager;
+    private SenderManager senderManager;
+
+    //thread
+    private final DeliverThread deliverThread;
+    private final SenderThread multicastSenderThread;
+
+    //local address
+    private Address localAddress;
+
+    //sequence numbers, messages ids and lock
+    private final SequenceNumberManager sequenceNumberManager;
+    private long messageIdCounter;
+    private final Lock sendLock;
+
+    //stats: profiling information
+    private final StatsCollector statsCollector;
+
+    public GROUP_MULTICAST() {
+        statsCollector = new StatsCollector();
+        deliverThread = new DeliverThread(this);
+        multicastSenderThread = new SenderThread(this);
+        sequenceNumberManager = new SequenceNumberManager();
+        sendLock = new ReentrantLock();
+        messageIdCounter = 0;
+    }
+
+    @Override
+    public void start() throws Exception {
+        deliverManager = new DeliverManagerImpl();
+        senderManager = new SenderManager();
+        deliverThread.start(deliverManager);
+        multicastSenderThread.clear();
+        multicastSenderThread.start();
+        statsCollector.setStatsEnabled(statsEnabled());
+    }
+
+    @Override
+    public void stop() {
+        deliverThread.interrupt();
+        multicastSenderThread.interrupt();
+    }
+
+    @Override
+    public Object down(Event evt) {
+        switch (evt.getType()) {
+            case Event.MSG:
+                handleDownMessage(evt);
+                return null;
+            case Event.SET_LOCAL_ADDRESS:
+                this.localAddress = (Address) evt.getArg();
+                multicastSenderThread.setLocalAddress(localAddress);
+                break;
+            case Event.VIEW_CHANGE:
+                handleViewChange((View) evt.getArg());
+                break;
+            default:
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+    @Override
+    public Object up(Event evt) {
+        switch (evt.getType()) {
+            case Event.MSG:
+                Message message = (Message) evt.getArg();
+
+                GroupMulticastHeader header = (GroupMulticastHeader) message.getHeader(this.id);
+
+                if (header == null) {
+                    break;
+                }
+
+                switch (header.getType()) {
+                    case GroupMulticastHeader.DATA_MESSAGE:
+                        handleDataMessage(message, header);
+                        break;
+                    case GroupMulticastHeader.PROPOSE_MESSAGE:
+                        handleSequenceNumberPropose(message.getSrc(), header);
+                        break;
+                    case GroupMulticastHeader.FINAL_MESSAGE:
+                        handleFinalSequenceNumber(header);
+                        break;
+                    default:
+                        throw new IllegalStateException(""Unknown header type received "" + header);
+                }
+                return null;
+            case Event.VIEW_CHANGE:
+                handleViewChange((View) evt.getArg());
+                break;
+            case Event.SET_LOCAL_ADDRESS:
+                this.localAddress = (Address) evt.getArg();
+                multicastSenderThread.setLocalAddress(localAddress);
+                break;
+            default:
+                break;
+        }
+        return up_prot.up(evt);
+    }
+
+    @Override
+    public void deliver(Message message) {
+        message.setDest(localAddress);
+
+        if (log.isDebugEnabled()) {
+            log.debug(""Deliver message "" + message + "" in total order"");
+        }
+
+        up_prot.up(new Event(Event.MSG, message));
+        statsCollector.incrementMessageDeliver();
+    }
+
+    private void handleViewChange(View view) {
+        if (log.isTraceEnabled()) {
+            log.trace(""Handle view "" + view);
+        }
+        // TODO: Future work: How to add fault tolerance? (simple and efficient)
+    }
+
+    private void handleDownMessage(Event evt) {
+        Message message = (Message) evt.getArg();
+        Address dest = message.getDest();
+
+        if (dest != null && dest instanceof GroupAddress && !message.isFlagSet(Message.Flag.NO_TOTAL_ORDER)) {
+            //group multicast message
+            handleDownGroupMulticastMessage(message);
+        } else if (dest != null && dest instanceof GroupAddress) {
+            //group address with NO_TOTAL_ORDER flag (should no be possible, but...)
+            handleDownGroupMessage(message);
+        } else {
+            //normal message
+            down_prot.down(evt);
+        }
+    }
+
+    private void handleDownGroupMessage(Message message) {
+        if (log.isTraceEnabled()) {
+            log.trace(""Handle message with Group Address but with Flag NO_TOTAL_ORDER set"");
+        }
+        GroupAddress groupAddress = (GroupAddress) message.getDest();
+        try {
+            multicastSenderThread.addMessage(message, groupAddress.getAddresses());
+        } catch (Exception e) {
+            logException(""Exception caugh while send a NO-TOTAL-ORDER group multicast"", e);
+        }
+    }
+
+    private void handleDownGroupMulticastMessage(Message message) {
+        boolean trace = log.isTraceEnabled();
+        boolean warn = log.isWarnEnabled();
+
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        if (trace) {
+            log.trace(""Handle group multicast message"");
+        }
+        GroupAddress groupAddress = (GroupAddress) message.getDest();
+        Set<Address> destination = groupAddress.getAddresses();
+
+        if (destination.isEmpty()) {
+            if (warn) {
+                log.warn(""Received a group address with an empty list"");
+            }
+            throw new IllegalStateException(""Group Address must have at least one element"");
+        }
+
+        if (destination.size() == 1) {
+            if (warn) {
+                log.warn(""Received a group address with an element"");
+            }
+            message.setDest(destination.iterator().next());
+            down_prot.down(new Event(Event.MSG, message));
+            return;
+        }
+
+        boolean deliverToMySelf = destination.contains(localAddress);
+
+        sendLock.lock();
+        try {
+            MessageID messageID = new MessageID(localAddress, messageIdCounter++);
+            long sequenceNumber = sequenceNumberManager.getAndIncrement();
+
+            GroupMulticastHeader header = GroupMulticastHeader.createNewHeader(GroupMulticastHeader.DATA_MESSAGE,
+                    messageID);
+            header.setSequencerNumber(sequenceNumber);
+            header.addDestinations(destination);
+            message.putHeader(this.id, header);
+
+            senderManager.addNewMessageToSent(messageID, destination, sequenceNumber, deliverToMySelf);
+
+            if (deliverToMySelf) {
+                deliverManager.addNewMessageToDeliver(messageID, message, sequenceNumber);
+            }
+
+            if (trace) {
+                log.trace(""Sending message "" + messageID + "" to "" + destination + "" with initial sequence number of "" +
+                        sequenceNumber);
+            }
+
+            multicastSenderThread.addMessage(message, destination);
+
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while handling group multicast message. Error is "" + e.getLocalizedMessage(),
+                    e);
+        } finally {
+            sendLock.unlock();
+            statsCollector.addGroupMulticastSentDuration(duration, (destination.size() - (deliverToMySelf ? 1 : 0)));
+        }
+    }
+
+    private void handleDataMessage(Message message, GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        try {
+            MessageID messageID = header.getMessageID();
+
+            //create the sequence number and put it in deliver manager
+            long myProposeSequenceNumber = sequenceNumberManager.updateAndGet(header.getSequencerNumber());
+            deliverManager.addNewMessageToDeliver(messageID, message, myProposeSequenceNumber);
+
+            if (log.isTraceEnabled()) {
+                log.trace(""Received the message with "" + header + "". The proposed sequence number is "" +
+                        myProposeSequenceNumber);
+            }
+
+            //create a new message and send it back
+            Message proposeMessage = new Message();
+            proposeMessage.setSrc(localAddress);
+            proposeMessage.setDest(messageID.getAddress());
+
+            GroupMulticastHeader newHeader = GroupMulticastHeader.createNewHeader(
+                    GroupMulticastHeader.PROPOSE_MESSAGE, messageID);
+
+            newHeader.setSequencerNumber(myProposeSequenceNumber);
+            proposeMessage.putHeader(this.id, newHeader);
+            proposeMessage.setFlag(Message.Flag.OOB);
+            proposeMessage.setFlag(Message.Flag.DONT_BUNDLE);
+
+            //multicastSenderThread.addUnicastMessage(proposeMessage);
+            down_prot.down(new Event(Event.MSG, proposeMessage));
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the data message "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addDataMessageDuration(duration);
+        }
+    }
+
+    private void handleSequenceNumberPropose(Address from, GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+        boolean lastProposeReceived = false;
+
+        boolean trace = log.isTraceEnabled();
+        try {
+            MessageID messageID = header.getMessageID();
+            if (trace) {
+                log.trace(""Received the proposed sequence number message with "" + header + "" from "" +
+                        from);
+            }
+
+            sequenceNumberManager.update(header.getSequencerNumber());
+            long finalSequenceNumber = senderManager.addPropose(messageID, from,
+                    header.getSequencerNumber());
+
+            if (finalSequenceNumber != SenderManager.NOT_READY) {
+                lastProposeReceived = true;
+                Message finalMessage = new Message();
+                finalMessage.setSrc(localAddress);
+
+                GroupMulticastHeader finalHeader = GroupMulticastHeader.createNewHeader(
+                        GroupMulticastHeader.FINAL_MESSAGE, messageID);
+
+                finalHeader.setSequencerNumber(finalSequenceNumber);
+                finalMessage.putHeader(this.id, finalHeader);
+                finalMessage.setFlag(Message.Flag.OOB);
+                finalMessage.setFlag(Message.Flag.DONT_BUNDLE);
+
+                Set<Address> destination = senderManager.getDestination(messageID);
+                if (destination.contains(localAddress)) {
+                    destination.remove(localAddress);
+                }
+
+                if (trace) {
+                    log.trace(""Message "" + messageID + "" is ready to be deliver. Final sequencer number is "" +
+                            finalSequenceNumber);
+                }
+
+                multicastSenderThread.addMessage(finalMessage, destination);
+                //returns true if we are in destination set
+                if (senderManager.markSent(messageID)) {
+                    deliverManager.markReadyToDeliver(messageID, finalSequenceNumber);
+                }
+            }
+
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the propose sequence number for "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addProposeSequenceNumberDuration(duration, lastProposeReceived);
+        }
+    }
+
+    private void handleFinalSequenceNumber(GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        try {
+            MessageID messageID = header.getMessageID();
+            if (log.isTraceEnabled()) {
+                log.trace(""Received the final sequence number message with "" + header);
+            }
+
+            sequenceNumberManager.update(header.getSequencerNumber());
+            deliverManager.markReadyToDeliver(messageID, header.getSequencerNumber());
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the final sequence number for "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addFinalSequenceNumberDuration(duration);
+        }
+    }
+
+    private void logException(String msg, Exception e) {
+        if (log.isDebugEnabled()) {
+            log.debug(msg, e);
+        } else if (log.isWarnEnabled()) {
+            log.warn(msg + "". Error is "" + e.getLocalizedMessage());
+        }
+    }
+
+    @ManagedOperation
+    public String getMessageList() {
+        return deliverManager.getMessageSet().toString();
+    }
+
+    @Override
+    public void enableStats(boolean flag) {
+        super.enableStats(flag);
+        statsCollector.setStatsEnabled(flag);
+    }
+
+    @Override
+    public void resetStats() {
+        super.resetStats();
+        statsCollector.clearStats();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing and sending the group "" +
+            ""multicast message to all the recipients"", writable = false)
+    public double getAvgGroupMulticastSentDuration() {
+        return statsCollector.getAvgGroupMulticastSentDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a data message received"",
+            writable = false)
+    public double getAvgDataMessageReceivedDuration() {
+        return statsCollector.getAvgDataMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a propose message received"" +
+            ""(not the last one"", writable = false)
+    public double getAvgProposeMessageReceivedDuration() {
+        return statsCollector.getAvgProposeMesageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing the last propose message "" +
+            ""received. This last propose message will originate the sending of the final message"", writable = false)
+    public double getAvgLastProposeMessageReceivedDuration() {
+        return statsCollector.getAvgLastProposeMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a final message received"",
+            writable = false)
+    public double getAvgFinalMessageReceivedDuration() {
+        return statsCollector.getAvgFinalMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The number of group multicast messages sent"", writable = false)
+    public int getNumberOfGroupMulticastMessagesSent() {
+        return statsCollector.getNumberOfGroupMulticastMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of final group messages sent"", writable = false)
+    public int getNumberOfFinalGroupMessagesSent() {
+        return statsCollector.getNumberOfFinalGroupMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of group multicast messages delivered"", writable = false)
+    public int getNumberOfGroupMulticastMessagesDelivered() {
+        return statsCollector.getGroupMulticastDelivered();
+    }
+
+    @ManagedAttribute(description = ""The number of propose messages sent"", writable = false)
+    public int getNumberOfProposeMessageSent() {
+        return statsCollector.getNumberOfProposeMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of final messages delivered"", writable = false)
+    public int getNumberOfFinalMessagesDelivered() {
+        return statsCollector.getNumberOfFinalMessagesDelivered();
+    }
+
+    @ManagedAttribute(description = ""The number of data messages delivered"", writable = false)
+    public int getNumberOfDataMessagesDelivered() {
+        return statsCollector.getNumberOfProposeMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of propose messages received"", writable = false)
+    public int getNumberOfProposeMessageReceived() {
+        return statsCollector.getNumberOfProposeMessagesReceived();
+    }
+
+    @ManagedAttribute(description = ""The average number of unicasts messages created per group multicast message"",
+            writable = false)
+    public double getAvgNumberOfUnicastSentPerGroupMulticast() {
+        return statsCollector.getAvgNumberOfUnicastSentPerGroupMulticast();
+    }
+}",2012-03-23T12:18:00Z,160
"@@ -0,0 +1,117 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.Global;
+import org.jgroups.util.Util;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ * This type of address represents a group in which the total order properties must be applied
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class GroupAddress implements Address {
+    private Set<Address> destinations;
+
+    public GroupAddress() {
+        destinations = new HashSet<Address>();
+    }
+
+    public void addAddress(Address address) {
+        destinations.add(address);
+    }
+
+    public void addAllAddress(Collection<Address> addresses) {
+        destinations.addAll(addresses);
+    }
+
+    public Set<Address> getAddresses() {
+        return destinations;
+    }
+
+    public int size() {
+        int size = Global.INT_SIZE;
+        for(Address address : destinations) {
+            size += Util.size(address);
+        }
+        return size;
+    }
+
+    @Override
+    public String toString() {
+        return ""GroupAddress{"" + destinations + ""}"";
+    }
+
+    @Override
+    public int hashCode() {
+        int hc = 0;
+        for(Address address : destinations) {
+            hc += address.hashCode();
+        }
+        return hc;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(obj == null) return false;
+        if(!(obj instanceof GroupAddress)) {
+            return false;
+        }
+
+        GroupAddress other = (GroupAddress) obj;
+
+        return other == this || (this.destinations.containsAll(other.destinations) &&
+                other.destinations.containsAll(this.destinations));
+    }
+
+    public int compareTo(Address o) {
+        int hc1, hc2;
+
+        if(this == o) return 0;
+        if(!(o instanceof GroupAddress))
+            throw new ClassCastException(""comparison between different classes: the other object is "" +
+                    (o != null? o.getClass() : o));
+        GroupAddress other = (GroupAddress) o;
+
+        hc1 = this.hashCode();
+        hc2 = other.hashCode();
+
+        if(hc1 == hc2) {
+            return this.destinations.size() < other.destinations.size() ? -1 :
+                    this.destinations.size() > other.destinations.size() ? 1 : 0;
+        } else {
+            return hc1 < hc2 ? -1 : 1;
+        }
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        Util.writeAddresses(destinations, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        destinations = (Set<Address>) Util.readAddresses(in, HashSet.class);
+    }
+
+    @Override
+    public void writeExternal(ObjectOutput objectOutput) throws IOException {
+        try {
+            writeTo(objectOutput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
+        try {
+            readFrom(objectInput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+}
\ No newline at end of file",2012-03-23T12:18:00Z,161
"@@ -0,0 +1,113 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.util.Streamable;
+import org.jgroups.util.Util;
+
+import java.io.*;
+
+/**
+ * The represents an unique identifier for the messages processed by the Total Order Multicast protocol
+ * 
+ * Note: it is similar to the ViewId (address + counter)
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class MessageID implements Externalizable, Comparable<MessageID>, Cloneable, Streamable {
+    private Address address = null;
+    private long id = -1;
+
+    public MessageID() {}
+
+    public MessageID(Address address, long id) {
+        this.address = address;
+        this.id = id;
+    }
+
+    public MessageID(Address address) {
+        this.address = address;
+    }
+
+    public void setID(long id) {
+        this.id = id;
+    }
+
+    @Override
+    public int compareTo(MessageID other) {
+        if(other == null) return 1;
+
+        if(this.getId() < other.getId()){
+            return -1;
+        } else if(this.getId() > other.getId()){
+            return 1;
+        }
+
+        return this.address.compareTo(other.address);
+    }
+
+    public MessageID copy() {
+        return (MessageID) clone();
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public Address getAddress() {
+        return address;
+    }
+
+    @Override
+    public String toString() {
+        return ""MessageID{"" + address + "":"" + id + ""}"";
+    }
+
+    public Object clone() {
+        return new MessageID(address, id);
+    }
+
+    public boolean equals(Object other) {
+        return (other instanceof MessageID) && compareTo((MessageID) other) == 0;
+    }
+
+
+    public int hashCode() {
+        return (int)id;
+    }
+
+
+    public int serializedSize() {
+        return Util.size(id) + Util.size(address);
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        Util.writeAddress(address, out);
+        Util.writeLong(id, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        address = Util.readAddress(in);
+        id = Util.readLong(in);
+    }
+
+    @Override
+    public void writeExternal(ObjectOutput objectOutput) throws IOException {
+        try {
+            writeTo(objectOutput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
+        try {
+            readFrom(objectInput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+}",2012-03-23T12:18:00Z,162
"@@ -0,0 +1,126 @@
+package org.jgroups.protocols.pmcast.header;
+
+import org.jgroups.Address;
+import org.jgroups.Global;
+import org.jgroups.Header;
+import org.jgroups.protocols.pmcast.MessageID;
+import org.jgroups.util.Util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * The header for the Total Order Multicast protocol
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class GroupMulticastHeader extends Header {
+
+    //type
+    public static final byte DATA_MESSAGE = 1;
+    public static final byte PROPOSE_MESSAGE = 1 << 1;
+    public static final byte FINAL_MESSAGE = 1 << 2;
+
+    private byte type = 0;
+    private MessageID messageID; //address and sequence number
+    private long sequencerNumber;
+    private Set<Address> destination = new HashSet<Address>();
+
+    public GroupMulticastHeader() {
+        messageID = new MessageID();
+    }
+
+    public MessageID getMessageID() {
+        return messageID;
+    }
+
+    public Address getOrigin() {
+        return messageID.getAddress();
+    }
+
+    public void addDestinations(Collection<Address> addresses) {
+        destination.addAll(addresses);
+    }
+
+    public Set<Address> getDestinations() {
+        return destination;
+    }
+
+    public long getSequencerNumber() {
+        return sequencerNumber;
+    }
+
+    public void setSequencerNumber(long sequencerNumber) {
+        this.sequencerNumber = sequencerNumber;
+    }
+
+    public byte getType() {
+        return type;
+    }
+
+    @Override
+    public int size() {
+        return (int) (Global.BYTE_SIZE  + messageID.serializedSize() + Util.size(sequencerNumber) +
+                Util.size(destination));
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type);
+        messageID.writeTo(out);
+        Util.writeLong(sequencerNumber, out);
+        Util.writeAddresses(destination, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        type = in.readByte();
+        messageID.readFrom(in);
+        sequencerNumber = Util.readLong(in);
+        destination = (Set<Address>) Util.readAddresses(in, HashSet.class);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(""GroupMulticastHeader{"")
+                .append(""type="").append(type2String(type))
+                .append("", message_id="").append(messageID)
+                .append("", sequence_number="").append(sequencerNumber)
+                .append("", destinations="").append(destination)
+                .append(""}"");
+        return sb.toString();
+    }
+
+    public static String type2String(byte type) {
+        switch(type) {
+            case DATA_MESSAGE: return ""DATA_MESSAGE"";
+            case PROPOSE_MESSAGE: return ""PROPOSE_MESSAGE"";
+            case FINAL_MESSAGE: return""FINAL_MESSAGE"";
+            default: return ""UNKNOWN"";
+        }
+    }
+
+    public static GroupMulticastHeader createNewHeader(byte type, MessageID messageID) {
+        if (messageID == null) {
+            throw new NullPointerException(""The message ID can't be null"");
+        }
+        GroupMulticastHeader header = new GroupMulticastHeader();
+        header.setType(type);
+        header.setMessageID(messageID);
+        return header;
+    }
+
+    private void setType(byte type) {
+        this.type = type;
+    }
+
+    private void setMessageID(MessageID messageID) {
+        this.messageID = messageID;
+    }
+}
+",2012-03-23T12:18:00Z,163
"@@ -0,0 +1,23 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Message;
+
+import java.util.List;
+
+/**
+ * The interface that a deliver manager must implement. This method is invoked by the deliver thread
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public interface DeliverManager {
+
+    /**
+     * returns an ordered list with the messages to be deliver.
+     * This method blocks if no messages are ready to be deliver
+     *
+     * @return a list of messages to deliver
+     * @throws InterruptedException if it is interrupted
+     */
+    List<Message> getNextMessagesToDeliver() throws InterruptedException;
+}",2012-03-23T12:18:00Z,164
"@@ -0,0 +1,253 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Message;
+import org.jgroups.protocols.pmcast.MessageID;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * The implementation of the Deliver Manager
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class DeliverManagerImpl implements DeliverManager {
+    private static final MessageInfoComparator COMPARATOR = new MessageInfoComparator();
+    private final SortedSet<MessageInfo> toDeliverSet = new TreeSet<MessageInfo>(COMPARATOR);
+    private final ConcurrentMap<MessageID, MessageInfo> messageCache = new ConcurrentHashMap<MessageID, MessageInfo>(8192, .75f, 64);
+
+    /**
+     * Add a new group message to be deliver 
+     * @param messageID         the message ID
+     * @param message           the message (needed to be deliver later)
+     * @param sequenceNumber    the initial sequence number
+     */
+    public void addNewMessageToDeliver(MessageID messageID, Message message, long sequenceNumber) {
+        MessageInfo messageInfo = new MessageInfo(messageID, message, sequenceNumber);
+        synchronized (toDeliverSet) {
+            toDeliverSet.add(messageInfo);
+        }
+        messageCache.put(messageID, messageInfo);
+    }
+
+    /**
+     * marks the message as ready to deliver and set the final sequence number (to be ordered)
+     * @param messageID             the message ID
+     * @param finalSequenceNumber   the final sequence number
+     */
+    public void markReadyToDeliver(MessageID messageID, long finalSequenceNumber) {
+        markReadyToDeliverV2(messageID, finalSequenceNumber);
+    }
+
+    @SuppressWarnings({""SuspiciousMethodCalls""})    
+    private void markReadyToDeliverV1(MessageID messageID, long finalSequenceNumber) {
+        //This is an old version. It was the bottleneck. Updated to version 2. It can be removed later
+        synchronized (toDeliverSet) {
+            MessageInfo messageInfo = null;
+            boolean needsUpdatePosition = false;
+            Iterator<MessageInfo> iterator = toDeliverSet.iterator();
+
+            while (iterator.hasNext()) {
+                MessageInfo aux = iterator.next();
+                if (aux.equals(messageID)) {
+                    messageInfo = aux;
+                    if (messageInfo.sequenceNumber != finalSequenceNumber) {
+                        needsUpdatePosition = true;
+                        iterator.remove();
+                    }
+                    break;
+                }
+            }
+
+            if (messageInfo == null) {
+                throw new IllegalStateException(""Message ID not found in to deliver list. this can't happen. "" +
+                        ""Message ID is "" + messageID);
+            }
+            messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+            if (needsUpdatePosition) {
+                toDeliverSet.add(messageInfo);
+            }
+
+            if (!toDeliverSet.isEmpty() && toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.notify();
+            }
+        }
+    }
+
+    private void markReadyToDeliverV2(MessageID messageID, long finalSequenceNumber) {
+        MessageInfo messageInfo = messageCache.remove(messageID);
+
+        if (messageInfo == null) {
+            throw new IllegalStateException(""Message ID not found in to deliver list. this can't happen. "" +
+                    ""Message ID is "" + messageID);
+        }
+
+        boolean needsUpdatePosition = messageInfo.isUpdatePositionNeeded(finalSequenceNumber);
+
+        synchronized (toDeliverSet) {
+            if (needsUpdatePosition) {
+                toDeliverSet.remove(messageInfo);
+                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+                toDeliverSet.add(messageInfo);
+            } else {
+                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+            }
+            
+            if (toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.notify();
+            }
+        }
+    }
+
+    //see the interface javadoc
+    @Override
+    public List<Message> getNextMessagesToDeliver() throws InterruptedException {
+        LinkedList<Message> toDeliver = new LinkedList<Message>();
+        synchronized (toDeliverSet) {
+            while (toDeliverSet.isEmpty()) {
+                toDeliverSet.wait();
+            }
+
+            if (!toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.wait();
+            }
+
+            Iterator<MessageInfo> iterator = toDeliverSet.iterator();
+
+            while (iterator.hasNext()) {
+                MessageInfo messageInfo = iterator.next();
+                if (messageInfo.isReadyToDeliver()) {
+                    toDeliver.add(messageInfo.getMessage());
+                    iterator.remove();
+                } else {
+                    break;
+                }
+            }
+        }
+        return toDeliver;
+    }
+
+    /**
+     * remove all the pending messages
+     */
+    public void clear() {
+        synchronized (toDeliverSet) {
+            toDeliverSet.clear();
+            messageCache.clear();
+        }
+    }
+
+    /**
+     * Keeps the state of a message
+     */
+    private static class MessageInfo {
+
+        private MessageID messageID;
+        private Message message;
+        private volatile long sequenceNumber;
+        private volatile boolean readyToDeliver;
+
+        public MessageInfo(MessageID messageID, Message message, long sequenceNumber) {
+            if (messageID == null) {
+                throw new NullPointerException(""Message ID can't be null"");
+            }
+            this.messageID = messageID;
+            this.message = message.copy(true, true);
+            this.sequenceNumber = sequenceNumber;
+            this.readyToDeliver = false;
+            this.message.setSrc(messageID.getAddress());
+        }
+
+        private Message getMessage() {
+            return message;
+        }
+
+        private void updateAndmarkReadyToDeliver(long finalSequenceNumber) {
+            this.readyToDeliver = true;
+            this.sequenceNumber = finalSequenceNumber;
+        }
+
+        private boolean isReadyToDeliver() {
+            return readyToDeliver;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+
+            if (o == null) {
+                return false;
+            }
+
+            boolean isMessageID = o.getClass() == MessageID.class;
+
+            if (o.getClass() != getClass() && !isMessageID) {
+                return false;
+            }
+
+            if (isMessageID) {
+                return messageID.equals(o);
+            }
+
+            MessageInfo that = (MessageInfo) o;
+
+            return messageID.equals(that.messageID);
+        }
+
+        @Override
+        public int hashCode() {
+            return messageID.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return ""MessageInfo{"" +
+                    ""messageID="" + messageID +
+                    "", sequenceNumber="" + sequenceNumber +
+                    "", readyToDeliver="" + readyToDeliver +
+                    '}';
+        }
+
+        public boolean isUpdatePositionNeeded(long finalSequenceNumber) {
+            return sequenceNumber != finalSequenceNumber;
+        }
+    }
+
+    private static class MessageInfoComparator implements Comparator<MessageInfo> {
+
+        @Override
+        public int compare(MessageInfo messageInfo, MessageInfo messageInfo1) {
+            if (messageInfo == null) {
+                return messageInfo1 == null ? 0 : 1;
+            } else if (messageInfo1 == null) {
+                return -1;
+            }
+
+            int compareMessageID = messageInfo.messageID.compareTo(messageInfo1.messageID);
+
+            if (compareMessageID == 0) {
+                return 0;
+            }
+
+            if (messageInfo.sequenceNumber != messageInfo1.sequenceNumber) {
+                return Long.signum(messageInfo.sequenceNumber - messageInfo1.sequenceNumber);
+            }
+
+            return compareMessageID;
+        }
+    }
+
+    /**
+     * It is used for testing (see the messages in JMX)
+     * @return unmodifiable set of messages
+     */
+    public Set<MessageInfo> getMessageSet() {
+        synchronized (toDeliverSet) {
+            return Collections.unmodifiableSet(toDeliverSet);
+        }
+    }
+}",2012-03-23T12:18:00Z,165
"@@ -0,0 +1,137 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Address;
+import org.jgroups.protocols.pmcast.MessageID;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Keeps track of all sended messages, until the final sequence number is known
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SenderManager {
+
+    public static final long NOT_READY = -1;
+
+    private final ConcurrentMap<MessageID, MessageInfo> sentMessages = new ConcurrentHashMap<MessageID, MessageInfo>();
+
+    /**
+     * Add a new message sent
+     * @param messageID             the message ID
+     * @param destination           the destination set
+     * @param initialSequenceNumber the initial sequence number
+     * @param deliverToMySelf       true if *this* member is in destination sent, false otherwise
+     */
+    public void addNewMessageToSent(MessageID messageID, Set<Address> destination, long initialSequenceNumber,
+                                    boolean deliverToMySelf) {
+        MessageInfo messageInfo = new MessageInfo(destination, initialSequenceNumber, deliverToMySelf);
+        if (deliverToMySelf) {
+            messageInfo.setProposeReceived(messageID.getAddress());
+        }
+        sentMessages.put(messageID, messageInfo);
+    }
+
+    /**
+     * Add a propose from a member in destination set
+     * @param messageID         the message ID
+     * @param from              the originator of the propose
+     * @param sequenceNumber    the proposed sequence number
+     * @return NOT_READY if the final sequence number is not know, or the final sequence number
+     */
+    public long addPropose(MessageID messageID, Address from, long sequenceNumber) {
+        MessageInfo messageInfo = sentMessages.get(messageID);
+        if (messageInfo != null && messageInfo.addPropose(from, sequenceNumber)) {
+            return messageInfo.getAndMarkFinalSent();
+        }
+        return NOT_READY;
+    }
+
+    /**
+     * Mark the message as sent
+     * @param messageID the message ID
+     * @return  return true if *this* member is in destination set
+     */
+    public boolean markSent(MessageID messageID) {
+        MessageInfo messageInfo =  sentMessages.remove(messageID);
+        return messageInfo != null && messageInfo.toSelfDeliver;
+    }
+
+    /**
+     * obtains the destination set of a message
+     * @param messageID the message ID
+     * @return the destination set
+     */
+    public Set<Address> getDestination(MessageID messageID) {
+        MessageInfo messageInfo = sentMessages.get(messageID);
+        Set<Address> destination;
+        if (messageInfo != null) {
+            destination = new HashSet<Address>(messageInfo.destination);
+        } else {
+            destination = Collections.emptySet();
+        }
+        return destination;
+    }
+
+    /**
+     * removes all pending messages
+     */
+    public void clear() {
+        sentMessages.clear();
+    }
+
+    /**
+     * The state of a message (destination, proposes missing, the highest sequence number proposed, etc...)
+     */
+    private static class MessageInfo {
+        private ArrayList<Address> destination;
+        private long highestSequenceNumberReceived;
+        private BitSet receivedPropose;
+        private boolean finalMessageSent = false;
+        private boolean toSelfDeliver = false;
+
+        private MessageInfo(Set<Address> addresses, long sequenceNumber, boolean selfDeliver) {
+            this.destination = new ArrayList<Address>(addresses);
+            this.highestSequenceNumberReceived = sequenceNumber;
+            createNewBitSet(addresses.size());
+            this.toSelfDeliver = selfDeliver;
+        }
+
+        private synchronized boolean addPropose(Address from, long sequenceNumber) {
+            setProposeReceived(from);
+            highestSequenceNumberReceived = Math.max(highestSequenceNumberReceived, sequenceNumber);
+            return checkAllProposesReceived();
+        }
+
+        private synchronized long getAndMarkFinalSent() {
+            if (checkAllProposesReceived() && !finalMessageSent) {
+                finalMessageSent = true;
+                return highestSequenceNumberReceived;
+            }
+            return NOT_READY;
+        }
+
+        private void createNewBitSet(int maxElements) {
+            receivedPropose = new BitSet(maxElements);
+            for (int i = 0; i < maxElements; ++i) {
+                receivedPropose.set(i);
+            }
+        }
+
+        private void setProposeReceived(Address address) {
+            int idx = destination.indexOf(address);
+            if (idx == -1) {
+                throw new IllegalStateException(""Address doesn't exists in destination list. Address is "" + address);
+            }
+            receivedPropose.set(idx, false);
+        }
+
+        private boolean checkAllProposesReceived() {
+            return receivedPropose.isEmpty();
+        }
+    }
+
+}",2012-03-23T12:18:00Z,166
"@@ -0,0 +1,43 @@
+package org.jgroups.protocols.pmcast.manager;
+
+/**
+ * Manages the messages sequence number (keeps it up-to-date)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SequenceNumberManager {
+
+    private long sequenceNumber = 0;
+
+    /**
+     * 
+     * @return the next sequence number
+     */
+    public synchronized long getAndIncrement() {
+        return sequenceNumber++;
+    }
+
+    /**
+     * updates the sequence number to the maximum between them
+     * @param otherSequenceNumber   the sequence number received
+     */
+    public synchronized void update(long otherSequenceNumber) {
+        sequenceNumber = Math.max(sequenceNumber, otherSequenceNumber + 1);
+    }
+
+    /**
+     * updates the sequence number and returns the next, that will be used a propose sequence number 
+     * @param otherSequenceNumber   the sequence number received
+     * @return                      the next sequence number or the received sequence number, if the received sequence
+     *                              number is higher the the actual sequence number
+     */
+    public synchronized long updateAndGet(long otherSequenceNumber) {
+        if (sequenceNumber >= otherSequenceNumber) {
+            return sequenceNumber++;
+        } else {
+            sequenceNumber = otherSequenceNumber + 1;
+            return otherSequenceNumber;
+        }
+    }
+}",2012-03-23T12:18:00Z,167
"@@ -0,0 +1,215 @@
+package org.jgroups.protocols.pmcast.stats;
+
+import java.util.EnumMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * This collects the stats and some profiling information
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class StatsCollector {
+
+    private static enum Counter {
+        PROPOSE_MESSAGE_RECEIVED,
+        LAST_PROPOSE_MESSAGE_RECEIVED,
+        FINAL_MESSAGE_RECEIVED,
+        DATA_MESSAGE_RECEIVED,
+        GROUP_MESSAGE_SENT,
+        GROUP_MESSAGE_DELIVERED,
+        UNICAST_MESSAGE_SENT
+    }
+
+    private static enum Duration {
+        PROPOSE_MESSAGE,
+        LAST_PROPOSE_MESSAGE,
+        FINAL_MESSAGE,
+        DATA_MESSAGE,
+        GROUP_MESSAGE_SENT
+    }
+
+    //from javadoc: Enum maps are represented internally as arrays. This representation is extremely compact and efficient. 
+    //this way is simple to add new stats and avoids create N field with atomic long or atomic integer. 
+    private EnumMap<Counter, AtomicInteger> counters;
+    private EnumMap<Duration, AtomicLong> durations;
+
+    public StatsCollector() {
+        counters = new EnumMap<Counter, AtomicInteger>(Counter.class);
+        durations = new EnumMap<Duration, AtomicLong>(Duration.class);
+
+        for (Counter counter : Counter.values()) {
+            counters.put(counter, new AtomicInteger(0));
+        }
+
+        for (Duration duration : Duration.values()) {
+            durations.put(duration, new AtomicLong(0));
+        }
+    }
+
+    private volatile boolean statsEnabled;
+
+    private boolean shouldCollectStats(long... values) {
+        if (!statsEnabled) {
+            return false;
+        }
+        for (long value : values) {
+            if (value < 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private double convertNanosToMillis(long nanos) {
+        return nanos / 1000000.0;
+    }
+
+    public void setStatsEnabled(boolean statsEnabled) {
+        this.statsEnabled = statsEnabled;
+    }
+
+    public void clearStats() {
+        for (AtomicInteger counter : counters.values()) {
+            counter.set(0);
+        }
+
+        for (AtomicLong duration : durations.values()) {
+            duration.set(0);
+        }
+    }
+
+    public long now() {
+        return statsEnabled ? System.nanoTime() : -1;
+    }
+
+    public void addProposeSequenceNumberDuration(long durationValue, boolean isLastProposeMessage) {
+        if (!shouldCollectStats(durationValue)) {
+            return;
+        }
+        Counter counter = isLastProposeMessage ? Counter.LAST_PROPOSE_MESSAGE_RECEIVED :
+                Counter.PROPOSE_MESSAGE_RECEIVED;
+        Duration duration = isLastProposeMessage ? Duration.LAST_PROPOSE_MESSAGE :
+                Duration.PROPOSE_MESSAGE;
+
+        counters.get(counter).incrementAndGet();
+        durations.get(duration).addAndGet(durationValue);
+    }
+
+    public void addFinalSequenceNumberDuration(long duration) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(Counter.FINAL_MESSAGE_RECEIVED).incrementAndGet();
+        durations.get(Duration.FINAL_MESSAGE).addAndGet(duration);
+    }
+
+    public void addDataMessageDuration(long duration) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(Counter.DATA_MESSAGE_RECEIVED).incrementAndGet();
+        durations.get(Duration.DATA_MESSAGE).addAndGet(duration);
+    }
+
+    public void addGroupMulticastSentDuration(long duration, int numberOfUnicasts) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(StatsCollector.Counter.UNICAST_MESSAGE_SENT).addAndGet(numberOfUnicasts);
+        counters.get(Counter.GROUP_MESSAGE_SENT).incrementAndGet();
+        durations.get(Duration.GROUP_MESSAGE_SENT).addAndGet(duration);
+    }
+
+    public void incrementMessageDeliver() {
+        if (!shouldCollectStats()) {
+            return ;
+        }
+        counters.get(Counter.GROUP_MESSAGE_DELIVERED).incrementAndGet();
+    }
+
+    public double getAvgDataMessageReceivedDuration() {
+        int count = counters.get(Counter.DATA_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.DATA_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgGroupMulticastSentDuration() {
+        int count = counters.get(Counter.GROUP_MESSAGE_SENT).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.GROUP_MESSAGE_SENT).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgProposeMesageReceivedDuration() {
+        int count = counters.get(Counter.PROPOSE_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.PROPOSE_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgLastProposeMessageReceivedDuration() {
+        int count = counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.LAST_PROPOSE_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgFinalMessageReceivedDuration() {
+        int count = counters.get(Counter.FINAL_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.FINAL_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public int getNumberOfGroupMulticastMessagesSent() {
+        return counters.get(Counter.GROUP_MESSAGE_SENT).get();
+    }
+
+    public int getGroupMulticastDelivered() {
+        return counters.get(Counter.GROUP_MESSAGE_DELIVERED).get();
+    }
+
+    public int getNumberOfProposeMessagesReceived() {
+        return counters.get(Counter.PROPOSE_MESSAGE_RECEIVED).get() +
+                counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfProposeMessagesSent() {
+        //we send a propose message for each data message received
+        return counters.get(Counter.DATA_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfFinalGroupMessagesSent() {
+        //we send 1 final group message when the last propose is received
+        return counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfFinalMessagesDelivered() {
+        return counters.get(Counter.FINAL_MESSAGE_RECEIVED).get();
+    }
+
+    public double getAvgNumberOfUnicastSentPerGroupMulticast() {
+        int multicast = counters.get(Counter.GROUP_MESSAGE_SENT).get();
+        if (multicast > 0) {
+            int unicast = counters.get(Counter.UNICAST_MESSAGE_SENT).get();
+            return unicast * 1.0 / multicast;
+        }
+        return 0D;
+    }
+}",2012-03-23T12:18:00Z,168
"@@ -0,0 +1,70 @@
+package org.jgroups.protocols.pmcast.threading;
+
+import org.jgroups.Message;
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.protocols.pmcast.DeliverProtocol;
+import org.jgroups.protocols.pmcast.manager.DeliverManager;
+
+import java.util.List;
+
+/**
+ * The deliver threads. Is the only thread that delivers the Total Order Multicast message in order
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class DeliverThread extends Thread {
+    private DeliverManager deliverManager;
+    private boolean running = false;
+    private DeliverProtocol groupMulticastProtocol;
+
+    private final Log log = LogFactory.getLog(this.getClass());
+
+    public DeliverThread(DeliverProtocol protocol) {
+        super(""Group-Multicast-Deliver-Thread"");
+        if (protocol == null) {
+            throw new NullPointerException(""Group Multicast Protocol can't be null"");
+        }
+        this.groupMulticastProtocol = protocol;
+    }
+
+    public void start(DeliverManager deliverManager) {
+        this.deliverManager = deliverManager;
+        start();
+    }
+
+    @Override
+    public void start() {
+        if (deliverManager == null) {
+            throw new NullPointerException(""Deliver Manager can't be null"");
+        }
+        running = true;
+        super.start();
+    }
+
+    @Override
+    public void run() {
+        while (running) {
+            try {
+                List<Message> messages = deliverManager.getNextMessagesToDeliver();
+
+                for (Message msg : messages) {
+                    try {
+                        groupMulticastProtocol.deliver(msg);
+                    } catch(Throwable t) {
+                        log.warn(""Exception caught while delivering message "" + msg + "":"" + t.getMessage());
+                    }
+                }
+            } catch (InterruptedException e) {
+                //interrupted
+            }
+        }
+    }
+
+    @Override
+    public void interrupt() {
+        running = false;
+        super.interrupt();
+    }
+}",2012-03-23T12:18:00Z,169
"@@ -0,0 +1,103 @@
+package org.jgroups.protocols.pmcast.threading;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.stack.Protocol;
+
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * This thread is the responsible to send the group messages, i.e, create N messages and send N unicasts messages
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SenderThread extends Thread {
+
+    private boolean running = false;
+    private Protocol groupMulticastProtocol;
+    private Address localAddress;
+
+    private final BlockingQueue<MessageToSend> sendingQueue;
+    private final Log log = LogFactory.getLog(this.getClass());
+
+    public SenderThread(Protocol protocol) {
+        super(""Group-Multicast-Sender-Thread"");
+        if (protocol == null) {
+            throw new NullPointerException(""Group Multicast Protocol can't be null"");
+        }
+        this.groupMulticastProtocol = protocol;
+        this.sendingQueue = new LinkedBlockingQueue<MessageToSend>();
+    }
+
+    public void setLocalAddress(Address localAddress) {
+        this.localAddress = localAddress;
+    }
+
+    public void addMessage(Message message, Set<Address> destination) throws InterruptedException {
+        sendingQueue.put(new MessageToSend(message, destination));
+    }
+
+    public void clear() {
+        sendingQueue.clear();
+    }
+
+    @Deprecated
+    public void addUnicastMessage(Message message) throws InterruptedException {
+        sendingQueue.put(new MessageToSend(message, null));
+    }
+
+    @Override
+    public void start() {
+        running = true;
+        super.start();
+    }
+
+    @Override
+    public void run() {
+        while (running) {
+            try {
+                MessageToSend messageToSend = sendingQueue.take();
+
+                if (messageToSend.destination == null) {
+                    groupMulticastProtocol.getDownProtocol().down(new Event(Event.MSG, messageToSend.message));
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug(""Send group message "" + messageToSend.message + "" to "" + messageToSend.destination);
+                    }
+                    for (Address address : messageToSend.destination) {
+                        if (address.equals(localAddress)) {
+                            continue;
+                        }
+                        Message cpy = messageToSend.message.copy();
+                        cpy.setDest(address);
+                        groupMulticastProtocol.getDownProtocol().down(new Event(Event.MSG, cpy));
+                    }
+                }
+            } catch (InterruptedException e) {
+                //interrupted
+            }
+        }
+    }
+
+    @Override
+    public void interrupt() {
+        running = false;
+        super.interrupt();
+    }
+
+    private class MessageToSend {
+        private Message message;
+        private Set<Address> destination;
+
+        private MessageToSend(Message message, Set<Address> destination) {
+            this.message = message;
+            this.destination = destination;
+        }
+    }
+}",2012-03-23T12:18:00Z,170
"@@ -0,0 +1,290 @@
+package org.jgroups.tests;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This check the order of the messages, assuming that the message IDs are printed in a file
+ * 
+ * Note: this is used for debugging
+ * Note2: this needs to be clean :)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class CheckGroupMulticastOrder {
+
+    public static void main(String[] args) throws InterruptedException {
+
+        if (args.length == 0) {
+            System.err.println(""usage: [-threads value] <files...>"");
+            System.exit(1);
+        }
+
+        int numberOfThreads = 2;
+        int startIdx = 0;
+
+        if (args[0].equals(""-threads"")) {
+            startIdx = 2;
+            try {
+                numberOfThreads = Integer.parseInt(args[1]);
+            } catch (Exception e) {
+                System.err.println(""Error parsing number of threads: "" + e.getLocalizedMessage());
+                numberOfThreads = 2;
+            } finally {
+                if (numberOfThreads < 1) {
+                    numberOfThreads = 2;
+                }
+            }
+        }
+
+        System.out.println(""--------------------------------------------------------------------"");
+        System.out.println(""------------------CHECK GROUP MULTICAST ORDER ----------------------"");
+        System.out.println(""--------------------------------------------------------------------"");
+
+        System.out.println(""analyze "" + printArgs(args) + "" using "" + numberOfThreads + "" threads"");
+        
+        ComparingFiles[] threads = new ComparingFiles[numberOfThreads];
+        
+        List<Pair> allCombinations = new LinkedList<Pair>();
+        
+        for (int x = startIdx; x < args.length; ++x) {
+            for (int y = x + 1; y < args.length; ++y) {
+                if (x == y) {
+                    continue;
+                }
+                allCombinations.add(new Pair(x, y));
+            }
+        }
+        
+        System.out.println(""Collection for the threads is "" + allCombinations);
+        
+        final Iterator<Pair> iterator = allCombinations.iterator();
+        for (int i = 0; i < threads.length; ++i) {
+            threads[i] = new ComparingFiles(iterator,args,""Comparator-"" + i);
+            threads[i].start();
+        }
+
+        for (ComparingFiles comparingFiles : threads) {
+            comparingFiles.join();
+        }
+
+        System.out.println(""=========== FINISHED! =============="");
+    }
+
+    private static String printArgs(String[] args) {
+        StringBuilder sb = new StringBuilder(args[0]);
+
+        for (int i = 1;  i < args.length; ++i) {
+            sb.append("","").append(args[i]);
+        }
+        return sb.toString();
+    }
+
+    public static void compareFiles(String filePath1, String filePath2, List<String> messageDeliverOrder) {
+        System.out.println(""Comparing "" + filePath1 + "" and "" + filePath2 + "" by thread "" + Thread.currentThread().getName());
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath1));
+
+            String message;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                messageDeliverOrder.add(message);
+            }
+
+            bufferedReader.close();
+            bufferedReader = new BufferedReader(new FileReader(filePath2));
+            int msgExpectedIdx = 0;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                    messageDeliverOrder.add(message);
+                    ++msgExpectedIdx;
+                    continue;
+                }
+                String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+                if (otherMessage.equals(message)) {
+                    msgExpectedIdx++;
+                    continue;
+                }
+
+                int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+                if (realMsgIdx == -1) {
+                    continue;
+                } else if (realMsgIdx < msgExpectedIdx) {
+                    System.err.println(""["" + Thread.currentThread().getName() + ""] Message deliver out of order: "" + message);
+                }
+                msgExpectedIdx = realMsgIdx + 1;
+            }
+
+            bufferedReader.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } catch (IOException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } finally {
+            System.out.println(""Finished comparing this files"");
+        }
+    }
+
+    /*public static void processFile(String filePath, List<String> messageDeliverOrder) {
+        System.out.println(""Processing "" + filePath + "" by thread "" + Thread.currentThread().getName());
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
+
+            int msgExpectedIdx = 0;
+            String message;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                    messageDeliverOrder.add(message);
+                    ++msgExpectedIdx;
+                    continue;
+                }
+                String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+                if (otherMessage.equals(message)) {
+                    msgExpectedIdx++;
+                    continue;
+                }
+
+                int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+                if (realMsgIdx == -1) {
+                    messageDeliverOrder.add(msgExpectedIdx, message);
+                    msgExpectedIdx++;
+                    continue;
+                } else if (realMsgIdx < msgExpectedIdx) {
+                    System.err.println(""["" + Thread.currentThread().getName() + ""] Message deliver out of order: "" +
+                            message + "". Real Idx:"" + realMsgIdx + "", Expected Idx:"" + msgExpectedIdx);
+                }
+                msgExpectedIdx = realMsgIdx + 1;
+            }
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } catch (IOException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } finally {
+            System.out.println(Thread.currentThread().getName() + "" finished processing the file. Getting another one"");
+        }
+    }
+
+    public static void joinLists(List<String> toJoin, ArrayList<String> messageDeliverOrder) {
+        int joinSize = toJoin.size();
+        messageDeliverOrder.ensureCapacity(joinSize);
+        System.out.println(""Joining lists. Sizes: "" + joinSize + "" and "" + messageDeliverOrder.size());
+
+        int msgExpectedIdx = 0;
+        for (String message : toJoin) {
+            if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                messageDeliverOrder.add(message);
+                ++msgExpectedIdx;
+                continue;
+            }
+            String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+            if (otherMessage.equals(message)) {
+                msgExpectedIdx++;
+                continue;
+            }
+
+            int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+            if (realMsgIdx == -1) {
+                messageDeliverOrder.add(msgExpectedIdx, message);
+                msgExpectedIdx++;
+                continue;
+            } else if (realMsgIdx < msgExpectedIdx) {
+                System.err.println(""[Joining] Message deliver out of order: "" + message + "". Real Idx:"" + realMsgIdx +
+                        "", Expected Idx:"" + msgExpectedIdx);
+                continue;
+            }
+            msgExpectedIdx = realMsgIdx + 1;
+        }
+
+    }
+
+    private static class ProcessingFile extends Thread {
+        private AtomicInteger argumentIdx;
+        private ArrayList<String> messageDeliverOrder = new ArrayList<String>();
+        private String[] args;
+
+        private ProcessingFile(final AtomicInteger argumentIdx, final String[] args, String threadName) {
+            super(threadName);
+            this.argumentIdx = argumentIdx;
+            this.args = args;
+        }
+
+        @Override
+        public void run() {
+            while (true) {
+                int idx = argumentIdx.getAndIncrement();
+                if (idx >= args.length) {
+                    break;
+                }
+                processFile(args[idx], messageDeliverOrder);
+            }
+            System.out.println(getName() + "" finished!"");
+        }
+    }*/
+    
+    private static class Pair {       
+        private final int x, y;
+
+        private Pair(int x, int y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        public int getX() {
+            return x;
+        }
+
+        public int getY() {
+            return y;
+        }
+
+        @Override
+        public String toString() {
+            return ""Pair{"" +
+                    ""y="" + y +
+                    "", x="" + x +
+                    '}';
+        }
+    }
+    
+    private static class ComparingFiles extends Thread {
+        private final Iterator<Pair> filesToCompare;
+        private ArrayList<String> messageDeliverOrder = new ArrayList<String>();
+        private String[] args;
+
+        private ComparingFiles(final Iterator<Pair> filesToCompare, final String[] args, String threadName) {
+            super(threadName);
+            this.filesToCompare = filesToCompare;
+            this.args = args;
+        }
+
+        @Override
+        public void run() {
+            while (true) {
+                Pair p;
+                synchronized (filesToCompare) {
+                    if (!filesToCompare.hasNext()) {
+                        break;
+                    }
+                    p = filesToCompare.next();
+                }
+                compareFiles(args[p.getX()], args[p.getY()], messageDeliverOrder);
+                int size = messageDeliverOrder.size();
+                messageDeliverOrder.clear();
+                messageDeliverOrder.ensureCapacity(size);
+            }            
+            
+            System.out.println(getName() + "" finished!"");
+        }
+    }
+}",2012-03-23T12:18:00Z,171
"@@ -0,0 +1,569 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.pmcast.GroupAddress;
+import org.jgroups.util.Util;
+
+import javax.management.*;
+import java.io.*;
+import java.lang.management.ManagementFactory;
+import java.util.*;
+
+/**
+ * Runs the Total Order Multicast protocol and saves the messages delivered
+ * 
+ * Note: this is used for debugging
+ * Note2: this needs to be clean :)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class TestGroupMulticastOrder {
+    private static final String PROPS = ""group-multicast.xml"";
+    private static final String CLUSTER = ""test-group-multicast-cluster"";
+    private static final String OUTPUT_FILE_SUFFIX = ""-messages.txt"";
+    private static final String JMX_DOMAIN = ""org.jgroups"";
+
+    private JChannel jChannel;
+    private MyReceiver receiver;
+    private int numberOfNodes;
+    private int numberOfMessages;
+    private final List<Address> members = new LinkedList<Address>();
+
+    private long start;
+    private long stop;
+    private long sentBytes = 0;
+    private long sentMessages = 0;
+    private String config;
+
+    public static void main(String[] args) throws InterruptedException {
+        System.out.println(""=========================="");
+        System.out.println(""Test Group Multicast Order"");
+        System.out.println(""=========================="");
+
+
+        ArgumentsParser argumentsParser = new ArgumentsParser(args);
+        if (argumentsParser.isHelp()) {
+            helpAndExit();
+        } else if(argumentsParser.isTestOrder()) {
+            /*String[] paths = argumentsParser.getFilesPath();
+            int numberOfFiles = paths.length;
+
+            ProcessFile[] threads = new ProcessFile[numberOfFiles];
+
+            for (int i = 0; i < threads.length; ++i) {
+                threads[i] = new ProcessFile(paths[i]);
+                threads[i].start();
+            }
+
+            Map<String, MessageInfo> allMessages = new HashMap<String, MessageInfo>();
+            for (ProcessFile processFile : threads) {
+                processFile.join();
+                for (MessageInfo messageInfo : processFile.list) {
+                    String message = messageInfo.message;
+                    if (!allMessages.containsKey(message)) {
+                        allMessages.put(message, messageInfo);
+                    } else {
+                        allMessages.get(message).join(messageInfo);
+                    }
+                }
+            }
+
+            for (MessageInfo messageInfo : allMessages.values()) {
+                messageInfo.check();
+            }
+            System.out.println(""============= FINISHED ============="");
+            System.exit(0);*/
+        }
+
+        TestGroupMulticastOrder testGroupMulticastOrder = new TestGroupMulticastOrder(
+                argumentsParser.getNumberOfNodes(),
+                argumentsParser.getNumberOfMessages(),
+                argumentsParser.getConfig());
+
+        try {
+            testGroupMulticastOrder.startTest();
+        } catch (Exception e) {
+            System.err.println(""Error while executing the test: "" + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        } finally {
+            testGroupMulticastOrder.closeJChannel();
+            System.out.println(""============= FINISHED ============="");
+        }
+        System.exit(0);
+    }
+
+    private static void helpAndExit() {
+        System.out.println(""usage: "" + TestGroupMulticastOrder.class.getCanonicalName() + "" <option>"");
+        System.out.println(""Options:"");
+        System.out.println(""  -h                    \tshow this message"");
+        System.out.println(""  -nr-nodes <value>     \tnumber of nodes"");
+        System.out.println(""  -nr-messages <values> \tnumber of messages to send by each node"");
+        System.out.println(""  -config <file>        \tthe JGroup's configuration file"");
+        System.exit(1);
+    }
+
+    // ====================== arguments parser ======================
+
+    private static class ArgumentsParser {
+        private static final int NR_NODES = 4;
+        private static final int NR_MESSAGES = 1000;
+
+        private String[] args;
+
+        private int numberOfNodes = -1;
+        private int numberOfMessages = -1;
+        private boolean help = false;
+        private boolean testOrder = false;
+        private String[] filesPath = null;
+        private String config = PROPS;
+
+        public ArgumentsParser(String[] args) {
+            this.args = args;
+            parse();
+            checkConfig();
+        }
+
+        private void parse() {
+            try {
+                for (int i = 0; i < args.length; ++i) {
+                    if (""-h"".equals(args[i])) {
+                        help = true;
+                    } else if (""-nr-nodes"".equals(args[i])) {
+                        numberOfNodes = Integer.parseInt(args[++i]);
+
+                        if (numberOfNodes < NR_NODES) {
+                            System.err.println(""Number of nodes must be greater or equal to "" + NR_NODES);
+                            System.exit(1);
+                        }
+                    } else if (""-nr-messages"".equals(args[i])) {
+                        numberOfMessages = Integer.parseInt(args[++i]);
+
+                        if (numberOfMessages <= 0) {
+                            System.err.println(""Number of messages must be greater than 0"");
+                            System.exit(1);
+                        }
+                    } else if (""-config"".equals(args[i])) {
+                        config = args[++i];
+                    } else {
+                        System.err.println(""Unknown argument: "" +args[i]);
+                        helpAndExit();
+                    }
+                }
+            } catch (Throwable t) {
+                System.err.println(""Error processing arguments: "" + t.getMessage());
+                t.printStackTrace();
+                System.exit(1);
+            }
+        }
+
+        private void checkConfig() {
+            if (numberOfNodes == -1) {
+                numberOfNodes = NR_NODES;
+            }
+            if (numberOfMessages == -1) {
+                numberOfMessages = NR_MESSAGES;
+            }
+        }
+
+        public boolean isHelp() {
+            return help;
+        }
+
+        public boolean isTestOrder() {
+            return testOrder;
+        }
+
+        public int getNumberOfNodes() {
+            return numberOfNodes;
+        }
+
+        public int getNumberOfMessages() {
+            return numberOfMessages;
+        }
+
+        public String[] getFilesPath() {
+            return filesPath;
+        }
+
+        public String getConfig() {
+            return config;
+        }
+    }
+
+    // ====================== receiver ======================
+
+    private static class MyReceiver extends ReceiverAdapter {
+        private int expectedMembers;
+        private int members = 0;
+        private final List<String> messageList;
+        private final TestGroupMulticastOrder testGroupMulticastOrder;
+
+        private long start = 0;
+        private long stop = 0;
+        private long receivedBytes = 0;
+        private int receivedMsgs = 0;
+
+        public MyReceiver(int expectedMembers, TestGroupMulticastOrder testGroupMulticastOrder) {
+            this.expectedMembers = expectedMembers;
+            this.testGroupMulticastOrder = testGroupMulticastOrder;
+            this.messageList = new LinkedList<String>();
+        }
+
+        @Override
+        public void receive(Message msg) {
+            DataMessage dataMessage = (DataMessage) msg.getObject();
+            switch (dataMessage.type) {
+                case DataMessage.FINISH:
+                    testGroupMulticastOrder.memberFinished(msg.getSrc());
+                    break;
+                case DataMessage.DATA:
+                    if (start == 0) {
+                        start = System.nanoTime();
+                    }
+                    synchronized (messageList) {
+                        messageList.add(dataMessage.data);
+                    }
+                    receivedBytes += (dataMessage.data.getBytes().length + 1);
+                    receivedMsgs++;
+                    stop = System.nanoTime();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        @Override
+        public void viewAccepted(View view) {
+            System.out.println(""New View: "" + view);
+            super.viewAccepted(view);
+            synchronized (this) {
+                members = view.getMembers().size();
+                this.notify();
+            }
+        }
+
+        public synchronized void waitUntilClusterIsFormed() throws InterruptedException {
+            while (members < expectedMembers) {
+                System.out.println(""Number of members is not the expected: "" + members + "" of "" + expectedMembers);
+                this.wait();
+            }
+        }
+
+        public void await(int expectedMessages) throws InterruptedException {
+            int actualSize;
+            while (true) {
+                synchronized (messageList) {
+                    actualSize = messageList.size();
+                }
+                if (actualSize < expectedMessages) {
+                    System.out.println(""waiting messages... "" + actualSize + "" of "" + expectedMessages);
+                    Thread.sleep(10000);
+                } else {
+                    break;
+                }
+            }
+        }
+
+        public List<String> getMessageList() {
+            return messageList;
+        }
+
+        public void printReceiverInfo() {
+            System.out.println(""+++ Receiver Information +++"");
+            double duration = stop - start;
+            duration /= 1000000.0; //nano to millis
+            System.out.println(""+ Duration (msec)   = "" + duration);
+            System.out.println(""+ Received Bytes    = "" + receivedBytes);
+            System.out.println(""+ Received Messages = "" + receivedMsgs);
+            duration /= 1000.0; //millis to sec
+            System.out.println(""---------------------"");
+            System.out.println(""+ Receiving Throughput (bytes/sec)  = "" + (receivedBytes / duration));
+            System.out.println(""+ Receiving Messages (messages/sec) = "" + (receivedMsgs / duration));
+            System.out.println(""-------------------------------------"");
+        }
+
+    }
+
+    // ====================== messages info (deliver before and after) ================
+    /*private static class MessageInfo {
+        private String message;
+        private Set<String> deliveredBefore = new HashSet<String>();
+        private Set<String> deliveredAfter = new HashSet<String>();
+
+        public void join(MessageInfo messageInfo) {
+            this.deliveredAfter.addAll(messageInfo.deliveredAfter);
+            this.deliveredBefore.addAll(messageInfo.deliveredBefore);
+        }
+
+        public void check() {
+            Set<String> intersect = new HashSet<String>(deliveredBefore);
+            intersect.retainAll(deliveredAfter);
+            if (!intersect.isEmpty()) {
+                System.err.println(""ERROR: WRONG ORDER! messages "" + intersect + "" was delivered before and after this"" +
+                        "" message "" + message);
+            }
+        }
+    }
+    
+    private static class MessageInfo2 extends MessageInfo {
+        private String message;
+        private Set<MessageInfo2> deliveredBefore = new HashSet<MessageInfo2>();
+        
+        @Override
+        public void join(MessageInfo messageInfo) {
+            deliveredBefore.addAll(((MessageInfo2)messageInfo).deliveredBefore);
+        }
+        
+        @Override
+        public void check() {
+            for (MessageInfo2 messageInfo2 : deliveredBefore) {
+                if (messageInfo2.deliveredBefore.contains(this)) {
+                    System.err.println(""ERROR: WRONG ORDER! This message "" + message + "" was delivered before and after the"" +
+                        "" message "" + messageInfo2.message);
+                }
+            }
+        }
+    }*/
+
+    //======================= thread processing each input file =====================
+    /*private static class ProcessFile extends Thread {
+        private String filepath;
+        public List<MessageInfo> list = new LinkedList<MessageInfo>();
+
+        private ProcessFile(String filepath) {
+            super();
+            this.filepath = filepath;
+        }
+
+        @Override
+        public void run() {
+            runV2();
+        }
+        
+        public void runV1() {
+            try {
+                Set<String> previously = new HashSet<String>();
+                BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath));
+                String message;
+
+                while ((message = bufferedReader.readLine()) != null) {
+                    MessageInfo messageInfo = new MessageInfo();
+                    messageInfo.message = message;
+                    messageInfo.deliveredBefore.addAll(previously);
+
+                    for (MessageInfo aux : list) {
+                        aux.deliveredAfter.add(message);
+                    }
+                    list.add(messageInfo);
+                    previously.add(message);
+                }
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            } catch (IOException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            }
+        }
+        
+        public void runV2() {
+            try {
+                Set<MessageInfo2> previously = new HashSet<MessageInfo2>();
+                BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath));
+                String message;
+
+                while ((message = bufferedReader.readLine()) != null) {
+                    MessageInfo2 messageInfo = new MessageInfo2();
+                    messageInfo.message = message;
+                    messageInfo.deliveredBefore.addAll(previously);                    
+                    list.add(messageInfo);
+                    previously.add(messageInfo);
+                }
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            } catch (IOException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            }
+        }
+    }*/
+
+    //======================= data message =======================
+    private static class DataMessage implements Serializable {
+        public transient static final byte FINISH = 1; //1 << 0
+        public transient static final byte DATA = 1 << 1;
+
+        private byte type;
+        private String data;
+    }
+
+    // ====================== other methods ======================
+
+    public TestGroupMulticastOrder(int numberOfNodes, int numberOfMessages, String config) {
+        this.numberOfNodes = numberOfNodes;
+        this.numberOfMessages = numberOfMessages;
+        this.config = config;
+    }
+
+    private void createJChannel() throws Exception {
+        System.out.println(""Creating Channel"");
+        receiver = new MyReceiver(numberOfNodes, this);
+        jChannel = new JChannel(config);
+
+        jChannel.setReceiver(receiver);
+        jChannel.connect(CLUSTER);
+
+        receiver.waitUntilClusterIsFormed();
+        Util.registerChannel(jChannel, JMX_DOMAIN);
+
+        members.addAll(jChannel.getView().getMembers());
+    }
+
+    private GroupAddress getDestinations(List<Address> members) {
+        int rand = members.indexOf(jChannel.getAddress());
+
+        GroupAddress address = new GroupAddress();
+
+        address.addAddress(members.get(rand++ % members.size()));
+        address.addAddress(members.get(rand++ % members.size()));
+        address.addAddress(members.get(rand % members.size()));
+
+        return address;
+    }
+
+    private void sendMessages() throws Exception {
+        System.out.println(""Start sending messages..."");
+
+        String address = jChannel.getAddressAsString();
+        List<Address> members = jChannel.getView().getMembers();
+        start = System.nanoTime();
+        for (int i = 0; i < numberOfMessages; ++i) {
+            GroupAddress dst = getDestinations(members);
+            Message message = new Message();
+            message.setDest(dst);
+
+            DataMessage dataMessage = new DataMessage();
+            dataMessage.type = DataMessage.DATA;
+            dataMessage.data = address + "":"" + i;
+
+            message.setObject(dataMessage);
+            jChannel.send(message);
+
+            sentBytes += (dataMessage.data.getBytes().length + 1);
+            sentMessages++;
+        }
+        stop = System.nanoTime();
+
+        System.out.println(""Finish sending messages..."");
+    }
+
+    private void awaitUntilAllMessagesAreReceived() throws InterruptedException {
+        int expectedMessages = 3 * numberOfMessages;
+
+        receiver.await(expectedMessages);
+    }
+
+    private void awaitUntilAllFinishes() throws Exception {
+        DataMessage dataMessage = new DataMessage();
+        dataMessage.type = DataMessage.FINISH;
+        dataMessage.data = null;
+
+        jChannel.send(null, dataMessage);
+
+        synchronized (members) {
+            if (!members.isEmpty()) {
+                members.wait();
+            }
+        }
+    }
+
+    public void printSenderInfo() {
+        System.out.println(""+++ Sender Information +++"");
+        double duration = stop - start;
+        duration /= 1000000.0; //nano to millis
+        System.out.println(""+ Duration (msec) = "" + duration);
+        System.out.println(""+ Sent Bytes      = "" + sentBytes);
+        System.out.println(""+ Sent Messages   = "" + sentMessages);
+        duration /= 1000.0; //millis to sec
+        System.out.println(""-------------------"");
+        System.out.println(""+ Sent Throughput (bytes/sec)  = "" + (sentBytes / duration));
+        System.out.println(""+ Sent Messages (messages/sec) = "" + (sentMessages / duration));
+        System.out.println(""--------------------------------"");
+    }
+
+    public void memberFinished(Address addr) {
+        synchronized (members) {
+            members.remove(addr);
+            if (members.isEmpty()) {
+                members.notify();
+            }
+        }
+    }
+
+    public void closeJChannel() {
+        System.out.println(""Close channel"");
+        jChannel.close();
+    }
+
+    public void startTest() throws Exception {
+        System.out.println(""Start testing..."");
+        createJChannel();
+        sendMessages();
+        awaitUntilAllMessagesAreReceived();
+
+        String filePath = jChannel.getAddressAsString() + OUTPUT_FILE_SUFFIX;
+        System.out.println(""Writing messages in "" + filePath);
+
+        FileWriter fileWriter = new FileWriter(filePath);
+        for (String s : receiver.getMessageList()) {
+            fileWriter.write(s);
+            fileWriter.write(""\n"");
+        }
+        fileWriter.flush();
+        fileWriter.close();
+        System.out.println(""All done!"");
+
+        awaitUntilAllFinishes();
+
+        printSenderInfo();
+        receiver.printReceiverInfo();
+        printJMXStats();
+    }
+
+    private void printJMXStats() {
+        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
+        ObjectName groupMulticast = getGroupMulticastObjectName(mBeanServer);
+
+        if (groupMulticast == null) {
+            System.err.println(""Unable to find the GROUP_MULTICAST protocol"");
+            return ;
+        }
+
+        try {
+            System.out.println(""======== JMX STATS ========="");
+            for (MBeanAttributeInfo mBeanAttributeInfo : mBeanServer.getMBeanInfo(groupMulticast).getAttributes()) {
+                String attribute = mBeanAttributeInfo.getName();
+                String type = mBeanAttributeInfo.getType();
+
+                if (!type.equals(""double"") && !type.equals(""int"")) {
+                    continue;
+                }
+
+                System.out.println(attribute + ""="" + mBeanServer.getAttribute(groupMulticast, attribute));
+            }
+            System.out.println(""======== JMX STATS ========="");
+        } catch (Exception e) {
+            System.err.println(""Error collecting stats"" + e.getLocalizedMessage());
+        }
+    }
+
+    private ObjectName getGroupMulticastObjectName(MBeanServer mBeanServer) {
+        for(ObjectName name : mBeanServer.queryNames(null, null)) {
+            if(name.getDomain().equals(JMX_DOMAIN)) {
+                if (""GROUP_MULTICAST"".equals(name.getKeyProperty(""protocol""))) {
+                    return name;
+                }
+            }
+        }
+        return null;
+    }
+}",2012-03-23T12:18:00Z,172
"@@ -705,12 +705,13 @@ protected boolean _startFlush(final View new_view, int maxAttempts, long randomF
             if(validView && flushProtocolInStack) {
                 int attemptCount = 0;
                 while (attemptCount < maxAttempts) {
+                    if (attemptCount > 0)
+                        Util.sleepRandom(randomFloor, randomCeiling);
                     try {
                         up_prot.up(new Event(Event.SUSPEND, new ArrayList<Address>(new_view.getMembers())));
                         successfulFlush = true;
                         break;
                     } catch (Exception e) {
-                        Util.sleepRandom(randomFloor, randomCeiling);
                         attemptCount++;
                     }
                 }
@@ -1396,4 +1397,4 @@ private void process(List<Request> requests) {
     }
 
 
-}
\ No newline at end of file
+}",2012-02-19T15:43:23Z,74
"@@ -2,7 +2,6 @@
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
-import java.io.Externalizable;
 import java.io.IOException;
 import java.io.NotSerializableException;
 import java.io.Serializable;
@@ -26,7 +25,6 @@
 
 import org.jgroups.JChannel;
 import org.jgroups.protocols.Executing;
-import org.jgroups.protocols.Locking;
 import org.jgroups.util.FutureListener;
 import org.jgroups.util.NotifyingFuture;
 import org.jgroups.util.Streamable;
@@ -42,9 +40,9 @@
  * can then be used as a workflow to submit other tasks sequentially or also to
  * query the future for the value at that time. 
  * <p>
- * Every callable or runnable submitted must be either {@link Serializable}, 
- * {@link Externalizable}, or {@link Streamable}.  Also the value returned from
- * a callable must {@link Serializable}, {@link Externalizable}, or 
+ * Every callable or runnable submitted must be either {@link Serializable} or 
+ * {@link Streamable}.  Also the value returned from
+ * a callable must {@link Serializable} or 
  * {@link Streamable}.  Unfortunately if the value returned is not serializable
  * then a {@link NotSerializableException} will be thrown as the cause. 
  * @author wburns
@@ -283,18 +281,6 @@ public void run() {
             sync.innerRun();
         }
 
-        /**
-         * Executes the computation without setting its result, and then
-         * resets this Future to initial state, failing to do so if the
-         * computation encounters an exception or is cancelled.  This is
-         * designed for use with tasks that intrinsically execute more
-         * than once.
-         * @return true if successfully run and reset
-         */
-        protected boolean runAndReset() {
-            return sync.innerRunAndReset();
-        }
-
         /**
          * Synchronization control for FutureTask. Note that this must be
          * a non-static inner class in order to invoke the protected
@@ -598,7 +584,7 @@ public void execute(Runnable command) {
             }
             else {
                 throw new IllegalArgumentException(
-                    ""Command was not Serializable, Externalizable, or Streamable - ""
+                    ""Command was not Serializable or Streamable - ""
                             + serializeCheck);
             }
         }",2011-03-22T02:46:19Z,173
"@@ -72,6 +72,8 @@ public void handleView(View view) {
             if(log.isDebugEnabled())
                 log.debug(""local_addr="" + local_addr + "", coord="" + coord + "", is_coord="" + is_coord);
         }
+        
+        // TODO: need to send consumer/task queue to the new coordinator if they went down
 
         if(num_backups > 0) {
             if (is_coord) {
@@ -115,21 +117,21 @@ else if (backup.equals(local_addr)) {
         }
     }
 
-    protected void updateBackups(Type type, Object obj) {
+    protected void updateBackups(Type type, Owner obj) {
         synchronized(backups) {
             for(Address backup: backups)
-                sendRequest(backup, type, (short)-1, obj);
+                sendRequest(backup, type, obj.getRequestId(), obj.getAddress());
         }
     }
     
     protected void copyQueueTo(List<Address> new_joiners) {
-        Set<Address> copyRequests;
-        Set<Address> copyConsumers;
+        Set<Owner> copyRequests;
+        Set<Owner> copyConsumers;
         
         _consumerLock.lock();
         try {
-            copyRequests = new HashSet<Address>(_runRequests);
-            copyConsumers = new HashSet<Address>(_consumersAvailable);
+            copyRequests = new HashSet<Owner>(_runRequests);
+            copyConsumers = new HashSet<Owner>(_consumersAvailable);
         }
         finally {
             _consumerLock.unlock();
@@ -138,12 +140,14 @@ protected void copyQueueTo(List<Address> new_joiners) {
         if(log.isTraceEnabled())
             log.trace(""copying queue to "" + new_joiners);
         for(Address joiner: new_joiners) {
-            for(Address address: copyRequests) {
-                sendRequest(joiner, Type.CREATE_RUN_REQUEST, (short)-1, address);
+            for(Owner address: copyRequests) {
+                sendRequest(joiner, Type.CREATE_RUN_REQUEST, 
+                    address.getRequestId(), address.getAddress());
             }
             
-            for(Address address: copyConsumers) {
-                sendRequest(joiner, Type.CREATE_CONSUMER_READY, (short)-1, address);
+            for(Owner address: copyConsumers) {
+                sendRequest(joiner, Type.CREATE_CONSUMER_READY, 
+                    address.getRequestId(), address.getAddress());
             }
         }
     }
@@ -156,28 +160,28 @@ protected void sendToCoordinator(Type type, Object value) {
 
     // @see org.jgroups.protocols.Executing#sendNewRunRequest(org.jgroups.Address)
     @Override
-    protected void sendNewRunRequest(Address sender) {
+    protected void sendNewRunRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.CREATE_RUN_REQUEST, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendRemoveRunRequest(org.jgroups.Address)
     @Override
-    protected void sendRemoveRunRequest(Address sender) {
+    protected void sendRemoveRunRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.DELETE_RUN_REQUEST, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendNewConsumerRequest(org.jgroups.Address)
     @Override
-    protected void sendNewConsumerRequest(Address sender) {
+    protected void sendNewConsumerRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.CREATE_CONSUMER_READY, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendRemoveConsumerRequest(org.jgroups.Address)
     @Override
-    protected void sendRemoveConsumerRequest(Address sender) {
+    protected void sendRemoveConsumerRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.DELETE_CONSUMER_READY, sender);
     }",2011-03-22T02:46:19Z,174
"@@ -29,7 +29,7 @@
 import java.util.concurrent.RunnableFuture;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
@@ -112,14 +112,14 @@ abstract public class Executing extends Protocol {
      * addresses that currently want to run something.  If this queue has
      * elements the consumer queue must be empty.
      */
-    protected Queue<Address> _runRequests = new ArrayDeque<Address>();
+    protected Queue<Owner> _runRequests = new ArrayDeque<Owner>();
     
     /**
      * This is stored on the coordinator side.  This queue holds all of the
      * addresses that currently are able to run something.  If this queue has
      * elements the run request queue must be empty.
      */
-    protected Queue<Address> _consumersAvailable = new ArrayDeque<Address>();
+    protected Queue<Owner> _consumersAvailable = new ArrayDeque<Owner>();
 
     protected static enum Type {
         RUN_REQUEST,            // request to coordinator from client to tell of a new task request
@@ -173,10 +173,17 @@ public Object down(Event evt) {
             case ExecutorEvent.TASK_SUBMIT:
                 Runnable runnable = (Runnable)evt.getArg();
                 _awaitingConsumer.add(runnable);
-                sendToCoordinator(Type.RUN_REQUEST, local_addr);
+                // We are limited to a number of concurrent request id's
+                // equal to 2^63-1.  This is quite large and if it 
+                // overflows it will still be positive
+                long requestId = Math.abs(counter.getAndIncrement());
+                sendToCoordinator(Type.RUN_REQUEST, new Owner(local_addr, 
+                    requestId));
                 break;
             case ExecutorEvent.CONSUMER_READY:
-                sendToCoordinator(Type.CONSUMER_READY, local_addr);
+                Owner owner = new Owner(local_addr, 
+                    Thread.currentThread().getId());
+                sendToCoordinator(Type.CONSUMER_READY, owner);
                 try {
                     // Unfortunately we can't start taking before we send
                     // a message, therefore we have to do a timed poll on
@@ -186,7 +193,7 @@ public Object down(Event evt) {
                     return runnable;
                 }
                 catch (InterruptedException e) {
-                    sendToCoordinator(Type.CONSUMER_UNREADY, local_addr);
+                    sendToCoordinator(Type.CONSUMER_UNREADY, owner);
                     Thread.currentThread().interrupt();
                 }
                 break;
@@ -201,7 +208,7 @@ public Object down(Event evt) {
                 else {
                     runnable = (Runnable)arg;
                 }
-                Owner owner = _running.remove(runnable);
+                owner = _running.remove(runnable);
                 // This won't remove anything if owner doesn't come back
                 _runnableThreads.remove(runnable);
 
@@ -378,18 +385,18 @@ public Object up(Event evt) {
                     log.trace(""["" + local_addr + ""] <-- ["" + msg.getSrc() + ""] "" + req);
                 switch(req.type) {
                     case RUN_REQUEST:
-                        handleTaskRequest((Address)req.object);
+                        handleTaskRequest((Owner)req.object);
                         break;
                     case CONSUMER_READY:
-                        handleConsumerReadyRequest((Address)req.object);
+                        handleConsumerReadyRequest((Owner)req.object);
                         break;
                     case CONSUMER_UNREADY:
-                        Address consumer = (Address)req.object;
+                        Owner consumer = (Owner)req.object;
                         _consumersAvailable.remove(consumer);
                         sendRemoveConsumerRequest(consumer);
                         break;
                     case CONSUMER_FOUND:
-                        handleConsumerFoundResponse((Address)req.object);
+                        handleConsumerFoundResponse(req);
                         break;
                     case RUN_SUBMITTED:
                         Object objectToRun = req.object;
@@ -424,16 +431,20 @@ else if (objectToRun instanceof Callable) {
                         handleInterruptRequest(msg.getSrc(), req.request);
                         break;
                     case CREATE_CONSUMER_READY:
-                        handleNewConsumer((Address)req.object);
+                        Owner owner = new Owner((Address)req.object, req.request);
+                        handleNewConsumer(owner);
                         break;
                     case CREATE_RUN_REQUEST:
-                        handleNewRunRequest((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleNewRunRequest(owner);
                         break;
                     case DELETE_CONSUMER_READY:
-                        handleRemoveConsumer((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleRemoveConsumer(owner);
                         break;
                     case DELETE_RUN_REQUEST:
-                        handleRemoveRunRequest((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleRemoveRunRequest(owner);
                         break;
                     default:
                         log.error(""Request of type "" + req.type + "" not known"");
@@ -456,9 +467,9 @@ protected void handleView(View view) {
         
         _consumerLock.lock();
         try {
-            Iterator<Address> iterator = _consumersAvailable.iterator();
+            Iterator<Owner> iterator = _consumersAvailable.iterator();
             while (iterator.hasNext()) {
-                Address address = iterator.next();
+                Owner address = iterator.next();
                 if (!members.contains(address)) {
                     iterator.remove();
                     sendRemoveConsumerRequest(address);
@@ -467,7 +478,7 @@ protected void handleView(View view) {
             
             iterator = _runRequests.iterator();
             while (iterator.hasNext()) {
-                Address address = iterator.next();
+                Owner address = iterator.next();
                 if (!members.contains(address)) {
                     iterator.remove();
                     sendRemoveRunRequest(address);
@@ -490,13 +501,13 @@ protected void handleView(View view) {
     }
 
     abstract protected void sendToCoordinator(Type type, Object obj);
-    abstract protected void sendNewRunRequest(Address source);
-    abstract protected void sendRemoveRunRequest(Address source);
-    abstract protected void sendNewConsumerRequest(Address source);
-    abstract protected void sendRemoveConsumerRequest(Address source);
+    abstract protected void sendNewRunRequest(Owner source);
+    abstract protected void sendRemoveRunRequest(Owner source);
+    abstract protected void sendNewConsumerRequest(Owner source);
+    abstract protected void sendRemoveConsumerRequest(Owner source);
 
-    protected void handleTaskRequest(Address source) {
-        Address consumer;
+    protected void handleTaskRequest(Owner source) {
+        Owner consumer;
         _consumerLock.lock();
         try {
             consumer = _consumersAvailable.poll();
@@ -509,16 +520,17 @@ protected void handleTaskRequest(Address source) {
         }
         
         if (consumer != null) {
-            sendRequest(source, Type.CONSUMER_FOUND, (short)-1, consumer);
+            sendRequest(source.getAddress(), Type.CONSUMER_FOUND, 
+                consumer.getRequestId(), consumer.getAddress());
             sendRemoveConsumerRequest(consumer);
         }
         else {
             sendNewRunRequest(source);
         }
     }
 
-    protected void handleConsumerReadyRequest(Address source) {
-        Address requestor;
+    protected void handleConsumerReadyRequest(Owner source) {
+        Owner requestor;
         _consumerLock.lock();
         try {
             requestor = _runRequests.poll();
@@ -531,42 +543,43 @@ protected void handleConsumerReadyRequest(Address source) {
         }
         
         if (requestor != null) {
-            sendRequest(requestor, Type.CONSUMER_FOUND, (short)-1, source);
+            sendRequest(requestor.getAddress(), Type.CONSUMER_FOUND, 
+                source.getRequestId(), source.getAddress());
             sendRemoveRunRequest(requestor);
         }
         else {
             sendNewConsumerRequest(source);
         }
     }
 
-    protected void handleConsumerFoundResponse(Address consumer) {
+    protected void handleConsumerFoundResponse(Request request) {
         Runnable runnable = _awaitingConsumer.poll();
+        // This is a representation of the server side owner running our task.
+        Owner owner = new Owner((Address)request.object, 
+            request.request);
         if (runnable == null) {
             // For some reason we don't have a runnable anymore
             // so we have to send back to the coordinator that
             // the consumer is still available.  The runnable
             // would be removed on a cancel
-            sendToCoordinator(Type.CONSUMER_READY, consumer);
+            sendToCoordinator(Type.CONSUMER_READY, owner);
         }
         else {
-            // We are limited to a number of concurrent request id's
-            // equal to 2^15-1.  This is quite large and if it 
-            // overflows it will still be positive
-            short requestId = (short)Math.abs(counter.getAndIncrement());
-            
-            _awaitingReturn.put(new Owner(consumer, requestId), runnable);
+            _awaitingReturn.put(owner, runnable);
             if (runnable instanceof DistributedFuture) {
                 Callable<?> callable = ((DistributedFuture<?>)runnable).getCallable();
-                sendRequest(consumer, Type.RUN_SUBMITTED, requestId, callable);
+                sendRequest(owner.getAddress(), Type.RUN_SUBMITTED, 
+                    owner.getRequestId(), callable);
             }
             else {
-                sendRequest(consumer, Type.RUN_SUBMITTED, requestId, runnable);
+                sendRequest(owner.getAddress(), Type.RUN_SUBMITTED, 
+                    owner.getRequestId(), runnable);
             }
         }
     }
 
     protected void handleTaskSubmittedRequest(Runnable runnable, Address source, 
-                                              short requestId) {
+                                              long requestId) {
         // We store in our map so that when that task is
         // finished so that we can send back to the owner
         // with the results
@@ -597,7 +610,7 @@ protected void handleTaskSubmittedRequest(Runnable runnable, Address source,
         }
     }
     
-    protected void handleTaskRejectedResponse(Address source, short requestId) {
+    protected void handleTaskRejectedResponse(Address source, long requestId) {
         Runnable runnable = _awaitingReturn.remove(new Owner(
             source, requestId));
         if (runnable != null) {
@@ -643,7 +656,7 @@ protected void handleExceptionResponse(Address source, Request req) {
         }
     }
 
-    protected void handleInterruptRequest(Address source, short requestId) {
+    protected void handleInterruptRequest(Address source, long requestId) {
         Owner owner = new Owner(source, requestId);
         Runnable runnable = removeKeyForValue(_running, owner);
         if (runnable != null) {
@@ -658,7 +671,7 @@ protected void handleInterruptRequest(Address source, short requestId) {
         }
     }
 
-    protected void handleNewRunRequest(Address sender) {
+    protected void handleNewRunRequest(Owner sender) {
         _consumerLock.lock();
         try {
             _runRequests.add(sender);
@@ -668,7 +681,7 @@ protected void handleNewRunRequest(Address sender) {
         }
     }
 
-    protected void handleRemoveRunRequest(Address sender) {
+    protected void handleRemoveRunRequest(Owner sender) {
         _consumerLock.lock();
         try {
             _runRequests.remove(sender);
@@ -678,7 +691,7 @@ protected void handleRemoveRunRequest(Address sender) {
         }
     }
     
-    protected void handleNewConsumer(Address sender) {
+    protected void handleNewConsumer(Owner sender) {
         _consumerLock.lock();
         try {
             _consumersAvailable.add(sender);
@@ -688,7 +701,7 @@ protected void handleNewConsumer(Address sender) {
         }
     }
 
-    protected void handleRemoveConsumer(Address sender) {
+    protected void handleRemoveConsumer(Owner sender) {
         _consumerLock.lock();
         try {
             _consumersAvailable.remove(sender);
@@ -698,7 +711,7 @@ protected void handleRemoveConsumer(Address sender) {
         }
     }
     
-    protected void sendRequest(Address dest, Type type, short requestId, Object object) {
+    protected void sendRequest(Address dest, Type type, long requestId, Object object) {
         Request req=new Request(type, object, requestId);
         Message msg=new Message(dest, null, req);
         msg.putHeader(id, new ExecutorHeader());
@@ -719,17 +732,17 @@ protected void sendRequest(Address dest, Type type, short requestId, Object obje
      * the response doesn't have to send back the future but instead the counter
      * We just let this roll over
      */
-    protected static final AtomicInteger counter = new AtomicInteger();
+    protected static final AtomicLong counter = new AtomicLong();
 
     protected static class Request implements Streamable {
         protected Type    type;
         protected Object  object;
-        protected short   request;
+        protected long   request;
         
         public Request() {
         }
 
-        public Request(Type type, Object object, short request) {
+        public Request(Type type, Object object, long request) {
             this.type=type;
             this.object=object;
             this.request=request;
@@ -755,7 +768,7 @@ public void writeTo(DataOutputStream out) throws IOException {
             catch (Exception e) {
                 throw new IOException(""Exception encountered while serializing execution request"", e);
             }
-            out.writeShort(request);
+            out.writeLong(request);
         }
 
         public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
@@ -783,7 +796,7 @@ public void readFrom(DataInputStream in) throws IOException, IllegalAccessExcept
             catch (Exception e) {
                 throw new IOException(""Exception encountered while serializing execution request"", e);
             }
-            request=in.readShort();
+            request=in.readLong();
         }
 
         public String toString() {
@@ -808,11 +821,15 @@ public void readFrom(DataInputStream in) throws IOException, IllegalAccessExcept
         }
     }
     
-    public static class Owner {
-        final protected Address address;
-        final protected short requestId;
+    public static class Owner implements Streamable {
+        protected Address address;
+        protected long requestId;
+        
+        public Owner() {
+            
+        }
 
-        public Owner(Address address, short requestId) {
+        public Owner(Address address, long requestId) {
             this.address=address;
             this.requestId=requestId;
         }
@@ -821,7 +838,7 @@ public Address getAddress() {
             return address;
         }
 
-        public short getRequestId() {
+        public long getRequestId() {
             return requestId;
         }
         
@@ -832,7 +849,7 @@ public int hashCode() {
             int result = 1;
             result = prime * result
                     + ((address == null) ? 0 : address.hashCode());
-            result = prime * result + requestId;
+            result = prime * result + (int) (requestId ^ (requestId >>> 32));
             return result;
         }
 
@@ -854,6 +871,18 @@ public boolean equals(Object obj) {
         public String toString() {
             return address + ""::"" + requestId;
         }
-    }
 
+        @Override
+        public void writeTo(DataOutputStream out) throws IOException {
+            Util.writeAddress(address, out);
+            out.writeLong(requestId);
+        }
+
+        @Override
+        public void readFrom(DataInputStream in) throws IOException,
+                IllegalAccessException, InstantiationException {
+            address=Util.readAddress(in);
+            requestId=in.readLong();
+        }
+    }
 }",2011-03-22T02:46:19Z,175
"@@ -18,7 +18,6 @@
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.Lock;
 
-import org.jgroups.Address;
 import org.jgroups.Global;
 import org.jgroups.JChannel;
 import org.jgroups.blocks.executor.ExecutionCompletionService;
@@ -95,7 +94,7 @@ public Queue<Runnable> getAwaitingConsumerQueue() {
             return _awaitingConsumer;
         }
         
-        public Queue<Address> getAvailableConsumers() {
+        public Queue<Owner> getAvailableConsumers() {
             return _consumersAvailable;
         }
         ",2011-03-22T02:46:19Z,176
