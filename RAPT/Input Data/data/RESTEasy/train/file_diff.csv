file_diff,commit_time,file_diff_id
"@@ -23,7 +23,15 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
+import javax.management.Notification;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationListener;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.client.Invocation.Builder;
@@ -41,7 +49,6 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-
 import org.junit.Assert;
 
 @RunWith(Arquillian.class)
@@ -79,11 +86,27 @@ private String generateURL(String path)
    public void testStream() throws Exception
    {
       try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
-         Builder builder = client.target(generateURL(""/test/document/abc/content"")).request();
-         //builder.get().readEntity explicitly on the same line below and not saved in any temp variable
-         //to let the JVM try finalizing the ClientResponse object
-         IOUtils.copy(builder.get().readEntity(InputStream.class), baos);
-         Assert.assertEquals(10000000, baos.size());
+          Builder builder = client.target(generateURL(""/test/document/abc/content"")).request();
+          //builder.get().readEntity explicitly on the same line below and not saved in any temp variable
+          //to let the JVM try finalizing the ClientResponse object
+          InputStream ins = builder.get().readEntity(InputStream.class);
+          //suggest jvm to do gc and wait the gc notification
+          final CountDownLatch coutDown = new CountDownLatch(1);
+          List<GarbageCollectorMXBean> gcbeans = ManagementFactory.getGarbageCollectorMXBeans();
+          for (GarbageCollectorMXBean gcbean : gcbeans) {
+              NotificationEmitter emitter = (NotificationEmitter) gcbean;
+              NotificationListener listener = new NotificationListener() {
+                  public void handleNotification(Notification notification,
+                                                 Object handback) {
+                      coutDown.countDown();
+                  }
+              };
+              emitter.addNotificationListener(listener, null, null);
+          }
+          System.gc();
+          coutDown.await(10, TimeUnit.SECONDS);
+          IOUtils.copy(ins, baos);
+          Assert.assertEquals(100000000, baos.size());
       }
    }
 ",2017-06-29T14:34:19Z,74
"@@ -15,6 +15,9 @@
 import com.fasterxml.jackson.jaxrs.json.JsonEndpointConfig;
 import com.fasterxml.jackson.jaxrs.util.ClassKey;
 
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import org.jboss.resteasy.annotations.providers.jackson.Formatted;
 import org.jboss.resteasy.annotations.providers.NoJackson;
 import org.jboss.resteasy.util.DelegatingOutputStream;
@@ -101,7 +104,7 @@ public int hashCode()
            = new ConcurrentHashMap<ClassAnnotationKey, JsonEndpointConfig>();
 
    @Override
-   public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String,String> httpHeaders, InputStream entityStream)
+   public Object readFrom(Class<Object> type, final Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String,String> httpHeaders, InputStream entityStream)
            throws IOException
    {
       LogMessages.LOGGER.debugf(""Provider : %s,  Method : readFrom"", getClass().getName());
@@ -114,8 +117,8 @@ public Object readFrom(Class<Object> type, Type genericType, Annotation[] annota
          endpoint = _configForReading(mapper, annotations, null);
          _readers.put(key, endpoint);
       }
-      ObjectReader reader = endpoint.getReader();
-      JsonParser jp = _createParser(reader, entityStream);
+      final ObjectReader reader = endpoint.getReader();
+      final JsonParser jp = _createParser(reader, entityStream);
       // If null is returned, considered to be empty stream
       if (jp == null || jp.nextToken() == null) {
          return null;
@@ -124,7 +127,23 @@ public Object readFrom(Class<Object> type, Type genericType, Annotation[] annota
       if (((Class<?>) type) == JsonParser.class) {
          return jp;
       }
-      return reader.withType(genericType).readValue(jp);
+
+      Object result = null;
+      try {
+         if (System.getSecurityManager() == null) {
+            result = reader.withType(genericType).readValue(jp);
+         } else {
+            result = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+               @Override
+               public Object run() throws Exception {
+                  return reader.withType(genericType).readValue(jp);
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+         throw new IOException(pae);
+      }
+      return result;
    }
 
    protected final ConcurrentHashMap<ClassAnnotationKey, JsonEndpointConfig> _writers
@@ -173,7 +192,7 @@ public void flush() throws IOException {
       *   HTTP headers?
       */
       JsonEncoding enc = findEncoding(mediaType, httpHeaders);
-      JsonGenerator jg = writer.getFactory().createGenerator(entityStream, enc);
+      final JsonGenerator jg = writer.getFactory().createGenerator(entityStream, enc);
       jg.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);
 
       try {
@@ -214,9 +233,25 @@ public void flush() throws IOException {
          value = endpoint.modifyBeforeWrite(value);
          ObjectWriterModifier mod = ObjectWriterInjector.getAndClear();
          if (mod != null) {
-             writer = mod.modify(endpoint, httpHeaders, value, writer, jg);
+            writer = mod.modify(endpoint, httpHeaders, value, writer, jg);
+         }
+
+         if (System.getSecurityManager() == null) {
+            writer.writeValue(jg, value);
+         } else {
+            final ObjectWriter smWriter = writer;
+            final Object smValue = value;
+            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+               @Override
+               public Object run() throws Exception {
+
+                  smWriter.writeValue(jg, smValue);
+                  return null;
+               }
+            });
          }
-         writer.writeValue(jg, value);
+      } catch(PrivilegedActionException pae) {
+         throw new IOException(pae);
       } finally {
          jg.close();
       }",2017-07-20T21:17:42Z,75
"@@ -1,5 +1,8 @@
 package org.jboss.resteasy.plugins.providers.jaxb;
 
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Collections;
 import javax.ws.rs.core.Context;
 import javax.ws.rs.core.MediaType;
@@ -96,7 +99,7 @@ public static String getPackageName(Class<?> type)
       return packageName;
    }
 
-   public static Class<?> findDefaultObjectFactoryClass(Class<?> type)
+   public static Class<?> findDefaultObjectFactoryClass(Class<?> type) throws PrivilegedActionException
    {
       XmlType typeAnnotation = type.getAnnotation(XmlType.class);
       if (typeAnnotation == null) return null;
@@ -106,7 +109,29 @@ public static Class<?> findDefaultObjectFactoryClass(Class<?> type)
       Class<?> factoryClass = null;
       try
       {
-         factoryClass = Thread.currentThread().getContextClassLoader().loadClass(b.toString());
+         if (System.getSecurityManager() == null)
+         {
+            factoryClass = Thread.currentThread().getContextClassLoader().loadClass(b.toString());
+         }
+         else
+         {
+            final String  smB = b.toString();
+            factoryClass = AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>()
+            {
+               @Override
+               public Class<?> run() throws Exception
+               {
+                  return Thread.currentThread().getContextClassLoader().loadClass(smB);
+               }
+            });
+         }
+      }
+      catch (PrivilegedActionException pae) {
+         if (pae.getException() instanceof ClassNotFoundException) {
+            return null;
+         } else {
+            throw pae;
+         }
       }
       catch (ClassNotFoundException e)
       {
@@ -148,9 +173,14 @@ public JAXBContext createContext(Annotation[] parameterAnnotations, Class... cla
 				if (type == null)
 					continue;
 				classes1.add(type);
-				Class<?> factory = findDefaultObjectFactoryClass(type);
-				if (factory != null)
-					classes1.add(factory);
+               try {
+                  Class<?> factory = findDefaultObjectFactoryClass(type);
+                  if (factory != null)
+                     classes1.add(factory);
+               } catch (PrivilegedActionException pae)
+               {
+                  throw new JAXBException(pae);
+               }
 			}
 		}
 		Class<?>[] classArray = classes1.toArray(new Class[classes1.size()]);",2017-07-20T21:17:42Z,76
"@@ -22,6 +22,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Constructor;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Collections;
 import java.util.Map;
 
@@ -44,14 +47,33 @@ public class JAXBContextWrapper extends JAXBContext
       try
       {
          // check to see if NamespacePrefixMapper is in classpath
-         Class namespace =  JAXBContextWrapper.class.getClassLoader().loadClass(""com.sun.xml.bind.marshaller.NamespacePrefixMapper"");
-         Class mapper =  JAXBContextWrapper.class.getClassLoader().loadClass(""org.jboss.resteasy.plugins.providers.jaxb.XmlNamespacePrefixMapper"");
+         Class mapper = null;
+
+         if (System.getSecurityManager() == null)
+         {
+            Class namespace =  JAXBContextWrapper.class.getClassLoader().loadClass(""com.sun.xml.bind.marshaller.NamespacePrefixMapper"");
+            mapper =  JAXBContextWrapper.class.getClassLoader().loadClass(""org.jboss.resteasy.plugins.providers.jaxb.XmlNamespacePrefixMapper"");
+         }
+         else
+         {
+            mapper = AccessController.doPrivileged(new PrivilegedExceptionAction<Class>() {
+               @Override public Class run() throws Exception {
+                  Class namespace =  JAXBContextWrapper.class.getClassLoader().loadClass(""com.sun.xml.bind.marshaller.NamespacePrefixMapper"");
+                   return JAXBContextWrapper.class.getClassLoader().loadClass(""org.jboss.resteasy.plugins.providers.jaxb.XmlNamespacePrefixMapper"");
+
+               }
+            });
+         }
+
          mapperConstructor = mapper.getConstructors()[0];
       }
       catch (ClassNotFoundException e)
       {
 
       }
+      catch (PrivilegedActionException pae) {
+
+      }
 
    }
 
@@ -81,11 +103,32 @@ public JAXBContextWrapper(JAXBContext wrappedContext, JAXBConfig config) throws
     * @param config
     * @throws JAXBException
     */
-   public JAXBContextWrapper(Class<?>[] classes, Map<String, Object> properties, JAXBConfig config)
+   public JAXBContextWrapper(final Class<?>[] classes, final Map<String, Object> properties, JAXBConfig config)
            throws JAXBException
    {
       processConfig(config);
-      wrappedContext = JAXBContext.newInstance(classes, properties);
+      try
+      {
+         if (System.getSecurityManager() == null)
+         {
+            wrappedContext = JAXBContext.newInstance(classes, properties);
+         }
+         else
+         {
+            wrappedContext = AccessController.doPrivileged(new PrivilegedExceptionAction<JAXBContext>()
+            {
+               @Override
+               public JAXBContext run() throws JAXBException
+               {
+                  return JAXBContext.newInstance(classes, properties);
+               }
+            });
+         }
+      }
+      catch (PrivilegedActionException paex)
+      {
+         throw new JAXBException(paex.getMessage());
+      }
    }
 
    /**",2017-07-20T21:17:42Z,77
"@@ -30,6 +30,9 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.nio.charset.StandardCharsets;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 /**
  * <p>
@@ -189,6 +192,10 @@ public static Object findObjectFactory(Class<?> type)
       {
          throw new JAXBMarshalException(e);
       }
+      catch (PrivilegedActionException pae)
+      {
+         throw new JAXBMarshalException(pae);
+      }
 
    }
 
@@ -204,8 +211,24 @@ public static JAXBElement<?> wrapInJAXBElement(Object t, Class<?> type)
    {
       try
       {
-         Object factory = findObjectFactory(type);
-         Method[] method = factory.getClass().getDeclaredMethods();
+         final Object factory = findObjectFactory(type);
+         Method[] method = new Method[0];
+         if (System.getSecurityManager() == null)
+         {
+            method = factory.getClass().getDeclaredMethods();
+         }
+         else
+         {
+            method =  AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>()
+            {
+               @Override
+               public Method[] run() throws Exception
+               {
+                  return factory.getClass().getDeclaredMethods();
+               }
+            });
+         }
+
          for (int i = 0; i < method.length; i++)
          {
             Method current = method[i];
@@ -231,5 +254,9 @@ public static JAXBElement<?> wrapInJAXBElement(Object t, Class<?> type)
       {
          throw new JAXBMarshalException(e.getCause());
       }
+      catch (PrivilegedActionException pae)
+      {
+         throw new JAXBMarshalException(pae);
+      }
    }
 }",2017-07-20T21:17:42Z,78
"@@ -4,6 +4,9 @@
 import java.io.InputStream;
 import java.io.Reader;
 import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBElement;
@@ -160,8 +163,21 @@ public Object unmarshal(InputSource source) throws JAXBException
           SAXParser sp = spf.newSAXParser();
           configParser(sp);
           XMLReader xmlReader = sp.getXMLReader();
-          SAXSource saxSource = new SAXSource(xmlReader, source);
-          return delegate.unmarshal(saxSource);
+          final SAXSource saxSource = new SAXSource(xmlReader, source);
+          if (System.getSecurityManager() == null) {
+             return delegate.unmarshal(saxSource);
+          }
+          else
+          {
+            return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>()
+            {
+               @Override
+               public Object run() throws JAXBException
+               {
+                  return delegate.unmarshal(saxSource);
+               }
+            });
+          }
       }
       catch (SAXException e)
       {
@@ -171,6 +187,10 @@ public Object unmarshal(InputSource source) throws JAXBException
       {
          throw new JAXBException(e);
       }
+      catch (PrivilegedActionException pae)
+      {
+         throw new JAXBException(pae);
+      }
    }
 
    public Object unmarshal(Node node) throws JAXBException {",2017-07-20T21:17:42Z,79
"@@ -17,6 +17,9 @@
 import javax.xml.bind.annotation.XmlTransient;
 import javax.xml.bind.annotation.XmlType;
 import java.net.URI;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -256,7 +259,27 @@ public <T> T getJAXBObject(Class<T> clazz, Class... otherPossibleClasses) throws
          ctx = JAXBContext.newInstance(classes);
       }
       if (getElement() == null) return null;
-      Object obj = ctx.createUnmarshaller().unmarshal(getElement());
+      Object obj = null;
+
+      if (System.getSecurityManager() == null) {
+         obj = ctx.createUnmarshaller().unmarshal(getElement());
+      }
+      else
+      {
+         final JAXBContext smCtx = ctx;
+         try {
+            obj = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+               @Override
+               public Object run() throws Exception {
+                  return smCtx.createUnmarshaller().unmarshal(getElement());
+               }
+            });
+         } catch (PrivilegedActionException pae)
+         {
+            throw new JAXBException(pae);
+         }
+      }
+
       if (obj instanceof JAXBElement)
       {
          jaxbObject = ((JAXBElement) obj).getValue();",2017-07-20T21:17:42Z,80
"@@ -2,6 +2,9 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -416,9 +419,24 @@ static protected String convertArrayToString(Object o)
     * Here, the ""super"" relationship is reflexive.  That is, a method
     * is a super method of itself.
     */
-   protected Method getSuperMethod(Method method, Class<?> clazz)
+   protected Method getSuperMethod(Method method, final Class<?> clazz)
    {
-      Method[] methods = clazz.getDeclaredMethods();
+      Method[] methods = new Method[0];
+      try {
+         if (System.getSecurityManager() == null) {
+            methods = clazz.getDeclaredMethods();
+         } else {
+            methods = AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>() {
+               @Override
+               public Method[] run() throws Exception {
+                  return clazz.getDeclaredMethods();
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+
+      }
+
       for (int i = 0; i < methods.length; i++)
       {
          if (overrides(method, methods[i]))
@@ -479,8 +497,22 @@ protected boolean parametersResolveToSameTypes(Method subTypeMethod, Method supe
       ResolvedType resolvedSubType = typeResolver.resolve(subTypeMethod.getDeclaringClass());
       MemberResolver memberResolver = new MemberResolver(typeResolver);
       memberResolver.setMethodFilter(new SimpleMethodFilter(subTypeMethod, superTypeMethod));
-      ResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(resolvedSubType, null, null);
-      ResolvedMethod[] resolvedMethods = typeWithMembers.getMemberMethods();
+      final ResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(resolvedSubType, null, null);
+      ResolvedMethod[] resolvedMethods = new ResolvedMethod[0];
+      try {
+         if (System.getSecurityManager() == null) {
+            resolvedMethods = typeWithMembers.getMemberMethods();
+         } else {
+            resolvedMethods = AccessController.doPrivileged(new PrivilegedExceptionAction<ResolvedMethod[]>() {
+               @Override
+               public ResolvedMethod[] run() throws Exception {
+                  return typeWithMembers.getMemberMethods();
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+
+      }
 
       // The ClassMate doc says that overridden methods are flattened to one
       // resolved method. But that is the case only for methods without any",2017-07-20T21:17:42Z,81
"@@ -30,6 +30,8 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.List;
 import java.util.Map;
 ",2017-07-20T21:17:42Z,82
"@@ -1,5 +1,8 @@
 package org.jboss.resteasy.core;
 
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import org.jboss.resteasy.core.registry.RootClassNode;
 import org.jboss.resteasy.core.registry.RootNode;
 import org.jboss.resteasy.plugins.server.resourcefactory.JndiResourceFactory;
@@ -226,7 +229,7 @@ public void addResourceFactory(ResourceFactory ref, String base, Class<?>[] clas
       // https://issues.jboss.org/browse/JBPAPP-7871
       for (Class<?> clazz : classes)
       {
-         for (Method method : clazz.getDeclaredMethods())
+         for (Method method : getDeclaredMethods(clazz))
          {
             Method _method = findAnnotatedMethod(clazz, method);
             if (_method != null && !java.lang.reflect.Modifier.isPublic(_method.getModifiers()))
@@ -238,6 +241,25 @@ public void addResourceFactory(ResourceFactory ref, String base, Class<?>[] clas
 
    }
 
+   private Method[] getDeclaredMethods(final Class<?> clazz) {
+      Method[] methodList = new Method[0];
+      try {
+         if (System.getSecurityManager() == null) {
+            methodList = clazz.getDeclaredMethods();
+         } else {
+            methodList = AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>() {
+               @Override
+               public Method[] run() throws Exception {
+                  return clazz.getDeclaredMethods();
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+
+      }
+      return methodList;
+   }
+
    @Override
    public void addResourceFactory(ResourceFactory rf, String base, ResourceClass resourceClass)
    {",2017-07-20T21:17:42Z,2
"@@ -1,5 +1,8 @@
 package org.jboss.resteasy.spi.metadata;
 
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import org.jboss.resteasy.annotations.Body;
 import org.jboss.resteasy.annotations.Form;
 import org.jboss.resteasy.annotations.Query;
@@ -889,19 +892,51 @@ protected static void processSetters(ResourceClassBuilder resourceClassBuilder,
       } while (root != null && !root.equals(Object.class));
    }
 
-   protected static void processDeclaredFields(ResourceClassBuilder resourceClassBuilder, Class<?> root)
+   protected static void processDeclaredFields(ResourceClassBuilder resourceClassBuilder, final Class<?> root)
    {
-      for (Field field : root.getDeclaredFields())
+      Field[] fieldList = new Field[0];
+      try {
+         if (System.getSecurityManager() == null) {
+            fieldList = root.getDeclaredFields();
+         } else {
+            fieldList = AccessController.doPrivileged(new PrivilegedExceptionAction<Field[]>() {
+               @Override
+               public Field[] run() throws Exception {
+                  return root.getDeclaredFields();
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+
+      }
+
+      for (Field field : fieldList)
       {
          FieldParameterBuilder builder = resourceClassBuilder.field(field).fromAnnotations();
          if (builder.field.paramType == Parameter.ParamType.MESSAGE_BODY && !field.isAnnotationPresent(Body.class)) continue;
          if (builder.field.paramType == Parameter.ParamType.UNKNOWN) continue;
          builder.buildField();
       }
    }
-   protected static void processDeclaredSetters(ResourceClassBuilder resourceClassBuilder, Class<?> root, Set<Long> visitedHashes)
+   protected static void processDeclaredSetters(ResourceClassBuilder resourceClassBuilder, final Class<?> root, Set<Long> visitedHashes)
    {
-      for (Method method : root.getDeclaredMethods())
+      Method[] methodList = new Method[0];
+      try {
+         if (System.getSecurityManager() == null) {
+            methodList = root.getDeclaredMethods();
+         } else {
+            methodList = AccessController.doPrivileged(new PrivilegedExceptionAction<Method[]>() {
+               @Override
+               public Method[] run() throws Exception {
+                  return root.getDeclaredMethods();
+               }
+            });
+         }
+      } catch (PrivilegedActionException pae) {
+
+      }
+
+      for (Method method : methodList)
       {
          if (!method.getName().startsWith(""set"")) continue;
          if (method.getParameterTypes().length != 1) continue;
@@ -971,8 +1006,4 @@ protected static void processMethod(boolean isLocator, ResourceClassBuilder reso
       }
    }
 
-
-
-
-
 }",2017-07-20T21:17:42Z,83
"@@ -93,6 +93,7 @@ public static Archive<?> createTestArchive() {
         WebArchive war = TestUtil.prepareArchive(ContextProvidersTest.class.getSimpleName());
         war.addClasses(ContextProvidersCustomer.class, ContextProvidersCustomerForm.class, ContextProvidersName.class, ContextProvidersXop.class, PortProviderUtil.class);
         war.addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+
         return TestUtil.finishContainerPrepare(war, null, ContextProvidersResource.class);
     }
 ",2017-07-20T21:17:42Z,84
"@@ -39,6 +39,7 @@ public class EmbeddedMultipartTest {
     public static Archive<?> deploy() {
         WebArchive war = TestUtil.prepareArchive(EmbeddedMultipartTest.class.getSimpleName());
         war.addClass(EmbeddedMultipartCustomer.class);
+
         return TestUtil.finishContainerPrepare(war, null, EmbeddedMultipartResource.class);
     }
 ",2017-07-20T21:17:42Z,85
"@@ -12,7 +12,6 @@
 import org.jboss.resteasy.test.providers.multipart.resource.MimeMultipartProviderCustomer;
 import org.jboss.resteasy.test.providers.multipart.resource.MimeMultipartProviderResource;
 import org.jboss.resteasy.util.HttpResponseCodes;
-import org.jboss.resteasy.utils.PermissionUtil;
 import org.jboss.resteasy.utils.PortProviderUtil;
 import org.jboss.resteasy.utils.TestUtil;
 import org.jboss.shrinkwrap.api.Archive;
@@ -34,15 +33,11 @@
 import javax.ws.rs.core.Response;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.InputStream;
-import java.io.StringWriter;
+import java.io.*;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.PropertyPermission;
 
 /**
  * @tpSubChapter Multipart provider
@@ -74,9 +69,7 @@ public static void after() throws Exception {
     @Deployment
     public static Archive<?> deploy() {
         WebArchive war = TestUtil.prepareArchive(MimeMultipartProviderTest.class.getSimpleName());
-        // Required by javax.mail
-        war.addAsManifestResource(PermissionUtil.createPermissionsXmlAsset(
-                new PropertyPermission(""*"", ""read,write"")), ""permissions.xml"");
+
         return TestUtil.finishContainerPrepare(war, null, MimeMultipartProviderResource.class, MimeMultipartProviderCustomer.class);
     }
 ",2017-07-20T21:17:42Z,86
"@@ -42,6 +42,7 @@ public static Archive<?> createTestArchive() {
                         ContextProvidersName.class, ContextProvidersXop.class)
                 .addClass(ContextProvidersTestBase.class)
                 .addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+
         return TestUtil.finishContainerPrepare(war, null, ContextProvidersResource.class);
     }
 ",2017-07-20T21:17:42Z,87
"@@ -38,6 +38,7 @@ public static Archive<?> createTestArchive() {
                 .addClasses(ContextProvidersCustomer.class, ContextProvidersCustomerForm.class, ContextProvidersName.class, ContextProvidersXop.class)
                 .addClass(ContextProvidersTestBase.class)
                 .addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+
         return TestUtil.finishContainerPrepare(war, null, ContextProvidersResource.class);
     }
 ",2017-07-20T21:17:42Z,88
"@@ -6,6 +6,7 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import javax.validation.constraints.AssertTrue;
 import javax.ws.rs.Consumes;
 import javax.ws.rs.GET;
 import javax.ws.rs.HEAD;
@@ -52,6 +53,7 @@
 public class Response4Test extends BaseResourceTest
 {
    @Path(""/"")
+   @Produces(""text/plain"")
    public static class Resource
    {
 
@@ -61,6 +63,12 @@ public void empty()
       {
       }
 
+      @GET
+      @Path(""default_head"")
+      public Response defaultHead()
+      {
+         return Response.ok("" "").build();
+      }
    }
 
 
@@ -92,6 +100,22 @@ public static void cleanup() throws Exception
       client.close();
    }
 
+   @Test
+   public void testDefaultHead()
+   {
+      // mucks up stream so create our own client.
+      //Client client = ClientBuilder.newClient();
+      Response response = client.target(generateURL(""/default_head"")).request().head();
+      Assert.assertEquals(201, response.getStatus());
+      Assert.assertNotNull(response.getMediaType());
+      System.out.println(response.getMediaType());
+      Assert.assertTrue(response.getMediaType().equals(MediaType.TEXT_PLAIN_TYPE));
+      response.close();
+      //client.close();
+
+   }
+
+
    @Test
    public void testChangeStatus()
    {",2013-05-31T21:42:40Z,89
"@@ -89,6 +89,14 @@ public Response empty()
          return Response.ok().build();
       }
 
+      @GET
+      @Produces(""text/plain"")
+      @Path(""default_head"")
+      public Response defaultHead()
+      {
+         return Response.ok(""f"").build();
+      }
+
       @HEAD
       @Path(""head"")
       public String head()
@@ -272,6 +280,19 @@ public void testHasEntity()
 
    }
 
+   @Test
+   public void testDefaultHead()
+   {
+      // mucks up stream so create our own client.
+      //Client client = ClientBuilder.newClient();
+      Response response = client.target(generateURL(""/default_head"")).request().head();
+      Assert.assertEquals(200, response.getStatus());
+      System.out.println(response.getMediaType());
+      response.close();
+      //client.close();
+
+   }
+
 
    @Test
    public void testHead()",2013-05-31T21:42:40Z,90
"@@ -233,14 +233,6 @@ public BuiltResponse invoke(HttpRequest request, HttpResponse response, Object t
       }
       uriInfo.pushCurrentResource(target);
       BuiltResponse rtn = invokeOnTarget(request, response, target);
-      if (rtn != null && request.getHttpMethod().equalsIgnoreCase(""HEAD""))
-      {
-         // STUPID TCK sending a response back with HEAD request causes unread client input stream
-         // to screw up socket state.
-         rtn.setEntity(null);
-         rtn.setEntityClass(null);
-         rtn.setGenericType(null);
-      }
       return rtn;
    }
 ",2013-05-31T21:42:40Z,2
"@@ -48,7 +48,7 @@ public static void writeNomapResponse(BuiltResponse jaxrsResponse, final HttpReq
 
       executeFilters(jaxrsResponse, request, response, providerFactory, method);
 
-      if (jaxrsResponse.getEntity() == null)
+      if (jaxrsResponse.getEntity() == null || request.getHttpMethod().equalsIgnoreCase(""HEAD""))
       {
          response.setStatus(jaxrsResponse.getStatus());
          commitHeaders(jaxrsResponse, response);",2013-05-31T21:42:40Z,91
"@@ -156,7 +156,7 @@ public Map<String, Cookie> getCookies()
    @Override
    public boolean hasEntity()
    {
-      return false;
+      return getMediaType() != null;
    }
 
    @Override",2013-05-31T21:42:40Z,1
"@@ -2360,7 +2360,12 @@ public boolean isRegistered(Object component)
    @Override
    public boolean isRegistered(Class<?> componentClass)
    {
-      return getProviderClasses().contains(componentClass);
+      if (getProviderClasses().contains(componentClass)) return true;
+      for (Object obj : getProviderInstances())
+      {
+         if (obj.getClass().equals(componentClass)) return true;
+      }
+      return false;
    }
 
    @Override",2013-05-31T21:42:40Z,25
"@@ -22,15 +22,14 @@ public class UriInfoImpl implements UriInfo
    private MultivaluedMap<String, String> encodedQueryParameters;
    private MultivaluedMap<String, String> pathParameters;
    private MultivaluedMap<String, String> encodedPathParameters;
-   private MultivaluedMap<String, PathSegment[]> pathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
-   private MultivaluedMap<String, PathSegment[]> encodedPathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
-   ;
+   private MultivaluedMap<String, PathSegment[]> pathParameterPathSegments;
+   private MultivaluedMap<String, PathSegment[]> encodedPathParameterPathSegments;
+   
    private List<PathSegment> pathSegments;
    private List<PathSegment> encodedPathSegments;
    private URI absolutePath;
    private URI absolutePathWithQueryString;
    private URI baseURI;
-   private String queryString;
    private List<String> matchedUris;
    private List<String> encodedMatchedUris;
    private List<Object> ancestors;
@@ -56,15 +55,13 @@ public UriInfoImpl(URI absolutePath, URI baseUri, String encodedPath, String que
       }
       //System.out.println(""path: "" + path);
       //System.out.println(""encodedPath: "" + encodedPath);
+
       this.absolutePath = absolutePath;
-      this.queryParameters = new MultivaluedMapImpl<String, String>();
-      this.encodedQueryParameters = new MultivaluedMapImpl<String, String>();
-      extractParameters(queryString);
-      this.encodedPathParameters = new MultivaluedMapImpl<String, String>();
-      this.pathParameters = new MultivaluedMapImpl<String, String>();
       this.encodedPathSegments = encodedPathSegments;
-      this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       this.baseURI = baseUri;
+
+      extractParameters(queryString);
+      this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       for (PathSegment segment : encodedPathSegments)
       {
          try
@@ -76,12 +73,10 @@ public UriInfoImpl(URI absolutePath, URI baseUri, String encodedPath, String que
             throw new RuntimeException(e);
          }
       }
-
-
-      this.queryString = queryString;
-
-
-      if (queryString == null) this.absolutePathWithQueryString = absolutePath;
+      if (queryString == null) 
+      {
+         this.absolutePathWithQueryString = absolutePath;
+      }
       else
       {
          this.absolutePathWithQueryString = URI.create(absolutePath.toString() + ""?"" + queryString);
@@ -144,48 +139,83 @@ public UriBuilder getBaseUriBuilder()
 
    public MultivaluedMap<String, String> getPathParameters()
    {
+      if( pathParameters == null )
+      {
+         pathParameters = new MultivaluedMapImpl<String, String>();
+      }
       return pathParameters;
    }
 
    public void addEncodedPathParameter(String name, String value)
    {
-      encodedPathParameters.add(name, value);
+      getEncodedPathParameters().add(name, value);
       try
       {
          String value1 = URLDecoder.decode(value, ""UTF-8"");
-         pathParameters.add(name, value1);
+         getPathParameters().add(name, value1);
       }
       catch (UnsupportedEncodingException e)
       {
          throw new RuntimeException(e);
       }
    }
 
+   private MultivaluedMap<String, String> getEncodedPathParameters()
+   {
+      if (encodedPathParameters == null)
+      {
+         encodedPathParameters = new MultivaluedMapImpl<String, String>();
+      }
+      return encodedPathParameters;
+   }
+
    public MultivaluedMap<String, PathSegment[]> getEncodedPathParameterPathSegments()
    {
+      if( encodedPathParameterPathSegments == null)
+      {
+         encodedPathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
+      }
       return encodedPathParameterPathSegments;
    }
 
    public MultivaluedMap<String, PathSegment[]> getPathParameterPathSegments()
    {
+      if( pathParameterPathSegments == null)
+      {
+         pathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
+      }
       return pathParameterPathSegments;
    }
 
    public MultivaluedMap<String, String> getPathParameters(boolean decode)
    {
       if (decode) return getPathParameters();
-      return encodedPathParameters;
+      return getEncodedPathParameters();
    }
 
    public MultivaluedMap<String, String> getQueryParameters()
    {
+      if( queryParameters == null)
+      {
+         queryParameters = new MultivaluedMapImpl<String, String>();
+      }
       return queryParameters;
    }
 
+   protected MultivaluedMap<String, String> getEncodedQueryParameters()
+   {
+      if( encodedQueryParameters == null )
+      {
+         this.encodedQueryParameters = new MultivaluedMapImpl<String, String>();
+      }
+      return encodedQueryParameters;
+   }
+   
+   
    public MultivaluedMap<String, String> getQueryParameters(boolean decode)
    {
-      if (decode) return queryParameters;
-      else return encodedQueryParameters;
+      if (decode) return getQueryParameters();
+      else return getEncodedQueryParameters();
    }
 
    protected void extractParameters(String queryString)
@@ -203,8 +233,8 @@ protected void extractParameters(String queryString)
             {
                String name = URLDecoder.decode(nv[0], ""UTF-8"");
                String val = nv.length > 1 ? nv[1] : """";
-               encodedQueryParameters.add(name, val);
-               queryParameters.add(name, URLDecoder.decode(val, ""UTF-8""));
+               getEncodedQueryParameters().add(name, val);
+               getQueryParameters().add(name, URLDecoder.decode(val, ""UTF-8""));
             }
             catch (UnsupportedEncodingException e)
             {
@@ -216,8 +246,8 @@ protected void extractParameters(String queryString)
             try
             {
                String name = URLDecoder.decode(param, ""UTF-8"");
-               encodedQueryParameters.add(name, """");
-               queryParameters.add(name, """");
+               getEncodedQueryParameters().add(name, """");
+               getQueryParameters().add(name, """");
             }
             catch (UnsupportedEncodingException e)
             {",2010-01-19T02:35:19Z,4
"@@ -0,0 +1,470 @@
+package org.jboss.resteasy.test.nextgen.resource;
+
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
+import org.jboss.resteasy.core.Dispatcher;
+import org.jboss.resteasy.plugins.delegates.LocaleDelegate;
+import org.jboss.resteasy.test.BaseResourceTest;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.DELETE;
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.EntityTag;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Request;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Variant;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import static org.jboss.resteasy.test.TestPortProvider.*;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class VariantsTest extends BaseResourceTest
+{
+   static Client client;
+
+   @BeforeClass
+   public static void setup() throws Exception
+   {
+      addPerRequestResource(LanguageVariantResource.class);
+      addPerRequestResource(ComplexVariantResource.class);
+      addPerRequestResource(EncodingVariantResource.class);
+      client = ClientBuilder.newClient();
+   }
+
+   @AfterClass
+   public static void cleanup() throws Exception
+   {
+      client.close();
+   }
+
+   @Path(""/"")
+   public static class LanguageVariantResource
+   {
+      @GET
+      public Response doGet(@Context Request r)
+      {
+         List<Variant> vs = Variant.VariantListBuilder.newInstance().languages(new Locale(""zh"")).languages(
+                 new Locale(""fr"")).languages(new Locale(""en"")).add().build();
+
+         Variant v = r.selectVariant(vs);
+         if (v == null)
+            return Response.notAcceptable(vs).build();
+         else
+            return Response.ok(v.getLanguage(), v).build();
+      }
+      @Path(""/brazil"")
+      @GET
+      public Response doGetBrazil(@Context Request r)
+      {
+         List<Variant> vs = Variant.VariantListBuilder.newInstance().languages(new Locale(""pt"", ""BR"")).add().build();
+
+         Variant v = r.selectVariant(vs);
+         if (v == null)
+            return Response.notAcceptable(vs).build();
+         else
+            return Response.ok(v.getLanguage(), v).build();
+      }
+
+      @GET
+      @Path(""/SelectVariantTestResponse"")
+      public Response selectVariantTestResponse(@Context Request req) {
+         List<Variant> list = Variant.encodings(""CP1250"", ""UTF-8"")
+                 .languages(Locale.ENGLISH)
+                 .mediaTypes(MediaType.APPLICATION_JSON_TYPE).add().build();
+         Variant selectedVariant = req.selectVariant(list);
+         if (null == selectedVariant)
+            return Response.notAcceptable(list).build();
+         return Response.ok(""entity"").build();
+      }
+
+      @GET
+      @Path(""/SelectVariantTestGet"")
+      public Response selectVariantTestGet(@Context Request req) {
+         List<Variant> vs = null;
+
+         try {
+            req.selectVariant(vs);
+            return Response.ok(""Test FAILED - no exception thrown"").build();
+         } catch (IllegalArgumentException ile) {
+            return Response.ok(""PASSED"")
+                    .build();
+         } catch (Throwable th) {
+            th.printStackTrace();
+            return Response.ok(
+                    ""Test FAILED - wrong type exception thrown"" +
+                            th.getMessage()).build();
+         }
+      }
+
+      @PUT
+      @Path(""/SelectVariantTestPut"")
+      public Response selectVariantTestPut(@Context Request req) {
+         return selectVariantTestGet(req);
+      }
+
+      @POST
+      @Path(""/SelectVariantTestPost"")
+      public Response selectVariantTestPost(@Context Request req) {
+         return selectVariantTestGet(req);
+      }
+
+      @DELETE
+      @Path(""/SelectVariantTestDelete"")
+      public Response selectVariantTestDelete(@Context Request req) {
+         return selectVariantTestGet(req);
+      }
+
+      @GET
+      @Path(""/preconditionsSimpleGet"")
+      public Response evaluatePreconditionsEntityTagGetSimpleTest(
+              @Context Request req) {
+         boolean ok = evaluatePreconditionsEntityTag(req, ""AAA"");
+         if (!ok)
+            return Response.status(Response.Status.GONE).build();
+         ok &= evaluatePreconditionsNowEntityTagNull(req);
+         if (!ok)
+            return Response.status(Response.Status.NOT_ACCEPTABLE).build();
+         ok &= evaluatePreconditionsEntityTagNull(req);
+         return createResponse(ok);
+      }
+      private static boolean evaluatePreconditionsEntityTagNull(Request req) {
+         try {
+            req.evaluatePreconditions((EntityTag) null);
+            return false;
+         } catch (IllegalArgumentException iae) {
+            return true;
+         }
+      }
+
+      private static boolean evaluatePreconditionsNowEntityTagNull(Request req) {
+         try {
+            Date now = Calendar.getInstance().getTime();
+            req.evaluatePreconditions(now, (EntityTag) null);
+            return false;
+         } catch (IllegalArgumentException iae) {
+            return true;
+         }
+      }
+
+      private static EntityTag createTag(String tag) {
+         String xtag = new StringBuilder().append(""\"""").append(tag).append(""\"""")
+                 .toString();
+         return EntityTag.valueOf(xtag);
+      }
+
+      private static boolean evaluatePreconditionsEntityTag(Request req, String tag) {
+         Response.ResponseBuilder rb = req.evaluatePreconditions(createTag(tag));
+         return rb == null;
+      }
+
+      private static Response createResponse(boolean ok) {
+         Response.Status status = ok ? Response.Status.OK : Response.Status.PRECONDITION_FAILED;
+         return Response.status(status).build();
+      }
+
+
+
+
+   }
+
+   @Test
+   public void evaluatePreconditionsTagNullAndSimpleGetTest()
+   {
+      Response response = client.target(generateURL(""/preconditionsSimpleGet"")).request()
+              .get();
+      Assert.assertEquals(200, response.getStatus());
+      response.close();
+   }
+
+
+   @Test
+   public void selectVariantPutRequestTest()
+   {
+      Response response = client.target(generateURL(""/SelectVariantTestPut"")).request()
+              .put(null);
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(""PASSED"", response.readEntity(String.class));
+      response.close();
+  }
+
+
+   @Test
+   public void selectVariantResponseVaryTest()
+   {
+      Response response = client.target(generateURL(""/SelectVariantTestResponse"")).request()
+              .accept(""application/json"").get();
+      Assert.assertEquals(200, response.getStatus());
+      List<String> headers = response.getStringHeaders().get(""Vary"");
+      Assert.assertEquals(1, headers.size());
+      String vary = headers.get(0);
+      System.out.println(vary);
+      Assert.assertTrue(vary.contains(""Accept-Language""));
+      Assert.assertTrue(vary.contains(""Accept-Encoding""));
+      Assert.assertTrue(vary.matches("".*Accept.*Accept.*Accept.*""));
+      response.close();
+   }
+
+
+   @Test
+   public void testGetLanguageEn() throws Exception
+   {
+      Response response = client.target(generateURL(""/"")).request().acceptLanguage(""en"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""en"", response.readEntity(String.class));
+      Assert.assertEquals(""en"", response.getLanguage().toString());
+      response.close();
+   }
+
+   @Test
+   public void testGetLanguageWildcard() throws Exception
+   {
+      Response response = client.target(generateURL(""/"")).request().acceptLanguage(""*"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertNotNull(response.getLanguage());
+      response.close();
+   }
+
+   @Test
+   public void testGetLanguageSubLocal() throws Exception
+   {
+      Response response = client.target(generateURL(""/brazil"")).request()
+              .acceptLanguage(""pt"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertNotNull(response.getLanguage());
+      response.close();
+   }
+
+   @Test
+   public void testGetLanguageZero() throws Exception
+   {
+      Response response = client.target(generateURL(""/"")).request()
+              .acceptLanguage(""*"", ""zh;q=0"", ""en;q=0"" ,""fr;q=0"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_NOT_ACCEPTABLE, response.getStatus());
+      response.close();
+   }
+
+   @Test
+   public void testGetLanguageZh() throws Exception
+   {
+      Response response = client.target(generateURL(""/"")).request().acceptLanguage(""zh"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""zh"", response.readEntity(String.class));
+      Assert.assertEquals(""zh"", response.getLanguage().toString());
+      response.close();
+   }
+
+   @Test
+   public void testGetLanguageMultiple() throws Exception
+   {
+      Response response = client.target(generateURL(""/"")).request()
+              .acceptLanguage(""en;q=0.3"", ""zh;q=0.4"",  ""fr"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""fr"", response.readEntity(String.class));
+      Assert.assertEquals(""fr"", response.getLanguage().toString());
+      response.close();
+   }
+
+   @Path(""/complex"")
+   public static class ComplexVariantResource
+   {
+      @GET
+      public Response doGet(@Context Request r)
+      {
+         List<Variant> vs = Variant.VariantListBuilder.newInstance().mediaTypes(MediaType.valueOf(""image/jpeg"")).add()
+                 .mediaTypes(MediaType.valueOf(""application/xml"")).languages(new Locale(""en"", ""us"")).add().mediaTypes(
+                         MediaType.valueOf(""text/xml"")).languages(new Locale(""en"")).add().mediaTypes(
+                         MediaType.valueOf(""text/xml"")).languages(new Locale(""en"", ""us"")).add().build();
+
+         Variant v = r.selectVariant(vs);
+         if (v == null)
+            return Response.notAcceptable(vs).build();
+         else
+            return Response.ok(""GET"", v).build();
+      }
+   }
+
+   @Test
+   public void testGetComplex1() throws Exception
+   {
+      Response response = client.target(generateURL(""/complex"")).request()
+            .accept(""text/xml"", ""application/xml"", ""application/xhtml+xml"", ""image/png"", ""text/html;q=0.9"", ""text/plain;q=0.8"", ""*/*;q=0.5"")
+            .acceptLanguage(""en-us"", ""en;q=0.5"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.readEntity(String.class));
+      Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
+      Assert.assertEquals(""en-us"", new LocaleDelegate().toString(response.getLanguage()));
+      response.close();
+   }
+
+   @Test
+   public void testGetComplex2() throws Exception
+   {
+      Response response = client.target(generateURL(""/complex"")).request()
+              .accept(""text/xml"", ""application/xml"", ""application/xhtml+xml"", ""image/png"", ""text/html;q=0.9"", ""text/plain;q=0.8"", ""*/*;q=0.5"")
+              .acceptLanguage(""en"", ""en-us"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.readEntity(String.class));
+      Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
+      Assert.assertEquals(""en-us"", new LocaleDelegate().toString(response.getLanguage()));
+      response.close();
+   }
+
+   @Test
+   public void testGetComplex3() throws Exception
+   {
+      Response response = client.target(generateURL(""/complex"")).request()
+              .accept(""application/xml"", ""text/xml"", ""application/xhtml+xml"", ""image/png"", ""text/html;q=0.9"", ""text/plain;q=0.8"", ""*/*;q=0.5"")
+              .acceptLanguage(""en-us"", ""en;q=0.5"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.readEntity(String.class));
+      Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
+      Assert.assertEquals(""en-us"", new LocaleDelegate().toString(response.getLanguage()));
+      response.close();
+   }
+
+   @Test
+   public void testGetComplex4() throws Exception
+   {
+      Response response = client.target(generateURL(""/complex"")).request()
+              .accept(""application/xml"", ""text/xml"", ""application/xhtml+xml"", ""image/png"", ""text/html;q=0.9"", ""text/plain;q=0.8"", ""*/*;q=0.5"")
+              .acceptLanguage(""en"",  ""en-us;q=0.5"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.readEntity(String.class));
+      Assert.assertEquals(""en"", response.getLanguage().toString());
+      Assert.assertEquals(MediaType.TEXT_XML_TYPE, response.getMediaType());
+      response.close();
+   }
+
+
+   @Test
+   public void testGetComplexNotAcceptable() throws Exception
+   {
+      {
+         Response response = client.target(generateURL(""/complex"")).request()
+                 .accept(""application/atom+xml"")
+                 .acceptLanguage(""en-us"", ""en"").get();
+         Assert.assertEquals(406, response.getStatus());;
+         String vary = response.getHeaderString(HttpHeaderNames.VARY);
+         Assert.assertNotNull(vary);
+         System.out.println(""vary: "" + vary);
+         Assert.assertTrue(contains(vary, ""Accept""));
+         Assert.assertTrue(contains(vary, ""Accept-Language""));
+         response.close();
+      }
+
+      {
+         Response response = client.target(generateURL(""/complex"")).request()
+                 .accept(""application/xml"")
+                 .acceptLanguage(""fr"").get();
+         Assert.assertEquals(406, response.getStatus());;
+         String vary = response.getHeaderString(HttpHeaderNames.VARY);
+         Assert.assertNotNull(vary);
+         System.out.println(""vary: "" + vary);
+         Assert.assertTrue(contains(vary, ""Accept""));
+         Assert.assertTrue(contains(vary, ""Accept-Language""));
+         response.close();
+      }
+   }
+
+   @Path(""/encoding"")
+   public static class EncodingVariantResource
+   {
+      @GET
+      public Response doGet(@Context Request r)
+      {
+         List<Variant> vs = Variant.VariantListBuilder.newInstance().encodings(""enc1"", ""enc2"", ""enc3"").add().build();
+         Variant v = r.selectVariant(vs);
+         if (v == null)
+            return Response.notAcceptable(vs).build();
+         else
+            return Response.ok(v.getEncoding(), v).build();
+      }
+   }
+
+   @Test
+   public void testGetEncoding1() throws Exception
+   {
+      Response response = client.target(generateURL(""/encoding"")).request()
+              .acceptEncoding(""enc1"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc1"", response.readEntity(String.class));
+      Assert.assertEquals(""enc1"", response.getHeaderString(HttpHeaderNames.CONTENT_ENCODING));
+      response.close();
+   }
+
+   @Test
+   public void testGetEncoding2() throws Exception
+   {
+      Response response = client.target(generateURL(""/encoding"")).request()
+              .acceptEncoding(""enc2"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc2"", response.readEntity(String.class));
+      Assert.assertEquals(""enc2"", response.getHeaderString(HttpHeaderNames.CONTENT_ENCODING));
+      response.close();
+   }
+
+   @Test
+   public void testGetEncoding3() throws Exception
+   {
+      Response response = client.target(generateURL(""/encoding"")).request()
+              .acceptEncoding(""enc3"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc3"", response.readEntity(String.class));
+      Assert.assertEquals(""enc3"", response.getHeaderString(HttpHeaderNames.CONTENT_ENCODING));
+      response.close();
+   }
+
+   @Test
+   public void testGetEncodingQ() throws Exception
+   {
+      Response response = client.target(generateURL(""/encoding"")).request()
+              .acceptEncoding(""enc1;q=0.5"", ""enc2;q=0.9"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc2"", response.readEntity(String.class));
+      Assert.assertEquals(""enc2"", response.getHeaderString(HttpHeaderNames.CONTENT_ENCODING));
+      response.close();
+   }
+
+   @Test
+   public void testGetEncodingQ2() throws Exception
+   {
+      Response response = client.target(generateURL(""/encoding"")).request()
+              .acceptEncoding(""enc1;q=0"", ""enc2;q=0.888"", ""enc3;q=0.889"").get();
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc3"", response.readEntity(String.class));
+      Assert.assertEquals(""enc3"", response.getHeaderString(HttpHeaderNames.CONTENT_ENCODING));
+      response.close();
+   }
+
+   private boolean contains(String l, String v)
+   {
+      String[] vs = l.split("","");
+      for (String s : vs)
+      {
+         s = s.trim();
+         if (s.equalsIgnoreCase(v))
+            return true;
+      }
+
+      return false;
+   }
+}",2013-05-15T18:57:50Z,92
"@@ -64,7 +64,7 @@ public Object invoke(Object o, Method method, Object[] objects) throws Throwable
          }
          catch (InvocationTargetException e)
          {
-            throw new ApplicationException(e.getCause());
+            throw e.getCause();
          }
       }
    }",2013-05-15T18:57:50Z,93
"@@ -248,7 +248,7 @@ public void pushContextObjects(final HttpRequest request, final HttpResponse res
       contextDataMap.put(HttpResponse.class, response);
       contextDataMap.put(HttpHeaders.class, request.getHttpHeaders());
       contextDataMap.put(UriInfo.class, request.getUri());
-      contextDataMap.put(Request.class, new RequestImpl(request));
+      contextDataMap.put(Request.class, new RequestImpl(request, response));
       contextDataMap.put(ResteasyAsynchronousContext.class, request.getAsyncContext());
       ResourceContext resourceContext = new ResourceContext()
       {",2013-05-15T18:57:50Z,94
"@@ -2,6 +2,7 @@
 
 import org.jboss.resteasy.core.request.ServerDrivenNegotiation;
 import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
 import org.jboss.resteasy.util.DateUtil;
 import org.jboss.resteasy.util.HttpHeaderNames;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -26,12 +27,14 @@ public class RequestImpl implements Request
    private String varyHeader;
    private String httpMethod;
    private HttpRequest request;
+   private HttpResponse response;
 
-   public RequestImpl(HttpRequest request)
+   public RequestImpl(HttpRequest request, HttpResponse response)
    {
       this.headers = request.getHttpHeaders();
       this.httpMethod = request.getHttpMethod().toUpperCase();
       this.request = request;
+      this.response = response;
    }
 
    public String getMethod()
@@ -58,6 +61,7 @@ public Variant selectVariant(List<Variant> variants) throws IllegalArgumentExcep
       negotiation.setAcceptLanguageHeaders(requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE));
 
       varyHeader = ResponseBuilderImpl.createVaryHeader(variants);
+      response.getOutputHeaders().add(HttpHeaderNames.VARY, varyHeader);
       return negotiation.getBestMatch(variants);
    }
 
@@ -117,6 +121,7 @@ public Response.ResponseBuilder ifNoneMatch(List<EntityTag> ifMatch, EntityTag e
 
    public Response.ResponseBuilder evaluatePreconditions(EntityTag eTag)
    {
+      if (eTag == null) throw new IllegalArgumentException(""eTag param null"");
       Response.ResponseBuilder builder = null;
       List<String> ifMatch = headers.getRequestHeaders().get(HttpHeaderNames.IF_MATCH);
       if (ifMatch != null && ifMatch.size() > 0)
@@ -165,6 +170,7 @@ public Response.ResponseBuilder ifUnmodifiedSince(String strDate, Date lastModif
 
    public Response.ResponseBuilder evaluatePreconditions(Date lastModified)
    {
+      if (lastModified == null) throw new IllegalArgumentException(""lastModified param null"");
       Response.ResponseBuilder builder = null;
       String ifModifiedSince = headers.getRequestHeaders().getFirst(HttpHeaderNames.IF_MODIFIED_SINCE);
       if (ifModifiedSince != null)
@@ -187,6 +193,8 @@ public Response.ResponseBuilder evaluatePreconditions(Date lastModified)
 
    public Response.ResponseBuilder evaluatePreconditions(Date lastModified, EntityTag eTag)
    {
+      if (lastModified == null) throw new IllegalArgumentException(""lastModified param null"");
+      if (eTag == null) throw new IllegalArgumentException(""eTag param null"");
       Response.ResponseBuilder rtn = null;
       Response.ResponseBuilder lastModifiedBuilder = evaluatePreconditions(lastModified);
       Response.ResponseBuilder etagBuilder = evaluatePreconditions(eTag);",2013-05-15T18:57:50Z,57
"@@ -12,7 +12,6 @@ org.jboss.resteasy.plugins.providers.IIOImageProvider
 org.jboss.resteasy.plugins.providers.SerializableProvider
 org.jboss.resteasy.plugins.interceptors.CacheControlFeature
 org.jboss.resteasy.plugins.interceptors.encoding.AcceptEncodingGZIPInterceptor
-org.jboss.resteasy.plugins.interceptors.encoding.AcceptEncodingGZIPFilter
 org.jboss.resteasy.plugins.interceptors.encoding.ClientContentEncodingAnnotationFeature
 org.jboss.resteasy.plugins.interceptors.encoding.GZIPDecodingInterceptor
 org.jboss.resteasy.plugins.interceptors.encoding.GZIPEncodingInterceptor",2013-05-15T18:57:50Z,95
"@@ -1,161 +0,0 @@
-
-package javax.ws.rs.core;
-
-/*
-import com.sun.localization.Localizable;
-import com.sun.localization.LocalizableMessageFactory;
-import com.sun.localization.Localizer;*/
-
-
-/**
- * Defines string formatting method for each constant in the resource file
- * 
- */
-public final class ApiMessages {
-   /*
-
-    private final static LocalizableMessageFactory messageFactory = new LocalizableMessageFactory(""javax.ws.rs.core.api"");
-    private final static Localizer localizer = new Localizer();
-
-    public static Localizable localizableILLEGAL_CONFIG_SYNTAX() {
-        return messageFactory.getMessage(""illegal.config.syntax"");
-    } */
-
-    /**
-     * Illegal configuration-file syntax.
-     * 
-     */
-    public static String ILLEGAL_CONFIG_SYNTAX() {
-        return ""Illegal config syntax""; //localizer.localize(localizableILLEGAL_CONFIG_SYNTAX());
-    }
-
-   /*
-    public static Localizable localizablePROVIDER_COULD_NOT_BE_CREATED(Object arg0, Object arg1) {
-        return messageFactory.getMessage(""provider.could.not.be.created"", arg0, arg1);
-    }  */
-
-    /**
-     * Provider {0} could not be instantiated: {1}
-     * 
-     */
-    public static String PROVIDER_COULD_NOT_BE_CREATED(Object arg0, Object arg1) {
-        return ""Provider could not be created"";//localizer.localize(localizablePROVIDER_COULD_NOT_BE_CREATED(arg0, arg1));
-    }
-
-   /*
-    public static Localizable localizableNO_BUILDER_IMPL() {
-        return messageFactory.getMessage(""no.builder.impl"");
-    } */
-
-    /**
-     * No Builder implementation found.
-     * 
-     */
-    public static String NO_BUILDER_IMPL() {
-        return ""No Builder IMPL"";//localizer.localize(localizableNO_BUILDER_IMPL());
-    }
-
-   /*
-    public static Localizable localizableCOOKIE_INVALID(Object arg0) {
-        return messageFactory.getMessage(""cookie.invalid"", arg0);
-    }*/
-
-    /**
-     * Invalid cookie: {0}
-     * 
-     */
-    public static String COOKIE_INVALID(Object arg0) {
-        return ""Cookie Invalid""; //localizer.localize(localizableCOOKIE_INVALID(arg0));
-    }
-   /*
-
-    public static Localizable localizableCACHE_CONTROL_INVALID(Object arg0) {
-        return messageFactory.getMessage(""cache.control.invalid"", arg0);
-    } */
-
-    /**
-     * Invalid cache control: {0}
-     * 
-     */
-    public static String CACHE_CONTROL_INVALID(Object arg0) {
-        return ""Cache control invalid"";//localizer.localize(localizableCACHE_CONTROL_INVALID(arg0));
-
-    }
-   /*
-    public static Localizable localizableILLEGAL_PROVIDER_CLASS_NAME(Object arg0) {
-        return messageFactory.getMessage(""illegal.provider.class.name"", arg0);
-    }*/
-
-    /**
-     * Illegal provider-class name: {0}.
-     * 
-     */
-    public static String ILLEGAL_PROVIDER_CLASS_NAME(Object arg0) {
-        return ""Illegal Provider Class Name""; //localizer.localize(localizableILLEGAL_PROVIDER_CLASS_NAME(arg0));
-    }
-
-   /*
-    public static Localizable localizableMEDIA_TYPE_CANNOT_BE_NULL() {
-        return messageFactory.getMessage(""media.type.cannot.be.null"");
-    }*/
-
-    /**
-     * mediaType parameter cannot be null.
-     * 
-     */
-    public static String MEDIA_TYPE_CANNOT_BE_NULL() {
-        return ""Media Type Cannot Be Null""; //localizer.localize(localizableMEDIA_TYPE_CANNOT_BE_NULL());
-    }
-   /*
-
-    public static Localizable localizablePROVIDER_NOT_FOUND(Object arg0) {
-        return messageFactory.getMessage(""provider.not.found"", arg0);
-    } */
-
-    /**
-     * Provider {0} not found.
-     * 
-     */
-    public static String PROVIDER_NOT_FOUND(Object arg0) {
-        return ""Provider Not Found"";//localizer.localize(localizablePROVIDER_NOT_FOUND(arg0));
-    }
-
-   /*
-    public static Localizable localizableCONTENT_CANNOT_BE_NULL() {
-        return messageFactory.getMessage(""content.cannot.be.null"");
-    }*/
-
-    /**
-     * content parameter cannot be null.
-     * 
-     */
-    public static String CONTENT_CANNOT_BE_NULL() {
-        return ""Content cannot be null"";//localizer.localize(localizableCONTENT_CANNOT_BE_NULL());
-    }
-
-   /*
-    public static Localizable localizableMEDIA_TYPE_INVALID(Object arg0) {
-        return messageFactory.getMessage(""media.type.invalid"", arg0);
-    }*/
-
-    /**
-     * Invalid media type: {0}
-     * 
-     */
-    public static String MEDIA_TYPE_INVALID(Object arg0) {
-        return ""Media type invalid""; //localizer.localize(localizableMEDIA_TYPE_INVALID(arg0));
-    }
-    /*
-    public static Localizable localizableETAG_INVALID(Object arg0) {
-        return messageFactory.getMessage(""etag.invalid"", arg0);
-    }*/
-
-    /**
-     * Invalid entity tag: {0}
-     * 
-     */
-    public static String ETAG_INVALID(Object arg0) {
-        return ""ETAG Invalid"";//localizer.localize(localizableETAG_INVALID(arg0));
-    }
-
-}",2008-03-18T01:44:44Z,96
"@@ -0,0 +1,26 @@
+package org.resteasy.plugins.delegates;
+
+import javax.ws.rs.core.EntityTag;
+import javax.ws.rs.ext.RuntimeDelegate;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class EntityTagDelegate implements RuntimeDelegate.HeaderDelegate<EntityTag>
+{
+   public EntityTag fromString(String value) throws IllegalArgumentException
+   {
+      if (value.startsWith(""W/""))
+      {
+         return new EntityTag(value.substring(2), true);
+      }
+      return new EntityTag(value);
+   }
+
+   public String toString(EntityTag value)
+   {
+      String weak = value.isWeak() ? ""W/"" : """";
+      return weak + value.getValue();
+   }
+}",2008-03-18T01:44:44Z,69
"@@ -0,0 +1,202 @@
+package org.resteasy.specimpl;
+
+import org.resteasy.util.DateUtil;
+import org.resteasy.util.HttpHeaderNames;
+import org.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.EntityTag;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Request;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Variant;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class RequestImpl implements Request
+{
+   private HttpHeaders headers;
+   private VaryHeader vary;
+   private String httpMethod;
+
+   public RequestImpl(HttpHeaders headers, VaryHeader vary, String httpMethod)
+   {
+      this.headers = headers;
+      this.vary = vary;
+      this.httpMethod = httpMethod.toUpperCase();
+   }
+
+
+   public Variant selectVariant(List<Variant> variants) throws IllegalArgumentException
+   {
+      if (variants == null || variants.size() == 0) throw new IllegalArgumentException(""Variant list must not be zero"");
+
+      List<MediaType> accepts = headers.getAcceptableMediaTypes();
+      List<String> languages = convertString(headers.getRequestHeaders().get(HttpHeaderNames.ACCEPT_LANGUAGE));
+      List<String> encodings = convertString(headers.getRequestHeaders().get(HttpHeaderNames.ACCEPT_ENCODING));
+
+
+      return null;
+   }
+
+   public static Variant pickVariant(List<Variant> variants, List<MediaType> accepts, List<String> languages, List<String> encodings)
+   {
+      VariantListBuilderImpl builder = new VariantListBuilderImpl();
+
+      if (accepts != null)
+      {
+         for (MediaType accept : accepts)
+         {
+            builder.mediaTypes(accept);
+         }
+      }
+
+      for (String language : languages) builder.languages(language);
+      for (String encoding : encodings) builder.encodings(encoding);
+
+      List<Variant> acceptVariants = builder.add().build();
+      return null;
+
+   }
+
+
+   public List<String> convertString(List<String> tags)
+   {
+      ArrayList<String> result = new ArrayList<String>();
+      if (tags == null) return result;
+      for (String tag : tags)
+      {
+         String[] split = tag.split("","");
+         for (String etag : split)
+         {
+            result.add(etag.trim());
+         }
+      }
+      return result;
+   }
+
+   public List<EntityTag> convertEtag(List<String> tags)
+   {
+      ArrayList<EntityTag> result = new ArrayList<EntityTag>();
+      for (String tag : tags)
+      {
+         String[] split = tag.split("","");
+         for (String etag : split)
+         {
+            result.add(EntityTag.parse(etag.trim()));
+         }
+      }
+      return result;
+   }
+
+   public Response.ResponseBuilder ifMatch(List<EntityTag> ifMatch, EntityTag eTag)
+   {
+      boolean match = false;
+      for (EntityTag tag : ifMatch)
+      {
+         if (tag.equals(eTag))
+         {
+            match = true;
+            break;
+         }
+      }
+      if (match) return null;
+      return Response.status(HttpResponseCodes.SC_PRECONDITION_FAILED).tag(eTag);
+
+   }
+
+   public Response.ResponseBuilder ifNoneMatch(List<EntityTag> ifMatch, EntityTag eTag)
+   {
+      boolean match = false;
+      for (EntityTag tag : ifMatch)
+      {
+         if (tag.equals(eTag))
+         {
+            match = true;
+            break;
+         }
+      }
+      if (match)
+      {
+         if (""GET"".equals(httpMethod) || ""HEAD"".equals(httpMethod))
+         {
+            return Response.notModified(eTag);
+         }
+
+         return Response.status(HttpResponseCodes.SC_PRECONDITION_FAILED).tag(eTag);
+      }
+      return null;
+   }
+
+
+   public Response.ResponseBuilder evaluatePreconditions(EntityTag eTag)
+   {
+      List<String> ifMatch = headers.getRequestHeaders().get(HttpHeaderNames.IF_MATCH);
+      if (ifMatch != null && ifMatch.size() > 0)
+      {
+         return ifMatch(convertEtag(ifMatch), eTag);
+      }
+      List<String> ifNoneMatch = headers.getRequestHeaders().get(HttpHeaderNames.IF_NONE_MATCH);
+      if (ifNoneMatch != null && ifNoneMatch.size() > 0)
+      {
+         return ifNoneMatch(convertEtag(ifMatch), eTag);
+      }
+      return null;
+   }
+
+   public Response.ResponseBuilder ifModifiedSince(String strDate, Date lastModified)
+   {
+      Date date = DateUtil.parseDate(strDate);
+
+      if (date.getTime() >= lastModified.getTime())
+      {
+         return Response.notModified();
+      }
+      return null;
+
+   }
+
+   public Response.ResponseBuilder ifUnmodifiedSince(String strDate, Date lastModified)
+   {
+      Date date = DateUtil.parseDate(strDate);
+
+      if (date.getTime() >= lastModified.getTime())
+      {
+         return null;
+      }
+      return Response.status(HttpResponseCodes.SC_PRECONDITION_FAILED).lastModified(lastModified);
+
+   }
+
+   public Response.ResponseBuilder evaluatePreconditions(Date lastModified)
+   {
+      String ifModifiedSince = headers.getRequestHeaders().getFirst(HttpHeaderNames.IF_MODIFIED_SINCE);
+      if (ifModifiedSince != null)
+      {
+         return ifModifiedSince(ifModifiedSince, lastModified);
+      }
+      String ifUnmodifiedSince = headers.getRequestHeaders().getFirst(HttpHeaderNames.IF_UNMODIFIED_SINCE);
+      if (ifUnmodifiedSince != null)
+      {
+         return ifUnmodifiedSince(ifUnmodifiedSince, lastModified);
+      }
+
+      return null;
+   }
+
+   public Response.ResponseBuilder evaluatePreconditions(Date lastModified, EntityTag eTag)
+   {
+      Response.ResponseBuilder builder = evaluatePreconditions(lastModified);
+      Response.ResponseBuilder builder2 = evaluatePreconditions(eTag);
+      if (builder == null && builder2 == null) return null;
+      if (builder != null && builder2 == null) return builder;
+      if (builder == null && builder2 != null) return builder2;
+      builder.tag(eTag);
+      return builder;
+   }
+}",2008-03-18T01:44:44Z,57
"@@ -0,0 +1,87 @@
+package org.resteasy.specimpl;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Variant;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class VariantListBuilderImpl extends Variant.VariantListBuilder
+{
+   private ArrayList<Variant> variants = new ArrayList<Variant>();
+   private ArrayList<String> currentLanguages = new ArrayList<String>();
+   private ArrayList<String> currentEncodings = new ArrayList<String>();
+   private ArrayList<MediaType> currentTypes = new ArrayList<MediaType>();
+
+   public List<Variant> build()
+   {
+      add();
+      ArrayList<Variant> copy = new ArrayList<Variant>();
+      copy.addAll(variants);
+      variants.clear();
+      currentLanguages.clear();
+      currentEncodings.clear();
+      currentTypes.clear();
+      return copy;
+   }
+
+   public Variant.VariantListBuilder add()
+   {
+      int langSize = currentLanguages.size();
+      int encodingSize = currentEncodings.size();
+      int typeSize = currentTypes.size();
+
+      int i = 0;
+
+      if (langSize == 0 && encodingSize == 0 && typeSize == 0) return this;
+
+      do
+      {
+         MediaType type = null;
+         if (i < typeSize) type = currentTypes.get(i);
+         int j = 0;
+         do
+         {
+            String encoding = null;
+            if (j < encodingSize) encoding = currentEncodings.get(j);
+            int k = 0;
+            do
+            {
+               String language = null;
+               if (k < langSize) language = currentLanguages.get(k);
+               variants.add(new Variant(type, language, encoding));
+               k++;
+            } while (k < langSize);
+            j++;
+         } while (j < encodingSize);
+         i++;
+      } while (i < typeSize);
+
+      currentLanguages.clear();
+      currentEncodings.clear();
+      currentTypes.clear();
+
+      return this;
+   }
+
+   public Variant.VariantListBuilder languages(String... languages)
+   {
+      for (String language : languages) currentLanguages.add(language);
+      return this;
+   }
+
+   public Variant.VariantListBuilder encodings(String... encodings)
+   {
+      for (String encoding : encodings) currentEncodings.add(encoding);
+      return this;
+   }
+
+   public Variant.VariantListBuilder mediaTypes(MediaType... mediaTypes)
+   {
+      for (MediaType type : mediaTypes) currentTypes.add(type);
+      return this;
+   }
+}",2008-03-18T01:44:44Z,6
"@@ -0,0 +1,54 @@
+package org.resteasy.specimpl;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class VaryHeader
+{
+   private boolean accept;
+   private boolean acceptLanguage;
+   private boolean acceptEncoding;
+
+   public void accept()
+   {
+      accept = true;
+   }
+
+   public void acceptLanguage()
+   {
+      acceptLanguage = true;
+   }
+
+   public void acceptEncoding()
+   {
+      acceptEncoding = true;
+   }
+
+   /**
+    * @return null if nothing set
+    */
+   public String vary()
+   {
+      String header = null;
+
+      if (accept)
+      {
+         if (header == null) header = ""Accept"";
+         else header += "" Accept"";
+      }
+
+      if (acceptLanguage)
+      {
+         if (header == null) header = ""Accept-Language"";
+         else header += "" Accept-Language"";
+      }
+
+      if (acceptEncoding)
+      {
+         if (header == null) header = ""Accept-Encoding"";
+         else header += "" Accept-Encoding"";
+      }
+      return header;
+   }
+}",2008-03-18T01:44:44Z,97
"@@ -2,16 +2,19 @@
 
 import org.resteasy.MediaTypeMap;
 import org.resteasy.plugins.delegates.CookieHeaderDelegate;
+import org.resteasy.plugins.delegates.EntityTagDelegate;
 import org.resteasy.plugins.delegates.MediaTypeHeaderDelegate;
 import org.resteasy.plugins.delegates.NewCookieHeaderDelegate;
 import org.resteasy.plugins.delegates.UriHeaderDelegate;
 import org.resteasy.specimpl.ResponseBuilderImpl;
 import org.resteasy.specimpl.UriBuilderImpl;
+import org.resteasy.specimpl.VariantListBuilderImpl;
 
 import javax.ws.rs.ConsumeMime;
 import javax.ws.rs.ProduceMime;
 import javax.ws.rs.core.ApplicationConfig;
 import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.EntityTag;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.NewCookie;
 import javax.ws.rs.core.Response;
@@ -64,6 +67,7 @@ public ResteasyProviderFactory()
       addHeaderDelegate(NewCookie.class, new NewCookieHeaderDelegate());
       addHeaderDelegate(Cookie.class, new CookieHeaderDelegate());
       addHeaderDelegate(URI.class, new UriHeaderDelegate());
+      addHeaderDelegate(EntityTag.class, new EntityTagDelegate());
    }
 
    public UriBuilder createUriBuilder()
@@ -78,7 +82,7 @@ public Response.ResponseBuilder createResponseBuilder()
 
    public Variant.VariantListBuilder createVariantListBuilder()
    {
-      throw new RuntimeException(""NOT IMPLEMENTED"");
+      return new VariantListBuilderImpl();
    }
 
    public <T> HeaderDelegate<T> createHeaderDelegate(Class<T> tClass)",2008-03-18T01:44:44Z,25
"@@ -0,0 +1,130 @@
+package org.resteasy.util;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Variant;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class AcceptableVariant implements Comparable<AcceptableVariant>
+{
+   private Variant variant;
+   private MediaType type;
+   private QualifiedStringHeader language;
+   private QualifiedStringHeader encoding;
+
+   public AcceptableVariant(Variant variant)
+   {
+      this.variant = variant;
+      this.type = variant.getMediaType();
+      if (variant.getLanguage() != null)
+      {
+         language = QualifiedStringHeader.parse(variant.getLanguage());
+      }
+      if (variant.getEncoding() != null)
+      {
+         encoding = QualifiedStringHeader.parse(variant.getEncoding());
+      }
+   }
+
+   public int compareTo(AcceptableVariant acceptableVariant)
+   {
+      int compare = 0;
+      if (type == acceptableVariant.type) compare = 0;
+      else if (type != null && acceptableVariant.type != null)
+         compare = MediaTypeHelper.compareWeight(type, acceptableVariant.type);
+      else if (type == null) compare = 1;
+      else if (type != null) compare = -1;
+
+      if (compare != 0) return compare;
+
+      if (language == acceptableVariant.language) compare = 0;
+      else if (language != null && acceptableVariant.language != null)
+         compare = language.compareWeight(acceptableVariant.language);
+      else if (language == null) compare = 1;
+      else if (language != null) compare = -1;
+
+
+      if (compare != 0) return compare;
+
+      if (encoding == acceptableVariant.encoding) compare = 0;
+      else if (encoding != null && acceptableVariant.encoding != null)
+         compare = encoding.compareWeight(acceptableVariant.encoding);
+      else if (encoding == null) return 1;
+      else if (encoding != null) return -1;
+
+      return 0;
+   }
+
+   public Variant getVariant()
+   {
+      return variant;
+   }
+
+   public MediaType getType()
+   {
+      return type;
+   }
+
+   public QualifiedStringHeader getLanguage()
+   {
+      return language;
+   }
+
+   public QualifiedStringHeader getEncoding()
+   {
+      return encoding;
+   }
+
+   public static List<Variant> sort(List<Variant> variants)
+   {
+      ArrayList<AcceptableVariant> acceptable = new ArrayList<AcceptableVariant>();
+      for (Variant v : variants) acceptable.add(new AcceptableVariant(v));
+      Collections.sort(acceptable);
+      List<Variant> sorted = new ArrayList<Variant>();
+      for (AcceptableVariant v : acceptable)
+      {
+         sorted.add(v.getVariant());
+      }
+      return sorted;
+   }
+
+   public static Variant pick(List<Variant> wants, List<Variant> has)
+   {
+      ArrayList<AcceptableVariant> acceptable = new ArrayList<AcceptableVariant>();
+      for (Variant v : wants) acceptable.add(new AcceptableVariant(v));
+      Collections.sort(acceptable);
+
+      ArrayList<AcceptableVariant> produces = new ArrayList<AcceptableVariant>();
+      for (Variant v : has) produces.add(new AcceptableVariant(v));
+
+      for (AcceptableVariant accept : acceptable)
+      {
+         for (AcceptableVariant produce : produces)
+         {
+            boolean match = false;
+            if (produce.getType() == null || accept.getType() == null) match = true;
+            else match = MediaTypeHelper.equivalent(produce.getType(), accept.getType());
+
+            if (!match) continue;
+
+            match = false;
+            if (produce.getLanguage() == null || accept.getLanguage() == null) match = true;
+            else match = produce.getLanguage().equals(accept.getLanguage());
+
+            if (!match) continue;
+
+            match = false;
+            if (produce.getEncoding() == null || accept.getEncoding() == null) match = true;
+            else match = produce.getEncoding().equals(accept.getEncoding());
+
+            return produce.getVariant();
+         }
+      }
+      return null;
+   }
+}",2008-03-18T01:44:44Z,45
"@@ -0,0 +1,215 @@
+package org.resteasy.util;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * A utility class for parsing and formatting HTTP dates as used in cookies and
+ * other headers.  This class handles dates as defined by RFC 2616 section
+ * 3.3.1 as well as some other common non-standard formats.
+ *
+ * @author Christopher Brown
+ * @author Michael Becke
+ */
+public class DateUtil
+{
+
+   public static class DateParseException extends RuntimeException
+   {
+      public DateParseException()
+      {
+      }
+
+      public DateParseException(String s)
+      {
+         super(s);
+      }
+
+      public DateParseException(String s, Throwable throwable)
+      {
+         super(s, throwable);
+      }
+
+      public DateParseException(Throwable throwable)
+      {
+         super(throwable);
+      }
+   }
+
+   /**
+    * Date format pattern used to parse HTTP date headers in RFC 1123 format.
+    */
+   public static final String PATTERN_RFC1123 = ""EEE, dd MMM yyyy HH:mm:ss zzz"";
+
+   /**
+    * Date format pattern used to parse HTTP date headers in RFC 1036 format.
+    */
+   public static final String PATTERN_RFC1036 = ""EEEE, dd-MMM-yy HH:mm:ss zzz"";
+
+   /**
+    * Date format pattern used to parse HTTP date headers in ANSI C
+    * <code>asctime()</code> format.
+    */
+   public static final String PATTERN_ASCTIME = ""EEE MMM d HH:mm:ss yyyy"";
+
+   private static final Collection DEFAULT_PATTERNS = Arrays.asList(
+           new String[]{PATTERN_ASCTIME, PATTERN_RFC1036, PATTERN_RFC1123});
+
+   private static final Date DEFAULT_TWO_DIGIT_YEAR_START;
+
+   static
+   {
+      Calendar calendar = Calendar.getInstance();
+      calendar.set(2000, Calendar.JANUARY, 1, 0, 0);
+      DEFAULT_TWO_DIGIT_YEAR_START = calendar.getTime();
+   }
+
+   private static final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
+
+   /**
+    * Parses a date value.  The formats used for parsing the date value are retrieved from
+    * the default http params.
+    *
+    * @param dateValue the date value to parse
+    * @return the parsed date
+    * @throws DateParseException if the value could not be parsed using any of the
+    *                            supported date formats
+    */
+   public static Date parseDate(String dateValue) throws DateParseException
+   {
+      return parseDate(dateValue, null, null);
+   }
+
+   /**
+    * Parses the date value using the given date formats.
+    *
+    * @param dateValue   the date value to parse
+    * @param dateFormats the date formats to use
+    * @return the parsed date
+    * @throws DateParseException if none of the dataFormats could parse the dateValue
+    */
+   public static Date parseDate(String dateValue, Collection dateFormats)
+           throws DateParseException
+   {
+      return parseDate(dateValue, dateFormats, null);
+   }
+
+   /**
+    * Parses the date value using the given date formats.
+    *
+    * @param dateValue   the date value to parse
+    * @param dateFormats the date formats to use
+    * @param startDate   During parsing, two digit years will be placed in the range
+    *                    <code>startDate</code> to <code>startDate + 100 years</code>. This value may
+    *                    be <code>null</code>. When <code>null</code> is given as a parameter, year
+    *                    <code>2000</code> will be used.
+    * @return the parsed date
+    * @throws DateParseException if none of the dataFormats could parse the dateValue
+    */
+   public static Date parseDate(
+           String dateValue,
+           Collection dateFormats,
+           Date startDate
+   ) throws DateParseException
+   {
+
+      if (dateValue == null)
+      {
+         throw new IllegalArgumentException(""dateValue is null"");
+      }
+      if (dateFormats == null)
+      {
+         dateFormats = DEFAULT_PATTERNS;
+      }
+      if (startDate == null)
+      {
+         startDate = DEFAULT_TWO_DIGIT_YEAR_START;
+      }
+      // trim single quotes around date if present
+      // see issue #5279
+      if (dateValue.length() > 1
+              && dateValue.startsWith(""'"")
+              && dateValue.endsWith(""'"")
+              )
+      {
+         dateValue = dateValue.substring(1, dateValue.length() - 1);
+      }
+
+      SimpleDateFormat dateParser = null;
+      Iterator formatIter = dateFormats.iterator();
+
+      while (formatIter.hasNext())
+      {
+         String format = (String) formatIter.next();
+         if (dateParser == null)
+         {
+            dateParser = new SimpleDateFormat(format, Locale.US);
+            dateParser.setTimeZone(TimeZone.getTimeZone(""GMT""));
+            dateParser.set2DigitYearStart(startDate);
+         }
+         else
+         {
+            dateParser.applyPattern(format);
+         }
+         try
+         {
+            return dateParser.parse(dateValue);
+         }
+         catch (ParseException pe)
+         {
+            // ignore this exception, we will try the next format
+         }
+      }
+
+      // we were unable to parse the date
+      throw new DateParseException(""Unable to parse the date "" + dateValue);
+   }
+
+   /**
+    * Formats the given date according to the RFC 1123 pattern.
+    *
+    * @param date The date to format.
+    * @return An RFC 1123 formatted date string.
+    * @see #PATTERN_RFC1123
+    */
+   public static String formatDate(Date date)
+   {
+      return formatDate(date, PATTERN_RFC1123);
+   }
+
+   /**
+    * Formats the given date according to the specified pattern.  The pattern
+    * must conform to that used by the {@link SimpleDateFormat simple date
+    * format} class.
+    *
+    * @param date    The date to format.
+    * @param pattern The pattern to use for formatting the date.
+    * @return A formatted date string.
+    * @throws IllegalArgumentException If the given date pattern is invalid.
+    * @see SimpleDateFormat
+    */
+   public static String formatDate(Date date, String pattern)
+   {
+      if (date == null) throw new IllegalArgumentException(""date is null"");
+      if (pattern == null) throw new IllegalArgumentException(""pattern is null"");
+
+      SimpleDateFormat formatter = new SimpleDateFormat(pattern, Locale.US);
+      formatter.setTimeZone(GMT);
+      return formatter.format(date);
+   }
+
+   /**
+    * This class should not be instantiated.
+    */
+   private DateUtil()
+   {
+   }
+
+}",2008-03-18T01:44:44Z,13
"@@ -0,0 +1,108 @@
+package org.resteasy.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class QualifiedStringHeader
+{
+   private String value;
+   private Map<String, String> parameters = new HashMap<String, String>();
+   private double q = 1.0;
+
+   protected QualifiedStringHeader()
+   {
+
+   }
+
+   public String getValue()
+   {
+      return value;
+   }
+
+   public Map<String, String> getParameters()
+   {
+      return parameters;
+   }
+
+   public double getQ()
+   {
+      return q;
+   }
+
+   public static QualifiedStringHeader parse(String value)
+   {
+      QualifiedStringHeader header = new QualifiedStringHeader();
+      int idx = value.indexOf("";"");
+      if (idx < 0)
+      {
+         header.value = value;
+         header.q = 1.0;
+      }
+      else
+      {
+         header.value = value.substring(0, idx);
+         String params = value.substring(idx + 1);
+         if (params.startsWith("";"")) params = params.substring(1);
+         String[] array = params.split("";"");
+         for (String param : array)
+         {
+            int pidx = param.indexOf(""="");
+            String name = param.substring(0, pidx);
+            String val = param.substring(pidx + 1);
+            if (name.equals(""q""))
+            {
+               header.q = Double.valueOf(val);
+            }
+            else header.parameters.put(name, val);
+         }
+      }
+      return header;
+   }
+
+   public boolean equals(Object o)
+   {
+      if (this == o) return true;
+      if (!(o instanceof QualifiedStringHeader)) return false;
+
+      QualifiedStringHeader comp = (QualifiedStringHeader) o;
+
+      if (!value.equals(comp.value)) return false;
+
+      Map<String, String> params1 = this.getParameters();
+      Map<String, String> params2 = comp.getParameters();
+
+      if (params1 == params2) return true;
+      if (params1 == null || params2 == null) return false;
+      if (params1.size() == 0 && params2.size() == 0) return true;
+      int numParams1 = params1.size();
+      if (params1.containsKey(""q"")) numParams1--;
+      int numParams2 = params2.size();
+      if (params2.containsKey(""q"")) numParams2--;
+
+      if (numParams1 != numParams2) return false;
+      if (numParams1 == 0) return true;
+
+      for (String key : params1.keySet())
+      {
+         if (key.equals(""q"")) continue;
+         String value = params1.get(key);
+         String value2 = params2.get(key);
+         if (value == value2) continue; // both null
+         if (value == null || value2 == null) return false;
+         if (value.equals(value2) == false) return false;
+      }
+      return true;
+   }
+
+   public int compareWeight(QualifiedStringHeader header)
+   {
+      if (q == header.q) return 0;
+      else if (q < header.q) return 1;
+      else return -1;
+   }
+
+}",2008-03-18T01:44:44Z,53
"@@ -0,0 +1,341 @@
+package org.resteasy.test.finegrain;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.resteasy.spi.ResteasyProviderFactory;
+import org.resteasy.util.AcceptableVariant;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Variant;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class VariantTest
+{
+   @BeforeClass
+   public static void start()
+   {
+      ResteasyProviderFactory.initializeInstance();
+   }
+
+   @Test
+   public void testAdd()
+   {
+      MediaType applicationXml = new MediaType(""application"", ""xml"");
+      MediaType textPlain = new MediaType(""text"", ""plain"");
+      MediaType textHtml = new MediaType(""text"", ""html"");
+
+      Variant.VariantListBuilder builder = Variant.VariantListBuilder.newInstance();
+
+      builder.languages(""en"", ""fr"");
+
+      builder.add();
+      List<Variant> variants = builder.build();
+
+      Assert.assertEquals(2, variants.size());
+
+      printVariants(variants);
+
+      System.out.println(""--------"");
+
+      builder.languages(""en"").encodings(""gzip"", ""octet"").mediaTypes(applicationXml);
+      variants = builder.build();
+
+      Assert.assertEquals(2, variants.size());
+
+      printVariants(variants);
+
+      System.out.println(""--------"");
+
+      builder.languages(""en"", ""es"").mediaTypes(applicationXml, textPlain, textHtml);
+      variants = builder.build();
+
+      Assert.assertEquals(6, variants.size());
+      printVariants(variants);
+
+      System.out.println(""--------"");
+
+      builder.languages(""en"", ""es"").mediaTypes(applicationXml, textPlain, textHtml).encodings(""zip"");
+      variants = builder.build();
+
+      Assert.assertEquals(6, variants.size());
+      printVariants(variants);
+   }
+
+   @Test
+   public void testVariantSorting()
+   {
+      List<Variant> variants = new ArrayList<Variant>();
+
+
+      Variant variant1 = new Variant(MediaType.parse(""text/plain""), ""en;q=0.3"", null);
+      Variant variant2 = new Variant(MediaType.parse(""text/plain""), ""fr"", null);
+      Variant variant3 = new Variant(MediaType.parse(""text/plain""), ""zh;q=0.6"", null);
+
+      variants.add(variant1);
+      variants.add(variant2);
+      variants.add(variant3);
+
+      variants = AcceptableVariant.sort(variants);
+      VariantTest.printVariants(variants);
+
+      Assert.assertTrue(variants.get(0) == variant2);
+      Assert.assertTrue(variants.get(1) == variant3);
+      Assert.assertTrue(variants.get(2) == variant1);
+
+
+      System.out.println(""--------"");
+   }
+
+   @Test
+   public void testVariantSorting2()
+   {
+      List<Variant> variants = new ArrayList<Variant>();
+
+
+      Variant variant1 = new Variant(MediaType.parse(""text/plain""), ""en;q=0.3"", null);
+      Variant variant2 = new Variant(MediaType.parse(""text/html;q=0.4""), ""fr"", null);
+      Variant variant3 = new Variant(MediaType.parse(""text/html""), ""es"", null);
+      Variant variant4 = new Variant(MediaType.parse(""text/plain""), ""zh;q=0.6"", null);
+
+      variants.add(variant1);
+      variants.add(variant2);
+      variants.add(variant3);
+      variants.add(variant4);
+
+      variants = AcceptableVariant.sort(variants);
+      VariantTest.printVariants(variants);
+
+      Assert.assertTrue(variants.get(0) == variant3);
+      Assert.assertTrue(variants.get(1) == variant4);
+      Assert.assertTrue(variants.get(2) == variant1);
+      Assert.assertTrue(variants.get(3) == variant2);
+
+      System.out.println(""--------"");
+   }
+
+   @Test
+   public void testVariantSorting3()
+   {
+      List<Variant> variants = new ArrayList<Variant>();
+
+
+      Variant variant1 = new Variant(MediaType.parse(""text/plain""), ""en;q=0.3"", null);
+      Variant variant2 = new Variant(MediaType.parse(""text/html;q=0.4""), ""fr"", null);
+      Variant variant3 = new Variant(MediaType.parse(""text/html""), ""es"", null);
+      Variant variant4 = new Variant(null, ""zh;q=0.6"", null);
+      Variant variant5 = new Variant(MediaType.parse(""application/xml""), ""es"", ""gzip"");
+
+
+      variants.add(variant1);
+      variants.add(variant2);
+      variants.add(variant3);
+      variants.add(variant4);
+      variants.add(variant5);
+
+      variants = AcceptableVariant.sort(variants);
+      VariantTest.printVariants(variants);
+
+      Assert.assertTrue(variants.get(0) == variant5);
+      Assert.assertTrue(variants.get(1) == variant3);
+      Assert.assertTrue(variants.get(2) == variant1);
+      Assert.assertTrue(variants.get(3) == variant2);
+      Assert.assertTrue(variants.get(4) == variant4);
+
+      System.out.println(""--------"");
+   }
+
+   @Test
+   public void testGetLanguageEn()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              languages(""zh"").
+              languages(""fr"").
+              languages(""en"").add().
+              build();
+
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance().languages(""en"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNull(v.getMediaType());
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""en"");
+   }
+
+   @Test
+   public void testGetLanguageZh()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              languages(""zh"").
+              languages(""fr"").
+              languages(""en"").add().
+              build();
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance()
+              .languages(""zh"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNull(v.getMediaType());
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""zh"");
+   }
+
+   @Test
+   public void testGetLanguageMultiple()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              languages(""zh"").
+              languages(""fr"").
+              languages(""en"").add().
+              build();
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance()
+              .languages(""zh;q=0.4"")
+              .languages(""en;q=0.3"")
+              .languages(""fr"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNull(v.getMediaType());
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""fr"");
+
+   }
+
+   @Test
+   public void testGetComplex1()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              mediaTypes(MediaType.parse(""image/jpeg"")).add().
+              mediaTypes(MediaType.parse(""application/xml"")).languages(""en-us"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en-us"").add().
+              build();
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance()
+              .mediaTypes(MediaType.parse(""text/xml""))
+              .mediaTypes(MediaType.parse(""application/xml""))
+              .mediaTypes(MediaType.parse(""application/xhtml+xml""))
+              .mediaTypes(MediaType.parse(""image/png""))
+              .mediaTypes(MediaType.parse(""text/html;q=0.9""))
+              .mediaTypes(MediaType.parse(""text/plain;q=0.8""))
+              .mediaTypes(MediaType.parse(""*/*;q=0.5""))
+              .languages(""en-us"")
+              .languages(""en;q=0.5"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNotNull(v.getMediaType());
+      Assert.assertTrue(MediaType.parse(""text/xml"").equals(v.getMediaType()));
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""en-us"");
+
+   }
+
+   @Test
+   public void testGetComplex2()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              mediaTypes(MediaType.parse(""image/jpeg"")).add().
+              mediaTypes(MediaType.parse(""application/xml"")).languages(""en-us"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en-us"").add().
+              build();
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance()
+              .mediaTypes(MediaType.parse(""text/xml""))
+              .mediaTypes(MediaType.parse(""application/xml""))
+              .mediaTypes(MediaType.parse(""application/xhtml+xml""))
+              .mediaTypes(MediaType.parse(""image/png""))
+              .mediaTypes(MediaType.parse(""text/html;q=0.9""))
+              .mediaTypes(MediaType.parse(""text/plain;q=0.8""))
+              .mediaTypes(MediaType.parse(""*/*;q=0.5""))
+              .languages(""en"")
+              .languages(""en-us"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNotNull(v.getMediaType());
+      Assert.assertTrue(MediaType.parse(""text/xml"").equals(v.getMediaType()));
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""en"");
+
+   }
+
+   @Test
+   public void testGetComplex3()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              mediaTypes(MediaType.parse(""image/jpeg"")).add().
+              mediaTypes(MediaType.parse(""application/xml"")).languages(""en-us"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en-us"").add().
+              build();
+
+      List<Variant> wants = Variant.VariantListBuilder.newInstance()
+              .mediaTypes(MediaType.parse(""application/xml""))
+              .mediaTypes(MediaType.parse(""text/xml""))
+              .mediaTypes(MediaType.parse(""application/xhtml+xml""))
+              .mediaTypes(MediaType.parse(""image/png""))
+              .mediaTypes(MediaType.parse(""text/html;q=0.9""))
+              .mediaTypes(MediaType.parse(""text/plain;q=0.8""))
+              .mediaTypes(MediaType.parse(""*/*;q=0.5""))
+              .languages(""en-us"")
+              .languages(""en;q=0.5"").build();
+
+      Variant v = AcceptableVariant.pick(wants, has);
+      Assert.assertNotNull(v);
+      Assert.assertNotNull(v.getMediaType());
+      Assert.assertTrue(MediaType.parse(""application/xml"").equals(v.getMediaType()));
+      Assert.assertNull(v.getEncoding());
+      Assert.assertEquals(v.getLanguage(), ""en-us"");
+
+   }
+
+   @Test
+   public void testGetComplexNotAcceptable()
+   {
+      List<Variant> has = Variant.VariantListBuilder.newInstance().
+              mediaTypes(MediaType.parse(""image/jpeg"")).add().
+              mediaTypes(MediaType.parse(""application/xml"")).languages(""en-us"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en"").add().
+              mediaTypes(MediaType.parse(""text/xml"")).languages(""en-us"").add().
+              build();
+      {
+         List<Variant> wants = Variant.VariantListBuilder.newInstance()
+                 .mediaTypes(MediaType.parse(""application/atom+xml""))
+                 .languages(""en-us"")
+                 .languages(""en"").build();
+
+         Variant v = AcceptableVariant.pick(wants, has);
+         Assert.assertNull(v);
+      }
+
+      {
+         List<Variant> wants = Variant.VariantListBuilder.newInstance()
+                 .mediaTypes(MediaType.parse(""application/xml""))
+                 .languages(""fr"").build();
+
+         Variant v = AcceptableVariant.pick(wants, has);
+         Assert.assertNull(v);
+      }
+
+
+   }
+
+   public static void printVariants(List<Variant> variants)
+   {
+      for (Variant variant : variants)
+      {
+         System.out.println(""Variant: type="" + variant.getMediaType() + "" language="" + variant.getLanguage() + "" encoding="" + variant.getEncoding());
+      }
+   }
+}
\ No newline at end of file",2008-03-18T01:44:44Z,98
"@@ -0,0 +1,202 @@
+package org.resteasy.test.finegrain.resource;
+
+import org.junit.BeforeClass;
+import org.resteasy.spi.ResteasyProviderFactory;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class VariantsTest
+{
+   @BeforeClass
+   public static void start()
+   {
+      ResteasyProviderFactory.initializeInstance();
+   }
+
+//   private static HttpServletDispatcher dispatcher;
+//
+//   @BeforeClass
+//   public static void before() throws Exception
+//   {
+//      dispatcher = EmbeddedServletContainer.start();
+//      dispatcher.getRegistry().addResource(LanguageVariantResource.class);
+//      dispatcher.getRegistry().addResource(ComplexVariantResource.class);
+//   }
+//
+//   @AfterClass
+//   public static void after() throws Exception
+//   {
+//      EmbeddedServletContainer.stop();
+//   }
+//
+//   @Path(""/"")
+//   public static class LanguageVariantResource
+//   {
+//      @GET
+//      public Response doGet(@Context Request r)
+//      {
+//         List<Variant> vs = Variant.VariantListBuilder.newInstance().
+//                 languages(""zh"").
+//                 languages(""fr"").
+//                 languages(""en"").add().
+//                 build();
+//
+//         Variant v = r.selectVariant(vs);
+//         if (v == null)
+//            return Response.notAcceptable(vs).build();
+//         else
+//            return Response.ok(v.getLanguage(), v).build();
+//      }
+//   }
+//
+//   public void testGetLanguageEn() throws IOException
+//   {
+//      initiateWebApplication(LanguageVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.
+//              header(""Accept-Language"", ""en"").
+//              get(ClientResponse.class);
+//      assertEquals(""en"", r.getEntity(String.class));
+//      assertEquals(""en"", r.getLanguage());
+//   }
+//
+//   public void testGetLanguageZh() throws IOException
+//   {
+//      initiateWebApplication(LanguageVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.
+//              header(""Accept-Language"", ""zh"").
+//              get(ClientResponse.class);
+//      assertEquals(""zh"", r.getEntity(String.class));
+//      assertEquals(""zh"", r.getLanguage());
+//   }
+//
+//   public void testGetLanguageMultiple() throws IOException
+//   {
+//      initiateWebApplication(LanguageVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.
+//              header(""Accept-Language"", ""en;q=0.3, zh;q=0.4, fr"").
+//              get(ClientResponse.class);
+//      assertEquals(""fr"", r.getEntity(String.class));
+//      assertEquals(""fr"", r.getLanguage());
+//   }
+//
+//   @Path(""/"")
+//   public static class ComplexVariantResource
+//   {
+//      @GET
+//      public Response doGet(@Context Request r)
+//      {
+//         List<Variant> vs = Variant.VariantListBuilder.newInstance().
+//                 mediaTypes(MediaType.parse(""image/jpeg"")).add().
+//                 mediaTypes(MediaType.parse(""application/xml"")).languages(""en-us"").add().
+//                 mediaTypes(MediaType.parse(""text/xml"")).languages(""en"").add().
+//                 mediaTypes(MediaType.parse(""text/xml"")).languages(""en-us"").add().
+//                 build();
+//
+//         Variant v = r.selectVariant(vs);
+//         if (v == null)
+//            return Response.notAcceptable(vs).build();
+//         else
+//            return Response.ok(""GET"", v).build();
+//      }
+//   }
+//
+//   public void testGetComplex1() throws IOException
+//   {
+//      initiateWebApplication(ComplexVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.accept(""text/xml"",
+//              ""application/xml"",
+//              ""application/xhtml+xml"",
+//              ""image/png"",
+//              ""text/html;q=0.9"",
+//              ""text/plain;q=0.8"",
+//              ""*/*;q=0.5"").
+//              header(""Accept-Language"", ""en-us,en;q=0.5"").
+//              get(ClientResponse.class);
+//      assertEquals(""GET"", r.getEntity(String.class));
+//      assertEquals(MediaType.parse(""text/xml""), r.getType());
+//      assertEquals(""en-us"", r.getLanguage());
+//   }
+//
+//   public void testGetComplex2() throws IOException
+//   {
+//      initiateWebApplication(ComplexVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.accept(""text/xml"",
+//              ""application/xml"",
+//              ""application/xhtml+xml"",
+//              ""image/png"",
+//              ""text/html;q=0.9"",
+//              ""text/plain;q=0.8"",
+//              ""*/*;q=0.5"").
+//              header(""Accept-Language"", ""en,en-us"").
+//              get(ClientResponse.class);
+//      assertEquals(""GET"", r.getEntity(String.class));
+//      assertEquals(MediaType.parse(""text/xml""), r.getType());
+//      assertEquals(""en"", r.getLanguage());
+//   }
+//
+//   public void testGetComplex3() throws IOException
+//   {
+//      initiateWebApplication(ComplexVariantResource.class);
+//      WebResource rp = resource(""/"");
+//
+//      ClientResponse r = rp.accept(""application/xml"",
+//              ""text/xml"",
+//              ""application/xhtml+xml"",
+//              ""image/png"",
+//              ""text/html;q=0.9"",
+//              ""text/plain;q=0.8"",
+//              ""*/*;q=0.5"").
+//              header(""Accept-Language"", ""en-us,en;q=0.5"").
+//              get(ClientResponse.class);
+//      assertEquals(""GET"", r.getEntity(String.class));
+//      assertEquals(MediaType.parse(""application/xml""), r.getType());
+//      assertEquals(""en-us"", r.getLanguage());
+//   }
+//
+//   public void testGetComplexNotAcceptable() throws IOException
+//   {
+//      initiateWebApplication(ComplexVariantResource.class);
+//      WebResource rp = resource(""/"", false);
+//
+//      ClientResponse r = rp.accept(""application/atom+xml"").
+//              header(""Accept-Language"", ""en-us,en"").
+//              get(ClientResponse.class);
+//      String vary = r.getMetadata().getFirst(""Vary"");
+//      assertNotNull(vary);
+//      assertTrue(contains(vary, ""Accept""));
+//      assertTrue(contains(vary, ""Accept-Language""));
+//      assertEquals(406, r.getStatus());
+//
+//      r = rp.accept(""application/xml"").
+//              header(""Accept-Language"", ""fr"").
+//              get(ClientResponse.class);
+//      assertTrue(contains(vary, ""Accept""));
+//      assertTrue(contains(vary, ""Accept-Language""));
+//      assertEquals(406, r.getStatus());
+//   }
+//
+//   private boolean contains(String l, String v)
+//   {
+//      String[] vs = l.split("","");
+//      for (String s : vs)
+//      {
+//         s = s.trim();
+//         if (s.equalsIgnoreCase(v))
+//            return true;
+//      }
+//
+//      return false;
+//   }
+}",2008-03-18T01:44:44Z,99
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -12,8 +12,6 @@
 
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
-import java.io.IOException;
-
 import static org.jboss.resteasy.test.TestPortProvider.*;
 
 /**
@@ -54,21 +52,19 @@ public String goodbye()
       }
    }
 
-   private void _test(HttpClient client, String path)
+   private void _test(String path)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
@@ -78,8 +74,8 @@ public void testEncoded() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(SimpleResource.class);
-         _test(new HttpClient(), ""/hello%20world"");
-         _test(new HttpClient(), ""/goodbye%7Bworld"");
+         _test(""/hello%20world"");
+         _test(""/goodbye%7Bworld"");
       }
       finally
       {",2011-11-02T20:21:10Z,100
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -16,7 +16,6 @@
 import javax.ws.rs.core.Context;
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
-import java.io.IOException;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
@@ -98,51 +97,45 @@ public static void after() throws Exception
       EmbeddedContainer.stop();
    }
 
-   private void _test(HttpClient client, String path, String body)
+   private void _test(String path, String body)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            Assert.assertEquals(body, method.getResponseBodyAsString());
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<String> response = request.get(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         Assert.assertEquals(body, response.getEntity());
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
    public void testIt()
    {
-      HttpClient client = new HttpClient();
-      _test(client, ""/extension.xml"", ""xml"");
-      _test(client, ""/extension.html.en"", ""html"");
-      _test(client, ""/extension.en.html"", ""html"");
-      _test(client, ""/extension/stuff.old.en.txt"", ""plain"");
-      _test(client, ""/extension/stuff.en.old.txt"", ""plain"");
-      _test(client, ""/extension/stuff.en.txt.old"", ""plain"");
+      _test(""/extension.xml"", ""xml"");
+      _test(""/extension.html.en"", ""html"");
+      _test(""/extension.en.html"", ""html"");
+      _test(""/extension/stuff.old.en.txt"", ""plain"");
+      _test(""/extension/stuff.en.old.txt"", ""plain"");
+      _test(""/extension/stuff.en.txt.old"", ""plain"");
    }
 
    @Test
    public void testError()
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/extension.junk""));
+      try
+      {
+         ClientResponse<String> response = request.get(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_NOT_FOUND, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
       {
-         GetMethod method = createGetMethod(""/extension.junk"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_NOT_FOUND);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         throw new RuntimeException(e);
       }
    }
 }
\ No newline at end of file",2011-11-02T20:21:10Z,101
"@@ -1,9 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.StringRequestEntity;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.client.ProxyFactory;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
@@ -112,95 +110,73 @@ public void post109(MultivaluedMap<String, String> form)
    @Test
    public void testResteasy109()
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/RESTEASY-109""));
+      request.body(MediaType.APPLICATION_FORM_URLENCODED,
+                   ""name=jon&address1=123+Main+St&address2=&zip=12345"");
+      try
       {
-         PostMethod method = createPostMethod(""/RESTEASY-109"");
-         try
-         {
-            method.setRequestEntity(new StringRequestEntity(""name=jon&address1=123+Main+St&address2=&zip=12345"",
-                    MediaType.APPLICATION_FORM_URLENCODED, null));
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, 204);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.post();
+         Assert.assertEquals(204, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
-   @Test
+   //@Test
    public void testQueryParamIsNull()
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/simple""));
+      request.formParameter(""hello"", ""world"");
+      try
       {
-         PostMethod method = createPostMethod(""/simple"");
-         NameValuePair[] params =
-                 {new NameValuePair(""hello"", ""world"")};
-         method.setRequestBody(params);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            String body = method.getResponseBodyAsString();
-            Assert.assertEquals(""hello=world"", body);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<String> response = request.post(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         Assert.assertEquals(""hello=world"", response.getEntity());
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
-   @Test
+   //@Test
    public void testPost()
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/form""));
+      request.formParameter(""hello"", ""world"");
+      try
       {
-         PostMethod method = createPostMethod(""/form"");
-         NameValuePair[] params =
-                 {new NameValuePair(""hello"", ""world"")};
-         method.setRequestBody(params);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            String body = method.getResponseBodyAsString();
-            Assert.assertEquals(""hello=world"", body);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<String> response = request.post(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         Assert.assertEquals(""hello=world"", response.getEntity());
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
-   @Test
+   //@Test
    public void testPostTwoParameters()
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/form/twoparams""));
+      request.formParameter(""hello"", ""world"");
+      request.formParameter(""yo"", ""mama"");
+      try
       {
-         PostMethod method = createPostMethod(""/form/twoparams"");
-         NameValuePair[] params =
-                 {new NameValuePair(""hello"", ""world""), new NameValuePair(""yo"", ""mama"")};
-         method.setRequestBody(params);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            String body = method.getResponseBodyAsString();
-            Assert.assertTrue(body.indexOf(""hello=world"") != -1);
-            Assert.assertTrue(body.indexOf(""yo=mama"") != -1);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<String> response = request.post(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         String body = response.getEntity();
+         Assert.assertTrue(body.indexOf(""hello=world"") != -1);
+         Assert.assertTrue(body.indexOf(""yo=mama"") != -1);
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Path(""/"")
@@ -219,7 +195,7 @@ public static interface TestProxy
       public MultivaluedMap<String, String> post2(MultivaluedMap<String, String> form);
    }
 
-   @Test
+   //@Test
    public void testProxy()
    {
       TestProxy proxy = ProxyFactory.create(TestProxy.class, generateBaseUrl());",2011-11-02T20:21:10Z,102
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.test.EmbeddedContainer;
@@ -160,43 +160,37 @@ public static void after() throws Exception
    @Test
    public void testDoubles()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/doubles"");
+      ClientRequest request = new ClientRequest(generateURL(""/doubles""));
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         String result = method.getResponseBodyAsString();
-         Assert.assertEquals(""45.0D 50.0D "", result);
-         System.out.println(result);
+         ClientResponse<String> response = request.get(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         String body = response.getEntity();
+         Assert.assertEquals(""45.0D 50.0D "", body);
+         System.out.println(body);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
-         method.releaseConnection();
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testFloats()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/floats"");
+      ClientRequest request = new ClientRequest(generateURL(""/floats""));
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         String result = method.getResponseBodyAsString();
-         Assert.assertEquals(""45.0F 50.0F "", result);
-         System.out.println(result);
+         ClientResponse<String> response = request.get(String.class);
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         String body = response.getEntity();
+         Assert.assertEquals(""45.0F 50.0F "", body);
+         System.out.println(body);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
-         method.releaseConnection();
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
 }
\ No newline at end of file",2011-11-02T20:21:10Z,103
"@@ -1,9 +1,10 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.test.BaseResourceTest;
 import org.jboss.resteasy.test.TestPortProvider;
+import org.jboss.resteasy.util.HttpResponseCodes;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -81,12 +82,11 @@ public void setUp() throws Exception
    @Test
    public void Test1() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = new GetMethod(TestPortProvider.generateURL(""/InheritanceTest""));
-      method.addRequestHeader(""Accept"", ""text/plain"");
-      int status = client.executeMethod(method);
-      Assert.assertEquals(200, status);
-      Assert.assertEquals(""First"", method.getResponseBodyAsString());
+      ClientRequest request = new ClientRequest(TestPortProvider.generateURL(""/InheritanceTest""));
+      request.header(""Accept"", ""text/plain"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""First"", response.getEntity());
    }
 
 
@@ -97,13 +97,11 @@ public void Test1() throws Exception
    @Test
    public void Test2() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = new GetMethod(TestPortProvider.generateURL(""/InheritanceTest1""));
-      method.addRequestHeader(""Accept"", ""text/html"");
-      int status = client.executeMethod(method);
-      Assert.assertEquals(200, status);
-      Assert.assertTrue(method.getResponseBodyAsString().indexOf(""Second"") > -1);
-
+      ClientRequest request = new ClientRequest(TestPortProvider.generateURL(""/InheritanceTest1""));
+      request.header(""Accept"", ""text/html"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertTrue(response.getEntity().indexOf(""Second"") > -1);
    }
 
 ",2011-11-02T20:21:10Z,23
"@@ -1,9 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.OptionsMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -17,7 +15,6 @@
 import javax.ws.rs.HttpMethod;
 import javax.ws.rs.Path;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.HashSet;
@@ -79,79 +76,73 @@ public static void after() throws Exception
    @Test
    public void testOptions() throws Exception
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/options""));
+      try
       {
-         OptionsMethod method = createOptionsMethod(""/options"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            Header[] headers = method.getResponseHeaders(""Allow"");
-            Assert.assertNotNull(headers);
-            Assert.assertEquals(headers[0].getValue(), ""GET, POST"");
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.options();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         Assert.assertEquals(""GET, POST"", response.getHeaders().getFirst(""Allow"")); 
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
    }
 
    @Test
    public void testDefaultOptions() throws Exception
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/stuff""));
+      try
       {
-         OptionsMethod method = createOptionsMethod(""/stuff"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-            Header[] headers = method.getResponseHeaders(""Allow"");
-            Assert.assertNotNull(headers);
-            String value = headers[0].getValue();
-            HashSet<String> vals = new HashSet<String>();
-            for (String v : value.split("",""))
-               vals.add(v.trim());
-            Assert.assertEquals(4, vals.size());
-            Assert.assertTrue(vals.contains(""GET""));
-            Assert.assertTrue(vals.contains(""DELETE""));
-            Assert.assertTrue(vals.contains(""HEAD""));
-            Assert.assertTrue(vals.contains(""OPTIONS""));
-         }
-         catch (IOException e)
+         ClientResponse<?> response = request.options();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         String allowed = response.getHeaders().getFirst(""Allow"");
+         Assert.assertNotNull(allowed);
+         HashSet<String> vals = new HashSet<String>();
+         for (String v : allowed.split("",""))
          {
-            throw new RuntimeException(e);
-         }
+            vals.add(v.trim());
+         }  
+         Assert.assertEquals(4, vals.size());
+         Assert.assertTrue(vals.contains(""GET""));
+         Assert.assertTrue(vals.contains(""DELETE""));
+         Assert.assertTrue(vals.contains(""HEAD""));
+         Assert.assertTrue(vals.contains(""OPTIONS""));
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
    }
 
    @Test
    public void testMethodNotAllowed() throws Exception
    {
-      HttpClient client = new HttpClient();
+      ClientRequest request = new ClientRequest(generateURL(""/stuff""));
+      try
       {
-         PostMethod method = createPostMethod(""/stuff"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_METHOD_NOT_ALLOWED);
-            Header[] headers = method.getResponseHeaders(""Allow"");
-            Assert.assertNotNull(headers);
-            String value = headers[0].getValue();
-            HashSet<String> vals = new HashSet<String>();
-            for (String v : value.split("",""))
-               vals.add(v.trim());
-            Assert.assertEquals(4, vals.size());
-            Assert.assertTrue(vals.contains(""HEAD""));
-            Assert.assertTrue(vals.contains(""OPTIONS""));
-            Assert.assertTrue(vals.contains(""GET""));
-            Assert.assertTrue(vals.contains(""DELETE""));
-         }
-         catch (IOException e)
+         ClientResponse<?> response = request.post();
+         Assert.assertEquals(HttpResponseCodes.SC_METHOD_NOT_ALLOWED, response.getStatus());
+         String allowed = response.getHeaders().getFirst(""Allow"");
+         Assert.assertNotNull(allowed);
+         HashSet<String> vals = new HashSet<String>();
+         for (String v : allowed.split("",""))
          {
-            throw new RuntimeException(e);
-         }
+            vals.add(v.trim());
+         }  
+         Assert.assertEquals(4, vals.size());
+         Assert.assertTrue(vals.contains(""GET""));
+         Assert.assertTrue(vals.contains(""DELETE""));
+         Assert.assertTrue(vals.contains(""HEAD""));
+         Assert.assertTrue(vals.contains(""OPTIONS""));
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
    }
 }",2011-11-02T20:21:10Z,104
"@@ -1,8 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PutMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -15,7 +14,6 @@
 import javax.ws.rs.Path;
 import javax.ws.rs.PathParam;
 import javax.ws.rs.QueryParam;
-import java.io.IOException;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
 
@@ -116,67 +114,60 @@ public static void after() throws Exception
       EmbeddedContainer.stop();
    }
 
-   private void _test(HttpClient client, String path)
+   private void _test(String path)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @SuppressWarnings(""unused"")
-   private void _testPut(HttpClient client, String path)
+   private void _testPut(String path)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         PutMethod method = createPutMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.put();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
    public void testUnlimitedOnClass()
    {
-      HttpClient client = new HttpClient();
-      _test(client, ""/unlimited"");
-      _test(client, ""/unlimited/on/and/on"");
+      _test(""/unlimited"");
+      _test(""/unlimited/on/and/on"");
    }
 
    @Test
    public void testUnlimitedOnMethod()
    {
-      HttpClient client = new HttpClient();
-      _test(client, ""/unlimited2/on/and/on"");
-      _test(client, ""/uriparam/on/and/on?expected=on%2Fand%2Fon"");
+      _test(""/unlimited2/on/and/on"");
+      _test(""/uriparam/on/and/on?expected=on%2Fand%2Fon"");
    }
 
    @Test
    public void testLocator()
    {
-      HttpClient client = new HttpClient();
-      _test(client, ""/locator"");
-      _test(client, ""/locator/on/and/on"");
-      _test(client, ""/locator2/on/and/on?expected=on%2Fand%2Fon"");
-      _test(client, ""/locator3/unlimited/unlimited2/on/and/on"");
-      _test(client, ""/locator3/unlimited/uriparam/on/and/on?expected=on%2Fand%2Fon"");
-      _test(client, ""/locator3/uriparam/1/uriparam/on/and/on?firstExpected=1&expected=on%2Fand%2Fon"");
+      _test(""/locator"");
+      _test(""/locator/on/and/on"");
+      _test(""/locator2/on/and/on?expected=on%2Fand%2Fon"");
+      _test(""/locator3/unlimited/unlimited2/on/and/on"");
+      _test(""/locator3/unlimited/uriparam/on/and/on?expected=on%2Fand%2Fon"");
+      _test(""/locator3/uriparam/1/uriparam/on/and/on?firstExpected=1&expected=on%2Fand%2Fon"");
 
    }
 }
\ No newline at end of file",2011-11-02T20:21:10Z,105
"@@ -1,7 +1,8 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
+import org.jboss.resteasy.client.core.executors.ApacheHttpClient4Executor;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpHeaderNames;
@@ -17,7 +18,6 @@
 import javax.ws.rs.core.EntityTag;
 import javax.ws.rs.core.Request;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
 import java.util.GregorianCalendar;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
@@ -64,149 +64,141 @@ public Response doGet(@Context Request request)
    @Test
    public void testIfUnmodifiedSinceBeforeLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 412);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(412, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfUnmodifiedSinceAfterLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfModifiedSinceBeforeLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfModifiedSinceAfterLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfUnmodifiedSinceBeforeLastModified_IfModifiedSinceBeforeLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 412);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(412, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfUnmodifiedSinceBeforeLastModified_IfModifiedSinceAfterLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfUnmodifiedSinceAfterLastModified_IfModifiedSinceAfterLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Test
    public void testIfUnmodifiedSinceAfterLastModified_IfModifiedSinceBeforeLastModified()
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
-      method.addRequestHeader(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.IF_UNMODIFIED_SINCE, ""Tue, 2 Jan 2007 00:00:00 GMT"");
+      request.header(HttpHeaderNames.IF_MODIFIED_SINCE, ""Sat, 30 Dec 2006 00:00:00 GMT"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 200);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(200, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    @Path(""/etag"")
@@ -314,177 +306,181 @@ public void testIfMatchWithoutMatchingETag_IfNonMatchWithoutMatchingETag()
 
    public void testIfMatchWithMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""\""1\"""");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""\""1\"""");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfMatchWithoutMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""\""2\"""");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""\""2\"""");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 412);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(412, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfMatchWildCard(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""*"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""*"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfNonMatchWithMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""\""1\"""");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""\""1\"""");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
-         Assert.assertEquals(""1"", method.getResponseHeader(HttpHeaderNames.ETAG).getValue());
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         Assert.assertEquals(""1"", response.getHeaders().getFirst(HttpHeaderNames.ETAG));
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfNonMatchWithoutMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""2"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""2"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
-   }
+  }
 
    public void testIfNonMatchWildCard(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""*"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""*"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
-         Assert.assertEquals(""1"", method.getResponseHeader(HttpHeaderNames.ETAG).getValue());
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         Assert.assertEquals(""1"", response.getHeaders().getFirst(HttpHeaderNames.ETAG));
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfMatchWithMatchingETag_IfNonMatchWithMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""1"");
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""1"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""1"");
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""1"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 304);
-         Assert.assertEquals(""1"", method.getResponseHeader(HttpHeaderNames.ETAG).getValue());
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(304, response.getStatus());
+         Assert.assertEquals(""1"", response.getHeaders().getFirst(HttpHeaderNames.ETAG));
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfMatchWithMatchingETag_IfNonMatchWithoutMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""1"");
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""2"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""1"");
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""2"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 200);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(200, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
-      method.releaseConnection();
    }
 
    public void testIfMatchWithoutMatchingETag_IfNonMatchWithMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""2"");
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""1"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""2"");
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""1"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 412);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(412, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
    }
 
    public void testIfMatchWithoutMatchingETag_IfNonMatchWithoutMatchingETag(String fromField)
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/etag"" + fromField);
-      method.addRequestHeader(HttpHeaderNames.IF_MATCH, ""2"");
-      method.addRequestHeader(HttpHeaderNames.IF_NONE_MATCH, ""2"");
+      ClientRequest request = new ClientRequest(generateURL(""/etag"" + fromField));
+      request.header(HttpHeaderNames.IF_MATCH, ""2"");
+      request.header(HttpHeaderNames.IF_NONE_MATCH, ""2"");
       try
       {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, 412);
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(412, response.getStatus());
+         shutdownConnections(request);
       }
-      catch (IOException e)
+      catch (Exception e)
       {
          throw new RuntimeException(e);
       }
    }
 
+   private void shutdownConnections(ClientRequest request)
+   {
+      ApacheHttpClient4Executor executor = (ApacheHttpClient4Executor) request.getExecutor();
+      executor.getHttpClient().getConnectionManager().shutdown();
+//      try
+//      {
+//         request.getExecutor().close();
+//      } catch (Exception e)
+//      {
+//         throw new RuntimeException(e);
+//      }
+   }
 }",2011-11-02T20:21:10Z,106
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpHeaderNames;
@@ -15,7 +15,6 @@
 import javax.ws.rs.Path;
 import javax.ws.rs.QueryParam;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
 import java.net.URI;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
@@ -63,21 +62,19 @@ public String get(@QueryParam(""abs"") String abs)
       }
    }
 
-   private void _test(HttpClient client, String path)
+   private void _test(String path)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
@@ -87,7 +84,7 @@ public void testUriInfo() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(SimpleResource.class);
-         _test(new HttpClient(), ""/simple"");
+         _test(""/simple"");
       }
       finally
       {
@@ -102,7 +99,7 @@ public void testUriInfo2() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(SimpleResource.class);
-         _test(new HttpClient(), ""/resteasy/simple?abs=resteasy"");
+         _test(""/resteasy/simple?abs=resteasy"");
       }
       finally
       {",2011-11-02T20:21:10Z,107
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.plugins.server.resourcefactory.SingletonResource;
 import org.jboss.resteasy.test.EmbeddedContainer;
@@ -19,9 +19,7 @@
 import javax.ws.rs.core.Context;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriInfo;
-import java.io.IOException;
 import java.net.URI;
-import java.net.URLDecoder;
 import java.util.List;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
@@ -96,21 +94,19 @@ public String get(@QueryParam(""abs"") String abs)
 
    }
 
-   private void _test(HttpClient client, String path)
+   private void _test(String path)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+         response.releaseConnection();
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
@@ -120,7 +116,7 @@ public void testUriInfoWithSingleton() throws Exception
       try
       {
          dispatcher.getRegistry().addResourceFactory(new SingletonResource(new SimpleResource()));
-         _test(new HttpClient(), ""/simple/fromField"");
+         _test(""/simple/fromField"");
       }
       finally
       {
@@ -136,8 +132,8 @@ public void testUriInfo() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(SimpleResource.class);
-         _test(new HttpClient(), ""/simple"");
-         _test(new HttpClient(), ""/simple/fromField"");
+         _test(""/simple"");
+         _test(""/simple/fromField"");
       }
       finally
       {
@@ -152,7 +148,7 @@ public void testUriInfo2() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(SimpleResource.class);
-         _test(new HttpClient(), ""/resteasy/simple?abs=resteasy"");
+         _test(""/resteasy/simple?abs=resteasy"");
       }
       finally
       {
@@ -207,7 +203,7 @@ public void testEscapedMatrParam() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(EscapedMatrParamResource.class);
-         _test(new HttpClient(), ""/queryEscapedMatrParam;a=a%3Bb;b=x%2Fy;c=m%5Cn;d=k%3Dl"");
+         _test(""/queryEscapedMatrParam;a=a%3Bb;b=x%2Fy;c=m%5Cn;d=k%3Dl"");
       }
       finally
       {
@@ -222,7 +218,7 @@ public void testEncodedTemplateParams() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(EncodedTemplateResource.class);
-         _test(new HttpClient(), ""/a%20b/x%20y"");
+         _test(""/a%20b/x%20y"");
       }
       finally
       {
@@ -250,7 +246,7 @@ public void testEncodedQueryParams() throws Exception
       try
       {
          dispatcher.getRegistry().addPerRequestResource(EncodedQueryResource.class);
-         _test(new HttpClient(), ""/query?a=a%20b"");
+         _test(""/query?a=a%20b"");
       }
       finally
       {",2011-11-02T20:21:10Z,108
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpHeaderNames;
@@ -18,7 +18,6 @@
 import javax.ws.rs.core.Request;
 import javax.ws.rs.core.Response;
 import javax.ws.rs.core.Variant;
-import java.io.IOException;
 import java.util.List;
 import java.util.Locale;
 
@@ -65,63 +64,36 @@ public Response doGet(@Context Request r)
    }
 
    @Test
-   public void testGetLanguageEn() throws IOException
+   public void testGetLanguageEn() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""en"", method.getResponseBodyAsString());
-         Assert.assertEquals(""en"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""en"", response.getEntity());
+      Assert.assertEquals(""en"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Test
-   public void testGetLanguageZh() throws IOException
+   public void testGetLanguageZh() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""zh"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""zh"", method.getResponseBodyAsString());
-         Assert.assertEquals(""zh"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""zh"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""zh"", response.getEntity());
+      Assert.assertEquals(""zh"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Test
-   public void testGetLanguageMultiple() throws IOException
+   public void testGetLanguageMultiple() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en;q=0.3, zh;q=0.4, fr"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""fr"", method.getResponseBodyAsString());
-         Assert.assertEquals(""fr"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en;q=0.3, zh;q=0.4, fr"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""fr"", response.getEntity());
+      Assert.assertEquals(""fr"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Path(""/complex"")
@@ -144,157 +116,111 @@ public Response doGet(@Context Request r)
    }
 
    @Test
-   public void testGetComplex1() throws IOException
+   public void testGetComplex1() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/complex"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""image/png"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en;q=0.5"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""GET"", method.getResponseBodyAsString());
-         Assert.assertEquals(""application/xml"", method.getResponseHeader(HttpHeaderNames.CONTENT_TYPE).getValue());
-         Assert.assertEquals(""en-us"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/complex""));
+      request.header(HttpHeaderNames.ACCEPT, ""text/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""image/png"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
+      request.header(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en;q=0.5"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.getEntity());
+      Assert.assertEquals(""application/xml"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_TYPE));
+      Assert.assertEquals(""en-us"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Test
-   public void testGetComplex2() throws IOException
+   public void testGetComplex2() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/complex"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""image/png"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en, en-us"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""GET"", method.getResponseBodyAsString());
-         Assert.assertEquals(""application/xml"", method.getResponseHeader(HttpHeaderNames.CONTENT_TYPE).getValue());
-         Assert.assertEquals(""en-us"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
+      ClientRequest request = new ClientRequest(generateURL(""/complex""));
+      request.header(HttpHeaderNames.ACCEPT, ""text/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""image/png"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
+      request.header(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en, en-us"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.getEntity());
+      Assert.assertEquals(""application/xml"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_TYPE));
+      Assert.assertEquals(""en-us"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Test
-   public void testGetComplex3() throws IOException
+   public void testGetComplex3() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/complex"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""image/png"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en;q=0.5"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""GET"", method.getResponseBodyAsString());
-         Assert.assertEquals(""application/xml"", method.getResponseHeader(HttpHeaderNames.CONTENT_TYPE).getValue());
-         Assert.assertEquals(""en-us"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
+      ClientRequest request = new ClientRequest(generateURL(""/complex""));
+      request.header(HttpHeaderNames.ACCEPT, ""application/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""image/png"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
+      request.header(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en;q=0.5"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.getEntity());
+      Assert.assertEquals(""application/xml"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_TYPE));
+      Assert.assertEquals(""en-us"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
    @Test
-   public void testGetComplex4() throws IOException
+   public void testGetComplex4() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/complex"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""image/png"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en, en-us;q=0.5"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""GET"", method.getResponseBodyAsString());
-         Assert.assertEquals(""text/xml"", method.getResponseHeader(HttpHeaderNames.CONTENT_TYPE).getValue());
-         Assert.assertEquals(""en"", method.getResponseHeader(HttpHeaderNames.CONTENT_LANGUAGE).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
+      ClientRequest request = new ClientRequest(generateURL(""/complex""));
+      request.header(HttpHeaderNames.ACCEPT, ""application/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""application/xhtml+xml"");
+      request.header(HttpHeaderNames.ACCEPT, ""image/png"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/html;q=0.9"");
+      request.header(HttpHeaderNames.ACCEPT, ""text/plain;q=0.8"");
+      request.header(HttpHeaderNames.ACCEPT, ""*/*;q=0.5"");
+      request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en, en-us;q=0.5"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+      Assert.assertEquals(""GET"", response.getEntity());
+      Assert.assertEquals(""text/xml"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_TYPE));
+      Assert.assertEquals(""en"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_LANGUAGE));
    }
 
 
    @Test
-   public void testGetComplexNotAcceptable() throws IOException
+   public void testGetComplexNotAcceptable() throws Exception
    {
       {
-         HttpClient client = new HttpClient();
-         GetMethod method = createGetMethod(""/complex"");
-         method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/atom+xml"");
-         method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, 406);
-            String vary = method.getResponseHeader(HttpHeaderNames.VARY).getValue();
-            Assert.assertNotNull(vary);
-            System.out.println(""vary: "" + vary);
-            Assert.assertTrue(contains(vary, ""Accept""));
-            Assert.assertTrue(contains(vary, ""Accept-Language""));
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientRequest request = new ClientRequest(generateURL(""/complex""));
+         request.header(HttpHeaderNames.ACCEPT, ""application/atom+xml"");
+         request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""en-us, en"");
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(406, response.getStatus());;
+         String vary = response.getHeaders().getFirst(HttpHeaderNames.VARY);
+         Assert.assertNotNull(vary);
+         System.out.println(""vary: "" + vary);
+         Assert.assertTrue(contains(vary, ""Accept""));
+         Assert.assertTrue(contains(vary, ""Accept-Language""));
+         response.releaseConnection();
       }
 
       {
-         HttpClient client = new HttpClient();
-         GetMethod method = createGetMethod(""/complex"");
-         method.addRequestHeader(HttpHeaderNames.ACCEPT, ""application/xml"");
-         method.addRequestHeader(HttpHeaderNames.ACCEPT_LANGUAGE, ""fr"");
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, 406);
-            String vary = method.getResponseHeader(HttpHeaderNames.VARY).getValue();
-            Assert.assertNotNull(vary);
-            Assert.assertTrue(contains(vary, ""Accept""));
-            Assert.assertTrue(contains(vary, ""Accept-Language""));
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         ClientRequest request = new ClientRequest(generateURL(""/complex""));
+         request.header(HttpHeaderNames.ACCEPT, ""application/xml"");
+         request.header(HttpHeaderNames.ACCEPT_LANGUAGE, ""fr"");
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(406, response.getStatus());;
+         String vary = response.getHeaders().getFirst(HttpHeaderNames.VARY);
+         Assert.assertNotNull(vary);
+         System.out.println(""vary: "" + vary);
+         Assert.assertTrue(contains(vary, ""Accept""));
+         Assert.assertTrue(contains(vary, ""Accept-Language""));
+         response.releaseConnection();
       }
    }
 
@@ -314,103 +240,58 @@ public Response doGet(@Context Request r)
    }
 
    @Test
-   public void testGetEncoding1() throws IOException
+   public void testGetEncoding1() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/encoding"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_ENCODING, ""enc1"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""enc1"", method.getResponseBodyAsString());
-         Assert.assertEquals(""enc1"", method.getResponseHeader(HttpHeaderNames.CONTENT_ENCODING).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/encoding""));
+      request.header(HttpHeaderNames.ACCEPT_ENCODING, ""enc1"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc1"", response.getEntity());
+      Assert.assertEquals(""enc1"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_ENCODING));
    }
 
    @Test
-   public void testGetEncoding2() throws IOException
+   public void testGetEncoding2() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/encoding"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_ENCODING, ""enc2"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""enc2"", method.getResponseBodyAsString());
-         Assert.assertEquals(""enc2"", method.getResponseHeader(HttpHeaderNames.CONTENT_ENCODING).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/encoding""));
+      request.header(HttpHeaderNames.ACCEPT_ENCODING, ""enc2"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc2"", response.getEntity());
+      Assert.assertEquals(""enc2"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_ENCODING));
    }
 
    @Test
-   public void testGetEncoding3() throws IOException
+   public void testGetEncoding3() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/encoding"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_ENCODING, ""enc3"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""enc3"", method.getResponseBodyAsString());
-         Assert.assertEquals(""enc3"", method.getResponseHeader(HttpHeaderNames.CONTENT_ENCODING).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/encoding""));
+      request.header(HttpHeaderNames.ACCEPT_ENCODING, ""enc3"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc3"", response.getEntity());
+      Assert.assertEquals(""enc3"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_ENCODING));
    }
 
    @Test
-   public void testGetEncodingQ() throws IOException
+   public void testGetEncodingQ() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/encoding"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_ENCODING, ""enc1;q=0.5, enc2;q=0.9"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""enc2"", method.getResponseBodyAsString());
-         Assert.assertEquals(""enc2"", method.getResponseHeader(HttpHeaderNames.CONTENT_ENCODING).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/encoding""));
+      request.header(HttpHeaderNames.ACCEPT_ENCODING, ""enc1;q=0.5, enc2;q=0.9"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc2"", response.getEntity());
+      Assert.assertEquals(""enc2"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_ENCODING));
    }
 
    @Test
-   public void testGetEncodingQ2() throws IOException
+   public void testGetEncodingQ2() throws Exception
    {
-      HttpClient client = new HttpClient();
-      GetMethod method = createGetMethod(""/encoding"");
-      method.addRequestHeader(HttpHeaderNames.ACCEPT_ENCODING, ""enc1;q=0, enc2;q=0.888, enc3;q=0.889"");
-      try
-      {
-         int status = client.executeMethod(method);
-         Assert.assertEquals(status, HttpResponseCodes.SC_OK);
-         Assert.assertEquals(""enc3"", method.getResponseBodyAsString());
-         Assert.assertEquals(""enc3"", method.getResponseHeader(HttpHeaderNames.CONTENT_ENCODING).getValue());
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
-      method.releaseConnection();
+      ClientRequest request = new ClientRequest(generateURL(""/encoding""));
+      request.header(HttpHeaderNames.ACCEPT_ENCODING, ""enc1;q=0, enc2;q=0.888, enc3;q=0.889"");
+      ClientResponse<String> response = request.get(String.class);
+      Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());;
+      Assert.assertEquals(""enc3"", response.getEntity());
+      Assert.assertEquals(""enc3"", response.getHeaders().getFirst(HttpHeaderNames.CONTENT_ENCODING));
    }
 
    private boolean contains(String l, String v)",2011-11-02T20:21:10Z,109
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.test.finegrain.resource;
 
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.methods.GetMethod;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.core.Dispatcher;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -14,8 +14,6 @@
 import javax.ws.rs.Path;
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
-
 import static org.jboss.resteasy.test.TestPortProvider.*;
 
 /**
@@ -59,27 +57,23 @@ public static void after() throws Exception
       EmbeddedContainer.stop();
    }
 
-   private void _test(HttpClient client, String path, int code)
+   private void _test(String path, int code)
    {
+      ClientRequest request = new ClientRequest(generateURL(path));
+      try
+      {
+         ClientResponse<?> response = request.get();
+         Assert.assertEquals(code, response.getStatus());
+      } catch (Exception e)
       {
-         GetMethod method = createGetMethod(path);
-         try
-         {
-            int status = client.executeMethod(method);
-            Assert.assertEquals(status, code);
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(e);
-         }
+         throw new RuntimeException(e);
       }
-
    }
 
    @Test
    public void testException()
    {
-      _test(new HttpClient(), ""/exception"", HttpResponseCodes.SC_UNAUTHORIZED);
+      _test(""/exception"", HttpResponseCodes.SC_UNAUTHORIZED);
    }
 
    /**
@@ -88,7 +82,7 @@ public void testException()
    @Test
    public void testExceptionWithEntity()
    {
-      _test(new HttpClient(), ""/exception/entity"", HttpResponseCodes.SC_UNAUTHORIZED);
+      _test(""/exception/entity"", HttpResponseCodes.SC_UNAUTHORIZED);
    }
 
 }",2011-11-02T20:21:10Z,110
"@@ -1,155 +1,180 @@
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
-   <parent>
-      <groupId>org.resteasy</groupId>
-      <artifactId>resteasy-jaxrs-all</artifactId>
-      <version>1.0</version>
-   </parent>
-   <modelVersion>4.0.0</modelVersion>
-   <groupId>org.resteasy</groupId>
-   <artifactId>resteasy-jaxrs</artifactId>
-   <packaging>jar</packaging>
-   <version>${resteasy-version}</version>
-   <name>Resteasy JAX-RS Implementation</name>
-   <url>http://maven.apache.org</url>
-   <repositories>
-      <repository>
-         <id>jakarta</id>
-         <url>http://jakarta.apache.org/commons/httpclient/</url>
-      </repository>
-      <repository>
-         <id>jboss</id>
-         <url>http://repository.jboss.org/maven2</url>
-      </repository>
-      <repository>
-         <id>java.net</id>
-         <url>
-            https://maven-repository.dev.java.net/nonav/repository
-         </url>
-         <layout>legacy</layout>
-      </repository>
-      <repository>
-         <id>scannotation</id>
-         <url>http://scannotation.sf.net/maven2</url>
-      </repository>
-      <repository>
-         <id>codehaus</id>
-         <url>http://repository.codehaus.org</url>
-      </repository>
-      <repository>
-         <id>maven2-repository.dev.java.net</id>
-         <name>Java.net Repository for Maven</name>
-         <url>http://download.java.net/maven/2/</url>
-         <layout>default</layout>
-      </repository>
-      <repository>
-         <id>ibiblio mirror</id>
-         <url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url>
-      </repository>
-   </repositories>
-   <dependencies>
-      <dependency>
-         <groupId>junit</groupId>
-         <artifactId>junit</artifactId>
-         <version>4.1</version>
-         <scope>test</scope>
-      </dependency>
-      <dependency>
-         <groupId>com.sun.xml.bind</groupId>
-         <artifactId>jaxb-impl</artifactId>
-         <version>2.1.2</version>
-      </dependency>
-      <dependency>
-         <groupId>org.codehaus.jettison</groupId>
-         <artifactId>jettison</artifactId>
-         <version>1.0</version>
-      </dependency>
-      <dependency>
-         <groupId>org.resteasy</groupId>
-         <artifactId>jaxrs-api</artifactId>
-         <version>1.0-beta-6</version>
-      </dependency>
-      <dependency>
-         <groupId>javax.servlet</groupId>
-         <artifactId>servlet-api</artifactId>
-         <version>2.5</version>
-         <scope>provided</scope>
-      </dependency>
-      <dependency>
-         <groupId>javax.annotation</groupId>
-         <artifactId>jsr250-api</artifactId>
-         <version>1.0</version>
-      </dependency>
-      <dependency>
-         <groupId>commons-httpclient</groupId>
-         <artifactId>commons-httpclient</artifactId>
-         <version>3.1</version>
-      </dependency>
-      <dependency>
-         <groupId>tjws</groupId>
-         <artifactId>webserver</artifactId>
-         <version>1.3.3</version>
-      </dependency>
-      <dependency>
-         <groupId>org.scannotation</groupId>
-         <artifactId>scannotation</artifactId>
-         <version>1.0.2</version>
-      </dependency>
-      <dependency>
-         <groupId>javassist</groupId>
-         <artifactId>javassist</artifactId>
-         <version>3.6.0.GA</version>
-      </dependency>
-      <dependency>
-         <groupId>org.springframework</groupId>
-         <artifactId>spring</artifactId>
-         <version>2.5.1</version>
-         <scope>provided</scope>
-      </dependency>
-      <dependency>
-         <groupId>com.sun.grizzly</groupId>
-         <artifactId>grizzly-http-webserver</artifactId>
-         <version>1.7.2</version>
-         <scope>provided</scope>
-      </dependency>
-      <dependency>
-         <groupId>com.sun.grizzly</groupId>
-         <artifactId>grizzly-http-servlet</artifactId>
-         <version>1.7.2</version>
-         <scope>provided</scope>
-      </dependency>
-      <dependency>
-         <groupId>com.sun.grizzly</groupId>
-         <artifactId>grizzly-comet</artifactId>
-         <version>1.7.2</version>
-         <scope>provided</scope>
-      </dependency>
-   </dependencies>
-   <build>
-      <plugins>
-         <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-compiler-plugin</artifactId>
-            <configuration>
-               <source>1.5</source>
-               <target>1.5</target>
-            </configuration>
-         </plugin>
-         <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-install-plugin</artifactId>
-            <configuration>
-               <createChecksum>true</createChecksum>
-            </configuration>
-         </plugin>
-      </plugins>
-   </build>
-   <reporting>
-      <plugins>
-         <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-         </plugin>
-      </plugins>
-   </reporting>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+	<parent>
+		<groupId>org.resteasy</groupId>
+		<artifactId>resteasy-jaxrs-all</artifactId>
+		<version>1.0</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<groupId>org.resteasy</groupId>
+	<artifactId>resteasy-jaxrs</artifactId>
+	<packaging>jar</packaging>
+	<version>${resteasy-version}</version>
+	<name>Resteasy JAX-RS Implementation</name>
+	<url>http://maven.apache.org</url>
+	<licenses>
+		<license>
+			<name>GNU LESSER GENERAL PUBLIC LICENSE</name>
+			<url>http://www.gnu.org/licenses/lgpl.txt</url>
+			<distribution>repo</distribution>
+		</license>
+	</licenses>
+	<repositories>
+		<repository>
+			<id>jakarta</id>
+			<url>http://jakarta.apache.org/commons/httpclient/</url>
+		</repository>
+		<repository>
+			<id>jboss</id>
+			<url>http://repository.jboss.org/maven2</url>
+		</repository>
+		<repository>
+			<id>java.net</id>
+			<url>
+				https://maven-repository.dev.java.net/nonav/repository
+			</url>
+			<layout>legacy</layout>
+		</repository>
+		<repository>
+			<id>scannotation</id>
+			<url>http://scannotation.sf.net/maven2</url>
+		</repository>
+		<repository>
+			<id>codehaus</id>
+			<url>http://repository.codehaus.org</url>
+		</repository>
+		<repository>
+			<id>maven2-repository.dev.java.net</id>
+			<name>Java.net Repository for Maven</name>
+			<url>http://download.java.net/maven/2/</url>
+			<layout>default</layout>
+		</repository>
+		<repository>
+			<id>ibiblio mirror</id>
+			<url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url>
+		</repository>
+	</repositories>
+	<dependencies>
+		<dependency>
+			<groupId>junit</groupId>
+			<artifactId>junit</artifactId>
+			<version>4.4</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.sun.xml.bind</groupId>
+			<artifactId>jaxb-impl</artifactId>
+			<version>2.1.2</version>
+		</dependency>
+		<dependency>
+			<groupId>org.codehaus.jettison</groupId>
+			<artifactId>jettison</artifactId>
+			<version>1.0</version>
+		</dependency>
+		<dependency>
+			<groupId>org.resteasy</groupId>
+			<artifactId>jaxrs-api</artifactId>
+			<version>1.0-beta-6</version>
+		</dependency>
+		<dependency>
+			<groupId>javax.servlet</groupId>
+			<artifactId>servlet-api</artifactId>
+			<version>2.5</version>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>javax.annotation</groupId>
+			<artifactId>jsr250-api</artifactId>
+			<version>1.0</version>
+		</dependency>
+		<dependency>
+			<groupId>commons-httpclient</groupId>
+			<artifactId>commons-httpclient</artifactId>
+			<version>3.1</version>
+		</dependency>
+		<dependency>
+			<groupId>tjws</groupId>
+			<artifactId>webserver</artifactId>
+			<version>1.3.3</version>
+		</dependency>
+		<dependency>
+			<groupId>org.scannotation</groupId>
+			<artifactId>scannotation</artifactId>
+			<version>1.0.2</version>
+		</dependency>
+		<dependency>
+			<groupId>javassist</groupId>
+			<artifactId>javassist</artifactId>
+			<version>3.6.0.GA</version>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework</groupId>
+			<artifactId>spring</artifactId>
+			<version>2.5.1</version>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.sun.grizzly</groupId>
+			<artifactId>grizzly-http-webserver</artifactId>
+			<version>1.7.2</version>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.sun.grizzly</groupId>
+			<artifactId>grizzly-http-servlet</artifactId>
+			<version>1.7.2</version>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.sun.grizzly</groupId>
+			<artifactId>grizzly-comet</artifactId>
+			<version>1.7.2</version>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>javax.mail</groupId>
+			<artifactId>mail</artifactId>
+			<version>1.4</version>
+			<scope>provided</scope>
+		</dependency>
+	</dependencies>
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<configuration>
+					<source>1.5</source>
+					<target>1.5</target>
+				</configuration>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-install-plugin</artifactId>
+				<configuration>
+					<createChecksum>true</createChecksum>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
+	<reporting>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-javadoc-plugin</artifactId>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>
+					maven-project-info-reports-plugin
+				</artifactId>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-surefire-report-plugin</artifactId>
+				
+			</plugin>
+		</plugins>
+	</reporting>
 </project>",2008-06-24T02:18:48Z,111
"@@ -53,8 +53,9 @@
           -->
 
         <module-def name=""org.bouncycastle"">
-            <maven-resource group=""org.bouncycastle"" artifact=""bcprov-jdk16""/>
-            <maven-resource group=""org.bouncycastle"" artifact=""bcmail-jdk16""/>
+            <maven-resource group=""org.bouncycastle"" artifact=""bcprov-jdk15on""/>
+            <maven-resource group=""org.bouncycastle"" artifact=""bcmail-jdk15on""/>
+            <maven-resource group=""org.bouncycastle"" artifact=""bcpkix-jdk15on""/>
         </module-def>
 
         <module-def name=""org.codehaus.jackson.jackson-core-asl"">",2015-07-10T13:34:32Z,112
"@@ -53,8 +53,8 @@
           -->
 
         <module-def name=""org.bouncycastle"">
-            <maven-resource group=""org.bouncycastle"" artifact=""bcprov-jdk16""/>
-            <maven-resource group=""org.bouncycastle"" artifact=""bcmail-jdk16""/>
+            <maven-resource group=""org.bouncycastle"" artifact=""bcprov-jdk15on""/>
+            <maven-resource group=""org.bouncycastle"" artifact=""bcmail-jdk15on""/>
         </module-def>
 
         <module-def name=""org.codehaus.jackson.jackson-core-asl"">",2015-07-10T13:34:32Z,113
"@@ -40,7 +40,11 @@
     <dependencies>
         <dependency>
             <groupId>org.bouncycastle</groupId>
-            <artifactId>bcprov-jdk16</artifactId>
+            <artifactId>bcprov-jdk15on</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcmail-jdk15on</artifactId>
         </dependency>
         <dependency>
             <groupId>org.codehaus.jackson</groupId>
@@ -86,10 +90,6 @@
           <groupId>com.fasterxml.jackson.module</groupId>
           <artifactId>jackson-module-jaxb-annotations</artifactId>
         </dependency>
-        <dependency>
-            <groupId>org.bouncycastle</groupId>
-            <artifactId>bcmail-jdk16</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.jboss.resteasy</groupId>
             <artifactId>jaxrs-api</artifactId>",2015-07-10T13:34:32Z,114
"@@ -24,10 +24,15 @@
 
 <module xmlns=""urn:jboss:module:1.1"" name=""org.bouncycastle"">
     <resources>
+        <resource-root path=""bcprov-jdk15on-1.52.jar""/>
+        <resource-root path=""bcmail-jdk15on-1.52.jar""/>
+        <resource-root path=""bcpkix-jdk15on-1.52.jar""/>
         <!-- Insert resources here -->
     </resources>
     <dependencies>
         <module name=""javax.api""/>
+        <module name=""javax.mail.api"" optional=""true""/>
+        <module name=""javax.activation.api"" optional=""true""/>
     </dependencies>
 
 </module>",2015-07-10T13:34:32Z,115
"@@ -34,6 +34,7 @@
         <module name=""javax.servlet.api""/>
         <module name=""javax.ws.rs.api""/>
         <module name=""org.jboss.resteasy.resteasy-jaxrs""/>
-        <module name=""org.bouncycastle"" export=""true""/>
+        <module name=""org.bouncycastle""/>
+        <module name=""javax.activation.api""/>
     </dependencies>
 </module>",2015-07-10T13:34:32Z,116
"@@ -18,6 +18,7 @@
         <dep.commons-io.version>2.1</dep.commons-io.version>
         <dep.hibernate-validator.version>5.1.0.Final</dep.hibernate-validator.version>
         <dep.javax.persistence.version>1.0.1.Final</dep.javax.persistence.version>
+        <dep.javax.activation.version>1.1.1</dep.javax.activation.version>
         <dep.spring-webmvc.version>3.0.6.RELEASE</dep.spring-webmvc.version>
         <dep.snakeyaml.version>1.8</dep.snakeyaml.version>
         <dep.cdi-api.version>1.1</dep.cdi-api.version>
@@ -26,6 +27,8 @@
         <dep.netty.version>3.6.4.Final</dep.netty.version>
         <dep.netty4.version>4.0.7.Final</dep.netty4.version>
         <dep.slf4j.version>1.7.5</dep.slf4j.version>
+        <dep.bc.version>1.52</dep.bc.version>
+        <dep.com.sun.mail.version>1.5.3</dep.com.sun.mail.version>
         <version.org.hibernate.javax.persistence.hibernate-jpa-2.1-api>1.0.0.Final</version.org.hibernate.javax.persistence.hibernate-jpa-2.1-api>
         <version.org.jboss.spec.javax.el.jboss-el-api_3.0_spec>1.0.0.Final</version.org.jboss.spec.javax.el.jboss-el-api_3.0_spec>
         <version.org.jboss.spec.javax.servlet.jboss-servlet-api_3.1_spec>1.0.0.Final</version.org.jboss.spec.javax.servlet.jboss-servlet-api_3.1_spec>
@@ -168,7 +171,11 @@
                 <artifactId>jaxb-impl</artifactId>
                 <version>${dep.jaxb-impl.version}</version>
             </dependency>
-
+            <dependency>
+                <groupId>com.sun.mail</groupId>
+                <artifactId>javax.mail</artifactId>
+                <version>${dep.com.sun.mail.version}</version>
+            </dependency>
             <dependency>
                 <groupId>com.sun.xml.stream</groupId>
                 <artifactId>sjsxp</artifactId>
@@ -223,7 +230,7 @@
             <dependency>
                 <groupId>javax.activation</groupId>
                 <artifactId>activation</artifactId>
-                <version>1.1</version>
+                <version>${dep.javax.activation.version}</version>
             </dependency>
 
             <dependency>
@@ -352,13 +359,18 @@
             </dependency>
             <dependency>
                 <groupId>org.bouncycastle</groupId>
-                <artifactId>bcprov-jdk16</artifactId>
-                <version>1.46</version>
+                <artifactId>bcprov-jdk15on</artifactId>
+                <version>${dep.bc.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.bouncycastle</groupId>
+                <artifactId>bcmail-jdk15on</artifactId>
+                <version>${dep.bc.version}</version>
             </dependency>
             <dependency>
                 <groupId>org.bouncycastle</groupId>
-                <artifactId>bcmail-jdk16</artifactId>
-                <version>1.46</version>
+                <artifactId>bcpkix-jdk15on</artifactId>
+                <version>${dep.bc.version}</version>
             </dependency>
             <dependency>
                 <groupId>net.oauth.core</groupId>",2015-07-10T13:34:32Z,117
"@@ -33,7 +33,7 @@
         </dependency>
         <dependency>
             <groupId>org.bouncycastle</groupId>
-            <artifactId>bcprov-jdk16</artifactId>
+            <artifactId>bcprov-jdk15on</artifactId>
         </dependency>
         <dependency>
             <groupId>org.jboss.resteasy</groupId>",2015-07-10T13:34:32Z,118
"@@ -80,6 +80,14 @@
             <version>${project.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcprov-jdk15on</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcmail-jdk15on</artifactId>
+        </dependency>
     </dependencies>
     <build>
         <plugins>",2015-07-10T13:34:32Z,119
"@@ -1,13 +1,16 @@
 package org.jboss.resteasy.test.keystone;
 
 import junit.framework.Assert;
-import org.bouncycastle.cms.CMSException;
-import org.bouncycastle.cms.CMSProcessable;
-import org.bouncycastle.cms.CMSProcessableByteArray;
-import org.bouncycastle.cms.CMSSignedData;
-import org.bouncycastle.cms.CMSSignedDataGenerator;
-import org.bouncycastle.cms.SignerInformation;
+import org.bouncycastle.cert.jcajce.JcaCertStore;
+import org.bouncycastle.cms.*;
+import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
+import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.operator.ContentSigner;
+import org.bouncycastle.operator.OperatorCreationException;
+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
+import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
+import org.bouncycastle.util.Store;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
 import org.jboss.resteasy.keystone.client.SkeletonKeyAdminClient;
@@ -49,10 +52,9 @@
 import java.security.Security;
 import java.security.cert.CertStore;
 import java.security.cert.CertStoreException;
+import java.security.cert.CertificateEncodingException;
 import java.security.cert.X509Certificate;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
 import static org.jboss.resteasy.test.TestPortProvider.generateBaseUrl;
 import static org.jboss.resteasy.test.TestPortProvider.generateURL;
@@ -267,21 +269,26 @@ public void testCMD() throws Exception
       System.out.println(""Base64.size: "" + Base64.encodeBytes(signed).length());
 
       SignerInformation signer = (SignerInformation)data.getSignerInfos().getSigners().iterator().next();
-      System.out.println(""valid: "" + signer.verify(cert, ""BC""));
+      System.out.println(""valid: "" + signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert.getPublicKey())));
       client.close();
 
 
    }
 
 
-   private static byte[] p7s(PrivateKey priv, X509Certificate storecert, CertStore certs, byte[] contentbytes) throws CertStoreException, CMSException, NoSuchAlgorithmException, NoSuchProviderException, IOException
-   {
+   private static byte[] p7s(PrivateKey priv, X509Certificate storecert, CertStore certs, byte[] contentbytes) throws CertStoreException, CMSException, NoSuchAlgorithmException, NoSuchProviderException, IOException, OperatorCreationException, CertificateEncodingException {
       CMSSignedDataGenerator signGen = new CMSSignedDataGenerator();
-      signGen.addSigner(priv, (X509Certificate)storecert, CMSSignedDataGenerator.DIGEST_SHA512);
-      //signGen.addCertificatesAndCRLs(certs);
-      CMSProcessable content = new CMSProcessableByteArray(contentbytes);
+      ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(priv);
+
+      signGen.addSignerInfoGenerator(
+              new JcaSignerInfoGeneratorBuilder(
+                      new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
+                      .build(sha1Signer, storecert));
+
+      CMSTypedData content = new CMSProcessableByteArray(contentbytes);
+
+      CMSSignedData signedData = signGen.generate(content, true);
 
-      CMSSignedData signedData = signGen.generate(content, true, ""BC"");
       return signedData.getEncoded();
    }
 ",2015-07-10T13:34:32Z,37
"@@ -52,15 +52,15 @@
         </dependency>
         <dependency>
             <groupId>org.bouncycastle</groupId>
-            <artifactId>bcprov-jdk16</artifactId>
+            <artifactId>bcprov-jdk15on</artifactId>
         </dependency>
         <dependency>
            <groupId>org.bouncycastle</groupId>
-           <artifactId>bcmail-jdk16</artifactId>
+           <artifactId>bcmail-jdk15on</artifactId>
         </dependency>
         <dependency>
-            <groupId>javax.mail</groupId>
-            <artifactId>mail</artifactId>
+            <groupId>com.sun.mail</groupId>
+            <artifactId>javax.mail</artifactId>
         </dependency>
         <dependency>
             <groupId>org.apache.james</groupId>",2015-07-10T13:34:32Z,120
"@@ -2,6 +2,8 @@
 
 import org.bouncycastle.cms.RecipientInformation;
 import org.bouncycastle.cms.RecipientInformationStore;
+import org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient;
+import org.bouncycastle.cms.jcajce.JceKeyTransRecipient;
 import org.bouncycastle.cms.jcajce.JceKeyTransRecipientId;
 import org.bouncycastle.mail.smime.SMIMEEnveloped;
 import org.bouncycastle.mail.smime.SMIMEUtil;
@@ -158,8 +160,9 @@ public Object getEntity(Class t, Type gt, Annotation[] ann, PrivateKey pKey, X50
 
          RecipientInformationStore recipients = m.getRecipientInfos();
          RecipientInformation recipient = recipients.get(recId);
+         JceKeyTransRecipient pKeyRecp = new JceKeyTransEnvelopedRecipient(pKey);
 
-         decrypted = SMIMEUtil.toMimeBodyPart(recipient.getContent(pKey, ""BC""));
+         decrypted = SMIMEUtil.toMimeBodyPart(recipient.getContent(pKeyRecp));
       }
       catch (Exception e1)
       {",2015-07-10T13:34:32Z,121
"@@ -2,6 +2,7 @@
 
 import org.bouncycastle.cms.SignerInformation;
 import org.bouncycastle.cms.SignerInformationStore;
+import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
 import org.bouncycastle.mail.smime.SMIMESigned;
 import org.jboss.resteasy.util.GenericType;
 
@@ -157,7 +158,7 @@ public boolean verify(PublicKey publicKey) throws Exception
 
       SignerInformationStore signers = signed.getSignerInfos();
       SignerInformation signer = (SignerInformation) signers.getSigners().iterator().next();
-      return signer.verify(publicKey, ""BC"");
+      return (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(publicKey)));
 
    }
 ",2015-07-10T13:34:32Z,54
"@@ -3,6 +3,8 @@
 import org.bouncycastle.cms.CMSException;
 import org.bouncycastle.cms.CMSSignedData;
 import org.bouncycastle.cms.SignerInformation;
+import org.bouncycastle.cms.SignerInformationVerifier;
+import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.util.Base64;
 import org.jboss.resteasy.util.GenericType;
@@ -206,7 +208,9 @@ public boolean verify(X509Certificate certificate) throws Exception
       for (Object info : data.getSignerInfos().getSigners())
       {
          SignerInformation signer = (SignerInformation)info;
-         if (signer.verify(certificate, ""BC""))
+
+
+         if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(certificate)))
          {
             return true;
          }
@@ -218,7 +222,7 @@ public boolean verify(PublicKey publicKey) throws Exception
       for (Object info : data.getSignerInfos().getSigners())
       {
          SignerInformation signer = (SignerInformation)info;
-         if (signer.verify(publicKey, ""BC""))
+         if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(publicKey)))
          {
             return true;
          }",2015-07-10T13:34:32Z,122
"@@ -1,10 +1,13 @@
 package org.jboss.resteasy.security.smime;
 
-import org.bouncycastle.cms.CMSException;
-import org.bouncycastle.cms.CMSProcessable;
-import org.bouncycastle.cms.CMSProcessableByteArray;
-import org.bouncycastle.cms.CMSSignedData;
-import org.bouncycastle.cms.CMSSignedDataGenerator;
+import org.bouncycastle.cert.jcajce.JcaCertStore;
+import org.bouncycastle.cms.*;
+import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
+import org.bouncycastle.operator.ContentSigner;
+import org.bouncycastle.operator.OperatorCreationException;
+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
+import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
+import org.bouncycastle.util.Store;
 import org.jboss.resteasy.security.BouncyIntegration;
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.spi.WriterException;
@@ -24,6 +27,7 @@
 import java.lang.reflect.Type;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
+import java.security.cert.CertificateEncodingException;
 import java.security.cert.X509Certificate;
 
 /**
@@ -70,8 +74,7 @@ public void writeTo(SignedOutput out, Class<?> type, Type genericType, Annotatio
       }
    }
 
-   public static byte[] sign(Providers providers, SignedOutput out) throws IOException, NoSuchAlgorithmException, NoSuchProviderException, CMSException
-   {
+   public static byte[] sign(Providers providers, SignedOutput out) throws IOException, NoSuchAlgorithmException, NoSuchProviderException, CMSException, OperatorCreationException, CertificateEncodingException {
       ByteArrayOutputStream bodyOs = new ByteArrayOutputStream();
       MessageBodyWriter writer = providers.getMessageBodyWriter(out.getType(), out.getGenericType(), null, out.getMediaType());
       if (writer == null)
@@ -82,11 +85,19 @@ public static byte[] sign(Providers providers, SignedOutput out) throws IOExcept
       bodyHeaders.add(""Content-Type"",  out.getMediaType().toString());
       writer.writeTo(out.getEntity(), out.getType(), out.getGenericType(), null, out.getMediaType(), bodyHeaders, bodyOs);
       CMSSignedDataGenerator signGen = new CMSSignedDataGenerator();
-      signGen.addSigner(out.getPrivateKey(), (X509Certificate)out.getCertificate(), CMSSignedDataGenerator.DIGEST_SHA1);
-      //signGen.addCertificatesAndCRLs(certs);
-      CMSProcessable content = new CMSProcessableByteArray(bodyOs.toByteArray());
 
-      CMSSignedData signedData = signGen.generate(content, true, ""BC"");
+
+      ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(out.getPrivateKey());
+
+      signGen.addSignerInfoGenerator(
+                              new JcaSignerInfoGeneratorBuilder(
+                                   new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build())
+                           .build(sha1Signer, out.getCertificate()));
+
+      CMSTypedData content = new CMSProcessableByteArray(bodyOs.toByteArray());
+
+      CMSSignedData signedData = signGen.generate(content, true);
+
       return signedData.getEncoded();
    }
 }",2015-07-10T13:34:32Z,123
"@@ -6,9 +6,7 @@
 import org.bouncycastle.cms.RecipientId;
 import org.bouncycastle.cms.RecipientInformation;
 import org.bouncycastle.cms.RecipientInformationStore;
-import org.bouncycastle.cms.jcajce.JceCMSContentEncryptorBuilder;
-import org.bouncycastle.cms.jcajce.JceKeyTransRecipientId;
-import org.bouncycastle.cms.jcajce.JceKeyTransRecipientInfoGenerator;
+import org.bouncycastle.cms.jcajce.*;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.mail.smime.SMIMEEnveloped;
 import org.bouncycastle.mail.smime.SMIMEEnvelopedGenerator;
@@ -129,7 +127,8 @@ public void testHeaders()
       OutputEncryptor encryptor = new JceCMSContentEncryptorBuilder(CMSAlgorithm.DES_EDE3_CBC)
               .setProvider(""BC"")
               .build();
-      gen.addKeyTransRecipient(cert);
+
+      gen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator(cert).setProvider(""BC""));
 
       //
       // generate a MimeBodyPart object which encapsulates the content
@@ -218,8 +217,9 @@ private MimeBodyPart decode2Mime(MimeBodyPart mp) throws MessagingException, CMS
 
       RecipientInformationStore recipients = m.getRecipientInfos();
       RecipientInformation recipient = recipients.get(recId);
+      JceKeyTransRecipient pKeyRecp = new JceKeyTransEnvelopedRecipient(privateKey);
 
-      return SMIMEUtil.toMimeBodyPart(recipient.getContent(privateKey, ""BC""));
+      return SMIMEUtil.toMimeBodyPart(recipient.getContent(pKeyRecp));
    }
 
 ",2015-07-10T13:34:32Z,124
"@@ -4,6 +4,7 @@
 import org.bouncycastle.cms.SignerInformation;
 import org.bouncycastle.cms.SignerInformationStore;
 import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoGeneratorBuilder;
+import org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.mail.smime.SMIMESigned;
 import org.bouncycastle.mail.smime.SMIMESignedGenerator;
@@ -135,7 +136,7 @@ public void testPythonSigned() throws Exception
       SignerInformationStore signers = signed.getSignerInfos();
       Assert.assertEquals(1, signers.size());
       SignerInformation signer = (SignerInformation) signers.getSigners().iterator().next();
-      Assert.assertTrue(signer.verify(cert.getPublicKey(), ""BC""));
+      Assert.assertTrue(signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(""BC"").build(cert.getPublicKey())));
    }
 
    @Test",2015-07-10T13:34:32Z,125
"@@ -46,6 +46,19 @@
             <artifactId>junit</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcprov-jdk15on</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcmail-jdk15on</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jackson-provider</artifactId>
+            <version>${project.version}</version>
+        </dependency>
     </dependencies>
     <build>
         <plugins>",2015-07-10T13:34:32Z,126
"@@ -170,27 +170,31 @@ public ResteasyClient register(Object component, Map<Class<?>, Integer> contract
    public ResteasyWebTarget target(String uri) throws IllegalArgumentException, NullPointerException
    {
       abortIfClosed();
+      if (uri == null) throw new NullPointerException(""uri was null"");
       return new ClientWebTarget(this, uri, configuration);
    }
 
    @Override
    public ResteasyWebTarget target(URI uri) throws NullPointerException
    {
       abortIfClosed();
+      if (uri == null) throw new NullPointerException(""uri was null"");
       return new ClientWebTarget(this, uri, configuration);
    }
 
    @Override
    public ResteasyWebTarget target(UriBuilder uriBuilder) throws NullPointerException
    {
       abortIfClosed();
+      if (uriBuilder == null) throw new NullPointerException(""uriBuilder was null"");
       return new ClientWebTarget(this, uriBuilder, configuration);
    }
 
    @Override
    public ResteasyWebTarget target(Link link) throws NullPointerException
    {
       abortIfClosed();
+      if (link == null) throw new NullPointerException(""link was null"");
       URI uri = link.getUri();
       return new ClientWebTarget(this, uri, configuration);
    }
@@ -199,6 +203,7 @@ public ResteasyWebTarget target(Link link) throws NullPointerException
    public Invocation.Builder invocation(Link link) throws NullPointerException, IllegalArgumentException
    {
       abortIfClosed();
+      if (link == null) throw new NullPointerException(""link was null"");
       WebTarget target = target(link);
       return target.request(link.getType());
    }",2013-05-07T22:47:36Z,55
"@@ -419,7 +419,12 @@ public ResteasyClientBuilder withConfig(Configuration config)
       for (Class clazz : config.getClasses())
       {
          Map<Class<?>, Integer> contracts = config.getContracts(clazz);
-         register(clazz, contracts);
+         try {
+            register(clazz, contracts);
+         }
+         catch (RuntimeException e) {
+            throw new RuntimeException(""failed on registering class: "" + clazz.getName(), e);
+         }
       }
       for (Object obj : config.getInstances())
       {",2013-05-07T22:47:36Z,55
"@@ -76,6 +76,7 @@ public <T> T proxy(Class<T> proxyInterface)
    public <T> ProxyBuilder<T> proxyBuilder(Class<T> proxyInterface)
    {
       client.abortIfClosed();
+      if (proxyInterface == null) throw new NullPointerException(""proxyInterface was null"");
       return ProxyBuilder.builder(proxyInterface, this);
    }
 
@@ -104,6 +105,7 @@ public Configuration getConfiguration()
    public ResteasyWebTarget path(String path) throws NullPointerException
    {
       client.abortIfClosed();
+      if (path == null) throw new NullPointerException(""path was null"");
       UriBuilder copy = uriBuilder.clone().path(path);
       return  new ClientWebTarget(client, copy, configuration);
    }
@@ -112,6 +114,7 @@ public ResteasyWebTarget path(String path) throws NullPointerException
    public ResteasyWebTarget path(Class<?> resource) throws IllegalArgumentException
    {
       client.abortIfClosed();
+      if (resource == null) throw new NullPointerException(""resource was null"");
       UriBuilder copy = uriBuilder.clone().path(resource);
       return  new ClientWebTarget(client, copy, configuration);
    }
@@ -120,6 +123,7 @@ public ResteasyWebTarget path(Class<?> resource) throws IllegalArgumentException
    public ResteasyWebTarget path(Method method) throws IllegalArgumentException
    {
       client.abortIfClosed();
+      if (method == null) throw new NullPointerException(""method was null"");
       UriBuilder copy = uriBuilder.clone().path(method);
       return  new ClientWebTarget(client, copy, configuration);
    }
@@ -128,6 +132,8 @@ public ResteasyWebTarget path(Method method) throws IllegalArgumentException
    public ResteasyWebTarget resolveTemplate(String name, Object value) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
+      if (value == null) throw new NullPointerException(""value was null"");
       String val = configuration.toString(value);
       UriBuilder copy = uriBuilder.resolveTemplate(name, val);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
@@ -138,6 +144,7 @@ public ResteasyWebTarget resolveTemplate(String name, Object value) throws NullP
    public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues) throws NullPointerException
    {
       client.abortIfClosed();
+      if (templateValues == null) throw new NullPointerException(""templateValues was null"");
       Map vals = new HashMap<String, String>();
       for (Map.Entry<String, Object> entry : templateValues.entrySet())
       {
@@ -153,6 +160,8 @@ public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues) th
    public ResteasyWebTarget resolveTemplate(String name, Object value, boolean encodeSlashInPath) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
+      if (value == null) throw new NullPointerException(""value was null"");
       String val = configuration.toString(value);
       UriBuilder copy = uriBuilder.resolveTemplate(name, val, encodeSlashInPath);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
@@ -163,6 +172,8 @@ public ResteasyWebTarget resolveTemplate(String name, Object value, boolean enco
    public ResteasyWebTarget resolveTemplateFromEncoded(String name, Object value) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
+      if (value == null) throw new NullPointerException(""value was null"");
       String val = configuration.toString(value);
       UriBuilder copy = uriBuilder.resolveTemplateFromEncoded(name, val);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
@@ -173,6 +184,7 @@ public ResteasyWebTarget resolveTemplateFromEncoded(String name, Object value) t
    public ResteasyWebTarget resolveTemplatesFromEncoded(Map<String, Object> templateValues) throws NullPointerException
    {
       client.abortIfClosed();
+      if (templateValues == null) throw new NullPointerException(""templateValues was null"");
       Map vals = new HashMap<String, String>();
       for (Map.Entry<String, Object> entry : templateValues.entrySet())
       {
@@ -188,6 +200,7 @@ public ResteasyWebTarget resolveTemplatesFromEncoded(Map<String, Object> templat
    public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues, boolean encodeSlashInPath) throws NullPointerException
    {
       client.abortIfClosed();
+      if (templateValues == null) throw new NullPointerException(""templateValues was null"");
       Map vals = new HashMap<String, String>();
       for (Map.Entry<String, Object> entry : templateValues.entrySet())
       {
@@ -203,6 +216,7 @@ public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues, bo
    public ResteasyWebTarget matrixParam(String name, Object... values) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
       String[] stringValues = toStringValues(values);
       UriBuilder copy = uriBuilder.clone().matrixParam(name, stringValues);
       return  new ClientWebTarget(client, copy, configuration);
@@ -222,6 +236,7 @@ private String[] toStringValues(Object[] values)
    public ResteasyWebTarget queryParam(String name, Object... values) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
       String[] stringValues = toStringValues(values);
       UriBuilder copy = uriBuilder.clone().queryParam(name, stringValues);
       return  new ClientWebTarget(client, copy, configuration);
@@ -231,6 +246,7 @@ public ResteasyWebTarget queryParam(String name, Object... values) throws NullPo
    public ResteasyWebTarget queryParams(MultivaluedMap<String, Object> parameters) throws IllegalArgumentException, NullPointerException
    {
       client.abortIfClosed();
+      if (parameters == null) throw new NullPointerException(""parameters was null"");
       UriBuilder copy = uriBuilder.clone();
       for (Map.Entry<String, List<Object>> entry : parameters.entrySet())
       {
@@ -244,6 +260,7 @@ public ResteasyWebTarget queryParams(MultivaluedMap<String, Object> parameters)
    public ResteasyWebTarget queryParamNoTemplate(String name, Object... values) throws NullPointerException
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
       String[] stringValues = toStringValues(values);
       ResteasyUriBuilder copy = (ResteasyUriBuilder)uriBuilder.clone();
       for (String obj : stringValues)
@@ -257,6 +274,7 @@ public ResteasyWebTarget queryParamNoTemplate(String name, Object... values) thr
    public ResteasyWebTarget queryParamsNoTemplate(MultivaluedMap<String, Object> parameters) throws IllegalArgumentException, NullPointerException
    {
       client.abortIfClosed();
+      if (parameters == null) throw new NullPointerException(""parameters was null"");
       ResteasyUriBuilder copy = (ResteasyUriBuilder)uriBuilder.clone();
       for (Map.Entry<String, List<Object>> entry : parameters.entrySet())
       {
@@ -298,6 +316,8 @@ public Invocation.Builder request(MediaType... acceptedResponseTypes)
    public ResteasyWebTarget property(String name, Object value)
    {
       client.abortIfClosed();
+      if (name == null) throw new NullPointerException(""name was null"");
+      if (value == null) throw new NullPointerException(""value was null"");
       configuration.property(name, value);
       return this;
    }",2013-05-07T22:47:36Z,127
"@@ -0,0 +1,25 @@
+package org.jboss.resteasy.test.client;
+
+import org.junit.Test;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Configuration;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ClientBuilderTest
+{
+   @Test
+   public void testBuilder() throws Exception
+   {
+      String property = ""prop"";
+      Client client = ClientBuilder.newClient();
+      client.property(property, property);
+      Configuration config = client.getConfiguration();
+      client = ClientBuilder.newClient(config);
+
+   }
+}",2013-05-07T22:47:36Z,128
"@@ -50,6 +50,8 @@ public UriBuilder clone()
       return impl;
    }
 
+   private static final Pattern uri2Pattern = Pattern.compile(""^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"");
+   private static final Pattern hostPortPattern = Pattern.compile(""([^/:]+):(\\d+)"");
    private static final Pattern uriPattern = Pattern.compile(""([a-zA-Z0-9+.-]+)://([^/:]+)(:(\\d+))?(/[^?]*)?(\\?([^#]+))?(#(.*))?"");
    private static final Pattern sspPattern = Pattern.compile(""([^:/]+):(.+)"");
    private static final Pattern pathPattern = Pattern.compile(""([^?]*)?(\\?([^#]+))?(#(.*))?"");
@@ -112,46 +114,51 @@ public static UriBuilder fromTemplate(String uriTemplate)
     */
    public UriBuilder uriTemplate(String uriTemplate)
    {
-      Matcher match = uriPattern.matcher(uriTemplate);
+      Matcher match = uri2Pattern.matcher(uriTemplate);
       if (match.matches())
       {
-         scheme(match.group(1));
-         String host = match.group(2);
-         if (host != null)
+         boolean scheme = match.group(2) != null;
+         if (scheme) scheme(match.group(2));
+         boolean authority = match.group(4) != null;
+         if (authority)
          {
+            String host = match.group(4);
             int at = host.indexOf('@');
             if (at > -1)
             {
                String user = host.substring(0, at);
                host = host.substring(at + 1);
                userInfo(user);
             }
+            Matcher hostPortMatch = hostPortPattern.matcher(host);
+            if (hostPortMatch.matches())
+            {
+               host(hostPortMatch.group(1));
+               int val = 0;
+               try {
+                  val = Integer.parseInt(hostPortMatch.group(2));
+               }
+               catch (NumberFormatException e) {
+                  throw new IllegalArgumentException(""Illegal uri template: "" + uriTemplate, e);
+               }
+               port(val);
+            }
+            else
+            {
+               host(host);
+            }
+         }
+         if (match.group(5) != null)
+         {
+            String group = match.group(5);
+            if (!scheme && !"""".equals(group) && !group.startsWith(""/"") && group.indexOf(':') > -1) throw new IllegalArgumentException(""Illegal uri template: "" + uriTemplate);
+            path(group);
          }
-         host(host);
-         if (match.group(4) != null) port(Integer.valueOf(match.group(4)));
-         if (match.group(5) != null) path(match.group(5));
          if (match.group(7) != null) replaceQuery(match.group(7));
          if (match.group(9) != null) fragment(match.group(9));
          return this;
       }
-      match = sspPattern.matcher(uriTemplate);
-      if (match.matches())
-      {
-         scheme(match.group(1));
-         schemeSpecificPart(match.group(2));
-         return this;
-      }
-
-      match = pathPattern.matcher(uriTemplate);
-      if (match.matches())
-      {
-         if (match.group(1) != null) path(match.group(1));
-         if (match.group(3) != null) replaceQuery(match.group(3));
-         if (match.group(5) != null) fragment(match.group(5));
-         return this;
-      }
-      throw new RuntimeException(""Illegal uri template: "" + uriTemplate);
-
+      throw new IllegalArgumentException(""Illegal uri template: "" + uriTemplate);
    }
 
    @Override",2013-05-07T22:47:36Z,67
"@@ -1206,7 +1206,7 @@ public void registerProvider(Class provider, boolean isBuiltin, int defaultPrior
          {
             clientRequestFilters = parent.getClientRequestFilters().clone(this);
          }
-         clientRequestFilters.registerClass(provider, getPriority(contracts, defaultPriority, ClientResponseFilter.class));
+         clientRequestFilters.registerClass(provider, getPriority(contracts, defaultPriority, ClientRequestFilter.class));
          newContracts.put(ClientRequestFilter.class, getPriority(provider));
       }
       if (isA(provider, ClientResponseFilter.class, contracts))",2013-05-07T22:47:36Z,25
"@@ -13,6 +13,8 @@
 import java.net.URI;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -26,6 +28,54 @@ public static void before()
       ResteasyProviderFactory.setInstance(new ResteasyProviderFactory());
    }
 
+   @Test
+   public void testExceptions()
+   {
+      try
+      {
+         UriBuilder builder = UriBuilder.fromUri("":cts:8080//tck:90090//jaxrs "");
+         Assert.fail();
+      }
+      catch (IllegalArgumentException e) {
+
+      }
+   }
+
+   @Test
+   public void testUrn()
+   {
+      UriBuilder builder = UriBuilder.fromUri(""urn:isbn:096139210x"");
+   }
+
+
+   private static final Pattern uriPattern = Pattern.compile(""([a-zA-Z0-9+.-]+)://([^/:]+)(:(\\d+))?(/[^?]*)?(\\?([^#]+))?(#(.*))?"");
+   private static final Pattern uri2Pattern = Pattern.compile(""^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"");
+
+   @Test
+   public void testParse()
+   {
+      String[] uris = {
+              "":cts:8080//tck:90090//jaxrs ""
+      };
+      for (String uri : uris)
+      {
+         printParse(uri);
+      }
+   }
+
+
+   public void printParse(String uri)
+   {
+      System.out.println(""--- "" + uri);
+      Matcher match = uri2Pattern.matcher(uri);
+      if (!match.matches()) throw new IllegalStateException(""no match found"");
+      for (int i = 1; i < match.groupCount() + 1; i++)
+      {
+         System.out.println(""group["" + i + ""] = '"" + match.group(i) + ""'"");
+      }
+
+   }
+
    @Test
    public void testTemplate() throws Exception
    {",2013-05-07T22:47:36Z,129
"@@ -20,6 +20,21 @@
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <!-- filter out unwanted jars -->
+            <exclusions>
+                <exclusion>
+                    <groupId>commons-httpclient</groupId>
+                    <artifactId>commons-httpclient</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>javax.servlet</groupId>
+                    <artifactId>servlet-api</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
         <dependency>
             <groupId>org.mortbay.jetty</groupId>
             <artifactId>jetty</artifactId>",2010-03-19T22:13:35Z,130
"@@ -1,5 +1,5 @@
 #HSQL Database Engine 1.8.0.5
-#Tue Mar 02 11:45:46 EST 2010
+#Fri Mar 19 17:18:28 EDT 2010
 hsqldb.script_format=0
 runtime.gc_interval=0
 sql.enforce_strict_size=false",2010-03-19T22:13:35Z,131
"@@ -1,5 +1,5 @@
 #HSQL Database Engine 1.8.0.5
-#Tue Mar 02 11:45:34 EST 2010
+#Fri Mar 19 17:18:20 EDT 2010
 hsqldb.script_format=0
 runtime.gc_interval=0
 sql.enforce_strict_size=false",2010-03-19T22:13:35Z,132
"@@ -122,6 +122,7 @@ public static UriBuilder fromUri(String uri) throws IllegalArgumentException
     */
    public static UriBuilder fromPath(String path) throws IllegalArgumentException
    {
+      if (path == null) throw new IllegalArgumentException(""path parameter is null"");
       UriBuilder b = newInstance();
       b.replacePath(path);
       return b;",2010-03-19T22:13:35Z,133
"@@ -59,9 +59,9 @@ private static String extractURI(URL url)
       if (url.getHost() != null) buffer.append(url.getHost());
       if (url.getPort() != -1 && url.getPort() != 80) buffer.append("":"").append(Integer.toString(url.getPort()));
       if (url.getPath() != null)
-         buffer.append(Encode.encodePath(url.getPath(), false).replace(""%3B"", "";"").replace(""%3D"", ""=""));
+         buffer.append(Encode.encodePath(url.getPath()));
       if (url.getQuery() != null) buffer.append(""?"").append(url.getQuery());
-      if (url.getRef() != null) buffer.append(""#"").append(Encode.encodeSegment(url.getRef(), false));
+      if (url.getRef() != null) buffer.append(""#"").append(Encode.encodeFragment(url.getRef()));
       String buf = buffer.toString();
       return buf;
    }",2010-03-19T22:13:35Z,17
"@@ -176,13 +176,15 @@ public UriBuilder userInfo(String ui)
    public UriBuilder host(String host) throws IllegalArgumentException
    {
       if (host == null) throw new IllegalArgumentException(""schemeSpecificPart was null"");
+      if (host.equals("""")) throw new IllegalArgumentException(""invalid host"");
       this.host = host;
       return this;
    }
 
    @Override
    public UriBuilder port(int port) throws IllegalArgumentException
    {
+      if (port < -1) throw new IllegalArgumentException(""Invalid port value"");
       this.port = port;
       return this;
    }
@@ -194,11 +196,32 @@ protected static String paths(boolean encode, String basePath, String... segment
       for (String segment : segments)
       {
          if ("""".equals(segment)) continue;
-         if (!path.endsWith(""/"")) path += ""/"";
-         if (segment.equals(""/"")) continue;
-         if (segment.startsWith(""/"")) segment = segment.substring(1);
-         if (encode) segment = Encode.encodePath(segment, true);
-         path += segment;
+         if (path.endsWith(""/""))
+         {
+            if (segment.startsWith(""/""))
+            {
+               segment = segment.substring(1);
+               if ("""".equals(segment)) continue;
+            }
+            if (encode) segment = Encode.encodePath(segment);
+            path += segment;
+         }
+         else
+         {
+            if (encode) segment = Encode.encodePath(segment);
+            if ("""".equals(path))
+            {
+               path = segment;
+            }
+            else if (segment.startsWith(""/""))
+            {
+               path += segment;
+            }
+            else
+            {
+               path += ""/"" + segment;
+            }
+         }
 
       }
       return path;
@@ -236,14 +259,19 @@ public UriBuilder path(Class resource, String method) throws IllegalArgumentExce
    {
       if (resource == null) throw new IllegalArgumentException(""resource was null"");
       if (method == null) throw new IllegalArgumentException(""method was null"");
+      Method theMethod = null;
       for (Method m : resource.getMethods())
       {
          if (m.getName().equals(method))
          {
-            return path(m);
+            if (theMethod != null && m.isAnnotationPresent(Path.class))
+            {
+               throw new IllegalArgumentException(""there are two method named "" + method);
+            }
+            if (m.isAnnotationPresent(Path.class)) theMethod = m;
          }
       }
-      return this;
+      return path(theMethod);
    }
 
    @Override
@@ -255,6 +283,10 @@ public UriBuilder path(Method method) throws IllegalArgumentException
       {
          path = paths(true, path, ann.value());
       }
+      else
+      {
+         throw new IllegalArgumentException(""method is not annotated with @Path"");
+      }
       return this;
    }
 
@@ -282,14 +314,19 @@ public UriBuilder replaceMatrix(String matrix) throws IllegalArgumentException
    @Override
    public UriBuilder replaceQuery(String query) throws IllegalArgumentException
    {
-      this.query = query;
+      if (query == null)
+      {
+         this.query = null;
+         return this;
+      }
+      this.query = Encode.encodeQueryString(query);
       return this;
    }
 
    @Override
    public UriBuilder fragment(String fragment) throws IllegalArgumentException
    {
-      this.fragment = Encode.encodeSegment(fragment, true);
+      this.fragment = Encode.encodeFragment(fragment);
       return this;
    }
 
@@ -306,7 +343,7 @@ public UriBuilder substitutePathParam(String name, Object value, boolean isEncod
       if (path != null)
       {
          StringBuffer buffer = new StringBuffer();
-         replaceParameter(name, value.toString(), isEncoded, path, buffer);
+         replacePathParameter(name, value.toString(), isEncoded, path, buffer);
          path = buffer.toString();
       }
       return this;
@@ -324,32 +361,42 @@ public URI buildFromEncodedMap(Map<String, ? extends Object> values) throws Ille
       return buildFromMap(values, true);
    }
 
-   public URI buildFromMap(Map<String, ? extends Object> paramMap, boolean isEncoded) throws IllegalArgumentException, UriBuilderException
+   public URI buildFromMap(Map<String, ? extends Object> paramMap, boolean fromEncodedMap) throws IllegalArgumentException, UriBuilderException
    {
       StringBuffer buffer = new StringBuffer();
 
-      if (scheme != null) replaceParameter(paramMap, isEncoded, scheme, buffer).append("":"");
+      if (scheme != null) replaceParameter(paramMap, fromEncodedMap, scheme, buffer).append("":"");
       if (ssp != null)
       {
          buffer.append(ssp);
       }
       else if (userInfo != null || host != null || port != -1)
       {
          buffer.append(""//"");
-         if (userInfo != null) replaceParameter(paramMap, isEncoded, userInfo, buffer).append(""@"");
-         if (host != null) replaceParameter(paramMap, isEncoded, host, buffer);
+         if (userInfo != null) replaceParameter(paramMap, fromEncodedMap, userInfo, buffer).append(""@"");
+         if (host != null) replaceParameter(paramMap, fromEncodedMap, host, buffer);
          if (port != -1) buffer.append("":"").append(Integer.toString(port));
       }
-      if (path != null) replaceParameter(paramMap, isEncoded, path, buffer);
+      if (path != null)
+      {
+         StringBuffer tmp = new StringBuffer();
+         replaceParameter(paramMap, fromEncodedMap, path, tmp);
+         String tmpPath = tmp.toString();
+         if (userInfo != null || host != null)
+         {
+            if (!tmpPath.startsWith(""/"")) buffer.append(""/"");
+         }
+         buffer.append(tmpPath);
+      }
       if (query != null)
       {
          buffer.append(""?"");
-         replaceQueryStringParameter(paramMap, isEncoded, query, buffer);
+         replaceQueryStringParameter(paramMap, fromEncodedMap, query, buffer);
       }
       if (fragment != null)
       {
          buffer.append(""#"");
-         replaceParameter(paramMap, isEncoded, fragment, buffer);
+         replaceParameter(paramMap, fromEncodedMap, fragment, buffer);
       }
       String buf = buffer.toString();
       try
@@ -362,7 +409,7 @@ else if (userInfo != null || host != null || port != -1)
       }
    }
 
-   protected StringBuffer replaceParameter(String name, String value, boolean isEncoded, String string, StringBuffer buffer)
+   protected StringBuffer replacePathParameter(String name, String value, boolean isEncoded, String string, StringBuffer buffer)
    {
       Matcher matcher = createUriParamMatcher(string);
       while (matcher.find())
@@ -371,7 +418,10 @@ protected StringBuffer replaceParameter(String name, String value, boolean isEnc
          if (!param.equals(name)) continue;
          if (!isEncoded)
          {
-            value = Encode.encodeSegment(value, false);
+            value = Encode.encodePath(value);
+         }
+         else
+         {
             value = Encode.encodeNonCodes(value);
          }
          matcher.appendReplacement(buffer, value);
@@ -386,19 +436,27 @@ protected Matcher createUriParamMatcher(String string)
       return matcher;
    }
 
-   protected StringBuffer replaceParameter(Map<String, ? extends Object> paramMap, boolean isEncoded, String string, StringBuffer buffer)
+   protected StringBuffer replaceParameter(Map<String, ? extends Object> paramMap, boolean fromEncodedMap, String string, StringBuffer buffer)
    {
       Matcher matcher = createUriParamMatcher(string);
       while (matcher.find())
       {
          String param = matcher.group(1);
-         String value = paramMap.get(param).toString();
+         Object valObj = paramMap.get(param);
+         if (valObj == null)
+         {
+            throw new IllegalArgumentException(""NULL value for template parameter: "" + param);
+         }
+         String value = valObj.toString();
          if (value != null)
          {
-            if (!isEncoded)
+            if (!fromEncodedMap)
             {
-               value = Encode.encodeSegment(value, false);
-               value = Encode.encodeNonCodes(value);
+               value = Encode.encodePathAsIs(value);
+            }
+            else
+            {
+               value = Encode.encodePathSaveEncodings(value);
             }
             matcher.appendReplacement(buffer, value);
          }
@@ -411,7 +469,7 @@ protected StringBuffer replaceParameter(Map<String, ? extends Object> paramMap,
       return buffer;
    }
 
-   protected StringBuffer replaceQueryStringParameter(Map<String, ? extends Object> paramMap, boolean isEncoded, String string, StringBuffer buffer)
+   protected StringBuffer replaceQueryStringParameter(Map<String, ? extends Object> paramMap, boolean fromEncodedMap, String string, StringBuffer buffer)
    {
       Matcher matcher = createUriParamMatcher(string);
       while (matcher.find())
@@ -420,9 +478,13 @@ protected StringBuffer replaceQueryStringParameter(Map<String, ? extends Object>
          String value = paramMap.get(param).toString();
          if (value != null)
          {
-            if (!isEncoded)
+            if (!fromEncodedMap)
+            {
+               value = Encode.encodeQueryParamAsIs(value);
+            }
+            else
             {
-               value = Encode.encodeQueryStringNameOrValue(value);
+               value = Encode.encodeQueryParamSaveEncodings(value);
             }
             matcher.appendReplacement(buffer, value);
          }
@@ -480,16 +542,15 @@ protected URI buildFromValues(boolean encoded, Object... values)
       List<String> params = getPathParamNamesInDeclarationOrder();
       if (values.length < params.size())
          throw new IllegalArgumentException(""You did not supply enough values to fill path parameters"");
-      if (values.length > params.size()) throw new IllegalArgumentException(""You provided too many values"");
 
       Map<String, Object> pathParams = new HashMap<String, Object>();
 
-      int i = 0;
 
-      for (Object val : values)
+      for (int i = 0; i < params.size(); i++)
       {
+         String pathParam = params.get(i);
+         Object val = values[i];
          if (val == null) throw new IllegalArgumentException(""A value was null"");
-         String pathParam = params.get(i++);
          pathParams.put(pathParam, val.toString());
       }
       return buildFromMap(pathParams, encoded);
@@ -501,7 +562,7 @@ public UriBuilder matrixParam(String name, Object... values) throws IllegalArgum
       if (path == null) path = """";
       for (Object val : values)
       {
-         path += "";"" + Encode.encodeSegment(name, false) + ""="" + Encode.encodeSegment(val.toString(), true);
+         path += "";"" + Encode.encodeMatrixParam(name) + ""="" + Encode.encodeMatrixParam(val.toString());
       }
       return this;
    }
@@ -587,11 +648,14 @@ public UriBuilder replaceMatrixParam(String name, Object... values) throws Illeg
    @Override
    public UriBuilder queryParam(String name, Object... values) throws IllegalArgumentException
    {
+      if (name == null) throw new IllegalArgumentException(""name parameter is null"");
+      if (values == null) throw new IllegalArgumentException(""values parameter is null"");
       for (Object value : values)
       {
+         if (value == null) throw new IllegalArgumentException(""A passed in value was null"");
          if (query == null) query = """";
          else query += ""&"";
-         query += Encode.encodeQueryStringNameOrValue(name) + ""="" + Encode.encodeQueryStringNameOrValue(value.toString());
+         query += Encode.encodeQueryParam(name) + ""="" + Encode.encodeQueryParam(value.toString());
       }
       return this;
    }
@@ -604,7 +668,7 @@ public UriBuilder replaceQueryParam(String name, Object... values) throws Illega
       String[] params = query.split(""&"");
       query = null;
 
-      String replacedName = Encode.encodeSegment(name, false);
+      String replacedName = Encode.encodeQueryParam(name);
 
       for (String param : params)
       {
@@ -627,6 +691,8 @@ public UriBuilder replaceQueryParam(String name, Object... values) throws Illega
             query += param;
          }
       }
+      // don't set values if values is null
+      if (values == null) return this;
       return queryParam(name, values);
    }
 
@@ -668,9 +734,11 @@ public String getFragment()
    @Override
    public UriBuilder segment(String... segments) throws IllegalArgumentException
    {
+      if (segments == null) throw new IllegalArgumentException(""segments parameter was null"");
       for (String segment : segments)
       {
-         path(Encode.encodeSegment(segment, true));
+         if (segment == null) throw new IllegalArgumentException(""A segment is null"");
+         path(Encode.encodePathSegment(segment));
       }
       return this;
    }
@@ -684,8 +752,12 @@ public URI buildFromEncoded(Object... values) throws IllegalArgumentException, U
    @Override
    public UriBuilder replacePath(String path)
    {
-      if (path == null) throw new IllegalArgumentException(""path was null"");
-      this.path = Encode.encodePath(path, true);
+      if (path == null)
+      {
+         this.path = null;
+         return this;
+      }
+      this.path = Encode.encodePath(path);
       return this;
    }
 ",2010-03-19T22:13:35Z,67
"@@ -1,5 +1,7 @@
 package org.jboss.resteasy.specimpl;
 
+import org.jboss.resteasy.util.Encode;
+
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
@@ -24,7 +26,7 @@ public class UriInfoImpl implements UriInfo
    private MultivaluedMap<String, String> encodedPathParameters;
    private MultivaluedMap<String, PathSegment[]> pathParameterPathSegments;
    private MultivaluedMap<String, PathSegment[]> encodedPathParameterPathSegments;
-   
+
    private List<PathSegment> pathSegments;
    private List<PathSegment> encodedPathSegments;
    private URI absolutePath;
@@ -45,14 +47,7 @@ public UriInfoImpl(URI absolutePath, URI baseUri, String encodedPath, String que
       }
       */
       this.encodedPath = encodedPath;
-      try
-      {
-         this.path = URLDecoder.decode(encodedPath, ""UTF-8"");
-      }
-      catch (UnsupportedEncodingException e)
-      {
-         throw new RuntimeException(e);
-      }
+      this.path = Encode.decodePath(encodedPath);
       //System.out.println(""path: "" + path);
       //System.out.println(""encodedPath: "" + encodedPath);
 
@@ -64,16 +59,9 @@ public UriInfoImpl(URI absolutePath, URI baseUri, String encodedPath, String que
       this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       for (PathSegment segment : encodedPathSegments)
       {
-         try
-         {
-            pathSegments.add(new PathSegmentImpl(URLDecoder.decode(((PathSegmentImpl) segment).getOriginal(), ""UTF-8"")));
-         }
-         catch (UnsupportedEncodingException e)
-         {
-            throw new RuntimeException(e);
-         }
+         pathSegments.add(new PathSegmentImpl(Encode.decodePath(((PathSegmentImpl) segment).getOriginal())));
       }
-      if (queryString == null) 
+      if (queryString == null)
       {
          this.absolutePathWithQueryString = absolutePath;
       }
@@ -139,7 +127,7 @@ public UriBuilder getBaseUriBuilder()
 
    public MultivaluedMap<String, String> getPathParameters()
    {
-      if( pathParameters == null )
+      if (pathParameters == null)
       {
          pathParameters = new MultivaluedMapImpl<String, String>();
       }
@@ -149,15 +137,8 @@ public MultivaluedMap<String, String> getPathParameters()
    public void addEncodedPathParameter(String name, String value)
    {
       getEncodedPathParameters().add(name, value);
-      try
-      {
-         String value1 = URLDecoder.decode(value, ""UTF-8"");
-         getPathParameters().add(name, value1);
-      }
-      catch (UnsupportedEncodingException e)
-      {
-         throw new RuntimeException(e);
-      }
+      String value1 = Encode.decodePath(value);
+      getPathParameters().add(name, value1);
    }
 
    private MultivaluedMap<String, String> getEncodedPathParameters()
@@ -171,7 +152,7 @@ private MultivaluedMap<String, String> getEncodedPathParameters()
 
    public MultivaluedMap<String, PathSegment[]> getEncodedPathParameterPathSegments()
    {
-      if( encodedPathParameterPathSegments == null)
+      if (encodedPathParameterPathSegments == null)
       {
          encodedPathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
       }
@@ -180,7 +161,7 @@ public MultivaluedMap<String, PathSegment[]> getEncodedPathParameterPathSegments
 
    public MultivaluedMap<String, PathSegment[]> getPathParameterPathSegments()
    {
-      if( pathParameterPathSegments == null)
+      if (pathParameterPathSegments == null)
       {
          pathParameterPathSegments = new MultivaluedMapImpl<String, PathSegment[]>();
       }
@@ -195,7 +176,7 @@ public MultivaluedMap<String, String> getPathParameters(boolean decode)
 
    public MultivaluedMap<String, String> getQueryParameters()
    {
-      if( queryParameters == null)
+      if (queryParameters == null)
       {
          queryParameters = new MultivaluedMapImpl<String, String>();
       }
@@ -204,14 +185,14 @@ public MultivaluedMap<String, String> getQueryParameters()
 
    protected MultivaluedMap<String, String> getEncodedQueryParameters()
    {
-      if( encodedQueryParameters == null )
+      if (encodedQueryParameters == null)
       {
          this.encodedQueryParameters = new MultivaluedMapImpl<String, String>();
       }
       return encodedQueryParameters;
    }
-   
-   
+
+
    public MultivaluedMap<String, String> getQueryParameters(boolean decode)
    {
       if (decode) return getQueryParameters();
@@ -318,8 +299,4 @@ public void popMatchedURI()
       }
    }
 
-   public String getConnegExtension()
-   {
-      throw new RuntimeException(""NOT IMPLEMENTED YET"");
-   }
 }",2010-03-19T22:13:35Z,4
"@@ -59,11 +59,14 @@ public class ResteasyDeployment
 
    public void start()
    {
-      
-      providerFactory = ResteasyProviderFactory.getInstance();
+      // it is very important that each deployment create their own provider factory
+      // this allows each WAR to have their own set of providers 
       if (providerFactory == null) providerFactory = new ResteasyProviderFactory();
       if (deploymentSensitiveFactoryEnabled)
       {
+         // the ThreadLocalResteasyProviderFactory pushes and pops this deployments providerFactory
+         // on a ThreadLocal stack.  This allows each application/WAR to have their own providerFactory
+         // and still be able to call ResteasyProviderFactory.getInstance()
          if (!(providerFactory instanceof ThreadLocalResteasyProviderFactory))
          {
             ResteasyProviderFactory.setInstance(new ThreadLocalResteasyProviderFactory(providerFactory));
@@ -139,13 +142,13 @@ public void start()
          {
             throw new RuntimeException(e);
          }
-         
+
          ConstructorInjector constructorInjector = providerFactory.getInjectorFactory().createConstructor(clazz.getConstructors()[0]);
          PropertyInjector propertyInjector = providerFactory.getInjectorFactory().createPropertyInjector(clazz);
-         
+
          application = (Application) constructorInjector.construct();
          propertyInjector.inject(application);
-         
+
       }
 
       // register all providers
@@ -268,7 +271,7 @@ else if (clazz.isAnnotationPresent(Provider.class))
             }
             else
             {
-               throw new RuntimeException(""Application.getClasses() returned unknown class type: "" + clazz.getName());
+               logger.warn(""Application.getClasses() returned unknown class type: "" + clazz.getName());
             }
          }
       }
@@ -287,7 +290,7 @@ else if (obj.getClass().isAnnotationPresent(Provider.class))
             }
             else
             {
-               throw new RuntimeException(""Application.getSingletons() returned unknown class type: "" + obj.getClass().getName());
+               logger.warn(""Application.getSingletons() returned unknown class type: "" + obj.getClass().getName());
             }
          }
       }",2010-03-19T22:13:35Z,134
"@@ -20,89 +20,213 @@ public class Encode
 {
    private static final Pattern PARAM_REPLACEMENT = Pattern.compile(""_resteasy_uri_parameter"");
 
-   /**
-    * Keep encoded values ""%..."", matrix parameters, and '/' characters intact.
-    *
-    * @param value
-    * @return
-    * @Param params whether or not to encode stuff between '{' and '}' false means don't encode
-    */
-   public static String encodePath(String value, boolean ignorePathParams)
+   private static final String[] pathEncoding = new String[128];
+   private static final String[] pathSegmentEncoding = new String[128];
+   private static final String[] matrixParameterEncoding = new String[128];
+   private static final String[] queryNameValueEncoding = new String[128];
+   private static final String[] queryStringEncoding = new String[128];
+
+   static
    {
-      ArrayList<String> params = new ArrayList<String>();
-      boolean foundParam = false;
-      if (ignorePathParams)
+      /*
+       * Encode via <a href=""http://ietf.org/rfc/rfc3986.txt"">RFC 3986</a>.  PCHAR is allowed allong with '/'
+       *
+       * unreserved  = ALPHA / DIGIT / ""-"" / ""."" / ""_"" / ""~""
+       * sub-delims  = ""!"" / ""$"" / ""&"" / ""'"" / ""("" / "")""
+                     / ""*"" / ""+"" / "","" / "";"" / ""=""
+       * pchar = unreserved / pct-encoded / sub-delims / "":"" / ""@""
+       *
+       */
+      for (int i = 0; i < 128; i++)
       {
-         StringBuffer newPath = new StringBuffer();
-         if (savePathParams(value, newPath, params))
+         if (i >= 'a' && i <= 'z') continue;
+         if (i >= 'A' && i <= 'Z') continue;
+         if (i >= '0' && i <= '9') continue;
+         switch ((char) i)
          {
-            foundParam = true;
-            value = newPath.toString();
+            case '-':
+            case '.':
+            case '_':
+            case '~':
+            case '!':
+            case '$':
+            case '&':
+            case '\'':
+            case '(':
+            case ')':
+            case '*':
+            case '+':
+            case ',':
+            case '/':
+            case ';':
+            case '=':
+            case ':':
+            case '@':
+               continue;
          }
-
+         StringBuffer sb = new StringBuffer();
+         sb.append((char) i);
+         pathEncoding[i] = URLEncoder.encode(sb.toString());
       }
-      String[] segments = value.split(""/"");
-      StringBuilder buffer = new StringBuilder();
-      boolean first = true;
-      for (String segment : segments)
+      pathEncoding[' '] = ""%20"";
+      System.arraycopy(pathEncoding, 0, matrixParameterEncoding, 0, pathEncoding.length);
+      matrixParameterEncoding[';'] = ""%3B"";
+      matrixParameterEncoding['='] = ""%3D"";
+      System.arraycopy(pathEncoding, 0, pathSegmentEncoding, 0, pathEncoding.length);
+      pathSegmentEncoding['/'] = ""%2F"";
+      /*
+       * Encode via <a href=""http://ietf.org/rfc/rfc3986.txt"">RFC 3986</a>.
+       *
+       * unreserved  = ALPHA / DIGIT / ""-"" / ""."" / ""_"" / ""~""
+       * space encoded as '+'
+       *
+       */
+      for (int i = 0; i < 128; i++)
       {
-         if (!first)
+         if (i >= 'a' && i <= 'z') continue;
+         if (i >= 'A' && i <= 'Z') continue;
+         if (i >= '0' && i <= '9') continue;
+         switch ((char) i)
          {
-            buffer.append(""/"");
+            case '-':
+            case '.':
+            case '_':
+            case '~':
+            case '?':
+               continue;
+            case ' ':
+               queryNameValueEncoding[i] = ""+"";
+               continue;
          }
-         segment = encodeSegment(segment, ignorePathParams);
-         buffer.append(segment);
-         first = false;
+         StringBuffer sb = new StringBuffer();
+         sb.append((char) i);
+         queryNameValueEncoding[i] = URLEncoder.encode(sb.toString());
       }
-      String result = buffer.toString();
-      if (value.endsWith(""/"")) result += ""/"";
 
-      if (ignorePathParams && foundParam)
+      /*
+       * query       = *( pchar / ""/"" / ""?"" )
+
+       */
+      for (int i = 0; i < 128; i++)
       {
-         result = pathParamReplacement(result, params);
+         if (i >= 'a' && i <= 'z') continue;
+         if (i >= 'A' && i <= 'Z') continue;
+         if (i >= '0' && i <= '9') continue;
+         switch ((char) i)
+         {
+            case '-':
+            case '.':
+            case '_':
+            case '~':
+            case '!':
+            case '$':
+            case '&':
+            case '\'':
+            case '(':
+            case ')':
+            case '*':
+            case '+':
+            case ',':
+            case ';':
+            case '=':
+            case ':':
+            case '@':
+            case '?':
+            case '/':
+               continue;
+            case ' ':
+               queryStringEncoding[i] = ""%20"";
+               continue;
+         }
+         StringBuffer sb = new StringBuffer();
+         sb.append((char) i);
+         queryStringEncoding[i] = URLEncoder.encode(sb.toString());
       }
+   }
 
-      return result;
+   /**
+    * Keep encoded values ""%..."" and template parameters intact.
+    */
+   public static String encodeQueryString(String value)
+   {
+      return encodeValue(value, queryStringEncoding);
+   }
+
+   /**
+    * Keep encoded values ""%..."", matrix parameters, template parameters, and '/' characters intact.
+    */
+   public static String encodePath(String value)
+   {
+      return encodeValue(value, pathEncoding);
+   }
+
+   /**
+    * Keep encoded values ""%..."", matrix parameters and template parameters intact.
+    */
+   public static String encodePathSegment(String value)
+   {
+      return encodeValue(value, pathSegmentEncoding);
+   }
+
+   /**
+    * Keep encoded values ""%..."" and template parameters intact.
+    */
+   public static String encodeFragment(String value)
+   {
+      return encodeValue(value, queryNameValueEncoding);
+   }
+
+   /**
+    * Keep encoded values ""%..."" and template parameters intact.
+    */
+   public static String encodeMatrixParam(String value)
+   {
+      return encodeValue(value, matrixParameterEncoding);
+   }
+
+   /**
+    * Keep encoded values ""%..."" and template parameters intact.
+    */
+   public static String encodeQueryParam(String value)
+   {
+      return encodeValue(value, queryNameValueEncoding);
    }
 
    private static final Pattern nonCodes = Pattern.compile(""%([^a-fA-F0-9]|$)"");
+   private static final Pattern encodedChars = Pattern.compile(""%([a-fA-F0-9][a-fA-F0-9])"");
 
-   public static String encodeNonCodes(String string)
+   public static String decodePath(String path)
    {
-      Matcher matcher = nonCodes.matcher(string);
+      Matcher matcher = encodedChars.matcher(path);
       StringBuffer buf = new StringBuffer();
       while (matcher.find())
       {
-         matcher.appendReplacement(buf, ""%25$1"");
+         String enc = matcher.group(1);
+         int c = Integer.parseInt(enc, 16);
+         StringBuffer cBuf = new StringBuffer();
+         cBuf.append((char) c);
+         matcher.appendReplacement(buf, cBuf.toString());
       }
       matcher.appendTail(buf);
       return buf.toString();
    }
 
-   public static String encodeQueryStringNameOrValue(String string)
+   /**
+    * Encode '%' if it is not an encoding sequence
+    *
+    * @param string
+    * @return
+    */
+   public static String encodeNonCodes(String string)
    {
+      Matcher matcher = nonCodes.matcher(string);
       StringBuffer buf = new StringBuffer();
-      List<String> params = new ArrayList<String>();
-      boolean foundParam = false;
-      if (savePathParams(string, buf, params))
-      {
-         foundParam = true;
-         string = buf.toString();
-      }
-      try
-      {
-         string = URLEncoder.encode(string, ""UTF-8"").replace(""%25"", ""%"");
-      }
-      catch (UnsupportedEncodingException e)
-      {
-         throw new RuntimeException(e);
-      }
-      string = encodeNonCodes(string);
-      if (foundParam)
+      while (matcher.find())
       {
-         return pathParamReplacement(string, params);
+         matcher.appendReplacement(buf, ""%25$1"");
       }
-      return string;
+      matcher.appendTail(buf);
+      return buf.toString();
    }
 
    private static boolean savePathParams(String segment, StringBuffer newSegment, List<String> params)
@@ -124,42 +248,111 @@ private static boolean savePathParams(String segment, StringBuffer newSegment, L
    }
 
    /**
-    * Keep encoded values ""%..."", matrix parameters, and '/' characters intact.
+    * Keep encoded values ""%..."" and template parameters intact i.e. ""{x}""
     *
     * @param segment
+    * @param encoding
     * @return
-    * @Param params whether or not to encode stuff between '{' and '}' false means don't encode
     */
-   public static String encodeSegment(String segment, boolean ignorePathParams)
+   public static String encodeValue(String segment, String[] encoding)
    {
       ArrayList<String> params = new ArrayList<String>();
       boolean foundParam = false;
-      if (ignorePathParams)
-      {
-         StringBuffer newSegment = new StringBuffer();
-         if (savePathParams(segment, newSegment, params))
-         {
-            foundParam = true;
-            segment = newSegment.toString();
-         }
-      }
-      String result;
-      try
-      {
-         result = URLEncoder.encode(segment, ""UTF-8"").replace(""+"", ""%20"").replace(""%3B"", "";"").replace(""%3D"", ""="").replace(""%25"", ""%"");
-      }
-      catch (UnsupportedEncodingException e)
+      StringBuffer newSegment = new StringBuffer();
+      if (savePathParams(segment, newSegment, params))
       {
-         throw new RuntimeException(e);
+         foundParam = true;
+         segment = newSegment.toString();
       }
+      String result = encodeFromArray(segment, encoding, false);
+      result = encodeNonCodes(result);
       segment = result;
-      if (ignorePathParams && foundParam)
+      if (foundParam)
       {
          segment = pathParamReplacement(segment, params);
       }
       return segment;
    }
 
+   /**
+    * Encode via <a href=""http://ietf.org/rfc/rfc3986.txt"">RFC 3986</a>.  PCHAR is allowed allong with '/'
+    * <p/>
+    * unreserved  = ALPHA / DIGIT / ""-"" / ""."" / ""_"" / ""~""
+    * sub-delims  = ""!"" / ""$"" / ""&"" / ""'"" / ""("" / "")""
+    * / ""*"" / ""+"" / "","" / "";"" / ""=""
+    * pchar = unreserved / pct-encoded / sub-delims / "":"" / ""@""
+    */
+   public static String encodePathAsIs(String segment)
+   {
+      return encodeFromArray(segment, pathEncoding, true);
+   }
+
+   /**
+    * Keep any valid encodings from string i.e. keep ""%2D"" but don't keep ""%p""
+    *
+    * @param segment
+    * @return
+    */
+   public static String encodePathSaveEncodings(String segment)
+   {
+      String result = encodeFromArray(segment, pathEncoding, false);
+      result = encodeNonCodes(result);
+      return result;
+   }
+
+   /**
+    * Encodes everything of a query parameter name or value.
+    *
+    * @param nameOrValue
+    * @return
+    */
+   public static String encodeQueryParamAsIs(String nameOrValue)
+   {
+      return encodeFromArray(nameOrValue, queryNameValueEncoding, true);
+   }
+
+   /**
+    * Keep any valid encodings from string i.e. keep ""%2D"" but don't keep ""%p""
+    *
+    * @param segment
+    * @return
+    */
+   public static String encodeQueryParamSaveEncodings(String segment)
+   {
+      String result = encodeFromArray(segment, queryNameValueEncoding, false);
+      result = encodeNonCodes(result);
+      return result;
+   }
+
+   public static String encodeFragmentAsIs(String nameOrValue)
+   {
+      return encodeFromArray(nameOrValue, queryNameValueEncoding, true);
+   }
+
+   protected static String encodeFromArray(String segment, String[] encodingMap, boolean encodePercent)
+   {
+      StringBuffer result = new StringBuffer();
+      for (int i = 0; i < segment.length(); i++)
+      {
+         if (!encodePercent && segment.charAt(i) == '%')
+         {
+            result.append(segment.charAt(i));
+            continue;
+         }
+         int idx = segment.charAt(i);
+         String encoding = encodingMap[idx];
+         if (encoding == null)
+         {
+            result.append(segment.charAt(i));
+         }
+         else
+         {
+            result.append(encoding);
+         }
+      }
+      return result.toString();
+   }
+
    private static String pathParamReplacement(String segment, List<String> params)
    {
       StringBuffer newSegment = new StringBuffer();
@@ -237,9 +430,4 @@ public static String decode(String string)
       }
    }
 
-   public static void main(String[] args) throws Exception
-   {
-      System.out.println(encodePath(""foo;bar={bar: .*};stuff={  stuff : .*}"", true));
-   }
-
 }",2010-03-19T22:13:35Z,43
"@@ -300,21 +300,11 @@ public void testClone()
       Assert.assertEquals(URI.create(""http://user@localhost:8080/a/b?query#fragment""), full);
    }
 
-   /**
-    * Regression test for RESTEASY-102
-    */
-   @Test
-   public void testResteasy102()
-   {
-      UriBuilder ub = UriBuilder.fromPath(""foo+bar"");
-      Assert.assertEquals(""foo%2Bbar"", ub.build().toString());
-
-   }
-
    /*
    * Create an UriBuilder instance using
    *                 uriBuilder.fromUri(String)
    */
+
    @Test
    public void FromUriTest3() throws Exception
    {
@@ -360,7 +350,7 @@ public void testEncoding() throws Exception
          map.put(""id"", ""something %%20something"");
 
          URI uri = impl.buildFromMap(map);
-         Assert.assertEquals(""/foo/something%20%25%20something"", uri.toString());
+         Assert.assertEquals(""/foo/something%20%25%2520something"", uri.toString());
       }
       {
          UriBuilderImpl impl = (UriBuilderImpl) UriBuilder.fromPath(""/foo/{id}"");
@@ -407,5 +397,491 @@ public void testQueryParamSubstitution() throws Exception
       UriBuilder.fromUri(""http://localhost/test"").queryParam(""a"", ""{b}"").build(""c"");
    }
 
+   /**
+    * Regression from TCK 1.1
+    */
+   @Test
+   public void testEncodedMap1() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%20yz"");
+      maps.put(""y"", ""/path-absolute/%test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+
+      String expected_path =
+              ""path-rootless/test2/x%20yz//path-absolute/%25test1/fred@example.com/x%20yz"";
+
+      uri = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"").
+              buildFromEncodedMap(maps);
+      if (uri.getRawPath().compareToIgnoreCase(expected_path) != 0)
+      {
+         pass = false;
+         sb.append(""Test failed for expected path: "" + expected_path +
+                 "" Got "" + uri.getRawPath() + "" instead\n"");
+      }
+      else
+      {
+         sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+      }
+
+      if (!pass)
+      {
+         System.out.println(sb.toString());
+      }
+      Assert.assertTrue(pass);
+   }
+
+   /**
+    * from TCK 1.1
+    */
+   @Test
+   public void testEncodedMapTest3() throws Exception
+   {
+      Map maps = new HashMap();
+      maps.put(""x"", null);
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+      maps.put(""u"", ""extra"");
+
+      String expected_path =
+              ""path-rootless/test2/x%yz//path-absolute/test1/fred@example.com/x%yz"";
+
+      try
+      {
+         URI uri = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"").
+                 buildFromEncodedMap(maps);
+         throw new Exception(""Test Failed: expected IllegalArgumentException not thrown"");
+      }
+      catch (IllegalArgumentException ex)
+      {
+      }
+   }
+
+   @Test
+   public void testEncodedMapTest4() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%yz"");
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+      maps.put(""u"", ""extra"");
+
+      String expected_path =
+              ""path-rootless/test2/x%yz//path-absolute/test1/fred@example.com/x%yz"";
+
+      try
+      {
+         uri = UriBuilder.fromPath("""").path(""{w}/{v}/{x}/{y}/{z}/{x}"").
+                 buildFromEncodedMap(maps);
+         throw new Exception(""Test Failed: expected IllegalArgumentException not thrown"");
+      }
+      catch (IllegalArgumentException ex)
+      {
+      }
+   }
+
+   @Test
+   public void testBuildFromMapTest1() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%yz"");
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+
+      String expected_path =
+              ""path-rootless/test2/x%25yz//path-absolute/test1/fred@example.com/x%25yz"";
+
+      try
+      {
+         uri = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"").
+                 buildFromMap(maps);
+         if (uri.getRawPath().compareToIgnoreCase(expected_path) != 0)
+         {
+            pass = false;
+            sb.append(""Test failed for expected path: "" + expected_path +
+                    "" Got "" + uri.getRawPath() + "" instead\n"");
+         }
+         else
+         {
+            sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+         }
+      }
+      catch (Exception ex)
+      {
+         pass = false;
+         sb.append(""Unexpected exception thrown: "" + ex.getMessage() +
+                 ""\n"");
+      }
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testBuildFromMapTest2() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%yz"");
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+      maps.put(""u"", ""extra"");
+
+      String expected_path =
+              ""path-rootless/test2/x%25yz//path-absolute/test1/fred@example.com/x%25yz"";
+
+      try
+      {
+         uri = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"").
+                 buildFromMap(maps);
+         if (uri.getRawPath().compareToIgnoreCase(expected_path) != 0)
+         {
+            pass = false;
+            sb.append(""Test failed for expected path: "" + expected_path +
+                    "" Got "" + uri.getRawPath() + "" instead"" + ""\n"");
+         }
+         else
+         {
+            sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+         }
+      }
+      catch (Exception ex)
+      {
+         pass = false;
+         sb.append(""Unexpected exception thrown: "" + ex.getMessage() +
+                 ""\n"");
+      }
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testBuildFromMapTest3() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", null);
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+      maps.put(""u"", ""extra"");
+
+      String expected_path =
+              ""path-rootless/test2/x%yz//path-absolute/test1/fred@example.com/x%yz"";
+
+      try
+      {
+         uri = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"").
+                 buildFromMap(maps);
+         throw new Exception(""Test Failed: expected IllegalArgumentException not thrown"");
+      }
+      catch (IllegalArgumentException ex)
+      {
+      }
+   }
+
+   @Test
+   public void testBuildFromMapTest4() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%yz"");
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+      maps.put(""u"", ""extra"");
+
+      String expected_path =
+              ""path-rootless/test2/x%yz//path-absolute/test1/fred@example.com/x%yz"";
+
+      try
+      {
+         uri = UriBuilder.fromPath("""").path(""{w}/{v}/{x}/{y}/{z}/{x}"").
+                 buildFromMap(maps);
+         throw new Exception(""Test Failed: expected IllegalArgumentException not thrown"");
+      }
+      catch (IllegalArgumentException ex)
+      {
+      }
+   }
+
+   @Test
+   public void testBuildFromMapTest5() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      URI uri;
+      UriBuilder ub;
+
+      Map maps = new HashMap();
+      maps.put(""x"", ""x%yz"");
+      maps.put(""y"", ""/path-absolute/test1"");
+      maps.put(""z"", ""fred@example.com"");
+      maps.put(""w"", ""path-rootless/test2"");
+
+      Map maps1 = new HashMap();
+      maps1.put(""x"", ""x%20yz"");
+      maps1.put(""y"", ""/path-absolute/test1"");
+      maps1.put(""z"", ""fred@example.com"");
+      maps1.put(""w"", ""path-rootless/test2"");
+
+      Map maps2 = new HashMap();
+      maps2.put(""x"", ""x%yz"");
+      maps2.put(""y"", ""/path-absolute/test1"");
+      maps2.put(""z"", ""fred@example.com"");
+      maps2.put(""w"", ""path-rootless/test2"");
+      maps2.put(""v"", ""xyz"");
+
+      String expected_path =
+              ""path-rootless/test2/x%25yz//path-absolute/test1/fred@example.com/x%25yz"";
+
+      String expected_path_1 =
+              ""path-rootless/test2/x%2520yz//path-absolute/test1/fred@example.com/x%2520yz"";
+
+      String expected_path_2 =
+              ""path-rootless/test2/x%25yz//path-absolute/test1/fred@example.com/x%25yz"";
+
+      try
+      {
+         ub = UriBuilder.fromPath("""").path(""{w}/{x}/{y}/{z}/{x}"");
+
+         uri = ub.buildFromMap(maps);
+
+         if (uri.getRawPath().compareToIgnoreCase(expected_path) != 0)
+         {
+            pass = false;
+            sb.append(""Test failed for expected path: "" + expected_path +
+                    "" Got "" + uri.getRawPath() + "" instead"" + ""\n"");
+         }
+         else
+         {
+            sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+         }
+
+         uri = ub.buildFromMap(maps1);
+
+         if (uri.getRawPath().compareToIgnoreCase(expected_path_1) != 0)
+         {
+            pass = false;
+            sb.append(""Test failed for expected path: "" + expected_path_1 +
+                    "" Got "" + uri.getRawPath() + "" instead"" + ""\n"");
+         }
+         else
+         {
+            sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+         }
+
+         uri = ub.buildFromMap(maps2);
+
+         if (uri.getRawPath().compareToIgnoreCase(expected_path_2) != 0)
+         {
+            pass = false;
+            sb.append(""Test failed for expected path: "" + expected_path_2 +
+                    "" Got "" + uri.getRawPath() + "" instead"" + ""\n"");
+         }
+         else
+         {
+            sb.append(""Got expected path: "" + uri.getRawPath() + ""\n"");
+         }
+      }
+      catch (Exception ex)
+      {
+         pass = false;
+         sb.append(""Unexpected exception thrown: "" + ex.getMessage() +
+                 ""\n"");
+      }
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testFromEncodedTest1() throws Exception
+   {
+      StringBuffer sb = new StringBuffer();
+      boolean pass = true;
+      String expected_value_1 = ""http://localhost:8080/a/%25/=/%25G0/%25/="";
+      String expected_value_2 = ""http://localhost:8080/xy/%20/%25/xy"";
+      URI uri = null;
+
+      uri = UriBuilder.fromPath(""http://localhost:8080"").path(""/{v}/{w}/{x}/{y}/{z}/{x}"").
+              buildFromEncoded(""a"", ""%25"", ""="", ""%G0"", ""%"", ""23"");
+
+      if (uri.toString().compareToIgnoreCase(expected_value_1) != 0)
+      {
+         pass = false;
+         sb.append(""Incorrec URI returned: "" + uri.toString() +
+                 "", expecting "" + expected_value_1 + ""\n"");
+      }
+      else
+      {
+         sb.append(""Got expected return: "" + expected_value_1 + ""\n"");
+      }
+
+      uri = UriBuilder.fromPath(""http://localhost:8080"").path(""/{x}/{y}/{z}/{x}"").
+              buildFromEncoded(""xy"", "" "", ""%"");
+
+      if (uri.toString().compareToIgnoreCase(expected_value_2) != 0)
+      {
+         pass = false;
+         sb.append(""Incorrec URI returned: "" + uri.toString() +
+                 "", expecting "" + expected_value_2 + ""\n"");
+      }
+      else
+      {
+         sb.append(""Got expected return: "" + expected_value_2 + ""\n"");
+      }
+
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testQueryParamTest1() throws Exception
+   {
+      String name = null;
+
+      try
+      {
+         UriBuilder.fromPath(""http://localhost:8080"").queryParam(name, ""x"",
+                 ""y"");
+         throw new Exception(""Expected IllegalArgumentException Not thrown"");
+      }
+      catch (IllegalArgumentException ilex)
+      {
+      }
+   }
+
+   @Test
+   public void QueryParamTest5() throws Exception
+   {
+      Boolean pass = true;
+      String name = ""name"";
+      StringBuffer sb = new StringBuffer();
+      String expected_value =
+              ""http://localhost:8080?name=x%3D&name=y?&name=x+y&name=%26"";
+      URI uri;
+
+      try
+      {
+         uri = UriBuilder.fromPath(""http://localhost:8080"").queryParam(name,
+                 ""x="", ""y?"", ""x y"", ""&"").build();
+         if (uri.toString().compareToIgnoreCase(expected_value) != 0)
+         {
+            pass = false;
+            sb.append(""Incorrec URI returned: "" + uri.toString() +
+                    "", expecting "" + expected_value + ""\n"");
+         }
+         else
+         {
+            sb.append(""Got expected return: "" + expected_value + ""\n"");
+         }
+      }
+      catch (Exception ex)
+      {
+         pass = false;
+         sb.append(""Unexpected Exception thrown"" + ex.getMessage());
+      }
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testReplaceQueryTest3() throws Exception
+   {
+      Boolean pass = true;
+      String name = ""name"";
+      StringBuffer sb = new StringBuffer();
+      String expected_value =
+              ""http://localhost:8080?name1=x&name2=%20&name3=x+y&name4=23&name5=x%20y"";
+      URI uri;
+
+      uri = UriBuilder.fromPath(""http://localhost:8080"").queryParam(name,
+              ""x="", ""y?"", ""x y"", ""&"").replaceQuery(""name1=x&name2=%20&name3=x+y&name4=23&name5=x y"").
+              build();
+      if (uri.toString().compareToIgnoreCase(expected_value) != 0)
+      {
+         pass = false;
+         sb.append(""Incorrec URI returned: "" + uri.toString() +
+                 "", expecting "" + expected_value + ""\n"");
+      }
+      else
+      {
+         sb.append(""Got expected return: "" + expected_value + ""\n"");
+      }
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
+   @Test
+   public void testReplaceQueryParamTest2() throws Exception
+   {
+      Boolean pass = true;
+      String name = ""name"";
+      StringBuffer sb = new StringBuffer();
+      String expected_value = ""http://localhost:8080"";
+      URI uri;
+
+      uri =
+              UriBuilder.fromPath(""http://localhost:8080"").queryParam(name,
+                      ""x="", ""y?"", ""x y"", ""&"").replaceQueryParam(name, null).build();
+      if (uri.toString().compareToIgnoreCase(expected_value) != 0)
+      {
+         pass = false;
+         sb.append(""Incorrec URI returned: "" + uri.toString() +
+                 "", expecting "" + expected_value + ""\n"");
+      }
+      else
+      {
+         sb.append(""Got expected return: "" + expected_value + ""\n"");
+      }
+
+      if (!pass)
+      {
+         throw new Exception(""At least one assertion failed: "" + sb.toString());
+      }
+   }
+
 
 }",2010-03-19T22:13:35Z,129
"@@ -66,6 +66,7 @@ public String get(@PathParam(""date"") String date)
    public String getPlus(@PathParam(""plus"") String p)
    {
       System.out.println(""GET PLUS: "" + p);
+      System.out.println(""request URL: "" + info.getRequestUri());
       Assert.assertEquals(""foo+bar"", p);
       return p;
    }",2010-03-19T22:13:35Z,72
"@@ -18,6 +18,18 @@
             <artifactId>resteasy-jaxrs</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-client</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxb-provider</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>io.netty</groupId>
             <artifactId>netty-all</artifactId>",2013-12-11T21:19:19Z,135
"@@ -54,6 +54,7 @@ public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
    private final boolean is100ContinueExpected;
    private NettyExecutionContext executionContext;
    private final ChannelHandlerContext ctx;
+   private volatile boolean flushed;
 
    public NettyHttpRequest(ChannelHandlerContext ctx, ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse response, boolean is100ContinueExpected)
    {
@@ -106,6 +107,11 @@ public ResteasyAsynchronousContext getAsyncContext()
       return executionContext;
    }
 
+   public boolean isFlushed()
+   {
+      return flushed;
+   }
+
    @Override
    public MultivaluedMap<String, String> getFormParameters()
    {
@@ -332,8 +338,7 @@ public boolean resume(Throwable ex) {
                     finally
                     {
                         done = true;
-                        ctx.writeAndFlush(nettyResponse.getDefaultFullHttpResponse());
-                        ctx.close();
+                        nettyFlush();
                     }
                 }
             }
@@ -350,7 +355,14 @@ public boolean cancel() {
                     }
                     done = true;
                     cancelled = true;
-                    return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).build());
+                   try
+                   {
+                      return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).build());
+                   }
+                   finally
+                   {
+                      nettyFlush();
+                   }
                 }
             }
 
@@ -362,19 +374,40 @@ public boolean cancel(int retryAfter) {
                     if (done) return false;
                     done = true;
                     cancelled = true;
-                    return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).header(HttpHeaders.RETRY_AFTER, retryAfter).build());
+                   try
+                   {
+                      return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).header(HttpHeaders.RETRY_AFTER, retryAfter).build());
+                   }
+                   finally
+                   {
+                      nettyFlush();
+                   }
                 }
             }
 
-            @Override
+           protected synchronized void nettyFlush()
+           {
+              flushed = true;
+              ctx.writeAndFlush(nettyResponse.getDefaultFullHttpResponse());
+              ctx.close();
+           }
+
+           @Override
             public boolean cancel(Date retryAfter) {
                 synchronized (responseLock)
                 {
                     if (cancelled) return true;
                     if (done) return false;
                     done = true;
                     cancelled = true;
-                    return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).header(HttpHeaders.RETRY_AFTER, retryAfter).build());
+                   try
+                   {
+                      return internalResume(Response.status(Response.Status.SERVICE_UNAVAILABLE).header(HttpHeaders.RETRY_AFTER, retryAfter).build());
+                   }
+                   finally
+                   {
+                      nettyFlush();
+                   }
                 }
             }
 ",2013-12-11T21:19:19Z,136
"@@ -10,6 +10,7 @@
 import io.netty.handler.codec.http.HttpVersion;
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MultivaluedMap;
@@ -32,14 +33,16 @@ public class NettyHttpResponse implements HttpResponse
    private final ChannelHandlerContext ctx;
    private boolean committed;
    private boolean keepAlive;
+   private ResteasyProviderFactory providerFactory;
 
-   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive, ResteasyProviderFactory providerFactory)
    {
       outputHeaders = new MultivaluedMapImpl<String, Object>();
       byteBuf = ctx.alloc().buffer();
       os = new ByteBufOutputStream(byteBuf);
       this.ctx = ctx;
       this.keepAlive = keepAlive;
+      this.providerFactory = providerFactory;
    }
 
    @Override
@@ -145,8 +148,11 @@ public void retain() {
         byteBuf.retain(1);
     }
 
-    public DefaultFullHttpResponse getDefaultFullHttpResponse() {
+    public DefaultFullHttpResponse getDefaultFullHttpResponse()
+    {
         HttpResponseStatus status = HttpResponseStatus.valueOf(getStatus());
-        return new DefaultFullHttpResponse(HTTP_1_1, status, getBuffer());
+        DefaultFullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, status, getBuffer());
+        RestEasyHttpResponseEncoder.transformHeaders(this, res, providerFactory);
+        return res;
     }
 }",2013-12-11T21:19:19Z,137
"@@ -1,180 +1,180 @@
-package org.jboss.resteasy.plugins.server.netty;
-
-import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.handler.codec.http.HttpObjectAggregator;
-import io.netty.handler.codec.http.HttpRequestDecoder;
-import io.netty.handler.codec.http.HttpResponseEncoder;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.util.concurrent.EventExecutor;
-import org.jboss.resteasy.core.SynchronousDispatcher;
-import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
-import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
-import org.jboss.resteasy.spi.ResteasyDeployment;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-
-/**
- * An HTTP server that sends back the content of the received HTTP request
- * in a pretty plaintext form.
- *
- * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
- * @author Andy Taylor (andy.taylor@jboss.org)
- * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
- * @author Norman Maurer
- * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
- */
-public class NettyJaxrsServer implements EmbeddedJaxrsServer
-{
-   protected ServerBootstrap bootstrap = new ServerBootstrap();
-   protected int port = 8080;
-   protected ResteasyDeployment deployment = new ResteasyDeployment();
-   protected String root = """";
-   protected SecurityDomain domain;
-   private EventLoopGroup eventLoopGroup;
-   private EventLoopGroup eventExecutor;
-   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
-   private int executorThreadCount = 16;
-   private SSLContext sslContext;
-   private int maxRequestSize = 1024 * 1024 * 10;
-   private int backlog = 128;
-
-   public void setSSLContext(SSLContext sslContext)
-   {
-      this.sslContext = sslContext;
-   }
-
-   /**
-    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
-    *
-    * @param ioWorkerCount
-    */
-   public void setIoWorkerCount(int ioWorkerCount)
-   {
-       this.ioWorkerCount = ioWorkerCount;
-   }
-
-   /**
-    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
-    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
-    * code in there.
-    *
-    * @param executorThreadCount
-    */
-   public void setExecutorThreadCount(int executorThreadCount)
-   {
-       this.executorThreadCount = executorThreadCount;
-   }
-
-   /**
-    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
-    *
-    * @param maxRequestSize the max request size. This is 10mb by default.
-    */
-   public void setMaxRequestSize(int maxRequestSize)
-   {
-       this.maxRequestSize  = maxRequestSize;
-   }
-
-   public int getPort()
-   {
-      return port;
-   }
-
-   public void setPort(int port)
-   {
-      this.port = port;
-   }
-
-    public void setBacklog(int backlog)
-    {
-        this.backlog = backlog;
-    }
-
-   @Override
-   public void setDeployment(ResteasyDeployment deployment)
-   {
-      this.deployment = deployment;
-   }
-
-   @Override
-   public void setRootResourcePath(String rootResourcePath)
-   {
-      root = rootResourcePath;
-      if (root != null && root.equals(""/"")) root = """";
-   }
-
-   @Override
-   public ResteasyDeployment getDeployment()
-   {
-      return deployment;
-   }
-
-   @Override
-   public void setSecurityDomain(SecurityDomain sc)
-   {
-      this.domain = sc;
-   }
-
-   @Override
-   public void start()
-   {
-      eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);
-      eventExecutor = new NioEventLoopGroup(executorThreadCount);
-      deployment.start();
-      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
-       // Configure the server.
-       if (sslContext == null) {
-           bootstrap.group(eventLoopGroup)
-                   .channel(NioServerSocketChannel.class)
-                   .childHandler(new ChannelInitializer<SocketChannel>() {
-                       @Override
-                       public void initChannel(SocketChannel ch) throws Exception {
-                           ch.pipeline().addLast(new HttpRequestDecoder());
-                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
-                           ch.pipeline().addLast(new HttpResponseEncoder());
-                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));
-                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
-                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
-                       }
-                   })
-                   .option(ChannelOption.SO_BACKLOG, backlog)
-                   .childOption(ChannelOption.SO_KEEPALIVE, true);
-       } else {
-           final SSLEngine engine = sslContext.createSSLEngine();
-           engine.setUseClientMode(false);
-           bootstrap.group(eventLoopGroup)
-                   .channel(NioServerSocketChannel.class)
-                   .childHandler(new ChannelInitializer<SocketChannel>() {
-                       @Override
-                       public void initChannel(SocketChannel ch) throws Exception {
-                           ch.pipeline().addFirst(new SslHandler(engine));
-                           ch.pipeline().addLast(new HttpRequestDecoder());
-                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
-                           ch.pipeline().addLast(new HttpResponseEncoder());
-                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));
-                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
-                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
-
-                       }
-                   })
-                   .option(ChannelOption.SO_BACKLOG, backlog)
-                   .childOption(ChannelOption.SO_KEEPALIVE, true);
-       }
-
-        bootstrap.bind(port).syncUninterruptibly();
-   }
-
-   @Override
-   public void stop()
-   {
-       eventLoopGroup.shutdownGracefully();
-       eventExecutor.shutdownGracefully();
-   }
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup eventLoopGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+   private int backlog = 128;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+    public void setBacklog(int backlog)
+    {
+        this.backlog = backlog;
+    }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(eventLoopGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, backlog)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(eventLoopGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, RestEasyHttpRequestDecoder.Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, backlog)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+        bootstrap.bind(port).syncUninterruptibly();
+   }
+
+   @Override
+   public void stop()
+   {
+       eventLoopGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
 }
\ No newline at end of file",2013-12-11T21:19:19Z,14
"@@ -72,10 +72,10 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
               future = ctx.writeAndFlush(response);
           } else {
               // Write an empty response
-              future = ctx.write(response);
+              //future = ctx.write(response);
               // retain buffer since it was automatically
               // reference counted by the write operation above
-              response.retain();
+              //response.retain();
           }
           // Close the non-keep-alive connection after the write operation is done.
           if (!request.isKeepAlive())",2013-12-11T21:19:19Z,138
"@@ -57,7 +57,7 @@ public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servl
     protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
     {
         boolean keepAlive = HttpHeaders.isKeepAlive(request);
-        final NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        final NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive, dispatcher.getProviderFactory());
         final ResteasyHttpHeaders headers;
         final ResteasyUriInfo uriInfo;
         try",2013-12-11T21:19:19Z,139
"@@ -7,6 +7,7 @@
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpHeaders.Values;
 import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.ext.RuntimeDelegate;
 import java.util.List;
@@ -39,36 +40,38 @@ public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
     protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
     {
         ByteBuf buffer = nettyResponse.getBuffer();
-        if (buffer.readableBytes() == 0) {
-            // content not written yet by the AsyncResponse
-            return;
-        }
         HttpResponse response = nettyResponse.getDefaultFullHttpResponse();
 
-        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
-        {
-           String key = entry.getKey();
-           for (Object value : entry.getValue())
-           {
-              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
-              if (delegate != null)
-              {
-                  response.headers().add(key, delegate.toString(value));
-              }
-              else
-              {
-                 response.headers().set(key, value.toString());
-              }
-           }
-        }
+        transformHeaders(nettyResponse, response, dispatcher.providerFactory);
 
-        if (nettyResponse.isKeepAlive())
-        {
-            // Add content length and connection header if needed
-            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
-            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
-        }
         out.add(response);
     }
 
+   public static void transformHeaders(NettyHttpResponse nettyResponse, HttpResponse response, ResteasyProviderFactory factory)
+   {
+      ByteBuf buffer = nettyResponse.getBuffer();
+      if (nettyResponse.isKeepAlive())
+      {
+         // Add content length and connection header if needed
+         response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+         response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+      }
+      for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+      {
+         String key = entry.getKey();
+         for (Object value : entry.getValue())
+         {
+            RuntimeDelegate.HeaderDelegate delegate = factory.getHeaderDelegate(value.getClass());
+            if (delegate != null)
+            {
+                response.headers().add(key, delegate.toString(value));
+            }
+            else
+            {
+               response.headers().set(key, value.toString());
+            }
+         }
+      }
+   }
+
 }",2013-12-11T21:19:19Z,140
"@@ -0,0 +1,200 @@
+package org.jboss.resteasy.test;
+
+
+import javax.ws.rs.ForbiddenException;
+import javax.ws.rs.GET;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.container.AsyncResponse;
+import javax.ws.rs.container.Suspended;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@Path(""/jaxrs"")
+public class AsyncJaxrsResource
+{
+   protected boolean cancelled;
+
+   @GET
+   @Path(""resume/object"")
+   @Produces(""application/xml"")
+   public void resumeObject(@Suspended final AsyncResponse response) {
+      response.resume(new XmlData(""bill""));
+   }
+
+   @GET
+   @Path(""resume/object/thread"")
+   @Produces(""application/xml"")
+   public void resumeObjectThread(@Suspended final AsyncResponse response) throws Exception
+   {
+      Thread t = new Thread()
+      {
+         @Override
+         public void run()
+         {
+            response.resume(new XmlData(""bill""));
+         }
+      };
+      t.start();
+   }
+
+
+
+   @GET
+   @Path(""injection-failure/{param}"")
+   public void injectionFailure(@Suspended final AsyncResponse response, @PathParam(""param"") int id) {
+      System.out.println(""injectionFailure: "" + id);
+      throw new ForbiddenException(""Should be unreachable"");
+   }
+
+   @GET
+   @Path(""method-failure"")
+   public void injectionFailure(@Suspended final AsyncResponse response) {
+      throw new ForbiddenException(""Should be unreachable"");
+   }
+
+
+
+   @GET
+   @Path(""cancelled"")
+   public Response getCancelled()
+   {
+      System.out.println(""getCancelled called!"");
+      if (cancelled) return Response.noContent().build();
+      else return Response.status(500).build();
+   }
+
+   @PUT
+   @Path(""cancelled"")
+   public void resetCancelled()
+   {
+      cancelled = false;
+
+   }
+
+   @GET
+   @Produces(""text/plain"")
+   public void get(@Suspended final AsyncResponse response) throws Exception
+   {
+      response.setTimeout(200000, TimeUnit.MILLISECONDS);
+      Thread t = new Thread()
+      {
+         @Override
+         public void run()
+         {
+            try
+            {
+               System.out.println(""STARTED!!!!"");
+               Thread.sleep(100);
+               Response jaxrs = Response.ok(""hello"").type(MediaType.TEXT_PLAIN).build();
+               response.resume(jaxrs);
+            }
+            catch (Exception e)
+            {
+               e.printStackTrace();
+            }
+         }
+      };
+      t.start();
+   }
+
+   @GET
+   @Path(""empty"")
+   @Produces(""text/plain"")
+   public void getEmpty(@Suspended final AsyncResponse response) throws Exception
+   {
+      response.setTimeout(200000, TimeUnit.MILLISECONDS);
+      Thread t = new Thread()
+      {
+         @Override
+         public void run()
+         {
+            try
+            {
+               System.out.println(""STARTED Empty!!!!"");
+               Thread.sleep(100);
+               response.resume(Response.noContent().build());
+            }
+            catch (Exception e)
+            {
+               e.printStackTrace();
+            }
+         }
+      };
+      t.start();
+   }
+
+
+   @GET
+   @Path(""timeout"")
+   @Produces(""text/plain"")
+   public void timeout(@Suspended final AsyncResponse response)
+   {
+      response.setTimeout(10, TimeUnit.MILLISECONDS);
+      Thread t = new Thread()
+      {
+         @Override
+         public void run()
+         {
+            try
+            {
+               System.out.println(""STARTED!!!!"");
+               Thread.sleep(100000);
+               Response jaxrs = Response.ok(""goodbye"").type(MediaType.TEXT_PLAIN).build();
+               response.resume(jaxrs);
+            }
+            catch (Exception e)
+            {
+               e.printStackTrace();
+            }
+         }
+      };
+      t.start();
+   }
+
+
+   @GET
+   @Path(""cancel"")
+   @Produces(""text/plain"")
+   public void cancel(@Suspended final AsyncResponse response) throws Exception
+   {
+      response.setTimeout(10000, TimeUnit.MILLISECONDS);
+      final CountDownLatch sync = new CountDownLatch(1);
+      final CountDownLatch ready = new CountDownLatch(1);
+      Thread t = new Thread()
+      {
+         @Override
+         public void run()
+         {
+            try
+            {
+               sync.countDown();
+               System.out.println(""cancel awaiting thread"");
+               ready.await();
+               System.out.println(""cancel resuming"");
+               Response jaxrs = Response.ok(""hello"").type(MediaType.TEXT_PLAIN).build();
+               cancelled = !response.resume(jaxrs);
+            }
+            catch (Exception e)
+            {
+               e.printStackTrace();
+            }
+         }
+      };
+      t.start();
+
+      sync.await();
+      System.out.println(""Cancelling..."");
+      response.cancel();
+      ready.countDown();
+   }
+
+}
\ No newline at end of file",2013-12-11T21:19:19Z,141
"@@ -0,0 +1,201 @@
+package org.jboss.resteasy.test;
+
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.ForbiddenException;
+import javax.ws.rs.NotFoundException;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Response;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class JaxrsAsyncTest
+{
+   static String BASE_URI = generateURL("""");
+   static Client client;
+
+   @BeforeClass
+   public static void setup() throws Exception
+   {
+      NettyContainer.start().getRegistry().addSingletonResource(new AsyncJaxrsResource());
+      client = ClientBuilder.newClient();
+   }
+
+   @AfterClass
+   public static void end() throws Exception
+   {
+      client.close();
+      NettyContainer.stop();
+   }
+
+   @Test
+   public void testInjectionFailure() throws Exception
+   {
+      System.out.println(""***INJECTION FAILURE***"");
+      long start = System.currentTimeMillis();
+      Client client = ClientBuilder.newClient();
+      Response response = client.target(BASE_URI).path(""jaxrs/injection-failure/abcd"").request().get();
+      Assert.assertEquals(Response.Status.NOT_FOUND.getStatusCode(), response.getStatus());
+      long end = System.currentTimeMillis() - start;
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+      client.close();
+   }
+
+   @Test
+   public void testMethodFailure() throws Exception
+   {
+      System.out.println(""***method FAILURE***"");
+      long start = System.currentTimeMillis();
+      Client client = ClientBuilder.newClient();
+      Response response = client.target(BASE_URI).path(""jaxrs/method-failure"").request().get();
+      Assert.assertEquals(Response.Status.FORBIDDEN.getStatusCode(), response.getStatus());
+      long end = System.currentTimeMillis() - start;
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+      client.close();
+   }
+
+
+
+   @Test
+   public void testAsync() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      callAsync(client);
+      callAsync(client);
+      callAsync(client);
+      client.close();
+   }
+
+   private void callAsync(Client client)
+   {
+      long start = System.currentTimeMillis();
+      Response response = client.target(BASE_URI).path(""jaxrs"").request().get();
+      long end = System.currentTimeMillis() - start;
+      Assert.assertEquals(200, response.getStatus());
+      System.out.println(response.getHeaders().size());
+      System.out.println(response.getHeaders().keySet().iterator().next());
+      Assert.assertEquals(""hello"", response.readEntity(String.class));
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+   }
+
+   @Test
+   public void testEmpty() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      callEmpty(client);
+      callEmpty(client);
+      callEmpty(client);
+      client.close();
+   }
+
+   private void callEmpty(Client client)
+   {
+      long start = System.currentTimeMillis();
+      Response response = client.target(BASE_URI).path(""jaxrs/empty"").request().get();
+      long end = System.currentTimeMillis() - start;
+      Assert.assertEquals(204, response.getStatus());
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+   }
+
+
+   @Test
+   public void testTimeout() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      Response response = client.target(BASE_URI).path(""jaxrs/timeout"").request().get();
+      Assert.assertEquals(503, response.getStatus());
+      response.close();
+      client.close();
+   }
+
+   @Test
+   public void testCancelled() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      Response response = null;
+      System.out.println(""calling cancelled"");
+      response = client.target(BASE_URI).path(""jaxrs/cancelled"").request().put(null);
+      Assert.assertEquals(204, response.getStatus());
+      response.close();
+      response = client.target(BASE_URI).path(""jaxrs/cancelled"").request().get();
+      System.out.println(""returned from calling cancelled"");
+      Assert.assertEquals(500, response.getStatus());
+      System.out.println(""done"");
+
+      response.close();
+      client.close();
+   }
+
+
+   @Test
+   public void testCancel() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      Response response = null;
+      System.out.println(""calling cancelled"");
+      response = client.target(BASE_URI).path(""jaxrs/cancelled"").request().put(null);
+      Assert.assertEquals(204, response.getStatus());
+      response.close();
+      response = client.target(BASE_URI).path(""jaxrs/cancelled"").request().get();
+      System.out.println(""returned from calling cancelled"");
+      Assert.assertEquals(500, response.getStatus());
+      System.out.println(""done"");
+      response.close();
+
+      System.out.println(""calling cancel"");
+      response = client.target(BASE_URI).path(""jaxrs/cancel"").request().get();
+      System.out.println(""got response"");
+      Assert.assertEquals(503, response.getStatus());
+      response.close();
+      System.out.println(""calling cancelled"");
+      response = client.target(BASE_URI).path(""jaxrs/cancelled"").request().get();
+      System.out.println(""returned from calling cancelled"");
+      Assert.assertEquals(204, response.getStatus());
+      System.out.println(""done"");
+
+      response.close();
+      client.close();
+   }
+
+   @Test
+   public void testResumeObject() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      long start = System.currentTimeMillis();
+      Response response = client.target(BASE_URI).path(""jaxrs/resume/object"").request().get();
+      long end = System.currentTimeMillis() - start;
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(""bill"", response.readEntity(XmlData.class).getName());
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+      client.close();
+   }
+
+   @Test
+   public void testResumeObjectThread() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      long start = System.currentTimeMillis();
+      Response response = client.target(BASE_URI).path(""jaxrs/resume/object/thread"").request().get();
+      long end = System.currentTimeMillis() - start;
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(""bill"", response.readEntity(XmlData.class).getName());
+      Assert.assertTrue(end < 1000);  // should take less than 1 second
+      response.close();
+      client.close();
+   }
+
+
+}",2013-12-11T21:19:19Z,142
"@@ -0,0 +1,56 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyTest
+{
+   @Path(""/test"")
+   public static class Resource
+   {
+      @GET
+      @Produces(""text/plain"")
+      public String hello()
+      {
+         return ""hello world"";
+      }
+
+
+   }
+
+   @BeforeClass
+   public static void setup() throws Exception
+   {
+      NettyContainer.start().getRegistry().addPerRequestResource(Resource.class);
+   }
+
+   @AfterClass
+   public static void end() throws Exception
+   {
+      NettyContainer.stop();
+   }
+
+   @Test
+   public void testBasic() throws Exception
+   {
+      ResteasyClient client = new ResteasyClientBuilder().build();
+      ResteasyWebTarget target = client.target(generateURL(""/test""));
+      String val = target.request().get(String.class);
+      Assert.assertEquals(val, ""hello world"");
+   }
+}",2013-12-11T21:19:19Z,143
"@@ -0,0 +1,34 @@
+package org.jboss.resteasy.test;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@XmlRootElement(name = ""data"")
+public class XmlData
+{
+   protected String name;
+
+   public XmlData(String data)
+   {
+      this.name = data;
+   }
+
+   public XmlData()
+   {
+   }
+
+   public String getName()
+   {
+      return name;
+   }
+
+   public void setName(String name)
+   {
+      this.name = name;
+   }
+
+
+}",2013-12-11T21:19:19Z,144
"@@ -205,7 +205,8 @@ public Invocation.Builder invocation(Link link) throws NullPointerException, Ill
       abortIfClosed();
       if (link == null) throw new NullPointerException(""link was null"");
       WebTarget target = target(link);
-      return target.request(link.getType());
+      if (link.getType() != null) return target.request(link.getType());
+      else return target.request();
    }
 
 }",2013-05-09T22:20:22Z,55
"@@ -4,7 +4,12 @@
 
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Configurable;
 import javax.ws.rs.core.Configuration;
+import javax.ws.rs.core.Feature;
+import javax.ws.rs.core.FeatureContext;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -22,4 +27,42 @@ public void testBuilder() throws Exception
       client = ClientBuilder.newClient(config);
 
    }
+
+   public static void inner() throws Exception
+   {
+      Feature feature = new Feature() {
+         @Override
+         public boolean configure(FeatureContext context)
+         {
+            return false;
+         }
+      };
+
+      System.out.println(""is static: "" + Modifier.isStatic(feature.getClass().getModifiers()));
+      Client client = ClientBuilder.newClient();
+      client.register(feature.getClass());
+
+   }
+
+   //@Test
+   public void testInnerFeature() throws Exception
+   {
+      // TCK uses anonymous non-static inner classes to test.  BOGUS POOP!
+      System.out.println(""non-static"");
+      inner();
+      System.out.println(""non-static"");
+      Feature feature = new Feature() {
+         @Override
+         public boolean configure(FeatureContext context)
+         {
+            return false;
+         }
+      };
+      System.out.println(""is static: "" + Modifier.isStatic(feature.getClass().getModifiers()));
+
+      Client client = ClientBuilder.newClient();
+      client.register(feature.getClass());
+
+
+   }
 }",2013-05-09T22:20:22Z,128
"@@ -1,46 +1,174 @@
 package org.jboss.resteasy.plugins.delegates;
 
+import org.jboss.resteasy.specimpl.LinkBuilderImpl;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.spi.LinkHeader;
 
 import javax.ws.rs.core.Link;
+import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.ext.RuntimeDelegate;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import java.util.StringTokenizer;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
 public class LinkDelegate implements RuntimeDelegate.HeaderDelegate<Link>
 {
+   private static class Parser
+   {
+      private int curr;
+      private String value;
+      private Link.Builder builder;
+
+      public Parser(String value)
+      {
+         this.value = value;
+         builder = new LinkBuilderImpl();
+      }
+
+      public Link getLink()
+      {
+         return builder.build();
+      }
+
+      public void parse()
+      {
+         String href = null;
+         MultivaluedMap<String, String> attributes = new MultivaluedMapImpl<String, String>();
+         while (curr < value.length())
+         {
+
+            char c = value.charAt(curr);
+            if (c == '<')
+            {
+               if (href != null)
+                  throw new IllegalArgumentException(""Unable to parse Link header. Too many links in declaration: "" + value);
+               href = parseLink();
+            }
+            else if (c == ';' || c == ' ')
+            {
+               curr++;
+               continue;
+            }
+            else
+            {
+               parseAttribute(attributes);
+            }
+         }
+         populateLink(href, attributes);
+
+
+      }
+
+      protected void populateLink(String href, MultivaluedMap<String, String> attributes)
+      {
+         builder.uri(href);
+         for (String name : attributes.keySet())
+         {
+            List<String> values = attributes.get(name);
+            if (name.equals(""rel""))
+            {
+               for (String val : values) builder.rel(val);
+            }
+            else if (name.equals(""title""))
+            {
+               for (String val : values) builder.title(val);
+
+            }
+            else if (name.equals(""type""))
+            {
+               for (String val : values) builder.type(val);
+
+            }
+            else
+            {
+               for (String val : values) builder.param(name, val);
+
+            }
+         }
+      }
+
+      public String parseLink()
+      {
+         int end = value.indexOf('>', curr);
+         if (end == -1) throw new IllegalArgumentException(""Unable to parse Link header.  No end to link: "" + value);
+         String href = value.substring(curr + 1, end);
+         curr = end + 1;
+         return href;
+      }
+
+      public void parseAttribute(MultivaluedMap<String, String> attributes)
+      {
+         int end = value.indexOf('=', curr);
+         if (end == -1 || end + 1 >= value.length())
+            throw new IllegalArgumentException(""Unable to parse Link header.  No end to parameter: "" + value);
+         String name = value.substring(curr, end);
+         name = name.trim();
+         curr = end + 1;
+         String val = null;
+         if (curr >= value.length())
+         {
+            val = """";
+         }
+         else
+         {
+
+            if (value.charAt(curr) == '""')
+            {
+               if (curr + 1 >= value.length())
+                  throw new IllegalArgumentException(""Unable to parse Link header.  No end to parameter: "" + value);
+               curr++;
+               end = value.indexOf('""', curr);
+               if (end == -1)
+                  throw new IllegalArgumentException(""Unable to parse Link header.  No end to parameter: "" + value);
+               val = value.substring(curr, end);
+               curr = end + 1;
+            }
+            else
+            {
+               StringBuffer buf = new StringBuffer();
+               while (curr < value.length())
+               {
+                  char c = value.charAt(curr);
+                  if (c == ',' || c == ';') break;
+                  buf.append(value.charAt(curr));
+                  curr++;
+               }
+               val = buf.toString();
+            }
+         }
+         attributes.add(name, val);
+
+      }
+
+   }
+
+
    @Override
    public Link fromString(String value) throws IllegalArgumentException
    {
-      LinkHeader header = new LinkHeaderDelegate().fromString(value);
-      org.jboss.resteasy.spi.Link resteasyLink = header.getLinks().get(0);
-      return resteasyLink.toJaxrsLink();
+      Parser parser = new Parser(value);
+      parser.parse();
+      return parser.getLink();
    }
 
    @Override
    public String toString(Link value) throws IllegalArgumentException
    {
-      LinkHeader header = new LinkHeader();
-
-      org.jboss.resteasy.spi.Link link = new org.jboss.resteasy.spi.Link();
-      link.setHref(value.getUri().toString());
-      link.setRelationship(value.getRel());
-      link.setTitle(value.getTitle());
-      link.setType(value.getType());
-      HashMap<String, String> copy = new HashMap<String, String>();
-      copy.putAll(value.getParams());
-      copy.remove(Link.REL);
-      copy.remove(Link.TITLE);
-      copy.remove(Link.TYPE);
-      for (Map.Entry<String, String> entry : copy.entrySet())
+      StringBuffer buf = new StringBuffer(""<"");
+      buf.append(value.getUri().toString()).append("">"");
+
+      for (Map.Entry<String, String> entry : value.getParams().entrySet())
       {
-         link.getExtensions().add(entry.getKey(), entry.getValue());
+         buf.append(""; "").append(entry.getKey()).append(""\"""").append(entry.getValue()).append(""\"""");
       }
-      header.addLink(link);
-      return header.toString();
+
+      return buf.toString();
    }
 }",2013-05-09T22:20:22Z,145
"@@ -1,12 +1,9 @@
 package org.jboss.resteasy.specimpl;
 
-import org.jboss.resteasy.spi.NotImplementedYetException;
 
 import javax.ws.rs.core.Link;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriBuilderException;
-import javax.ws.rs.core.UriInfo;
-import java.lang.reflect.Method;
 import java.net.URI;
 
 /**
@@ -44,55 +41,62 @@ public Link.Builder uriBuilder(UriBuilder uriBuilder)
 
    @Override
    public Link.Builder uri(URI uri) {
+      if (uri == null) throw new IllegalArgumentException(""uri param was null"");
       uriBuilder = UriBuilder.fromUri(uri);
       return this;
    }
 
    @Override
    public Link.Builder uri(String uri) throws IllegalArgumentException {
+      if (uri == null) throw new IllegalArgumentException(""uri param was null"");
       uriBuilder = UriBuilder.fromUri(uri);
       return this;
    }
 
    @Override
    public Link.Builder rel(String rel) {
+      if (rel == null) throw new IllegalArgumentException(""rel param was null"");
       final String rels = link.map.get(Link.REL);
       param(Link.REL, rels == null ? rel : rels + "" "" + rel);
       return this;
    }
 
    @Override
    public Link.Builder title(String title) {
+      if (title == null) throw new IllegalArgumentException(""title param was null"");
       param(Link.TITLE, title);
       return this;
 
    }
 
    @Override
    public Link.Builder type(String type) {
+      if (type == null) throw new IllegalArgumentException(""type param was null"");
       param(Link.TYPE, type);
       return this;
    }
 
    @Override
    public Link.Builder param(String name, String value) throws IllegalArgumentException {
-      if (name == null || value == null) {
-         throw new IllegalArgumentException(""Link parameter name or value is null"");
-      }
+      if (name == null) throw new IllegalArgumentException(""name param was null"");
+      if (value == null) throw new IllegalArgumentException(""value param was null"");
       link.map.put(name, value);
       return this;
    }
 
    @Override
    public Link build(Object... values) throws UriBuilderException
    {
+      if (values == null) throw new IllegalArgumentException(""values param was null"");
       link.uri = uriBuilder.build(values);
       return link;
    }
 
    @Override
    public Link buildRelativized(URI uri, Object... values)
    {
+      if (uri == null) throw new IllegalArgumentException(""uri param was null"");
+      if (values == null) throw new IllegalArgumentException(""values param was null"");
       URI built = uriBuilder.build(values);
       URI with = built;
       if (baseUri != null) with = baseUri.resolve(built);",2013-05-09T22:20:22Z,146
"@@ -26,6 +26,11 @@ public class LinkImpl extends Link
    protected static final RuntimeDelegate.HeaderDelegate<Link> delegate =
            RuntimeDelegate.getInstance().createHeaderDelegate(Link.class);
 
+   public static Link valueOf(String value)
+   {
+      return delegate.fromString(value);
+   }
+
    @Override
    public URI getUri() {
       return uri;",2013-05-09T22:20:22Z,147
"@@ -141,7 +141,7 @@ public UriBuilder uriTemplate(String uriTemplate)
    protected UriBuilder parseHierarchicalUri(String uriTemplate, Matcher match)
    {
       boolean scheme = match.group(2) != null;
-      if (scheme) scheme(match.group(2));
+      if (scheme) this.scheme = match.group(2);
       String authority = match.group(4);
       if (authority != null)
       {
@@ -152,24 +152,23 @@ protected UriBuilder parseHierarchicalUri(String uriTemplate, Matcher match)
          {
             String user = host.substring(0, at);
             host = host.substring(at + 1);
-            userInfo(user);
+            this. userInfo = user;
          }
          Matcher hostPortMatch = hostPortPattern.matcher(host);
          if (hostPortMatch.matches())
          {
-            host(hostPortMatch.group(1));
+            this.host = hostPortMatch.group(1);
             int val = 0;
             try {
-               val = Integer.parseInt(hostPortMatch.group(2));
+               this.port = Integer.parseInt(hostPortMatch.group(2));
             }
             catch (NumberFormatException e) {
                throw new IllegalArgumentException(""Illegal uri template: "" + uriTemplate, e);
             }
-            port(val);
          }
          else
          {
-            host(host);
+            this.host = host;
          }
       }
       if (match.group(5) != null)
@@ -393,13 +392,17 @@ public UriBuilder path(Class resource, String method) throws IllegalArgumentExce
             if (m.isAnnotationPresent(Path.class)) theMethod = m;
          }
       }
+      if (theMethod == null) throw new IllegalArgumentException(""No @Path annotated method for "" + resource.getName()+ ""."" +method);
       return path(theMethod);
    }
 
    @Override
    public UriBuilder path(Method method) throws IllegalArgumentException
    {
-      if (method == null) throw new IllegalArgumentException(""method was null"");
+      if (method == null)
+      {
+         throw new IllegalArgumentException(""method was null"");
+      }
       Path ann = method.getAnnotation(Path.class);
       if (ann != null)
       {
@@ -529,7 +532,11 @@ else if (userInfo != null || host != null || port != -1)
       {
          buffer.append(""//"");
          if (userInfo != null) replaceParameter(paramMap, fromEncodedMap, isTemplate, userInfo, buffer, encodeSlash).append(""@"");
-         if (host != null) replaceParameter(paramMap, fromEncodedMap, isTemplate, host, buffer, encodeSlash);
+         if (host != null)
+         {
+            if ("""".equals(host)) throw new UriBuilderException(""empty host name"");
+            replaceParameter(paramMap, fromEncodedMap, isTemplate, host, buffer, encodeSlash);
+         }
          if (port != -1) buffer.append("":"").append(Integer.toString(port));
       }
       else if (authority != null)
@@ -727,14 +734,16 @@ protected URI buildFromValues(boolean encodeSlash, boolean encoded, Object... va
          if (val == null) throw new IllegalArgumentException(""A value was null"");
          pathParams.put(pathParam, val.toString());
       }
-      String buf = buildString(pathParams, encoded, false, encodeSlash);
+      String buf = null;
       try
       {
-         return URI.create(buf);
+         buf = buildString(pathParams, encoded, false, encodeSlash);
+         return new URI(buf);
+         //return URI.create(buf);
       }
       catch (Exception e)
       {
-         throw new RuntimeException(""Failed to create URI: "" + buf, e);
+         throw new UriBuilderException(""Failed to create URI: "" + buf, e);
       }
    }
 ",2013-05-09T22:20:22Z,67
"@@ -68,6 +68,8 @@
 import javax.ws.rs.ext.WriterInterceptor;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
@@ -1867,7 +1869,7 @@ public <T> ConstructorInjector createConstructorInjector(Class<? extends T> claz
       Constructor<?> constructor = PickConstructor.pickSingletonConstructor(clazz);
       if (constructor == null)
       {
-         throw new RuntimeException(""Unable to find a public constructor for provider class "" + clazz.getName());
+         throw new IllegalArgumentException(""Unable to find a public constructor for provider class "" + clazz.getName());
       }
       return getInjectorFactory().createConstructor(constructor, this);
    }
@@ -1882,14 +1884,59 @@ public <T> ConstructorInjector createConstructorInjector(Class<? extends T> claz
    public <T> T injectedInstance(Class<? extends T> clazz)
    {
       Constructor<?> constructor = PickConstructor.pickSingletonConstructor(clazz);
+      Object obj = null;
       if (constructor == null)
       {
-         throw new RuntimeException(""Unable to find a public constructor for class "" + clazz.getName());
+         // TODO this is solely to pass the TCK.  This is WRONG WRONG WRONG!  I'm challenging.
+         if (false)//if (clazz.isAnonymousClass())
+         {
+            constructor = clazz.getDeclaredConstructors()[0];
+            constructor.setAccessible(true);
+            if (!Modifier.isStatic(clazz.getModifiers()))
+            {
+               Object[] args = {null};
+               try {
+                  obj = constructor.newInstance(args);
+               }
+               catch (InstantiationException e) {
+                  throw new RuntimeException(e);
+               }
+               catch (IllegalAccessException e) {
+                  throw new RuntimeException(e);
+               }
+               catch (InvocationTargetException e) {
+                  throw new RuntimeException(e);
+               }
+            }
+            else
+            {
+               try {
+                  obj = constructor.newInstance();
+               }
+               catch (InstantiationException e) {
+                  throw new RuntimeException(e);
+               }
+               catch (IllegalAccessException e) {
+                  throw new RuntimeException(e);
+               }
+               catch (InvocationTargetException e) {
+                  throw new RuntimeException(e);
+               }
+            }
+         }
+         else
+         {
+            throw new IllegalArgumentException(""Unable to find a public constructor for class "" + clazz.getName());
+         }
+      }
+      else
+      {
+         ConstructorInjector constructorInjector = getInjectorFactory().createConstructor(constructor, this);
+         obj = constructorInjector.construct();
+
       }
-      ConstructorInjector constructorInjector = getInjectorFactory().createConstructor(constructor, this);
       PropertyInjector propertyInjector = getInjectorFactory().createPropertyInjector(clazz, this);
 
-      Object obj = constructorInjector.construct();
       propertyInjector.inject(obj);
       return (T)obj;
    }",2013-05-09T22:20:22Z,25
"@@ -1,9 +1,20 @@
 package org.jboss.resteasy.test.finegrain;
 
+import org.junit.Assert;
 import org.junit.Test;
 
 import javax.ws.rs.core.Link;
+import java.lang.reflect.Method;
 import java.net.URI;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.DELETE;
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.UriBuilderException;
+
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -29,4 +40,77 @@ public void testRelativized() throws Exception
       System.out.println(link.toString());
 
    }
+
+
+   @Path(""resource"")
+   public static class Resource {
+
+      @GET
+      @Path(""get"")
+      public String get() {
+         return ""GET"";
+      }
+
+      @DELETE
+      @Path(""delete"")
+      public String delete() {
+         return ""DELETE"";
+      }
+
+      @GET
+      @Produces(MediaType.APPLICATION_SVG_XML)
+      @Path(""producessvgxml"")
+      public String producesSvgXml() {
+         return MediaType.APPLICATION_SVG_XML;
+      }
+
+      @POST
+      @Consumes(MediaType.APPLICATION_JSON)
+      @Path(""consumesappjson"")
+      public String consumesAppJson() {
+         return MediaType.APPLICATION_JSON;
+      }
+
+      @POST
+      @Produces({ MediaType.APPLICATION_XHTML_XML,
+              MediaType.APPLICATION_ATOM_XML, MediaType.APPLICATION_SVG_XML })
+      @Path(""producesxml"")
+      public String producesXml() {
+         return MediaType.APPLICATION_XHTML_XML;
+      }
+
+      @POST
+      @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
+      @Path(""consumesform"")
+      public String consumesForm() {
+         return MediaType.APPLICATION_FORM_URLENCODED;
+      }
+
+   }
+
+
+   @Test
+   public void testFromMethod()
+   {
+      for (Method m : Resource.class.getDeclaredMethods())
+      {
+         Link link = Link.fromMethod(Resource.class, m.getName()).build();
+         String string = link.toString();
+         System.out.println(""initial: "" + string);
+         Link fromValueOf = Link.valueOf(string);
+         Assert.assertEquals(string, fromValueOf.toString());
+      }
+   }
+
+   @Test
+   public void testIllegalUri()
+   {
+      Link.Builder builder = Link.fromUri(""http://:@"");
+      try {
+         Link link = builder.build();
+         Assert.fail();
+      } catch (UriBuilderException e) {
+      }
+
+   }
 }",2013-05-09T22:20:22Z,148
"@@ -217,26 +217,4 @@ public void testClassGenericTypeDiscovery() throws Exception
 
    }
 
-   @Test
-   public void testPickConstructor()
-   {
-      Feature feature = new Feature() {
-         @Override
-         public boolean configure(FeatureContext context)
-         {
-            return false;
-         }
-      };
-
-      Constructor constructor = PickConstructor.pickSingletonConstructor(feature.getClass());
-      System.out.println(constructor);
-
-
-
-
-   }
-
-
-
-
 }",2013-05-09T22:20:22Z,149
"@@ -1,5 +1,5 @@
 #HSQL Database Engine 1.8.0.5
-#Fri Oct 30 10:23:29 EDT 2009
+#Fri Oct 30 11:24:18 EDT 2009
 hsqldb.script_format=0
 runtime.gc_interval=0
 sql.enforce_strict_size=false",2009-10-30T21:26:53Z,131
"@@ -1,5 +1,5 @@
 #HSQL Database Engine 1.8.0.5
-#Fri Oct 30 10:23:22 EDT 2009
+#Fri Oct 30 11:24:11 EDT 2009
 hsqldb.script_format=0
 runtime.gc_interval=0
 sql.enforce_strict_size=false",2009-10-30T21:26:53Z,132
"@@ -0,0 +1,23 @@
+package org.jboss.resteasy.annotations;
+
+import org.jboss.resteasy.spi.StringParameterUnmarshaller;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Meta-annotation to be placed on another annotation that triggers a StringParameterUnmarshaller to be applied
+ * to a string based annotation injector i.e. @HeaderParam, @PathParam, @QueryParam
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.spi.StringParameterUnmarshaller
+ */
+@Target({ElementType.ANNOTATION_TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface StringParameterUnmarshallerBinder
+{
+   Class<? extends StringParameterUnmarshaller> value();
+}
\ No newline at end of file",2009-10-30T21:26:53Z,150
"@@ -6,6 +6,7 @@
 
 import javax.ws.rs.CookieParam;
 import javax.ws.rs.core.Cookie;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 
@@ -16,7 +17,7 @@
 public class CookieParamInjector extends StringParameterInjector implements ValueInjector
 {
 
-   public CookieParamInjector(Class type, Type genericType, AccessibleObject target, String cookieName, String defaultValue, ResteasyProviderFactory factory)
+   public CookieParamInjector(Class type, Type genericType, AccessibleObject target, String cookieName, String defaultValue, Annotation[] annotations, ResteasyProviderFactory factory)
    {
       if (type.equals(Cookie.class))
       {
@@ -28,7 +29,7 @@ public CookieParamInjector(Class type, Type genericType, AccessibleObject target
       }
       else
       {
-         initialize(type, genericType, cookieName, CookieParam.class, defaultValue, target, factory);
+         initialize(type, genericType, cookieName, CookieParam.class, defaultValue, target, annotations, factory);
       }
    }
 ",2009-10-30T21:26:53Z,151
"@@ -5,6 +5,7 @@
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.FormParam;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 import java.util.List;
@@ -16,9 +17,9 @@
 public class FormParamInjector extends StringParameterInjector implements ValueInjector
 {
 
-   public FormParamInjector(Class type, Type genericType, AccessibleObject target, String header, String defaultValue, ResteasyProviderFactory factory)
+   public FormParamInjector(Class type, Type genericType, AccessibleObject target, String header, String defaultValue, Annotation[] annotations, ResteasyProviderFactory factory)
    {
-      super(type, genericType, header, FormParam.class, defaultValue, target, factory);
+      super(type, genericType, header, FormParam.class, defaultValue, target, annotations, factory);
    }
 
    public Object inject(HttpRequest request, HttpResponse response)",2009-10-30T21:26:53Z,152
"@@ -5,6 +5,7 @@
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.HeaderParam;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 import java.util.List;
@@ -16,9 +17,9 @@
 public class HeaderParamInjector extends StringParameterInjector implements ValueInjector
 {
 
-   public HeaderParamInjector(Class type, Type genericType, AccessibleObject target, String header, String defaultValue, ResteasyProviderFactory factory)
+   public HeaderParamInjector(Class type, Type genericType, AccessibleObject target, String header, String defaultValue, Annotation[] annotations, ResteasyProviderFactory factory)
    {
-      super(type, genericType, header, HeaderParam.class, defaultValue, target, factory);
+      super(type, genericType, header, HeaderParam.class, defaultValue, target, annotations, factory);
    }
 
    public Object inject(HttpRequest request, HttpResponse response)",2009-10-30T21:26:53Z,153
"@@ -73,31 +73,31 @@ public static ValueInjector getParameterExtractor(Class injectTargetClass, Acces
 
       if ((query = FindAnnotation.findAnnotation(annotations, QueryParam.class)) != null)
       {
-         return new QueryParamInjector(type, genericType, injectTarget, query.value(), defaultVal, encode, providerFactory);
+         return new QueryParamInjector(type, genericType, injectTarget, query.value(), defaultVal, encode, annotations, providerFactory);
       }
       else if ((header = FindAnnotation.findAnnotation(annotations, HeaderParam.class)) != null)
       {
-         return new HeaderParamInjector(type, genericType, injectTarget, header.value(), defaultVal, providerFactory);
+         return new HeaderParamInjector(type, genericType, injectTarget, header.value(), defaultVal, annotations, providerFactory);
       }
       else if ((formParam = FindAnnotation.findAnnotation(annotations, FormParam.class)) != null)
       {
-         return new FormParamInjector(type, genericType, injectTarget, formParam.value(), defaultVal, providerFactory);
+         return new FormParamInjector(type, genericType, injectTarget, formParam.value(), defaultVal, annotations, providerFactory);
       }
       else if ((cookie = FindAnnotation.findAnnotation(annotations, CookieParam.class)) != null)
       {
-         return new CookieParamInjector(type, genericType, injectTarget, cookie.value(), defaultVal, providerFactory);
+         return new CookieParamInjector(type, genericType, injectTarget, cookie.value(), defaultVal, annotations, providerFactory);
       }
       else if ((uriParam = FindAnnotation.findAnnotation(annotations, PathParam.class)) != null)
       {
-         return new PathParamInjector(type, genericType, injectTarget, uriParam.value(), defaultVal, encode, providerFactory);
+         return new PathParamInjector(type, genericType, injectTarget, uriParam.value(), defaultVal, encode, annotations, providerFactory);
       }
       else if ((form = FindAnnotation.findAnnotation(annotations, Form.class)) != null)
       {
          return new FormInjector(type, providerFactory);
       }
       else if ((matrix = FindAnnotation.findAnnotation(annotations, MatrixParam.class)) != null)
       {
-         return new MatrixParamInjector(type, genericType, injectTarget, matrix.value(), defaultVal, providerFactory);
+         return new MatrixParamInjector(type, genericType, injectTarget, matrix.value(), defaultVal, annotations, providerFactory);
       }
       else if ((suspend = FindAnnotation.findAnnotation(annotations, Suspend.class)) != null)
       {",2009-10-30T21:26:53Z,154
"@@ -6,6 +6,7 @@
 
 import javax.ws.rs.MatrixParam;
 import javax.ws.rs.core.PathSegment;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -17,9 +18,9 @@
  */
 public class MatrixParamInjector extends StringParameterInjector implements ValueInjector
 {
-   public MatrixParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, ResteasyProviderFactory factory)
+   public MatrixParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, Annotation[] annotations, ResteasyProviderFactory factory)
    {
-      super(type, genericType, paramName, MatrixParam.class, defaultValue, target, factory);
+      super(type, genericType, paramName, MatrixParam.class, defaultValue, target, annotations, factory);
    }
 
    public Object inject(HttpRequest request, HttpResponse response)",2009-10-30T21:26:53Z,155
"@@ -9,6 +9,7 @@
 
 import javax.ws.rs.PathParam;
 import javax.ws.rs.core.PathSegment;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -28,7 +29,7 @@ public class PathParamInjector implements ValueInjector
    private boolean pathSegmentArray = false;
    private boolean pathSegmentList = false;
 
-   public PathParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, boolean encode, ResteasyProviderFactory factory)
+   public PathParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, boolean encode, Annotation[] annotations, ResteasyProviderFactory factory)
    {
       this.type = type;
       if (isPathSegmentArray(type))
@@ -45,7 +46,7 @@ else if (type.equals(PathSegment.class))
       }
       else
       {
-         extractor = new StringParameterInjector(type, genericType, paramName, PathParam.class, defaultValue, target, factory);
+         extractor = new StringParameterInjector(type, genericType, paramName, PathParam.class, defaultValue, target, annotations, factory);
       }
       this.paramName = paramName;
       this.encode = encode;",2009-10-30T21:26:53Z,156
"@@ -7,6 +7,7 @@
 
 import javax.ws.rs.QueryParam;
 import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Type;
 import java.net.URLDecoder;
@@ -21,9 +22,9 @@ public class QueryParamInjector extends StringParameterInjector implements Value
    private boolean encode;
    private String encodedName;
 
-   public QueryParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, boolean encode, ResteasyProviderFactory factory)
+   public QueryParamInjector(Class type, Type genericType, AccessibleObject target, String paramName, String defaultValue, boolean encode, Annotation[] annotations, ResteasyProviderFactory factory)
    {
-      super(type, genericType, paramName, QueryParam.class, defaultValue, target, factory);
+      super(type, genericType, paramName, QueryParam.class, defaultValue, target, annotations, factory);
       this.encode = encode;
       try
       {",2009-10-30T21:26:53Z,157
"@@ -1,12 +1,15 @@
 package org.jboss.resteasy.core;
 
+import org.jboss.resteasy.annotations.StringParameterUnmarshallerBinder;
 import org.jboss.resteasy.spi.BadRequestException;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.spi.StringConverter;
+import org.jboss.resteasy.spi.StringParameterUnmarshaller;
 import org.jboss.resteasy.util.StringToPrimitive;
 
 import javax.ws.rs.HeaderParam;
 import javax.ws.rs.ext.RuntimeDelegate;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
@@ -39,24 +42,25 @@ public class StringParameterInjector
    protected Class<? extends Collection> collectionType;
    protected AccessibleObject target;
    protected StringConverter converter;
+   protected StringParameterUnmarshaller unmarshaller;
    protected RuntimeDelegate.HeaderDelegate delegate;
 
    public StringParameterInjector()
    {
 
    }
 
-   public StringParameterInjector(Class type, Type genericType, String paramName, Class paramType, String defaultValue, AccessibleObject target, ResteasyProviderFactory factory)
+   public StringParameterInjector(Class type, Type genericType, String paramName, Class paramType, String defaultValue, AccessibleObject target, Annotation[] annotations, ResteasyProviderFactory factory)
    {
-      initialize(type, genericType, paramName, paramType, defaultValue, target, factory);
+      initialize(type, genericType, paramName, paramType, defaultValue, target, annotations, factory);
    }
 
    public boolean isCollectionOrArray()
    {
       return isCollection || type.isArray();
    }
 
-   protected void initialize(Class type, Type genericType, String paramName, Class paramType, String defaultValue, AccessibleObject target, ResteasyProviderFactory factory)
+   protected void initialize(Class type, Type genericType, String paramName, Class paramType, String defaultValue, AccessibleObject target, Annotation[] annotations, ResteasyProviderFactory factory)
    {
       this.type = type;
       this.paramName = paramName;
@@ -95,6 +99,35 @@ else if (Set.class.isAssignableFrom(type))
       }
       if (!baseType.isPrimitive())
       {
+         unmarshaller = factory.createStringParameterUnmarshaller(baseType);
+         if (unmarshaller != null)
+         {
+            unmarshaller.setAnnotations(annotations);
+            return;
+         }
+
+         for (Annotation annotation : annotations)
+         {
+            StringParameterUnmarshallerBinder binder = annotation.annotationType().getAnnotation(StringParameterUnmarshallerBinder.class);
+            if (binder != null)
+            {
+               try
+               {
+                  unmarshaller = binder.value().newInstance();
+               }
+               catch (InstantiationException e)
+               {
+                  throw new RuntimeException(e.getCause());
+               }
+               catch (IllegalAccessException e)
+               {
+                  throw new RuntimeException(e);
+               }
+               unmarshaller.setAnnotations(annotations);
+               return;
+            }
+         }
+
          converter = factory.getStringConverter(baseType);
          if (converter != null) return;
 
@@ -194,6 +227,10 @@ public Object extractValue(String strVal)
       {
          return converter.fromString(strVal);
       }
+      else if (unmarshaller != null)
+      {
+         return unmarshaller.fromString(strVal);
+      }
       else if (delegate != null)
       {
          return delegate.fromString(strVal);",2009-10-30T21:26:53Z,158
"@@ -1,14 +1,16 @@
 package org.jboss.resteasy.core;
 
-import org.jboss.resteasy.spi.interception.ClientExecutionInterceptor;
+import org.jboss.resteasy.client.core.ClientErrorInterceptor;
 import org.jboss.resteasy.core.interception.InterceptorRegistry;
+import org.jboss.resteasy.spi.ProviderFactoryDelegate;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.spi.StringConverter;
+import org.jboss.resteasy.spi.StringParameterUnmarshaller;
+import org.jboss.resteasy.spi.interception.ClientExecutionInterceptor;
 import org.jboss.resteasy.spi.interception.MessageBodyReaderInterceptor;
 import org.jboss.resteasy.spi.interception.MessageBodyWriterInterceptor;
 import org.jboss.resteasy.spi.interception.PostProcessInterceptor;
 import org.jboss.resteasy.spi.interception.PreProcessInterceptor;
-import org.jboss.resteasy.spi.ProviderFactoryDelegate;
-import org.jboss.resteasy.spi.ResteasyProviderFactory;
-import org.jboss.resteasy.spi.StringConverter;
 import org.jboss.resteasy.util.ThreadLocalStack;
 
 import javax.ws.rs.core.Application;
@@ -48,6 +50,30 @@ public ResteasyProviderFactory getDelegate()
       return factory;
    }
 
+   @Override
+   public void addStringParameterUnmarshaller(Class<? extends StringParameterUnmarshaller> resolver)
+   {
+      getDelegate().addStringParameterUnmarshaller(resolver);
+   }
+
+   @Override
+   public void addClientErrorInterceptor(ClientErrorInterceptor handler)
+   {
+      getDelegate().addClientErrorInterceptor(handler);
+   }
+
+   @Override
+   public List<ClientErrorInterceptor> getClientErrorInterceptors()
+   {
+      return getDelegate().getClientErrorInterceptors();
+   }
+
+   @Override
+   public <T> StringParameterUnmarshaller<T> createStringParameterUnmarshaller(Class<T> clazz)
+   {
+      return super.createStringParameterUnmarshaller(clazz);
+   }
+
    @Override
    public boolean isBuiltinsRegistered()
    {",2009-10-30T21:26:53Z,159
"@@ -14,11 +14,11 @@
 import org.jboss.resteasy.plugins.delegates.CacheControlDelegate;
 import org.jboss.resteasy.plugins.delegates.CookieHeaderDelegate;
 import org.jboss.resteasy.plugins.delegates.EntityTagDelegate;
+import org.jboss.resteasy.plugins.delegates.LinkHeaderDelegate;
 import org.jboss.resteasy.plugins.delegates.LocaleDelegate;
 import org.jboss.resteasy.plugins.delegates.MediaTypeHeaderDelegate;
 import org.jboss.resteasy.plugins.delegates.NewCookieHeaderDelegate;
 import org.jboss.resteasy.plugins.delegates.UriHeaderDelegate;
-import org.jboss.resteasy.plugins.delegates.LinkHeaderDelegate;
 import org.jboss.resteasy.plugins.providers.RegisterBuiltin;
 import org.jboss.resteasy.specimpl.ResponseBuilderImpl;
 import org.jboss.resteasy.specimpl.UriBuilderImpl;
@@ -162,6 +162,7 @@ public Class getType()
    protected Map<Class<?>, Object> providers = new HashMap<Class<?>, Object>();
    protected Map<Class<?>, MediaTypeMap<ContextResolver>> contextResolvers = new HashMap<Class<?>, MediaTypeMap<ContextResolver>>();
    protected Map<Class<?>, StringConverter> stringConverters = new HashMap<Class<?>, StringConverter>();
+   protected Map<Class<?>, Class<? extends StringParameterUnmarshaller>> stringParameterUnmarshallers = new HashMap<Class<?>, Class<? extends StringParameterUnmarshaller>>();
 
    protected Map<Class<?>, HeaderDelegate> headerDelegates = new HashMap<Class<?>, HeaderDelegate>();
 
@@ -701,6 +702,23 @@ public void addStringConverter(StringConverter provider)
       }
    }
 
+   public void addStringParameterUnmarshaller(Class<? extends StringParameterUnmarshaller> provider)
+   {
+      Type[] intfs = provider.getClass().getGenericInterfaces();
+      for (Type type : intfs)
+      {
+         if (type instanceof ParameterizedType)
+         {
+            ParameterizedType pt = (ParameterizedType) type;
+            if (pt.getRawType().equals(StringParameterUnmarshaller.class))
+            {
+               Class<?> aClass = Types.getRawType(pt.getActualTypeArguments()[0]);
+               stringParameterUnmarshallers.put(aClass, provider);
+            }
+         }
+      }
+   }
+
    public List<ContextResolver> getContextResolvers(Class<?> clazz, MediaType type)
    {
       MediaTypeMap<ContextResolver> resolvers = contextResolvers.get(clazz);
@@ -714,6 +732,28 @@ public StringConverter getStringConverter(Class<?> clazz)
       return stringConverters.get(clazz);
    }
 
+   public <T> StringParameterUnmarshaller<T> createStringParameterUnmarshaller(Class<T> clazz)
+   {
+      if (stringParameterUnmarshallers.size() == 0) return null;
+      Class<? extends StringParameterUnmarshaller> un = stringParameterUnmarshallers.get(clazz);
+      StringParameterUnmarshaller<T> provider = null;
+      try
+      {
+         provider = un.newInstance();
+      }
+      catch (InstantiationException e)
+      {
+         throw new RuntimeException(e.getCause());
+      }
+      catch (IllegalAccessException e)
+      {
+         throw new RuntimeException(e);
+      }
+      PropertyInjectorImpl injector = new PropertyInjectorImpl(provider.getClass(), this);
+      injector.inject(provider);
+      return provider;
+
+   }
 
    public void registerProvider(Class provider)
    {
@@ -819,6 +859,10 @@ public void registerProvider(Class provider, boolean isBuiltin)
       {
          addStringConverter(provider);
       }
+      if (StringParameterUnmarshaller.class.isAssignableFrom(provider))
+      {
+         addStringParameterUnmarshaller(provider);
+      }
    }
 
    /**",2009-10-30T21:26:53Z,25
"@@ -0,0 +1,21 @@
+package org.jboss.resteasy.spi;
+
+import java.lang.annotation.Annotation;
+
+/**
+ * Similar to StringConverter except specific to a parameter injection only.  It is annotation sensitive.
+ * <p/>
+ * Instances of this class are created per parameter injection.
+ * setAnnotations() is called when the object is instantiated
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @See StringConverter
+ * @See org.jboss.resteasy.annotationsStringParameterUnmarshallerBinder
+ */
+public interface StringParameterUnmarshaller<T>
+{
+   void setAnnotations(Annotation[] annotations);
+
+   T fromString(String str);
+}",2009-10-30T21:26:53Z,160
"@@ -0,0 +1,91 @@
+package org.jboss.resteasy.test.finegrain.methodparams;
+
+import org.jboss.resteasy.annotations.StringParameterUnmarshallerBinder;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.spi.StringParameterUnmarshaller;
+import org.jboss.resteasy.test.BaseResourceTest;
+import static org.jboss.resteasy.test.TestPortProvider.*;
+import org.jboss.resteasy.util.FindAnnotation;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class StringParamUnmarshallerTest extends BaseResourceTest
+{
+   @Retention(RetentionPolicy.RUNTIME)
+   @StringParameterUnmarshallerBinder(DateFormatter.class)
+   public @interface DateFormat
+   {
+      String value();
+   }
+
+   public static class DateFormatter implements StringParameterUnmarshaller<Date>
+   {
+      private SimpleDateFormat formatter;
+
+      public void setAnnotations(Annotation[] annotations)
+      {
+         DateFormat format = FindAnnotation.findAnnotation(annotations, DateFormat.class);
+         formatter = new SimpleDateFormat(format.value());
+      }
+
+      public Date fromString(String str)
+      {
+         try
+         {
+            return formatter.parse(str);
+         }
+         catch (ParseException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+   }
+
+   @Path(""/datetest"")
+   public static class Service
+   {
+      @GET
+      @Produces(""text/plain"")
+      @Path(""/{date}"")
+      public String get(@PathParam(""date"") @DateFormat(""MM-dd-yyyy"") Date date)
+      {
+         System.out.println(date);
+         Calendar c = Calendar.getInstance();
+         c.setTime(date);
+         Assert.assertEquals(3, c.get(Calendar.MONTH));
+         Assert.assertEquals(23, c.get(Calendar.DAY_OF_MONTH));
+         Assert.assertEquals(1977, c.get(Calendar.YEAR));
+         return date.toString();
+      }
+   }
+
+   @BeforeClass
+   public static void setup() throws Exception
+   {
+      addPerRequestResource(Service.class);
+   }
+
+   @Test
+   public void testMe() throws Exception
+   {
+      ClientRequest request = new ClientRequest(generateURL(""/datetest/04-23-1977""));
+      System.out.println(request.getTarget(String.class));
+   }
+}",2009-10-30T21:26:53Z,161
"@@ -87,7 +87,7 @@ else if (isCookie)
                defaultVal = defaultValue.value();
 
             return new CookieParamInjector(type, genericType, method,
-                    cookieParam.value(), defaultVal, factory).inject(request,
+                    cookieParam.value(), defaultVal, annotations, factory).inject(request,
                     null);
          }
       }",2009-10-30T21:26:53Z,162
"@@ -14,6 +14,7 @@
 import org.apache.http.impl.conn.BasicClientConnectionManager;
 import org.apache.http.impl.conn.PoolingClientConnectionManager;
 import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
 import org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient4Engine;
 import org.jboss.resteasy.client.jaxrs.engines.PassthroughTrustManager;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
@@ -77,6 +78,10 @@ public static enum HostnameVerificationPolicy
    protected int maxPooledPerRoute = 0;
    protected long connectionTTL = -1;
    protected TimeUnit connectionTTLUnit = TimeUnit.MILLISECONDS;
+   protected long socketTimeout = -1;
+   protected TimeUnit socketTimeoutUnits = TimeUnit.MILLISECONDS;
+   protected long establishConnectionTimeout = -1;
+   protected TimeUnit establishConnectionTimeoutUnits = TimeUnit.MILLISECONDS;
    protected HostnameVerifier verifier = null;
    protected HttpHost defaultProxy;
 
@@ -104,13 +109,50 @@ public ResteasyClientBuilder asyncExecutor(ExecutorService asyncExecutor)
       return this;
    }
 
+   /**
+    * If there is a connection pool, set the time to live in the pool.
+    *
+    * @param ttl
+    * @param unit
+    * @return
+    */
    public ResteasyClientBuilder connectionTTL(long ttl, TimeUnit unit)
    {
       this.connectionTTL = ttl;
       this.connectionTTLUnit = unit;
       return this;
    }
 
+   /**
+    * Socket inactivity timeout
+    *
+    * @param timeout
+    * @param unit
+    * @return
+    */
+   public ResteasyClientBuilder socketTimeout(long timeout, TimeUnit unit)
+   {
+      this.socketTimeout = timeout;
+      this.socketTimeoutUnits = unit;
+      return this;
+   }
+
+   /**
+    *
+    *
+    * @param timeout
+    * @param unit
+    * @return
+    */
+   public ResteasyClientBuilder establishConnectionTimeout(long timeout, TimeUnit unit)
+   {
+      this.establishConnectionTimeout = timeout;
+      this.establishConnectionTimeoutUnits = unit;
+      return this;
+   }
+
+
+
    public ResteasyClientBuilder maxPooledPerRoute(int maxPooledPerRoute)
    {
       this.maxPooledPerRoute = maxPooledPerRoute;
@@ -306,11 +348,6 @@ else if (clientKeyStore != null || truststore != null)
          {
             sslsf = new SSLSocketFactory(SSLSocketFactory.TLS, clientKeyStore, clientPrivateKeyPassword, truststore, null, verifier);
          }
-         else if (connectionPoolSize <= 0)
-         {
-            // no special settings, just return the default
-            return new ApacheHttpClient4Engine();
-         }
          else
          {
             //sslsf = new SSLSocketFactory(SSLContext.getInstance(SSLSocketFactory.TLS), verifier);
@@ -337,7 +374,17 @@ else if (connectionPoolSize <= 0)
          {
             cm = new BasicClientConnectionManager(registry);
          }
-         httpClient = new DefaultHttpClient(cm, new BasicHttpParams());
+         BasicHttpParams params = new BasicHttpParams();
+         if (socketTimeout > -1)
+         {
+            HttpConnectionParams.setSoTimeout(params, (int) socketTimeoutUnits.toMillis(socketTimeout));
+
+         }
+         if (establishConnectionTimeout > -1)
+         {
+            HttpConnectionParams.setConnectionTimeout(params, (int)establishConnectionTimeoutUnits.toMillis(establishConnectionTimeout));
+         }
+         httpClient = new DefaultHttpClient(cm, params);
          ApacheHttpClient4Engine engine = new ApacheHttpClient4Engine(httpClient, true);
          engine.setHostnameVerifier(verifier);
          // this may be null.  We can't really support this with Apache Client.",2013-10-24T20:11:42Z,55
"@@ -37,6 +37,11 @@
             <artifactId>servlet-api</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+        </dependency>
+
     </dependencies>
 
 </project>",2013-10-24T20:11:42Z,163
"@@ -0,0 +1,99 @@
+package org.jboss.resteasy.test.nextgen.client;
+
+import org.jboss.resteasy.client.jaxrs.ClientHttpEngine;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.test.BaseResourceTest;
+import org.jboss.resteasy.test.TestPortProvider;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.ProcessingException;
+import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.core.Response;
+
+import java.net.SocketTimeoutException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class TimeoutTest extends BaseResourceTest
+{
+   /**
+    * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+    * @version $Revision: 1 $
+    */
+   @Path(""/timeout"")
+   public static interface TimeoutResource
+   {
+      @GET
+      @Produces(""text/plain"")
+      String get(@QueryParam(""sleep"") int sleep)  throws Exception;
+   }
+
+   @Path(""/timeout"")
+   public static class TimeoutResourceBean implements TimeoutResource
+   {
+      @Override
+      @GET
+      @Produces(""text/plain"")
+      public String get(@QueryParam(""sleep"") int sleep)  throws Exception
+      {
+          Thread.sleep(sleep * 1000);
+          return ""OK"";
+      }
+   }
+
+   @BeforeClass
+   public static void reg()
+   {
+      addPerRequestResource(TimeoutResourceBean.class);
+   }
+
+   @Test
+   public void testEcho()  throws Exception
+   {
+      ResteasyClient client1 = new ResteasyClientBuilder().socketTimeout(2, TimeUnit.SECONDS).build();
+      ClientHttpEngine engine = client1.httpEngine();
+      Assert.assertNotNull(engine);
+
+      ResteasyClient client = new ResteasyClientBuilder().httpEngine(engine).build();
+      ResteasyWebTarget target = client.target(TestPortProvider.generateURL(""/timeout""));
+      try
+      {
+         Response response = target.queryParam(""sleep"", ""5"").request().get();
+         Assert.fail();
+      }
+      catch (ProcessingException e)
+      {
+         Assert.assertEquals(e.getCause().getClass(), SocketTimeoutException.class);
+      }
+
+      TimeoutResource proxy = client.target(TestPortProvider.generateURL("""")).proxy(TimeoutResource.class);
+      try
+      {
+         proxy.get(5);
+         Assert.fail();
+      }
+      catch (ProcessingException e)
+      {
+         Assert.assertEquals(e.getCause().getClass(), SocketTimeoutException.class);
+      }
+
+   }
+
+   @Test
+   public void testEngine() throws Exception
+   {
+
+   }
+
+
+}",2013-10-24T20:11:42Z,164
"@@ -1,29 +1,29 @@
 Content-Type: application/pkcs7-mime;name=smime.p7m;smime-type=enveloped-data
-MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUHq
-pFCEMA0GCSqGSIb3DQEBAQUABIIBAB7UsbPTSHK5ZvCPC1vxc0Em5158RGEbYd2JcsWsPrBB+k5n
-LiQzd3lP4PRAvxg5xpu+Ew8sQcFvmbzTRflBlgBI359e5aGPWF9tYCzPGoutlh15s3yYYmlJKHUM
-cOgKNXSr9P9+WbzLjkun0vIASiRdfeeHWnlUh0iP6l0Ojx53tgYtbFgI2df3sJ1vjJRyro6qxg/T
-Rjxawxf5buQ77/J+sURGVQyXADodnRKxSkkE58D1D70n0V+TbhGDpiPPsCGfDORaVt7ck5ZcWo/K
-/G6zv8wq3LWiONx8kbrRby0K5VMPgr/spWa47AG8XSx+7T2qZF6zrU2LUueSdUKtYYMwgAYJKoZI
-hvcNAQcBMBQGCCqGSIb3DQMHBAiYE9BIAewklqCABIID6IfyjvhK7/qqf29W9/5qGmFadPwmNwwD
-wnm2zpJ7kXBaFMCC9bkU3yUpdtDhVRzGSMJzQzla6jYaQy7U3nLyjZyhtUak4sbeCKprK+iRPmkN
-lyWc00VKvZCEl++TKbfNcgCxFIlEHSeIO6FfQltM/L60PJ4FWFWL5N0AM8SGYAMqwARzPZRJvqyt
-LcFDPtL3JVyOxucgv1oj+AAExNMjAqXrIeFTfkD5EifJ/HS4HTCj8lQh9r2wrik5My2NaNi53zo/
-n2aZQLGbt+0MRsTichMJ4bH58iMK9TWdW1GtRba1LfLEWxr5sQEoJkKznsPmlk65S3gsj8ANZEse
-QSZqAEQvztPMVAoua8O3H7Z466ZgK1XA8X4u30UnsUApZDZgWnKZxXJLj2RzKvE7QEinrv4bKy67
-Op9W1TrUjEA4d2LbOfni4zbLHizF4H7eE8SFQyCmdBeLwMcMXZvZvEJV0BxfigBa+EqorVBbscJy
-BbfLzb8SepOGZubPXKvACXl4Mhng0oNhC8ghjjnsF2i8pkjLj+wyLYRhWAAnbY/RLjsW9viEjkbP
-U819QkntZLjQ5slkMRc6qfAsyE9YcgUuGog+mTu1OUxyQVyEWxoCZnxEHOdUUdEn/Hf9frdQG1u2
-ojQr580nb+hMbN6amcmDB4UMQexLHwut6x58dFYW2Ivs1vy/OMWj7S0Sv1qxiS3UxwZCJaUnS4jU
-oBBBcP7OhiPdFtiIpRbmzZJqm9+6vD8bq/GXeCWkydxJ3rhQkELzogZ3T5C8yG6yJhEjb5OCFaRT
-AfbHVl5/JMtTw6O01BPOr/p4jWQz2T/mNqU9SBQpPY23XPy0BjTLy7thtCMLgN3bpDSRnKapF8Oy
-mEeb5UNLQLdTEsAZT6LvOvSdCkM7D/JgfARg8smsLH0gNCL9EisO2Ske+YWzSUY4G5qdqcqAgcjp
-F9tZaYib/r6T8J3GgAep4t7DpNUuskzrVoHWxTIaH2gvHDpbDCHwcHHrR/pljHHuoPlG0WqnuG0f
-sTBrwVtOWvAfGSPk6cJONYcdYRRIS/eWRfs/p3hXbjAZx4c+G1K4SfpLHrQHEeURJmFZYws2oljd
-wlThIMdGsSL1UwIfKEl7TLhaC5sr8UvlmPlBG+rhzgQlGX88MgacVTL8o18AItjS+96RB5oeIMlU
-uhcchD0Jk6St1aQxlP5ztoK18PRRbWdE7oVJRwTM/20K4UhzzKbk5NiHkYoe9LlUKwjfrmbZlO+4
-m2UMUp1/NKTyXeFnTt6KyoYckmJrwloeYzN4Uy6XzLqXWab/twIP0sEpIm7CjNq/g4HqlumdXpaR
-Zr2smJeOsyMEgcAEd4OwrVVY9w7pGEr0u7x3ZbsaAKxKc/yZ6RmFAQOKfxogLdZRX+0AgeG/ZLk2
-NMPUoOJXkEXhwJ/nGAw++FXsTjxEVMZg7K/HPAmO/g31slas9fnsnG3uPULS2tAsRRGeiv0mJ+et
-ihpi1IC9wlwTfS5DXknZPHAhpkgU6NoA2CUld7cuQ+TDnPtk7fNGxvbJCtOTpC1I+j6tNX9G2KMV
-9xsRT86v1btgnGhgOXF9lH2aFy6HrETYkrMMrG78xq8AAAAAAAAAAAAA
\ No newline at end of file
+MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUHs
+APacMA0GCSqGSIb3DQEBAQUABIIBAAx+oIXbaomtkGdas7JTA+f9Q0kgbGzkqhAxGyY6jv02FoW8
+i7Tn8k6Sg0VkUESMqrAAV51LAux8mREZuPbS9tg5xrJ/ojOqvd77BBT7YKa8RWCo4pac55s+EMP8
+FvPWNIJjkEETcgnzjmmT/1Y1kJlEws3HzqYiZIYR6Nc+1wRaUvpEErjVPZp+V7tf6LnZxUWSlGus
+Pn081Vajprdi+x0xPPC22B89AV9QhwQG6MXeUPsYkJYjwzboKKu9SBZbRIpx2EX3JDrP51mmH5Sp
+zG/adxN4AGwqEkpCPlPvmtjGu0ncfsssLj0zVBcGPUCVSMCUEyDOebGSvHBrci+W5nIwgAYJKoZI
+hvcNAQcBMBQGCCqGSIb3DQMHBAgg4ebtbhJswKCABIID6EJ9YvVBOl96ZhtyJcKOrrnSvHa4cqGZ
+Q6aObaGWtkIF2VGmZXWDgFNCaSseUPTzCfWnkJqxzqau9uxGN+N47wKhI2mWWYqmDL0rO0I3b0DN
+Y3KxqzMLN6na97OqbvJZlBH+kQ72gFy9o7O9/6cQSfBdmdWBqzk5INY27N/19tgvcKESwsTi/yvn
+x3p5DN9iVFeMQHfvbTCdek9Js4XGekWzQ/ZKp+78RKxBqHwszVBafRBwAXcvUluCT/zVKttOKxgi
+qpolNecWTUyreNNTxb23IsCY2zgUG8pK/gIrA7Yz50YvikEoBwTLOS/Ed5YrjEYQhobcLzYpr+XM
+PPeMqW1ugrt1cZ2W3BVFJKhrKM9iOGWH1Kp9fAJV6bbCHfnwGEeN0Ip6EjYPTnwzZit54ed+3OH5
+Z0poydXmmUKTpi1uJ2/T4tftLgpLvWe2NUYH3SWmomVJb2+CoBIiYXH40w97PfWAd/a2rVShy/Cd
+cpB6ZhtZWeS1+S3NINhN28DmTlkH7a9TfCLGe4n0NNmdgPngS7qh36NEEGPB4g5PLmGz0RnuYb1B
+HnX2SlZYU3sN6G6PUSiITVqOC6cjVdIOWdwaVq19SrftkplCXQxuRoeYeLZxGnDEBeY8QYdL7Qbb
+AfgMinSXdJV0tefgEthJOVbJhmm1jZMnVXOc9y9f4EgGyoKVdCEBkeHDgU8PWfq8ijrdmL9etG3w
+LaswJM2tYULQOcb72SPyEzkrvOt/1dUmT0+ppAeNLO/06kTnrOQ/rzVXDo+0XX+y1Do56e9DWlPg
+1Yn1hxw41A1gNRGyKoWqyfRCv/8SVM7AGX0d+1/MuHK8N9dH8bVlqnsDOBpn25gcMCG9Ub9aT8ga
+a0T0+uv+B6nAdKXqflO2mnOmXsdzmOFofiQQZKcWUEh5Vx3qjHBtY/4fc1Ci3jPqF6EI6U2NIYKs
+Rms/shfWIeRaU2gJnISjf8VILrum4qAQvFOyoJKA2SZRIJuXVOJBvjY9QH3ZTHGbc/ylFMxji8HO
+mqa4/kHghtp17VGIbE6njZRV9Qf5Fiw6Ez+lmd8DPMM1q7RONlhzsAqDETu6VA3KQay7xj0lT635
+Al3hiIrfQh/ioHqR9HP/0CPuSuFBNxQc3YHZfGQ9HddzKh4tI3iDBKRgFJiTG91JaKth+SJ9N4cd
+y/l/zlVA3FclU9AjHjSnlp9/3hZQeKcUcFLlmuK1mv8C1e0NCk5NCCoCTCjFTtZJexAplWF9C78c
+MAQTNXuxW3cqs4V9WVqaW5AIjo6nWDj3EGNYb2aQ58XVM6vI4IgE94m+omBcZknxB1rzDn/Pcv+B
+GoglJI9N0tcEgbjusa1NhuYzQypIfOg87XCLz7WaMbQcthy49GpLCY12f8Zg4EfXOBpujw5xNO6G
+/7yvsK+khxlr6WDgUYS6TisqnWf46vHvaUGPV9XlUWxassJ3lSmjIN73QQjlnu5zBdXaF/2B/RNi
+1/IDX2pNkA0wYA8iUI8bBKNp9mk7uD21KrI1xM5UBOeSQF+O+feE5xUltmWDuaFNVbP52g+2iWgb
+dH63cAjO9N/+Nm1oYyX+1jIcfWHYSmedAAAAAAAAAAAAAA==
\ No newline at end of file",2013-10-24T20:11:42Z,165
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_19_221443134.1382621139379""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_15_2073262261.1382643988396""
 
-------=_Part_19_221443134.1382621139379
+------=_Part_15_2073262261.1382643988396
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_19_221443134.1382621139379
+------=_Part_15_2073262261.1382643988396
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDEzMjUzOVowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAVjQ7hhfkPlz89LbivclnwDSL
-yP/4Os+Z5LomwrjA/ZUoSvuC56y9b+rkeg9WKCgWwbRKEBvON6X0gVPBlUfCnsM9R/+BDN9ToyAs
-X4s9SQqmnvcRoo9FIMjfVlUkWBMkcjhqesjtKK+V4K1t6YY+bU0b8ZsyiXARwuS/AuS0k+EAAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDE5NDYyOFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAMzFJra6oILN0hxZvr3mB8DGp
+8zqa44sOXK+99EBMGseCoLyPNe4XpvLahE6Fbziwiea9z/7yK3nz+/tNQ+OARxtt75J052ILQSGn
+TzNHwJnTu6+FmFG8uxzrBGwT3Aia9BfOzc3EOZcXSx9OPGvbCfQK5sdLz5EY4n1rfa7OTdoAAAAA
 AAA=
-------=_Part_19_221443134.1382621139379--
+------=_Part_15_2073262261.1382643988396--",2013-10-24T20:11:42Z,166
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_21_98463786.1382621139384""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_17_113043185.1382643988402""
 
-------=_Part_21_98463786.1382621139384
+------=_Part_17_113043185.1382643988402
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_21_98463786.1382621139384
+------=_Part_17_113043185.1382643988402
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDEzMjUzOVowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAEhgWVAH8HE1SzeDpG2+wFn4P
-zB80Lwq88d9SPmyPuqRwW23NC47Lp/794X6Sc/c21k7n4pF6Jy0qIg3jT8cAYOZj2reYkcZgv0Z7
-RG7Gb/Tyv6TYzA1SF7pqD4sQX9jnHZlptoqOZIKInzwjIqeWJ/td5FHwzPiCFhy6RKLfi00AAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDE5NDYyOFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAor8h2MmtSu3E8XxvtzBqvrDB
+H+Asz3cqMmmDJPl+DLE8YoszOwD/lWvovv/KX6/64Eg3GL9WxAblTgORNj/fT7V8Ts4mTOEF2sf6
+2yKxPeLBZcgLGu+iM+b8u41FdNUacV0wmsNqPrMrWj21bjd+e9INpdBrawskiuRcs3VrL3wAAAAA
 AAA=
-------=_Part_21_98463786.1382621139384--
+------=_Part_17_113043185.1382643988402--",2013-10-24T20:11:42Z,167
"@@ -18,10 +18,26 @@
             with the modules/ directory of the JBoss AS7 distribution.  This will overwrite some of the existing files there.
         </para>
     </sect1>
+    <sect1 id=""upgrading-eap61"">
+        <title>Upgrading Resteasy Within JBoss EAP 6.1</title>
+        <para>
+            Resteasy is bundled with JBoss EAP 6.1.  You will likely have the need to upgrade Resteasy in JBoss EAP 6.1.  The Resteasy
+            distribution comes with a zip file called resteasy-jboss-modules-3.0-rc-1.zip.  Unzip this file while
+            with the modules/system/layers/base/ directory of the JBoss EAP 6.1 distribution.  This will overwrite some of the existing files there.
+        </para>
+    </sect1>
+    <sect1 id=""upgrading-wildfly"">
+        <title>Upgrading Resteasy Within Wildfly</title>
+        <para>
+            Resteasy is bundled with Wildfly.  You will likely have the need to upgrade Resteasy in Wildfly.  The Resteasy
+            distribution comes with a zip file called resteasy-jboss-modules-wf8-3.0-rc-1.zip.  Unzip this file while
+            with the modules/system/layers/base/ directory of the Wildfly distribution.  This will overwrite some of the existing files there.
+        </para>
+    </sect1>
     <sect1>
-        <title>Configuring in JBoss AS 7</title>
+        <title>Configuring in JBoss AS 7, EAP, and Wildfly</title>
         <para>
-            RESTEasy is bundled with JBoss AS 7 and completely integrated as per the requirements of Java EE 6.
+            RESTEasy is bundled with JBoss/Wildfly and completely integrated as per the requirements of Java EE 6.
             First you must at least provide an empty web.xml file.  You can of course deploy any custom servlet, filter
             or security constraint you want to within your web.xml, but the least amount of work is to create an empty
             web.xml file.  Also, resteasy context-params are available if you want to tweak turn on/off any specific
@@ -57,7 +73,7 @@
         </para>
     </sect1>
     <section>
-        <title>Resteasy Modules in AS7</title>
+        <title>Resteasy Modules in AS7, EAP6.1, Wildfly</title>
         <para>
             Resteasy and JAX-RS are automically loaded into your deployment's classpath, if and only if you are deploying
             a JAX-RS Application.  If you only want to use the client library, you will have to create a dependency
@@ -239,7 +255,7 @@
     <sect1>
         <title>Standalone Resteasy</title>
         <para>
-            If you are using resteasy outside of JBoss AS 7, you will need to do a few manual steps to install and
+            If you are using resteasy outside of JBoss/Wildfly, you will need to do a few manual steps to install and
             configure resteasy.
             RESTeasy is deployed as a WAR archive and thus depends on a Servlet container. We strongly suggest that you
             use Maven to build your WAR files as RESTEasy is split into",2013-06-10T13:21:39Z,168
"@@ -1,4 +1,4 @@
-<chapter id=""Atom"">
+<chapter id=""ContentRange"">
    <title>Content-Range Support</title>
    <para>
       Resteasy supports <literal>Range</literal> requests for <literal>java.io.File</literal> response entities.",2013-06-10T13:21:39Z,169
"@@ -1,6 +1,8 @@
 package org.jboss.resteasy.client.jaxrs.engines;
 
+import org.apache.commons.io.output.DeferredFileOutputStream;
 import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.entity.FileEntity;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
@@ -12,35 +14,104 @@
 import org.apache.http.client.params.HttpClientParams;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 import org.apache.http.protocol.HttpContext;
+import org.jboss.resteasy.client.ClientRequest;
 import org.jboss.resteasy.client.core.SelfExpandingBufferredInputStream;
 import org.jboss.resteasy.client.jaxrs.ClientHttpEngine;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.logging.Logger;
 import org.jboss.resteasy.util.CaseInsensitiveMap;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.ws.rs.ProcessingException;
 import javax.ws.rs.core.MultivaluedMap;
 import java.io.ByteArrayOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.management.ManagementFactory;
 import java.util.List;
 import java.util.Map;
+import java.util.logging.Level;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
 public class ApacheHttpClient4Engine implements ClientHttpEngine
 {
+   private final static Logger logger = Logger.getLogger(ApacheHttpClient4Engine.class);
+
+   /**
+    * Used to build temp file prefix.
+    */
+   private static String processId = null;
+
+   static
+   {
+      processId = ManagementFactory.getRuntimeMXBean().getName().replaceAll(""[^0-9a-zA-Z]"", """");
+   }
+
    protected HttpClient httpClient;
    protected boolean createdHttpClient;
    protected HttpContext httpContext;
    protected boolean closed;
    protected SSLContext sslContext;
    protected HostnameVerifier hostnameVerifier;
+   /**
+    * For uploading File's over JAX-RS framework, this property, together with {@link #fileUploadMemoryUnit},
+    * defines the maximum File size allowed in memory. If fileSize exceeds this size, it will be stored to
+    * {@link #fileUploadTempFileDir}. <br>
+    * <br>
+    * Defaults to 1 MB
+    */
+   protected int fileUploadInMemoryThresholdLimit = 1;
+
+   /**
+    * Enumeration to represent memory units.
+    */
+   public static enum MemoryUnit
+   {
+      /**
+       * Bytes
+       */
+      BY,
+      /**
+       * Killo Bytes
+       */
+      KB,
+
+      /**
+       * Mega Bytes
+       */
+      MB,
+
+      /**
+       * Giga Bytes
+       */
+      GB
+   }
+
+   /**
+    * The unit for {@link #fileUploadInMemoryThresholdLimit}. <br>
+    * <br>
+    * Defaults to MB.
+    *
+    * @see MemoryUnit
+    */
+   protected MemoryUnit fileUploadMemoryUnit = MemoryUnit.MB;
+
+   /**
+    * Temp directory to write output request stream to. Any file to be uploaded has to be written out to the
+    * output request stream to be sent to the service and when the File is too huge the output request stream is
+    * written out to the disk rather than to memory. <br>
+    * <br>
+    * Defaults to JVM temp directory.
+    */
+   protected File fileUploadTempFileDir = new File(System.getProperty(""java.io.tmpdir""));
 
 
    public ApacheHttpClient4Engine()
@@ -67,6 +138,40 @@ public ApacheHttpClient4Engine(HttpClient httpClient, HttpContext httpContext)
       this.httpContext = httpContext;
    }
 
+   /**
+    * Based on memory unit
+    * @return
+    */
+   public int getFileUploadInMemoryThresholdLimit()
+   {
+      return fileUploadInMemoryThresholdLimit;
+   }
+
+   public void setFileUploadInMemoryThresholdLimit(int fileUploadInMemoryThresholdLimit)
+   {
+      this.fileUploadInMemoryThresholdLimit = fileUploadInMemoryThresholdLimit;
+   }
+
+   public MemoryUnit getFileUploadMemoryUnit()
+   {
+      return fileUploadMemoryUnit;
+   }
+
+   public void setFileUploadMemoryUnit(MemoryUnit fileUploadMemoryUnit)
+   {
+      this.fileUploadMemoryUnit = fileUploadMemoryUnit;
+   }
+
+   public File getFileUploadTempFileDir()
+   {
+      return fileUploadTempFileDir;
+   }
+
+   public void setFileUploadTempFileDir(File fileUploadTempFileDir)
+   {
+      this.fileUploadTempFileDir = fileUploadTempFileDir;
+   }
+
    public HttpClient getHttpClient()
    {
       return httpClient;
@@ -132,6 +237,10 @@ public ClientResponse invoke(ClientInvocation request)
       {
          throw new ProcessingException(""Unable to invoke request"", e);
       }
+      finally
+      {
+         cleanUpAfterExecute(httpMethod);
+      }
 
       ClientResponse response = new ClientResponse(request.getClientConfiguration())
       {
@@ -262,15 +371,7 @@ protected void loadHttpMethod(final ClientInvocation request, HttpRequestBase ht
          request.getDelegatingOutputStream().setDelegate(baos);
          try
          {
-            request.writeRequestBody(request.getEntityStream());
-            ByteArrayEntity entity = new ByteArrayEntity(baos.toByteArray())
-            {
-               @Override
-               public Header getContentType()
-               {
-                  return new BasicHeader(""Content-Type"", request.getHeaders().getMediaType().toString());
-               }
-            };
+            HttpEntity entity = buildEntity(request);
             HttpPost post = (HttpPost) httpMethod;
             commitHeaders(request, httpMethod);
             post.setEntity(entity);
@@ -326,4 +427,166 @@ public void finalize() throws Throwable
       close();
       super.finalize();
    }
+
+   /**
+    * If passed httpMethod is of type HttpPost then obtain its entity. If the entity has an enclosing File then
+    * delete it by invoking this method after the request has completed. The entity will have an enclosing File
+    * only if it was too huge to fit into memory.
+    *
+    * @param httpMethod - the httpMethod to clean up.
+    */
+   protected void cleanUpAfterExecute(final HttpRequestBase httpMethod)
+   {
+      if (httpMethod != null && httpMethod instanceof HttpPost)
+      {
+         HttpPost postMethod = (HttpPost) httpMethod;
+         HttpEntity entity = postMethod.getEntity();
+         if (entity != null && entity instanceof FileExposingFileEntity)
+         {
+            File tempRequestFile = ((FileExposingFileEntity) entity).getFile();
+            try
+            {
+               boolean isDeleted = tempRequestFile.delete();
+               if (!isDeleted)
+               {
+                  handleFileNotDeletedError(tempRequestFile, null);
+               }
+            }
+            catch (Exception ex)
+            {
+               handleFileNotDeletedError(tempRequestFile, ex);
+            }
+         }
+      }
+   }
+
+   /**
+    * Build the HttpEntity to be sent to the Service as part of (POST) request. Creates a off-memory
+    * {@link FileExposingFileEntity} or a regular in-memory {@link ByteArrayEntity} depending on if the request
+    * OutputStream fit into memory when built by calling.
+    *
+    * @param request -
+    * @return - the built HttpEntity
+    * @throws IOException -
+    */
+   protected HttpEntity buildEntity(final ClientInvocation request) throws IOException
+   {
+      HttpEntity entityToBuild = null;
+      DeferredFileOutputStream memoryManagedOutStream = writeRequestBodyToOutputStream(request);
+
+      if (memoryManagedOutStream.isInMemory())
+      {
+         ByteArrayEntity entityToBuildByteArray = new ByteArrayEntity(memoryManagedOutStream.getData());
+         entityToBuildByteArray.setContentType(new BasicHeader(HTTP.CONTENT_TYPE, request.getHeaders().getMediaType().toString()));
+         entityToBuild = entityToBuildByteArray;
+      }
+      else
+      {
+         File requestBodyFile = memoryManagedOutStream.getFile();
+         requestBodyFile.deleteOnExit();
+         entityToBuild = new FileExposingFileEntity(memoryManagedOutStream.getFile(), request.getHeaders().getMediaType().toString());
+      }
+
+      return entityToBuild;
+   }
+
+   /**
+    * Creates the request OutputStream, to be sent to the end Service invoked, as a
+    * <a href=""http://commons.apache.org/io/api-release/org/apache/commons/io/output/DeferredFileOutputStream.html""
+    * >DeferredFileOutputStream</a>.
+    *
+    *
+    * @param request -
+    * @return - DeferredFileOutputStream with the ClientRequest written out per HTTP specification.
+    * @throws IOException -
+    */
+   private DeferredFileOutputStream writeRequestBodyToOutputStream(final ClientInvocation request) throws IOException
+   {
+      DeferredFileOutputStream memoryManagedOutStream =
+              new DeferredFileOutputStream(this.fileUploadInMemoryThresholdLimit * getMemoryUnitMultiplier(),
+                      getTempfilePrefix(), "".tmp"", this.fileUploadTempFileDir);
+      request.getDelegatingOutputStream().setDelegate(memoryManagedOutStream);
+      request.writeRequestBody(request.getEntityStream());
+      memoryManagedOutStream.close();
+      return memoryManagedOutStream;
+   }
+
+   /**
+    * Use context information, which will include node name, to avoid conflicts in case of multiple VMS using same
+    * temp directory location.
+    *
+    * @return -
+    */
+   protected String getTempfilePrefix()
+   {
+      return processId;
+   }
+   /**
+    * @return - the constant to multiply {@link #fileUploadInMemoryThresholdLimit} with based on
+    *         {@link #fileUploadMemoryUnit} enumeration value.
+    */
+   private int getMemoryUnitMultiplier()
+   {
+      switch (this.fileUploadMemoryUnit)
+      {
+         case BY:
+            return 1;
+         case KB:
+            return 1024;
+         case MB:
+            return 1024 * 1024;
+         case GB:
+            return 1024 * 1024 * 1024;
+      }
+      return 1;
+   }
+
+
+
+   /**
+    * Log that the file did not get deleted but prevent the request from failing by eating the exception. The file
+    * has been registered to delete on exit, so it will get deleted eventually.
+    *
+    * @param tempRequestFile -
+    * @param ex - a null may be passed in which case this param gets ignored.
+    */
+   private void handleFileNotDeletedError(File tempRequestFile, Exception ex)
+   {
+      logger.warn(""Could not delete file' "" + tempRequestFile.getAbsolutePath() + ""' for request: "", ex);
+   }
+
+
+
+
+   /**
+    * We use {@link org.apache.http.entity.FileEntity} as the {@link HttpEntity} implementation when the request OutputStream has been
+    * saved to a File on disk (because it was too large to fit into memory see however, we have to delete
+    * the File supporting the <code>FileEntity</code>, otherwise the disk will soon run out of space - remember
+    * that there can be very huge files, in GB range, processed on a regular basis - and FileEntity exposes its
+    * content File as a protected field. For the enclosing parent class ( {@link ApacheHttpClient4Engine} ) to be
+    * able to get a handle to this content File and delete it, this class expose the content File.<br>
+    * This class is private scoped to prevent access to this content File outside of the parent class.
+    *
+    * @author <a href=""mailto:stikoo@digitalriver.com"">Sandeep Tikoo</a>
+    */
+   private static class FileExposingFileEntity extends FileEntity
+   {
+      /**
+       * @param pFile -
+       * @param pContentType -
+       */
+      public FileExposingFileEntity(File pFile, String pContentType)
+      {
+         super(pFile, pContentType);
+      }
+
+      /**
+       * @return - the content File enclosed by this FileEntity.
+       */
+      File getFile()
+      {
+         return this.file;
+      }
+   }
+
 }
\ No newline at end of file",2013-06-10T13:21:39Z,15
"@@ -0,0 +1,165 @@
+package org.jboss.resteasy.test.nextgen.client;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.entity.ByteArrayEntity;
+import org.apache.http.entity.FileEntity;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient4Engine;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *          <p/>
+ *          Copyright Sep 29, 2012
+ */
+public class EntityBufferingInFileTest
+{
+   private static final Logger log = Logger.getLogger(EntityBufferingInFileTest.class);
+
+   protected ResteasyDeployment deployment;
+
+   @Path(""/"")
+   static public class TestResource
+   {
+      @POST
+      @Produces(""text/plain"")
+      @Path(""hello"")
+      public String resourceMethod(String body)
+      {
+         System.out.println(""entered resourceMethod()"");
+         return body;
+      }
+   }
+
+   @Before
+   public void before() throws Exception
+   {
+      deployment = EmbeddedContainer.start();
+      deployment.getRegistry().addPerRequestResource(TestResource.class);
+   }
+
+   @After
+   public void after() throws Exception
+   {
+      EmbeddedContainer.stop();
+      deployment = null;
+   }
+
+   @Test
+   public void testInMemoryBytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.BY, 16, 10, true);
+   }
+
+   @Test
+   public void testOnDiskBytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.BY, 16, 20, false);
+   }
+
+   @Test
+   public void testInMemoryKilobytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.KB, 1, 500, true);
+   }
+
+   @Test
+   public void testOnDiskKilobytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.KB, 1, 2000, false);
+   }
+
+   @Test
+   public void testInMemoryMegabytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.MB, 1, 500000, true);
+   }
+
+   @Test
+   public void testOnDiskMegabytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.MB, 1, 2000000, false);
+   }
+
+   @Test
+   public void testInMemoryGigabytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.GB, 1, 500000000, true);
+   }
+
+   @Test
+   public void testOnDiskGigabytes() throws Exception
+   {
+      doTest(ApacheHttpClient4Engine.MemoryUnit.GB, 1, 2000000000, false);
+   }
+
+   protected void doTest(ApacheHttpClient4Engine.MemoryUnit memoryUnit, int threshold, int length, boolean inMemory) throws Exception
+   {
+      try
+      {
+         TestClientExecutor executor = new TestClientExecutor();
+         executor.setFileUploadMemoryUnit(memoryUnit);
+         executor.setFileUploadInMemoryThresholdLimit(threshold);
+         StringBuffer sb = new StringBuffer();
+         for (int i = 0; i < length; i++)
+         {
+            sb.append(""0"");
+         }
+         String body = sb.toString();
+
+         ResteasyClient client = new ResteasyClientBuilder().httpEngine(executor).build();
+         Response response = client.target(generateURL(""/hello"")).request().post(Entity.text(body));
+         System.out.println(""Received response"");
+         Assert.assertEquals(200, response.getStatus());
+         Assert.assertEquals(body, response.readEntity(String.class));
+         if (inMemory)
+         {
+            Assert.assertTrue(executor.getBuildEntity() instanceof ByteArrayEntity);
+         }
+         else
+         {
+            Assert.assertTrue(executor.getBuildEntity() instanceof FileEntity);
+         }
+      }
+      catch (OutOfMemoryError e)
+      {
+         // Ok, skip it.
+         log.info(""OutOfMemoryError on "" + memoryUnit + "" test."");
+
+      }
+   }
+
+   static class TestClientExecutor extends ApacheHttpClient4Engine
+   {
+      private HttpEntity entityToBuild;
+
+      protected HttpEntity buildEntity(final ClientInvocation request) throws IOException
+      {
+         entityToBuild = super.buildEntity(request);
+         return entityToBuild;
+      }
+
+      public HttpEntity getBuildEntity()
+      {
+         return entityToBuild;
+      }
+   }
+}",2013-06-10T13:21:39Z,170
"@@ -61,10 +61,7 @@ public void writeTo(InputStream inputStream, Class<?> type, Type genericType, An
 		   }
 		   else
 			   entityStream.write(c);
-		   while ((c = inputStream.read()) != -1)
-		   {
-			   entityStream.write(c);
-		   }
+         ProviderHelper.writeTo(inputStream, entityStream);
 	   }
 	   finally
 	   {",2013-06-10T13:21:39Z,171
"@@ -20,6 +20,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
 /**
  * 
  * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
@@ -121,7 +123,7 @@ protected void doTest(String memoryUnit, int threshold, int length, boolean inMe
          sb.append(""0"");
       }
       String body = sb.toString();
-      ClientRequest request = new ClientRequest(""http://localhost:8081/hello/"", executor);
+      ClientRequest request = new ClientRequest(generateURL(""/hello""), executor);
       request.body(""text/plain"", body);
       System.out.println(""Sending request"");
       ClientResponse<String> response = request.post(String.class);",2013-06-10T13:21:39Z,44
"@@ -25,6 +25,7 @@
         <dep.guice.version>3.0</dep.guice.version>
         <dep.jboss-el.version>1.0_02.CR4</dep.jboss-el.version>
         <dep.netty.version>3.6.4.Final</dep.netty.version>
+        <dep.netty4.version>4.0.6.Final</dep.netty4.version>
     </properties>
 
     <url>http://rest-easy.org</url>",2013-08-13T21:09:44Z,117
"@@ -16,5 +16,6 @@
     <modules>
         <module>resteasy-jdk-http</module>
         <module>resteasy-netty</module>
+        <module>resteasy-netty4</module>
     </modules>
 </project>",2013-08-13T21:09:44Z,172
"@@ -0,0 +1,45 @@
+<?xml version=""1.0""?>
+<project>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>resteasy-netty4</artifactId>
+    <name>RESTEasy Netty 4 Integration</name>
+    <description/>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>${dep.netty4.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2013-08-13T21:09:44Z,135
"@@ -0,0 +1,221 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.SynchronousExecutionContext;
+import org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.NotImplementedYetException;
+import org.jboss.resteasy.spi.ResteasyAsynchronousContext;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.Encode;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * Abstraction for an inbound http request on the server, or a response from a server to a client
+ * <p/>
+ * We have this abstraction so that we can reuse marshalling objects in a client framework and serverside framework
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
+{
+   protected ResteasyHttpHeaders httpHeaders;
+   protected SynchronousDispatcher dispatcher;
+   protected ResteasyUriInfo uriInfo;
+   protected String httpMethod;
+   protected MultivaluedMap<String, String> formParameters;
+   protected MultivaluedMap<String, String> decodedFormParameters;
+   protected InputStream inputStream;
+   protected Map<String, Object> attributes = new HashMap<String, Object>();
+   protected NettyHttpResponse httpResponse;
+   private final boolean is100ContinueExpected;
+
+
+   public NettyHttpRequest(ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse httpResponse, boolean is100ContinueExpected)
+   {
+      this.is100ContinueExpected = is100ContinueExpected;
+      this.httpResponse = httpResponse;
+      this.dispatcher = dispatcher;
+      this.httpHeaders = httpHeaders;
+      this.httpMethod = httpMethod;
+      this.uriInfo = uri;
+
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return httpHeaders.getMutableHeaders();
+   }
+
+   @Override
+   public void setHttpMethod(String method)
+   {
+      this.httpMethod = method;
+   }
+
+   @Override
+   public Enumeration<String> getAttributeNames()
+   {
+      Enumeration<String> en = new Enumeration<String>()
+      {
+         private Iterator<String> it = attributes.keySet().iterator();
+         @Override
+         public boolean hasMoreElements()
+         {
+            return it.hasNext();
+         }
+
+         @Override
+         public String nextElement()
+         {
+            return it.next();
+         }
+      };
+      return en;
+   }
+
+   @Override
+   public ResteasyAsynchronousContext getAsyncContext()
+   {
+      return new SynchronousExecutionContext(dispatcher, this, httpResponse);
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getFormParameters()
+   {
+      if (formParameters != null) return formParameters;
+      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      {
+         try
+         {
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+      else
+      {
+         throw new IllegalArgumentException(""Request media type is not application/x-www-form-urlencoded"");
+      }
+      return formParameters;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getDecodedFormParameters()
+   {
+      if (decodedFormParameters != null) return decodedFormParameters;
+      decodedFormParameters = Encode.decode(getFormParameters());
+      return decodedFormParameters;
+   }
+
+
+   @Override
+   public Object getAttribute(String attribute)
+   {
+      return attributes.get(attribute);
+   }
+
+   @Override
+   public void setAttribute(String name, Object value)
+   {
+      attributes.put(name, value);
+   }
+
+   @Override
+   public void removeAttribute(String name)
+   {
+      attributes.remove(name);
+   }
+
+   @Override
+   public HttpHeaders getHttpHeaders()
+   {
+      return httpHeaders;
+   }
+
+   @Override
+   public InputStream getInputStream()
+   {
+      return inputStream;
+   }
+
+   @Override
+   public void setInputStream(InputStream stream)
+   {
+      this.inputStream = stream;
+   }
+
+   @Override
+   public ResteasyUriInfo getUri()
+   {
+      return uriInfo;
+   }
+
+   @Override
+   public String getHttpMethod()
+   {
+      return httpMethod;
+   }
+
+   @Override
+   public void setRequestUri(URI requestUri) throws IllegalStateException
+   {
+      uriInfo = uriInfo.setRequestUri(requestUri);
+   }
+
+   @Override
+   public void setRequestUri(URI baseUri, URI requestUri) throws IllegalStateException
+   {
+      uriInfo = new ResteasyUriInfo(baseUri.resolve(requestUri));
+   }
+
+
+   @Override
+   public boolean isInitial()
+   {
+      return true;
+   }
+
+   public NettyHttpResponse getResponse()
+   {
+       return httpResponse;
+   }
+
+   public boolean isKeepAlive()
+   {
+       return httpResponse.isKeepAlive();
+   }
+
+   public boolean is100ContinueExpected()
+   {
+       return is100ContinueExpected;
+   }
+
+   @Override
+   public void forward(String path)
+   {
+      throw new NotImplementedYetException();
+   }
+
+   @Override
+   public boolean wasForwarded()
+   {
+      return false;
+   }
+
+}",2013-08-13T21:09:44Z,136
"@@ -0,0 +1,142 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.spi.HttpResponse;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.NewCookie;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyHttpResponse implements HttpResponse
+{
+   private int status = 200;
+   private ByteBuf byteBuf;
+   private OutputStream os;
+   private MultivaluedMap<String, Object> outputHeaders;
+   private final ChannelHandlerContext ctx;
+   private boolean committed;
+   private boolean keepAlive;
+
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   {
+      outputHeaders = new MultivaluedMapImpl<String, Object>();
+      byteBuf = Unpooled.buffer();
+      os = new ByteBufOutputStream(byteBuf);
+      this.ctx = ctx;
+      this.keepAlive = keepAlive;
+   }
+
+   @Override
+   public void setOutputStream(OutputStream os)
+   {
+      this.os = os;
+   }
+
+   public ByteBuf getBuffer()
+   {
+      return byteBuf;
+   }
+
+   @Override
+   public int getStatus()
+   {
+      return status;
+   }
+
+   @Override
+   public void setStatus(int status)
+   {
+      this.status = status;
+   }
+
+   @Override
+   public MultivaluedMap<String, Object> getOutputHeaders()
+   {
+      return outputHeaders;
+   }
+
+   @Override
+   public OutputStream getOutputStream() throws IOException
+   {
+      return os;
+   }
+
+   @Override
+   public void addNewCookie(NewCookie cookie)
+   {
+      outputHeaders.add(HttpHeaders.SET_COOKIE, cookie);
+   }
+
+   @Override
+   public void sendError(int status) throws IOException
+   {
+      sendError(status, null);
+   }
+
+   @Override
+   public void sendError(int status, String message) throws IOException
+   {
+       if (committed)
+       {
+           throw new IllegalStateException();
+       }
+
+       final HttpResponseStatus responseStatus;
+       if (message != null)
+       {
+           responseStatus = new HttpResponseStatus(status, message);
+           setStatus(status);
+       }
+       else
+       {
+           responseStatus = HttpResponseStatus.valueOf(status);
+           setStatus(status);
+       }
+       final io.netty.handler.codec.http.HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, responseStatus);
+       if (keepAlive)
+       {
+           // Add keep alive and content length if needed
+           response.headers().add(Names.CONNECTION, Values.KEEP_ALIVE);
+           response.headers().add(Names.CONTENT_LENGTH, 0);
+       }
+       ctx.writeAndFlush(response);
+       committed = true;
+   }
+
+   @Override
+   public boolean isCommitted()
+   {
+      return committed;
+   }
+
+   @Override
+   public void reset()
+   {
+      if (committed)
+      {
+          throw new IllegalStateException(""Already committed"");
+      }
+      outputHeaders.clear();
+      byteBuf.clear();
+      outputHeaders.clear();
+   }
+
+   public boolean isKeepAlive() {
+       return keepAlive;
+   }
+}",2013-08-13T21:09:44Z,137
"@@ -0,0 +1,188 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import resteasy.plugins.server.netty.RequestDispatcher;
+import resteasy.plugins.server.netty.RequestHandler;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder.Protocol;
+import resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup bossGroup;
+   private EventLoopGroup workerGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      bossGroup = new NioEventLoopGroup();
+      workerGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+       try {
+           bootstrap.bind(port).sync();
+       } catch (InterruptedException e) {
+           // ignore
+       }
+   }
+
+   @Override
+   public void stop()
+   {
+       workerGroup.shutdownGracefully();
+       bossGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,14
"@@ -0,0 +1,54 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+
+import javax.ws.rs.core.SecurityContext;
+import java.security.Principal;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettySecurityContext implements SecurityContext
+{
+   protected final Principal principal;
+   protected final SecurityDomain domain;
+   protected final String authScheme;
+   protected final boolean isSecure;
+
+   public NettySecurityContext(Principal principal, SecurityDomain domain, String authScheme, boolean secure)
+   {
+      this.principal = principal;
+      this.domain = domain;
+      this.authScheme = authScheme;
+      isSecure = secure;
+   }
+   public NettySecurityContext() {
+       this(null, null, null, false);
+   }
+
+   @Override
+   public Principal getUserPrincipal()
+   {
+      return principal;
+   }
+
+   @Override
+   public boolean isUserInRole(String role)
+   {
+      if (domain == null) return false;
+      return domain.isUserInRoll(principal, role);
+   }
+
+   @Override
+   public boolean isSecure()
+   {
+      return isSecure;
+   }
+
+   @Override
+   public String getAuthenticationScheme()
+   {
+      return authScheme;
+   }
+}",2013-08-13T21:09:44Z,173
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.PathHelper;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyUtil
+{
+   public static ResteasyUriInfo extractUriInfo(HttpRequest request, String contextPath, String protocol)
+   {
+      String host = HttpHeaders.getHost(request, ""unknown"");
+      String uri = request.getUri();
+
+      URI absoluteURI = URI.create(protocol + ""://"" + host + uri);
+
+      String path = PathHelper.getEncodedPathInfo(absoluteURI.getRawPath(), contextPath);
+      if (!path.startsWith(""/""))
+      {
+         path = ""/"" + path;
+      }
+
+      URI baseURI = absoluteURI;
+      if (!path.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = UriBuilder.fromUri(absoluteURI).replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      else
+      {
+         baseURI = UriBuilder.fromUri(absoluteURI).replaceQuery(null).build();
+      }
+      URI relativeURI = UriBuilder.fromUri(path).replaceQuery(absoluteURI.getRawQuery()).build();
+      //System.out.println(""path: "" + path);
+      //System.out.println(""query string: "" + request.getQueryString());
+      ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
+      return uriInfo;
+   }
+
+   public static ResteasyHttpHeaders extractHttpHeaders(HttpRequest request)
+   {
+
+      MultivaluedMap<String, String> requestHeaders = extractRequestHeaders(request);
+      ResteasyHttpHeaders headers = new ResteasyHttpHeaders(requestHeaders);
+
+      Map<String, Cookie> cookies = extractCookies(requestHeaders);
+      headers.setCookies(cookies);
+      // test parsing should throw an exception on error
+      headers.testParsing();
+      return headers;
+
+   }
+
+   static Map<String, Cookie> extractCookies(MultivaluedMap<String, String> headers)
+   {
+      Map<String, Cookie> cookies = new HashMap<String, Cookie>();
+      List<String> cookieHeaders = headers.get(""Cookie"");
+      if (cookieHeaders == null) return cookies;
+
+      for (String cookieVal : cookieHeaders)
+      {
+         Cookie cookie = Cookie.valueOf(cookieVal);
+         cookies.put(cookie.getName(), cookie);
+      }
+      return cookies;
+   }
+
+   public static List<MediaType> extractAccepts(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT);
+      if (accepts == null) return acceptableMediaTypes;
+
+      for (String accept : accepts)
+      {
+         acceptableMediaTypes.addAll(MediaTypeHelper.parseHeader(accept));
+      }
+      return acceptableMediaTypes;
+   }
+
+   public static List<String> extractLanguages(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<String> acceptable = new ArrayList<String>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE);
+      if (accepts == null) return acceptable;
+
+      for (String accept : accepts)
+      {
+         String[] splits = accept.split("","");
+         for (String split : splits) acceptable.add(split.trim());
+      }
+      return acceptable;
+   }
+
+   public static MultivaluedMap<String, String> extractRequestHeaders(HttpRequest request)
+   {
+      Headers<String> requestHeaders = new Headers<String>();
+
+      for (Map.Entry<String, String> header : request.headers())
+      {
+         requestHeaders.add(header.getKey(), header.getValue());
+      }
+      return requestHeaders;
+   }
+}",2013-08-13T21:09:44Z,174
"@@ -0,0 +1,141 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.apache.commons.codec.binary.Base64;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.SecurityContext;
+import java.io.IOException;
+import java.security.Principal;
+import java.util.List;
+
+/**
+ * Helper/delegate class to unify Servlet and Filter dispatcher implementations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class RequestDispatcher
+{
+   protected final SynchronousDispatcher dispatcher;
+   protected final ResteasyProviderFactory providerFactory;
+   protected final SecurityDomain domain;
+
+   public RequestDispatcher(SynchronousDispatcher dispatcher, ResteasyProviderFactory providerFactory, SecurityDomain domain)
+   {
+      this.dispatcher = dispatcher;
+      this.providerFactory = providerFactory;
+      this.domain = domain;
+   }
+
+   public SynchronousDispatcher getDispatcher()
+   {
+      return dispatcher;
+   }
+
+   public SecurityDomain getDomain()
+   {
+      return domain;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void service(HttpRequest request, HttpResponse response, boolean handleNotFound) throws IOException
+   {
+
+      try
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.push(providerFactory);
+         }
+
+         SecurityContext securityContext;
+         if (domain != null)
+         {
+            securityContext = basicAuthentication(request, response);
+            if (securityContext == null) // not authenticated
+            {
+               return;
+            }
+         } else {
+            securityContext = new NettySecurityContext();
+         }
+         try
+         {
+
+            ResteasyProviderFactory.pushContext(SecurityContext.class, securityContext);
+            if (handleNotFound)
+            {
+               dispatcher.invoke(request, response);
+            }
+            else
+            {
+               dispatcher.invokePropagateNotFound(request, response);
+            }
+         }
+         finally
+         {
+            ResteasyProviderFactory.clearContextData();
+         }
+      }
+      finally
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.pop();
+         }
+
+      }
+   }
+
+   private SecurityContext basicAuthentication(HttpRequest request, HttpResponse response) throws IOException
+   {
+      List<String> headers = request.getHttpHeaders().getRequestHeader(HttpHeaderNames.AUTHORIZATION);
+      if (!headers.isEmpty()) {
+         String auth = headers.get(0);
+         if (auth.length() > 5)
+         {
+            String type = auth.substring(0, 5);
+            type = type.toLowerCase();
+            if (""basic"".equals(type))
+            {
+               String cookie = auth.substring(6);
+               cookie = new String(Base64.decodeBase64(cookie.getBytes()));
+               String[] split = cookie.split("":"");
+               Principal user = null;
+               try
+               {
+                  user = domain.authenticate(split[0], split[1]);
+                  return new NettySecurityContext(user, domain, ""BASIC"", true);
+               }
+               catch (SecurityException e)
+               {
+                  response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+                  return null;
+               }
+            }
+            else
+            {
+               response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+               return null;
+            }
+         }
+      }
+      return null;
+   }
+
+
+}
\ No newline at end of file",2013-08-13T21:09:44Z,175
"@@ -0,0 +1,104 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.Failure;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which handles the requests and dispatch them.
+ *
+ * This class is {@link Sharable}.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
+ */
+@Sharable
+public class RequestHandler extends ChannelInboundHandlerAdapter
+{
+   protected final RequestDispatcher dispatcher;
+   private final static Logger logger = Logger.getLogger(RequestHandler.class);
+
+   public RequestHandler(RequestDispatcher dispatcher)
+   {
+      this.dispatcher = dispatcher;
+   }
+
+   @Override
+   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
+   {
+      if (msg instanceof NettyHttpRequest) {
+          NettyHttpRequest request = (NettyHttpRequest) msg;
+
+          if (request.is100ContinueExpected())
+          {
+             send100Continue(ctx);
+          }
+
+          NettyHttpResponse response = request.getResponse();
+          try
+          {
+             dispatcher.service(request, response, true);
+          }
+          catch (Failure e1)
+          {
+             response.reset();
+             response.setStatus(e1.getErrorCode());
+             return;
+          }
+          catch (Exception ex)
+          {
+             response.reset();
+             response.setStatus(500);
+             logger.error(""Unexpected"", ex);
+             return;
+          }
+
+          // Write the response.
+          ChannelFuture future = ctx.writeAndFlush(response);
+
+          // Close the non-keep-alive connection after the write operation is done.
+          if (!request.isKeepAlive())
+          {
+             future.addListener(ChannelFutureListener.CLOSE);
+          }
+      }
+   }
+
+   private void send100Continue(ChannelHandlerContext ctx)
+   {
+      HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+      ctx.writeAndFlush(response);
+   }
+
+   @Override
+   public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
+           throws Exception
+   {
+      // handle the case of to big requests.
+      if (e.getCause() instanceof TooLongFrameException)
+      {
+          DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, REQUEST_ENTITY_TOO_LARGE);
+          ctx.write(response).addListener(ChannelFutureListener.CLOSE);
+      }
+      else
+      {
+          e.getCause().printStackTrace();
+          ctx.close();
+      }
+
+   }
+}",2013-08-13T21:09:44Z,138
"@@ -0,0 +1,86 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected;
+
+/**
+ * This {@link MessageToMessageDecoder} is responsible for decode {@link io.netty.handler.codec.http.HttpRequest}
+ * to {@link NettyHttpRequest}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.HttpRequest>
+{
+    private final static Logger logger = Logger.getLogger(RestEasyHttpRequestDecoder.class);
+
+    private final SynchronousDispatcher dispatcher;
+    private final String servletMappingPrefix;
+    private final String proto;
+
+    public enum Protocol
+    {
+        HTTPS,
+        HTTP
+    }
+
+    public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servletMappingPrefix, Protocol protocol)
+    {
+        this.dispatcher = dispatcher;
+        this.servletMappingPrefix = servletMappingPrefix;
+        if (protocol == Protocol.HTTP)
+        {
+            proto = ""http"";
+        }
+        else
+        {
+            proto = ""https"";
+        }
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
+    {
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
+        NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        ResteasyHttpHeaders headers = null;
+        ResteasyUriInfo uriInfo = null;
+        try
+        {
+           headers = NettyUtil.extractHttpHeaders(request);
+
+           uriInfo = NettyUtil.extractUriInfo(request, servletMappingPrefix, proto);
+           NettyHttpRequest nettyRequest = new NettyHttpRequest(headers, uriInfo, request.getMethod().name(), dispatcher, response, is100ContinueExpected(request) );
+           if (request instanceof HttpContent)
+           {
+               HttpContent content = (HttpContent) request;
+               ByteBuf buf = content.content().copy();
+               ByteBufInputStream in = new ByteBufInputStream(buf);
+               nettyRequest.setInputStream(in);
+               out.add(nettyRequest);
+           }
+        }
+        catch (Exception e)
+        {
+           response.sendError(400);
+           // made it warn so that people can filter this.
+           logger.warn(""Failed to parse request."", e);
+        }
+    }
+}",2013-08-13T21:09:44Z,139
"@@ -0,0 +1,76 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.util.List;
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+
+/**
+ * {@link MessageToMessageEncoder} implementation which encodes {@link org.jboss.resteasy.spi.HttpResponse}'s to
+ * {@link HttpResponse}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpResponseEncoder extends MessageToMessageEncoder<NettyHttpResponse>
+{
+
+    private final RequestDispatcher dispatcher;
+
+    public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
+    {
+        this.dispatcher = dispatcher;
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
+    {
+        // Build the response object.
+        HttpResponseStatus status = HttpResponseStatus.valueOf(nettyResponse.getStatus());
+        ByteBuf buffer = nettyResponse.getBuffer();
+        HttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, buffer);
+
+        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+        {
+           String key = entry.getKey();
+           for (Object value : entry.getValue())
+           {
+              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
+              if (delegate != null)
+              {
+                  response.headers().add(key, delegate.toString(value));
+              }
+              else
+              {
+                 response.headers().set(key, value.toString());
+              }
+           }
+        }
+
+        if (nettyResponse.isKeepAlive())
+        {
+            // Add content length and connection header if needed
+            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+        }
+        out.add(response);
+    }
+
+}",2013-08-13T21:09:44Z,140
"@@ -0,0 +1,72 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyContainer
+{
+   public static NettyJaxrsServer netty;
+
+   public static ResteasyDeployment start() throws Exception
+   {
+      return start("""");
+   }
+
+   public static ResteasyDeployment start(String bindPath) throws Exception
+   {
+      return start(bindPath, null);
+   }
+
+   public static void start(ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath("""");
+      netty.setSecurityDomain(null);
+      netty.start();
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setSecurityEnabled(true);
+      return start(bindPath, domain, deployment);
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain, ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath(bindPath);
+      netty.setSecurityDomain(domain);
+      netty.start();
+      return netty.getDeployment();
+   }
+
+   public static void stop() throws Exception
+   {
+      if (netty != null)
+      {
+         try
+         {
+            netty.stop();
+         }
+         catch (Exception e)
+         {
+
+         }
+      }
+      netty = null;
+   }
+
+   public static void main(String args[]) throws Exception {
+       start();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,176
"@@ -15,6 +15,7 @@
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import java.io.ByteArrayInputStream;
+import java.net.URI;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -38,6 +39,17 @@ public String create(String cust)
 
    }
 
+   @Test
+   public void testUri() throws Exception
+   {
+      URI uri = URI.create(""/foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+      System.out.println(""---"");
+      uri = URI.create(""foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+   }
 
    @Test
    public void testCleartext() throws Exception",2014-01-26T16:19:49Z,177
"@@ -38,6 +38,8 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
             contextPath += ""/"";
          contextPath += servletPrefix;
       }
+      return new ResteasyUriInfo(request.getRequestURL().toString(), request.getQueryString(), contextPath);
+      /*
       URI absolutePath = null;
       try
       {
@@ -70,6 +72,7 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
       //System.out.println(""query string: "" + request.getQueryString());
       ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
       return uriInfo;
+      */
    }
 
    public static ResteasyHttpHeaders extractHttpHeaders(HttpServletRequest request)",2014-01-26T16:19:49Z,36
"@@ -15,7 +15,8 @@ public class PathSegmentImpl implements PathSegment
 {
    private String path;
    private String original;
-   private MultivaluedMap<String, String> matrixParameters = new MultivaluedMapImpl<String, String>();
+   private MultivaluedMap<String, String> matrixParameters;
+   private boolean hasMatrixParams;
 
    /**
     * @param segment encoded path segment
@@ -28,6 +29,8 @@ public PathSegmentImpl(String segment, boolean decode)
       int semicolon = segment.indexOf(';');
       if (semicolon >= 0)
       {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+         hasMatrixParams = true;
          if (semicolon > 0) this.path = segment.substring(0, semicolon);
          else this.path = """";
          String matrixParams = segment.substring(semicolon + 1);
@@ -52,6 +55,15 @@ public PathSegmentImpl(String segment, boolean decode)
       if (decode) this.path = Encode.decodePath(this.path);
    }
 
+   /**
+    * NOTE: Used for optimization in ResteasyUriInfo
+    * @return
+    */
+   public boolean hasMatrixParams()
+   {
+      return hasMatrixParams;
+   }
+
    public String getOriginal()
    {
       return original;
@@ -64,6 +76,10 @@ public String getPath()
 
    public MultivaluedMap<String, String> getMatrixParameters()
    {
+      if (matrixParameters == null)
+      {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+      }
       return matrixParameters;
    }
 
@@ -84,15 +100,34 @@ public String toString()
       return buf.toString();
    }
 
+   public static List<PathSegment> parseSegments(String path, boolean decode)
+   {
+      return parseSegmentsOptimization(path, decode).segments;
+   }
+
+   /**
+    * Used when creating the matching path in ResteasyUriInfo
+    *
+    */
+   public static class SegmentParse
+   {
+      public List<PathSegment> segments;
+      public boolean hasMatrixParams;
+
+
+   }
+
    /**
     *
     * @param path encoded full path
     * @param decode whether or not to decode each segment
     * @return
     */
-   public static List<PathSegment> parseSegments(String path, boolean decode)
+   public static SegmentParse parseSegmentsOptimization(String path, boolean decode)
    {
+      SegmentParse parse = new SegmentParse();
       List<PathSegment> pathSegments = new ArrayList<PathSegment>();
+      parse.segments = pathSegments;
       int start = 0;
       if (path.startsWith(""/"")) start++;
       int length = path.length();
@@ -110,9 +145,11 @@ public static List<PathSegment> parseSegments(String path, boolean decode)
             p = path.substring(start, slash);
             start = slash + 1;
          }
-         pathSegments.add(new PathSegmentImpl(p, decode));
+         PathSegmentImpl pathSegment = new PathSegmentImpl(p, decode);
+         parse.hasMatrixParams |= pathSegment.hasMatrixParams();
+         pathSegments.add(pathSegment);
       } while (start < length);
-      return pathSegments;
+      return parse;
    }
 
 }",2014-01-26T16:19:49Z,3
"@@ -1,157 +1,157 @@
-package org.jboss.resteasy.specimpl;
-
-import org.jboss.resteasy.util.CaseInsensitiveMap;
-import org.jboss.resteasy.util.DateUtil;
-import org.jboss.resteasy.util.LocaleHelper;
-import org.jboss.resteasy.util.MediaTypeHelper;
-import org.jboss.resteasy.util.WeightedLanguage;
-
-import javax.ws.rs.core.Cookie;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.MultivaluedMap;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-/**
- * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
- * @version $Revision: 1 $
- */
-public class ResteasyHttpHeaders implements HttpHeaders
-{
-
-   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
-   private Map<String, Cookie> cookies = Collections.emptyMap();
-
-   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
-   {
-      this.requestHeaders = requestHeaders;
-   }
-
-   @Override
-   public MultivaluedMap<String, String> getRequestHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public MultivaluedMap<String, String> getMutableHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public void testParsing()
-   {
-      // test parsing should throw an exception on error
-      getAcceptableMediaTypes();
-      getMediaType();
-      getLanguage();
-      getAcceptableLanguages();
-
-   }
-
-   @Override
-   public List<String> getRequestHeader(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return Collections.EMPTY_LIST;
-      return Collections.unmodifiableList(vals);
-   }
-
-   @Override
-   public Map<String, Cookie> getCookies()
-   {
-      return cookies;
-   }
-
-   public void setCookies(Map<String, Cookie> cookies)
-   {
-      this.cookies = Collections.unmodifiableMap(cookies);
-   }
-
-   @Override
-   public Date getDate()
-   {
-      String date = requestHeaders.getFirst(DATE);
-      if (date == null) return null;
-      return DateUtil.parseDate(date);
-   }
-
-   @Override
-   public String getHeaderString(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return null;
-      StringBuilder builder = new StringBuilder();
-      boolean first = true;
-      for (String val : vals)
-      {
-         if (first) first = false;
-         else builder.append("","");
-         builder.append(val);
-      }
-      return builder.toString();
-   }
-
-   @Override
-   public Locale getLanguage()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
-      if (obj == null) return null;
-      return new Locale(obj);
-   }
-
-   @Override
-   public int getLength()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
-      if (obj == null) return -1;
-      return Integer.parseInt(obj);
-   }
-
-   @Override
-   public MediaType getMediaType()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
-      if (obj == null) return null;
-      return MediaType.valueOf(obj);
-   }
-
-   @Override
-   public List<MediaType> getAcceptableMediaTypes()
-   {
-      String accepts = getHeaderString(ACCEPT);
-      if (accepts == null) return Collections.emptyList();
-      List<MediaType> list = new ArrayList<MediaType>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         list.add(MediaType.valueOf(item));
-      }
-      MediaTypeHelper.sortByWeight(list);
-      return Collections.unmodifiableList(list);
-   }
-
-   @Override
-   public List<Locale> getAcceptableLanguages()
-   {
-      String accepts = getHeaderString(ACCEPT_LANGUAGE);
-      if (accepts == null) return Collections.emptyList();
-      List<Locale> list = new ArrayList<Locale>();
-      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         languages.add(WeightedLanguage.parse(item));
-      }
-      Collections.sort(languages);
-      for (WeightedLanguage language : languages) list.add(language.getLocale());
-      return Collections.unmodifiableList(list);
-   }
-}
+package org.jboss.resteasy.specimpl;
+
+import org.jboss.resteasy.util.CaseInsensitiveMap;
+import org.jboss.resteasy.util.DateUtil;
+import org.jboss.resteasy.util.LocaleHelper;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.WeightedLanguage;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ResteasyHttpHeaders implements HttpHeaders
+{
+
+   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
+   private Map<String, Cookie> cookies = Collections.emptyMap();
+
+   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
+   {
+      this.requestHeaders = requestHeaders;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getRequestHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public void testParsing()
+   {
+      // test parsing should throw an exception on error
+      getAcceptableMediaTypes();
+      getMediaType();
+      getLanguage();
+      getAcceptableLanguages();
+
+   }
+
+   @Override
+   public List<String> getRequestHeader(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return Collections.EMPTY_LIST;
+      return Collections.unmodifiableList(vals);
+   }
+
+   @Override
+   public Map<String, Cookie> getCookies()
+   {
+      return cookies;
+   }
+
+   public void setCookies(Map<String, Cookie> cookies)
+   {
+      this.cookies = Collections.unmodifiableMap(cookies);
+   }
+
+   @Override
+   public Date getDate()
+   {
+      String date = requestHeaders.getFirst(DATE);
+      if (date == null) return null;
+      return DateUtil.parseDate(date);
+   }
+
+   @Override
+   public String getHeaderString(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return null;
+      StringBuilder builder = new StringBuilder();
+      boolean first = true;
+      for (String val : vals)
+      {
+         if (first) first = false;
+         else builder.append("","");
+         builder.append(val);
+      }
+      return builder.toString();
+   }
+
+   @Override
+   public Locale getLanguage()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
+      if (obj == null) return null;
+      return new Locale(obj);
+   }
+
+   @Override
+   public int getLength()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
+      if (obj == null) return -1;
+      return Integer.parseInt(obj);
+   }
+
+   @Override
+   public MediaType getMediaType()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
+      if (obj == null) return null;
+      return MediaType.valueOf(obj);
+   }
+
+   @Override
+   public List<MediaType> getAcceptableMediaTypes()
+   {
+      String accepts = getHeaderString(ACCEPT);
+      if (accepts == null) return Collections.emptyList();
+      List<MediaType> list = new ArrayList<MediaType>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         list.add(MediaType.valueOf(item));
+      }
+      MediaTypeHelper.sortByWeight(list);
+      return Collections.unmodifiableList(list);
+   }
+
+   @Override
+   public List<Locale> getAcceptableLanguages()
+   {
+      String accepts = getHeaderString(ACCEPT_LANGUAGE);
+      if (accepts == null) return Collections.emptyList();
+      List<Locale> list = new ArrayList<Locale>();
+      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         languages.add(WeightedLanguage.parse(item));
+      }
+      Collections.sort(languages);
+      for (WeightedLanguage language : languages) list.add(language.getLocale());
+      return Collections.unmodifiableList(list);
+   }
+}",2014-01-26T16:19:49Z,68
"@@ -4,13 +4,17 @@
 import org.jboss.resteasy.specimpl.PathSegmentImpl;
 import org.jboss.resteasy.specimpl.ResteasyUriBuilder;
 import org.jboss.resteasy.util.Encode;
+import org.jboss.resteasy.util.PathHelper;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
 import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
 import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
 import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -45,6 +49,31 @@ public class ResteasyUriInfo implements UriInfo
    private List<Object> ancestors;
 
 
+   public ResteasyUriInfo(String absoluteUri, String queryString, String contextPath)
+   {
+      ResteasyUriBuilder absoluteBuilder = (ResteasyUriBuilder)UriBuilder.fromUri(absoluteUri).replaceQuery(queryString);
+      requestURI = absoluteBuilder.build();
+      absolutePath = URI.create(absoluteUri);
+      encodedPath = PathHelper.getEncodedPathInfo(absolutePath.getRawPath(), contextPath);
+      baseURI = absolutePath;
+      if (!encodedPath.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = absoluteBuilder.clone().replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      // make sure there is no trailing '/'
+      if (encodedPath.length() > 1 && encodedPath.endsWith(""/"")) encodedPath = encodedPath.substring(0, encodedPath.length() - 1);
+
+      // make sure path starts with '/'
+      if (encodedPath.length() == 0 || encodedPath.charAt(0) != '/')
+      {
+         encodedPath = ""/"" + encodedPath;
+      }
+      path = UriBuilder.fromPath(encodedPath).build().getPath();
+      processPath();
+   }
+
    public ResteasyUriInfo(URI base, URI relative)
    {
       String b = base.toString();
@@ -60,18 +89,26 @@ public ResteasyUriInfo(URI base, URI relative)
          encodedPath = ""/"" + r;
          path = ""/"" + relative.getPath();
       }
-      requestURI = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery()).build();
+      UriBuilder requestUriBuilder = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery());
+      requestURI = requestUriBuilder.build();
+      absolutePath = requestUriBuilder.replaceQuery(null).build();
       baseURI = base;
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
+      processPath();
+   }
+
+   protected void processPath()
+   {
+      PathSegmentImpl.SegmentParse parse = PathSegmentImpl.parseSegmentsOptimization(encodedPath, false);
+      encodedPathSegments = parse.segments;
       this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       for (PathSegment segment : encodedPathSegments)
       {
          pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
       }
       extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
+      if (parse.hasMatrixParams) extractMatchingPath(encodedPathSegments);
+      else matchingPath = encodedPath;
 
-      absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
    }
 
    public ResteasyUriInfo(URI requestURI)
@@ -89,16 +126,8 @@ public ResteasyUriInfo(URI requestURI)
       }
       this.requestURI = requestURI;
       baseURI = UriBuilder.fromUri(requestURI).replacePath("""").build();
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
-      this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
-      for (PathSegment segment : encodedPathSegments)
-      {
-         pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
-      }
-      extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
-
       absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
+      processPath();
 
    }
 ",2014-01-26T16:19:49Z,29
"@@ -30,6 +30,7 @@ private static class CaseInsensitiveComparator
       public int compare(String s1, String s2) {
          if (s1 == s2) return 0;
          int n1 = 0;
+         // null check is different than JDK version of this method
          if (s1 != null) n1 = s1.length();
          int n2 = 0;
          if (s2 != null) n2 = s2.length();",2014-01-26T16:19:49Z,178
"@@ -25,6 +25,7 @@
         <dep.guice.version>3.0</dep.guice.version>
         <dep.jboss-el.version>1.0_02.CR4</dep.jboss-el.version>
         <dep.netty.version>3.6.4.Final</dep.netty.version>
+        <dep.netty4.version>4.0.6.Final</dep.netty4.version>
     </properties>
 
     <url>http://rest-easy.org</url>",2013-08-13T21:09:44Z,117
"@@ -16,5 +16,6 @@
     <modules>
         <module>resteasy-jdk-http</module>
         <module>resteasy-netty</module>
+        <module>resteasy-netty4</module>
     </modules>
 </project>",2013-08-13T21:09:44Z,172
"@@ -0,0 +1,45 @@
+<?xml version=""1.0""?>
+<project>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>resteasy-netty4</artifactId>
+    <name>RESTEasy Netty 4 Integration</name>
+    <description/>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>${dep.netty4.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2013-08-13T21:09:44Z,135
"@@ -0,0 +1,221 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.SynchronousExecutionContext;
+import org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.NotImplementedYetException;
+import org.jboss.resteasy.spi.ResteasyAsynchronousContext;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.Encode;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * Abstraction for an inbound http request on the server, or a response from a server to a client
+ * <p/>
+ * We have this abstraction so that we can reuse marshalling objects in a client framework and serverside framework
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
+{
+   protected ResteasyHttpHeaders httpHeaders;
+   protected SynchronousDispatcher dispatcher;
+   protected ResteasyUriInfo uriInfo;
+   protected String httpMethod;
+   protected MultivaluedMap<String, String> formParameters;
+   protected MultivaluedMap<String, String> decodedFormParameters;
+   protected InputStream inputStream;
+   protected Map<String, Object> attributes = new HashMap<String, Object>();
+   protected NettyHttpResponse httpResponse;
+   private final boolean is100ContinueExpected;
+
+
+   public NettyHttpRequest(ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse httpResponse, boolean is100ContinueExpected)
+   {
+      this.is100ContinueExpected = is100ContinueExpected;
+      this.httpResponse = httpResponse;
+      this.dispatcher = dispatcher;
+      this.httpHeaders = httpHeaders;
+      this.httpMethod = httpMethod;
+      this.uriInfo = uri;
+
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return httpHeaders.getMutableHeaders();
+   }
+
+   @Override
+   public void setHttpMethod(String method)
+   {
+      this.httpMethod = method;
+   }
+
+   @Override
+   public Enumeration<String> getAttributeNames()
+   {
+      Enumeration<String> en = new Enumeration<String>()
+      {
+         private Iterator<String> it = attributes.keySet().iterator();
+         @Override
+         public boolean hasMoreElements()
+         {
+            return it.hasNext();
+         }
+
+         @Override
+         public String nextElement()
+         {
+            return it.next();
+         }
+      };
+      return en;
+   }
+
+   @Override
+   public ResteasyAsynchronousContext getAsyncContext()
+   {
+      return new SynchronousExecutionContext(dispatcher, this, httpResponse);
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getFormParameters()
+   {
+      if (formParameters != null) return formParameters;
+      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      {
+         try
+         {
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+      else
+      {
+         throw new IllegalArgumentException(""Request media type is not application/x-www-form-urlencoded"");
+      }
+      return formParameters;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getDecodedFormParameters()
+   {
+      if (decodedFormParameters != null) return decodedFormParameters;
+      decodedFormParameters = Encode.decode(getFormParameters());
+      return decodedFormParameters;
+   }
+
+
+   @Override
+   public Object getAttribute(String attribute)
+   {
+      return attributes.get(attribute);
+   }
+
+   @Override
+   public void setAttribute(String name, Object value)
+   {
+      attributes.put(name, value);
+   }
+
+   @Override
+   public void removeAttribute(String name)
+   {
+      attributes.remove(name);
+   }
+
+   @Override
+   public HttpHeaders getHttpHeaders()
+   {
+      return httpHeaders;
+   }
+
+   @Override
+   public InputStream getInputStream()
+   {
+      return inputStream;
+   }
+
+   @Override
+   public void setInputStream(InputStream stream)
+   {
+      this.inputStream = stream;
+   }
+
+   @Override
+   public ResteasyUriInfo getUri()
+   {
+      return uriInfo;
+   }
+
+   @Override
+   public String getHttpMethod()
+   {
+      return httpMethod;
+   }
+
+   @Override
+   public void setRequestUri(URI requestUri) throws IllegalStateException
+   {
+      uriInfo = uriInfo.setRequestUri(requestUri);
+   }
+
+   @Override
+   public void setRequestUri(URI baseUri, URI requestUri) throws IllegalStateException
+   {
+      uriInfo = new ResteasyUriInfo(baseUri.resolve(requestUri));
+   }
+
+
+   @Override
+   public boolean isInitial()
+   {
+      return true;
+   }
+
+   public NettyHttpResponse getResponse()
+   {
+       return httpResponse;
+   }
+
+   public boolean isKeepAlive()
+   {
+       return httpResponse.isKeepAlive();
+   }
+
+   public boolean is100ContinueExpected()
+   {
+       return is100ContinueExpected;
+   }
+
+   @Override
+   public void forward(String path)
+   {
+      throw new NotImplementedYetException();
+   }
+
+   @Override
+   public boolean wasForwarded()
+   {
+      return false;
+   }
+
+}",2013-08-13T21:09:44Z,136
"@@ -0,0 +1,142 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.spi.HttpResponse;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.NewCookie;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyHttpResponse implements HttpResponse
+{
+   private int status = 200;
+   private ByteBuf byteBuf;
+   private OutputStream os;
+   private MultivaluedMap<String, Object> outputHeaders;
+   private final ChannelHandlerContext ctx;
+   private boolean committed;
+   private boolean keepAlive;
+
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   {
+      outputHeaders = new MultivaluedMapImpl<String, Object>();
+      byteBuf = Unpooled.buffer();
+      os = new ByteBufOutputStream(byteBuf);
+      this.ctx = ctx;
+      this.keepAlive = keepAlive;
+   }
+
+   @Override
+   public void setOutputStream(OutputStream os)
+   {
+      this.os = os;
+   }
+
+   public ByteBuf getBuffer()
+   {
+      return byteBuf;
+   }
+
+   @Override
+   public int getStatus()
+   {
+      return status;
+   }
+
+   @Override
+   public void setStatus(int status)
+   {
+      this.status = status;
+   }
+
+   @Override
+   public MultivaluedMap<String, Object> getOutputHeaders()
+   {
+      return outputHeaders;
+   }
+
+   @Override
+   public OutputStream getOutputStream() throws IOException
+   {
+      return os;
+   }
+
+   @Override
+   public void addNewCookie(NewCookie cookie)
+   {
+      outputHeaders.add(HttpHeaders.SET_COOKIE, cookie);
+   }
+
+   @Override
+   public void sendError(int status) throws IOException
+   {
+      sendError(status, null);
+   }
+
+   @Override
+   public void sendError(int status, String message) throws IOException
+   {
+       if (committed)
+       {
+           throw new IllegalStateException();
+       }
+
+       final HttpResponseStatus responseStatus;
+       if (message != null)
+       {
+           responseStatus = new HttpResponseStatus(status, message);
+           setStatus(status);
+       }
+       else
+       {
+           responseStatus = HttpResponseStatus.valueOf(status);
+           setStatus(status);
+       }
+       final io.netty.handler.codec.http.HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, responseStatus);
+       if (keepAlive)
+       {
+           // Add keep alive and content length if needed
+           response.headers().add(Names.CONNECTION, Values.KEEP_ALIVE);
+           response.headers().add(Names.CONTENT_LENGTH, 0);
+       }
+       ctx.writeAndFlush(response);
+       committed = true;
+   }
+
+   @Override
+   public boolean isCommitted()
+   {
+      return committed;
+   }
+
+   @Override
+   public void reset()
+   {
+      if (committed)
+      {
+          throw new IllegalStateException(""Already committed"");
+      }
+      outputHeaders.clear();
+      byteBuf.clear();
+      outputHeaders.clear();
+   }
+
+   public boolean isKeepAlive() {
+       return keepAlive;
+   }
+}",2013-08-13T21:09:44Z,137
"@@ -0,0 +1,188 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import resteasy.plugins.server.netty.RequestDispatcher;
+import resteasy.plugins.server.netty.RequestHandler;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder.Protocol;
+import resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup bossGroup;
+   private EventLoopGroup workerGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      bossGroup = new NioEventLoopGroup();
+      workerGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+       try {
+           bootstrap.bind(port).sync();
+       } catch (InterruptedException e) {
+           // ignore
+       }
+   }
+
+   @Override
+   public void stop()
+   {
+       workerGroup.shutdownGracefully();
+       bossGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,14
"@@ -0,0 +1,54 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+
+import javax.ws.rs.core.SecurityContext;
+import java.security.Principal;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettySecurityContext implements SecurityContext
+{
+   protected final Principal principal;
+   protected final SecurityDomain domain;
+   protected final String authScheme;
+   protected final boolean isSecure;
+
+   public NettySecurityContext(Principal principal, SecurityDomain domain, String authScheme, boolean secure)
+   {
+      this.principal = principal;
+      this.domain = domain;
+      this.authScheme = authScheme;
+      isSecure = secure;
+   }
+   public NettySecurityContext() {
+       this(null, null, null, false);
+   }
+
+   @Override
+   public Principal getUserPrincipal()
+   {
+      return principal;
+   }
+
+   @Override
+   public boolean isUserInRole(String role)
+   {
+      if (domain == null) return false;
+      return domain.isUserInRoll(principal, role);
+   }
+
+   @Override
+   public boolean isSecure()
+   {
+      return isSecure;
+   }
+
+   @Override
+   public String getAuthenticationScheme()
+   {
+      return authScheme;
+   }
+}",2013-08-13T21:09:44Z,173
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.PathHelper;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyUtil
+{
+   public static ResteasyUriInfo extractUriInfo(HttpRequest request, String contextPath, String protocol)
+   {
+      String host = HttpHeaders.getHost(request, ""unknown"");
+      String uri = request.getUri();
+
+      URI absoluteURI = URI.create(protocol + ""://"" + host + uri);
+
+      String path = PathHelper.getEncodedPathInfo(absoluteURI.getRawPath(), contextPath);
+      if (!path.startsWith(""/""))
+      {
+         path = ""/"" + path;
+      }
+
+      URI baseURI = absoluteURI;
+      if (!path.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = UriBuilder.fromUri(absoluteURI).replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      else
+      {
+         baseURI = UriBuilder.fromUri(absoluteURI).replaceQuery(null).build();
+      }
+      URI relativeURI = UriBuilder.fromUri(path).replaceQuery(absoluteURI.getRawQuery()).build();
+      //System.out.println(""path: "" + path);
+      //System.out.println(""query string: "" + request.getQueryString());
+      ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
+      return uriInfo;
+   }
+
+   public static ResteasyHttpHeaders extractHttpHeaders(HttpRequest request)
+   {
+
+      MultivaluedMap<String, String> requestHeaders = extractRequestHeaders(request);
+      ResteasyHttpHeaders headers = new ResteasyHttpHeaders(requestHeaders);
+
+      Map<String, Cookie> cookies = extractCookies(requestHeaders);
+      headers.setCookies(cookies);
+      // test parsing should throw an exception on error
+      headers.testParsing();
+      return headers;
+
+   }
+
+   static Map<String, Cookie> extractCookies(MultivaluedMap<String, String> headers)
+   {
+      Map<String, Cookie> cookies = new HashMap<String, Cookie>();
+      List<String> cookieHeaders = headers.get(""Cookie"");
+      if (cookieHeaders == null) return cookies;
+
+      for (String cookieVal : cookieHeaders)
+      {
+         Cookie cookie = Cookie.valueOf(cookieVal);
+         cookies.put(cookie.getName(), cookie);
+      }
+      return cookies;
+   }
+
+   public static List<MediaType> extractAccepts(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT);
+      if (accepts == null) return acceptableMediaTypes;
+
+      for (String accept : accepts)
+      {
+         acceptableMediaTypes.addAll(MediaTypeHelper.parseHeader(accept));
+      }
+      return acceptableMediaTypes;
+   }
+
+   public static List<String> extractLanguages(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<String> acceptable = new ArrayList<String>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE);
+      if (accepts == null) return acceptable;
+
+      for (String accept : accepts)
+      {
+         String[] splits = accept.split("","");
+         for (String split : splits) acceptable.add(split.trim());
+      }
+      return acceptable;
+   }
+
+   public static MultivaluedMap<String, String> extractRequestHeaders(HttpRequest request)
+   {
+      Headers<String> requestHeaders = new Headers<String>();
+
+      for (Map.Entry<String, String> header : request.headers())
+      {
+         requestHeaders.add(header.getKey(), header.getValue());
+      }
+      return requestHeaders;
+   }
+}",2013-08-13T21:09:44Z,174
"@@ -0,0 +1,141 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.apache.commons.codec.binary.Base64;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.SecurityContext;
+import java.io.IOException;
+import java.security.Principal;
+import java.util.List;
+
+/**
+ * Helper/delegate class to unify Servlet and Filter dispatcher implementations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class RequestDispatcher
+{
+   protected final SynchronousDispatcher dispatcher;
+   protected final ResteasyProviderFactory providerFactory;
+   protected final SecurityDomain domain;
+
+   public RequestDispatcher(SynchronousDispatcher dispatcher, ResteasyProviderFactory providerFactory, SecurityDomain domain)
+   {
+      this.dispatcher = dispatcher;
+      this.providerFactory = providerFactory;
+      this.domain = domain;
+   }
+
+   public SynchronousDispatcher getDispatcher()
+   {
+      return dispatcher;
+   }
+
+   public SecurityDomain getDomain()
+   {
+      return domain;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void service(HttpRequest request, HttpResponse response, boolean handleNotFound) throws IOException
+   {
+
+      try
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.push(providerFactory);
+         }
+
+         SecurityContext securityContext;
+         if (domain != null)
+         {
+            securityContext = basicAuthentication(request, response);
+            if (securityContext == null) // not authenticated
+            {
+               return;
+            }
+         } else {
+            securityContext = new NettySecurityContext();
+         }
+         try
+         {
+
+            ResteasyProviderFactory.pushContext(SecurityContext.class, securityContext);
+            if (handleNotFound)
+            {
+               dispatcher.invoke(request, response);
+            }
+            else
+            {
+               dispatcher.invokePropagateNotFound(request, response);
+            }
+         }
+         finally
+         {
+            ResteasyProviderFactory.clearContextData();
+         }
+      }
+      finally
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.pop();
+         }
+
+      }
+   }
+
+   private SecurityContext basicAuthentication(HttpRequest request, HttpResponse response) throws IOException
+   {
+      List<String> headers = request.getHttpHeaders().getRequestHeader(HttpHeaderNames.AUTHORIZATION);
+      if (!headers.isEmpty()) {
+         String auth = headers.get(0);
+         if (auth.length() > 5)
+         {
+            String type = auth.substring(0, 5);
+            type = type.toLowerCase();
+            if (""basic"".equals(type))
+            {
+               String cookie = auth.substring(6);
+               cookie = new String(Base64.decodeBase64(cookie.getBytes()));
+               String[] split = cookie.split("":"");
+               Principal user = null;
+               try
+               {
+                  user = domain.authenticate(split[0], split[1]);
+                  return new NettySecurityContext(user, domain, ""BASIC"", true);
+               }
+               catch (SecurityException e)
+               {
+                  response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+                  return null;
+               }
+            }
+            else
+            {
+               response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+               return null;
+            }
+         }
+      }
+      return null;
+   }
+
+
+}
\ No newline at end of file",2013-08-13T21:09:44Z,175
"@@ -0,0 +1,104 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.Failure;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which handles the requests and dispatch them.
+ *
+ * This class is {@link Sharable}.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
+ */
+@Sharable
+public class RequestHandler extends ChannelInboundHandlerAdapter
+{
+   protected final RequestDispatcher dispatcher;
+   private final static Logger logger = Logger.getLogger(RequestHandler.class);
+
+   public RequestHandler(RequestDispatcher dispatcher)
+   {
+      this.dispatcher = dispatcher;
+   }
+
+   @Override
+   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
+   {
+      if (msg instanceof NettyHttpRequest) {
+          NettyHttpRequest request = (NettyHttpRequest) msg;
+
+          if (request.is100ContinueExpected())
+          {
+             send100Continue(ctx);
+          }
+
+          NettyHttpResponse response = request.getResponse();
+          try
+          {
+             dispatcher.service(request, response, true);
+          }
+          catch (Failure e1)
+          {
+             response.reset();
+             response.setStatus(e1.getErrorCode());
+             return;
+          }
+          catch (Exception ex)
+          {
+             response.reset();
+             response.setStatus(500);
+             logger.error(""Unexpected"", ex);
+             return;
+          }
+
+          // Write the response.
+          ChannelFuture future = ctx.writeAndFlush(response);
+
+          // Close the non-keep-alive connection after the write operation is done.
+          if (!request.isKeepAlive())
+          {
+             future.addListener(ChannelFutureListener.CLOSE);
+          }
+      }
+   }
+
+   private void send100Continue(ChannelHandlerContext ctx)
+   {
+      HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+      ctx.writeAndFlush(response);
+   }
+
+   @Override
+   public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
+           throws Exception
+   {
+      // handle the case of to big requests.
+      if (e.getCause() instanceof TooLongFrameException)
+      {
+          DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, REQUEST_ENTITY_TOO_LARGE);
+          ctx.write(response).addListener(ChannelFutureListener.CLOSE);
+      }
+      else
+      {
+          e.getCause().printStackTrace();
+          ctx.close();
+      }
+
+   }
+}",2013-08-13T21:09:44Z,138
"@@ -0,0 +1,86 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected;
+
+/**
+ * This {@link MessageToMessageDecoder} is responsible for decode {@link io.netty.handler.codec.http.HttpRequest}
+ * to {@link NettyHttpRequest}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.HttpRequest>
+{
+    private final static Logger logger = Logger.getLogger(RestEasyHttpRequestDecoder.class);
+
+    private final SynchronousDispatcher dispatcher;
+    private final String servletMappingPrefix;
+    private final String proto;
+
+    public enum Protocol
+    {
+        HTTPS,
+        HTTP
+    }
+
+    public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servletMappingPrefix, Protocol protocol)
+    {
+        this.dispatcher = dispatcher;
+        this.servletMappingPrefix = servletMappingPrefix;
+        if (protocol == Protocol.HTTP)
+        {
+            proto = ""http"";
+        }
+        else
+        {
+            proto = ""https"";
+        }
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
+    {
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
+        NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        ResteasyHttpHeaders headers = null;
+        ResteasyUriInfo uriInfo = null;
+        try
+        {
+           headers = NettyUtil.extractHttpHeaders(request);
+
+           uriInfo = NettyUtil.extractUriInfo(request, servletMappingPrefix, proto);
+           NettyHttpRequest nettyRequest = new NettyHttpRequest(headers, uriInfo, request.getMethod().name(), dispatcher, response, is100ContinueExpected(request) );
+           if (request instanceof HttpContent)
+           {
+               HttpContent content = (HttpContent) request;
+               ByteBuf buf = content.content().copy();
+               ByteBufInputStream in = new ByteBufInputStream(buf);
+               nettyRequest.setInputStream(in);
+               out.add(nettyRequest);
+           }
+        }
+        catch (Exception e)
+        {
+           response.sendError(400);
+           // made it warn so that people can filter this.
+           logger.warn(""Failed to parse request."", e);
+        }
+    }
+}",2013-08-13T21:09:44Z,139
"@@ -0,0 +1,76 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.util.List;
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+
+/**
+ * {@link MessageToMessageEncoder} implementation which encodes {@link org.jboss.resteasy.spi.HttpResponse}'s to
+ * {@link HttpResponse}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpResponseEncoder extends MessageToMessageEncoder<NettyHttpResponse>
+{
+
+    private final RequestDispatcher dispatcher;
+
+    public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
+    {
+        this.dispatcher = dispatcher;
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
+    {
+        // Build the response object.
+        HttpResponseStatus status = HttpResponseStatus.valueOf(nettyResponse.getStatus());
+        ByteBuf buffer = nettyResponse.getBuffer();
+        HttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, buffer);
+
+        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+        {
+           String key = entry.getKey();
+           for (Object value : entry.getValue())
+           {
+              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
+              if (delegate != null)
+              {
+                  response.headers().add(key, delegate.toString(value));
+              }
+              else
+              {
+                 response.headers().set(key, value.toString());
+              }
+           }
+        }
+
+        if (nettyResponse.isKeepAlive())
+        {
+            // Add content length and connection header if needed
+            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+        }
+        out.add(response);
+    }
+
+}",2013-08-13T21:09:44Z,140
"@@ -0,0 +1,72 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyContainer
+{
+   public static NettyJaxrsServer netty;
+
+   public static ResteasyDeployment start() throws Exception
+   {
+      return start("""");
+   }
+
+   public static ResteasyDeployment start(String bindPath) throws Exception
+   {
+      return start(bindPath, null);
+   }
+
+   public static void start(ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath("""");
+      netty.setSecurityDomain(null);
+      netty.start();
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setSecurityEnabled(true);
+      return start(bindPath, domain, deployment);
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain, ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath(bindPath);
+      netty.setSecurityDomain(domain);
+      netty.start();
+      return netty.getDeployment();
+   }
+
+   public static void stop() throws Exception
+   {
+      if (netty != null)
+      {
+         try
+         {
+            netty.stop();
+         }
+         catch (Exception e)
+         {
+
+         }
+      }
+      netty = null;
+   }
+
+   public static void main(String args[]) throws Exception {
+       start();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,176
"@@ -15,6 +15,7 @@
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import java.io.ByteArrayInputStream;
+import java.net.URI;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -38,6 +39,17 @@ public String create(String cust)
 
    }
 
+   @Test
+   public void testUri() throws Exception
+   {
+      URI uri = URI.create(""/foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+      System.out.println(""---"");
+      uri = URI.create(""foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+   }
 
    @Test
    public void testCleartext() throws Exception",2014-01-26T16:19:49Z,177
"@@ -38,6 +38,8 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
             contextPath += ""/"";
          contextPath += servletPrefix;
       }
+      return new ResteasyUriInfo(request.getRequestURL().toString(), request.getQueryString(), contextPath);
+      /*
       URI absolutePath = null;
       try
       {
@@ -70,6 +72,7 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
       //System.out.println(""query string: "" + request.getQueryString());
       ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
       return uriInfo;
+      */
    }
 
    public static ResteasyHttpHeaders extractHttpHeaders(HttpServletRequest request)",2014-01-26T16:19:49Z,36
"@@ -15,7 +15,8 @@ public class PathSegmentImpl implements PathSegment
 {
    private String path;
    private String original;
-   private MultivaluedMap<String, String> matrixParameters = new MultivaluedMapImpl<String, String>();
+   private MultivaluedMap<String, String> matrixParameters;
+   private boolean hasMatrixParams;
 
    /**
     * @param segment encoded path segment
@@ -28,6 +29,8 @@ public PathSegmentImpl(String segment, boolean decode)
       int semicolon = segment.indexOf(';');
       if (semicolon >= 0)
       {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+         hasMatrixParams = true;
          if (semicolon > 0) this.path = segment.substring(0, semicolon);
          else this.path = """";
          String matrixParams = segment.substring(semicolon + 1);
@@ -52,6 +55,15 @@ public PathSegmentImpl(String segment, boolean decode)
       if (decode) this.path = Encode.decodePath(this.path);
    }
 
+   /**
+    * NOTE: Used for optimization in ResteasyUriInfo
+    * @return
+    */
+   public boolean hasMatrixParams()
+   {
+      return hasMatrixParams;
+   }
+
    public String getOriginal()
    {
       return original;
@@ -64,6 +76,10 @@ public String getPath()
 
    public MultivaluedMap<String, String> getMatrixParameters()
    {
+      if (matrixParameters == null)
+      {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+      }
       return matrixParameters;
    }
 
@@ -84,15 +100,34 @@ public String toString()
       return buf.toString();
    }
 
+   public static List<PathSegment> parseSegments(String path, boolean decode)
+   {
+      return parseSegmentsOptimization(path, decode).segments;
+   }
+
+   /**
+    * Used when creating the matching path in ResteasyUriInfo
+    *
+    */
+   public static class SegmentParse
+   {
+      public List<PathSegment> segments;
+      public boolean hasMatrixParams;
+
+
+   }
+
    /**
     *
     * @param path encoded full path
     * @param decode whether or not to decode each segment
     * @return
     */
-   public static List<PathSegment> parseSegments(String path, boolean decode)
+   public static SegmentParse parseSegmentsOptimization(String path, boolean decode)
    {
+      SegmentParse parse = new SegmentParse();
       List<PathSegment> pathSegments = new ArrayList<PathSegment>();
+      parse.segments = pathSegments;
       int start = 0;
       if (path.startsWith(""/"")) start++;
       int length = path.length();
@@ -110,9 +145,11 @@ public static List<PathSegment> parseSegments(String path, boolean decode)
             p = path.substring(start, slash);
             start = slash + 1;
          }
-         pathSegments.add(new PathSegmentImpl(p, decode));
+         PathSegmentImpl pathSegment = new PathSegmentImpl(p, decode);
+         parse.hasMatrixParams |= pathSegment.hasMatrixParams();
+         pathSegments.add(pathSegment);
       } while (start < length);
-      return pathSegments;
+      return parse;
    }
 
 }",2014-01-26T16:19:49Z,3
"@@ -1,157 +1,157 @@
-package org.jboss.resteasy.specimpl;
-
-import org.jboss.resteasy.util.CaseInsensitiveMap;
-import org.jboss.resteasy.util.DateUtil;
-import org.jboss.resteasy.util.LocaleHelper;
-import org.jboss.resteasy.util.MediaTypeHelper;
-import org.jboss.resteasy.util.WeightedLanguage;
-
-import javax.ws.rs.core.Cookie;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.MultivaluedMap;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-/**
- * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
- * @version $Revision: 1 $
- */
-public class ResteasyHttpHeaders implements HttpHeaders
-{
-
-   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
-   private Map<String, Cookie> cookies = Collections.emptyMap();
-
-   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
-   {
-      this.requestHeaders = requestHeaders;
-   }
-
-   @Override
-   public MultivaluedMap<String, String> getRequestHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public MultivaluedMap<String, String> getMutableHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public void testParsing()
-   {
-      // test parsing should throw an exception on error
-      getAcceptableMediaTypes();
-      getMediaType();
-      getLanguage();
-      getAcceptableLanguages();
-
-   }
-
-   @Override
-   public List<String> getRequestHeader(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return Collections.EMPTY_LIST;
-      return Collections.unmodifiableList(vals);
-   }
-
-   @Override
-   public Map<String, Cookie> getCookies()
-   {
-      return cookies;
-   }
-
-   public void setCookies(Map<String, Cookie> cookies)
-   {
-      this.cookies = Collections.unmodifiableMap(cookies);
-   }
-
-   @Override
-   public Date getDate()
-   {
-      String date = requestHeaders.getFirst(DATE);
-      if (date == null) return null;
-      return DateUtil.parseDate(date);
-   }
-
-   @Override
-   public String getHeaderString(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return null;
-      StringBuilder builder = new StringBuilder();
-      boolean first = true;
-      for (String val : vals)
-      {
-         if (first) first = false;
-         else builder.append("","");
-         builder.append(val);
-      }
-      return builder.toString();
-   }
-
-   @Override
-   public Locale getLanguage()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
-      if (obj == null) return null;
-      return new Locale(obj);
-   }
-
-   @Override
-   public int getLength()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
-      if (obj == null) return -1;
-      return Integer.parseInt(obj);
-   }
-
-   @Override
-   public MediaType getMediaType()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
-      if (obj == null) return null;
-      return MediaType.valueOf(obj);
-   }
-
-   @Override
-   public List<MediaType> getAcceptableMediaTypes()
-   {
-      String accepts = getHeaderString(ACCEPT);
-      if (accepts == null) return Collections.emptyList();
-      List<MediaType> list = new ArrayList<MediaType>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         list.add(MediaType.valueOf(item));
-      }
-      MediaTypeHelper.sortByWeight(list);
-      return Collections.unmodifiableList(list);
-   }
-
-   @Override
-   public List<Locale> getAcceptableLanguages()
-   {
-      String accepts = getHeaderString(ACCEPT_LANGUAGE);
-      if (accepts == null) return Collections.emptyList();
-      List<Locale> list = new ArrayList<Locale>();
-      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         languages.add(WeightedLanguage.parse(item));
-      }
-      Collections.sort(languages);
-      for (WeightedLanguage language : languages) list.add(language.getLocale());
-      return Collections.unmodifiableList(list);
-   }
-}
+package org.jboss.resteasy.specimpl;
+
+import org.jboss.resteasy.util.CaseInsensitiveMap;
+import org.jboss.resteasy.util.DateUtil;
+import org.jboss.resteasy.util.LocaleHelper;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.WeightedLanguage;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ResteasyHttpHeaders implements HttpHeaders
+{
+
+   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
+   private Map<String, Cookie> cookies = Collections.emptyMap();
+
+   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
+   {
+      this.requestHeaders = requestHeaders;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getRequestHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public void testParsing()
+   {
+      // test parsing should throw an exception on error
+      getAcceptableMediaTypes();
+      getMediaType();
+      getLanguage();
+      getAcceptableLanguages();
+
+   }
+
+   @Override
+   public List<String> getRequestHeader(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return Collections.EMPTY_LIST;
+      return Collections.unmodifiableList(vals);
+   }
+
+   @Override
+   public Map<String, Cookie> getCookies()
+   {
+      return cookies;
+   }
+
+   public void setCookies(Map<String, Cookie> cookies)
+   {
+      this.cookies = Collections.unmodifiableMap(cookies);
+   }
+
+   @Override
+   public Date getDate()
+   {
+      String date = requestHeaders.getFirst(DATE);
+      if (date == null) return null;
+      return DateUtil.parseDate(date);
+   }
+
+   @Override
+   public String getHeaderString(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return null;
+      StringBuilder builder = new StringBuilder();
+      boolean first = true;
+      for (String val : vals)
+      {
+         if (first) first = false;
+         else builder.append("","");
+         builder.append(val);
+      }
+      return builder.toString();
+   }
+
+   @Override
+   public Locale getLanguage()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
+      if (obj == null) return null;
+      return new Locale(obj);
+   }
+
+   @Override
+   public int getLength()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
+      if (obj == null) return -1;
+      return Integer.parseInt(obj);
+   }
+
+   @Override
+   public MediaType getMediaType()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
+      if (obj == null) return null;
+      return MediaType.valueOf(obj);
+   }
+
+   @Override
+   public List<MediaType> getAcceptableMediaTypes()
+   {
+      String accepts = getHeaderString(ACCEPT);
+      if (accepts == null) return Collections.emptyList();
+      List<MediaType> list = new ArrayList<MediaType>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         list.add(MediaType.valueOf(item));
+      }
+      MediaTypeHelper.sortByWeight(list);
+      return Collections.unmodifiableList(list);
+   }
+
+   @Override
+   public List<Locale> getAcceptableLanguages()
+   {
+      String accepts = getHeaderString(ACCEPT_LANGUAGE);
+      if (accepts == null) return Collections.emptyList();
+      List<Locale> list = new ArrayList<Locale>();
+      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         languages.add(WeightedLanguage.parse(item));
+      }
+      Collections.sort(languages);
+      for (WeightedLanguage language : languages) list.add(language.getLocale());
+      return Collections.unmodifiableList(list);
+   }
+}",2014-01-26T16:19:49Z,68
"@@ -4,13 +4,17 @@
 import org.jboss.resteasy.specimpl.PathSegmentImpl;
 import org.jboss.resteasy.specimpl.ResteasyUriBuilder;
 import org.jboss.resteasy.util.Encode;
+import org.jboss.resteasy.util.PathHelper;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
 import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
 import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
 import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -45,6 +49,31 @@ public class ResteasyUriInfo implements UriInfo
    private List<Object> ancestors;
 
 
+   public ResteasyUriInfo(String absoluteUri, String queryString, String contextPath)
+   {
+      ResteasyUriBuilder absoluteBuilder = (ResteasyUriBuilder)UriBuilder.fromUri(absoluteUri).replaceQuery(queryString);
+      requestURI = absoluteBuilder.build();
+      absolutePath = URI.create(absoluteUri);
+      encodedPath = PathHelper.getEncodedPathInfo(absolutePath.getRawPath(), contextPath);
+      baseURI = absolutePath;
+      if (!encodedPath.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = absoluteBuilder.clone().replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      // make sure there is no trailing '/'
+      if (encodedPath.length() > 1 && encodedPath.endsWith(""/"")) encodedPath = encodedPath.substring(0, encodedPath.length() - 1);
+
+      // make sure path starts with '/'
+      if (encodedPath.length() == 0 || encodedPath.charAt(0) != '/')
+      {
+         encodedPath = ""/"" + encodedPath;
+      }
+      path = UriBuilder.fromPath(encodedPath).build().getPath();
+      processPath();
+   }
+
    public ResteasyUriInfo(URI base, URI relative)
    {
       String b = base.toString();
@@ -60,18 +89,26 @@ public ResteasyUriInfo(URI base, URI relative)
          encodedPath = ""/"" + r;
          path = ""/"" + relative.getPath();
       }
-      requestURI = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery()).build();
+      UriBuilder requestUriBuilder = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery());
+      requestURI = requestUriBuilder.build();
+      absolutePath = requestUriBuilder.replaceQuery(null).build();
       baseURI = base;
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
+      processPath();
+   }
+
+   protected void processPath()
+   {
+      PathSegmentImpl.SegmentParse parse = PathSegmentImpl.parseSegmentsOptimization(encodedPath, false);
+      encodedPathSegments = parse.segments;
       this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       for (PathSegment segment : encodedPathSegments)
       {
          pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
       }
       extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
+      if (parse.hasMatrixParams) extractMatchingPath(encodedPathSegments);
+      else matchingPath = encodedPath;
 
-      absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
    }
 
    public ResteasyUriInfo(URI requestURI)
@@ -89,16 +126,8 @@ public ResteasyUriInfo(URI requestURI)
       }
       this.requestURI = requestURI;
       baseURI = UriBuilder.fromUri(requestURI).replacePath("""").build();
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
-      this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
-      for (PathSegment segment : encodedPathSegments)
-      {
-         pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
-      }
-      extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
-
       absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
+      processPath();
 
    }
 ",2014-01-26T16:19:49Z,29
"@@ -30,6 +30,7 @@ private static class CaseInsensitiveComparator
       public int compare(String s1, String s2) {
          if (s1 == s2) return 0;
          int n1 = 0;
+         // null check is different than JDK version of this method
          if (s1 != null) n1 = s1.length();
          int n2 = 0;
          if (s2 != null) n2 = s2.length();",2014-01-26T16:19:49Z,178
"@@ -25,6 +25,7 @@
         <dep.guice.version>3.0</dep.guice.version>
         <dep.jboss-el.version>1.0_02.CR4</dep.jboss-el.version>
         <dep.netty.version>3.6.4.Final</dep.netty.version>
+        <dep.netty4.version>4.0.6.Final</dep.netty4.version>
     </properties>
 
     <url>http://rest-easy.org</url>",2013-08-13T21:09:44Z,117
"@@ -16,5 +16,6 @@
     <modules>
         <module>resteasy-jdk-http</module>
         <module>resteasy-netty</module>
+        <module>resteasy-netty4</module>
     </modules>
 </project>",2013-08-13T21:09:44Z,172
"@@ -0,0 +1,45 @@
+<?xml version=""1.0""?>
+<project>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>resteasy-netty4</artifactId>
+    <name>RESTEasy Netty 4 Integration</name>
+    <description/>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>${dep.netty4.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2013-08-13T21:09:44Z,135
"@@ -0,0 +1,221 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.SynchronousExecutionContext;
+import org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.NotImplementedYetException;
+import org.jboss.resteasy.spi.ResteasyAsynchronousContext;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.Encode;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * Abstraction for an inbound http request on the server, or a response from a server to a client
+ * <p/>
+ * We have this abstraction so that we can reuse marshalling objects in a client framework and serverside framework
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
+{
+   protected ResteasyHttpHeaders httpHeaders;
+   protected SynchronousDispatcher dispatcher;
+   protected ResteasyUriInfo uriInfo;
+   protected String httpMethod;
+   protected MultivaluedMap<String, String> formParameters;
+   protected MultivaluedMap<String, String> decodedFormParameters;
+   protected InputStream inputStream;
+   protected Map<String, Object> attributes = new HashMap<String, Object>();
+   protected NettyHttpResponse httpResponse;
+   private final boolean is100ContinueExpected;
+
+
+   public NettyHttpRequest(ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse httpResponse, boolean is100ContinueExpected)
+   {
+      this.is100ContinueExpected = is100ContinueExpected;
+      this.httpResponse = httpResponse;
+      this.dispatcher = dispatcher;
+      this.httpHeaders = httpHeaders;
+      this.httpMethod = httpMethod;
+      this.uriInfo = uri;
+
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return httpHeaders.getMutableHeaders();
+   }
+
+   @Override
+   public void setHttpMethod(String method)
+   {
+      this.httpMethod = method;
+   }
+
+   @Override
+   public Enumeration<String> getAttributeNames()
+   {
+      Enumeration<String> en = new Enumeration<String>()
+      {
+         private Iterator<String> it = attributes.keySet().iterator();
+         @Override
+         public boolean hasMoreElements()
+         {
+            return it.hasNext();
+         }
+
+         @Override
+         public String nextElement()
+         {
+            return it.next();
+         }
+      };
+      return en;
+   }
+
+   @Override
+   public ResteasyAsynchronousContext getAsyncContext()
+   {
+      return new SynchronousExecutionContext(dispatcher, this, httpResponse);
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getFormParameters()
+   {
+      if (formParameters != null) return formParameters;
+      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      {
+         try
+         {
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+      else
+      {
+         throw new IllegalArgumentException(""Request media type is not application/x-www-form-urlencoded"");
+      }
+      return formParameters;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getDecodedFormParameters()
+   {
+      if (decodedFormParameters != null) return decodedFormParameters;
+      decodedFormParameters = Encode.decode(getFormParameters());
+      return decodedFormParameters;
+   }
+
+
+   @Override
+   public Object getAttribute(String attribute)
+   {
+      return attributes.get(attribute);
+   }
+
+   @Override
+   public void setAttribute(String name, Object value)
+   {
+      attributes.put(name, value);
+   }
+
+   @Override
+   public void removeAttribute(String name)
+   {
+      attributes.remove(name);
+   }
+
+   @Override
+   public HttpHeaders getHttpHeaders()
+   {
+      return httpHeaders;
+   }
+
+   @Override
+   public InputStream getInputStream()
+   {
+      return inputStream;
+   }
+
+   @Override
+   public void setInputStream(InputStream stream)
+   {
+      this.inputStream = stream;
+   }
+
+   @Override
+   public ResteasyUriInfo getUri()
+   {
+      return uriInfo;
+   }
+
+   @Override
+   public String getHttpMethod()
+   {
+      return httpMethod;
+   }
+
+   @Override
+   public void setRequestUri(URI requestUri) throws IllegalStateException
+   {
+      uriInfo = uriInfo.setRequestUri(requestUri);
+   }
+
+   @Override
+   public void setRequestUri(URI baseUri, URI requestUri) throws IllegalStateException
+   {
+      uriInfo = new ResteasyUriInfo(baseUri.resolve(requestUri));
+   }
+
+
+   @Override
+   public boolean isInitial()
+   {
+      return true;
+   }
+
+   public NettyHttpResponse getResponse()
+   {
+       return httpResponse;
+   }
+
+   public boolean isKeepAlive()
+   {
+       return httpResponse.isKeepAlive();
+   }
+
+   public boolean is100ContinueExpected()
+   {
+       return is100ContinueExpected;
+   }
+
+   @Override
+   public void forward(String path)
+   {
+      throw new NotImplementedYetException();
+   }
+
+   @Override
+   public boolean wasForwarded()
+   {
+      return false;
+   }
+
+}",2013-08-13T21:09:44Z,136
"@@ -0,0 +1,142 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.spi.HttpResponse;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.NewCookie;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyHttpResponse implements HttpResponse
+{
+   private int status = 200;
+   private ByteBuf byteBuf;
+   private OutputStream os;
+   private MultivaluedMap<String, Object> outputHeaders;
+   private final ChannelHandlerContext ctx;
+   private boolean committed;
+   private boolean keepAlive;
+
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   {
+      outputHeaders = new MultivaluedMapImpl<String, Object>();
+      byteBuf = Unpooled.buffer();
+      os = new ByteBufOutputStream(byteBuf);
+      this.ctx = ctx;
+      this.keepAlive = keepAlive;
+   }
+
+   @Override
+   public void setOutputStream(OutputStream os)
+   {
+      this.os = os;
+   }
+
+   public ByteBuf getBuffer()
+   {
+      return byteBuf;
+   }
+
+   @Override
+   public int getStatus()
+   {
+      return status;
+   }
+
+   @Override
+   public void setStatus(int status)
+   {
+      this.status = status;
+   }
+
+   @Override
+   public MultivaluedMap<String, Object> getOutputHeaders()
+   {
+      return outputHeaders;
+   }
+
+   @Override
+   public OutputStream getOutputStream() throws IOException
+   {
+      return os;
+   }
+
+   @Override
+   public void addNewCookie(NewCookie cookie)
+   {
+      outputHeaders.add(HttpHeaders.SET_COOKIE, cookie);
+   }
+
+   @Override
+   public void sendError(int status) throws IOException
+   {
+      sendError(status, null);
+   }
+
+   @Override
+   public void sendError(int status, String message) throws IOException
+   {
+       if (committed)
+       {
+           throw new IllegalStateException();
+       }
+
+       final HttpResponseStatus responseStatus;
+       if (message != null)
+       {
+           responseStatus = new HttpResponseStatus(status, message);
+           setStatus(status);
+       }
+       else
+       {
+           responseStatus = HttpResponseStatus.valueOf(status);
+           setStatus(status);
+       }
+       final io.netty.handler.codec.http.HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, responseStatus);
+       if (keepAlive)
+       {
+           // Add keep alive and content length if needed
+           response.headers().add(Names.CONNECTION, Values.KEEP_ALIVE);
+           response.headers().add(Names.CONTENT_LENGTH, 0);
+       }
+       ctx.writeAndFlush(response);
+       committed = true;
+   }
+
+   @Override
+   public boolean isCommitted()
+   {
+      return committed;
+   }
+
+   @Override
+   public void reset()
+   {
+      if (committed)
+      {
+          throw new IllegalStateException(""Already committed"");
+      }
+      outputHeaders.clear();
+      byteBuf.clear();
+      outputHeaders.clear();
+   }
+
+   public boolean isKeepAlive() {
+       return keepAlive;
+   }
+}",2013-08-13T21:09:44Z,137
"@@ -0,0 +1,188 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import resteasy.plugins.server.netty.RequestDispatcher;
+import resteasy.plugins.server.netty.RequestHandler;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder.Protocol;
+import resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup bossGroup;
+   private EventLoopGroup workerGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      bossGroup = new NioEventLoopGroup();
+      workerGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+       try {
+           bootstrap.bind(port).sync();
+       } catch (InterruptedException e) {
+           // ignore
+       }
+   }
+
+   @Override
+   public void stop()
+   {
+       workerGroup.shutdownGracefully();
+       bossGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,14
"@@ -0,0 +1,54 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+
+import javax.ws.rs.core.SecurityContext;
+import java.security.Principal;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettySecurityContext implements SecurityContext
+{
+   protected final Principal principal;
+   protected final SecurityDomain domain;
+   protected final String authScheme;
+   protected final boolean isSecure;
+
+   public NettySecurityContext(Principal principal, SecurityDomain domain, String authScheme, boolean secure)
+   {
+      this.principal = principal;
+      this.domain = domain;
+      this.authScheme = authScheme;
+      isSecure = secure;
+   }
+   public NettySecurityContext() {
+       this(null, null, null, false);
+   }
+
+   @Override
+   public Principal getUserPrincipal()
+   {
+      return principal;
+   }
+
+   @Override
+   public boolean isUserInRole(String role)
+   {
+      if (domain == null) return false;
+      return domain.isUserInRoll(principal, role);
+   }
+
+   @Override
+   public boolean isSecure()
+   {
+      return isSecure;
+   }
+
+   @Override
+   public String getAuthenticationScheme()
+   {
+      return authScheme;
+   }
+}",2013-08-13T21:09:44Z,173
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.PathHelper;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyUtil
+{
+   public static ResteasyUriInfo extractUriInfo(HttpRequest request, String contextPath, String protocol)
+   {
+      String host = HttpHeaders.getHost(request, ""unknown"");
+      String uri = request.getUri();
+
+      URI absoluteURI = URI.create(protocol + ""://"" + host + uri);
+
+      String path = PathHelper.getEncodedPathInfo(absoluteURI.getRawPath(), contextPath);
+      if (!path.startsWith(""/""))
+      {
+         path = ""/"" + path;
+      }
+
+      URI baseURI = absoluteURI;
+      if (!path.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = UriBuilder.fromUri(absoluteURI).replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      else
+      {
+         baseURI = UriBuilder.fromUri(absoluteURI).replaceQuery(null).build();
+      }
+      URI relativeURI = UriBuilder.fromUri(path).replaceQuery(absoluteURI.getRawQuery()).build();
+      //System.out.println(""path: "" + path);
+      //System.out.println(""query string: "" + request.getQueryString());
+      ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
+      return uriInfo;
+   }
+
+   public static ResteasyHttpHeaders extractHttpHeaders(HttpRequest request)
+   {
+
+      MultivaluedMap<String, String> requestHeaders = extractRequestHeaders(request);
+      ResteasyHttpHeaders headers = new ResteasyHttpHeaders(requestHeaders);
+
+      Map<String, Cookie> cookies = extractCookies(requestHeaders);
+      headers.setCookies(cookies);
+      // test parsing should throw an exception on error
+      headers.testParsing();
+      return headers;
+
+   }
+
+   static Map<String, Cookie> extractCookies(MultivaluedMap<String, String> headers)
+   {
+      Map<String, Cookie> cookies = new HashMap<String, Cookie>();
+      List<String> cookieHeaders = headers.get(""Cookie"");
+      if (cookieHeaders == null) return cookies;
+
+      for (String cookieVal : cookieHeaders)
+      {
+         Cookie cookie = Cookie.valueOf(cookieVal);
+         cookies.put(cookie.getName(), cookie);
+      }
+      return cookies;
+   }
+
+   public static List<MediaType> extractAccepts(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT);
+      if (accepts == null) return acceptableMediaTypes;
+
+      for (String accept : accepts)
+      {
+         acceptableMediaTypes.addAll(MediaTypeHelper.parseHeader(accept));
+      }
+      return acceptableMediaTypes;
+   }
+
+   public static List<String> extractLanguages(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<String> acceptable = new ArrayList<String>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE);
+      if (accepts == null) return acceptable;
+
+      for (String accept : accepts)
+      {
+         String[] splits = accept.split("","");
+         for (String split : splits) acceptable.add(split.trim());
+      }
+      return acceptable;
+   }
+
+   public static MultivaluedMap<String, String> extractRequestHeaders(HttpRequest request)
+   {
+      Headers<String> requestHeaders = new Headers<String>();
+
+      for (Map.Entry<String, String> header : request.headers())
+      {
+         requestHeaders.add(header.getKey(), header.getValue());
+      }
+      return requestHeaders;
+   }
+}",2013-08-13T21:09:44Z,174
"@@ -0,0 +1,141 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.apache.commons.codec.binary.Base64;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.SecurityContext;
+import java.io.IOException;
+import java.security.Principal;
+import java.util.List;
+
+/**
+ * Helper/delegate class to unify Servlet and Filter dispatcher implementations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class RequestDispatcher
+{
+   protected final SynchronousDispatcher dispatcher;
+   protected final ResteasyProviderFactory providerFactory;
+   protected final SecurityDomain domain;
+
+   public RequestDispatcher(SynchronousDispatcher dispatcher, ResteasyProviderFactory providerFactory, SecurityDomain domain)
+   {
+      this.dispatcher = dispatcher;
+      this.providerFactory = providerFactory;
+      this.domain = domain;
+   }
+
+   public SynchronousDispatcher getDispatcher()
+   {
+      return dispatcher;
+   }
+
+   public SecurityDomain getDomain()
+   {
+      return domain;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void service(HttpRequest request, HttpResponse response, boolean handleNotFound) throws IOException
+   {
+
+      try
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.push(providerFactory);
+         }
+
+         SecurityContext securityContext;
+         if (domain != null)
+         {
+            securityContext = basicAuthentication(request, response);
+            if (securityContext == null) // not authenticated
+            {
+               return;
+            }
+         } else {
+            securityContext = new NettySecurityContext();
+         }
+         try
+         {
+
+            ResteasyProviderFactory.pushContext(SecurityContext.class, securityContext);
+            if (handleNotFound)
+            {
+               dispatcher.invoke(request, response);
+            }
+            else
+            {
+               dispatcher.invokePropagateNotFound(request, response);
+            }
+         }
+         finally
+         {
+            ResteasyProviderFactory.clearContextData();
+         }
+      }
+      finally
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.pop();
+         }
+
+      }
+   }
+
+   private SecurityContext basicAuthentication(HttpRequest request, HttpResponse response) throws IOException
+   {
+      List<String> headers = request.getHttpHeaders().getRequestHeader(HttpHeaderNames.AUTHORIZATION);
+      if (!headers.isEmpty()) {
+         String auth = headers.get(0);
+         if (auth.length() > 5)
+         {
+            String type = auth.substring(0, 5);
+            type = type.toLowerCase();
+            if (""basic"".equals(type))
+            {
+               String cookie = auth.substring(6);
+               cookie = new String(Base64.decodeBase64(cookie.getBytes()));
+               String[] split = cookie.split("":"");
+               Principal user = null;
+               try
+               {
+                  user = domain.authenticate(split[0], split[1]);
+                  return new NettySecurityContext(user, domain, ""BASIC"", true);
+               }
+               catch (SecurityException e)
+               {
+                  response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+                  return null;
+               }
+            }
+            else
+            {
+               response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+               return null;
+            }
+         }
+      }
+      return null;
+   }
+
+
+}
\ No newline at end of file",2013-08-13T21:09:44Z,175
"@@ -0,0 +1,104 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.Failure;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which handles the requests and dispatch them.
+ *
+ * This class is {@link Sharable}.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
+ */
+@Sharable
+public class RequestHandler extends ChannelInboundHandlerAdapter
+{
+   protected final RequestDispatcher dispatcher;
+   private final static Logger logger = Logger.getLogger(RequestHandler.class);
+
+   public RequestHandler(RequestDispatcher dispatcher)
+   {
+      this.dispatcher = dispatcher;
+   }
+
+   @Override
+   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
+   {
+      if (msg instanceof NettyHttpRequest) {
+          NettyHttpRequest request = (NettyHttpRequest) msg;
+
+          if (request.is100ContinueExpected())
+          {
+             send100Continue(ctx);
+          }
+
+          NettyHttpResponse response = request.getResponse();
+          try
+          {
+             dispatcher.service(request, response, true);
+          }
+          catch (Failure e1)
+          {
+             response.reset();
+             response.setStatus(e1.getErrorCode());
+             return;
+          }
+          catch (Exception ex)
+          {
+             response.reset();
+             response.setStatus(500);
+             logger.error(""Unexpected"", ex);
+             return;
+          }
+
+          // Write the response.
+          ChannelFuture future = ctx.writeAndFlush(response);
+
+          // Close the non-keep-alive connection after the write operation is done.
+          if (!request.isKeepAlive())
+          {
+             future.addListener(ChannelFutureListener.CLOSE);
+          }
+      }
+   }
+
+   private void send100Continue(ChannelHandlerContext ctx)
+   {
+      HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+      ctx.writeAndFlush(response);
+   }
+
+   @Override
+   public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
+           throws Exception
+   {
+      // handle the case of to big requests.
+      if (e.getCause() instanceof TooLongFrameException)
+      {
+          DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, REQUEST_ENTITY_TOO_LARGE);
+          ctx.write(response).addListener(ChannelFutureListener.CLOSE);
+      }
+      else
+      {
+          e.getCause().printStackTrace();
+          ctx.close();
+      }
+
+   }
+}",2013-08-13T21:09:44Z,138
"@@ -0,0 +1,86 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected;
+
+/**
+ * This {@link MessageToMessageDecoder} is responsible for decode {@link io.netty.handler.codec.http.HttpRequest}
+ * to {@link NettyHttpRequest}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.HttpRequest>
+{
+    private final static Logger logger = Logger.getLogger(RestEasyHttpRequestDecoder.class);
+
+    private final SynchronousDispatcher dispatcher;
+    private final String servletMappingPrefix;
+    private final String proto;
+
+    public enum Protocol
+    {
+        HTTPS,
+        HTTP
+    }
+
+    public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servletMappingPrefix, Protocol protocol)
+    {
+        this.dispatcher = dispatcher;
+        this.servletMappingPrefix = servletMappingPrefix;
+        if (protocol == Protocol.HTTP)
+        {
+            proto = ""http"";
+        }
+        else
+        {
+            proto = ""https"";
+        }
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
+    {
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
+        NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        ResteasyHttpHeaders headers = null;
+        ResteasyUriInfo uriInfo = null;
+        try
+        {
+           headers = NettyUtil.extractHttpHeaders(request);
+
+           uriInfo = NettyUtil.extractUriInfo(request, servletMappingPrefix, proto);
+           NettyHttpRequest nettyRequest = new NettyHttpRequest(headers, uriInfo, request.getMethod().name(), dispatcher, response, is100ContinueExpected(request) );
+           if (request instanceof HttpContent)
+           {
+               HttpContent content = (HttpContent) request;
+               ByteBuf buf = content.content().copy();
+               ByteBufInputStream in = new ByteBufInputStream(buf);
+               nettyRequest.setInputStream(in);
+               out.add(nettyRequest);
+           }
+        }
+        catch (Exception e)
+        {
+           response.sendError(400);
+           // made it warn so that people can filter this.
+           logger.warn(""Failed to parse request."", e);
+        }
+    }
+}",2013-08-13T21:09:44Z,139
"@@ -0,0 +1,76 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.util.List;
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+
+/**
+ * {@link MessageToMessageEncoder} implementation which encodes {@link org.jboss.resteasy.spi.HttpResponse}'s to
+ * {@link HttpResponse}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpResponseEncoder extends MessageToMessageEncoder<NettyHttpResponse>
+{
+
+    private final RequestDispatcher dispatcher;
+
+    public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
+    {
+        this.dispatcher = dispatcher;
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
+    {
+        // Build the response object.
+        HttpResponseStatus status = HttpResponseStatus.valueOf(nettyResponse.getStatus());
+        ByteBuf buffer = nettyResponse.getBuffer();
+        HttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, buffer);
+
+        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+        {
+           String key = entry.getKey();
+           for (Object value : entry.getValue())
+           {
+              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
+              if (delegate != null)
+              {
+                  response.headers().add(key, delegate.toString(value));
+              }
+              else
+              {
+                 response.headers().set(key, value.toString());
+              }
+           }
+        }
+
+        if (nettyResponse.isKeepAlive())
+        {
+            // Add content length and connection header if needed
+            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+        }
+        out.add(response);
+    }
+
+}",2013-08-13T21:09:44Z,140
"@@ -0,0 +1,72 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyContainer
+{
+   public static NettyJaxrsServer netty;
+
+   public static ResteasyDeployment start() throws Exception
+   {
+      return start("""");
+   }
+
+   public static ResteasyDeployment start(String bindPath) throws Exception
+   {
+      return start(bindPath, null);
+   }
+
+   public static void start(ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath("""");
+      netty.setSecurityDomain(null);
+      netty.start();
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setSecurityEnabled(true);
+      return start(bindPath, domain, deployment);
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain, ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath(bindPath);
+      netty.setSecurityDomain(domain);
+      netty.start();
+      return netty.getDeployment();
+   }
+
+   public static void stop() throws Exception
+   {
+      if (netty != null)
+      {
+         try
+         {
+            netty.stop();
+         }
+         catch (Exception e)
+         {
+
+         }
+      }
+      netty = null;
+   }
+
+   public static void main(String args[]) throws Exception {
+       start();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,176
"@@ -15,6 +15,7 @@
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import java.io.ByteArrayInputStream;
+import java.net.URI;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -38,6 +39,17 @@ public String create(String cust)
 
    }
 
+   @Test
+   public void testUri() throws Exception
+   {
+      URI uri = URI.create(""/foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+      System.out.println(""---"");
+      uri = URI.create(""foo"");
+      System.out.println(uri);
+      System.out.println(uri.getRawPath());
+   }
 
    @Test
    public void testCleartext() throws Exception",2014-01-26T16:19:49Z,177
"@@ -38,6 +38,8 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
             contextPath += ""/"";
          contextPath += servletPrefix;
       }
+      return new ResteasyUriInfo(request.getRequestURL().toString(), request.getQueryString(), contextPath);
+      /*
       URI absolutePath = null;
       try
       {
@@ -70,6 +72,7 @@ public static ResteasyUriInfo extractUriInfo(HttpServletRequest request, String
       //System.out.println(""query string: "" + request.getQueryString());
       ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
       return uriInfo;
+      */
    }
 
    public static ResteasyHttpHeaders extractHttpHeaders(HttpServletRequest request)",2014-01-26T16:19:49Z,36
"@@ -15,7 +15,8 @@ public class PathSegmentImpl implements PathSegment
 {
    private String path;
    private String original;
-   private MultivaluedMap<String, String> matrixParameters = new MultivaluedMapImpl<String, String>();
+   private MultivaluedMap<String, String> matrixParameters;
+   private boolean hasMatrixParams;
 
    /**
     * @param segment encoded path segment
@@ -28,6 +29,8 @@ public PathSegmentImpl(String segment, boolean decode)
       int semicolon = segment.indexOf(';');
       if (semicolon >= 0)
       {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+         hasMatrixParams = true;
          if (semicolon > 0) this.path = segment.substring(0, semicolon);
          else this.path = """";
          String matrixParams = segment.substring(semicolon + 1);
@@ -52,6 +55,15 @@ public PathSegmentImpl(String segment, boolean decode)
       if (decode) this.path = Encode.decodePath(this.path);
    }
 
+   /**
+    * NOTE: Used for optimization in ResteasyUriInfo
+    * @return
+    */
+   public boolean hasMatrixParams()
+   {
+      return hasMatrixParams;
+   }
+
    public String getOriginal()
    {
       return original;
@@ -64,6 +76,10 @@ public String getPath()
 
    public MultivaluedMap<String, String> getMatrixParameters()
    {
+      if (matrixParameters == null)
+      {
+         matrixParameters = new MultivaluedMapImpl<String, String>();
+      }
       return matrixParameters;
    }
 
@@ -84,15 +100,34 @@ public String toString()
       return buf.toString();
    }
 
+   public static List<PathSegment> parseSegments(String path, boolean decode)
+   {
+      return parseSegmentsOptimization(path, decode).segments;
+   }
+
+   /**
+    * Used when creating the matching path in ResteasyUriInfo
+    *
+    */
+   public static class SegmentParse
+   {
+      public List<PathSegment> segments;
+      public boolean hasMatrixParams;
+
+
+   }
+
    /**
     *
     * @param path encoded full path
     * @param decode whether or not to decode each segment
     * @return
     */
-   public static List<PathSegment> parseSegments(String path, boolean decode)
+   public static SegmentParse parseSegmentsOptimization(String path, boolean decode)
    {
+      SegmentParse parse = new SegmentParse();
       List<PathSegment> pathSegments = new ArrayList<PathSegment>();
+      parse.segments = pathSegments;
       int start = 0;
       if (path.startsWith(""/"")) start++;
       int length = path.length();
@@ -110,9 +145,11 @@ public static List<PathSegment> parseSegments(String path, boolean decode)
             p = path.substring(start, slash);
             start = slash + 1;
          }
-         pathSegments.add(new PathSegmentImpl(p, decode));
+         PathSegmentImpl pathSegment = new PathSegmentImpl(p, decode);
+         parse.hasMatrixParams |= pathSegment.hasMatrixParams();
+         pathSegments.add(pathSegment);
       } while (start < length);
-      return pathSegments;
+      return parse;
    }
 
 }",2014-01-26T16:19:49Z,3
"@@ -1,157 +1,157 @@
-package org.jboss.resteasy.specimpl;
-
-import org.jboss.resteasy.util.CaseInsensitiveMap;
-import org.jboss.resteasy.util.DateUtil;
-import org.jboss.resteasy.util.LocaleHelper;
-import org.jboss.resteasy.util.MediaTypeHelper;
-import org.jboss.resteasy.util.WeightedLanguage;
-
-import javax.ws.rs.core.Cookie;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.MultivaluedMap;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-/**
- * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
- * @version $Revision: 1 $
- */
-public class ResteasyHttpHeaders implements HttpHeaders
-{
-
-   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
-   private Map<String, Cookie> cookies = Collections.emptyMap();
-
-   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
-   {
-      this.requestHeaders = requestHeaders;
-   }
-
-   @Override
-   public MultivaluedMap<String, String> getRequestHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public MultivaluedMap<String, String> getMutableHeaders()
-   {
-      return requestHeaders;
-   }
-
-   public void testParsing()
-   {
-      // test parsing should throw an exception on error
-      getAcceptableMediaTypes();
-      getMediaType();
-      getLanguage();
-      getAcceptableLanguages();
-
-   }
-
-   @Override
-   public List<String> getRequestHeader(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return Collections.EMPTY_LIST;
-      return Collections.unmodifiableList(vals);
-   }
-
-   @Override
-   public Map<String, Cookie> getCookies()
-   {
-      return cookies;
-   }
-
-   public void setCookies(Map<String, Cookie> cookies)
-   {
-      this.cookies = Collections.unmodifiableMap(cookies);
-   }
-
-   @Override
-   public Date getDate()
-   {
-      String date = requestHeaders.getFirst(DATE);
-      if (date == null) return null;
-      return DateUtil.parseDate(date);
-   }
-
-   @Override
-   public String getHeaderString(String name)
-   {
-      List<String> vals = requestHeaders.get(name);
-      if (vals == null) return null;
-      StringBuilder builder = new StringBuilder();
-      boolean first = true;
-      for (String val : vals)
-      {
-         if (first) first = false;
-         else builder.append("","");
-         builder.append(val);
-      }
-      return builder.toString();
-   }
-
-   @Override
-   public Locale getLanguage()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
-      if (obj == null) return null;
-      return new Locale(obj);
-   }
-
-   @Override
-   public int getLength()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
-      if (obj == null) return -1;
-      return Integer.parseInt(obj);
-   }
-
-   @Override
-   public MediaType getMediaType()
-   {
-      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
-      if (obj == null) return null;
-      return MediaType.valueOf(obj);
-   }
-
-   @Override
-   public List<MediaType> getAcceptableMediaTypes()
-   {
-      String accepts = getHeaderString(ACCEPT);
-      if (accepts == null) return Collections.emptyList();
-      List<MediaType> list = new ArrayList<MediaType>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         list.add(MediaType.valueOf(item));
-      }
-      MediaTypeHelper.sortByWeight(list);
-      return Collections.unmodifiableList(list);
-   }
-
-   @Override
-   public List<Locale> getAcceptableLanguages()
-   {
-      String accepts = getHeaderString(ACCEPT_LANGUAGE);
-      if (accepts == null) return Collections.emptyList();
-      List<Locale> list = new ArrayList<Locale>();
-      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
-      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
-      while (tokenizer.hasMoreElements())
-      {
-         String item = tokenizer.nextToken().trim();
-         languages.add(WeightedLanguage.parse(item));
-      }
-      Collections.sort(languages);
-      for (WeightedLanguage language : languages) list.add(language.getLocale());
-      return Collections.unmodifiableList(list);
-   }
-}
+package org.jboss.resteasy.specimpl;
+
+import org.jboss.resteasy.util.CaseInsensitiveMap;
+import org.jboss.resteasy.util.DateUtil;
+import org.jboss.resteasy.util.LocaleHelper;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.WeightedLanguage;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ResteasyHttpHeaders implements HttpHeaders
+{
+
+   private MultivaluedMap<String, String> requestHeaders = new CaseInsensitiveMap<String>();
+   private Map<String, Cookie> cookies = Collections.emptyMap();
+
+   public ResteasyHttpHeaders(MultivaluedMap<String, String> requestHeaders)
+   {
+      this.requestHeaders = requestHeaders;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getRequestHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return requestHeaders;
+   }
+
+   public void testParsing()
+   {
+      // test parsing should throw an exception on error
+      getAcceptableMediaTypes();
+      getMediaType();
+      getLanguage();
+      getAcceptableLanguages();
+
+   }
+
+   @Override
+   public List<String> getRequestHeader(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return Collections.EMPTY_LIST;
+      return Collections.unmodifiableList(vals);
+   }
+
+   @Override
+   public Map<String, Cookie> getCookies()
+   {
+      return cookies;
+   }
+
+   public void setCookies(Map<String, Cookie> cookies)
+   {
+      this.cookies = Collections.unmodifiableMap(cookies);
+   }
+
+   @Override
+   public Date getDate()
+   {
+      String date = requestHeaders.getFirst(DATE);
+      if (date == null) return null;
+      return DateUtil.parseDate(date);
+   }
+
+   @Override
+   public String getHeaderString(String name)
+   {
+      List<String> vals = requestHeaders.get(name);
+      if (vals == null) return null;
+      StringBuilder builder = new StringBuilder();
+      boolean first = true;
+      for (String val : vals)
+      {
+         if (first) first = false;
+         else builder.append("","");
+         builder.append(val);
+      }
+      return builder.toString();
+   }
+
+   @Override
+   public Locale getLanguage()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LANGUAGE);
+      if (obj == null) return null;
+      return new Locale(obj);
+   }
+
+   @Override
+   public int getLength()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_LENGTH);
+      if (obj == null) return -1;
+      return Integer.parseInt(obj);
+   }
+
+   @Override
+   public MediaType getMediaType()
+   {
+      String obj = requestHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
+      if (obj == null) return null;
+      return MediaType.valueOf(obj);
+   }
+
+   @Override
+   public List<MediaType> getAcceptableMediaTypes()
+   {
+      String accepts = getHeaderString(ACCEPT);
+      if (accepts == null) return Collections.emptyList();
+      List<MediaType> list = new ArrayList<MediaType>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         list.add(MediaType.valueOf(item));
+      }
+      MediaTypeHelper.sortByWeight(list);
+      return Collections.unmodifiableList(list);
+   }
+
+   @Override
+   public List<Locale> getAcceptableLanguages()
+   {
+      String accepts = getHeaderString(ACCEPT_LANGUAGE);
+      if (accepts == null) return Collections.emptyList();
+      List<Locale> list = new ArrayList<Locale>();
+      List<WeightedLanguage> languages = new ArrayList<WeightedLanguage>();
+      StringTokenizer tokenizer = new StringTokenizer(accepts, "","");
+      while (tokenizer.hasMoreElements())
+      {
+         String item = tokenizer.nextToken().trim();
+         languages.add(WeightedLanguage.parse(item));
+      }
+      Collections.sort(languages);
+      for (WeightedLanguage language : languages) list.add(language.getLocale());
+      return Collections.unmodifiableList(list);
+   }
+}",2014-01-26T16:19:49Z,68
"@@ -4,13 +4,17 @@
 import org.jboss.resteasy.specimpl.PathSegmentImpl;
 import org.jboss.resteasy.specimpl.ResteasyUriBuilder;
 import org.jboss.resteasy.util.Encode;
+import org.jboss.resteasy.util.PathHelper;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
 import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
 import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
 import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -45,6 +49,31 @@ public class ResteasyUriInfo implements UriInfo
    private List<Object> ancestors;
 
 
+   public ResteasyUriInfo(String absoluteUri, String queryString, String contextPath)
+   {
+      ResteasyUriBuilder absoluteBuilder = (ResteasyUriBuilder)UriBuilder.fromUri(absoluteUri).replaceQuery(queryString);
+      requestURI = absoluteBuilder.build();
+      absolutePath = URI.create(absoluteUri);
+      encodedPath = PathHelper.getEncodedPathInfo(absolutePath.getRawPath(), contextPath);
+      baseURI = absolutePath;
+      if (!encodedPath.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = absoluteBuilder.clone().replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      // make sure there is no trailing '/'
+      if (encodedPath.length() > 1 && encodedPath.endsWith(""/"")) encodedPath = encodedPath.substring(0, encodedPath.length() - 1);
+
+      // make sure path starts with '/'
+      if (encodedPath.length() == 0 || encodedPath.charAt(0) != '/')
+      {
+         encodedPath = ""/"" + encodedPath;
+      }
+      path = UriBuilder.fromPath(encodedPath).build().getPath();
+      processPath();
+   }
+
    public ResteasyUriInfo(URI base, URI relative)
    {
       String b = base.toString();
@@ -60,18 +89,26 @@ public ResteasyUriInfo(URI base, URI relative)
          encodedPath = ""/"" + r;
          path = ""/"" + relative.getPath();
       }
-      requestURI = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery()).build();
+      UriBuilder requestUriBuilder = UriBuilder.fromUri(base).path(relative.getRawPath()).replaceQuery(relative.getRawQuery());
+      requestURI = requestUriBuilder.build();
+      absolutePath = requestUriBuilder.replaceQuery(null).build();
       baseURI = base;
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
+      processPath();
+   }
+
+   protected void processPath()
+   {
+      PathSegmentImpl.SegmentParse parse = PathSegmentImpl.parseSegmentsOptimization(encodedPath, false);
+      encodedPathSegments = parse.segments;
       this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
       for (PathSegment segment : encodedPathSegments)
       {
          pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
       }
       extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
+      if (parse.hasMatrixParams) extractMatchingPath(encodedPathSegments);
+      else matchingPath = encodedPath;
 
-      absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
    }
 
    public ResteasyUriInfo(URI requestURI)
@@ -89,16 +126,8 @@ public ResteasyUriInfo(URI requestURI)
       }
       this.requestURI = requestURI;
       baseURI = UriBuilder.fromUri(requestURI).replacePath("""").build();
-      encodedPathSegments = PathSegmentImpl.parseSegments(encodedPath, false);
-      this.pathSegments = new ArrayList<PathSegment>(encodedPathSegments.size());
-      for (PathSegment segment : encodedPathSegments)
-      {
-         pathSegments.add(new PathSegmentImpl(((PathSegmentImpl) segment).getOriginal(), true));
-      }
-      extractParameters(requestURI.getRawQuery());
-      extractMatchingPath(encodedPathSegments);
-
       absolutePath = UriBuilder.fromUri(requestURI).replaceQuery(null).build();
+      processPath();
 
    }
 ",2014-01-26T16:19:49Z,29
"@@ -30,6 +30,7 @@ private static class CaseInsensitiveComparator
       public int compare(String s1, String s2) {
          if (s1 == s2) return 0;
          int n1 = 0;
+         // null check is different than JDK version of this method
          if (s1 != null) n1 = s1.length();
          int n2 = 0;
          if (s2 != null) n2 = s2.length();",2014-01-26T16:19:49Z,178
"@@ -25,6 +25,7 @@
         <dep.guice.version>3.0</dep.guice.version>
         <dep.jboss-el.version>1.0_02.CR4</dep.jboss-el.version>
         <dep.netty.version>3.6.4.Final</dep.netty.version>
+        <dep.netty4.version>4.0.6.Final</dep.netty4.version>
     </properties>
 
     <url>http://rest-easy.org</url>",2013-08-13T21:09:44Z,117
"@@ -16,5 +16,6 @@
     <modules>
         <module>resteasy-jdk-http</module>
         <module>resteasy-netty</module>
+        <module>resteasy-netty4</module>
     </modules>
 </project>",2013-08-13T21:09:44Z,172
"@@ -0,0 +1,45 @@
+<?xml version=""1.0""?>
+<project>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>resteasy-netty4</artifactId>
+    <name>RESTEasy Netty 4 Integration</name>
+    <description/>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>${dep.netty4.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2013-08-13T21:09:44Z,135
"@@ -0,0 +1,221 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.SynchronousExecutionContext;
+import org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.NotImplementedYetException;
+import org.jboss.resteasy.spi.ResteasyAsynchronousContext;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.Encode;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * Abstraction for an inbound http request on the server, or a response from a server to a client
+ * <p/>
+ * We have this abstraction so that we can reuse marshalling objects in a client framework and serverside framework
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
+{
+   protected ResteasyHttpHeaders httpHeaders;
+   protected SynchronousDispatcher dispatcher;
+   protected ResteasyUriInfo uriInfo;
+   protected String httpMethod;
+   protected MultivaluedMap<String, String> formParameters;
+   protected MultivaluedMap<String, String> decodedFormParameters;
+   protected InputStream inputStream;
+   protected Map<String, Object> attributes = new HashMap<String, Object>();
+   protected NettyHttpResponse httpResponse;
+   private final boolean is100ContinueExpected;
+
+
+   public NettyHttpRequest(ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse httpResponse, boolean is100ContinueExpected)
+   {
+      this.is100ContinueExpected = is100ContinueExpected;
+      this.httpResponse = httpResponse;
+      this.dispatcher = dispatcher;
+      this.httpHeaders = httpHeaders;
+      this.httpMethod = httpMethod;
+      this.uriInfo = uri;
+
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return httpHeaders.getMutableHeaders();
+   }
+
+   @Override
+   public void setHttpMethod(String method)
+   {
+      this.httpMethod = method;
+   }
+
+   @Override
+   public Enumeration<String> getAttributeNames()
+   {
+      Enumeration<String> en = new Enumeration<String>()
+      {
+         private Iterator<String> it = attributes.keySet().iterator();
+         @Override
+         public boolean hasMoreElements()
+         {
+            return it.hasNext();
+         }
+
+         @Override
+         public String nextElement()
+         {
+            return it.next();
+         }
+      };
+      return en;
+   }
+
+   @Override
+   public ResteasyAsynchronousContext getAsyncContext()
+   {
+      return new SynchronousExecutionContext(dispatcher, this, httpResponse);
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getFormParameters()
+   {
+      if (formParameters != null) return formParameters;
+      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      {
+         try
+         {
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+      else
+      {
+         throw new IllegalArgumentException(""Request media type is not application/x-www-form-urlencoded"");
+      }
+      return formParameters;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getDecodedFormParameters()
+   {
+      if (decodedFormParameters != null) return decodedFormParameters;
+      decodedFormParameters = Encode.decode(getFormParameters());
+      return decodedFormParameters;
+   }
+
+
+   @Override
+   public Object getAttribute(String attribute)
+   {
+      return attributes.get(attribute);
+   }
+
+   @Override
+   public void setAttribute(String name, Object value)
+   {
+      attributes.put(name, value);
+   }
+
+   @Override
+   public void removeAttribute(String name)
+   {
+      attributes.remove(name);
+   }
+
+   @Override
+   public HttpHeaders getHttpHeaders()
+   {
+      return httpHeaders;
+   }
+
+   @Override
+   public InputStream getInputStream()
+   {
+      return inputStream;
+   }
+
+   @Override
+   public void setInputStream(InputStream stream)
+   {
+      this.inputStream = stream;
+   }
+
+   @Override
+   public ResteasyUriInfo getUri()
+   {
+      return uriInfo;
+   }
+
+   @Override
+   public String getHttpMethod()
+   {
+      return httpMethod;
+   }
+
+   @Override
+   public void setRequestUri(URI requestUri) throws IllegalStateException
+   {
+      uriInfo = uriInfo.setRequestUri(requestUri);
+   }
+
+   @Override
+   public void setRequestUri(URI baseUri, URI requestUri) throws IllegalStateException
+   {
+      uriInfo = new ResteasyUriInfo(baseUri.resolve(requestUri));
+   }
+
+
+   @Override
+   public boolean isInitial()
+   {
+      return true;
+   }
+
+   public NettyHttpResponse getResponse()
+   {
+       return httpResponse;
+   }
+
+   public boolean isKeepAlive()
+   {
+       return httpResponse.isKeepAlive();
+   }
+
+   public boolean is100ContinueExpected()
+   {
+       return is100ContinueExpected;
+   }
+
+   @Override
+   public void forward(String path)
+   {
+      throw new NotImplementedYetException();
+   }
+
+   @Override
+   public boolean wasForwarded()
+   {
+      return false;
+   }
+
+}",2013-08-13T21:09:44Z,136
"@@ -0,0 +1,142 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.spi.HttpResponse;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.NewCookie;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyHttpResponse implements HttpResponse
+{
+   private int status = 200;
+   private ByteBuf byteBuf;
+   private OutputStream os;
+   private MultivaluedMap<String, Object> outputHeaders;
+   private final ChannelHandlerContext ctx;
+   private boolean committed;
+   private boolean keepAlive;
+
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   {
+      outputHeaders = new MultivaluedMapImpl<String, Object>();
+      byteBuf = Unpooled.buffer();
+      os = new ByteBufOutputStream(byteBuf);
+      this.ctx = ctx;
+      this.keepAlive = keepAlive;
+   }
+
+   @Override
+   public void setOutputStream(OutputStream os)
+   {
+      this.os = os;
+   }
+
+   public ByteBuf getBuffer()
+   {
+      return byteBuf;
+   }
+
+   @Override
+   public int getStatus()
+   {
+      return status;
+   }
+
+   @Override
+   public void setStatus(int status)
+   {
+      this.status = status;
+   }
+
+   @Override
+   public MultivaluedMap<String, Object> getOutputHeaders()
+   {
+      return outputHeaders;
+   }
+
+   @Override
+   public OutputStream getOutputStream() throws IOException
+   {
+      return os;
+   }
+
+   @Override
+   public void addNewCookie(NewCookie cookie)
+   {
+      outputHeaders.add(HttpHeaders.SET_COOKIE, cookie);
+   }
+
+   @Override
+   public void sendError(int status) throws IOException
+   {
+      sendError(status, null);
+   }
+
+   @Override
+   public void sendError(int status, String message) throws IOException
+   {
+       if (committed)
+       {
+           throw new IllegalStateException();
+       }
+
+       final HttpResponseStatus responseStatus;
+       if (message != null)
+       {
+           responseStatus = new HttpResponseStatus(status, message);
+           setStatus(status);
+       }
+       else
+       {
+           responseStatus = HttpResponseStatus.valueOf(status);
+           setStatus(status);
+       }
+       final io.netty.handler.codec.http.HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, responseStatus);
+       if (keepAlive)
+       {
+           // Add keep alive and content length if needed
+           response.headers().add(Names.CONNECTION, Values.KEEP_ALIVE);
+           response.headers().add(Names.CONTENT_LENGTH, 0);
+       }
+       ctx.writeAndFlush(response);
+       committed = true;
+   }
+
+   @Override
+   public boolean isCommitted()
+   {
+      return committed;
+   }
+
+   @Override
+   public void reset()
+   {
+      if (committed)
+      {
+          throw new IllegalStateException(""Already committed"");
+      }
+      outputHeaders.clear();
+      byteBuf.clear();
+      outputHeaders.clear();
+   }
+
+   public boolean isKeepAlive() {
+       return keepAlive;
+   }
+}",2013-08-13T21:09:44Z,137
"@@ -0,0 +1,188 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import resteasy.plugins.server.netty.RequestDispatcher;
+import resteasy.plugins.server.netty.RequestHandler;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder.Protocol;
+import resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup bossGroup;
+   private EventLoopGroup workerGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      bossGroup = new NioEventLoopGroup();
+      workerGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+       try {
+           bootstrap.bind(port).sync();
+       } catch (InterruptedException e) {
+           // ignore
+       }
+   }
+
+   @Override
+   public void stop()
+   {
+       workerGroup.shutdownGracefully();
+       bossGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,14
"@@ -0,0 +1,54 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+
+import javax.ws.rs.core.SecurityContext;
+import java.security.Principal;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettySecurityContext implements SecurityContext
+{
+   protected final Principal principal;
+   protected final SecurityDomain domain;
+   protected final String authScheme;
+   protected final boolean isSecure;
+
+   public NettySecurityContext(Principal principal, SecurityDomain domain, String authScheme, boolean secure)
+   {
+      this.principal = principal;
+      this.domain = domain;
+      this.authScheme = authScheme;
+      isSecure = secure;
+   }
+   public NettySecurityContext() {
+       this(null, null, null, false);
+   }
+
+   @Override
+   public Principal getUserPrincipal()
+   {
+      return principal;
+   }
+
+   @Override
+   public boolean isUserInRole(String role)
+   {
+      if (domain == null) return false;
+      return domain.isUserInRoll(principal, role);
+   }
+
+   @Override
+   public boolean isSecure()
+   {
+      return isSecure;
+   }
+
+   @Override
+   public String getAuthenticationScheme()
+   {
+      return authScheme;
+   }
+}",2013-08-13T21:09:44Z,173
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.PathHelper;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyUtil
+{
+   public static ResteasyUriInfo extractUriInfo(HttpRequest request, String contextPath, String protocol)
+   {
+      String host = HttpHeaders.getHost(request, ""unknown"");
+      String uri = request.getUri();
+
+      URI absoluteURI = URI.create(protocol + ""://"" + host + uri);
+
+      String path = PathHelper.getEncodedPathInfo(absoluteURI.getRawPath(), contextPath);
+      if (!path.startsWith(""/""))
+      {
+         path = ""/"" + path;
+      }
+
+      URI baseURI = absoluteURI;
+      if (!path.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = UriBuilder.fromUri(absoluteURI).replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      else
+      {
+         baseURI = UriBuilder.fromUri(absoluteURI).replaceQuery(null).build();
+      }
+      URI relativeURI = UriBuilder.fromUri(path).replaceQuery(absoluteURI.getRawQuery()).build();
+      //System.out.println(""path: "" + path);
+      //System.out.println(""query string: "" + request.getQueryString());
+      ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
+      return uriInfo;
+   }
+
+   public static ResteasyHttpHeaders extractHttpHeaders(HttpRequest request)
+   {
+
+      MultivaluedMap<String, String> requestHeaders = extractRequestHeaders(request);
+      ResteasyHttpHeaders headers = new ResteasyHttpHeaders(requestHeaders);
+
+      Map<String, Cookie> cookies = extractCookies(requestHeaders);
+      headers.setCookies(cookies);
+      // test parsing should throw an exception on error
+      headers.testParsing();
+      return headers;
+
+   }
+
+   static Map<String, Cookie> extractCookies(MultivaluedMap<String, String> headers)
+   {
+      Map<String, Cookie> cookies = new HashMap<String, Cookie>();
+      List<String> cookieHeaders = headers.get(""Cookie"");
+      if (cookieHeaders == null) return cookies;
+
+      for (String cookieVal : cookieHeaders)
+      {
+         Cookie cookie = Cookie.valueOf(cookieVal);
+         cookies.put(cookie.getName(), cookie);
+      }
+      return cookies;
+   }
+
+   public static List<MediaType> extractAccepts(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT);
+      if (accepts == null) return acceptableMediaTypes;
+
+      for (String accept : accepts)
+      {
+         acceptableMediaTypes.addAll(MediaTypeHelper.parseHeader(accept));
+      }
+      return acceptableMediaTypes;
+   }
+
+   public static List<String> extractLanguages(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<String> acceptable = new ArrayList<String>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE);
+      if (accepts == null) return acceptable;
+
+      for (String accept : accepts)
+      {
+         String[] splits = accept.split("","");
+         for (String split : splits) acceptable.add(split.trim());
+      }
+      return acceptable;
+   }
+
+   public static MultivaluedMap<String, String> extractRequestHeaders(HttpRequest request)
+   {
+      Headers<String> requestHeaders = new Headers<String>();
+
+      for (Map.Entry<String, String> header : request.headers())
+      {
+         requestHeaders.add(header.getKey(), header.getValue());
+      }
+      return requestHeaders;
+   }
+}",2013-08-13T21:09:44Z,174
"@@ -0,0 +1,141 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.apache.commons.codec.binary.Base64;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.SecurityContext;
+import java.io.IOException;
+import java.security.Principal;
+import java.util.List;
+
+/**
+ * Helper/delegate class to unify Servlet and Filter dispatcher implementations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class RequestDispatcher
+{
+   protected final SynchronousDispatcher dispatcher;
+   protected final ResteasyProviderFactory providerFactory;
+   protected final SecurityDomain domain;
+
+   public RequestDispatcher(SynchronousDispatcher dispatcher, ResteasyProviderFactory providerFactory, SecurityDomain domain)
+   {
+      this.dispatcher = dispatcher;
+      this.providerFactory = providerFactory;
+      this.domain = domain;
+   }
+
+   public SynchronousDispatcher getDispatcher()
+   {
+      return dispatcher;
+   }
+
+   public SecurityDomain getDomain()
+   {
+      return domain;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void service(HttpRequest request, HttpResponse response, boolean handleNotFound) throws IOException
+   {
+
+      try
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.push(providerFactory);
+         }
+
+         SecurityContext securityContext;
+         if (domain != null)
+         {
+            securityContext = basicAuthentication(request, response);
+            if (securityContext == null) // not authenticated
+            {
+               return;
+            }
+         } else {
+            securityContext = new NettySecurityContext();
+         }
+         try
+         {
+
+            ResteasyProviderFactory.pushContext(SecurityContext.class, securityContext);
+            if (handleNotFound)
+            {
+               dispatcher.invoke(request, response);
+            }
+            else
+            {
+               dispatcher.invokePropagateNotFound(request, response);
+            }
+         }
+         finally
+         {
+            ResteasyProviderFactory.clearContextData();
+         }
+      }
+      finally
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.pop();
+         }
+
+      }
+   }
+
+   private SecurityContext basicAuthentication(HttpRequest request, HttpResponse response) throws IOException
+   {
+      List<String> headers = request.getHttpHeaders().getRequestHeader(HttpHeaderNames.AUTHORIZATION);
+      if (!headers.isEmpty()) {
+         String auth = headers.get(0);
+         if (auth.length() > 5)
+         {
+            String type = auth.substring(0, 5);
+            type = type.toLowerCase();
+            if (""basic"".equals(type))
+            {
+               String cookie = auth.substring(6);
+               cookie = new String(Base64.decodeBase64(cookie.getBytes()));
+               String[] split = cookie.split("":"");
+               Principal user = null;
+               try
+               {
+                  user = domain.authenticate(split[0], split[1]);
+                  return new NettySecurityContext(user, domain, ""BASIC"", true);
+               }
+               catch (SecurityException e)
+               {
+                  response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+                  return null;
+               }
+            }
+            else
+            {
+               response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+               return null;
+            }
+         }
+      }
+      return null;
+   }
+
+
+}
\ No newline at end of file",2013-08-13T21:09:44Z,175
"@@ -0,0 +1,104 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.Failure;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which handles the requests and dispatch them.
+ *
+ * This class is {@link Sharable}.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
+ */
+@Sharable
+public class RequestHandler extends ChannelInboundHandlerAdapter
+{
+   protected final RequestDispatcher dispatcher;
+   private final static Logger logger = Logger.getLogger(RequestHandler.class);
+
+   public RequestHandler(RequestDispatcher dispatcher)
+   {
+      this.dispatcher = dispatcher;
+   }
+
+   @Override
+   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
+   {
+      if (msg instanceof NettyHttpRequest) {
+          NettyHttpRequest request = (NettyHttpRequest) msg;
+
+          if (request.is100ContinueExpected())
+          {
+             send100Continue(ctx);
+          }
+
+          NettyHttpResponse response = request.getResponse();
+          try
+          {
+             dispatcher.service(request, response, true);
+          }
+          catch (Failure e1)
+          {
+             response.reset();
+             response.setStatus(e1.getErrorCode());
+             return;
+          }
+          catch (Exception ex)
+          {
+             response.reset();
+             response.setStatus(500);
+             logger.error(""Unexpected"", ex);
+             return;
+          }
+
+          // Write the response.
+          ChannelFuture future = ctx.writeAndFlush(response);
+
+          // Close the non-keep-alive connection after the write operation is done.
+          if (!request.isKeepAlive())
+          {
+             future.addListener(ChannelFutureListener.CLOSE);
+          }
+      }
+   }
+
+   private void send100Continue(ChannelHandlerContext ctx)
+   {
+      HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+      ctx.writeAndFlush(response);
+   }
+
+   @Override
+   public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
+           throws Exception
+   {
+      // handle the case of to big requests.
+      if (e.getCause() instanceof TooLongFrameException)
+      {
+          DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, REQUEST_ENTITY_TOO_LARGE);
+          ctx.write(response).addListener(ChannelFutureListener.CLOSE);
+      }
+      else
+      {
+          e.getCause().printStackTrace();
+          ctx.close();
+      }
+
+   }
+}",2013-08-13T21:09:44Z,138
"@@ -0,0 +1,86 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected;
+
+/**
+ * This {@link MessageToMessageDecoder} is responsible for decode {@link io.netty.handler.codec.http.HttpRequest}
+ * to {@link NettyHttpRequest}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.HttpRequest>
+{
+    private final static Logger logger = Logger.getLogger(RestEasyHttpRequestDecoder.class);
+
+    private final SynchronousDispatcher dispatcher;
+    private final String servletMappingPrefix;
+    private final String proto;
+
+    public enum Protocol
+    {
+        HTTPS,
+        HTTP
+    }
+
+    public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servletMappingPrefix, Protocol protocol)
+    {
+        this.dispatcher = dispatcher;
+        this.servletMappingPrefix = servletMappingPrefix;
+        if (protocol == Protocol.HTTP)
+        {
+            proto = ""http"";
+        }
+        else
+        {
+            proto = ""https"";
+        }
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
+    {
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
+        NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        ResteasyHttpHeaders headers = null;
+        ResteasyUriInfo uriInfo = null;
+        try
+        {
+           headers = NettyUtil.extractHttpHeaders(request);
+
+           uriInfo = NettyUtil.extractUriInfo(request, servletMappingPrefix, proto);
+           NettyHttpRequest nettyRequest = new NettyHttpRequest(headers, uriInfo, request.getMethod().name(), dispatcher, response, is100ContinueExpected(request) );
+           if (request instanceof HttpContent)
+           {
+               HttpContent content = (HttpContent) request;
+               ByteBuf buf = content.content().copy();
+               ByteBufInputStream in = new ByteBufInputStream(buf);
+               nettyRequest.setInputStream(in);
+               out.add(nettyRequest);
+           }
+        }
+        catch (Exception e)
+        {
+           response.sendError(400);
+           // made it warn so that people can filter this.
+           logger.warn(""Failed to parse request."", e);
+        }
+    }
+}",2013-08-13T21:09:44Z,139
"@@ -0,0 +1,76 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.util.List;
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+
+/**
+ * {@link MessageToMessageEncoder} implementation which encodes {@link org.jboss.resteasy.spi.HttpResponse}'s to
+ * {@link HttpResponse}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpResponseEncoder extends MessageToMessageEncoder<NettyHttpResponse>
+{
+
+    private final RequestDispatcher dispatcher;
+
+    public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
+    {
+        this.dispatcher = dispatcher;
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
+    {
+        // Build the response object.
+        HttpResponseStatus status = HttpResponseStatus.valueOf(nettyResponse.getStatus());
+        ByteBuf buffer = nettyResponse.getBuffer();
+        HttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, buffer);
+
+        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+        {
+           String key = entry.getKey();
+           for (Object value : entry.getValue())
+           {
+              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
+              if (delegate != null)
+              {
+                  response.headers().add(key, delegate.toString(value));
+              }
+              else
+              {
+                 response.headers().set(key, value.toString());
+              }
+           }
+        }
+
+        if (nettyResponse.isKeepAlive())
+        {
+            // Add content length and connection header if needed
+            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+        }
+        out.add(response);
+    }
+
+}",2013-08-13T21:09:44Z,140
"@@ -0,0 +1,72 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyContainer
+{
+   public static NettyJaxrsServer netty;
+
+   public static ResteasyDeployment start() throws Exception
+   {
+      return start("""");
+   }
+
+   public static ResteasyDeployment start(String bindPath) throws Exception
+   {
+      return start(bindPath, null);
+   }
+
+   public static void start(ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath("""");
+      netty.setSecurityDomain(null);
+      netty.start();
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setSecurityEnabled(true);
+      return start(bindPath, domain, deployment);
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain, ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath(bindPath);
+      netty.setSecurityDomain(domain);
+      netty.start();
+      return netty.getDeployment();
+   }
+
+   public static void stop() throws Exception
+   {
+      if (netty != null)
+      {
+         try
+         {
+            netty.stop();
+         }
+         catch (Exception e)
+         {
+
+         }
+      }
+      netty = null;
+   }
+
+   public static void main(String args[]) throws Exception {
+       start();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,176
"@@ -1,6 +1,8 @@
 package org.jboss.resteasy.plugins.server.netty;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
@@ -10,12 +12,15 @@
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.util.concurrent.Future;
+
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.spi.HttpResponse;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.NewCookie;
+
 import java.io.IOException;
 import java.io.OutputStream;
 
@@ -168,12 +173,17 @@ public void prepareChunkStream() {
 
    public void finish() throws IOException {
       os.flush();
+      ChannelFuture future;
       if (isCommitted()) {
          // if committed this means the output stream was used.
-         ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+         future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
       } else {
          io.netty.handler.codec.http.HttpResponse response = getDefaultHttpResponse();
-         ctx.writeAndFlush(response);
+         future = ctx.writeAndFlush(response);
+      }
+      
+      if(!isKeepAlive()) {
+         future.addListener(ChannelFutureListener.CLOSE);
       }
 
    }",2014-03-26T11:39:09Z,137
"@@ -1,21 +1,19 @@
 package org.jboss.resteasy.plugins.server.netty;
 
-import io.netty.channel.ChannelFuture;
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
+
 import org.jboss.resteasy.logging.Logger;
 import org.jboss.resteasy.spi.Failure;
 
-import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
-import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
-import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
-
 /**
  * {@link SimpleChannelInboundHandler} which handles the requests and dispatch them.
  *
@@ -65,20 +63,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
              response.setStatus(500);
              logger.error(""Unexpected"", ex);
           }
-          ChannelFuture future = null;
+
           if (!request.getAsyncContext().isSuspended()) {
              response.finish();
-          } else {
-              // Write an empty response
-              //future = ctx.write(response);
-              // retain buffer since it was automatically
-              // reference counted by the write operation above
-              //response.retain();
-          }
-          // Close the non-keep-alive connection after the write operation is done.
-          if (!request.isKeepAlive())
-          {
-              future.addListener(ChannelFutureListener.CLOSE);
           }
       }
    }",2014-03-26T11:39:09Z,138
"@@ -1,17 +1,16 @@
 package org.jboss.resteasy.test;
 
-import org.junit.AfterClass;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
 
-import javax.ws.rs.ForbiddenException;
-import javax.ws.rs.NotFoundException;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.core.Response;
 
-import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import javax.ws.rs.client.Invocation.Builder;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -196,6 +195,18 @@ public void testResumeObjectThread() throws Exception
       response.close();
       client.close();
    }
+   
+   @Test
+   public void testConnectionCloseHeader() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      Builder requestBuilder = client.target(BASE_URI).path(""jaxrs/empty"").request();
+      requestBuilder.header(""Connection"", ""close"");
+      Response response = requestBuilder.get();
+      Assert.assertNull(response.getHeaderString(""Connection""));
+      response.close();
+      client.close();
+   }
 
 
 }",2014-03-26T11:39:09Z,142
"@@ -1,6 +1,8 @@
 package org.jboss.resteasy.plugins.server.netty;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
@@ -10,12 +12,15 @@
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.util.concurrent.Future;
+
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.jboss.resteasy.spi.HttpResponse;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.NewCookie;
+
 import java.io.IOException;
 import java.io.OutputStream;
 
@@ -168,12 +173,17 @@ public void prepareChunkStream() {
 
    public void finish() throws IOException {
       os.flush();
+      ChannelFuture future;
       if (isCommitted()) {
          // if committed this means the output stream was used.
-         ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+         future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
       } else {
          io.netty.handler.codec.http.HttpResponse response = getDefaultHttpResponse();
-         ctx.writeAndFlush(response);
+         future = ctx.writeAndFlush(response);
+      }
+      
+      if(!isKeepAlive()) {
+         future.addListener(ChannelFutureListener.CLOSE);
       }
 
    }",2014-03-26T11:39:09Z,137
"@@ -1,21 +1,19 @@
 package org.jboss.resteasy.plugins.server.netty;
 
-import io.netty.channel.ChannelFuture;
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
+
 import org.jboss.resteasy.logging.Logger;
 import org.jboss.resteasy.spi.Failure;
 
-import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
-import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
-import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
-
 /**
  * {@link SimpleChannelInboundHandler} which handles the requests and dispatch them.
  *
@@ -65,20 +63,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
              response.setStatus(500);
              logger.error(""Unexpected"", ex);
           }
-          ChannelFuture future = null;
+
           if (!request.getAsyncContext().isSuspended()) {
              response.finish();
-          } else {
-              // Write an empty response
-              //future = ctx.write(response);
-              // retain buffer since it was automatically
-              // reference counted by the write operation above
-              //response.retain();
-          }
-          // Close the non-keep-alive connection after the write operation is done.
-          if (!request.isKeepAlive())
-          {
-              future.addListener(ChannelFutureListener.CLOSE);
           }
       }
    }",2014-03-26T11:39:09Z,138
"@@ -1,17 +1,16 @@
 package org.jboss.resteasy.test;
 
-import org.junit.AfterClass;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
 
-import javax.ws.rs.ForbiddenException;
-import javax.ws.rs.NotFoundException;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.core.Response;
 
-import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import javax.ws.rs.client.Invocation.Builder;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -196,6 +195,18 @@ public void testResumeObjectThread() throws Exception
       response.close();
       client.close();
    }
+   
+   @Test
+   public void testConnectionCloseHeader() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      Builder requestBuilder = client.target(BASE_URI).path(""jaxrs/empty"").request();
+      requestBuilder.header(""Connection"", ""close"");
+      Response response = requestBuilder.get();
+      Assert.assertNull(response.getHeaderString(""Connection""));
+      response.close();
+      client.close();
+   }
 
 
 }",2014-03-26T11:39:09Z,142
"@@ -25,6 +25,7 @@
         <dep.guice.version>3.0</dep.guice.version>
         <dep.jboss-el.version>1.0_02.CR4</dep.jboss-el.version>
         <dep.netty.version>3.6.4.Final</dep.netty.version>
+        <dep.netty4.version>4.0.6.Final</dep.netty4.version>
     </properties>
 
     <url>http://rest-easy.org</url>",2013-08-13T21:09:44Z,117
"@@ -16,5 +16,6 @@
     <modules>
         <module>resteasy-jdk-http</module>
         <module>resteasy-netty</module>
+        <module>resteasy-netty4</module>
     </modules>
 </project>",2013-08-13T21:09:44Z,172
"@@ -0,0 +1,45 @@
+<?xml version=""1.0""?>
+<project>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>resteasy-netty4</artifactId>
+    <name>RESTEasy Netty 4 Integration</name>
+    <description/>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>${dep.netty4.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2013-08-13T21:09:44Z,135
"@@ -0,0 +1,221 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.SynchronousExecutionContext;
+import org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.NotImplementedYetException;
+import org.jboss.resteasy.spi.ResteasyAsynchronousContext;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.Encode;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * Abstraction for an inbound http request on the server, or a response from a server to a client
+ * <p/>
+ * We have this abstraction so that we can reuse marshalling objects in a client framework and serverside framework
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class NettyHttpRequest implements org.jboss.resteasy.spi.HttpRequest
+{
+   protected ResteasyHttpHeaders httpHeaders;
+   protected SynchronousDispatcher dispatcher;
+   protected ResteasyUriInfo uriInfo;
+   protected String httpMethod;
+   protected MultivaluedMap<String, String> formParameters;
+   protected MultivaluedMap<String, String> decodedFormParameters;
+   protected InputStream inputStream;
+   protected Map<String, Object> attributes = new HashMap<String, Object>();
+   protected NettyHttpResponse httpResponse;
+   private final boolean is100ContinueExpected;
+
+
+   public NettyHttpRequest(ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uri, String httpMethod, SynchronousDispatcher dispatcher, NettyHttpResponse httpResponse, boolean is100ContinueExpected)
+   {
+      this.is100ContinueExpected = is100ContinueExpected;
+      this.httpResponse = httpResponse;
+      this.dispatcher = dispatcher;
+      this.httpHeaders = httpHeaders;
+      this.httpMethod = httpMethod;
+      this.uriInfo = uri;
+
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getMutableHeaders()
+   {
+      return httpHeaders.getMutableHeaders();
+   }
+
+   @Override
+   public void setHttpMethod(String method)
+   {
+      this.httpMethod = method;
+   }
+
+   @Override
+   public Enumeration<String> getAttributeNames()
+   {
+      Enumeration<String> en = new Enumeration<String>()
+      {
+         private Iterator<String> it = attributes.keySet().iterator();
+         @Override
+         public boolean hasMoreElements()
+         {
+            return it.hasNext();
+         }
+
+         @Override
+         public String nextElement()
+         {
+            return it.next();
+         }
+      };
+      return en;
+   }
+
+   @Override
+   public ResteasyAsynchronousContext getAsyncContext()
+   {
+      return new SynchronousExecutionContext(dispatcher, this, httpResponse);
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getFormParameters()
+   {
+      if (formParameters != null) return formParameters;
+      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      {
+         try
+         {
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+      else
+      {
+         throw new IllegalArgumentException(""Request media type is not application/x-www-form-urlencoded"");
+      }
+      return formParameters;
+   }
+
+   @Override
+   public MultivaluedMap<String, String> getDecodedFormParameters()
+   {
+      if (decodedFormParameters != null) return decodedFormParameters;
+      decodedFormParameters = Encode.decode(getFormParameters());
+      return decodedFormParameters;
+   }
+
+
+   @Override
+   public Object getAttribute(String attribute)
+   {
+      return attributes.get(attribute);
+   }
+
+   @Override
+   public void setAttribute(String name, Object value)
+   {
+      attributes.put(name, value);
+   }
+
+   @Override
+   public void removeAttribute(String name)
+   {
+      attributes.remove(name);
+   }
+
+   @Override
+   public HttpHeaders getHttpHeaders()
+   {
+      return httpHeaders;
+   }
+
+   @Override
+   public InputStream getInputStream()
+   {
+      return inputStream;
+   }
+
+   @Override
+   public void setInputStream(InputStream stream)
+   {
+      this.inputStream = stream;
+   }
+
+   @Override
+   public ResteasyUriInfo getUri()
+   {
+      return uriInfo;
+   }
+
+   @Override
+   public String getHttpMethod()
+   {
+      return httpMethod;
+   }
+
+   @Override
+   public void setRequestUri(URI requestUri) throws IllegalStateException
+   {
+      uriInfo = uriInfo.setRequestUri(requestUri);
+   }
+
+   @Override
+   public void setRequestUri(URI baseUri, URI requestUri) throws IllegalStateException
+   {
+      uriInfo = new ResteasyUriInfo(baseUri.resolve(requestUri));
+   }
+
+
+   @Override
+   public boolean isInitial()
+   {
+      return true;
+   }
+
+   public NettyHttpResponse getResponse()
+   {
+       return httpResponse;
+   }
+
+   public boolean isKeepAlive()
+   {
+       return httpResponse.isKeepAlive();
+   }
+
+   public boolean is100ContinueExpected()
+   {
+       return is100ContinueExpected;
+   }
+
+   @Override
+   public void forward(String path)
+   {
+      throw new NotImplementedYetException();
+   }
+
+   @Override
+   public boolean wasForwarded()
+   {
+      return false;
+   }
+
+}",2013-08-13T21:09:44Z,136
"@@ -0,0 +1,142 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.spi.HttpResponse;
+
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.NewCookie;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyHttpResponse implements HttpResponse
+{
+   private int status = 200;
+   private ByteBuf byteBuf;
+   private OutputStream os;
+   private MultivaluedMap<String, Object> outputHeaders;
+   private final ChannelHandlerContext ctx;
+   private boolean committed;
+   private boolean keepAlive;
+
+   public NettyHttpResponse(ChannelHandlerContext ctx, boolean keepAlive)
+   {
+      outputHeaders = new MultivaluedMapImpl<String, Object>();
+      byteBuf = Unpooled.buffer();
+      os = new ByteBufOutputStream(byteBuf);
+      this.ctx = ctx;
+      this.keepAlive = keepAlive;
+   }
+
+   @Override
+   public void setOutputStream(OutputStream os)
+   {
+      this.os = os;
+   }
+
+   public ByteBuf getBuffer()
+   {
+      return byteBuf;
+   }
+
+   @Override
+   public int getStatus()
+   {
+      return status;
+   }
+
+   @Override
+   public void setStatus(int status)
+   {
+      this.status = status;
+   }
+
+   @Override
+   public MultivaluedMap<String, Object> getOutputHeaders()
+   {
+      return outputHeaders;
+   }
+
+   @Override
+   public OutputStream getOutputStream() throws IOException
+   {
+      return os;
+   }
+
+   @Override
+   public void addNewCookie(NewCookie cookie)
+   {
+      outputHeaders.add(HttpHeaders.SET_COOKIE, cookie);
+   }
+
+   @Override
+   public void sendError(int status) throws IOException
+   {
+      sendError(status, null);
+   }
+
+   @Override
+   public void sendError(int status, String message) throws IOException
+   {
+       if (committed)
+       {
+           throw new IllegalStateException();
+       }
+
+       final HttpResponseStatus responseStatus;
+       if (message != null)
+       {
+           responseStatus = new HttpResponseStatus(status, message);
+           setStatus(status);
+       }
+       else
+       {
+           responseStatus = HttpResponseStatus.valueOf(status);
+           setStatus(status);
+       }
+       final io.netty.handler.codec.http.HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, responseStatus);
+       if (keepAlive)
+       {
+           // Add keep alive and content length if needed
+           response.headers().add(Names.CONNECTION, Values.KEEP_ALIVE);
+           response.headers().add(Names.CONTENT_LENGTH, 0);
+       }
+       ctx.writeAndFlush(response);
+       committed = true;
+   }
+
+   @Override
+   public boolean isCommitted()
+   {
+      return committed;
+   }
+
+   @Override
+   public void reset()
+   {
+      if (committed)
+      {
+          throw new IllegalStateException(""Already committed"");
+      }
+      outputHeaders.clear();
+      byteBuf.clear();
+      outputHeaders.clear();
+   }
+
+   public boolean isKeepAlive() {
+       return keepAlive;
+   }
+}",2013-08-13T21:09:44Z,137
"@@ -0,0 +1,188 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.codec.http.HttpRequestDecoder;
+import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.EventExecutor;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import resteasy.plugins.server.netty.RequestDispatcher;
+import resteasy.plugins.server.netty.RequestHandler;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;
+import resteasy.plugins.server.netty.RestEasyHttpRequestDecoder.Protocol;
+import resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
+ */
+public class NettyJaxrsServer implements EmbeddedJaxrsServer
+{
+   protected ServerBootstrap bootstrap = new ServerBootstrap();
+   protected int port = 8080;
+   protected ResteasyDeployment deployment = new ResteasyDeployment();
+   protected String root = """";
+   protected SecurityDomain domain;
+   private EventLoopGroup bossGroup;
+   private EventLoopGroup workerGroup;
+   private EventLoopGroup eventExecutor;
+   private int ioWorkerCount = Runtime.getRuntime().availableProcessors() * 2;
+   private int executorThreadCount = 16;
+   private SSLContext sslContext;
+   private int maxRequestSize = 1024 * 1024 * 10;
+
+   public void setSSLContext(SSLContext sslContext)
+   {
+      this.sslContext = sslContext;
+   }
+
+   /**
+    * Specify the worker count to use. For more information about this please see the javadocs of {@link EventLoopGroup}
+    *
+    * @param ioWorkerCount
+    */
+   public void setIoWorkerCount(int ioWorkerCount)
+   {
+       this.ioWorkerCount = ioWorkerCount;
+   }
+
+   /**
+    * Set the number of threads to use for the EventExecutor. For more information please see the javadocs of {@link EventExecutor}.
+    * If you want to disable the use of the {@link EventExecutor} specify a value <= 0.  This should only be done if you are 100% sure that you don't have any blocking
+    * code in there.
+    *
+    *
+    * @param executorThreadCount
+    */
+   public void setExecutorThreadCount(int executorThreadCount)
+   {
+       this.executorThreadCount = executorThreadCount;
+   }
+
+   /**
+    * Set the max. request size in bytes. If this size is exceed we will send a ""413 Request Entity Too Large"" to the client.
+    *
+    * @param maxRequestSize the max request size. This is 10mb by default.
+    */
+   public void setMaxRequestSize(int maxRequestSize)
+   {
+       this.maxRequestSize  = maxRequestSize;
+   }
+
+   public int getPort()
+   {
+      return port;
+   }
+
+   public void setPort(int port)
+   {
+      this.port = port;
+   }
+
+   @Override
+   public void setDeployment(ResteasyDeployment deployment)
+   {
+      this.deployment = deployment;
+   }
+
+   @Override
+   public void setRootResourcePath(String rootResourcePath)
+   {
+      root = rootResourcePath;
+      if (root != null && root.equals(""/"")) root = """";
+   }
+
+   @Override
+   public ResteasyDeployment getDeployment()
+   {
+      return deployment;
+   }
+
+   @Override
+   public void setSecurityDomain(SecurityDomain sc)
+   {
+      this.domain = sc;
+   }
+
+   @Override
+   public void start()
+   {
+      bossGroup = new NioEventLoopGroup();
+      workerGroup = new NioEventLoopGroup(ioWorkerCount);
+      eventExecutor = new NioEventLoopGroup(executorThreadCount);
+
+      deployment.start();
+      final RequestDispatcher dispatcher = new RequestDispatcher((SynchronousDispatcher)deployment.getDispatcher(), deployment.getProviderFactory(), domain);
+       // Configure the server.
+       if (sslContext == null) {
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTP));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       } else {
+           final SSLEngine engine = sslContext.createSSLEngine();
+           engine.setUseClientMode(false);
+           bootstrap.group(bossGroup, workerGroup)
+                   .channel(NioServerSocketChannel.class)
+                   .childHandler(new ChannelInitializer<SocketChannel>() {
+                       @Override
+                       public void initChannel(SocketChannel ch) throws Exception {
+                           ch.pipeline().addFirst(new SslHandler(engine));
+                           ch.pipeline().addLast(new HttpRequestDecoder());
+                           ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));
+                           ch.pipeline().addLast(new HttpResponseEncoder());
+                           ch.pipeline().addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root, Protocol.HTTPS));
+                           ch.pipeline().addLast(new RestEasyHttpResponseEncoder(dispatcher));
+                           ch.pipeline().addLast(eventExecutor, new RequestHandler(dispatcher));
+
+                       }
+                   })
+                   .option(ChannelOption.SO_BACKLOG, 128)
+                   .childOption(ChannelOption.SO_KEEPALIVE, true);
+       }
+
+       try {
+           bootstrap.bind(port).sync();
+       } catch (InterruptedException e) {
+           // ignore
+       }
+   }
+
+   @Override
+   public void stop()
+   {
+       workerGroup.shutdownGracefully();
+       bossGroup.shutdownGracefully();
+       eventExecutor.shutdownGracefully();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,14
"@@ -0,0 +1,54 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+
+import javax.ws.rs.core.SecurityContext;
+import java.security.Principal;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettySecurityContext implements SecurityContext
+{
+   protected final Principal principal;
+   protected final SecurityDomain domain;
+   protected final String authScheme;
+   protected final boolean isSecure;
+
+   public NettySecurityContext(Principal principal, SecurityDomain domain, String authScheme, boolean secure)
+   {
+      this.principal = principal;
+      this.domain = domain;
+      this.authScheme = authScheme;
+      isSecure = secure;
+   }
+   public NettySecurityContext() {
+       this(null, null, null, false);
+   }
+
+   @Override
+   public Principal getUserPrincipal()
+   {
+      return principal;
+   }
+
+   @Override
+   public boolean isUserInRole(String role)
+   {
+      if (domain == null) return false;
+      return domain.isUserInRoll(principal, role);
+   }
+
+   @Override
+   public boolean isSecure()
+   {
+      return isSecure;
+   }
+
+   @Override
+   public String getAuthenticationScheme()
+   {
+      return authScheme;
+   }
+}",2013-08-13T21:09:44Z,173
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.MediaTypeHelper;
+import org.jboss.resteasy.util.PathHelper;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyUtil
+{
+   public static ResteasyUriInfo extractUriInfo(HttpRequest request, String contextPath, String protocol)
+   {
+      String host = HttpHeaders.getHost(request, ""unknown"");
+      String uri = request.getUri();
+
+      URI absoluteURI = URI.create(protocol + ""://"" + host + uri);
+
+      String path = PathHelper.getEncodedPathInfo(absoluteURI.getRawPath(), contextPath);
+      if (!path.startsWith(""/""))
+      {
+         path = ""/"" + path;
+      }
+
+      URI baseURI = absoluteURI;
+      if (!path.trim().equals(""""))
+      {
+         String tmpContextPath = contextPath;
+         if (!tmpContextPath.endsWith(""/"")) tmpContextPath += ""/"";
+         baseURI = UriBuilder.fromUri(absoluteURI).replacePath(tmpContextPath).replaceQuery(null).build();
+      }
+      else
+      {
+         baseURI = UriBuilder.fromUri(absoluteURI).replaceQuery(null).build();
+      }
+      URI relativeURI = UriBuilder.fromUri(path).replaceQuery(absoluteURI.getRawQuery()).build();
+      //System.out.println(""path: "" + path);
+      //System.out.println(""query string: "" + request.getQueryString());
+      ResteasyUriInfo uriInfo = new ResteasyUriInfo(baseURI, relativeURI);
+      return uriInfo;
+   }
+
+   public static ResteasyHttpHeaders extractHttpHeaders(HttpRequest request)
+   {
+
+      MultivaluedMap<String, String> requestHeaders = extractRequestHeaders(request);
+      ResteasyHttpHeaders headers = new ResteasyHttpHeaders(requestHeaders);
+
+      Map<String, Cookie> cookies = extractCookies(requestHeaders);
+      headers.setCookies(cookies);
+      // test parsing should throw an exception on error
+      headers.testParsing();
+      return headers;
+
+   }
+
+   static Map<String, Cookie> extractCookies(MultivaluedMap<String, String> headers)
+   {
+      Map<String, Cookie> cookies = new HashMap<String, Cookie>();
+      List<String> cookieHeaders = headers.get(""Cookie"");
+      if (cookieHeaders == null) return cookies;
+
+      for (String cookieVal : cookieHeaders)
+      {
+         Cookie cookie = Cookie.valueOf(cookieVal);
+         cookies.put(cookie.getName(), cookie);
+      }
+      return cookies;
+   }
+
+   public static List<MediaType> extractAccepts(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT);
+      if (accepts == null) return acceptableMediaTypes;
+
+      for (String accept : accepts)
+      {
+         acceptableMediaTypes.addAll(MediaTypeHelper.parseHeader(accept));
+      }
+      return acceptableMediaTypes;
+   }
+
+   public static List<String> extractLanguages(MultivaluedMap<String, String> requestHeaders)
+   {
+      List<String> acceptable = new ArrayList<String>();
+      List<String> accepts = requestHeaders.get(HttpHeaderNames.ACCEPT_LANGUAGE);
+      if (accepts == null) return acceptable;
+
+      for (String accept : accepts)
+      {
+         String[] splits = accept.split("","");
+         for (String split : splits) acceptable.add(split.trim());
+      }
+      return acceptable;
+   }
+
+   public static MultivaluedMap<String, String> extractRequestHeaders(HttpRequest request)
+   {
+      Headers<String> requestHeaders = new Headers<String>();
+
+      for (Map.Entry<String, String> header : request.headers())
+      {
+         requestHeaders.add(header.getKey(), header.getValue());
+      }
+      return requestHeaders;
+   }
+}",2013-08-13T21:09:44Z,174
"@@ -0,0 +1,141 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import org.apache.commons.codec.binary.Base64;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.HttpResponse;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.jboss.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.core.SecurityContext;
+import java.io.IOException;
+import java.security.Principal;
+import java.util.List;
+
+/**
+ * Helper/delegate class to unify Servlet and Filter dispatcher implementations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @author Norman Maurer
+ * @version $Revision: 1 $
+ */
+public class RequestDispatcher
+{
+   protected final SynchronousDispatcher dispatcher;
+   protected final ResteasyProviderFactory providerFactory;
+   protected final SecurityDomain domain;
+
+   public RequestDispatcher(SynchronousDispatcher dispatcher, ResteasyProviderFactory providerFactory, SecurityDomain domain)
+   {
+      this.dispatcher = dispatcher;
+      this.providerFactory = providerFactory;
+      this.domain = domain;
+   }
+
+   public SynchronousDispatcher getDispatcher()
+   {
+      return dispatcher;
+   }
+
+   public SecurityDomain getDomain()
+   {
+      return domain;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void service(HttpRequest request, HttpResponse response, boolean handleNotFound) throws IOException
+   {
+
+      try
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.push(providerFactory);
+         }
+
+         SecurityContext securityContext;
+         if (domain != null)
+         {
+            securityContext = basicAuthentication(request, response);
+            if (securityContext == null) // not authenticated
+            {
+               return;
+            }
+         } else {
+            securityContext = new NettySecurityContext();
+         }
+         try
+         {
+
+            ResteasyProviderFactory.pushContext(SecurityContext.class, securityContext);
+            if (handleNotFound)
+            {
+               dispatcher.invoke(request, response);
+            }
+            else
+            {
+               dispatcher.invokePropagateNotFound(request, response);
+            }
+         }
+         finally
+         {
+            ResteasyProviderFactory.clearContextData();
+         }
+      }
+      finally
+      {
+         ResteasyProviderFactory defaultInstance = ResteasyProviderFactory.getInstance();
+         if (defaultInstance instanceof ThreadLocalResteasyProviderFactory)
+         {
+            ThreadLocalResteasyProviderFactory.pop();
+         }
+
+      }
+   }
+
+   private SecurityContext basicAuthentication(HttpRequest request, HttpResponse response) throws IOException
+   {
+      List<String> headers = request.getHttpHeaders().getRequestHeader(HttpHeaderNames.AUTHORIZATION);
+      if (!headers.isEmpty()) {
+         String auth = headers.get(0);
+         if (auth.length() > 5)
+         {
+            String type = auth.substring(0, 5);
+            type = type.toLowerCase();
+            if (""basic"".equals(type))
+            {
+               String cookie = auth.substring(6);
+               cookie = new String(Base64.decodeBase64(cookie.getBytes()));
+               String[] split = cookie.split("":"");
+               Principal user = null;
+               try
+               {
+                  user = domain.authenticate(split[0], split[1]);
+                  return new NettySecurityContext(user, domain, ""BASIC"", true);
+               }
+               catch (SecurityException e)
+               {
+                  response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+                  return null;
+               }
+            }
+            else
+            {
+               response.sendError(HttpResponseCodes.SC_UNAUTHORIZED);
+               return null;
+            }
+         }
+      }
+      return null;
+   }
+
+
+}
\ No newline at end of file",2013-08-13T21:09:44Z,175
"@@ -0,0 +1,104 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpResponse;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.Failure;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which handles the requests and dispatch them.
+ *
+ * This class is {@link Sharable}.
+ *
+ * @author <a href=""http://www.jboss.org/netty/"">The Netty Project</a>
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author <a href=""http://gleamynode.net/"">Trustin Lee</a>
+ * @author Norman Maurer
+ * @version $Rev: 2368 $, $Date: 2010-10-18 17:19:03 +0900 (Mon, 18 Oct 2010) $
+ */
+@Sharable
+public class RequestHandler extends ChannelInboundHandlerAdapter
+{
+   protected final RequestDispatcher dispatcher;
+   private final static Logger logger = Logger.getLogger(RequestHandler.class);
+
+   public RequestHandler(RequestDispatcher dispatcher)
+   {
+      this.dispatcher = dispatcher;
+   }
+
+   @Override
+   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
+   {
+      if (msg instanceof NettyHttpRequest) {
+          NettyHttpRequest request = (NettyHttpRequest) msg;
+
+          if (request.is100ContinueExpected())
+          {
+             send100Continue(ctx);
+          }
+
+          NettyHttpResponse response = request.getResponse();
+          try
+          {
+             dispatcher.service(request, response, true);
+          }
+          catch (Failure e1)
+          {
+             response.reset();
+             response.setStatus(e1.getErrorCode());
+             return;
+          }
+          catch (Exception ex)
+          {
+             response.reset();
+             response.setStatus(500);
+             logger.error(""Unexpected"", ex);
+             return;
+          }
+
+          // Write the response.
+          ChannelFuture future = ctx.writeAndFlush(response);
+
+          // Close the non-keep-alive connection after the write operation is done.
+          if (!request.isKeepAlive())
+          {
+             future.addListener(ChannelFutureListener.CLOSE);
+          }
+      }
+   }
+
+   private void send100Continue(ChannelHandlerContext ctx)
+   {
+      HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+      ctx.writeAndFlush(response);
+   }
+
+   @Override
+   public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
+           throws Exception
+   {
+      // handle the case of to big requests.
+      if (e.getCause() instanceof TooLongFrameException)
+      {
+          DefaultHttpResponse response = new DefaultHttpResponse(HTTP_1_1, REQUEST_ENTITY_TOO_LARGE);
+          ctx.write(response).addListener(ChannelFutureListener.CLOSE);
+      }
+      else
+      {
+          e.getCause().printStackTrace();
+          ctx.close();
+      }
+
+   }
+}",2013-08-13T21:09:44Z,138
"@@ -0,0 +1,86 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.jboss.resteasy.core.SynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.ResteasyHttpHeaders;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
+
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected;
+
+/**
+ * This {@link MessageToMessageDecoder} is responsible for decode {@link io.netty.handler.codec.http.HttpRequest}
+ * to {@link NettyHttpRequest}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.HttpRequest>
+{
+    private final static Logger logger = Logger.getLogger(RestEasyHttpRequestDecoder.class);
+
+    private final SynchronousDispatcher dispatcher;
+    private final String servletMappingPrefix;
+    private final String proto;
+
+    public enum Protocol
+    {
+        HTTPS,
+        HTTP
+    }
+
+    public RestEasyHttpRequestDecoder(SynchronousDispatcher dispatcher, String servletMappingPrefix, Protocol protocol)
+    {
+        this.dispatcher = dispatcher;
+        this.servletMappingPrefix = servletMappingPrefix;
+        if (protocol == Protocol.HTTP)
+        {
+            proto = ""http"";
+        }
+        else
+        {
+            proto = ""https"";
+        }
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, List<Object> out) throws Exception
+    {
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
+        NettyHttpResponse response = new NettyHttpResponse(ctx, keepAlive);
+        ResteasyHttpHeaders headers = null;
+        ResteasyUriInfo uriInfo = null;
+        try
+        {
+           headers = NettyUtil.extractHttpHeaders(request);
+
+           uriInfo = NettyUtil.extractUriInfo(request, servletMappingPrefix, proto);
+           NettyHttpRequest nettyRequest = new NettyHttpRequest(headers, uriInfo, request.getMethod().name(), dispatcher, response, is100ContinueExpected(request) );
+           if (request instanceof HttpContent)
+           {
+               HttpContent content = (HttpContent) request;
+               ByteBuf buf = content.content().copy();
+               ByteBufInputStream in = new ByteBufInputStream(buf);
+               nettyRequest.setInputStream(in);
+               out.add(nettyRequest);
+           }
+        }
+        catch (Exception e)
+        {
+           response.sendError(400);
+           // made it warn so that people can filter this.
+           logger.warn(""Failed to parse request."", e);
+        }
+    }
+}",2013-08-13T21:09:44Z,139
"@@ -0,0 +1,76 @@
+package org.jboss.resteasy.plugins.server.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.util.List;
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+
+/**
+ * {@link MessageToMessageEncoder} implementation which encodes {@link org.jboss.resteasy.spi.HttpResponse}'s to
+ * {@link HttpResponse}'s
+ *
+ * This implementation is {@link Sharable}
+ *
+ * @author Norman Maurer
+ *
+ */
+@Sharable
+public class RestEasyHttpResponseEncoder extends MessageToMessageEncoder<NettyHttpResponse>
+{
+
+    private final RequestDispatcher dispatcher;
+
+    public RestEasyHttpResponseEncoder(RequestDispatcher dispatcher)
+    {
+        this.dispatcher = dispatcher;
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    protected void encode(ChannelHandlerContext ctx, NettyHttpResponse nettyResponse, List<Object> out) throws Exception
+    {
+        // Build the response object.
+        HttpResponseStatus status = HttpResponseStatus.valueOf(nettyResponse.getStatus());
+        ByteBuf buffer = nettyResponse.getBuffer();
+        HttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, buffer);
+
+        for (Map.Entry<String, List<Object>> entry : nettyResponse.getOutputHeaders().entrySet())
+        {
+           String key = entry.getKey();
+           for (Object value : entry.getValue())
+           {
+              RuntimeDelegate.HeaderDelegate delegate = dispatcher.providerFactory.getHeaderDelegate(value.getClass());
+              if (delegate != null)
+              {
+                  response.headers().add(key, delegate.toString(value));
+              }
+              else
+              {
+                 response.headers().set(key, value.toString());
+              }
+           }
+        }
+
+        if (nettyResponse.isKeepAlive())
+        {
+            // Add content length and connection header if needed
+            response.headers().set(Names.CONTENT_LENGTH, buffer.readableBytes());
+            response.headers().set(Names.CONNECTION, Values.KEEP_ALIVE);
+        }
+        out.add(response);
+    }
+
+}",2013-08-13T21:09:44Z,140
"@@ -0,0 +1,72 @@
+package org.jboss.resteasy.test;
+
+import org.jboss.resteasy.plugins.server.embedded.SecurityDomain;
+import org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class NettyContainer
+{
+   public static NettyJaxrsServer netty;
+
+   public static ResteasyDeployment start() throws Exception
+   {
+      return start("""");
+   }
+
+   public static ResteasyDeployment start(String bindPath) throws Exception
+   {
+      return start(bindPath, null);
+   }
+
+   public static void start(ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath("""");
+      netty.setSecurityDomain(null);
+      netty.start();
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setSecurityEnabled(true);
+      return start(bindPath, domain, deployment);
+   }
+
+   public static ResteasyDeployment start(String bindPath, SecurityDomain domain, ResteasyDeployment deployment) throws Exception
+   {
+      netty = new NettyJaxrsServer();
+      netty.setDeployment(deployment);
+      netty.setPort(TestPortProvider.getPort());
+      netty.setRootResourcePath(bindPath);
+      netty.setSecurityDomain(domain);
+      netty.start();
+      return netty.getDeployment();
+   }
+
+   public static void stop() throws Exception
+   {
+      if (netty != null)
+      {
+         try
+         {
+            netty.stop();
+         }
+         catch (Exception e)
+         {
+
+         }
+      }
+      netty = null;
+   }
+
+   public static void main(String args[]) throws Exception {
+       start();
+   }
+}
\ No newline at end of file",2013-08-13T21:09:44Z,176
"@@ -11,10 +11,13 @@
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.ext.Provider;
 import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.SequenceInputStream;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
@@ -28,6 +31,45 @@
 public class DataSourceProvider extends AbstractEntityProvider<DataSource>
 {
 
+	protected static class SequencedDataSource implements DataSource {
+		private byte[] byteBuffer;
+		private int byteBufferOffset;
+		private int byteBufferLength;
+		private File tempFile;
+		private String type;
+
+		public SequencedDataSource(byte[] byteBuffer, int byteBufferOffset,
+				int byteBufferLength, File tempFile, String type) {
+			super();
+			this.byteBuffer = byteBuffer;
+			this.byteBufferOffset = byteBufferOffset;
+			this.byteBufferLength = byteBufferLength;
+			this.tempFile = tempFile;
+			this.type = type;
+		}
+
+		public String getContentType() {
+			return type;
+		}
+
+		public InputStream getInputStream() throws IOException {
+			InputStream bis = new ByteArrayInputStream(byteBuffer, byteBufferOffset, byteBufferLength);
+			if (tempFile == null)
+				return bis;
+			InputStream fis = new FileInputStream(tempFile);
+			return new SequenceInputStream(bis, fis);
+		}
+
+		public String getName() {
+			return """";
+		}
+
+		public OutputStream getOutputStream() throws IOException {
+			throw new IOException(""No output stream allowed"");
+		}
+		
+	}
+
 
    /**
     * @param in
@@ -37,33 +79,24 @@ public class DataSourceProvider extends AbstractEntityProvider<DataSource>
     */
    public static DataSource readDataSource(final InputStream in, final MediaType mediaType) throws IOException
    {
-      final String type = mediaType.toString();
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      ProviderHelper.writeTo(in, baos);
-      final byte[] bytes = baos.toByteArray();
+      byte[] memoryBuffer = new byte[4096];
+      int readCount = in.read(memoryBuffer, 0, memoryBuffer.length);
+
+      File tempFile = null;
+      if (in.available() > 0) {
+    	  tempFile = File.createTempFile(""resteasy-provider-datasource"", null);
+    	  FileOutputStream fos = new FileOutputStream(tempFile);
+    	  try {
+    		  ProviderHelper.writeTo(in, fos);
+    	  } finally {
+    		  fos.close();
+    	  }
+      }
 
-      return new DataSource()
-      {
-         public InputStream getInputStream() throws IOException
-         {
-            return new ByteArrayInputStream(bytes);
-         }
-
-         public OutputStream getOutputStream() throws IOException
-         {
-            throw new IOException(""No output stream allowed"");
-         }
-
-         public String getContentType()
-         {
-            return type;
-         }
-
-         public String getName()
-         {
-            return """";
-         }
-      };
+      if (readCount == -1)
+    	  readCount = 0;
+
+      return new SequencedDataSource(memoryBuffer, 0, readCount, tempFile, mediaType.toString());
    }
 
    /**",2009-10-11T14:19:43Z,179
"@@ -6,6 +6,7 @@
 
 import javax.ws.rs.ext.Providers;
 import java.io.BufferedReader;
+import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.net.URL;
 import java.util.Enumeration;
@@ -45,13 +46,18 @@ public static void registerProviders(ResteasyProviderFactory factory) throws Exc
       while (en.hasMoreElements())
       {
          URL url = en.nextElement();
-         BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
-         String line;
-         while ((line = reader.readLine()) != null)
-         {
-            line = line.trim();
-            if (line.equals("""")) continue;
-            set.add(line);
+         InputStream is = url.openStream();
+         try {
+	         BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+	         String line;
+	         while ((line = reader.readLine()) != null)
+	         {
+	            line = line.trim();
+	            if (line.equals("""")) continue;
+	            set.add(line);
+	         }
+         } finally {
+        	 is.close();
          }
       }
       for (String line : set)",2009-10-11T14:19:43Z,180
"@@ -56,6 +56,6 @@ public void writeTo(String o,
                        MultivaluedMap<String, Object> httpHeaders,
                        OutputStream entityStream) throws IOException
    {
-      entityStream.write(o.toString().getBytes());
+      entityStream.write(o.getBytes());
    }
 }
\ No newline at end of file",2009-10-11T14:19:43Z,181
"@@ -32,6 +32,12 @@ public String postDataSource(DataSource datasource)
       return datasource.getContentType();
    }
 
+   @POST
+   @Path(""/echo"")
+   public DataSource echo(DataSource datasource) {
+	   return datasource;
+   }
+
    @GET
    @Path(""/{value}"")
    public DataSource getDataSource(@PathParam(""value"") String value) throws IOException",2009-10-11T14:19:43Z,182
"@@ -5,11 +5,16 @@
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
 
 import javax.servlet.http.HttpServletResponse;
+import javax.ws.rs.core.MediaType;
 
 import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.methods.ByteArrayRequestEntity;
 import org.apache.commons.httpclient.methods.FileRequestEntity;
 import org.apache.commons.httpclient.methods.GetMethod;
 import org.apache.commons.httpclient.methods.PostMethod;
@@ -52,6 +57,73 @@ public void testPostDataSource() throws Exception
       method.releaseConnection();
    }
 
+   @Test
+   public void testEchoDataSourceBigData() throws Exception
+   {
+      HttpClient client = new HttpClient();
+      File file = LocateTestData.getTestData(""harper.jpg"");
+      Assert.assertTrue(file.exists());
+      PostMethod method = new PostMethod(TEST_URI + ""/echo"");
+      method.setRequestEntity(new FileRequestEntity(file, ""image/jpeg""));
+      int status = client.executeMethod(method);
+      Assert.assertEquals(HttpServletResponse.SC_OK, status);
+
+      InputStream ris = null;
+      InputStream fis = null;
+      try {
+    	  ris = method.getResponseBodyAsStream();
+    	  fis = new FileInputStream(file);
+    	  int fi;
+    	  int ri;
+    	  do  {
+    		  fi = fis.read();
+    		  ri = ris.read();
+    		  if (fi != ri)
+    			  Assert.fail(""The sent and recived stream is not identical."");
+    	  } while (fi != -1);
+      } finally {
+    	  if (ris != null)
+    		  ris.close();
+    	  if (fis != null)
+    		  fis.close();
+      }
+
+      method.releaseConnection();
+   }
+
+   @Test
+   public void testEchoDataSourceSmallData() throws Exception
+   {
+      HttpClient client = new HttpClient();
+      byte [] input = ""Hello World!"".getBytes(""utf-8"");
+      PostMethod method = new PostMethod(TEST_URI + ""/echo"");
+      method.setRequestEntity(new ByteArrayRequestEntity(input, MediaType.APPLICATION_OCTET_STREAM));
+      int status = client.executeMethod(method);
+      Assert.assertEquals(HttpServletResponse.SC_OK, status);
+
+      InputStream ris = null;
+      InputStream bis = null;
+      try {
+    	  ris = method.getResponseBodyAsStream();
+    	  bis = new ByteArrayInputStream(input);
+    	  int fi;
+    	  int ri;
+    	  do  {
+    		  fi = bis.read();
+    		  ri = ris.read();
+    		  if (fi != ri)
+    			  Assert.fail(""The sent and recived stream is not identical."");
+    	  } while (fi != -1);
+      } finally {
+    	  if (ris != null)
+    		  ris.close();
+    	  if (bis != null)
+    		  bis.close();
+      }
+
+      method.releaseConnection();
+   }
+
    @Test
    public void testGetDataSource() throws Exception
    {",2009-10-11T14:19:43Z,183
"@@ -97,21 +97,21 @@ public Configuration configuration()
    public ResteasyWebTarget path(String path) throws NullPointerException
    {
       UriBuilder copy = uriBuilder.clone().path(path);
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
    }
 
    @Override
    public ResteasyWebTarget path(Class<?> resource) throws IllegalArgumentException
    {
       UriBuilder copy = uriBuilder.clone().path(resource);
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
    }
 
    @Override
    public ResteasyWebTarget path(Method method) throws IllegalArgumentException
    {
       UriBuilder copy = uriBuilder.clone().path(method);
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
    }
 
    @Override
@@ -145,7 +145,7 @@ public ResteasyWebTarget matrixParam(String name, Object... values) throws NullP
    {
       String[] stringValues = toStringValues(values);
       UriBuilder copy = uriBuilder.clone().matrixParam(name, stringValues);
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
    }
 
    private String[] toStringValues(Object[] values)
@@ -163,7 +163,16 @@ public ResteasyWebTarget queryParam(String name, Object... values) throws NullPo
    {
       String[] stringValues = toStringValues(values);
       UriBuilder copy = uriBuilder.clone().queryParam(name, stringValues);
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
+   }
+
+   protected ResteasyWebTarget copyPathParams(UriBuilder copy)
+   {
+      HashMap<String, String> paramMap = new HashMap<String, String>();
+      paramMap.putAll(pathParams);
+      ClientWebTarget target =  new ClientWebTarget(client, copy, configuration);
+      target.pathParams = paramMap;
+      return target;
    }
 
    @Override
@@ -175,7 +184,7 @@ public ResteasyWebTarget queryParams(MultivaluedMap<String, Object> parameters)
          String[] stringValues = toStringValues(entry.getValue().toArray());
          uriBuilder.queryParam(entry.getKey(), stringValues);
       }
-      return new ClientWebTarget(client, copy, configuration);
+      return copyPathParams(copy);
    }
 
    @Override
@@ -187,15 +196,15 @@ public Invocation.Builder request()
    @Override
    public Invocation.Builder request(String... acceptedResponseTypes)
    {
-      ClientInvocationBuilder builder = new ClientInvocationBuilder(client, uriBuilder.build(pathParams), configuration);
+      ClientInvocationBuilder builder = new ClientInvocationBuilder(client, uriBuilder.buildFromMap(pathParams), configuration);
       builder.getHeaders().accept(acceptedResponseTypes);
       return builder;
    }
 
    @Override
    public Invocation.Builder request(MediaType... acceptedResponseTypes)
    {
-      ClientInvocationBuilder builder = new ClientInvocationBuilder(client, uriBuilder.build(pathParams), configuration);
+      ClientInvocationBuilder builder = new ClientInvocationBuilder(client, uriBuilder.buildFromMap(pathParams), configuration);
       builder.getHeaders().accept(acceptedResponseTypes);
       return builder;
    }",2012-08-28T20:18:23Z,127
"@@ -216,15 +216,17 @@ public void process(ClientInvocationBuilder invocation, Object param)
          @Override
          public Object process(Object target, Object value, Object processor)
          {
-            process((ClientInvocationBuilder)target, value, processor);
-            return null;
+            processParam((ClientInvocationBuilder)target, value, processor);
+            return target;
          }
       }, invocation, param);
    }
 
 
    protected Object process(Process process, Object target, Object param)
    {
+      if (param == null) return target;
+
       for (Map.Entry<Field, Object> entry : fieldMap.entrySet())
       {
 
@@ -270,7 +272,7 @@ private WebTarget build(WebTarget target, Object val, Object proc)
       return target;
    }
 
-   private void process(ClientInvocationBuilder invocation, Object val, Object proc)
+   private void processParam(ClientInvocationBuilder invocation, Object val, Object proc)
    {
       if (proc instanceof InvocationProcessor)
       {",2012-08-28T20:18:23Z,184
"@@ -15,6 +15,7 @@
 import org.jboss.resteasy.util.FindAnnotation;
 import org.jboss.resteasy.util.MediaTypeHelper;
 
+import javax.ws.rs.BeanParam;
 import javax.ws.rs.CookieParam;
 import javax.ws.rs.Encoded;
 import javax.ws.rs.FormParam;
@@ -112,6 +113,11 @@ else if ((/* form = */FindAnnotation.findAnnotation(annotations,
       {
          processor = new FormProcessor(type, configuration);
       }
+      else if ((/* form = */FindAnnotation.findAnnotation(annotations,
+              BeanParam.class)) != null)
+      {
+         processor = new FormProcessor(type, configuration);
+      }
       else if ((FindAnnotation.findAnnotation(annotations,
               Context.class)) != null)
       {",2012-08-28T20:18:23Z,185
"@@ -38,7 +38,8 @@ protected ClientInvocationBuilder apply(ClientInvocationBuilder target, Object o
          form = new Form();
          target.getInvocation().setEntity(Entity.form(form));
       }
-      form.param(paramName, target.getInvocation().getConfiguration().toString(object));
+      String value = target.getInvocation().getConfiguration().toString(object);
+      form.param(paramName, value);
       return target;
    }
 ",2012-08-28T20:18:23Z,186
"@@ -0,0 +1,206 @@
+/*
+ * JBoss, the OpenSource J2EE webOS
+ * 
+ * Distributable under LGPL license.
+ * See terms of license at gnu.org.
+ */
+package org.jboss.resteasy.test.nextgen.beanparam;
+
+import javax.ws.rs.FormParam;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.QueryParam;
+import java.io.Serializable;
+
+
+/**
+ * A FormValueHolder.
+ *
+ * @author <a href=""ryan@damnhandy.com"">Ryan J. McDonough</a>
+ * @version $Revision:$
+ */
+public class ClientForm implements Serializable
+{
+
+
+   /**
+    * The serialVersionUID
+    */
+   private static final long serialVersionUID = 1L;
+
+   @HeaderParam(""custom-header"")
+   private int headerParam;
+
+   @FormParam(""booleanValue"")
+   private Boolean booleanValue;
+
+   @FormParam(""name"")
+   private String name;
+
+   @FormParam(""doubleValue"")
+   private Double doubleValue;
+
+   @FormParam(""longValue"")
+   private Long longValue;
+
+   @FormParam(""integerValue"")
+   private Integer integerValue;
+
+   @FormParam(""shortValue"")
+   private Short shortValue;
+
+   private int id;
+   private int queryParam;
+
+   public int getHeaderParam()
+   {
+      return headerParam;
+   }
+
+   public void setHeaderParam(int headerParam)
+   {
+      this.headerParam = headerParam;
+   }
+
+   @PathParam(""id"")
+   public int getId()
+   {
+      return id;
+   }
+
+   public void setId(int id)
+   {
+      this.id = id;
+   }
+
+   @QueryParam(""query"")
+   public int getQueryParam()
+   {
+      return queryParam;
+   }
+
+   public void setQueryParam(int queryParam)
+   {
+      this.queryParam = queryParam;
+   }
+
+   /**
+    * Get the booleanValue.
+    *
+    * @return the booleanValue.
+    */
+   public Boolean getBooleanValue()
+   {
+      return booleanValue;
+   }
+
+   /**
+    * Set the booleanValue.
+    *
+    * @param booleanValue The booleanValue to set.
+    */
+   public void setBooleanValue(Boolean booleanValue)
+   {
+      this.booleanValue = booleanValue;
+   }
+
+   /**
+    * Get the name.
+    *
+    * @return the name.
+    */
+   public String getName()
+   {
+      return name;
+   }
+
+   /**
+    * Set the name.
+    *
+    * @param name The name to set.
+    */
+   public void setName(String name)
+   {
+      this.name = name;
+   }
+
+   /**
+    * Get the doubleValue.
+    *
+    * @return the doubleValue.
+    */
+   public Double getDoubleValue()
+   {
+      return doubleValue;
+   }
+
+   /**
+    * Set the doubleValue.
+    *
+    * @param doubleValue The doubleValue to set.
+    */
+   public void setDoubleValue(Double doubleValue)
+   {
+      this.doubleValue = doubleValue;
+   }
+
+   /**
+    * Get the longValue.
+    *
+    * @return the longValue.
+    */
+   public Long getLongValue()
+   {
+      return longValue;
+   }
+
+   /**
+    * Set the longValue.
+    *
+    * @param longValue The longValue to set.
+    */
+   public void setLongValue(Long longValue)
+   {
+      this.longValue = longValue;
+   }
+
+   /**
+    * Get the integerValue.
+    *
+    * @return the integerValue.
+    */
+   public Integer getIntegerValue()
+   {
+      return integerValue;
+   }
+
+   /**
+    * Set the integerValue.
+    *
+    * @param integerValue The integerValue to set.
+    */
+   public void setIntegerValue(Integer integerValue)
+   {
+      this.integerValue = integerValue;
+   }
+
+   /**
+    * Get the shortValue.
+    *
+    * @return the shortValue.
+    */
+   public Short getShortValue()
+   {
+      return shortValue;
+   }
+
+   /**
+    * Set the shortValue.
+    *
+    * @param shortValue The shortValue to set.
+    */
+   public void setShortValue(Short shortValue)
+   {
+      this.shortValue = shortValue;
+   }
+}
\ No newline at end of file",2012-08-28T20:18:23Z,187
"@@ -0,0 +1,48 @@
+/*
+ * JBoss, the OpenSource J2EE webOS
+ * 
+ * Distributable under LGPL license.
+ * See terms of license at gnu.org.
+ */
+package org.jboss.resteasy.test.nextgen.beanparam;
+
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.junit.Assert;
+
+import javax.ws.rs.BeanParam;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MultivaluedMap;
+
+/**
+ * A FormResource.
+ *
+ * @author <a href=""ryan@damnhandy.com"">Ryan J. McDonough</a>
+ * @version $Revision:$
+ */
+@Path(""/form/{id}"")
+@Produces(""application/x-www-form-urlencoded"")
+@Consumes(""application/x-www-form-urlencoded"")
+public class FormResource
+{
+
+   @POST
+   public MultivaluedMap<String, String> postObject(@BeanParam FormValueHolder value)
+   {
+      MultivaluedMap<String, String> rtn = new MultivaluedMapImpl<String, String>();
+      rtn.add(""booleanValue"", value.getBooleanValue().toString());
+      rtn.add(""doubleValue"", value.getDoubleValue().toString());
+      rtn.add(""integerValue"", value.getIntegerValue().toString());
+      rtn.add(""longValue"", value.getLongValue().toString());
+      rtn.add(""shortValue"", value.getShortValue().toString());
+      rtn.add(""name"", value.getName());
+
+      Assert.assertEquals(value.getHeaderParam(), 42);
+      Assert.assertEquals(value.getQueryParam(), 42);
+      Assert.assertEquals(value.getId(), 42);
+      Assert.assertEquals(value.getDefaultValue(), 42);
+      return rtn;
+   }
+}",2012-08-28T20:18:23Z,188
"@@ -0,0 +1,215 @@
+/*
+ * JBoss, the OpenSource J2EE webOS
+ * 
+ * Distributable under LGPL license.
+ * See terms of license at gnu.org.
+ */
+package org.jboss.resteasy.test.nextgen.beanparam;
+
+import javax.ws.rs.DefaultValue;
+import javax.ws.rs.FormParam;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.QueryParam;
+import java.io.Serializable;
+
+
+/**
+ * A FormValueHolder.
+ *
+ * @author <a href=""ryan@damnhandy.com"">Ryan J. McDonough</a>
+ * @version $Revision:$
+ */
+public class FormValueHolder implements Serializable
+{
+
+
+   /**
+    * The serialVersionUID
+    */
+   private static final long serialVersionUID = 1L;
+
+   @FormParam(""booleanValue"")
+   private Boolean booleanValue;
+
+   @FormParam(""name"")
+   private String name;
+
+   @FormParam(""doubleValue"")
+   private Double doubleValue;
+
+   @FormParam(""longValue"")
+   private Long longValue;
+
+   @FormParam(""integerValue"")
+   private Integer integerValue;
+
+   @FormParam(""shortValue"")
+   private Short shortValue;
+
+   @QueryParam(""defaultValue"")
+   @DefaultValue(""42"")
+   public int defaultValue;
+
+   private int headerParam;
+   private int id;
+   private int queryParam;
+
+   public int getDefaultValue()
+   {
+      return defaultValue;
+   }
+
+   public int getHeaderParam()
+   {
+      return headerParam;
+   }
+
+   @HeaderParam(""custom-header"")
+   public void setHeaderParam(int headerParam)
+   {
+      this.headerParam = headerParam;
+   }
+
+   public int getId()
+   {
+      return id;
+   }
+
+   @PathParam(""id"")
+   public void setId(int id)
+   {
+      this.id = id;
+   }
+
+   public int getQueryParam()
+   {
+      return queryParam;
+   }
+
+   @QueryParam(""query"")
+   public void setQueryParam(int queryParam)
+   {
+      this.queryParam = queryParam;
+   }
+
+   /**
+    * Get the booleanValue.
+    *
+    * @return the booleanValue.
+    */
+   public Boolean getBooleanValue()
+   {
+      return booleanValue;
+   }
+
+   /**
+    * Set the booleanValue.
+    *
+    * @param booleanValue The booleanValue to set.
+    */
+   public void setBooleanValue(Boolean booleanValue)
+   {
+      this.booleanValue = booleanValue;
+   }
+
+   /**
+    * Get the name.
+    *
+    * @return the name.
+    */
+   public String getName()
+   {
+      return name;
+   }
+
+   /**
+    * Set the name.
+    *
+    * @param name The name to set.
+    */
+   public void setName(String name)
+   {
+      this.name = name;
+   }
+
+   /**
+    * Get the doubleValue.
+    *
+    * @return the doubleValue.
+    */
+   public Double getDoubleValue()
+   {
+      return doubleValue;
+   }
+
+   /**
+    * Set the doubleValue.
+    *
+    * @param doubleValue The doubleValue to set.
+    */
+   public void setDoubleValue(Double doubleValue)
+   {
+      this.doubleValue = doubleValue;
+   }
+
+   /**
+    * Get the longValue.
+    *
+    * @return the longValue.
+    */
+   public Long getLongValue()
+   {
+      return longValue;
+   }
+
+   /**
+    * Set the longValue.
+    *
+    * @param longValue The longValue to set.
+    */
+   public void setLongValue(Long longValue)
+   {
+      this.longValue = longValue;
+   }
+
+   /**
+    * Get the integerValue.
+    *
+    * @return the integerValue.
+    */
+   public Integer getIntegerValue()
+   {
+      return integerValue;
+   }
+
+   /**
+    * Set the integerValue.
+    *
+    * @param integerValue The integerValue to set.
+    */
+   public void setIntegerValue(Integer integerValue)
+   {
+      this.integerValue = integerValue;
+   }
+
+   /**
+    * Get the shortValue.
+    *
+    * @return the shortValue.
+    */
+   public Short getShortValue()
+   {
+      return shortValue;
+   }
+
+   /**
+    * Set the shortValue.
+    *
+    * @param shortValue The shortValue to set.
+    */
+   public void setShortValue(Short shortValue)
+   {
+      this.shortValue = shortValue;
+   }
+}",2012-08-28T20:18:23Z,189
"@@ -0,0 +1,271 @@
+/*
+ * JBoss, the OpenSource J2EE webOS
+ * 
+ * Distributable under LGPL license.
+ * See terms of license at gnu.org.
+ */
+package org.jboss.resteasy.test.nextgen.beanparam;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
+import org.jboss.resteasy.test.BaseResourceTest;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.ws.rs.BeanParam;
+import javax.ws.rs.GET;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.core.Form;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
+import java.io.BufferedInputStream;
+import java.io.InputStream;
+import java.net.URLDecoder;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateBaseUrl;
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * A TestFormResource.
+ *
+ * @author <a href=""ryan@damnhandy.com"">Ryan J. McDonough</a>
+ * @version $Revision:$
+ */
+public class TestFormResource extends BaseResourceTest
+{
+   private static final String SHORT_VALUE_FIELD = ""shortValue"";
+
+   private static final String INTEGER_VALUE_FIELD = ""integerValue"";
+
+   private static final String LONG_VALUE_FIELD = ""longValue"";
+
+   private static final String DOUBLE_VALUE_FIELD = ""doubleValue"";
+
+   private static final String NAME_FIELD = ""name"";
+
+   private static final String BOOLEAN_VALUE_FIELD = ""booleanValue"";
+
+   private static final String TEST_URI = generateURL(""/form/42?query=42"");
+
+   @SuppressWarnings(""unused"")
+   private static final Logger logger = Logger.getLogger(TestFormResource.class);
+
+   @Path(""/form/{id}"")
+   public interface FormClientProxy
+   {
+      @Produces(MediaType.APPLICATION_FORM_URLENCODED)
+      @POST
+      MultivaluedMap<String, String> post(@BeanParam ClientForm form);
+
+      @Produces(MediaType.APPLICATION_FORM_URLENCODED)
+      @POST
+      String postString(@BeanParam ClientForm form);
+
+   }
+
+   public static class ClientForm2
+   {
+      @HeaderParam(""custom-header"")
+      protected String foo;
+
+
+      public String getFoo()
+      {
+         return foo;
+      }
+
+      public void setFoo(String foo)
+      {
+         this.foo = foo;
+      }
+   }
+
+   @Path(""/myform"")
+   public interface MyFormProxy
+   {
+      @POST
+      public void post(@BeanParam ClientForm2 form2);
+   }
+
+   @Path(""/myform"")
+   public static class MyFormResource
+   {
+      @GET
+      @Path(""/server"")
+      @Produces(""application/x-www-form-urlencoded"")
+      public MultivaluedMap<String, String> retrieveServername()
+      {
+
+         MultivaluedMap<String, String> serverMap = new MultivaluedMapImpl<String, String>();
+         serverMap.add(""servername"", ""srv1"");
+         serverMap.add(""servername"", ""srv2"");
+
+         return serverMap;
+      }
+
+      @POST
+      public void post()
+      {
+
+      }
+   }
+
+   /**
+    * FIXME Comment this
+    *
+    * @throws Exception
+    */
+   @Before
+   public void setUp() throws Exception
+   {
+      addPerRequestResource(FormResource.class);
+      addPerRequestResource(MyFormResource.class);
+   }
+
+   /**
+    * RESTEASY-261
+    *
+    * @throws Exception
+    */
+   @Test
+   public void testMultiValueParam() throws Exception
+   {
+      ResteasyClient client = new ResteasyClient();
+      ResteasyWebTarget target = client.target(generateURL(""/myform/server""));
+      Response response = target.request().get();
+      int status = response.getStatus();
+      Assert.assertEquals(200, status);
+      boolean sv1 = false;
+      boolean sv2 = false;
+      MultivaluedMap<String, String> form = response.readEntity(new javax.ws.rs.core.GenericType<MultivaluedMap<String, String>>(){});
+      Assert.assertEquals(2, form.get(""servername"").size());
+      for (String str : form.get(""servername""))
+      {
+         if (str.equals(""srv1"")) sv1 = true;
+         else if (str.equals(""srv2"")) sv2 = true;
+      }
+      Assert.assertTrue(sv1);
+      Assert.assertTrue(sv2);
+   }
+
+   /**
+    * RESTEASY-691
+    *
+    * @throws Exception
+    */
+   @Test
+   public void testProxy691() throws Exception
+   {
+      ResteasyClient client = new ResteasyClient();
+      ResteasyWebTarget target = client.target(generateBaseUrl());
+      MyFormProxy proxy = target.proxy(MyFormProxy.class);
+      proxy.post(null);
+   }
+
+   @Test
+   public void testProxy() throws Exception
+   {
+      ResteasyClient client = new ResteasyClient();
+      ResteasyWebTarget target = client.target(generateBaseUrl());
+      FormClientProxy proxy = target.proxy(FormClientProxy.class);
+      ClientForm form = new ClientForm();
+      form.setBooleanValue(true);
+      form.setName(""This is My Name"");
+      form.setDoubleValue(123.45);
+      form.setLongValue(566780L);
+      form.setIntegerValue(3);
+      form.setShortValue((short) 12345);
+      form.setHeaderParam(42);
+      form.setQueryParam(42);
+      form.setId(42);
+      MultivaluedMap<String, String> rtn = proxy.post(form);
+      Assert.assertEquals(rtn.getFirst(BOOLEAN_VALUE_FIELD), ""true"");
+      Assert.assertEquals(rtn.getFirst(NAME_FIELD), ""This is My Name"");
+      Assert.assertEquals(rtn.getFirst(DOUBLE_VALUE_FIELD), ""123.45"");
+      Assert.assertEquals(rtn.getFirst(LONG_VALUE_FIELD), ""566780"");
+      Assert.assertEquals(rtn.getFirst(INTEGER_VALUE_FIELD), ""3"");
+      Assert.assertEquals(rtn.getFirst(SHORT_VALUE_FIELD), ""12345"");
+      String str = proxy.postString(form);
+      System.out.println(""STR: "" + str);
+      String[] params = str.split(""&"");
+      Map<String, String> map = new HashMap<String, String>();
+      for (int i = 0; i < params.length; i++)
+      {
+         int index = params[i].indexOf('=');
+         String key = params[i].substring(0, index).trim();
+         String value = params[i].substring(index + 1).trim().replace('+', ' ');
+         map.put(key, value);
+      }
+      Assert.assertEquals(map.get(BOOLEAN_VALUE_FIELD), ""true"");
+      Assert.assertEquals(map.get(NAME_FIELD), ""This is My Name"");
+      Assert.assertEquals(map.get(DOUBLE_VALUE_FIELD), ""123.45"");
+      Assert.assertEquals(map.get(LONG_VALUE_FIELD), ""566780"");
+      Assert.assertEquals(map.get(INTEGER_VALUE_FIELD), ""3"");
+      Assert.assertEquals(map.get(SHORT_VALUE_FIELD), ""12345"");
+   }
+
+   @Test
+   public void testFormResource() throws Exception
+   {      
+      InputStream in = null;
+      try
+      {
+         ResteasyClient client = new ResteasyClient();
+         ResteasyWebTarget target = client.target(TEST_URI);
+         Invocation.Builder request = target.request();
+         request.header(""custom-header"", ""42"");
+         Form form = new Form().param(BOOLEAN_VALUE_FIELD, ""true"")
+                               .param(NAME_FIELD, ""This is My Name"")
+                               .param(DOUBLE_VALUE_FIELD, ""123.45"")
+                               .param(LONG_VALUE_FIELD, ""566780"")
+                               .param(INTEGER_VALUE_FIELD, ""3"")
+                               .param(SHORT_VALUE_FIELD, ""12345"");
+         Response response = request.post(Entity.form(form));
+         Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatus());
+         String contentType = response.getHeaderString(""content-type"");
+         Assert.assertEquals(""application/x-www-form-urlencoded"", contentType);
+         InputStream responseStream = response.readEntity(InputStream.class);
+         in = new BufferedInputStream(responseStream);
+         String formData = readString(in);
+         String[] keys = formData.split(""&"");
+         Map<String, String> values = new HashMap<String, String>();
+         for (String pair : keys)
+         {
+            int index = pair.indexOf('=');
+            if (index < 0)
+            {
+               values.put(URLDecoder.decode(pair, ""UTF-8""), null);
+            }
+            else if (index > 0)
+            {
+               values.put(URLDecoder.decode(pair.substring(0, index), ""UTF-8""), URLDecoder.decode(pair
+                     .substring(index + 1), ""UTF-8""));
+            }
+         }
+         Assert.assertEquals(values.get(BOOLEAN_VALUE_FIELD), ""true"");
+         Assert.assertEquals(values.get(NAME_FIELD), ""This is My Name"");
+         Assert.assertEquals(values.get(DOUBLE_VALUE_FIELD), ""123.45"");
+         Assert.assertEquals(values.get(LONG_VALUE_FIELD), ""566780"");
+         Assert.assertEquals(values.get(INTEGER_VALUE_FIELD), ""3"");
+      }
+      finally
+      {
+         if (in != null)
+         {
+            in.close();
+         }
+      }
+   }
+}",2012-08-28T20:18:23Z,190
"@@ -6,6 +6,7 @@
 import org.jboss.resteasy.util.FindAnnotation;
 import org.jboss.resteasy.util.MediaTypeHelper;
 
+import javax.ws.rs.BeanParam;
 import javax.ws.rs.CookieParam;
 import javax.ws.rs.Encoded;
 import javax.ws.rs.FormParam;
@@ -104,6 +105,11 @@ else if ((/* form = */FindAnnotation.findAnnotation(annotations,
       {
          marshaller = new FormMarshaller(type, providerFactory);
       }
+      else if ((/* form = */FindAnnotation.findAnnotation(annotations,
+              BeanParam.class)) != null)
+      {
+         marshaller = new FormMarshaller(type, providerFactory);
+      }
       else if ((FindAnnotation.findAnnotation(annotations,
               Context.class)) != null)
       {",2012-08-28T20:18:23Z,61
"@@ -9,6 +9,7 @@
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.util.Types;
 
+import javax.ws.rs.BeanParam;
 import javax.ws.rs.CookieParam;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.Encoded;
@@ -122,6 +123,10 @@ else if ((form = findAnnotation(annotations, Form.class)) != null)
          }
          return new FormInjector(type, providerFactory);
       }
+      else if (findAnnotation(annotations, BeanParam.class) != null)
+      {
+         return new FormInjector(type, providerFactory);
+      }
       else if ((matrix = findAnnotation(annotations, MatrixParam.class)) != null)
       {
          return new MatrixParamInjector(type, genericType, injectTarget, matrix.value(), defaultVal, annotations, providerFactory);",2012-08-28T20:18:23Z,154
"@@ -10,9 +10,7 @@
       <sourceFolder url=""file://$MODULE_DIR$/target/generated-sources/test-annotations"" isTestSource=""true"" />
       <sourceFolder url=""file://$MODULE_DIR$/target/generated-sources/annotations"" isTestSource=""false"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/classes"" />
-      <excludeFolder url=""file://$MODULE_DIR$/target/javadoc-bundle-options"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/maven-archiver"" />
-      <excludeFolder url=""file://$MODULE_DIR$/target/site"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/surefire"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/surefire-reports"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/test-classes"" />",2011-09-07T21:12:09Z,191
"@@ -19,6 +19,7 @@
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
+import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -50,24 +51,34 @@ protected MockHttpRequest()
    {
    }
 
+   protected static final URI EMPTY_URI = URI.create("""");
+
    protected static MockHttpRequest initWithUri(String uri) throws URISyntaxException
    {
       URI absoluteUri = new URI(uri);
-      URI baseUri = absoluteUri;
+      //URI baseUri = absoluteUri;
+      URI baseUri = EMPTY_URI;
       return initWithUri(absoluteUri, baseUri);
    }
 
    private static MockHttpRequest initWithUri(URI absoluteUri, URI baseUri)
    {
+      if (baseUri == null) baseUri = EMPTY_URI;
       MockHttpRequest request = new MockHttpRequest();
       request.httpHeaders = new HttpHeadersImpl();
       request.httpHeaders.setAcceptableLanguages(new ArrayList<String>());
       request.httpHeaders.setAcceptableMediaTypes(new ArrayList<MediaType>());
       request.httpHeaders.setCookies(new HashMap<String, Cookie>());
       request.httpHeaders.setRequestHeaders(new Headers<String>());
       //request.uri = new UriInfoImpl(absoluteUri, absoluteUri, absoluteUri.getPath(), absoluteUri.getQuery(), PathSegmentImpl.parseSegments(absoluteUri.getPath()));
-      List<PathSegment> encodedPathSegments = PathSegmentImpl.parseSegments(absoluteUri.getRawPath(), false);
-      request.uri = new UriInfoImpl(absoluteUri, baseUri, absoluteUri.getRawPath(), absoluteUri.getRawQuery(), encodedPathSegments);
+      
+      // remove query part
+      URI absolutePath = UriBuilder.fromUri(absoluteUri).replaceQuery(null).build();
+      // path must be relative to the application's base uri
+	   URI relativeUri = baseUri.relativize(absoluteUri);
+		
+      List<PathSegment> encodedPathSegments = PathSegmentImpl.parseSegments(relativeUri.getRawPath(), false);
+      request.uri = new UriInfoImpl(absolutePath, baseUri, ""/"" + relativeUri.getRawPath(), absoluteUri.getRawQuery(), encodedPathSegments);
       request.preprocessedPath = request.uri.getPath(false);
       return request;
    }",2011-09-07T21:12:09Z,16
"@@ -6,6 +6,8 @@
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriInfo;
+import java.net.URI;
 import java.net.URISyntaxException;
 
 import static org.jboss.resteasy.spi.ResteasyProviderFactory.*;
@@ -134,16 +136,12 @@ private MultivaluedMap<String, String> getHeaders(HttpRequest request)
       return request.getHttpHeaders().getRequestHeaders();
    }
 
-   public static MockHttpRequest createRequest(String uri, String verb)
+   public static MockHttpRequest createRequest(String relativeUri, String verb)
    {
-      try
-      {
-         return MockHttpRequest.create(verb, uri);
-      }
-      catch (URISyntaxException e)
-      {
-         throw new RuntimeException(
-                 ""could not create uri for internal dispatching"", e);
-      }
+      UriInfo uriInfo = ResteasyProviderFactory.getContextData(UriInfo.class);
+
+      URI baseUri = uriInfo.getBaseUri();
+      URI absoluteUri = baseUri.resolve(relativeUri);
+      return MockHttpRequest.create(verb, absoluteUri, baseUri);
    }
 }",2011-09-07T21:12:09Z,19
"@@ -10,6 +10,7 @@
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.test.EmbeddedContainer;
 import org.junit.AfterClass;
+import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -25,6 +26,9 @@
 import javax.ws.rs.QueryParam;
 import javax.ws.rs.core.Context;
 import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriInfo;
+
+import java.util.Stack;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
 
@@ -39,6 +43,7 @@ public class InternalDispatcherTest
 {
 
    private static Dispatcher dispatcher;
+   private static ForwardingResource forwardingResource;
 
    @Path(""/"")
    public interface Client
@@ -94,13 +99,17 @@ public interface Client
    @Path(""/"")
    public static class ForwardingResource
    {
+      public Stack<String> uriStack = new Stack<String>();
       String basic = ""basic"";
+      @Context
+      UriInfo uriInfo;
 
       @GET
       @Produces(""text/plain"")
       @Path(""/basic"")
       public String getBasic()
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          return basic;
       }
 
@@ -109,6 +118,7 @@ public String getBasic()
       @Path(""/forward/basic"")
       public String forwardBasic(@Context InternalDispatcher dispatcher)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          return (String) dispatcher.getEntity(""/basic"");
       }
 
@@ -118,13 +128,15 @@ public String forwardBasic(@Context InternalDispatcher dispatcher)
       @Path(""/basic"")
       public void putBasic(String basic)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          this.basic = basic;
       }
 
       @DELETE
       @Path(""/basic"")
       public void deleteBasic()
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          this.basic = ""basic"";
       }
 
@@ -134,6 +146,7 @@ public void deleteBasic()
       public void putForwardBasic(String basic,
                                   @Context InternalDispatcher dispatcher)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          dispatcher.putEntity(""/basic"", basic);
       }
 
@@ -143,13 +156,15 @@ public void putForwardBasic(String basic,
       public void postForwardBasic(String basic,
                                    @Context InternalDispatcher dispatcher)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          dispatcher.postEntity(""/basic"", basic);
       }
 
       @DELETE
       @Path(""/forward/basic"")
       public void deleteForwardBasic(@Context InternalDispatcher dispatcher)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          dispatcher.delete(""/basic"");
       }
 
@@ -158,6 +173,7 @@ public void deleteForwardBasic(@Context InternalDispatcher dispatcher)
       @Path(""/object/{id}"")
       public Response getObject(@PathParam(""id"") Integer id)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          if (id == 0)
             return Response.noContent().build();
          else
@@ -169,6 +185,7 @@ public Response getObject(@PathParam(""id"") Integer id)
       public Response forwardObject(@PathParam(""id"") Integer id,
                                     @Context InternalDispatcher dispatcher)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          return dispatcher.getResponse(""/object/"" + id);
       }
 
@@ -177,6 +194,7 @@ public Response forwardObject(@PathParam(""id"") Integer id,
       public int infinitFoward(@Context InternalDispatcher dispatcher,
                                @QueryParam(""count"") @DefaultValue(""0"") int count)
       {
+         uriStack.push(uriInfo.getAbsolutePath().toString());
          try
          {
             dispatcher.getEntity(""/infinite-forward?count="" + (count + 1));
@@ -203,7 +221,13 @@ public int infinitFoward(@Context InternalDispatcher dispatcher,
    public static void before() throws Exception
    {
       dispatcher = EmbeddedContainer.start().getDispatcher();
-      dispatcher.getRegistry().addSingletonResource(new ForwardingResource());
+            forwardingResource = new ForwardingResource();
+            dispatcher.getRegistry().addSingletonResource(forwardingResource);
+   }
+
+@Before
+   public void setup() {
+       forwardingResource.uriStack.clear();
    }
 
    @AfterClass
@@ -245,4 +269,26 @@ public void testInfinitForward()
       Assert.assertEquals(1, client.infiniteForward());
    }
 
+      @Test
+   public void testUriInfoBasic() {
+       String baseUrl = generateBaseUrl();
+       Client client = ProxyFactory.create(Client.class, baseUrl);
+
+       client.getBasic();
+       Assert.assertEquals(baseUrl + ""/basic"", forwardingResource.uriStack.pop());
+       Assert.assertTrue(forwardingResource.uriStack.isEmpty());
+
+   }
+
+   @Test
+   public void testUriInfoForwardBasic() {
+      String baseUrl = generateBaseUrl();
+       Client client = ProxyFactory.create(Client.class, baseUrl);
+
+       client.getForwardBasic();
+       Assert.assertEquals(baseUrl + ""/basic"", forwardingResource.uriStack.pop());
+       Assert.assertEquals(baseUrl + ""/forward/basic"", forwardingResource.uriStack.pop());
+       Assert.assertTrue(forwardingResource.uriStack.isEmpty());
+   }
+
 }
\ No newline at end of file",2011-09-07T21:12:09Z,192
"@@ -7,9 +7,7 @@
       <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" />
       <sourceFolder url=""file://$MODULE_DIR$/target/generated-sources/annotations"" isTestSource=""false"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/classes"" />
-      <excludeFolder url=""file://$MODULE_DIR$/target/javadoc-bundle-options"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/maven-archiver"" />
-      <excludeFolder url=""file://$MODULE_DIR$/target/site"" />
       <excludeFolder url=""file://$MODULE_DIR$/target/surefire"" />
     </content>
     <orderEntry type=""inheritedJdk"" />",2011-09-07T21:12:09Z,193
"@@ -0,0 +1,131 @@
+package org.jboss.resteasy.plugins.guice;
+
+import com.google.inject.Binder;
+import com.google.inject.Module;
+import org.jboss.resteasy.client.ProxyFactory;
+import org.jboss.resteasy.core.Dispatcher;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import static org.jboss.resteasy.test.TestPortProvider.generateBaseUrl;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.UriInfo;
+
+public class GuiceContextTest
+{
+   private static Dispatcher dispatcher;
+
+   @BeforeClass
+   public static void beforeClass() throws Exception
+   {
+      dispatcher = EmbeddedContainer.start();
+   }
+
+   @AfterClass
+   public static void afterClass() throws Exception
+   {
+      EmbeddedContainer.stop();
+   }
+
+   @Test
+   public void testMethodInjection() {
+      final Module module = new Module()
+      {
+         public void configure(final Binder binder)
+         {
+            binder.bind(MethodTestResource.class);
+         }
+      };
+      final ModuleProcessor processor = new ModuleProcessor(dispatcher.getRegistry(), dispatcher.getProviderFactory());
+      processor.process(module);
+      final TestResource resource = ProxyFactory.create(TestResource.class, generateBaseUrl());
+      Assert.assertEquals(""method"", resource.getName());
+      dispatcher.getRegistry().removeRegistrations(MethodTestResource.class);
+   }
+
+   //@Test // not (yet) supprted
+   public void testFieldInjection() {
+      final Module module = new Module()
+      {
+         public void configure(final Binder binder)
+         {
+            binder.bind(FieldTestResource.class);
+         }
+      };
+      final ModuleProcessor processor = new ModuleProcessor(dispatcher.getRegistry(), dispatcher.getProviderFactory());
+      processor.process(module);
+      final TestResource resource = ProxyFactory.create(TestResource.class, generateBaseUrl());
+      Assert.assertEquals(""field"", resource.getName());
+      dispatcher.getRegistry().removeRegistrations(FieldTestResource.class);
+   }
+
+   //@Test // not (yet) supprted
+   public void testConstructorInjection() {
+      final Module module = new Module()
+      {
+         public void configure(final Binder binder)
+         {
+            binder.bind(ConstructorTestResource.class);
+         }
+      };
+      final ModuleProcessor processor = new ModuleProcessor(dispatcher.getRegistry(), dispatcher.getProviderFactory());
+      processor.process(module);
+      final TestResource resource = ProxyFactory.create(TestResource.class, generateBaseUrl());
+      Assert.assertEquals(""constructor"", resource.getName());
+      dispatcher.getRegistry().removeRegistrations(ConstructorTestResource.class);
+   }
+
+   @Path(""test"")
+   public interface TestResource
+   {
+      @GET
+      public String getName();
+   }
+
+   @Path(""test"")
+   public static class MethodTestResource
+   {
+      @GET
+      public String getName(final @Context UriInfo uriInfo)
+      {
+         Assert.assertNotNull(uriInfo);
+         return ""method"";
+      }
+   }
+
+   @Path(""test"")
+   public static class FieldTestResource
+   {
+      private @Context UriInfo uriInfo;
+
+      @GET
+      public String getName()
+      {
+         Assert.assertNotNull(uriInfo);
+         return ""field"";
+      }
+   }
+
+   @Path(""test"")
+   public static class ConstructorTestResource
+   {
+      private final UriInfo uriInfo;
+
+      public ConstructorTestResource(@Context final UriInfo uriInfo)
+      {
+         this.uriInfo = uriInfo;
+      }
+
+      @GET
+      public String getName()
+      {
+         Assert.assertNotNull(uriInfo);
+         return ""field"";
+      }
+   }
+}
\ No newline at end of file",2009-05-21T17:28:50Z,194
"@@ -70,7 +70,7 @@ public JAXBContext getJAXBContext(Class<?>... classes)
          }
          contextCache.putIfAbsent(classes, context);
       }
-      logger.debug(""Locating JAXBContext for package: {}"", classes);
+      logger.debug(""Locating JAXBContext for package: {0}"", classes);
       return context;
    }
 
@@ -83,7 +83,7 @@ public JAXBContext getJAXBContext(Class<?>... classes)
    public JAXBContext getJAXBContext(String... packageNames)
    {
       String contextPath = buildContextPath(packageNames);
-      logger.debug(""Locating JAXBContext for packages: {}"", contextPath);
+      logger.debug(""Locating JAXBContext for packages: {0}"", contextPath);
       // FIXME This was the original call causing an infinitive recursive loop.
       // However I don't know how to fix it, but this method is not used currently
       // so instead of fixing it modified it to return a null and not going into",2010-11-02T17:01:06Z,8
"@@ -166,7 +166,7 @@ public String putData(MimeMultipart multipart)
             {
                logger.debug(multipart.getBodyPart(i).getContent()
                        .toString());
-               logger.debug(""bytes available {}"", multipart.getBodyPart(i)
+               logger.debug(""bytes available {0}"", multipart.getBodyPart(i)
                        .getInputStream().available());
             }
             catch (IOException e)",2010-11-02T17:01:06Z,195
"@@ -70,7 +70,7 @@ public JAXBContext getJAXBContext(Class<?>... classes)
          }
          contextCache.putIfAbsent(classes, context);
       }
-      logger.debug(""Locating JAXBContext for package: {}"", classes);
+      logger.debug(""Locating JAXBContext for package: {0}"", classes);
       return context;
    }
 
@@ -83,7 +83,7 @@ public JAXBContext getJAXBContext(Class<?>... classes)
    public JAXBContext getJAXBContext(String... packageNames)
    {
       String contextPath = buildContextPath(packageNames);
-      logger.debug(""Locating JAXBContext for packages: {}"", contextPath);
+      logger.debug(""Locating JAXBContext for packages: {0}"", contextPath);
       // FIXME This was the original call causing an infinitive recursive loop.
       // However I don't know how to fix it, but this method is not used currently
       // so instead of fixing it modified it to return a null and not going into",2010-11-02T17:01:06Z,8
"@@ -60,12 +60,12 @@ public Object readFrom(Class<Object> type, Type genericType, Annotation[] annota
       }
       catch (YamlException ye)
       {
-         logger.debug(""Failed to decode Yaml: {}"", ye.getMessage());
+         logger.debug(""Failed to decode Yaml: {0}"", ye.getMessage());
          throw new ReaderException(""Failed to decode Yaml"", ye);
       }
       catch (Exception e)
       {
-         logger.debug(""Failed to decode Yaml: {}"", e.getMessage());
+         logger.debug(""Failed to decode Yaml: {0}"", e.getMessage());
          throw new ReaderException(""Failed to decode Yaml"", e);
       }
 
@@ -112,7 +112,7 @@ public void writeTo(Object t, Class<?> type, Type genericType, Annotation[] anno
       catch (Exception e)
       {
 
-         logger.debug(""Failed to encode yaml for object: {}"", t.toString());
+         logger.debug(""Failed to encode yaml for object: {0}"", t.toString());
          throw new WriterException(e);
 
       }",2010-11-02T17:01:06Z,196
"@@ -65,7 +65,7 @@ private List<Module> getModules(final ServletContext context)
          {
             try
             {
-               logger.info(""found module: {}"", moduleString);
+               logger.info(""found module: {0}"", moduleString);
                final Class clazz = Thread.currentThread().getContextClassLoader().loadClass(moduleString.trim());
                final Module module = (Module) clazz.newInstance();
                result.add(module);",2010-11-02T17:01:06Z,64
"@@ -62,12 +62,12 @@ private void processInjector(final Injector injector)
             if (GetRestful.isRootResource(beanClass))
             {
                final ResourceFactory resourceFactory = new GuiceResourceFactory(binding.getProvider(), beanClass);
-               logger.info(""registering factory for {}"", beanClass);
+               logger.info(""registering factory for {0}"", beanClass.getName());
                registry.addResourceFactory(resourceFactory);
             }
             if (beanClass.isAnnotationPresent(Provider.class))
             {
-               logger.info(""registering provider instance for {}"", beanClass);
+               logger.info(""registering provider instance for {0}"", beanClass.getName());
                providerFactory.registerProviderInstance(binding.getProvider().get());
             }
          }",2010-11-02T17:01:06Z,197
"@@ -173,7 +173,7 @@ private void warnIfJaxRSAnnotatedFields(Object obj)
 
             if (annotations.length != 0)
             {
-               logger.warn(""Field '{}' of subresource '{}' will not be injected "" +
+               logger.warn(""Field {0} of subresource {1} will not be injected "" +
                        ""according to spec"", field.getName(), obj.getClass().getName());
             }
 ",2010-11-02T17:01:06Z,40
"@@ -80,7 +80,7 @@ public static <T> T getType(final Class<T> targetType, final String source)
       }
       catch (NoSuchMethodException e)
       {
-         logger.warn(""No valueOf() method available for {}, trying constructor..."", targetType
+         logger.warn(""No valueOf() method available for {0}, trying constructor..."", targetType
                  .getSimpleName());
          result = getTypeViaStringConstructor(source, targetType);
       }",2010-11-02T17:01:06Z,198
"@@ -27,7 +27,8 @@
     </build>
 
     <modules>
+        <module>managedbean-test</module>
+        <module>ejb-stateless-test</module>
         <module>application-test</module>
-        <module>null-test</module>
     </modules>
 </project>",2013-10-25T19:21:04Z,199
"@@ -7,6 +7,7 @@
 import org.junit.Test;
 
 import javax.ws.rs.Consumes;
+import javax.ws.rs.GET;
 import javax.ws.rs.POST;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -38,6 +39,13 @@ public int postInt(int val) {
       public boolean postInt(boolean val) {
          return val;
       }
+
+      @GET
+      @Path(""nothing"")
+      public Response nothing()
+      {
+         return Response.ok().build();
+      }
    }
 
 
@@ -77,6 +85,14 @@ public void testBoolean()
       response.close();
    }
 
+   @Test
+   public void testNothing()
+   {
+      Response response = client.target(generateURL(""/nothing"")).request().get();
+      String str = response.readEntity(String.class);
+
+   }
+
 
 
 ",2013-10-25T19:21:04Z,200
"@@ -1343,7 +1343,7 @@ public void registerProvider(Class provider, Integer priorityOverride, boolean i
    {
       if (getClasses().contains(provider))
       {
-         logger.warn(""Provider class "" + provider.getName() + "" is already registered.  2nd registration is being ignored."");
+         //logger.warn(""Provider class "" + provider.getName() + "" is already registered.  2nd registration is being ignored."");
          return;
       }
       Map<Class<?>, Integer> newContracts = new HashMap<Class<?>, Integer>();",2013-10-25T19:21:04Z,25
"@@ -678,6 +678,10 @@ public static ResourceClassBuilder locator(Class<?> root)
    public static ResourceConstructor constructor(Class<?> annotatedResourceClass)
    {
       Constructor constructor = PickConstructor.pickPerRequestConstructor(annotatedResourceClass);
+      if (constructor == null)
+      {
+         throw new RuntimeException(""Could not find constructor for class: "" + annotatedResourceClass.getName());
+      }
       ResourceConstructorBuilder builder = rootResource(annotatedResourceClass).constructor(constructor);
       if (constructor.getParameterTypes() != null)
       {",2013-10-25T19:21:04Z,201
"@@ -1,5 +1,7 @@
 package org.jboss.resteasy.plugins.servlet;
 
+import org.jboss.resteasy.core.AsynchronousDispatcher;
+import org.jboss.resteasy.logging.Logger;
 import org.jboss.resteasy.plugins.server.servlet.HttpServlet30Dispatcher;
 import org.jboss.resteasy.plugins.server.servlet.ResteasyContextParameters;
 import org.jboss.resteasy.spi.NotImplementedYetException;
@@ -23,6 +25,15 @@
 @HandlesTypes({Application.class, Path.class, Provider.class})
 public class ResteasyServletInitializer implements ServletContainerInitializer
 {
+   final static Logger logger = Logger.getLogger(ResteasyServletInitializer.class);
+
+   final static Set<String> ignoredPackages = new HashSet<String>();
+
+   static
+   {
+      ignoredPackages.add(AsynchronousDispatcher.class.getPackage().getName());
+   }
+
    @Override
    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException
    {
@@ -41,6 +52,7 @@ public void onStartup(Set<Class<?>> classes, ServletContext servletContext) thro
 
       for (Class<?> clazz : classes)
       {
+         if (ignoredPackages.contains(clazz.getPackage().getName())) continue;
          if (clazz.isAnnotationPresent(Path.class))
          {
             resources.add(clazz);
@@ -125,6 +137,7 @@ protected void register(Class<?> applicationClass, Set<Class<?>> providers, Set<
             {
                builder.append("","");
             }
+
             builder.append(resource.getName());
          }
          reg.setInitParameter(ResteasyContextParameters.RESTEASY_SCANNED_RESOURCES, builder.toString());",2013-10-25T19:21:04Z,202
"@@ -1,29 +1,29 @@
 Content-Type: application/pkcs7-mime;name=smime.p7m;smime-type=enveloped-data
-MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUHs
-VKqrMA0GCSqGSIb3DQEBAQUABIIBAAo6FqXO1KBgNZ+0vRSTOpzSHAxWMo3blBZPzUnLEUELCEJ2
-d3OsrWJzkbdTSh2ujNfoQ69tfO6DPdEJVxMCbDnxXIehjmdEez0cUQbFf3fIkruFAFCLD/r86Tre
-NezXMoDueJG4kb+GxCJ35CT6fEdpc0s5PfVxHeTNwf5iz55t6n8bTO7OKeGRQgTP1cbAa9M6nyJA
-tSHbX2IDA3+7OCD/jF68id7wtyZIb7pkccaeR2LhhBXqaQO2ZRuKrW5zU5BgQTKgrsEDrr0kYgte
-ROKvVujPIQlOG/a3dNBjbOMLcXv/QBQeuzz1aCHhvsQNcr4VZqgmf8aYQT+QlBPn+oEwgAYJKoZI
-hvcNAQcBMBQGCCqGSIb3DQMHBAjGxJV0rO55raCABIID6DkdAlzaIrGRiegfbzJh8ZukwbWRZUnm
-vtmkB8H5jOoAfokKAxtN5f56J9VAGHpVO5vwEw/Xn2yTqKvL5P4bD3AKUyLH3LAUXbELTi/kI5DH
-x+3jBcxTZDvP+qm9NfE+H2+UYVBofjpfdPnKP4Fa9YX+egayfCzbMZ60VTwDdbWgvfcme8O3N1nm
-BdF651XxgJ30OIwDdaiPL+DnMdWfFs1TH8QRT3AJ4X9/koua9+8Az8Sf6NrVXFk59rUZH1hxCY6H
-u2a6xo7AJiUuk+k5b9/3u9fihZM/Gpiv3ZQAXpAPN6uwxtlOs2gd1IzqS54S2atNNN8Rv9MzpKFa
-cv1fNbAX+Qpm+xhl8m1/U4isGwBB77hj5bHUiiVFrvL3ATDiaefCyOk4hZk/cHHg3rNqH8fmP/7u
-Nsju6zEPbLLCHmetIUg34SwebK5PUM7ZDrR4SUjsusyL3lzIwgLpSkQgb9otVNMiaG8WavZjmvVD
-RhSybgYdJXAyqjuZ4qyqpcl5u9rmbqZ+I8h8N6hG46QTTvanoNUa+gXo0w5BRJ/MpqFCoeP3m86X
-1ANHYyLnC4s2tr1Lm6D05Sx9K0suMnPBRykMxsiLPF3J6Q18cBgEEfgwqFcjBdmsMsa+7zLETv67
-SPzTazR2mrRV1RFHIltfXsrwHsqEcOaNmpZNv8OKaWzsz30JcqltPUr54VexaPaLcxtsOOn/PEYW
-yqVpZWQRnhPfU62qpD/wAx3feQ55Py03UZ8g0aT03Vs8q9R44Ocv3/mqZ/IX9pgRoU3c6KUm0adP
-7TGrN5Chhv6kKm5rcoH9jo7dgz4iNGgDBcqB+CKC3eGWeFXk6s8vnxrHkUI0pbXALkG8dSVu7LBJ
-POyqCtA/7UvNddJS1/qFpv5lxavXpPsAwWu5Z8CUgfPjiiqai1EUEeP7l6fXHuCaT8GQM3Z/bbsI
-jxExpreTSO0HC0zhiK+CUCgoSHGKZ4VOwgjxP8xqhjIZJXBJBT6NstnlZU7HmbanfQ5LFxFgRQp/
-/fvRQPrqvJXo3lnF75h1TxlTbomYoEgmffsfOj/h5lJhtqEXHDfyjMI6mJkhqt3wCL6mF9FlBYMf
-kUHMrFffilp2FJ4mHqNVDeOBPeBPh+MPuRI/LwsupV+gUzXlqschDGtdQoR5CxqftjWqi/4lJ3/e
-9T+ZFj/SGHtnKxmlcStvGL7ZNg246Lj2KIg6DBaBK51mMmLV4Hb7oi3weiR4UnLKJLCfNKsSPjd2
-s6SRZVuJ1s50bQGrzcLb3bnJniG9EVTwaEAiq/hx+E03kDbKC2AjNRVxrGUe39RASi4oWKhgim8u
-sjE02GK6u5AEgcBL8v66k0NaP1nDD0XeqWCQprWwfsIYAtsQQE7Y0zFd9U4O+z6F88JcardiAtK6
-XwZJtFmEgL3L1Lp7FehkdTEoErK7m4FCrIXd2gmqK+7jPCUOHbaNKB4BZa9XfPEgYnZxT/xVGDw2
-Kns3Ft2zNEOVXy0lN2Ni6QyFLmeC4OC8UkRZUH0eL4/7iOlNoWNyofaxoJBLEUwL1BPeNB7npct4
-AytvviZpI5GsGaK/tZM755QZ3ecwvGtwLuY9ppWrrOoAAAAAAAAAAAAA
\ No newline at end of file
+MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUHx
+CSWfMA0GCSqGSIb3DQEBAQUABIIBAGULwR2mxj9FVcvtZa3uY6uk6cuhcA4dKyVZiIXvWeuO1pAa
+4SOXAp02BhPqoVd7XN8IM1XtgKh8sxkOWGbDxX6rHra+W3L4mya7BXvH65VJqzLLWRGPZC3rWySv
+Eiv+RrYi8p08KIZinpJhghyyholxhE/hyrBbdmApypuiFusB0KzuLpVEsRVHNeDw+USMpk6IvXHJ
+lME5e0NsoPb7zhatZ2J76l1EHdEo0pgYczPRZ6gdPQEhk3wNIqw9UmYYxYXsSuaHcsti7l2PoEji
+NQ/ZuxwWoVwH1aGkM+03Ho2Dbf6XbKzZVxt5UlIXLJnaMoFyoJBvZeMJ5k5UK+mxfQ4wgAYJKoZI
+hvcNAQcBMBQGCCqGSIb3DQMHBAgAVXRo+M+29KCABIID6Fh8SV+G34fLAMYxM9XTBd54iw4llXmA
+UI5sl1GtVyWbaRz/k/IA8bL7jeLnI95pDwSb4FVAk5fejZ+7pFaiZhCW0oXnh7klOe/6LR/bH6y5
+oxU3kqlnJOklh3vR19p0yJPIaJJFtoLdJWmOx2uZPI0o/BZGVb9Qx1vyGTq9uxFSTWArY6pLwH+4
+EOZS1XFGQ8V9PZN4Ajjwcb3thkdbPh75a2kNsLQfBcsxWpArr/OvrJc1enc3Fuo4I5QuADS6nk8z
+UQlTQ6qXxGzwx3ZZ3eEmV5VH8bl7WqJSPeSooTn9O+Nl+pz+qxyTaVJeXBQsnUv6STHygmb3cluR
+CI75NWZxfHjhRxAvr6iA/SN5mhTXeVfsbnNKr9rPBLobudrHBObcKjZvpmZ42kLQ8YtjaEejG68M
+YTrcjLcg6CTTs4LfWGFTG1vRmWklyY4f8mADmds+cUscjglIzoCOI6ZQ0oSpjKVLHLgtJDS6teJV
+Dxxz4Uojm6csN/7ZmomMBiBYkjVzQ5A5spJGOqVqXsQ2ik7mhawvogi9KFV7cNGVIdjJkHnmeO7y
+Vuh46XD8/XjPOOL/vxllvjl5Xdi5mgcEXtOX2HfC11LVeHRkrwAStATjRuHPn6QDrroq6bh3Wmlk
+hXj+c/RuSnQn/1heFUWsDfBp6ctWVX2afFsJnTvyH/vjC/9o0Ru6K5SNiW+ZL8JFKXQCLSRHxQjL
+/ryUiQVSj67Nbu8NVM5PfhVfWXn1XyBwFMJUka1wO1IcgXEUmoRF4N/9PjwYl7G6TLeJBe2sFbUN
+Xb4vV/Zamg0Pvh/sAxr+YT81FjZU1pjOa+Gd5S87dNvTB46wKMNP9Jp95uUZmNQ2CWgnWJ/M4b/h
+MGlWrU2ItkTWP5Xyh87/5GbNSRVWYMs/dDt2Rd3riKOzHX1W2qK9LancNo/TbqeDuGMuSwzd43yF
+NLlm6/25QdDdmNzJH6U065HUIrb7ashPyk3H9kCJLAppHTKXbwFKKK2IK6smg6Q4EegKKk2yKTPV
+bRvMzei2cwIdpGqkGT1iT3a0owxkm+sL0WxAsiopb3o1JBAfABMelDf+uPi8AtmDseE9dcrDb4Gt
+3E4QX4ulb/QI9yuiVyHCURDreKzJ/OOPg1wL+uixFvgSwSL2rtV9NE6n9yyBpPwEXFJ1VG0Jif/A
+FHu69llmupHFKB0xTCHUSfxGUiGZndFdQZRrrN2d0m76yGjvPmlShUHGd+bavznfDlpTpP3RfINB
+IbBBLWCyaN+U0s+wSK1KOLMOw0EWLFkn7s9sAugqVSyjfDY4cqDSLN9ba58frhLxNulmE6GwPL2c
+24+4AAChanoEgcB4YStoAOpZzbP/o3bs9qHY0c4+C21pBHcg7DxCIFTVRCrJRV4EwC2QeRBF5C0F
+lqrQB2EIJIcF6xmldt2dmVsNLQGl8jm0KkSLF4z4Ep4Z7k5v+Z4gUNLBVFE3G2UQe33Lom7d/PoI
+oEFwoZAGmPjWyrNOYosBBX8Rl3X+TusR7EsIeTMuRoBGhXGP/ZEeEJe01LbQycwpYYreTm1pnMuy
+uBi4IVhnwTbvoFzSUoVbFDQRDqBU4iySHoCohSCB/IIAAAAAAAAAAAAA
\ No newline at end of file",2013-10-25T19:21:04Z,165
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_15_1201909170.1382649474042""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_15_2061720876.1382728410813""
 
-------=_Part_15_1201909170.1382649474042
+------=_Part_15_2061720876.1382728410813
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_15_1201909170.1382649474042
+------=_Part_15_2061720876.1382728410813
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDIxMTc1NFowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAihqyn8uEarrgNlIOyTAQcirb
-7prKz2rD6SlS6KDnMEM4OyPrr5FOu+AXlpscPtQ1byC3YMy87RyOvly4I2e5nNQh+ZF8lws26E0n
-EbmYNfCUsoSfSN6C6rsoJrYJ1IAbW7B46ojf4k73oLj73i0GDilgGGYIXD9p/bJKXiaUzwwAAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNTE5MTMzMFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAtWgV5uNufo5d7kC/4d7G1uH2
+6yMSGk/ZJOAJBsUW/t7q1XZBGMiuI1E5PXfkQdlC16FtZ7fIGP2mT51nGnZnwUsJWDfD49GS72S/
+mSRq9asOQpSuUbSOx9yHzejT8f2meD4zL5GQPxsGc0tpNAkog9LfOmnfigSVmw8fw+2IvmMAAAAA
 AAA=
-------=_Part_15_1201909170.1382649474042--
+------=_Part_15_2061720876.1382728410813--",2013-10-25T19:21:04Z,166
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_17_1655256299.1382649474048""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_17_1712899783.1382728410819""
 
-------=_Part_17_1655256299.1382649474048
+------=_Part_17_1712899783.1382728410819
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_17_1655256299.1382649474048
+------=_Part_17_1712899783.1382728410819
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNDIxMTc1NFowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAkDkEh1XW3BYjmfOJhtOwwwVX
-ypBrcu45YedRBjFUcR75qRATMkn10VsHFuCIiMZdTS2zBx5f9OlnSNCuamDap7P/lhZGLshksLYg
-iZMsYWElXUlJ542mA88ZjNO0JRw16UZ0pM7Bx+iUPnmpp8sbxhL/lWM1NNu5fz/TmHHLYzAAAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMTAyNTE5MTMzMFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAyRq2tZsweEWXFDO8lFwWMgOd
+fEXwuNWNdKnrn8TlWBYJeghWamu0IFnKuW12fxO6E1FhRIGnziP8hFvrjITifLcjVB0327i7D1tk
+IpMweoAvj/MMqly0sZaaD5vt6Qt48oCJBtNr03eoEenT2rv+OWQrzKZ5VyaTcatbJW5FI5IAAAAA
 AAA=
-------=_Part_17_1655256299.1382649474048--
+------=_Part_17_1712899783.1382728410819--",2013-10-25T19:21:04Z,167
"@@ -1,4 +1,5 @@
-<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
     <modelVersion>4.0.0</modelVersion>
 
     <name>RESTEasy JAX-RS</name>
@@ -23,7 +24,8 @@
 
     <scm>
         <connection>scm:svn:https://resteasy.svn.sourceforge.net/svnroot/resteasy/trunk/jaxrs</connection>
-        <developerConnection>scm:svn:https://resteasy.svn.sourceforge.net/svnroot/resteasy/trunk/jaxrs</developerConnection>
+        <developerConnection>scm:svn:https://resteasy.svn.sourceforge.net/svnroot/resteasy/trunk/jaxrs
+        </developerConnection>
         <url>http://resteasy.svn.sourceforge.net/viewvc/resteasy/trunk/jaxrs</url>
     </scm>
 
@@ -75,6 +77,7 @@
         <module>resteasy-jaxrs-war</module>
         <module>async-http-jbossweb</module>
         <module>async-http-servlet-3.0</module>
+        <module>resteasy-cache</module>
         <module>async-http-tomcat</module>
         <!--module>examples</module-->
     </modules>
@@ -306,7 +309,7 @@
                 <plugin>
                     <groupId>org.codehaus.mojo</groupId>
                     <artifactId>cobertura-maven-plugin</artifactId>
-                    <configuration />
+                    <configuration/>
                     <executions>
                         <execution>
                             <goals>",2009-03-09T22:15:43Z,117
"@@ -0,0 +1,19 @@
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <parent>
+        <groupId>org.jboss.resteasy</groupId>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <version>1.1-RC1</version>
+    </parent>
+    <name>RESTEasy Cache</name>
+    <url>http://www.attainware.com/</url>
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.jboss.resteasy</groupId>
+    <artifactId>resteasy-cache-pom</artifactId>
+    <packaging>pom</packaging>
+
+    <modules>
+        <module>resteasy-cache-core</module>
+    </modules>
+</project>",2009-03-09T22:15:43Z,203
"@@ -0,0 +1,50 @@
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.jboss.resteasy</groupId>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <version>1.1-RC1</version>
+    </parent>
+    <groupId>org.jboss.resteasy</groupId>
+    <artifactId>resteasy-cache-core</artifactId>
+    <packaging>jar</packaging>
+    <name>RESTEasy Cache Core</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.cache</groupId>
+            <artifactId>jbosscache-core</artifactId>
+            <version>3.0.3.GA</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>jaxrs-api</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.5</source>
+                    <target>1.5</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>",2009-03-09T22:15:43Z,204
"@@ -0,0 +1,184 @@
+package org.jboss.resteasy.plugins.cache.server;
+
+
+import org.jboss.cache.Cache;
+import org.jboss.cache.CacheFactory;
+import org.jboss.cache.DefaultCacheFactory;
+import org.jboss.cache.Fqn;
+import org.jboss.cache.Node;
+import org.jboss.cache.RegionManagerImpl;
+import org.jboss.cache.config.Configuration;
+import org.jboss.cache.config.EvictionConfig;
+import org.jboss.cache.config.EvictionRegionConfig;
+import org.jboss.cache.eviction.ExpirationAlgorithmConfig;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+import javax.ws.rs.core.CacheControl;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+
+/**
+ * An HTTP cache that behaves somewhat the same way as a proxy (like Squid)
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class JBossCache implements ServerCache
+{
+
+   public static class CacheEntry implements Entry
+   {
+      private final byte[] cached;
+      private final int expires;
+      private final long timestamp = System.currentTimeMillis();
+      private final MultivaluedMap<String, Object> headers;
+      private String etag;
+      private MediaType mediaType;
+
+      private CacheEntry(MultivaluedMap<String, Object> headers, byte[] cached, int expires, String etag, MediaType mediaType)
+      {
+         this.cached = cached;
+         this.expires = expires;
+         this.headers = headers;
+         this.etag = etag;
+         this.mediaType = mediaType;
+      }
+
+      public int getExpirationInSeconds()
+      {
+         return expires - (int) ((System.currentTimeMillis() - timestamp) / 1000);
+      }
+
+      public boolean isExpired()
+      {
+         return System.currentTimeMillis() - timestamp >= expires * 1000;
+      }
+
+      public String getEtag()
+      {
+         return etag;
+      }
+
+      public MultivaluedMap<String, Object> getHeaders()
+      {
+         return headers;
+      }
+
+      public byte[] getCached()
+      {
+         return cached;
+      }
+
+      public MediaType getMediaType()
+      {
+         return mediaType;
+      }
+   }
+
+   protected int maxSize = 100;
+   protected long wakeupInterval = 5000;
+   protected Cache cache;
+   protected ResteasyProviderFactory providerFactory;
+
+   public int getMaxSize()
+   {
+      return maxSize;
+   }
+
+   public void setMaxSize(int maxSize)
+   {
+      this.maxSize = maxSize;
+   }
+
+   public long getWakeupInterval()
+   {
+      return wakeupInterval;
+   }
+
+   public void setWakeupInterval(long wakeupInterval)
+   {
+      this.wakeupInterval = wakeupInterval;
+   }
+
+   public ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
+   public void setProviderFactory(ResteasyProviderFactory providerFactory)
+   {
+      this.providerFactory = providerFactory;
+   }
+
+   public void start()
+   {
+      CacheFactory factory = new DefaultCacheFactory();
+      ExpirationAlgorithmConfig exp = new ExpirationAlgorithmConfig();
+      exp.setMaxNodes(maxSize);
+
+      EvictionRegionConfig evictionRegionConfig = new EvictionRegionConfig(RegionManagerImpl.DEFAULT_REGION);
+      evictionRegionConfig.setEvictionAlgorithmConfig(exp);
+
+      EvictionConfig evictConfig = new EvictionConfig();
+      evictConfig.setDefaultEvictionRegionConfig(evictionRegionConfig);
+      evictConfig.setWakeupInterval(wakeupInterval);
+
+
+      Configuration config = new Configuration();
+      config.setCacheMode(Configuration.CacheMode.LOCAL);
+      config.setEvictionConfig(evictConfig);
+
+      cache = factory.createCache(config, true);
+
+      ServerCacheHitInterceptor hit = new ServerCacheHitInterceptor(this);
+      ServerCacheInterceptor interceptor = new ServerCacheInterceptor(this);
+
+      getProviderFactory().getServerPreProcessInterceptorRegistry().register(hit);
+      getProviderFactory().getServerMessageBodyWriterInterceptorRegistry().register(interceptor);
+   }
+
+   public void stop()
+   {
+      cache.stop();
+   }
+
+
+   public Entry get(String uri, MediaType accept)
+   {
+      Node parent = cache.getRoot().getChild(Fqn.fromElements(uri));
+      if (parent == null) return null;
+
+      for (Object obj : parent.getChildren())
+      {
+         Node leaf = (Node) obj;
+         CacheEntry entry = (CacheEntry) leaf.get(""entry"");
+         if (accept.isCompatible(entry.getMediaType()))
+         {
+            return (Entry) leaf.get(""entry"");
+         }
+      }
+      return null;
+   }
+
+   public Entry add(String uri, MediaType mediaType, CacheControl cc, MultivaluedMap<String, Object> headers, byte[] entity, String etag)
+   {
+      System.out.println(""adding..."");
+      Node parent = cache.getRoot().addChild(Fqn.fromElements(uri));
+      Node leaf = parent.addChild(Fqn.fromElements(mediaType.toString()));
+      leaf.put(ExpirationAlgorithmConfig.EXPIRATION_KEY, (cc.getMaxAge() * 1000) + System.currentTimeMillis());
+      CacheEntry cacheEntry = new CacheEntry(headers, entity, cc.getMaxAge(), etag, mediaType);
+      leaf.put(""entry"", cacheEntry);
+      return cacheEntry;
+   }
+
+   public void remove(String key)
+   {
+      // let JBossCache clean it up
+   }
+
+   public void clear()
+   {
+      cache.clearData(Fqn.ROOT);
+   }
+
+}
\ No newline at end of file",2009-03-09T22:15:43Z,205
"@@ -1,4 +1,4 @@
-package org.jboss.resteasy.plugins.interceptors.cache;
+package org.jboss.resteasy.plugins.cache.server;
 
 import javax.ws.rs.core.CacheControl;
 import javax.ws.rs.core.MediaType;",2009-03-09T22:15:43Z,42
"@@ -1,4 +1,4 @@
-package org.jboss.resteasy.plugins.interceptors.cache;
+package org.jboss.resteasy.plugins.cache.server;
 
 import org.jboss.resteasy.core.ResourceMethod;
 import org.jboss.resteasy.core.ServerResponse;",2009-03-09T22:15:43Z,46
"@@ -1,4 +1,4 @@
-package org.jboss.resteasy.plugins.interceptors.cache;
+package org.jboss.resteasy.plugins.cache.server;
 
 import org.jboss.resteasy.core.interception.MessageBodyWriterContext;
 import org.jboss.resteasy.core.interception.MessageBodyWriterInterceptor;",2009-03-09T22:15:43Z,7
"@@ -0,0 +1,47 @@
+package org.jboss.resteasy.plugins.cache.server;
+
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+import javax.servlet.ServletContext;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ServletServerCache implements ServletContextListener
+{
+   protected ResteasyProviderFactory providerFactory;
+   protected JBossCache cache = new JBossCache();
+
+   public void contextInitialized(ServletContextEvent servletContextEvent)
+   {
+      ServletContext servletContext = servletContextEvent.getServletContext();
+      providerFactory = (ResteasyProviderFactory) servletContext.getAttribute(ResteasyProviderFactory.class.getName());
+      if (providerFactory == null)
+      {
+         throw new RuntimeException(""Resteasy is not intialized, could not find ResteasyProviderFactory attribute"");
+      }
+
+      String maxSize = servletContext.getInitParameter(""resteasy.server.cache.maxsize"");
+      if (maxSize != null)
+      {
+         cache.setMaxSize(Integer.parseInt(maxSize));
+      }
+
+      String wakeupInterval = servletContext.getInitParameter(""resteasy.server.cache.eviction.wakeup.interval"");
+      if (wakeupInterval != null)
+      {
+         cache.setWakeupInterval(Long.parseLong(wakeupInterval));
+      }
+      cache.setProviderFactory(providerFactory);
+
+      cache.start();
+   }
+
+   public void contextDestroyed(ServletContextEvent servletContextEvent)
+   {
+      cache.stop();
+   }
+}",2009-03-09T22:15:43Z,206
"@@ -1,4 +1,4 @@
-package org.jboss.resteasy.plugins.interceptors.cache;
+package org.jboss.resteasy.plugins.cache.server;
 
 
 import javax.ws.rs.core.CacheControl;
@@ -13,6 +13,7 @@
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
+@Deprecated
 public class SimpleServerCache implements ServerCache
 {
    public static class CacheEntry implements Entry",2009-03-09T22:15:43Z,18
"@@ -3,9 +3,7 @@
 import org.jboss.resteasy.annotations.cache.Cache;
 import org.jboss.resteasy.client.ClientRequest;
 import org.jboss.resteasy.client.ClientResponse;
-import org.jboss.resteasy.plugins.interceptors.cache.ServerCacheHitInterceptor;
-import org.jboss.resteasy.plugins.interceptors.cache.ServerCacheInterceptor;
-import org.jboss.resteasy.plugins.interceptors.cache.SimpleServerCache;
+import org.jboss.resteasy.plugins.cache.server.JBossCache;
 import org.jboss.resteasy.test.BaseResourceTest;
 import static org.jboss.resteasy.test.TestPortProvider.*;
 import org.junit.Assert;
@@ -85,13 +83,9 @@ public static interface MyProxy
    @Before
    public void setUp() throws Exception
    {
-      SimpleServerCache cache = new SimpleServerCache();
-      ServerCacheHitInterceptor hit = new ServerCacheHitInterceptor(cache);
-      ServerCacheInterceptor interceptor = new ServerCacheInterceptor(cache);
-
-      getProviderFactory().getServerPreProcessInterceptorRegistry().register(hit);
-      getProviderFactory().getServerMessageBodyWriterInterceptorRegistry().register(interceptor);
-
+      JBossCache cache = new JBossCache();
+      cache.setProviderFactory(getProviderFactory());
+      cache.start();
       addPerRequestResource(MyService.class);
    }
 ",2009-03-09T22:15:43Z,207
"@@ -0,0 +1,14 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<module relativePaths=""true"" MavenProjectsManager.isMavenModule=""true"" type=""JAVA_MODULE"" version=""4"">
+  <component name=""NewModuleRootManager"" LANGUAGE_LEVEL=""JDK_1_5"" inherit-compiler-output=""false"">
+    <output url=""file://$MODULE_DIR$/target/classes"" />
+    <output-test url=""file://$MODULE_DIR$/target/test-classes"" />
+    <exclude-output />
+    <content url=""file://$MODULE_DIR$"">
+      <excludeFolder url=""file://$MODULE_DIR$/target"" />
+    </content>
+    <orderEntry type=""inheritedJdk"" />
+    <orderEntry type=""sourceFolder"" forTests=""false"" />
+  </component>
+</module>
+",2009-03-09T22:15:43Z,208
"@@ -1,29 +1,16 @@
 package org.jboss.resteasy.client.cache;
 
-
-import org.jboss.resteasy.client.ClientRequest;
-import org.jboss.resteasy.client.ClientResponse;
-import org.jboss.resteasy.client.core.BaseClientResponse;
-import org.jboss.resteasy.util.DateUtil;
-import org.jboss.resteasy.util.ReadFromStream;
-
-import javax.ws.rs.core.CacheControl;
-import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.MultivaluedMap;
-import java.util.Date;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
+import java.io.Serializable;
 
 /**
- * An HTTP cache that behaves in the same way a browser should behave obeying Cache-Control headers and such.
- *
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class BrowserCache
+public interface BrowserCache
 {
-   public static class Header
+   public static class Header implements Serializable
    {
       private String name;
       private String value;
@@ -45,203 +32,27 @@ public String getValue()
       }
    }
 
-   public static class CacheEntry
-   {
-      private final MediaType mediaType;
-      private final byte[] cached;
-      private final int expires;
-      private final long timestamp = System.currentTimeMillis();
-      private final MultivaluedMap<String, String> headers;
-      private Header[] validationHeaders = {};
-
-      private CacheEntry(MultivaluedMap<String, String> headers, byte[] cached, int expires, String etag, String lastModified, MediaType mediaType)
-      {
-         this.cached = cached;
-         this.expires = expires;
-         this.mediaType = mediaType;
-         this.headers = headers;
-
-         if (etag != null || lastModified != null)
-         {
-            if (etag != null && lastModified != null)
-            {
-               validationHeaders = new Header[2];
-               validationHeaders[0] = new Header(""If-Modified-Since"", lastModified);
-               validationHeaders[1] = new Header(""If-None-Match"", etag);
-            }
-            else if (etag != null)
-            {
-               validationHeaders = new Header[1];
-               validationHeaders[0] = new Header(""If-None-Match"", etag);
-            }
-            else if (lastModified != null)
-            {
-               validationHeaders = new Header[1];
-               validationHeaders[0] = new Header(""If-Modified-Since"", lastModified);
-            }
-
-         }
-      }
-
-      public MultivaluedMap<String, String> getHeaders()
-      {
-         return headers;
-      }
-
-      public boolean expired()
-      {
-         return System.currentTimeMillis() - timestamp >= expires * 1000;
-      }
-
-      public Header[] getValidationHeaders()
-      {
-         return validationHeaders;
-      }
-
-      public byte[] getCached()
-      {
-         return cached;
-      }
-
-      public MediaType getMediaType()
-      {
-         return mediaType;
-      }
-   }
-
-   private Map<String, Map<MediaType, CacheEntry>> cache = new ConcurrentHashMap<String, Map<MediaType, CacheEntry>>();
-
-   public Map<MediaType, CacheEntry> get(String key)
-   {
-      return cache.get(key);
-   }
-
-
-   public boolean isCacheable(MultivaluedMap<String, String> headers)
-   {
-      String cc = headers.getFirst(HttpHeaders.CACHE_CONTROL);
-
-      if (cc != null)
-      {
-         CacheControl cacheControl = CacheControl.valueOf(cc);
-         if (cacheControl.isNoCache()) return false;
-         return true;
-      }
-      else
-      {
-         return headers.containsKey(HttpHeaders.EXPIRES) ||
-                 headers.containsKey(HttpHeaders.LAST_MODIFIED) ||
-                 headers.containsKey(HttpHeaders.ETAG);
-      }
-   }
-
-   public ClientResponse cacheIfPossible(ClientRequest request, BaseClientResponse response) throws Exception
+   public static interface Entry
    {
-      String cc = (String) response.getHeaders().getFirst(HttpHeaders.CACHE_CONTROL);
-      String exp = (String) response.getHeaders().getFirst(HttpHeaders.EXPIRES);
-      int expires = -1;
+      MultivaluedMap<String, String> getHeaders();
 
-      if (cc != null)
-      {
-         CacheControl cacheControl = CacheControl.valueOf(cc);
-         if (cacheControl.isNoCache()) return response;
-         expires = cacheControl.getMaxAge();
-      }
-      else if (exp != null)
-      {
-         Date date = DateUtil.parseDate(exp);
-         expires = (int) ((date.getTime() - System.currentTimeMillis()) / 1000);
-      }
-
-      String lastModified = (String) response.getHeaders().getFirst(HttpHeaders.LAST_MODIFIED);
-      String etag = (String) response.getHeaders().getFirst(HttpHeaders.ETAG);
+      boolean expired();
 
-      String contentType = (String) response.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);
+      Header[] getValidationHeaders();
 
-      byte[] cached = ReadFromStream.readFromStream(1024, response.getInputStream());
-      response.releaseConnection();
+      byte[] getCached();
 
-      CacheEntry entry = put(request.getUri(), MediaType.valueOf(contentType), (MultivaluedMap<String, String>) response.getHeaders(), cached, expires, etag, lastModified);
-
-      return new CachedClientResponse(entry, request.getProviderFactory());
+      MediaType getMediaType();
    }
 
-   public ClientResponse updateOnNotModified(ClientRequest request, CacheEntry old, BaseClientResponse response) throws Exception
-   {
-      old.getHeaders().remove(HttpHeaders.CACHE_CONTROL);
-      old.getHeaders().remove(HttpHeaders.EXPIRES);
-      old.getHeaders().remove(HttpHeaders.LAST_MODIFIED);
-      String cc = (String) response.getHeaders().getFirst(HttpHeaders.CACHE_CONTROL);
-      String exp = (String) response.getHeaders().getFirst(HttpHeaders.EXPIRES);
-      int expires = -1;
-
-      if (cc != null)
-      {
-         CacheControl cacheControl = CacheControl.valueOf(cc);
-         if (cacheControl.isNoCache())
-         {
-            return new CachedClientResponse(old, request.getProviderFactory());
-         }
-         expires = cacheControl.getMaxAge();
-      }
-      else if (exp != null)
-      {
-         Date date = DateUtil.parseDate(exp);
-         expires = (int) ((date.getTime() - System.currentTimeMillis()) / 1000);
-      }
-
-      if (cc != null)
-      {
-         old.getHeaders().putSingle(HttpHeaders.CACHE_CONTROL, cc);
-      }
-      if (exp != null)
-      {
-         old.getHeaders().putSingle(HttpHeaders.CACHE_CONTROL, exp);
-      }
+   Entry getAny(String key);
 
-      String lastModified = (String) response.getHeaders().getFirst(HttpHeaders.LAST_MODIFIED);
-      String etag = (String) response.getHeaders().getFirst(HttpHeaders.ETAG);
+   Entry get(String key, MediaType accept);
 
-      if (etag == null) etag = old.getHeaders().getFirst(HttpHeaders.ETAG);
-      else old.getHeaders().putSingle(HttpHeaders.ETAG, etag);
+   Entry put(String key, MediaType mediaType, MultivaluedMap<String, String> headers, byte[] cached, int expires, String etag, String lastModified);
 
-      if (lastModified != null)
-      {
-         old.getHeaders().putSingle(HttpHeaders.LAST_MODIFIED, lastModified);
-      }
+   void remove(String key, MediaType type);
 
-      if (etag == null && lastModified == null && cc == null && exp == null) // don't cache
-      {
-         return new CachedClientResponse(old, request.getProviderFactory());
-      }
-
-
-      CacheEntry entry = put(request.getUri(), old.getMediaType(), old.getHeaders(), old.getCached(), expires, etag, lastModified);
-      return new CachedClientResponse(entry, request.getProviderFactory());
-
-   }
-
-   public CacheEntry put(String key, MediaType mediaType, MultivaluedMap<String, String> headers, byte[] cached, int expires, String etag, String lastModified)
-   {
-      Map<MediaType, CacheEntry> map = cache.get(key);
-      if (map == null)
-      {
-         map = new ConcurrentHashMap<MediaType, CacheEntry>();
-         cache.put(key, map);
-      }
-      CacheEntry cacheEntry = new CacheEntry(headers, cached, expires, etag, lastModified, mediaType);
-      map.put(mediaType, cacheEntry);
-      return cacheEntry;
-   }
-
-   public void remove(String key)
-   {
-      cache.remove(key);
-   }
-
-   public void clear()
-   {
-      cache.clear();
-   }
+   void clear();
 
 }",2009-03-09T22:15:43Z,209
"@@ -17,9 +17,9 @@ public class CacheFactory
     * @param clientProxy
     * @return
     */
-   public static BrowserCache makeCacheable(Object clientProxy)
+   public static LightweightBrowserCache makeCacheable(Object clientProxy)
    {
-      BrowserCache cache = new BrowserCache();
+      LightweightBrowserCache cache = new LightweightBrowserCache();
       makeCacheable(clientProxy, cache);
       return cache;
    }",2009-03-09T22:15:43Z,210
"@@ -6,18 +6,21 @@
 import org.jboss.resteasy.core.interception.AcceptedByMethod;
 import org.jboss.resteasy.core.interception.ClientExecutionContext;
 import org.jboss.resteasy.core.interception.ClientExecutionInterceptor;
+import org.jboss.resteasy.util.DateUtil;
+import org.jboss.resteasy.util.ReadFromStream;
 import org.jboss.resteasy.util.WeightedMediaType;
 
 import javax.ws.rs.GET;
+import javax.ws.rs.core.CacheControl;
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Iterator;
+import java.util.Date;
 import java.util.List;
-import java.util.Map;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -46,17 +49,17 @@ public ClientResponse execute(ClientExecutionContext ctx) throws Exception
          return ctx.proceed();
       }
 
-      BrowserCache.CacheEntry entry = getEntry(request);
+      BrowserCache.Entry entry = getEntry(request);
       if (entry == null)
       {
          ClientResponse response = ctx.proceed();
          if (response.getStatus() != 200) return response;
-         return cache.cacheIfPossible(request, (BaseClientResponse) response);
+         return cacheIfPossible(request, (BaseClientResponse) response);
       }
 
       if (entry.expired())
       {
-         cache.remove(request.getUri());
+         cache.remove(request.getUri(), entry.getMediaType());
          BrowserCache.Header[] headers = entry.getValidationHeaders();
          for (BrowserCache.Header header : headers)
          {
@@ -66,11 +69,11 @@ public ClientResponse execute(ClientExecutionContext ctx) throws Exception
          ClientResponse response = ctx.proceed();
          if (response.getStatus() == Response.Status.NOT_MODIFIED.getStatusCode())
          {
-            return cache.updateOnNotModified(request, entry, (BaseClientResponse) response);
+            return updateOnNotModified(request, entry, (BaseClientResponse) response);
          }
          else if (response.getStatus() == 200)
          {
-            return cache.cacheIfPossible(request, (BaseClientResponse) response);
+            return cacheIfPossible(request, (BaseClientResponse) response);
          }
          else
          {
@@ -83,16 +86,99 @@ else if (response.getStatus() == 200)
       }
    }
 
-   protected BrowserCache.CacheEntry getEntry(ClientRequest request) throws Exception
+   public ClientResponse updateOnNotModified(ClientRequest request, BrowserCache.Entry old, BaseClientResponse response) throws Exception
    {
-      String uri = request.getUri();
-      Map<MediaType, BrowserCache.CacheEntry> entries = cache.get(uri);
-      if (entries == null)
+      old.getHeaders().remove(HttpHeaders.CACHE_CONTROL);
+      old.getHeaders().remove(HttpHeaders.EXPIRES);
+      old.getHeaders().remove(HttpHeaders.LAST_MODIFIED);
+      String cc = (String) response.getHeaders().getFirst(HttpHeaders.CACHE_CONTROL);
+      String exp = (String) response.getHeaders().getFirst(HttpHeaders.EXPIRES);
+      int expires = -1;
+
+      if (cc != null)
+      {
+         CacheControl cacheControl = CacheControl.valueOf(cc);
+         if (cacheControl.isNoCache())
+         {
+            return new CachedClientResponse(old, request.getProviderFactory());
+         }
+         expires = cacheControl.getMaxAge();
+      }
+      else if (exp != null)
+      {
+         Date date = DateUtil.parseDate(exp);
+         expires = (int) ((date.getTime() - System.currentTimeMillis()) / 1000);
+      }
+
+      if (cc != null)
+      {
+         old.getHeaders().putSingle(HttpHeaders.CACHE_CONTROL, cc);
+      }
+      if (exp != null)
       {
-         return null;
+         old.getHeaders().putSingle(HttpHeaders.CACHE_CONTROL, exp);
       }
 
-      BrowserCache.CacheEntry entry = null;
+      String lastModified = (String) response.getHeaders().getFirst(HttpHeaders.LAST_MODIFIED);
+      String etag = (String) response.getHeaders().getFirst(HttpHeaders.ETAG);
+
+      if (etag == null) etag = old.getHeaders().getFirst(HttpHeaders.ETAG);
+      else old.getHeaders().putSingle(HttpHeaders.ETAG, etag);
+
+      if (lastModified != null)
+      {
+         old.getHeaders().putSingle(HttpHeaders.LAST_MODIFIED, lastModified);
+      }
+
+      if (etag == null && lastModified == null && cc == null && exp == null) // don't cache
+      {
+         return new CachedClientResponse(old, request.getProviderFactory());
+      }
+
+
+      BrowserCache.Entry entry = cache.put(request.getUri(), old.getMediaType(), old.getHeaders(), old.getCached(), expires, etag, lastModified);
+      return new CachedClientResponse(entry, request.getProviderFactory());
+
+   }
+
+
+   public ClientResponse cacheIfPossible(ClientRequest request, BaseClientResponse response) throws Exception
+   {
+      String cc = (String) response.getHeaders().getFirst(HttpHeaders.CACHE_CONTROL);
+      String exp = (String) response.getHeaders().getFirst(HttpHeaders.EXPIRES);
+      int expires = -1;
+
+      if (cc != null)
+      {
+         CacheControl cacheControl = CacheControl.valueOf(cc);
+         if (cacheControl.isNoCache()) return response;
+         expires = cacheControl.getMaxAge();
+      }
+      else if (exp != null)
+      {
+         Date date = DateUtil.parseDate(exp);
+         expires = (int) ((date.getTime() - System.currentTimeMillis()) / 1000);
+      }
+
+      String lastModified = (String) response.getHeaders().getFirst(HttpHeaders.LAST_MODIFIED);
+      String etag = (String) response.getHeaders().getFirst(HttpHeaders.ETAG);
+
+      String contentType = (String) response.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);
+
+      byte[] cached = ReadFromStream.readFromStream(1024, response.getInputStream());
+      response.releaseConnection();
+
+      BrowserCache.Entry entry = cache.put(request.getUri(), MediaType.valueOf(contentType), (MultivaluedMap<String, String>) response.getHeaders(), cached, expires, etag, lastModified);
+
+      return new CachedClientResponse(entry, request.getProviderFactory());
+   }
+
+
+   protected BrowserCache.Entry getEntry(ClientRequest request) throws Exception
+   {
+      String uri = request.getUri();
+
+      BrowserCache.Entry entry = null;
       String acceptHeader = request.getHeaders().getFirst(HttpHeaders.ACCEPT);
       if (acceptHeader != null)
       {
@@ -110,14 +196,13 @@ protected BrowserCache.CacheEntry getEntry(ClientRequest request) throws Excepti
          }
          for (MediaType accept : accepts)
          {
-            entry = entries.get(accept);
+            entry = cache.get(uri, accept);
             if (entry != null) return entry;
          }
       }
       else
       {
-         Iterator<BrowserCache.CacheEntry> it = entries.values().iterator();
-         if (it.hasNext()) return it.next();
+         return cache.getAny(uri);
       }
 
       return null;",2009-03-09T22:15:43Z,211
"@@ -13,9 +13,9 @@
  */
 public class CachedClientResponse extends BaseClientResponse
 {
-   protected BrowserCache.CacheEntry entry;
+   protected BrowserCache.Entry entry;
 
-   public CachedClientResponse(BrowserCache.CacheEntry entry, ResteasyProviderFactory factory)
+   public CachedClientResponse(BrowserCache.Entry entry, ResteasyProviderFactory factory)
    {
       this.entry = entry;
       this.headers = entry.getHeaders();",2009-03-09T22:15:43Z,212
"@@ -0,0 +1,177 @@
+package org.jboss.resteasy.client.cache;
+
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * In-memory BrowserCache.  Uses java.util.ConcurrentHashMaps.  You specify maximum bytes you want the cache
+ * to have.  The default is 2Megabytes.  If the cache exceeds this amount, it is wiped clean.  This rather draconian
+ * approach to cache reaping is to avoid synchronization that you would normally have to do in a sophisticated cache.
+ * <p/>
+ * With high concurrent access, because this is not a sophisticated cache, sometimes a cache entry may be lost.
+ * It is consistent though.
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class LightweightBrowserCache implements BrowserCache
+{
+
+
+   public static class CacheEntry implements Entry
+   {
+      private final MediaType mediaType;
+      private final byte[] cached;
+      private final int expires;
+      private final long timestamp = System.currentTimeMillis();
+      private final MultivaluedMap<String, String> headers;
+      private Header[] validationHeaders = {};
+      private final String key;
+
+      public CacheEntry(String key, MultivaluedMap<String, String> headers, byte[] cached, int expires, String etag, String lastModified, MediaType mediaType)
+      {
+         this.key = key;
+         this.cached = cached;
+         this.expires = expires;
+         this.mediaType = mediaType;
+         this.headers = headers;
+
+         if (etag != null || lastModified != null)
+         {
+            if (etag != null && lastModified != null)
+            {
+               validationHeaders = new Header[2];
+               validationHeaders[0] = new Header(""If-Modified-Since"", lastModified);
+               validationHeaders[1] = new Header(""If-None-Match"", etag);
+            }
+            else if (etag != null)
+            {
+               validationHeaders = new Header[1];
+               validationHeaders[0] = new Header(""If-None-Match"", etag);
+            }
+            else if (lastModified != null)
+            {
+               validationHeaders = new Header[1];
+               validationHeaders[0] = new Header(""If-Modified-Since"", lastModified);
+            }
+
+         }
+      }
+
+      public String getKey()
+      {
+         return key;
+      }
+
+      public MultivaluedMap<String, String> getHeaders()
+      {
+         return headers;
+      }
+
+      public boolean expired()
+      {
+         return System.currentTimeMillis() - timestamp >= expires * 1000;
+      }
+
+      public Header[] getValidationHeaders()
+      {
+         return validationHeaders;
+      }
+
+      public byte[] getCached()
+      {
+         return cached;
+      }
+
+      public MediaType getMediaType()
+      {
+         return mediaType;
+      }
+   }
+
+   // we have a wrapper for these two so that there is only one guaranteed volatile memory size we're working with
+   private static class CacheHolder
+   {
+      protected AtomicLong bytes = new AtomicLong(0);
+      protected ConcurrentHashMap<String, Map<MediaType, Entry>> cache = new ConcurrentHashMap<String, Map<MediaType, Entry>>();
+
+   }
+
+   protected long maxBytes = 2000000; // 2 meg default
+   protected volatile CacheHolder holder = new CacheHolder();
+
+   public long getMaxBytes()
+   {
+      return maxBytes;
+   }
+
+   public void setMaxBytes(long maxBytes)
+   {
+      this.maxBytes = maxBytes;
+   }
+
+   public long getByteCount()
+   {
+      return holder.bytes.get();
+   }
+
+   public Entry getAny(String key)
+   {
+      Map<MediaType, Entry> parent = holder.cache.get(key);
+      if (parent == null) return null;
+      Iterator<Entry> iterator = parent.values().iterator();
+      if (iterator.hasNext()) return iterator.next();
+      return null;
+   }
+
+   public void remove(String key, MediaType type)
+   {
+      CacheHolder tmpHolder = holder;
+      Map<MediaType, Entry> parent = tmpHolder.cache.get(key);
+      if (parent == null) return;
+      Entry entry = parent.remove(type);
+      if (entry != null) tmpHolder.bytes.addAndGet(-1 * entry.getCached().length);
+   }
+
+   public Entry get(String key, MediaType accept)
+   {
+      Map<MediaType, Entry> parent = holder.cache.get(key);
+      if (parent == null) return null;
+      return parent.get(accept);
+   }
+
+
+   public Entry put(String key, MediaType mediaType, MultivaluedMap<String, String> headers, byte[] cached, int expires, String etag, String lastModified)
+   {
+      CacheEntry cacheEntry = new CacheEntry(key, headers, cached, expires, etag, lastModified, mediaType);
+
+      CacheHolder tmpHolder = holder;
+      if (tmpHolder.bytes.addAndGet(cached.length) > maxBytes)
+      {
+         tmpHolder = new CacheHolder(); // just freakin wipe it clean!!
+         tmpHolder.bytes.addAndGet(cached.length);
+         holder = tmpHolder;
+      }
+
+      Map<MediaType, Entry> map = tmpHolder.cache.get(key);
+      if (map == null)
+      {
+         map = new ConcurrentHashMap<MediaType, Entry>();
+         Map<MediaType, Entry> tmp = tmpHolder.cache.putIfAbsent(key, map);
+         map = (tmp == null) ? map : tmp;
+      }
+      map.put(mediaType, cacheEntry);
+      return cacheEntry;
+   }
+
+   public void clear()
+   {
+      holder.cache.clear();
+   }
+
+}",2009-03-09T22:15:43Z,213
"@@ -1,8 +1,9 @@
-package org.jboss.resteasy.test.cache;
+package org.jboss.resteasy.test.client.cache;
 
 import org.jboss.resteasy.annotations.cache.Cache;
 import org.jboss.resteasy.client.ProxyFactory;
 import org.jboss.resteasy.client.cache.CacheFactory;
+import org.jboss.resteasy.client.cache.LightweightBrowserCache;
 import org.jboss.resteasy.test.BaseResourceTest;
 import static org.jboss.resteasy.test.TestPortProvider.*;
 import org.junit.Assert;
@@ -11,6 +12,7 @@
 
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
 import javax.ws.rs.Produces;
 import javax.ws.rs.core.CacheControl;
 import javax.ws.rs.core.Context;
@@ -84,6 +86,16 @@ public Response getValidateEtagged(@Context Request request)
          return Response.ok(""hello"" + count).tag(""42"").build();
       }
 
+      @Path(""/cacheit/{id}"")
+      @GET
+      @Produces(""text/plain"")
+      @Cache(maxAge = 3000)
+      public String getCacheit(@PathParam(""id"") String id)
+      {
+         count++;
+         return ""cachecache"" + count;
+      }
+
    }
 
    @Path(""/cache"")
@@ -107,6 +119,12 @@ public static interface MyProxy
       @GET
       @Produces(""text/plain"")
       public String getValidateEtagged();
+
+      @Path(""/cacheit/{id}"")
+      @GET
+      @Produces(""text/plain"")
+      @Cache(maxAge = 3000)
+      public String getCacheit(@PathParam(""id"") String id);
    }
 
 
@@ -186,4 +204,36 @@ public void testProxy() throws Exception
       Assert.assertEquals(4, count);
    }
 
+   @Test
+   public void testMaxSize() throws Exception
+   {
+      MyProxy proxy = ProxyFactory.create(MyProxy.class, generateBaseUrl());
+      LightweightBrowserCache cache = CacheFactory.makeCacheable(proxy);
+      cache.setMaxBytes(20);
+
+      count = 0;
+
+      String rtn = proxy.getCacheit(""1"");
+      Assert.assertEquals(""cachecache"" + 1, rtn);
+      Assert.assertEquals(1, count);
+
+      rtn = proxy.getCacheit(""1"");
+      Assert.assertEquals(""cachecache"" + 1, rtn);
+      Assert.assertEquals(1, count);
+
+      rtn = proxy.getCacheit(""2"");
+      Assert.assertEquals(""cachecache"" + 2, rtn);
+      Assert.assertEquals(2, count);
+
+      rtn = proxy.getCacheit(""2"");
+      Assert.assertEquals(""cachecache"" + 2, rtn);
+      Assert.assertEquals(2, count);
+
+      rtn = proxy.getCacheit(""1"");
+      Assert.assertEquals(""cachecache"" + 3, rtn);
+      Assert.assertEquals(3, count);
+
+
+   }
+
 }",2009-03-09T22:15:43Z,32
"@@ -174,6 +174,8 @@ protected void writeResponse(HttpResponse response, ResourceMethod invoker, Obje
       Annotation[] annotations = invoker.getMethod().getAnnotations();
 
       MessageBodyWriter writer = providerFactory.createMessageBodyWriter(type, genericType, annotations, responseContentType);
+      System.out.println(""MessageBodyWriter class is: "" + writer.getClass().getName());
+      System.out.println(""Response content type: "" + responseContentType);
       if (writer == null)
       {
          throw new RuntimeException(""Could not find MessageBodyWriter for response object of type: "" + entity.getClass() + "" of media type: "" + responseContentType);",2008-03-25T20:39:56Z,51
"@@ -125,7 +125,9 @@ public List<T> getPossible(MediaType accept)
       List<Entry<T>> matches = new ArrayList<Entry<T>>();
       if (accept.isWildcardType())
       {
-         return everything;
+         ArrayList<T> copy = new ArrayList<T>();
+         copy.addAll(everything);
+         return copy;
       }
       else
       {",2008-03-25T20:39:56Z,214
"@@ -23,7 +23,7 @@ public QueryParamInjector(Class type, Type genericType, AccessibleObject target,
 
    public Object inject(HttpRequest request, HttpResponse response)
    {
-      List<String> list = request.getParameters().get(paramName);
+      List<String> list = request.getUri().getQueryParameters().get(paramName);
       return extractValues(list);
    }
 ",2008-03-25T20:39:56Z,215
"@@ -0,0 +1,146 @@
+package org.resteasy.plugins.providers;
+
+import org.resteasy.specimpl.MultivaluedMapImpl;
+import org.resteasy.util.FindAnnotation;
+
+import javax.ws.rs.ConsumeMime;
+import javax.ws.rs.Encoded;
+import javax.ws.rs.ProduceMime;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Provider;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@Provider
+@ProduceMime(""application/x-www-form-urlencoded"")
+@ConsumeMime(""application/x-www-form-urlencoded"")
+public class FormUrlEncodedProvider implements MessageBodyReader<MultivaluedMap<String, String>>, MessageBodyWriter<MultivaluedMap<String, String>>
+{
+   public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations)
+   {
+      if (!type.equals(MultivaluedMap.class)) return false;
+      if (genericType == null) return true;
+
+      if (!(genericType instanceof ParameterizedType)) return false;
+      ParameterizedType params = (ParameterizedType) genericType;
+      if (params.getActualTypeArguments().length != 2) return false;
+      return params.getActualTypeArguments().equals(String.class) && params.getActualTypeArguments()[1].equals(String.class);
+   }
+
+   public MultivaluedMap<String, String> readFrom(Class<MultivaluedMap<String, String>> type, Type genericType, MediaType mediaType, Annotation[] annotations, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException
+   {
+
+      char[] buffer = new char[100];
+      StringBuffer buf = new StringBuffer();
+      BufferedReader reader = new BufferedReader(new InputStreamReader(entityStream));
+
+      int wasRead = 0;
+      do
+      {
+         wasRead = reader.read(buffer, 0, 100);
+         if (wasRead > 0) buf.append(buffer, 0, wasRead);
+      } while (wasRead > -1);
+
+      String form = buf.toString();
+
+      boolean encoded = FindAnnotation.findAnnotation(annotations, Encoded.class) != null;
+
+      MultivaluedMap<String, String> formData = new MultivaluedMapImpl<String, String>();
+      String[] params = form.split(""&"");
+
+      for (String param : params)
+      {
+         if (param.indexOf('=') >= 0)
+         {
+            String[] nv = param.split(""="");
+            try
+            {
+               String name = URLDecoder.decode(nv[0], ""UTF-8"");
+               if (encoded)
+               {
+                  formData.add(name, nv[1]);
+               }
+               else
+               {
+                  formData.add(name, URLDecoder.decode(nv[1], ""UTF-8""));
+               }
+            }
+            catch (UnsupportedEncodingException e)
+            {
+               throw new RuntimeException(e);
+            }
+         }
+         else
+         {
+            try
+            {
+               String name = URLDecoder.decode(param, ""UTF-8"");
+               formData.add(name, """");
+            }
+            catch (UnsupportedEncodingException e)
+            {
+               throw new RuntimeException(e);
+            }
+         }
+      }
+      return formData;
+   }
+
+   public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations)
+   {
+      if (!type.equals(MultivaluedMap.class)) return false;
+      if (genericType == null) return true;
+
+      if (!(genericType instanceof ParameterizedType)) return false;
+      ParameterizedType params = (ParameterizedType) genericType;
+      if (params.getActualTypeArguments().length != 2) return false;
+      return params.getActualTypeArguments().equals(String.class) && params.getActualTypeArguments()[1].equals(String.class);
+   }
+
+   public long getSize(MultivaluedMap<String, String> inputStream)
+   {
+      return -1;
+   }
+
+   public void writeTo(MultivaluedMap<String, String> formData, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException
+   {
+      boolean encoded = FindAnnotation.findAnnotation(annotations, Encoded.class) != null;
+      OutputStreamWriter writer = new OutputStreamWriter(entityStream, ""UTF-8"");
+
+      boolean first = false;
+      for (Map.Entry<String, List<String>> entry : formData.entrySet())
+      {
+         if (first) first = true;
+         else writer.write(""&"");
+         String encodedName = URLEncoder.encode(entry.getKey(), ""UTF-8"");
+         for (String value : entry.getValue())
+         {
+            if (!encoded) value = URLEncoder.encode(value, ""UTF-8"");
+            writer.write(encodedName);
+            writer.write(""="");
+            writer.write(value);
+         }
+      }
+
+   }
+
+}
\ No newline at end of file",2008-03-25T20:39:56Z,216
"@@ -25,5 +25,10 @@ public static void register(ResteasyProviderFactory factory)
 
       factory.addMessageBodyReader(new ByteArrayProvider());
       factory.addMessageBodyWriter(new ByteArrayProvider());
+
+      factory.addMessageBodyReader(new FormUrlEncodedProvider());
+      factory.addMessageBodyWriter(new FormUrlEncodedProvider());
+
+      factory.addMessageBodyWriter(new StreamingOutputProvider());
    }
 }",2008-03-25T20:39:56Z,217
"@@ -0,0 +1,34 @@
+package org.resteasy.plugins.providers;
+
+import javax.ws.rs.ProduceMime;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.StreamingOutput;
+import javax.ws.rs.ext.MessageBodyWriter;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@ProduceMime(""*/*"")
+public class StreamingOutputProvider implements MessageBodyWriter<StreamingOutput>
+{
+   public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations)
+   {
+      return StreamingOutput.class.isAssignableFrom(type);
+   }
+
+   public long getSize(StreamingOutput streamingOutput)
+   {
+      return -1;
+   }
+
+   public void writeTo(StreamingOutput streamingOutput, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException
+   {
+      streamingOutput.write(entityStream);
+   }
+}",2008-03-25T20:39:56Z,218
"@@ -124,7 +124,7 @@ protected void invokeJaxrs(GrizzlyRequest request, GrizzlyResponse response)
       HttpRequest in;
       try
       {
-         in = new GrizzlyHttpRequest(headers, request.getInputStream(), uriInfo, parameters, request.getMethod().toUpperCase());
+         in = new GrizzlyHttpRequest(headers, request.getInputStream(), uriInfo, request.getMethod().toUpperCase());
       }
       catch (IOException e)
       {",2008-03-25T20:39:56Z,47
"@@ -3,7 +3,6 @@
 import org.resteasy.util.HttpRequestImpl;
 
 import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.UriInfo;
 import java.io.InputStream;
 
@@ -13,8 +12,8 @@
  */
 public class GrizzlyHttpRequest extends HttpRequestImpl
 {
-   public GrizzlyHttpRequest(HttpHeaders httpHeaders, InputStream inputStream, UriInfo uri, MultivaluedMap<String, String> parameters, String httpMethod)
+   public GrizzlyHttpRequest(HttpHeaders httpHeaders, InputStream inputStream, UriInfo uri, String httpMethod)
    {
-      super(inputStream, httpHeaders, httpMethod, uri, parameters);
+      super(inputStream, httpHeaders, httpMethod, uri);
    }
 }",2008-03-25T20:39:56Z,21
"@@ -86,7 +86,6 @@ public void invoke(HttpServletRequest httpServletRequest, HttpServletResponse ht
    public void service(String httpMethod, HttpServletRequest request, HttpServletResponse response)
    {
       HttpHeaders headers = extractHttpHeaders(request);
-      MultivaluedMapImpl<String, String> parameters = extractParameters(request);
       String path = request.getPathInfo();
       //System.out.println(""path: "" + path);
       URI absolutePath = null;
@@ -110,7 +109,7 @@ public void service(String httpMethod, HttpServletRequest request, HttpServletRe
       HttpRequest in;
       try
       {
-         in = new HttpServletInputMessage(headers, request.getInputStream(), uriInfo, parameters, httpMethod.toUpperCase());
+         in = new HttpServletInputMessage(headers, request.getInputStream(), uriInfo, httpMethod.toUpperCase());
       }
       catch (IOException e)
       {
@@ -130,22 +129,6 @@ public void service(String httpMethod, HttpServletRequest request, HttpServletRe
       }
    }
 
-   public static MultivaluedMapImpl<String, String> extractParameters(HttpServletRequest request)
-   {
-      MultivaluedMapImpl<String, String> parameters = new MultivaluedMapImpl<String, String>();
-
-      Enumeration parameterNames = request.getParameterNames();
-      while (parameterNames.hasMoreElements())
-      {
-         String parameterName = (String) parameterNames.nextElement();
-         for (String parameterValue : request.getParameterValues(parameterName))
-         {
-            parameters.add(parameterName, parameterValue);
-         }
-      }
-      return parameters;
-   }
-
    public static HttpHeaders extractHttpHeaders(HttpServletRequest request)
    {
       HttpHeadersImpl headers = new HttpHeadersImpl();",2008-03-25T20:39:56Z,71
"@@ -3,7 +3,6 @@
 import org.resteasy.util.HttpRequestImpl;
 
 import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.UriInfo;
 import java.io.InputStream;
 
@@ -18,9 +17,9 @@
 public class HttpServletInputMessage extends HttpRequestImpl
 {
 
-   public HttpServletInputMessage(HttpHeaders httpHeaders, InputStream inputStream, UriInfo uri, MultivaluedMap<String, String> parameters, String httpMethod)
+   public HttpServletInputMessage(HttpHeaders httpHeaders, InputStream inputStream, UriInfo uri, String httpMethod)
    {
-      super(inputStream, httpHeaders, httpMethod, uri, parameters);
+      super(inputStream, httpHeaders, httpMethod, uri);
    }
 
 }",2008-03-25T20:39:56Z,27
"@@ -140,37 +140,41 @@ protected void processProviders(AnnotationDB db)
       if (classes == null) return;
       for (String clazz : classes)
       {
-         System.out.println(""FOUND JAX-RS @Provider: "" + clazz);
-         Class provider = null;
+         registerProvider(clazz);
+      }
+   }
+
+   private void registerProvider(String clazz)
+   {
+      Class provider = null;
+      try
+      {
+         provider = Thread.currentThread().getContextClassLoader().loadClass(clazz);
+      }
+      catch (ClassNotFoundException e)
+      {
+         throw new RuntimeException(e);
+      }
+      if (MessageBodyReader.class.isAssignableFrom(provider))
+      {
          try
          {
-            provider = Thread.currentThread().getContextClassLoader().loadClass(clazz);
+            factory.addMessageBodyReader(provider);
          }
-         catch (ClassNotFoundException e)
+         catch (Exception e)
          {
-            throw new RuntimeException(e);
+            throw new RuntimeException(""Unable to instantiate MessageBodyReader"", e);
          }
-         if (MessageBodyReader.class.isAssignableFrom(provider))
+      }
+      if (MessageBodyWriter.class.isAssignableFrom(provider))
+      {
+         try
          {
-            try
-            {
-               factory.addMessageBodyReader((MessageBodyReader) provider.newInstance());
-            }
-            catch (Exception e)
-            {
-               throw new RuntimeException(""Unable to instantiate MessageBodyReader"", e);
-            }
+            factory.addMessageBodyWriter(provider);
          }
-         if (MessageBodyWriter.class.isAssignableFrom(provider))
+         catch (Exception e)
          {
-            try
-            {
-               factory.addMessageBodyWriter((MessageBodyWriter) provider.newInstance());
-            }
-            catch (Exception e)
-            {
-               throw new RuntimeException(""Unable to instantiate MessageBodyWriter"", e);
-            }
+            throw new RuntimeException(""Unable to instantiate MessageBodyWriter"", e);
          }
       }
    }
@@ -205,18 +209,7 @@ protected void setProviders(String providers)
       for (String provider : p)
       {
          provider = provider.trim();
-         Object obj = null;
-         try
-         {
-            Class prov = Thread.currentThread().getContextClassLoader().loadClass(provider);
-            obj = prov.newInstance();
-         }
-         catch (Exception e)
-         {
-            throw new RuntimeException(e);
-         }
-         if (obj instanceof MessageBodyReader) factory.addMessageBodyReader((MessageBodyReader) obj);
-         if (obj instanceof MessageBodyWriter) factory.addMessageBodyWriter((MessageBodyWriter) obj);
+         registerProvider(provider);
       }
    }
 ",2008-03-25T20:39:56Z,52
"@@ -4,7 +4,10 @@
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
+import java.io.UnsupportedEncodingException;
 import java.net.URI;
+import java.net.URL;
+import java.net.URLDecoder;
 import java.util.List;
 
 /**
@@ -15,6 +18,7 @@ public class UriInfoImpl implements UriInfo
 {
    private String path;
    private MultivaluedMap<String, String> queryParameters;
+   private MultivaluedMap<String, String> encodedQueryParameters;
    private MultivaluedMap<String, String> templateParameters;
    private List<PathSegment> pathSegments;
    private URI absolutePath;
@@ -23,13 +27,17 @@ public class UriInfoImpl implements UriInfo
    private MultivaluedMap<String, PathSegment> pathParamSegments = new MultivaluedMapImpl<String, PathSegment>();
    private String queryString;
 
-   public static void main(String[] args)
+   public static void main(String[] args) throws Exception
    {
-      String val = ""http://foo.com/hello/world/dude"";
-      val = val.substring(0, val.indexOf(""world/dude""));
-      System.out.print(val);
+      URL url = new URL(""http://localhost.com/foo bar/junk"");
+      System.out.println(url.toURI());
    }
 
+   /**
+    * @param absolutePath
+    * @param path         decoded equivalent to HttpServletRequest.getPathInfo()
+    * @param queryString  encoded query string of request
+    */
    public UriInfoImpl(URI absolutePath, String path, String queryString)
    {
       this(absolutePath, path, queryString, PathSegmentImpl.parseSegments(path));
@@ -40,6 +48,8 @@ public UriInfoImpl(URI absolutePath, String path, String queryString, List<PathS
       this.path = path;
       this.absolutePath = absolutePath;
       this.queryParameters = new MultivaluedMapImpl<String, String>();
+      this.encodedQueryParameters = new MultivaluedMapImpl<String, String>();
+      extractParameters(queryString);
       this.templateParameters = new MultivaluedMapImpl<String, String>();
       this.pathSegments = pathSegments;
       this.queryString = queryString;
@@ -148,7 +158,8 @@ public MultivaluedMap<String, String> getQueryParameters()
 
    public MultivaluedMap<String, String> getQueryParameters(boolean decode)
    {
-      throw new RuntimeException(""NOT IMPLEMENTED"");
+      if (decode) return queryParameters;
+      else return encodedQueryParameters;
    }
 
    public List<String> getAncestorResourceURIs()
@@ -160,4 +171,43 @@ public List<Object> getAncestorResources()
    {
       throw new RuntimeException(""NOT IMPLEMENTED"");
    }
+
+   protected void extractParameters(String queryString)
+   {
+      if (queryString == null || queryString.equals("""")) return;
+
+      String[] params = queryString.split(""&"");
+
+      for (String param : params)
+      {
+         if (param.indexOf('=') >= 0)
+         {
+            String[] nv = param.split(""="");
+            try
+            {
+               String name = URLDecoder.decode(nv[0], ""UTF-8"");
+               encodedQueryParameters.add(name, nv[1]);
+               queryParameters.add(name, URLDecoder.decode(nv[1], ""UTF-8""));
+            }
+            catch (UnsupportedEncodingException e)
+            {
+               throw new RuntimeException(e);
+            }
+         }
+         else
+         {
+            try
+            {
+               String name = URLDecoder.decode(param, ""UTF-8"");
+               encodedQueryParameters.add(name, """");
+               queryParameters.add(name, """");
+            }
+            catch (UnsupportedEncodingException e)
+            {
+               throw new RuntimeException(e);
+            }
+         }
+      }
+   }
+
 }",2008-03-25T20:39:56Z,4
"@@ -1,7 +1,6 @@
 package org.resteasy.spi;
 
 import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.UriInfo;
 import java.io.InputStream;
 
@@ -19,7 +18,5 @@ public interface HttpRequest
 
    UriInfo getUri();
 
-   MultivaluedMap<String, String> getParameters();
-
    String getHttpMethod();
 }",2008-03-25T20:39:56Z,5
"@@ -24,8 +24,10 @@
 import javax.ws.rs.ext.MessageBodyWriter;
 import javax.ws.rs.ext.RuntimeDelegate;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -37,9 +39,48 @@
  */
 public class ResteasyProviderFactory extends RuntimeDelegate
 {
+   /**
+    * Allow us to sort message body implementations that are more specific for their types
+    * i.e. MessageBodyWriter<Object> is less specific than MessageBodyWriter<String>.
+    * <p/>
+    * This helps out a lot when the desired media type is a wildcard and to weed out all the possible
+    * default mappings.
+    */
+   private static class MessageBodyKey<T> implements Comparable<MessageBodyKey<T>>
+   {
+      public Class<? extends T> readerClass;
+      public T obj;
+
+      boolean isGeneric = false;
+
+      private MessageBodyKey(Class<? extends T> readerClass, T reader)
+      {
+         this.readerClass = readerClass;
+         this.obj = reader;
+         Type impls = readerClass.getGenericInterfaces()[0];
+         if (impls instanceof ParameterizedType)
+         {
+            ParameterizedType param = (ParameterizedType) impls;
+            if (param.getActualTypeArguments()[0].equals(Object.class)) isGeneric = true;
+         }
+         else
+         {
+            isGeneric = true;
+         }
+      }
+
+      public int compareTo(MessageBodyKey<T> tMessageBodyKey)
+      {
+         if (this == tMessageBodyKey) return 0;
+         if (isGeneric == tMessageBodyKey.isGeneric) return 0;
+         if (isGeneric) return 1;
+         return -1;
+      }
+   }
+
 
-   private MediaTypeMap<MessageBodyReader> messageBodyReaders = new MediaTypeMap<MessageBodyReader>();
-   private MediaTypeMap<MessageBodyWriter> messageBodyWriters = new MediaTypeMap<MessageBodyWriter>();
+   private MediaTypeMap<MessageBodyKey<MessageBodyReader>> messageBodyReaders = new MediaTypeMap<MessageBodyKey<MessageBodyReader>>();
+   private MediaTypeMap<MessageBodyKey<MessageBodyWriter>> messageBodyWriters = new MediaTypeMap<MessageBodyKey<MessageBodyWriter>>();
    private Map<Class<?>, HeaderDelegate> headerDelegates = new HashMap<Class<?>, HeaderDelegate>();
 
    private static AtomicReference<ResteasyProviderFactory> pfr = new AtomicReference<ResteasyProviderFactory>();
@@ -122,61 +163,133 @@ public void addHeaderDelegate(Class clazz, HeaderDelegate header)
       headerDelegates.put(clazz, header);
    }
 
+   public void addMessageBodyReader(Class<? extends MessageBodyReader> provider)
+   {
+      ConsumeMime consumeMime = provider.getAnnotation(ConsumeMime.class);
+      MessageBodyReader reader = null;
+      try
+      {
+         reader = provider.newInstance();
+      }
+      catch (InstantiationException e)
+      {
+         throw new RuntimeException(e);
+      }
+      catch (IllegalAccessException e)
+      {
+         throw new RuntimeException(e);
+      }
+      MessageBodyKey<MessageBodyReader> key = new MessageBodyKey<MessageBodyReader>(provider, reader);
+      if (consumeMime != null)
+      {
+         for (String consume : consumeMime.value())
+         {
+            MediaType mime = MediaType.parse(consume);
+            messageBodyReaders.add(mime, key);
+         }
+      }
+      else
+      {
+         messageBodyReaders.add(new MediaType(""*"", ""*""), key);
+      }
+   }
+
    public void addMessageBodyReader(MessageBodyReader provider)
    {
       ConsumeMime consumeMime = provider.getClass().getAnnotation(ConsumeMime.class);
+      MessageBodyKey<MessageBodyReader> key = new MessageBodyKey<MessageBodyReader>(provider.getClass(), provider);
+      if (consumeMime != null)
+      {
+         for (String consume : consumeMime.value())
+         {
+            MediaType mime = MediaType.parse(consume);
+            messageBodyReaders.add(mime, key);
+         }
+      }
+      else
+      {
+         messageBodyReaders.add(new MediaType(""*"", ""*""), key);
+      }
+   }
+
+   public void addMessageBodyWriter(Class<? extends MessageBodyWriter> provider)
+   {
+      ProduceMime consumeMime = provider.getAnnotation(ProduceMime.class);
+      MessageBodyWriter writer = null;
+      try
+      {
+         writer = provider.newInstance();
+      }
+      catch (InstantiationException e)
+      {
+         throw new RuntimeException(e);
+      }
+      catch (IllegalAccessException e)
+      {
+         throw new RuntimeException(e);
+      }
+      MessageBodyKey<MessageBodyWriter> key = new MessageBodyKey<MessageBodyWriter>(provider, writer);
       if (consumeMime != null)
       {
          for (String consume : consumeMime.value())
          {
             MediaType mime = MediaType.parse(consume);
-            messageBodyReaders.add(mime, provider);
+            messageBodyWriters.add(mime, key);
          }
       }
       else
       {
-         messageBodyReaders.add(new MediaType(""*"", ""*""), provider);
+         messageBodyWriters.add(new MediaType(""*"", ""*""), key);
       }
    }
 
    public void addMessageBodyWriter(MessageBodyWriter provider)
    {
-      ProduceMime produceMime = provider.getClass().getAnnotation(ProduceMime.class);
-      if (produceMime != null)
+      ProduceMime consumeMime = provider.getClass().getAnnotation(ProduceMime.class);
+      MessageBodyKey<MessageBodyWriter> key = new MessageBodyKey<MessageBodyWriter>(provider.getClass(), provider);
+      if (consumeMime != null)
       {
-         for (String produce : produceMime.value())
+         for (String consume : consumeMime.value())
          {
-            MediaType mime = MediaType.parse(produce);
-            messageBodyWriters.add(mime, provider);
+            MediaType mime = MediaType.parse(consume);
+            messageBodyWriters.add(mime, key);
          }
       }
       else
       {
-         messageBodyWriters.add(new MediaType(""*"", ""*""), provider);
+         messageBodyWriters.add(new MediaType(""*"", ""*""), key);
       }
    }
 
    public <T> MessageBodyReader<T> createMessageBodyReader(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)
    {
-      List<MessageBodyReader> readers = messageBodyReaders.getPossible(mediaType);
-      for (MessageBodyReader reader : readers)
+      List<MessageBodyKey<MessageBodyReader>> readers = messageBodyReaders.getPossible(mediaType);
+
+      // if the desired media type is */* then sort the readers by their parameterized type to weed out less generic types
+      // This helps with default mappings
+      if (mediaType.isWildcardType()) Collections.sort(readers);
+      for (MessageBodyKey<MessageBodyReader> reader : readers)
       {
-         if (reader.isReadable(type, genericType, annotations))
+         if (reader.obj.isReadable(type, genericType, annotations))
          {
-            return (MessageBodyReader<T>) reader;
+            return (MessageBodyReader<T>) reader.obj;
          }
       }
       return null;
    }
 
    public <T> MessageBodyWriter<T> createMessageBodyWriter(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)
    {
-      List<MessageBodyWriter> writers = messageBodyWriters.getPossible(mediaType);
-      for (MessageBodyWriter writer : writers)
+      List<MessageBodyKey<MessageBodyWriter>> writers = messageBodyWriters.getPossible(mediaType);
+      // if the desired media type is */* then sort the readers by their parameterized type to weed out less generic types
+      // This helps with default mappings
+      if (mediaType.isWildcardType()) Collections.sort(writers);
+      for (MessageBodyKey<MessageBodyWriter> writer : writers)
       {
-         if (writer.isWriteable(type, genericType, annotations))
+         System.out.println(""matching: "" + writer.obj.getClass());
+         if (writer.obj.isWriteable(type, genericType, annotations))
          {
-            return (MessageBodyWriter<T>) writer;
+            return (MessageBodyWriter<T>) writer.obj;
          }
       }
       return null;",2008-03-25T20:39:56Z,25
"@@ -3,7 +3,6 @@
 import org.resteasy.spi.HttpRequest;
 
 import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.UriInfo;
 import java.io.InputStream;
 
@@ -16,16 +15,14 @@ public class HttpRequestImpl implements HttpRequest
    protected HttpHeaders httpHeaders;
    protected InputStream inputStream;
    protected UriInfo uri;
-   protected MultivaluedMap<String, String> parameters;
    protected String httpMethod;
 
-   public HttpRequestImpl(InputStream inputStream, HttpHeaders httpHeaders, String httpMethod, UriInfo uri, MultivaluedMap<String, String> parameters)
+   public HttpRequestImpl(InputStream inputStream, HttpHeaders httpHeaders, String httpMethod, UriInfo uri)
    {
       this.inputStream = inputStream;
       this.httpHeaders = httpHeaders;
       this.httpMethod = httpMethod;
       this.uri = uri;
-      this.parameters = parameters;
    }
 
    public HttpHeaders getHttpHeaders()
@@ -43,11 +40,6 @@ public UriInfo getUri()
       return uri;
    }
 
-   public MultivaluedMap<String, String> getParameters()
-   {
-      return parameters;
-   }
-
    public String getHttpMethod()
    {
       return httpMethod;",2008-03-25T20:39:56Z,65
"@@ -0,0 +1,90 @@
+package org.resteasy.test.regression;
+
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.NameValuePair;
+import org.apache.commons.httpclient.methods.PostMethod;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.resteasy.spi.Dispatcher;
+import org.resteasy.test.EmbeddedContainer;
+import org.resteasy.util.HttpResponseCodes;
+
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.core.StreamingOutput;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class FormUrlEncodedTest
+{
+   private static Dispatcher dispatcher;
+
+   @BeforeClass
+   public static void before() throws Exception
+   {
+      dispatcher = EmbeddedContainer.start();
+      dispatcher.getRegistry().addResource(SimpleResource.class);
+   }
+
+   @AfterClass
+   public static void after() throws Exception
+   {
+      EmbeddedContainer.stop();
+   }
+
+   public static class SimpleResource
+   {
+      @Path(""/simple"")
+      @POST
+      public StreamingOutput post(@QueryParam(""hello"")String abs, InputStream entityStream) throws IOException
+      {
+         Assert.assertNull(abs);
+         final InputStream is = entityStream;
+         return new StreamingOutput()
+         {
+            public void write(OutputStream output) throws IOException
+            {
+               System.out.println(""WITHIN STREAMING OUTPUT!!!!"");
+               int c;
+               while ((c = is.read()) != -1)
+               {
+                  output.write(c);
+               }
+            }
+         };
+      }
+
+   }
+
+   @Test
+   public void testPost()
+   {
+      HttpClient client = new HttpClient();
+      {
+         PostMethod method = new PostMethod(""http://localhost:8081/simple"");
+         NameValuePair[] params = {new NameValuePair(""hello"", ""world"")};
+         method.setRequestBody(params);
+         try
+         {
+            int status = client.executeMethod(method);
+            Assert.assertEquals(status, HttpResponseCodes.SC_OK);
+            String body = method.getResponseBodyAsString();
+            Assert.assertEquals(""hello=world"", body);
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(e);
+         }
+      }
+
+   }
+
+}",2008-03-25T20:39:56Z,219
"@@ -46,6 +46,7 @@ public void putBasic(String body)
    @ProduceMime(""text/plain"")
    public String getQueryParam(@QueryParam(""param"")String param)
    {
+      System.out.println(""query param: "" + param);
       return param;
    }
 ",2008-03-25T20:39:56Z,220
"@@ -12,6 +12,7 @@
 import org.resteasy.spi.ResteasyProviderFactory;
 
 import javax.servlet.http.HttpServletResponse;
+import java.net.URLEncoder;
 
 /**
  * Simple smoke test
@@ -63,7 +64,7 @@ public void testNoDefaultsResource() throws Exception
       {
          MockHttpServletRequest request = new MockHttpServletRequest(""GET"", ""/queryParam"");
          request.setPathInfo(""/queryParam"");
-         request.addParameter(""param"", ""hello world"");
+         request.setQueryString(""param="" + URLEncoder.encode(""hello world"", ""UTF-8""));
          MockHttpServletResponse response = new MockHttpServletResponse();
 
          servlet.invoke(request, response);
@@ -125,7 +126,7 @@ public void testLocatingResource() throws Exception
       {
          MockHttpServletRequest request = new MockHttpServletRequest(""GET"", ""/locating/queryParam"");
          request.setPathInfo(""/locating/queryParam"");
-         request.addParameter(""param"", ""hello world"");
+         request.setQueryString(""param="" + URLEncoder.encode(""hello world"", ""UTF-8""));
          MockHttpServletResponse response = new MockHttpServletResponse();
 
          servlet.invoke(request, response);",2008-03-25T20:39:56Z,221
"@@ -116,8 +116,11 @@ public interface InputPart
 <programlisting>
 public interface MultipartFormDataInput extends MultipartInput
 {
+   @Deprecated
    Map&lt;String, InputPart&gt; getFormData();
 
+   Map&lt;String, List&lt;InputPart&gt;&gt; getFormDataMap();
+
    &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType) throws IOException;
 
    &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
@@ -147,6 +150,34 @@ public interface MultipartFormDataInput extends MultipartInput
    }
 
 </programlisting>
+   </sect2>
+   <sect2 id=""MultipartRelated"">
+      <title>Input with multipart/related</title>
+      <para>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in
+      multipart/related mime type. A multipart/related is used to indicate that message parts
+      should not be considered individually but rather as parts of an aggregate whole. One example
+      usage for multipart/related is to send a web page complete with images in a single message.
+      Every multipart/related message has a root/start part that references the other parts of the message.
+      The parts are identified by their ""Content-ID"" headers. multipart/related is defined by RFC 2387.
+      The interface used for related input is org.jboss.resteasy.plugins.providers.multipart.MultipartRelatedInput</para>
+<programlisting>
+public interface MultipartRelatedInput extends MultipartInput
+{
+   String getType();
+
+   String getStart();
+
+   String getStartInfo();
+
+   InputPart getRootPart();
+
+   Map&lt;String, InputPart&gt; getRelatedMap();
+}
+</programlisting>
+      <para>
+         It works in much the same way as MultipartInput described earlier in this chapter.
+      </para>
+
    </sect2>
    <sect2 id=""multipart_output"">
       <title>Output with multipart</title>
@@ -292,6 +323,67 @@ public class MultipartFormDataOutput extends MultipartOutput
       }
    }
 
+</programlisting>
+   </sect2>
+   <sect2 id=""multipart_related_output"">
+      <title>Output with multipart/related</title>
+      <para>RESTEasy provides a simple API to output multipart/related.</para>
+<programlisting><![CDATA[
+package org.jboss.resteasy.plugins.providers.multipart;
+
+public class MultipartRelatedOutput extends MultipartOutput
+{
+   public OutputPart getRootPart()
+
+   public OutputPart addPart(Object entity, MediaType mediaType,
+      String contentId, String contentTransferEncoding)
+
+   public String getStartInfo()
+
+   public void setStartInfo(String startInfo)
+}
+]]>
+</programlisting>
+      <para>When you want to output multipart/related it is as simple as creating a MultipartRelatedOutput object
+      and calling addPart() methods. The first added part will be used as the root part of the multipart/related
+      message.
+      Resteasy will automatically find a MessageBodyWriter to marshall your entity objects. Like MultipartInput,
+      sometimes you may have marshalling which is sensitive to generic type metadata. In that case, use
+      GenericType.  Most of the time though passing in an Object and its MediaType is enough.  In the example
+      below, we are sending back a ""multipart/related"" format back to the calling client. We are sending a
+      html with 2 images.</para>
+<programlisting>
+@Path(""/related"")
+public class MyService
+{
+   @GET
+   @Produces(""multipart/related"")
+   public MultipartRelatedOutput get()
+   {
+      MultipartRelatedOutput output = new MultipartRelatedOutput();
+      output.setStartInfo(""text/html"");
+
+      Map&lt;String, String&gt; mediaTypeParameters = new LinkedHashMap&lt;String, String&gt;();
+      mediaTypeParameters.put(""charset"", ""UTF-8"");
+      mediaTypeParameters.put(""type"", ""text/html"");
+      output
+         .addPart(
+            ""&lt;html&gt;&lt;body&gt;\n""
+            + ""This is me: &lt;img src='cid:http://example.org/me.png' /&gt;\n""
+            + ""&lt;br /&gt;This is you: &lt;img src='cid:http://example.org/you.png' /&gt;\n""
+            + ""&lt;/body&gt;&lt;/html&gt;"",
+            new MediaType(""text"", ""html"", mediaTypeParameters),
+            ""&lt;mymessage.xml@example.org&gt;"", ""8bit"");
+      output.addPart(""// binary octets for me png"",
+            new MediaType(""image"", ""png""), ""&lt;http://example.org/me.png&gt;"",
+            ""binary"");
+      output.addPart(""// binary octets for you png"", new MediaType(
+            ""image"", ""png""),
+            ""&lt;http://example.org/you.png&gt;"", ""binary"");
+      client.putRelated(output);
+      return output;
+   }
+}
 </programlisting>
    </sect2>
    <sect2 id=""multipartform_annotation"">
@@ -359,4 +451,76 @@ public class MultipartFormDataOutput extends MultipartOutput
    }
 </programlisting>
    </sect2>
+   <sect2 id=""xop_with_multipart_related"">
+      <title>XML-binary Optimized Packaging (Xop)</title>
+      <para>RESTEasy supports Xop messages packaged as multipart/related. What does this mean? If you have a JAXB
+      annotated POJO that also holds some binary content you may choose to send it in such a way where the binary
+      does not need to be encoded in any way (neither base64 neither hex). This results in faster transport while
+      still using the convenient POJO. More about Xop can be read here:
+      <link linkend=""http://www.w3.org/TR/xop10/"">http://www.w3.org/TR/xop10/</link>. Now lets see an example:</para>
+      <para>First we have a JAXB annotated POJO to work with. @XmlMimeType tells JAXB the mime type of the binary
+      content (its not required to do XOP packaging but it is recommended to be set if you know the exact type):</para>
+<programlisting>
+@XmlRootElement
+@XmlAccessorType(XmlAccessType.FIELD)
+public static class Xop {
+  private Customer bill;
+
+  private Customer monica;
+
+  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
+  private byte[] myBinary;
+
+  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
+  private DataHandler myDataHandler;
+
+  // methods, other fields ...
+}
+</programlisting>
+      <para>In the above POJO myBinary and myDataHandler will be processed as binary attachments while the whole Xop
+      object will be sent as xml (in the places of the binaries only their references will be generated).
+      javax.activation.DataHandler is the most general supported type so if you need an java.io.InputStream or a
+      javax.activation.DataSource you need to go with the DataHandler. Some other special types are supported too:
+      java.awt.Image and javax.xml.transform.Source. Let's assume that Customer is also JAXB friendly POJO in the
+      above example (of course it can also have binary parts). Now lets see a an example Java client that sends this:</para>
+<programlisting>
+// our client interface:
+@Path(""mime"")
+public static interface MultipartClient {
+  @Path(""xop"")
+  @PUT
+  @Consumes(MediaType.MULTIPART_RELATED)
+  public void putXop(@XopWithMultipartRelated Xop bean);
+}
+
+// Somewhere using it:
+{
+  MultipartClient client = ProxyFactory.create(MultipartClient.class,
+    ""http://www.example.org"");
+  Xop xop = new Xop(new Customer(""bill""), new Customer(""monica""),
+    ""Hello Xop World!"".getBytes(""UTF-8""),
+    new DataHandler(new ByteArrayDataSource(""Hello Xop World!"".getBytes(""UTF-8""),
+    MediaType.APPLICATION_OCTET_STREAM)));
+  client.putXop(xop);
+}
+</programlisting>
+	<para>We used @Consumes(MediaType.MULTIPART_RELATED) to tell RESTEasy that we want to send multipart/related
+	packages (thats the container format that will hold our Xop message). We used @XopWithMultipartRelated to tell
+	RESTEasy that we want to make Xop messages. So we have a POJO and a client service that is willing to send it. All
+	we need now a server that can read it:</para>
+<programlisting>
+@Path(""/mime"")
+public class XopService {
+  @PUT
+  @Path(""xop"")
+  @Consumes(MediaType.MULTIPART_RELATED)
+  public void putXopWithMultipartRelated(@XopWithMultipartRelated Xop xop) {
+    // do very important things here
+  }
+}
+</programlisting>
+	<para>We used @Consumes(MediaType.MULTIPART_RELATED) to tell RESTEasy that we want to read multipart/related
+	packages. We used @XopWithMultipartRelated to tell RESTEasy that we want to read Xop messages. Of course we could
+	also produce Xop return values but we would than also need to annotate that and use a Produce annotation, too.</para>
+   </sect2>
 </sect1>
\ No newline at end of file",2009-06-09T21:58:34Z,222
"@@ -0,0 +1,38 @@
+package org.jboss.resteasy.annotations.providers.jaxb;
+
+import org.jboss.resteasy.annotations.Decorator;
+import org.jboss.resteasy.plugins.providers.jaxb.StylesheetProcessor;
+
+import javax.xml.bind.Marshaller;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies an XML stylesheet header
+ * <p/>
+ * e.g.
+ * <p/>
+ * <pre>
+ * <?xml-stylesheet type='text/xsl' href='foobar.xsl' ?>
+ * </pre>
+ * <p/>
+ * You can use replacement expressions in value string.
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.util.StringContextReplacement
+ */
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
+@Retention(RetentionPolicy.RUNTIME)
+@Decorator(processor = StylesheetProcessor.class, target = Marshaller.class)
+public @interface Stylesheet
+{
+   public static final String XSL = ""text/xsl"";
+   public static final String CSS = ""text/css"";
+
+   String href();
+
+   String type();
+}",2009-06-11T00:05:50Z,223
"@@ -0,0 +1,27 @@
+package org.jboss.resteasy.annotations.providers.jaxb;
+
+import org.jboss.resteasy.annotations.Decorator;
+import org.jboss.resteasy.plugins.providers.jaxb.XmlHeaderProcessor;
+
+import javax.xml.bind.Marshaller;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Sets an XML header for the returned document.
+ * <p/>
+ * You can use replacement expressions in value string.
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.util.StringContextReplacement
+ */
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
+@Retention(RetentionPolicy.RUNTIME)
+@Decorator(processor = XmlHeaderProcessor.class, target = Marshaller.class)
+public @interface XmlHeader
+{
+   String value();
+}",2009-06-11T00:05:50Z,224
"@@ -6,6 +6,7 @@
  */
 package org.jboss.resteasy.plugins.providers.jaxb;
 
+import org.jboss.resteasy.core.interception.DecoratorMatcher;
 import org.jboss.resteasy.plugins.providers.AbstractEntityProvider;
 import org.jboss.resteasy.util.TypeConverter;
 
@@ -53,6 +54,18 @@ public JAXBContext findJAXBContext(Class<?> type, Annotation[] annotations, Medi
       return finder.findCachedContext(type, mediaType, annotations);
    }
 
+   public static Marshaller decorateMarshaller(Class type, Annotation[] annotations, MediaType mediaType, Marshaller marshaller) throws JAXBException
+   {
+      DecoratorMatcher processor = new DecoratorMatcher();
+      return processor.decorate(Marshaller.class, marshaller, type, annotations, mediaType);
+   }
+
+   public static Unmarshaller decorateUnmarshaller(Class type, Annotation[] annotations, MediaType mediaType, Unmarshaller marshaller) throws JAXBException
+   {
+      DecoratorMatcher processor = new DecoratorMatcher();
+      return processor.decorate(Unmarshaller.class, marshaller, type, annotations, mediaType);
+   }
+
    /**
     *
     */
@@ -67,6 +80,7 @@ public T readFrom(Class<T> type,
       {
          JAXBContext jaxb = findJAXBContext(type, annotations, mediaType, true);
          Unmarshaller unmarshaller = jaxb.createUnmarshaller();
+         unmarshaller = decorateUnmarshaller(type, annotations, mediaType, unmarshaller);
          return (T) unmarshaller.unmarshal(new StreamSource(entityStream));
       }
       catch (JAXBException e)
@@ -90,6 +104,7 @@ public void writeTo(T t,
       try
       {
          Marshaller marshaller = getMarshaller(type, annotations, mediaType);
+         marshaller = decorateMarshaller(type, annotations, mediaType, marshaller);
          marshaller.marshal(t, outputStream);
       }
       catch (JAXBException e)",2009-06-11T00:05:50Z,225
"@@ -120,6 +120,7 @@ public Object readFrom(Class<Object> type, Type genericType, Annotation[] annota
       {
          JAXBContext ctx = finder.findCachedContext(baseType, mediaType, null);
          Unmarshaller unmarshaller = ctx.createUnmarshaller();
+         unmarshaller = AbstractJAXBProvider.decorateUnmarshaller(baseType, annotations, mediaType, unmarshaller);
          if (type.isArray())
          {
             Object array = Array.newInstance(baseType, col.getValue().size());
@@ -215,6 +216,7 @@ public void writeTo(Object entry, Class<?> type, Type genericType, Annotation[]
 
          JAXBElement<JaxbCollection> collection = new JAXBElement<JaxbCollection>(new QName(namespaceURI, element, prefix), JaxbCollection.class, col);
          Marshaller marshaller = ctx.createMarshaller();
+         AbstractJAXBProvider.decorateMarshaller(baseType, annotations, mediaType, marshaller);
          marshaller.marshal(collection, entityStream);
       }
       catch (JAXBException e)",2009-06-11T00:05:50Z,226
"@@ -116,6 +116,7 @@ public Object readFrom(Class<Object> type, Type genericType, Annotation[] annota
          HashMap map = new HashMap();
 
          Unmarshaller unmarshaller = ctx.createUnmarshaller();
+         unmarshaller = AbstractJAXBProvider.decorateUnmarshaller(valueType, annotations, mediaType, unmarshaller);
 
          for (int i = 0; i < jaxbMap.getValue().size(); i++)
          {
@@ -204,6 +205,7 @@ public void writeTo(Object target, Class<?> type, Type genericType, Annotation[]
 
          JAXBElement<JaxbMap> jaxbMap = new JAXBElement<JaxbMap>(new QName(namespaceURI, mapName, prefix), JaxbMap.class, map);
          Marshaller marshaller = ctx.createMarshaller();
+         marshaller = AbstractJAXBProvider.decorateMarshaller(valueType, annotations, mediaType, marshaller);
          marshaller.marshal(jaxbMap, entityStream);
       }
       catch (JAXBException e)",2009-06-11T00:05:50Z,227
"@@ -0,0 +1,35 @@
+package org.jboss.resteasy.plugins.providers.jaxb;
+
+import org.jboss.resteasy.annotations.DecorateTypes;
+import org.jboss.resteasy.annotations.providers.jaxb.Stylesheet;
+import org.jboss.resteasy.core.interception.DecoratorProcessor;
+import org.jboss.resteasy.util.StringContextReplacement;
+
+import javax.ws.rs.core.MediaType;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.PropertyException;
+import java.lang.annotation.Annotation;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@DecorateTypes({""text/*+xml"", ""application/*+xml""})
+public class StylesheetProcessor implements DecoratorProcessor<Marshaller, Stylesheet>
+{
+   public Marshaller decorate(Marshaller target, Stylesheet annotation, Class type, Annotation[] annotations, MediaType mediaType)
+   {
+      String doctype = StringContextReplacement.replace(annotation.type());
+      String href = StringContextReplacement.replace(annotation.href());
+      String h = ""<?xml-stylesheet type='"" + doctype + ""' href='"" + href + ""' ?>"";
+      try
+      {
+         target.setProperty(""com.sun.xml.bind.xmlHeaders"", h);
+      }
+      catch (PropertyException e)
+      {
+         throw new RuntimeException(e);
+      }
+      return target;
+   }
+}
\ No newline at end of file",2009-06-11T00:05:50Z,228
"@@ -0,0 +1,33 @@
+package org.jboss.resteasy.plugins.providers.jaxb;
+
+import org.jboss.resteasy.annotations.DecorateTypes;
+import org.jboss.resteasy.annotations.providers.jaxb.XmlHeader;
+import org.jboss.resteasy.core.interception.DecoratorProcessor;
+import org.jboss.resteasy.util.StringContextReplacement;
+
+import javax.ws.rs.core.MediaType;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.PropertyException;
+import java.lang.annotation.Annotation;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@DecorateTypes({""text/*+xml"", ""application/*+xml""})
+public class XmlHeaderProcessor implements DecoratorProcessor<Marshaller, XmlHeader>
+{
+   public Marshaller decorate(Marshaller target, XmlHeader annotation, Class type, Annotation[] annotations, MediaType mediaType)
+   {
+      String h = StringContextReplacement.replace(annotation.value());
+      try
+      {
+         target.setProperty(""com.sun.xml.bind.xmlHeaders"", h);
+      }
+      catch (PropertyException e)
+      {
+         throw new RuntimeException(e);
+      }
+      return target;
+   }
+}",2009-06-11T00:05:50Z,229
"@@ -1,5 +1,6 @@
 package org.jboss.resteasy.plugins.providers.jaxb.json;
 
+import org.jboss.resteasy.plugins.providers.jaxb.AbstractJAXBProvider;
 import org.jboss.resteasy.plugins.providers.jaxb.CollectionProvider;
 import org.jboss.resteasy.plugins.providers.jaxb.JAXBContextFinder;
 import org.jboss.resteasy.plugins.providers.jaxb.JAXBMarshalException;
@@ -15,6 +16,7 @@
 import javax.ws.rs.ext.Provider;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -130,6 +132,8 @@ public void writeTo(Object entry, Class<?> type, Type genericType, Annotation[]
       try
       {
          JAXBContext ctx = finder.findCachedContext(baseType, mediaType, annotations);
+         Marshaller marshaller = ctx.createMarshaller();
+         marshaller = AbstractJAXBProvider.decorateMarshaller(baseType, annotations, mediaType, marshaller);
          if (type.isArray())
          {
             Object[] array = (Object[]) entry;
@@ -144,7 +148,7 @@ public void writeTo(Object entry, Class<?> type, Type genericType, Annotation[]
                {
                   entityStream.write(',');
                }
-               ctx.createMarshaller().marshal(obj, entityStream);
+               marshaller.marshal(obj, entityStream);
             }
          }
          else
@@ -161,7 +165,7 @@ public void writeTo(Object entry, Class<?> type, Type genericType, Annotation[]
                {
                   entityStream.write(',');
                }
-               ctx.createMarshaller().marshal(obj, entityStream);
+               marshaller.marshal(obj, entityStream);
             }
          }
          entityStream.write(']');",2009-06-11T00:05:50Z,230
"@@ -0,0 +1,137 @@
+package org.jboss.resteasy.test.providers.jaxb;
+
+import org.jboss.resteasy.annotations.DecorateTypes;
+import org.jboss.resteasy.annotations.Decorator;
+import org.jboss.resteasy.annotations.providers.jaxb.Stylesheet;
+import org.jboss.resteasy.annotations.providers.jaxb.XmlHeader;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.core.interception.DecoratorProcessor;
+import org.jboss.resteasy.test.BaseResourceTest;
+import static org.jboss.resteasy.test.TestPortProvider.*;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.lang.annotation.Annotation;
+
+/**
+ * This tests decorators in general as well as the @XmlHeader and @Stylesheet annotations
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class XmlHeaderTest extends BaseResourceTest
+{
+   /**
+    * Test correct type (Marshaller), but incorrect media type
+    */
+   @Decorator(processor = MyDecorator.class, target = Marshaller.class)
+   public static @interface Junk
+   {
+   }
+
+   @DecorateTypes(""application/json"")
+   public static class MyDecorator implements DecoratorProcessor<Marshaller, Junk>
+   {
+      public Marshaller decorate(Marshaller target, Junk annotation, Class type, Annotation[] annotations, MediaType mediaType)
+      {
+         throw new RuntimeException(""FAILURE!!!!"");
+      }
+   }
+
+   /**
+    * Test correct media type, but incorrect type
+    */
+   @Decorator(processor = MyDecorator.class, target = Assert.class)
+   public static @interface Junk2
+   {
+   }
+
+   @DecorateTypes(""application/xml"")
+   public static class MyDecorator2 implements DecoratorProcessor<Assert, Junk2>
+   {
+      public Assert decorate(Assert target, Junk2 annotation, Class type, Annotation[] annotations, MediaType mediaType)
+      {
+         throw new RuntimeException(""FAILURE!!!!"");
+      }
+   }
+
+   @XmlRootElement
+   @Junk
+   @Junk2
+   public static class Thing
+   {
+      private String name;
+
+      public String getName()
+      {
+         return name;
+      }
+
+      public void setName(String name)
+      {
+         this.name = name;
+      }
+   }
+
+   @Path(""/test"")
+   public static class TestService
+   {
+
+      @GET
+      @Path(""/header"")
+      @Produces(""application/xml"")
+      @XmlHeader(""<?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?>"")
+      public Thing get()
+      {
+         Thing thing = new Thing();
+         thing.setName(""bill"");
+         return thing;
+      }
+
+      @GET
+      @Path(""/stylesheet"")
+      @Produces(""application/xml"")
+      @Stylesheet(type = ""text/css"", href = ""${basepath}foo.xsl"")
+      @Junk
+      public Thing getStyle()
+      {
+         Thing thing = new Thing();
+         thing.setName(""bill"");
+         return thing;
+      }
+   }
+
+   @Before
+   public void setUp() throws Exception
+   {
+      addPerRequestResource(TestService.class);
+   }
+
+   @Test
+   public void testHeader() throws Exception
+   {
+      ClientRequest request = new ClientRequest(generateURL(""/test/header""));
+      String response = request.getTarget(String.class);
+      System.out.println(response);
+      Assert.assertTrue(response.contains(""<?xml-stylesheet""));
+
+   }
+
+   @Test
+   public void testStylesheet() throws Exception
+   {
+      ClientRequest request = new ClientRequest(generateURL(""/test/stylesheet""));
+      String response = request.getTarget(String.class);
+      System.out.println(response);
+      Assert.assertTrue(response.contains(""<?xml-stylesheet""));
+
+   }
+
+}",2009-06-11T00:05:50Z,231
"@@ -0,0 +1,21 @@
+package org.jboss.resteasy.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Must be placed on a DecoratorProcessor class to specify the supported types
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.core.interception.DecoratorProcessor
+ * @see org.jboss.resteasy.annotations.Decorator
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DecorateTypes
+{
+   String[] value();
+}",2009-06-11T00:05:50Z,232
"@@ -0,0 +1,25 @@
+package org.jboss.resteasy.annotations;
+
+import org.jboss.resteasy.core.interception.DecoratorProcessor;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Meta-annotation to be placed on another annotation that triggers decoration
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.core.interception.DecoratorProcessor
+ * @see org.jboss.resteasy.annotations.DecorateTypes
+ */
+@Target({ElementType.ANNOTATION_TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Decorator
+{
+   Class<? extends DecoratorProcessor> processor();
+
+   Class<?> target();
+}",2009-06-11T00:05:50Z,233
"@@ -1,24 +1,5 @@
 package org.jboss.resteasy.client;
 
-import static org.jboss.resteasy.util.HttpHeaderNames.ACCEPT;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import javax.ws.rs.core.Cookie;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.MultivaluedMap;
-import javax.ws.rs.core.UriBuilder;
-import javax.ws.rs.ext.MessageBodyWriter;
-import javax.ws.rs.ext.RuntimeDelegate;
-
 import org.apache.commons.httpclient.HttpClient;
 import org.jboss.resteasy.client.core.BaseClientResponse;
 import org.jboss.resteasy.client.core.ClientInterceptorRepositoryImpl;
@@ -31,10 +12,27 @@
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.spi.StringConverter;
 import org.jboss.resteasy.util.GenericType;
+import static org.jboss.resteasy.util.HttpHeaderNames.*;
+
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.UriBuilder;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.RuntimeDelegate;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 
 /**
  * Create a hand coded request to send to the server.
- * 
+ *
  * @author <a href=""mailto:sduskis@gmail.com"">Solomon Duskis</a>
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
@@ -77,25 +75,26 @@ public ClientRequest(String uriTemplate, ClientExecutor executor)
    }
 
    public ClientRequest(String uriTemplate, HttpClient httpClient,
-         ResteasyProviderFactory providerFactory)
+                        ResteasyProviderFactory providerFactory)
    {
       this(getBuilder(uriTemplate), new ApacheHttpClientExecutor(httpClient),
-            providerFactory);
+              providerFactory);
    }
 
-   public ClientRequest(UriBuilder uri, ClientExecutor executor){
+   public ClientRequest(UriBuilder uri, ClientExecutor executor)
+   {
       this(uri, executor, ResteasyProviderFactory.getInstance());
    }
 
    public ClientRequest(UriBuilder uri, ClientExecutor executor,
-         ResteasyProviderFactory providerFactory)
+                        ResteasyProviderFactory providerFactory)
    {
       this.uri = (UriBuilderImpl) uri;
       this.executor = executor;
       if (providerFactory instanceof ProviderFactoryDelegate)
       {
          this.providerFactory = ((ProviderFactoryDelegate) providerFactory)
-               .getDelegate();
+                 .getDelegate();
       }
       else
       {
@@ -141,7 +140,7 @@ protected String toString(Object object)
       if (object instanceof String)
          return (String) object;
       StringConverter converter = providerFactory.getStringConverter(object
-            .getClass());
+              .getClass());
       if (converter != null)
          return converter.toString(object);
       else
@@ -152,12 +151,12 @@ protected String toString(Object object)
    protected String toHeaderString(Object object)
    {
       StringConverter converter = providerFactory.getStringConverter(object
-            .getClass());
+              .getClass());
       if (converter != null)
          return converter.toString(object);
 
       RuntimeDelegate.HeaderDelegate delegate = providerFactory
-            .createHeaderDelegate(object.getClass());
+              .createHeaderDelegate(object.getClass());
       if (delegate != null)
          return delegate.toString(object);
       else
@@ -217,7 +216,7 @@ public ClientRequest pathParameters(Object... values)
    public ClientRequest body(String contentType, Object data)
    {
       return body(MediaType.valueOf(contentType), data, data.getClass(), null,
-            null);
+              null);
    }
 
    public ClientRequest body(MediaType contentType, Object data)
@@ -226,20 +225,20 @@ public ClientRequest body(MediaType contentType, Object data)
    }
 
    public ClientRequest body(MediaType contentType, Object data,
-         GenericType genericType)
+                             GenericType genericType)
    {
       return body(contentType, data, genericType.getType(), genericType
-            .getGenericType(), null);
+              .getGenericType(), null);
    }
 
    public ClientRequest body(MediaType contentType, Object data,
-         Type genericType)
+                             Type genericType)
    {
       return body(contentType, data, data.getClass(), genericType, null);
    }
 
    public ClientRequest body(MediaType contentType, Object data, Class type,
-         Type genericType, Annotation[] annotations)
+                             Type genericType, Annotation[] annotations)
    {
       this.body = data;
       this.bodyContentType = contentType;
@@ -340,13 +339,13 @@ public ClientResponse execute() throws Exception
    {
       if (getReaderInterceptorList().isEmpty())
          setReaderInterceptors(providerFactory
-               .getClientMessageBodyReaderInterceptorRegistry().bindForList(
-                     null, null));
+                 .getClientMessageBodyReaderInterceptorRegistry().bindForList(
+                 null, null));
 
       if (getExecutionInterceptorList().isEmpty())
       {
          setExecutionInterceptors(providerFactory
-               .getClientExecutionInterceptorRegistry().bindForList(null, null));
+                 .getClientExecutionInterceptorRegistry().bindForList(null, null));
       }
 
       BaseClientResponse response = null;
@@ -357,15 +356,15 @@ public ClientResponse execute() throws Exception
       else
       {
          ClientExecutionContextImpl ctx = new ClientExecutionContextImpl(
-               getExecutionInterceptorList(), executor, this);
+                 getExecutionInterceptorList(), executor, this);
          response = (BaseClientResponse) ctx.proceed();
       }
       response.setMessageBodyReaderInterceptors(getReaderInterceptors());
       return response;
    }
 
    public void writeRequestBody(MultivaluedMap<String, Object> headers,
-         OutputStream outputStream) throws IOException
+                                OutputStream outputStream) throws IOException
    {
       if (body == null)
       {
@@ -375,27 +374,41 @@ public void writeRequestBody(MultivaluedMap<String, Object> headers,
       if (getWriterInterceptorList().isEmpty())
       {
          setWriterInterceptors(providerFactory
-               .getClientMessageBodyWriterInterceptorRegistry().bindForList(
-                     null, null));
+                 .getClientMessageBodyWriterInterceptorRegistry().bindForList(
+                 null, null));
       }
       MessageBodyWriter writer = providerFactory
-            .getMessageBodyWriter(bodyType, bodyGenericType,
-                  bodyAnnotations, bodyContentType);
+              .getMessageBodyWriter(bodyType, bodyGenericType,
+                      bodyAnnotations, bodyContentType);
       if (writer == null)
       {
          throw new RuntimeException(""could not find writer for content-type ""
-               + bodyContentType + "" type: "" + bodyType.getName());
+                 + bodyContentType + "" type: "" + bodyType.getName());
       }
       new MessageBodyWriterContextImpl(getWriterInterceptors(), writer, body,
-            bodyType, bodyGenericType, bodyAnnotations, bodyContentType,
-            headers, outputStream).proceed();
+              bodyType, bodyGenericType, bodyAnnotations, bodyContentType,
+              headers, outputStream).proceed();
    }
 
    public ClientResponse get() throws Exception
    {
       return httpMethod(""GET"");
    }
 
+   /**
+    * Tries to automatically unmarshal to target type.
+    *
+    * @param returnType
+    * @param <T>
+    * @return
+    * @throws Exception
+    */
+   public <T> T getTarget(Class<T> returnType) throws Exception
+   {
+      BaseClientResponse<T> response = (BaseClientResponse<T>) get(returnType);
+      return response.getEntity();
+   }
+
    public <T> ClientResponse<T> get(Class<T> returnType) throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) get();
@@ -404,7 +417,7 @@ public <T> ClientResponse<T> get(Class<T> returnType) throws Exception
    }
 
    public <T> ClientResponse<T> get(Class<T> returnType, Type genericType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) get();
       response.setReturnType(returnType);
@@ -438,7 +451,7 @@ public <T> ClientResponse<T> put(Class<T> returnType) throws Exception
    }
 
    public <T> ClientResponse<T> put(Class<T> returnType, Type genericType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) put();
       response.setReturnType(returnType);
@@ -467,7 +480,7 @@ public <T> ClientResponse<T> post(Class<T> returnType) throws Exception
    }
 
    public <T> ClientResponse<T> post(Class<T> returnType, Type genericType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) post();
       response.setReturnType(returnType);
@@ -496,7 +509,7 @@ public <T> ClientResponse<T> delete(Class<T> returnType) throws Exception
    }
 
    public <T> ClientResponse<T> delete(Class<T> returnType, Type genericType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) delete();
       response.setReturnType(returnType);
@@ -525,7 +538,7 @@ public <T> ClientResponse<T> options(Class<T> returnType) throws Exception
    }
 
    public <T> ClientResponse<T> options(Class<T> returnType, Type genericType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) options();
       response.setReturnType(returnType);
@@ -548,15 +561,15 @@ public ClientResponse httpMethod(String httpMethod) throws Exception
    }
 
    public <T> ClientResponse<T> httpMethod(String method, Class<T> returnType)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) httpMethod(method);
       response.setReturnType(returnType);
       return response;
    }
 
    public <T> ClientResponse<T> httpmethod(String method, Class<T> returnType,
-         Type genericType) throws Exception
+                                           Type genericType) throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) httpMethod(method);
       response.setReturnType(returnType);
@@ -565,7 +578,7 @@ public <T> ClientResponse<T> httpmethod(String method, Class<T> returnType,
    }
 
    public <T> ClientResponse<T> httpMethod(String method, GenericType type)
-         throws Exception
+           throws Exception
    {
       BaseClientResponse response = (BaseClientResponse) httpMethod(method);
       response.setReturnType(type.getType());
@@ -581,7 +594,7 @@ public void overrideUri(URI uri)
    /**
     * This method populates all path, matrix, and query parameters and saves it
     * internally. Once its called once it returns the cached value.
-    * 
+    *
     * @return
     * @throws Exception
     */
@@ -595,7 +608,7 @@ public String getUri() throws Exception
       if (matrixParameters != null)
       {
          for (Map.Entry<String, List<String>> entry : matrixParameters
-               .entrySet())
+                 .entrySet())
          {
             List<String> values = entry.getValue();
             for (String value : values)
@@ -605,7 +618,7 @@ public String getUri() throws Exception
       if (queryParameters != null)
       {
          for (Map.Entry<String, List<String>> entry : queryParameters
-               .entrySet())
+                 .entrySet())
          {
             List<String> values = entry.getValue();
             for (String value : values)",2009-06-11T00:05:50Z,48
"@@ -1,15 +1,5 @@
 package org.jboss.resteasy.client.core;
 
-import static java.lang.String.format;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.MultivaluedMap;
-
 import org.jboss.resteasy.client.ClientResponse;
 import org.jboss.resteasy.client.ClientResponseFailure;
 import org.jboss.resteasy.core.interception.MessageBodyReaderInterceptor;
@@ -19,6 +9,14 @@
 import org.jboss.resteasy.util.HttpHeaderNames;
 import org.jboss.resteasy.util.HttpResponseCodes;
 
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.io.InputStream;
+import static java.lang.String.*;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
@@ -29,6 +27,7 @@ public class BaseClientResponse<T> extends ClientResponse<T>
    public static interface BaseClientResponseStreamFactory
    {
       InputStream getInputStream() throws IOException;
+
       void performReleaseConnection();
    }
 
@@ -38,7 +37,7 @@ public static interface BaseClientResponseStreamFactory
    protected String alternateMediaType;
    protected Class<?> returnType;
    protected Type genericReturnType;
-   protected Annotation[] annotations;
+   protected Annotation[] annotations = {};
    protected int status;
    protected boolean wasReleased = false;
    protected boolean streamWasRead = false;
@@ -52,7 +51,7 @@ public BaseClientResponse(BaseClientResponseStreamFactory streamFactory)
    {
       this.streamFactory = streamFactory;
    }
-   
+
    public void setMessageBodyReaderInterceptors(MessageBodyReaderInterceptor[] messageBodyReaderInterceptors)
    {
       this.messageBodyReaderInterceptors = messageBodyReaderInterceptors;
@@ -165,7 +164,7 @@ public <T2> T2 getEntity(Class<T2> type, Type genericType)
    private <T2> Annotation[] getAnnotations(Class<T2> type, Type genericType)
    {
       return (this.returnType == type && this.genericReturnType == genericType) ? this.annotations
-            : null;
+              : null;
    }
 
    @Override
@@ -177,22 +176,22 @@ public <T2> T2 getEntity(Class<T2> type, Type genericType, Annotation[] anns)
                  + attributeExceptionsTo, exception);
       }
 
-      if (unmarshaledEntity != null && !type.isInstance(this.unmarshaledEntity)) 
+      if (unmarshaledEntity != null && !type.isInstance(this.unmarshaledEntity))
          throw new RuntimeException(""The entity was already read, and it was of type ""
                  + unmarshaledEntity.getClass());
 
       if (unmarshaledEntity == null)
       {
          try
          {
-            if (status == HttpResponseCodes.SC_NO_CONTENT) 
+            if (status == HttpResponseCodes.SC_NO_CONTENT)
                return null;
-   
-           unmarshaledEntity = readFrom(type, genericType, getMediaType(), anns);
+
+            unmarshaledEntity = readFrom(type, genericType, getMediaType(), anns);
          }
          finally
          {
-            if(!InputStream.class.isAssignableFrom(type))
+            if (!InputStream.class.isAssignableFrom(type))
                releaseConnection();
          }
       }
@@ -211,25 +210,25 @@ protected MediaType getMediaType()
    }
 
    protected <T2> Object readFrom(Class<T2> type, Type genericType,
-         MediaType media, Annotation[] annotations)
+                                  MediaType media, Annotation[] annotations)
    {
       try
       {
          ReaderUtility reader = new ReaderUtility(providerFactory,
-               messageBodyReaderInterceptors)
+                 messageBodyReaderInterceptors)
          {
             @Override
             public RuntimeException createReaderNotFound(Type genericType,
-                  MediaType mediaType)
+                                                         MediaType mediaType)
             {
                return createResponseFailure(format(
-                     ""Unable to find a MessageBodyReader of content-type %s and type %s"",
-                     mediaType, genericType));
+                       ""Unable to find a MessageBodyReader of content-type %s and type %s"",
+                       mediaType, genericType));
             }
          };
          return reader.doRead(type, genericType == null ? type : genericType,
-               media, this.annotations, getHeaders(), streamFactory
-                     .getInputStream());
+                 media, this.annotations, getHeaders(), streamFactory
+                         .getInputStream());
       }
       catch (IOException e)
       {
@@ -303,13 +302,13 @@ public boolean wasReleased()
 
    public final void releaseConnection()
    {
-      if(!wasReleased)
+      if (!wasReleased)
       {
          streamFactory.performReleaseConnection();
          wasReleased = true;
       }
    }
-      
+
    @Override
    protected final void finalize() throws Throwable
    {",2009-06-11T00:05:50Z,30
"@@ -0,0 +1,98 @@
+package org.jboss.resteasy.core.interception;
+
+import org.jboss.resteasy.annotations.DecorateTypes;
+import org.jboss.resteasy.annotations.Decorator;
+import org.jboss.resteasy.core.MediaTypeMap;
+
+import javax.ws.rs.core.MediaType;
+import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Finds DecoratorProcessors and calls decorates on them by introspecting annotations.
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ * @see org.jboss.resteasy.core.interception.DecoratorProcessor
+ * @see org.jboss.resteasy.annotations.DecorateTypes
+ * @see org.jboss.resteasy.annotations.Decorator
+ */
+public class DecoratorMatcher
+{
+   /**
+    * @param targetClass i.e. Marshaller
+    * @param target
+    * @param type        i.e. a JAXB annotated class
+    * @param annotations i.e. method or parameter annotations
+    * @param mediaType
+    * @param <T>
+    * @return
+    */
+   public <T> T decorate(Class<T> targetClass, T target, Class type, Annotation[] annotations, MediaType mediaType)
+   {
+      HashMap<Class<?>, Annotation> meta = new HashMap<Class<?>, Annotation>();
+      if (type != null)
+      {
+         for (Annotation annotation : type.getAnnotations())
+         {
+            if (annotation.annotationType().isAnnotationPresent(Decorator.class))
+            {
+               meta.put(annotation.annotationType(), annotation);
+            }
+         }
+      }
+      // override any class level ones
+      if (annotations != null)
+      {
+         for (Annotation annotation : annotations)
+         {
+            Decorator decorator = annotation.annotationType().getAnnotation(Decorator.class);
+            if (decorator != null && targetClass.isAssignableFrom(decorator.target()))
+            {
+               meta.put(annotation.annotationType(), annotation);
+            }
+         }
+      }
+      if (meta.size() == 0) return target;
+
+      MediaTypeMap<Class<?>> typeMap = new MediaTypeMap<Class<?>>();
+      for (Class<?> decoratorAnnotation : meta.keySet())
+      {
+         Decorator decorator = decoratorAnnotation.getAnnotation(Decorator.class);
+         String[] mediaTypes = {""*/*""};
+         DecorateTypes produces = decorator.processor().getAnnotation(DecorateTypes.class);
+         if (produces != null)
+         {
+            mediaTypes = produces.value();
+         }
+         for (String pType : mediaTypes)
+         {
+            typeMap.add(MediaType.valueOf(pType), decoratorAnnotation);
+         }
+      }
+
+      List<Class<?>> list = typeMap.getPossible(mediaType);
+      for (Class<?> decoratorAnnotation : list)
+      {
+         Annotation annotation = meta.get(decoratorAnnotation);
+         Decorator decorator = decoratorAnnotation.getAnnotation(Decorator.class);
+         DecoratorProcessor processor = null;
+         try
+         {
+            processor = decorator.processor().newInstance();
+         }
+         catch (InstantiationException e)
+         {
+            throw new RuntimeException(e.getCause());
+         }
+         catch (IllegalAccessException e)
+         {
+            throw new RuntimeException(e);
+         }
+         target = (T) processor.decorate(target, annotation, type, annotations, mediaType);
+      }
+
+      return target;
+   }
+}",2009-06-11T00:05:50Z,49
"@@ -0,0 +1,25 @@
+package org.jboss.resteasy.core.interception;
+
+import javax.ws.rs.core.MediaType;
+import java.lang.annotation.Annotation;
+
+/**
+ * Part of a generic decorator framework.
+ * <p/>
+ * Decorate a target.  For example, decorate a JAXB Marshaller with property values.
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public interface DecoratorProcessor<T, A extends Annotation>
+{
+   /**
+    * @param target      i.e. a Marshaller instance
+    * @param annotation  the annotation that triggered the decorator
+    * @param type
+    * @param annotations
+    * @param mediaType
+    * @return should never return null
+    */
+   T decorate(T target, A annotation, Class type, Annotation[] annotations, MediaType mediaType);
+}",2009-06-11T00:05:50Z,234
"@@ -0,0 +1,66 @@
+package org.jboss.resteasy.util;
+
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.core.UriInfo;
+import java.util.regex.Pattern;
+
+/**
+ * Utility to replace predefined expressions within a string with  values from the HTTP request;
+ * <p/>
+ * ${basepath} - UriInfo.getBaseUri().getRawPath()
+ * ${absolutepath} - UriInfo.getAbsolutePath().getRawPath()
+ * ${absoluteuri} - UriInfo.getAbsolutePath().toString()
+ * ${baseuri} - UriInfo.getBaseUri().toString()
+ * ${contextpath} - HttpServletRequest.getContextPath()
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class StringContextReplacement
+{
+   private static final Pattern basepath = Pattern.compile(""\\$\\{basepath\\}"");
+   private static final Pattern absolutepath = Pattern.compile(""\\$\\{absolutepath\\}"");
+   private static final Pattern absoluteUri = Pattern.compile(""\\$\\{absoluteuri\\}"");
+   private static final Pattern baseUri = Pattern.compile(""\\$\\{baseuri\\}"");
+   private static final Pattern contextPath = Pattern.compile(""\\$\\{contextpath\\}"");
+
+   /**
+    * Utility to replace predefined expressions within a string with values from the HTTP request;
+    * <p/>
+    * ${basepath} - UriInfo.getBaseUri().getRawPath()
+    * ${absolutepath} - UriInfo.getAbsolutePath().getRawPath()
+    * ${absoluteuri} - UriInfo.getAbsolutePath().toString()
+    * ${baseuri} - UriInfo.getBaseUri().toString()
+    * ${contextpath} - HttpServletRequest.getContextPath()
+    *
+    * @param original
+    * @return
+    */
+   public static String replace(String original)
+   {
+      UriInfo uriInfo = ResteasyProviderFactory.getContextData(UriInfo.class);
+      if (uriInfo != null)
+      {
+         String base = uriInfo.getBaseUri().getRawPath();
+         String abs = uriInfo.getAbsolutePath().getRawPath();
+         String absU = uriInfo.getAbsolutePath().toString();
+         String baseU = uriInfo.getBaseUri().toString();
+
+         original = basepath.matcher(original).replaceAll(base);
+         original = absolutepath.matcher(original).replaceAll(abs);
+         original = absoluteUri.matcher(original).replaceAll(absU);
+         original = baseUri.matcher(original).replaceAll(baseU);
+
+      }
+      HttpServletRequest request = ResteasyProviderFactory.getContextData(HttpServletRequest.class);
+      if (request != null)
+      {
+         original = contextPath.matcher(original).replaceAll(request.getContextPath());
+
+      }
+      return original;
+   }
+
+}",2009-06-11T00:05:50Z,235
"@@ -3,11 +3,10 @@
 import org.jboss.resteasy.spi.AsyncOutputStream;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import reactor.core.publisher.EmitterProcessor;
 import reactor.core.publisher.Flux;
-import reactor.core.publisher.FluxSink;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoProcessor;
+import reactor.core.publisher.Sinks;
+import reactor.core.publisher.Sinks.EmitFailureHandler;
 import reactor.netty.http.server.HttpServerRequest;
 import reactor.netty.http.server.HttpServerResponse;
 import reactor.util.function.Tuple2;
@@ -33,39 +32,42 @@ public class ChunkOutputStream extends AsyncOutputStream {
 
    private final ReactorNettyHttpResponse parentResponse;
 
-    /**
-     * This is the {@link Mono} that we return from
-     * {@link ReactorNettyJaxrsServer.Handler#handle(HttpServerRequest, HttpServerResponse)}
-     */
-   private final MonoProcessor<Void> completionMono;
+   /**
+    * This is the {@link Mono} that we return from
+    * {@link ReactorNettyJaxrsServer.Handler#handle(HttpServerRequest, HttpServerResponse)}
+    */
+   private final Sinks.Empty<Void> completionSink;
 
-    /**
-     * Indicates that we've starting sending the response bytes.
-     */
-    private volatile boolean started;
+   /**
+    * Indicates that we've starting sending the response bytes.
+    */
+   private volatile boolean started;
 
-    /**
-     * This is ultimately think 'sink' that we write bytes to in {@link #asyncWrite(byte[], int, int)}.
-     */
-    private FluxSink<Tuple2<byte[], CompletableFuture<Void>>> byteSink;
+   /**
+    * This is ultimately think 'sink' that we write bytes to in
+    * {@link #asyncWrite(byte[], int, int)}.
+    */
+   private Sinks.Many<Tuple2<byte[], CompletableFuture<Void>>> byteSink;
 
-    /**
-     * This is used to establish {@link #byteSink} upon the first writing of bytes.
-     */
-   private final Supplier<FluxSink<Tuple2<byte[], CompletableFuture<Void>>>> byteSinkSupplier;
+   /**
+    * This is used to establish {@link #byteSink} upon the first writing of bytes.
+    */
+   private final Supplier<Sinks.Many<Tuple2<byte[], CompletableFuture<Void>>>> byteSinkSupplier;
+
+   private static final EmitFailureHandler EMIT_FAILURE_HANDLER = EmitFailureHandler.FAIL_FAST;
 
    ChunkOutputStream(
        final ReactorNettyHttpResponse parentResponse,
        final HttpServerResponse reactorNettyResponse,
-       final MonoProcessor<Void> completionMono
+       final Sinks.Empty<Void> completionSink
    ) {
        this.parentResponse = Objects.requireNonNull(parentResponse);
-       this.completionMono = Objects.requireNonNull(completionMono);
+       this.completionSink = Objects.requireNonNull(completionSink);
        Objects.requireNonNull(reactorNettyResponse);
        this.byteSinkSupplier = () -> {
            log.trace(""Creating FluxSink for output."");
-           final EmitterProcessor<Tuple2<byte[], CompletableFuture<Void>>> bytesEmitter = EmitterProcessor.create();
-           final Flux<byte[]> byteFlux = bytesEmitter.map(tup -> {
+           final Sinks.Many<Tuple2<byte[], CompletableFuture<Void>>> outSink = Sinks.many().multicast().onBackpressureBuffer();
+           final Flux<byte[]> byteFlux = outSink.asFlux().map(tup -> {
                    log.trace(""Submitting bytes to downstream"");
                    tup.getT2().complete(null);
                    return tup.getT1();
@@ -76,23 +78,25 @@ public class ChunkOutputStream extends AsyncOutputStream {
                        log.trace(""Subscription on Flux<byte[]> occurred: {}"", s);
                    })
                .doFinally(s -> log.trace(""Flux<byte[]> closing with signal: {}"", s));
-           reactorNettyResponse.sendByteArray(byteFlux).subscribe(completionMono);
-           return bytesEmitter.sink();
+
+           SinkSubscriber.subscribe(completionSink, Mono.from(reactorNettyResponse.sendByteArray(byteFlux)));
+
+           return outSink;
        };
    }
 
    @Override
    public void write(int b) {
-      byteSink.next(Tuples.of(new byte[] {(byte)b}, new CompletableFuture<>()));
+      byteSink.emitNext(Tuples.of(new byte[] {(byte)b}, new CompletableFuture<>()), EMIT_FAILURE_HANDLER);
    }
 
    @Override
    public void close() throws IOException {
        log.trace(""Closing the ChunkOutputStream."");
        if (!started || byteSink == null) {
-           Mono.<Void>empty().subscribe(completionMono);
+           SinkSubscriber.subscribe(completionSink, Mono.<Void>empty());
        } else {
-           byteSink.complete();
+           byteSink.emitComplete(EMIT_FAILURE_HANDLER);
        }
    }
 
@@ -147,7 +151,7 @@ public CompletableFuture<Void> asyncFlush() {
        return CompletableFuture.completedFuture(null);
    }
 
-    @Override
+   @Override
    public CompletableFuture<Void> asyncWrite(final byte[] bs, int offset, int length) {
         final CompletableFuture<Void> cf = new CompletableFuture<>();
         if (!started) {
@@ -161,7 +165,7 @@ public CompletableFuture<Void> asyncWrite(final byte[] bs, int offset, int lengt
             bytes = Arrays.copyOfRange(bs, offset, offset + length);
         }
         log.trace(""Sending bytes to the sink"");
-        byteSink.next(Tuples.of(bytes, cf));
+        byteSink.emitNext(Tuples.of(bytes, cf), EMIT_FAILURE_HANDLER);
         return cf;
    }
 }",2021-04-19T16:27:19Z,439
"@@ -9,7 +9,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoProcessor;
+import reactor.core.publisher.Sinks;
 import reactor.netty.http.server.HttpServerResponse;
 
 import javax.ws.rs.core.MultivaluedMap;
@@ -34,17 +34,17 @@ public class ReactorNettyHttpResponse implements HttpResponse {
     private final HttpServerResponse resp;
     private OutputStream out;
     private boolean committed;
-    private final MonoProcessor<Void> completionMono;
+    private final Sinks.Empty<Void> completionSink;
 
     public ReactorNettyHttpResponse(
         final HttpMethod method,
         final HttpServerResponse resp,
-        final MonoProcessor<Void> completionMono
+        final Sinks.Empty<Void> completionSink
     ) {
         this.resp = resp;
-        this.completionMono = completionMono;
+        this.completionSink = completionSink;
         if (method == null || !method.equals(HttpMethod.HEAD)) {
-            this.out = new ChunkOutputStream(this, resp, completionMono);
+            this.out = new ChunkOutputStream(this, resp, completionSink);
         } else {
             // Not entirely sure this is the best way to handle this..
             resp.responseHeaders().remove(HttpHeaderNames.TRANSFER_ENCODING);
@@ -237,23 +237,33 @@ public void addNewCookie(NewCookie cookie)
 
     @Override
     public void sendError(int status) {
-        log.trace(""Sending error"");
-        resp.status(status)
+
+        log.trace(""Sending error. Status: {}."", status);
+
+        final Mono<Void> respMono = resp.status(status)
             .header(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO)
-            .then().subscribe(completionMono);
+            .then();
+
         committed = true;
+        SinkSubscriber.subscribe(completionSink, respMono);
+        committed();
+
     }
 
     @Override
     public void sendError(int status, String message) {
-        log.trace(""Sending error: "" + message);
-        resp.status(status)
+
+        log.trace(""Sending error. Status: {}. Message: {}"", status, message);
+
+        final Mono<Void> respMono = resp.status(status)
             .header(HttpHeaderNames.CONTENT_LENGTH, Integer.toString(message.length()))
             .header(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN)
             .sendString(Mono.just(message))
-            .then()
-            .subscribe(completionMono);
+            .then();
+
+        SinkSubscriber.subscribe(completionSink, respMono);
         committed();
+
     }
 
     @Override
@@ -281,7 +291,7 @@ public void close() throws IOException {
             out.flush();
             out.close();
         } else {
-            Mono.<Void>empty().subscribe(completionMono);
+            SinkSubscriber.subscribe(completionSink, Mono.<Void>empty());
         }
     }
 
@@ -290,4 +300,5 @@ public void flushBuffer() throws IOException {
         log.trace(""Flushing response buffer!"");
         out.flush();
     }
+
 }",2021-04-19T16:27:19Z,440
"@@ -34,12 +34,12 @@
 import io.netty.handler.timeout.IdleStateHandler;
 import reactor.core.Exceptions;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoProcessor;
+import reactor.core.publisher.Sinks;
+import reactor.netty.Connection;
 import reactor.netty.DisposableServer;
 import reactor.netty.http.server.HttpServer;
 import reactor.netty.http.server.HttpServerRequest;
 import reactor.netty.http.server.HttpServerResponse;
-import reactor.netty.tcp.TcpServer;
 
 /**
  * A server adapter built on top of <a
@@ -91,18 +91,17 @@ public ReactorNettyJaxrsServer start() {
       log.info(""Starting RestEasy Reactor-based server!"");
       serverHelper.checkDeployment(deployment);
 
-      String appPath = serverHelper.checkAppDeployment(deployment);
+      final String appPath = serverHelper.checkAppDeployment(deployment);
       if (appPath != null && (root == null || """".equals(root))) {
          setRootResourcePath(appPath);
       }
 
       final Handler handler = new Handler();
 
-      HttpServer svrBuilder = HttpServer
-          .create()
-          .tcpConfiguration(this::configure)
-          .port(configuredPort)
-          .handle(handler::handle);
+      HttpServer svrBuilder = HttpServer.create()
+              .doOnConnection(this::configure)
+              .port(configuredPort)
+              .handle(handler::handle);
 
       if (sslContext != null) {
          svrBuilder = svrBuilder.secure(sslContextSpec -> sslContextSpec.sslContext(toNettySSLContext(sslContext)));
@@ -152,12 +151,12 @@ Publisher<Void> handle(final HttpServerRequest req, final HttpServerResponse res
          // don't know if that's configurable or not..
 
          // This is a subscription tied to the completion writing the response.
-         final MonoProcessor<Void> completionMono = MonoProcessor.create();
+         final Sinks.Empty<Void> completionSink = Sinks.empty();
 
          final AtomicBoolean isTimeoutSet = new AtomicBoolean(false);
 
          final ReactorNettyHttpResponse resteasyResp =
-             new ReactorNettyHttpResponse(req.method(), resp, completionMono);
+             new ReactorNettyHttpResponse(req.method(), resp, completionSink);
 
          return req.receive()
              .aggregate()
@@ -210,9 +209,9 @@ Publisher<Void> handle(final HttpServerRequest req, final HttpServerResponse res
                 final Mono<Void> actualMono = Optional.ofNullable(resteasyReq.timeout())
                     .map(timeout -> {
                        isTimeoutSet.set(true);
-                       return completionMono.timeout(resteasyReq.timeout());
+                       return completionSink.asMono().timeout(resteasyReq.timeout());
                     })
-                    .orElse(completionMono);
+                    .orElse(completionSink.asMono());
 
                 log.trace(""Returning completion signal mono from main Flux."");
                 return actualMono
@@ -235,12 +234,13 @@ Publisher<Void> handle(final HttpServerRequest req, final HttpServerResponse res
                    } else {
                       sendMono = resp.status(500).send();
                    }
-                   sendMono.subscribe(completionMono);
+                   SinkSubscriber.subscribe(completionSink, sendMono);
+
                 } else {
                    log.debug(""Omitting sending back error response. Response is already committed."");
                 }
 
-                return completionMono;
+                return completionSink.asMono();
              })
              .doOnError(err -> log.error(""Request processing err."", err))
              .doFinally(s -> log.trace(""Request processing finished with: {}"", s))
@@ -355,27 +355,24 @@ public ReactorNettyJaxrsServer setCleanUpTasks(final List<Runnable> cleanUpTasks
       return this;
    }
 
-   private TcpServer configure(final TcpServer baseServer)
+   private void configure(final Connection conn)
    {
       if (idleTimeout != null) {
-         return baseServer.doOnConnection(conn -> {
-            final long idleNanos = idleTimeout.toNanos();
-            // TODO, why can't I use reactor-netty methods for this??
-            conn.channel().pipeline().addFirst(""idleStateHandler"", new IdleStateHandler(0, 0, idleNanos, TimeUnit.NANOSECONDS));
-            conn.channel().pipeline().addAfter(""idleStateHandler"", ""idleEventHandler"", new ChannelDuplexHandler() {
-               @Override
-               public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
-                  if (evt instanceof IdleStateEvent) {
-                     IdleStateEvent e = (IdleStateEvent) evt;
-                     if (e.state() == IdleState.ALL_IDLE) {
-                        ctx.close();
-                     }
+         final long idleNanos = idleTimeout.toNanos();
+         // TODO, why can't I use reactor-netty methods for this??
+         conn.channel().pipeline().addFirst(""idleStateHandler"", new IdleStateHandler(0, 0, idleNanos, TimeUnit.NANOSECONDS));
+         conn.channel().pipeline().addAfter(""idleStateHandler"", ""idleEventHandler"", new ChannelDuplexHandler() {
+            @Override
+            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
+               if (evt instanceof IdleStateEvent) {
+                  IdleStateEvent e = (IdleStateEvent) evt;
+                  if (e.state() == IdleState.ALL_IDLE) {
+                     ctx.close();
                   }
                }
-            });
+            }
          });
-      }
-      return baseServer;
+       }
    }
 
    private SslContext toNettySSLContext(final SSLContext sslContext)
@@ -414,4 +411,5 @@ private ResteasyUriInfo extractUriInfo(final HttpServerRequest req, final String
 
       return new ResteasyUriInfo(uriString, contextPath);
    }
+
 }
\ No newline at end of file",2021-04-19T16:27:19Z,441
"@@ -0,0 +1,27 @@
+package org.jboss.resteasy.plugins.server.reactor.netty;
+
+import java.util.function.Consumer;
+import reactor.core.publisher.Mono;
+import reactor.core.publisher.Sinks;
+import reactor.core.publisher.Sinks.EmitFailureHandler;
+
+public class SinkSubscriber {
+
+    /**
+     * See {@link reactor.core.publisher.Mono#subscribe(Consumer, Consumer, Runnable)}
+     * @param sink - The sink that will consume signals emitted by the mono.
+     * @param mono - The mono to subscribe on.
+     */
+    public static void subscribe(Sinks.Empty<Void> sink, final Mono<Void> mono) {
+        mono.subscribe(
+            v -> {},
+            e -> sink.emitError(e, EmitFailureHandler.FAIL_FAST),
+            /**
+             * Ok not to check return value below because we're inside `subscribe` and the
+             * source is a Publisher<Void>.<br>
+             * See more in https://github.com/reactor/reactor-core/issues/2431
+             */
+            sink::tryEmitEmpty);
+    }
+
+}",2021-04-19T16:27:19Z,442
"@@ -145,4 +145,7 @@ public interface Messages
 
    @Message(id = BASE + 190, value = ""Parameter annotated with %s cannot be null"")
    String nullParameter(String annotation);
+
+   @Message(id = BASE + 191, value = ""Unable to load ClientConfigProvider configuration because uri is null"")
+   String unableToLoadClientConfigProviderConfiguration();
 }",2020-07-16T08:16:20Z,443
"@@ -1,13 +1,18 @@
 package org.jboss.resteasy.client.jaxrs.engines;
 
 import java.io.IOException;
+import java.net.Socket;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.SecureRandom;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
+import java.util.ServiceLoader;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SNIHostName;
 import javax.net.ssl.SNIServerName;
@@ -32,10 +37,13 @@
 import org.apache.http.impl.client.HttpClientBuilder;
 import org.apache.http.impl.conn.BasicHttpClientConnectionManager;
 import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpCoreContext;
 import org.apache.http.ssl.SSLContexts;
 import org.jboss.resteasy.client.jaxrs.ClientHttpEngine;
 import org.jboss.resteasy.client.jaxrs.ClientHttpEngineBuilder;
 import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
 
 public class ClientHttpEngineBuilder43 implements ClientHttpEngineBuilder {
 
@@ -77,6 +85,8 @@ public ClientHttpEngine build()
       {
          SSLConnectionSocketFactory sslsf = null;
          SSLContext theContext = that.getSSLContext();
+          Iterator clientConfigProviderIterator = ServiceLoader.load(ClientConfigProvider.class).iterator();
+
          if (that.isTrustManagerDisabled())
          {
             theContext = SSLContext.getInstance(""SSL"");
@@ -132,6 +142,26 @@ protected void prepareSocket(SSLSocket socket) throws IOException
                   }
                }
             };
+         } else if (clientConfigProviderIterator.hasNext())
+         {
+            // delegate creation of socket to ClientConfigProvider implementation
+            final ClientConfigProvider configProvider = ((ClientConfigProvider) clientConfigProviderIterator.next());
+            sslsf = new SSLConnectionSocketFactory(SSLContext.getDefault(), verifier) {
+               @Override
+               public Socket createSocket(HttpContext context) throws IOException {
+                  try {
+                     String targetHostUri = context.getAttribute(
+                             HttpCoreContext.HTTP_TARGET_HOST).toString();
+                     if (targetHostUri != null) {
+                        return configProvider.getSSLContext(new URI(targetHostUri)).getSocketFactory().createSocket();
+                     } else {
+                        throw new RuntimeException(""URI is not known"");
+                     }
+                  } catch (URISyntaxException e) {
+                     throw new RuntimeException(e);
+                  }
+               }
+            };
          }
          else
          {",2020-07-16T08:16:20Z,58
"@@ -0,0 +1,48 @@
+package org.jboss.resteasy.client.jaxrs.internal;
+
+import org.jboss.resteasy.client.jaxrs.i18n.LogMessages;
+import org.jboss.resteasy.client.jaxrs.i18n.Messages;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
+import org.jboss.resteasy.util.BasicAuthHelper;
+
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.core.HttpHeaders;
+import java.io.IOException;
+import java.net.URI;
+
+/**
+ * Client filter that will attach authorization header with either HTTP Basic auth or Bearer token auth.
+ * Credentials and token are loaded from ClientConfigProvider implementation.
+ *
+ * @author dvilkola@redhat.com
+ */
+public class ClientConfigProviderFilter implements ClientRequestFilter {
+
+    private final ClientConfigProvider clientConfigProvider;
+
+    public ClientConfigProviderFilter(final ClientConfigProvider clientConfigProvider) {
+        this.clientConfigProvider = clientConfigProvider;
+    }
+
+    @Override
+    public void filter(ClientRequestContext requestContext) throws IOException {
+        if (requestContext.getHeaderString(HttpHeaders.AUTHORIZATION) == null) {
+            URI uri = requestContext.getUri();
+            if (uri == null) {
+                LogMessages.LOGGER.warn(Messages.MESSAGES.unableToLoadClientConfigProviderConfiguration());
+                return;
+            }
+            String token = clientConfigProvider.getBearerToken(uri);
+            if (token != null) {
+                requestContext.getHeaders().putSingle(HttpHeaders.AUTHORIZATION, ""Bearer "" + token);
+            } else {
+                String username = clientConfigProvider.getUsername(uri);
+                String password = clientConfigProvider.getPassword(uri);
+                if (username != null && password != null) {
+                    requestContext.getHeaders().putSingle(HttpHeaders.AUTHORIZATION, BasicAuthHelper.createHeader(username, password));
+                }
+            }
+        }
+    }
+}",2020-07-16T08:16:20Z,444
"@@ -9,13 +9,15 @@
 import org.jboss.resteasy.client.jaxrs.engines.ClientHttpEngineBuilder43;
 import org.jboss.resteasy.client.jaxrs.i18n.LogMessages;
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
 import org.jboss.resteasy.core.providerfactory.ResteasyProviderFactoryDelegate;
 import org.jboss.resteasy.plugins.interceptors.AcceptEncodingGZIPFilter;
 import org.jboss.resteasy.plugins.providers.RegisterBuiltin;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.ws.rs.Priorities;
 import javax.ws.rs.RuntimeType;
 import javax.ws.rs.core.Configuration;
 
@@ -26,8 +28,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.ServiceLoader;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
@@ -395,6 +399,10 @@ public ResteasyClient build()
       if (resetProxy) {
          this.defaultProxy = null;
       }
+      Iterator<ClientConfigProvider> serviceLoaderIterator = ServiceLoader.load(ClientConfigProvider.class).iterator();
+      if (serviceLoaderIterator.hasNext()) {
+         config.register(new ClientConfigProviderFilter(serviceLoaderIterator.next()), Priorities.AUTHENTICATION);
+      }
       return createResteasyClient(engine, executor, cleanupExecutor, scheduledExecutorService, config);
 
    }",2020-07-16T08:16:20Z,262
"@@ -0,0 +1,23 @@
+package org.jboss.resteasy.client.jaxrs.spi;
+
+/**
+ * General client configuration exception
+ * @author dvilkola@redhat.com
+ */
+public class ClientConfigException extends RuntimeException {
+    public ClientConfigException() {
+        super();
+    }
+
+    public ClientConfigException(final String message) {
+        super(message);
+    }
+
+    public ClientConfigException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
+
+    public ClientConfigException(final Throwable cause) {
+        super(cause);
+    }
+}",2020-07-16T08:16:20Z,445
"@@ -0,0 +1,16 @@
+package org.jboss.resteasy.client.jaxrs.spi;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+
+/**
+ * Interface to enable loading of authentication configuration from outside.
+ * @author dvilkola@redhat.com
+ */
+public interface ClientConfigProvider {
+
+    String getUsername(URI uri) throws ClientConfigException;
+    String getPassword(URI uri) throws ClientConfigException;
+    String getBearerToken(URI uri) throws ClientConfigException;
+    SSLContext getSSLContext(URI uri) throws ClientConfigException;
+}",2020-07-16T08:16:20Z,446
"@@ -79,7 +79,6 @@
         <version.org.wildfly.extras.creaper>1.6.1</version.org.wildfly.extras.creaper>
         <version.org.wildfly.wildfly-arquillian-container-managed>2.2.0.Final</version.org.wildfly.wildfly-arquillian-container-managed>
         <version.org.wildfly.wildfly-arquillian-container-remote>2.2.0.Final</version.org.wildfly.wildfly-arquillian-container-remote>
-        <version.org.wildfly.security.wildfly-elytron>1.7.0.Final</version.org.wildfly.security.wildfly-elytron>
         <version.weld.api>3.0.SP4</version.weld.api>
         <version.weld>3.0.5.Final</version.weld>
         <version.json.patch>1.13</version.json.patch>
@@ -877,11 +876,6 @@
                 <artifactId>wildfly-cli</artifactId>
                 <version>${version.org.wildfly.core.wildfly-cli}</version>
             </dependency>
-            <dependency>
-                <groupId>org.wildfly.security</groupId>
-                <artifactId>wildfly-elytron</artifactId>
-                <version>${version.org.wildfly.security.wildfly-elytron}</version>
-            </dependency>
             <dependency>
                 <groupId>org.wildfly.arquillian</groupId>
                 <artifactId>wildfly-arquillian-container-managed</artifactId>",2020-07-16T08:16:20Z,247
"@@ -28,13 +28,6 @@
     </modules>
 
     <dependencies>
-        <!-- TODO Workaround dependency for arquillian to work with container using Remoting 5. Remove when updated version of
-        wildfly-arquillian-container-managed is available -->
-        <dependency>
-            <groupId>org.wildfly.security</groupId>
-            <artifactId>wildfly-elytron</artifactId>
-            <scope>test</scope>
-        </dependency>
 
         <dependency>
             <groupId>junit</groupId>",2020-07-16T08:16:20Z,398
"@@ -201,14 +201,6 @@
             <scope>test</scope>
         </dependency>
 
-        <!-- TODO Workaround dependency for arquillian to work with container using Remoting 5. Remove when updated version of
-        wildfly-arquillian-container-managed is available -->
-        <dependency>
-            <groupId>org.wildfly.security</groupId>
-            <artifactId>wildfly-elytron</artifactId>
-            <scope>test</scope>
-        </dependency>
-
         <dependency>
             <groupId>org.jboss.resteasy</groupId>
             <artifactId>arquillian-utils</artifactId>",2020-07-16T08:16:20Z,399
"@@ -43,6 +43,8 @@
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 
+import java.io.IOException;
+
 /**
  * @tpSubChapter Security
  * @tpChapter Integration tests
@@ -320,6 +322,33 @@ public void testWithClientRequestFilterUnauthorizedUser() {
         Assert.assertEquals(WRONG_RESPONSE, ACCESS_FORBIDDEN_MESSAGE, response.readEntity(String.class));
     }
 
+    /**
+     * @tpTestDetails Test that client correctly loads ClientConfigProvider implementation and uses credentials when making a request.
+     * Also test these credentials are ignored if different are set.
+     */
+    @Test
+    public void testClientConfigProviderCredentials() throws IOException {
+        String jarPath = ClientConfigProviderTestJarHelper.createClientConfigProviderTestJarWithBASIC();
+
+        Process process = ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(
+                ClientConfigProviderTestJarHelper.TestType.TEST_CREDENTIALS_ARE_USED_FOR_BASIC,
+                jarPath,
+                new String[]{generateURL(""/secured/authorized"")});
+        String line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+        Assert.assertEquals(""200"", line);
+        process.destroy();
+
+        process = ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(
+                ClientConfigProviderTestJarHelper.TestType.TEST_CLIENTCONFIG_CREDENTIALS_ARE_IGNORED_IF_DIFFERENT_SET,
+                jarPath,
+                new String[]{generateURL(""/secured/authorized"")});
+        line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+        Assert.assertEquals(""401"", line);
+        process.destroy();
+
+        Assert.assertTrue(new File(jarPath).delete());
+    }
+
     static class SecurityDomainSetup extends AbstractUsersRolesSecurityDomainSetup {
 
       @Override",2020-07-16T08:16:20Z,447
"@@ -0,0 +1,31 @@
+package org.jboss.resteasy.test.security;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * @tpSubChapter Security
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Test that Bearer token is correctly loaded from ClientConfigProvider impl and used for outgoing requests.
+ */
+public class ClientConfigProviderBearerTokenTest {
+
+    @Test
+    public void testClientConfigProviderBearerToken() throws IOException {
+        String jarPath = ClientConfigProviderTestJarHelper.createClientConfigProviderTestJarWithBearerToken();
+
+        Process process = ClientConfigProviderTestJarHelper.runClientConfigProviderBearerTestJar(ClientConfigProviderTestJarHelper.TestType.TEST_BEARER_TOKEN_IS_USED, jarPath);
+        String line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+        Assert.assertEquals(""200"", line);
+        process.destroy();
+
+        process = ClientConfigProviderTestJarHelper.runClientConfigProviderBearerTestJar(ClientConfigProviderTestJarHelper.TestType.TEST_BEARER_TOKEN_IGNORED_IF_BASIC_SET_BY_USER, jarPath);
+        line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+        Assert.assertEquals(""Credentials set by user had precedence"", line);
+        process.destroy();
+        Assert.assertTrue(new File(jarPath).delete());
+    }
+}",2020-07-16T08:16:20Z,448
"@@ -0,0 +1,160 @@
+package org.jboss.resteasy.test.security;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Objects;
+import java.util.jar.Attributes;
+import java.util.jar.JarEntry;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+
+/**
+ * Contains utility methods used for creating, running and getting results of jars meant to test ClientConfigProvider functionality.
+ */
+class ClientConfigProviderTestJarHelper {
+
+    enum TestType {
+        TEST_CREDENTIALS_ARE_USED_FOR_BASIC,
+        TEST_CLIENTCONFIG_CREDENTIALS_ARE_IGNORED_IF_DIFFERENT_SET,
+        TEST_SSLCONTEXT_USED,
+        TEST_CLIENTCONFIG_SSLCONTEXT_IGNORED_WHEN_DIFFERENT_SET,
+        TEST_BEARER_TOKEN_IS_USED,
+        TEST_BEARER_TOKEN_IGNORED_IF_BASIC_SET_BY_USER
+    }
+
+    private static class ConfigProviderProperties {
+        String mainClassName;
+        String mainClassCompiled;
+        String mainClassPath;
+        String mainClassWithPackage;
+        String mockedClientConfigProviderImplName;
+        String mockedClientConfigProviderImplClassPath;
+    }
+
+    private static final String PACKAGE_NAME = ""org.jboss.resteasy.test.security.testjar"";
+    private static final String PACKAGE_PATH = ""org/jboss/resteasy/test/security/testjar/"";
+    private static final String JAR_NAME = ""client-config-provider-test.jar"";
+
+    private static ConfigProviderProperties bearerJarConfigProperties = new ConfigProviderProperties();
+    private static ConfigProviderProperties basicAuthJarConfigProperties = new ConfigProviderProperties();
+    private static ConfigProviderProperties sslJarConfigProperties = new ConfigProviderProperties();
+
+    static {
+        basicAuthJarConfigProperties.mainClassName = ""ClientConfigTestMainClass"";
+        basicAuthJarConfigProperties.mainClassCompiled = basicAuthJarConfigProperties.mainClassName + "".class"";
+        basicAuthJarConfigProperties.mainClassPath = PACKAGE_PATH + basicAuthJarConfigProperties.mainClassCompiled;
+        basicAuthJarConfigProperties.mainClassWithPackage = PACKAGE_NAME + ""."" + basicAuthJarConfigProperties.mainClassCompiled;
+        basicAuthJarConfigProperties.mockedClientConfigProviderImplName = ""ClientConfigProviderImplCredentials"";
+        basicAuthJarConfigProperties.mockedClientConfigProviderImplClassPath = PACKAGE_PATH + basicAuthJarConfigProperties.mockedClientConfigProviderImplName + "".class"";
+
+        sslJarConfigProperties.mainClassName = ""ClientConfigTestMainClass"";
+        sslJarConfigProperties.mainClassCompiled = sslJarConfigProperties.mainClassName + "".class"";
+        sslJarConfigProperties.mainClassPath = PACKAGE_PATH + sslJarConfigProperties.mainClassCompiled;
+        sslJarConfigProperties.mainClassWithPackage = PACKAGE_NAME + ""."" + sslJarConfigProperties.mainClassCompiled;
+        sslJarConfigProperties.mockedClientConfigProviderImplName = ""ClientConfigProviderImplMocked"";
+        sslJarConfigProperties.mockedClientConfigProviderImplClassPath = PACKAGE_PATH + sslJarConfigProperties.mockedClientConfigProviderImplName + "".class"";
+
+        bearerJarConfigProperties.mainClassName = ""ClientConfigBearerTokenTestMainClass"";
+        bearerJarConfigProperties.mainClassCompiled = bearerJarConfigProperties.mainClassName + "".class"";
+        bearerJarConfigProperties.mainClassPath = PACKAGE_PATH + bearerJarConfigProperties.mainClassCompiled;
+        bearerJarConfigProperties.mainClassWithPackage = PACKAGE_NAME + ""."" + bearerJarConfigProperties.mainClassCompiled;
+        bearerJarConfigProperties.mockedClientConfigProviderImplName = ""ClientConfigProviderImplWithBearerMocked"";
+        bearerJarConfigProperties.mockedClientConfigProviderImplClassPath = PACKAGE_PATH + bearerJarConfigProperties.mockedClientConfigProviderImplName + "".class"";
+    }
+
+    static String createClientConfigProviderTestJarWithBASIC() throws IOException {
+        return createClientConfigProviderTestJar(basicAuthJarConfigProperties);
+    }
+
+    static String createClientConfigProviderTestJarWithSSL() throws IOException {
+        return createClientConfigProviderTestJar(sslJarConfigProperties);
+    }
+
+    static String createClientConfigProviderTestJarWithBearerToken() throws IOException {
+        return createClientConfigProviderTestJar(bearerJarConfigProperties);
+    }
+
+    private static String createClientConfigProviderTestJar(ConfigProviderProperties properties) throws IOException {
+        Manifest manifest = new Manifest();
+        Attributes mainAttributes = manifest.getMainAttributes();
+        mainAttributes.put(Attributes.Name.MANIFEST_VERSION, ""1.0"");
+        mainAttributes.put(Attributes.Name.MAIN_CLASS, properties.mainClassWithPackage);
+        File file = new File(JAR_NAME);
+        try (JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(file), manifest)) {
+            ClassLoader classLoader = ClientConfigProviderTestJarHelper.class.getClassLoader();
+            String[] addClassesToJAR = {properties.mainClassPath, properties.mockedClientConfigProviderImplClassPath};
+            for (String name : addClassesToJAR) {
+                putClassToJar(jarOutputStream, name,
+                        Objects.requireNonNull(classLoader.getResource(name)));
+            }
+            exposeService(jarOutputStream,
+                    ""org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider"",
+                    PACKAGE_NAME + ""."" + properties.mockedClientConfigProviderImplName);
+        }
+        return file.getAbsolutePath();
+    }
+
+    static Process runClientConfigProviderTestJar(TestType testType, String jarPath, String[] args) throws IOException {
+        String[] finalArgs = new String[args.length + 2];
+        finalArgs[0] = sslJarConfigProperties.mainClassName;
+        finalArgs[1] = testType.name();
+        System.arraycopy(args, 0, finalArgs, 2, args.length);
+
+        return ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(jarPath, finalArgs);
+    }
+
+    static Process runClientConfigProviderBearerTestJar(TestType testType, String jarPath) throws IOException {
+        return ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(jarPath, new String[]{bearerJarConfigProperties.mainClassName, testType.name()});
+    }
+
+    static Process runClientConfigProviderTestJar(String jarPath, String[] args) throws IOException {
+        // use quotation marks for classpath on windows because folder names can have spaces
+        String classPath = System.getProperty(""os.name"").contains(""indows"") ? ""\"""" + jarPath + "";"" + System.getProperty(""java.class.path"") + ""\"""" : jarPath + "":"" + System.getProperty(""java.class.path"");
+        return Runtime.getRuntime()
+                .exec(""java -cp ""  +  classPath + "" "" + ClientConfigProviderTestJarHelper.PACKAGE_NAME + ""."" + String.join("" "", args) );
+    }
+
+    static String getResultOfProcess(Process proc) throws IOException {
+        StringBuilder builder = new StringBuilder();
+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()))) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                if (!line.contains(""WARN"")) {
+                    builder.append(line);
+                }
+            }
+        }
+        return builder.toString();
+    }
+
+    private static void putClassToJar(JarOutputStream jar, String s, java.net.URL resource) throws IOException {
+        byte[] buffer = new byte[1024];
+        JarEntry entry = new JarEntry(s);
+        jar.putNextEntry(entry);
+        int len;
+        try (InputStream is = new BufferedInputStream(new FileInputStream(resource.getPath()))) {
+            while ((len = is.read(buffer, 0, buffer.length)) != -1) {
+                jar.write(buffer, 0, len);
+            }
+        } finally {
+            jar.closeEntry();
+        }
+    }
+
+    private static void exposeService(JarOutputStream jar, String service, String implementation) throws IOException {
+        JarEntry entry = new JarEntry(""META-INF/services/"" + service);
+        jar.putNextEntry(entry);
+        try {
+            jar.write((implementation).getBytes(StandardCharsets.UTF_8));
+        } finally {
+            jar.closeEntry();
+        }
+    }
+}",2020-07-16T08:16:20Z,449
"@@ -18,6 +18,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -241,9 +242,34 @@ public void testIsTrustSelfSignedCertificatesTrue() {
       Assert.assertEquals(200, response.getStatus());
    }
 
+   @Test
+   public void testTrustedServerWithClientConfigProvider() throws IOException, InterruptedException {
+      String jarPath = ClientConfigProviderTestJarHelper.createClientConfigProviderTestJarWithSSL();
+      File clientTruststore = new File(CLIENT_TRUSTSTORE_PATH);
+      Process process = ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(
+              ClientConfigProviderTestJarHelper.TestType.TEST_SSLCONTEXT_USED,
+              jarPath,
+              new String[]{URL, clientTruststore.getAbsolutePath()});
+      String line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+      // first request will succeed because SSLContext from ClientConfigProvider will be used. Second request will fail because user will set sslContext on RestEasyBuilder to SSLContext.getDefault()
+      Assert.assertEquals(""200"", line);
+      process.destroy();
+
+      process = ClientConfigProviderTestJarHelper.runClientConfigProviderTestJar(
+              ClientConfigProviderTestJarHelper.TestType.TEST_CLIENTCONFIG_SSLCONTEXT_IGNORED_WHEN_DIFFERENT_SET,
+              jarPath,
+              new String[]{URL, clientTruststore.getAbsolutePath()});
+      line = ClientConfigProviderTestJarHelper.getResultOfProcess(process);
+      Assert.assertEquals(""SSLHandshakeException"", line);
+      process.destroy();
+      Assert.assertTrue(new File(jarPath).delete());
+   }
+
    @After
    public void after() {
-      client.close();
+      if (client != null) {
+         client.close();
+      }
    }
 
 }",2020-07-16T08:16:20Z,450
"@@ -0,0 +1,56 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+import org.jboss.resteasy.spi.HttpResponseCodes;
+import org.junit.Assert;
+
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Response;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Main class used in jar that is meant to test ClientConfigProvider functionality regarding Bearer token.
+ */
+public class ClientConfigBearerTokenTestMainClass {
+    static String dummyUrl = ""dummyUrl"";
+
+    public static void main(String[] args) {
+
+        String testType = args[0];
+        String result = null;
+        ResteasyClientBuilder builder = (ResteasyClientBuilder) ClientBuilder.newBuilder();
+        ResteasyClient client = builder.build();
+
+        if (testType.equals(""TEST_BEARER_TOKEN_IS_USED"")) {
+            Response response = client.target(dummyUrl)
+                    .register(ClientConfigProviderBearerTokenAbortFilter.class).request().get();
+            // ClientConfigProviderBearerTokenAbortFilter will succeed since bearer token was used from ClientConfigProvider
+            Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+            result = String.valueOf(response.getStatus());
+        }
+
+        if (testType.equals(""TEST_BEARER_TOKEN_IGNORED_IF_BASIC_SET_BY_USER"")) {
+            try { // when user sets credentials then ClientConfigProvider's credentials and bearer token will be ignored
+                client.register(new BasicAuthentication(""bill"", ""password1""));
+                client.register(ClientConfigProviderBearerTokenAbortFilter.class);
+                client.target(dummyUrl).request().get();
+                fail(""ClientConfigProviderBearerTokenAbortFilter should fail since we have set different credentials"");
+            } catch (Exception e) {
+                // bearer token was not added because Basic auth was used, therefore assertion failed with the below message
+                String assertionErrorMessage = ""The request authorization header is not correct expected:<B[earer myTestToken]> but was:<B[asic YmlsbDpwYXNzd29yZDE=]>"";
+                assertTrue(e.getMessage().contains(assertionErrorMessage));
+                client.close();
+                result = ""Credentials set by user had precedence"";
+            }
+        }
+
+        //CHECKSTYLE.OFF: RegexpSinglelineJava
+        System.out.println(result);
+        //CHECKSTYLE.ON: RegexpSinglelineJava
+        client.close();
+    }
+}",2020-07-16T08:16:20Z,451
"@@ -0,0 +1,22 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.junit.Assert;
+
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+
+/**
+ * ClientRequestFilter that is used to check content of attached Bearer token. If Bearer Token checks are successful the request is aborted.
+ */
+public class ClientConfigProviderBearerTokenAbortFilter implements ClientRequestFilter {
+
+    @Override
+    public void filter(ClientRequestContext requestContext) throws IOException {
+        String authorizationHeader = requestContext.getHeaderString(""Authorization"");
+        Assert.assertEquals(""The request authorization header is not correct"", ""Bearer myTestToken"", authorizationHeader);
+        Assert.assertTrue(""The request authorization header should not contain both Bearer token and Basic credentials"", !(authorizationHeader.contains(""Basic"") && authorizationHeader.contains(""Bearer"")));
+        requestContext.abortWith(Response.ok().build());
+    }
+}",2020-07-16T08:16:20Z,452
"@@ -0,0 +1,33 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigException;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+
+/**
+ * ClientConfigProvider implementation used in jar that tests ClientConfigProvider functionality regarding HTTP BASIC auth.
+ */
+public class ClientConfigProviderImplCredentials implements ClientConfigProvider {
+
+    @Override
+    public String getUsername(URI uri) throws ClientConfigException {
+        return ""bill"";
+    }
+
+    @Override
+    public String getPassword(URI uri) throws ClientConfigException {
+        return ""password1"";
+    }
+
+    @Override
+    public String getBearerToken(URI uri) throws ClientConfigException {
+        return null;
+    }
+
+    @Override
+    public SSLContext getSSLContext(URI uri) throws ClientConfigException {
+        return null;
+    }
+}",2020-07-16T08:16:20Z,453
"@@ -0,0 +1,60 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigException;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
+import org.jboss.resteasy.test.security.resource.CustomTrustManager;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.net.URI;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * ClientConfigProvider implementation used in jar that tests ClientConfigProvider functionality regarding SSLContext.
+ */
+public class ClientConfigProviderImplMocked implements ClientConfigProvider {
+    static String KEYSTORE_PATH = null;
+
+    @Override
+    public String getUsername(URI uri) throws ClientConfigException {
+        return null;
+    }
+
+    @Override
+    public String getPassword(URI uri) throws ClientConfigException {
+        return null;
+    }
+
+    @Override
+    public String getBearerToken(URI uri) throws ClientConfigException {
+        return null;
+    }
+
+    @Override
+    public SSLContext getSSLContext(URI uri) throws ClientConfigException {
+        SSLContext sslContext;
+        if (KEYSTORE_PATH != null) {
+            try {
+                KeyStore correctTruststore = KeyStore.getInstance(""jks"");
+                try (InputStream in = new FileInputStream(KEYSTORE_PATH)) {
+                    correctTruststore.load(in, ""123456"".toCharArray());
+                }
+                sslContext = SSLContext.getInstance(""TLS"");
+                sslContext.init(null, new TrustManager[]{new CustomTrustManager(correctTruststore)}, null);
+            } catch (Exception e) {
+                throw new ClientConfigException(e);
+            }
+        } else {
+            try {
+                sslContext = SSLContext.getDefault();
+            } catch (NoSuchAlgorithmException e) {
+                throw new ClientConfigException(e);
+            }
+        }
+
+        return sslContext;
+    }
+}",2020-07-16T08:16:20Z,454
"@@ -0,0 +1,33 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigException;
+import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+
+/**
+ * ClientConfigProvider implementation used in jar that tests ClientConfigProvider functionality regarding Bearer token.
+ */
+public class ClientConfigProviderImplWithBearerMocked implements ClientConfigProvider {
+
+    @Override
+    public String getUsername(URI uri) throws ClientConfigException {
+        return ""name"";
+    }
+
+    @Override
+    public String getPassword(URI uri) throws ClientConfigException {
+        return ""pass"";
+    }
+
+    @Override
+    public String getBearerToken(URI uri) throws ClientConfigException {
+        return ""myTestToken"";
+    }
+
+    @Override
+    public SSLContext getSSLContext(URI uri) throws ClientConfigException {
+        return null;
+    }
+}",2020-07-16T08:16:20Z,455
"@@ -0,0 +1,62 @@
+package org.jboss.resteasy.test.security.testjar;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+
+import javax.net.ssl.SSLContext;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * ClientConfigProvider implementation used in jar that tests ClientConfigProvider functionality regarding HTTP BASIC auth and SSLContext.
+ */
+public class ClientConfigTestMainClass {
+    public static void main(String[] args) throws IOException, URISyntaxException, NoSuchAlgorithmException {
+        if (args.length <= 1) {
+            throw new IllegalArgumentException(""Url must be supplied!"");
+        }
+
+        if (args.length > 2) {
+            ClientConfigProviderImplMocked.KEYSTORE_PATH = args[2];
+        }
+
+        String testType = args[0];
+        String result = null;
+        URL url = new URL(args[1]);
+        ResteasyClientBuilder resteasyClientBuilder = (ResteasyClientBuilder) ClientBuilder.newBuilder();
+        ResteasyClient client = resteasyClientBuilder.build();
+        Response response;
+
+        if (testType.equals(""TEST_CREDENTIALS_ARE_USED_FOR_BASIC"") || testType.equals(""TEST_SSLCONTEXT_USED"")) {
+            response = client.target(url.toURI()).request().get();
+            result = Integer.toString(response.getStatus());
+        }
+
+        if (testType.equals(""TEST_CLIENTCONFIG_CREDENTIALS_ARE_IGNORED_IF_DIFFERENT_SET"")) {
+            client.register(new BasicAuthentication(""invalid"", ""invalid_pass""));
+            response = client.target(url.toURI()).request().get();
+            result = Integer.toString(response.getStatus());
+        }
+
+        if (testType.equals(""TEST_CLIENTCONFIG_SSLCONTEXT_IGNORED_WHEN_DIFFERENT_SET"")) {
+            ResteasyClient clientWithSSLContextSetByUser = resteasyClientBuilder.sslContext(SSLContext.getDefault()).build();
+            try {
+                response = clientWithSSLContextSetByUser.target(url.toURI()).request().get();
+                result = Integer.toString(response.getStatus());
+            } catch (Exception e) {
+                if (e.getCause().getMessage().contains(""unable to find valid certification path to requested target"")) {
+                    result = ""SSLHandshakeException"";
+                }
+            }
+        }
+        //CHECKSTYLE.OFF: RegexpSinglelineJava
+        System.out.println(result);
+        //CHECKSTYLE.ON: RegexpSinglelineJava
+        client.close();
+    }
+}",2020-07-16T08:16:20Z,456
"@@ -255,6 +255,15 @@
                                             <includedPackages>
                                                 <package>org.jboss.resteasy.resteasy-rxjava2</package>
                                             </includedPackages>
+                                            <!--
+                                                Required for BC - this is needed to resemble what in
+                                                jboss-deployment-structure-bouncycastle.xml.
+                                                That deployment structure is used by some test cases and is expected
+                                                to reflect the server module working configuration.
+                                            -->
+                                            <includedPackages>
+                                                <package>org.bouncycastle</package>
+                                            </includedPackages>
                                         </feature-pack>
                                     </feature-packs>
                                     <layers>",2020-11-26T14:07:19Z,399
"@@ -46,6 +46,25 @@ To redirect to standard output (console) use ``-Dmaven.test.redirectTestOutputTo
 
 > mvn clean verify -Dserver.home=PATH_TO_WIDLFLY_HOME -Dmaven.test.redirectTestOutputToFile=false
 
+## Set security subsystem for the tests (PicketBox/Elytron)
+The testsuite can run in **three modes**, which differ by security subsystem configuration and by subsystem used in the tests,
+which require security domain defined.
+
+The tests which require security domain configuration are extending ``org.jboss.resteasy.setup.AbstractUsersRolesSecurityDomainSetup``
+which implements ServerSetupTask.
+
+### PicketBox is enabled, Elytron is not enabled
+Tests run with PicketBox security domain. This is the default.
+  
+### Both PicketBox and Elytron security subsystems are enabled
+  * Tests run with PicketBox security domain. Activate this mode by:
+    > mvn clean verify -Dserver.home=PATH_TO_WIDLFLY_HOME -Delytron
+  * Tests run with Elytron security domain. Activate this mode by:
+    > mvn clean verify -Dserver.home=PATH_TO_WIDLFLY_HOME -Delytron -Dsecurity.domain=elytron
+    
+    If property '-Dsecurity.domain=elytron' is defined in the maven run, then '-Delytron' property is enforced to be defined too,
+     because tests need this property to trigger correct server configuration.
+
 # Guidance for writing new tests
 * Keep structure of the tests [example](integration-tests/src/test/java/org/jboss/resteasy/test/resource/param/CookieInjectionTest.java).
 * Document test class and all tests within test class see [Test Documentation](#Test Documentation). It will help others to understand.",2017-02-17T17:05:22Z,457
"@@ -0,0 +1,206 @@
+package org.jboss.resteasy.setup;
+
+import org.jboss.as.arquillian.api.ServerSetupTask;
+import org.jboss.as.arquillian.container.ManagementClient;
+import org.jboss.resteasy.utils.TestUtil;
+import org.wildfly.extras.creaper.commands.security.AddLoginModule;
+import org.wildfly.extras.creaper.commands.security.AddSecurityDomain;
+import org.wildfly.extras.creaper.core.online.OnlineManagementClient;
+import org.wildfly.extras.creaper.core.online.operations.Address;
+import org.wildfly.extras.creaper.core.online.operations.Operations;
+import org.wildfly.extras.creaper.core.online.operations.Values;
+import org.wildfly.extras.creaper.core.online.operations.admin.Administration;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URISyntaxException;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * This abstract class implements steps needed to create PicketBox or Elytron security domain.
+ *
+ */
+public abstract class AbstractUsersRolesSecurityDomainSetup implements ServerSetupTask {
+
+    // Creaper fields
+    private static OnlineManagementClient managementClient;
+    private Operations ops;
+    private Administration administration;
+
+    // Properties file path
+    private static final String USERS_FILENAME = ""users.properties"";
+    private static final String ROLES_FILENAME = ""roles.properties"";
+    private File USERS_FILE;
+    private File ROLES_FILE;
+
+    // This property decides under which security subsystem will be used for the tests
+    private static final String SUBSYSTEM = System.getProperty(""security.domain"", ""picketbox"");
+    // Security domain name shared by elytron and picketBox configuration
+    private static final String SECURITY_DOMAIN_NAME = ""jaxrsSecDomain"";
+
+
+    // PicketBox related settings
+    private static final Address TEST_SECURITY_DOMAIN_ADDRESS
+            = Address.subsystem(""security"").and(""security-domain"", SECURITY_DOMAIN_NAME);
+    private static final Address TEST_AUTHN_CLASSIC_ADDRESS = TEST_SECURITY_DOMAIN_ADDRESS
+            .and(""authentication"", ""classic"");
+    private static final String TEST_LOGIN_MODULE_NAME = ""UsersRoles"";
+    private static final Address TEST_LOGIN_MODULE_ADDRESS = TEST_AUTHN_CLASSIC_ADDRESS
+            .and(""login-module"", TEST_LOGIN_MODULE_NAME);
+
+    // Elytron related settings
+    private static final String ELYTRON_PROPERTIES_REALM_NAME = ""propRealm"";
+    private static final Address ELYTRON_PROPERTIES_REALM_ADDRESS
+            = Address.subsystem(""elytron"").and(""properties-realm"", ELYTRON_PROPERTIES_REALM_NAME);
+    private static final String ELYTRON_SECURITY_DOMAIN_NAME = ""propertyElytronSecDomain"";
+    private static final Address ELYTRON_SECURITY_DOMAIN_ADDRESS
+            = Address.subsystem(""elytron"").and(""security-domain"", ELYTRON_SECURITY_DOMAIN_NAME);
+    private static final String ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_NAME = ""prop-http-authentication-factory"";
+    private static final Address ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_ADDRESS
+            = Address.subsystem(""elytron"").and(""http-authentication-factory"", ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_NAME);
+    private static final String UNDERTOW_APPLICATION_SECURITY_DOMAIN_NAME = SECURITY_DOMAIN_NAME;
+    private static final Address UNDERTOW_APPLICATION_SECURITY_DOMAIN_ADDRESS
+            = Address.subsystem(""undertow"").and(""application-security-domain"", UNDERTOW_APPLICATION_SECURITY_DOMAIN_NAME);
+
+    /**
+     * Creates Files pointing to users.properties and roles.properties for the current test.
+     * @param folder
+     */
+    public void createPropertiesFiles(File folder) {
+        this.USERS_FILE = new File(folder, USERS_FILENAME);
+        this.ROLES_FILE = new File(folder, ROLES_FILENAME);
+    }
+
+    @Override
+    public void setup(ManagementClient fakemanagementClient, String s) throws Exception {
+
+        // Set path for users.properties and roles.properties
+        setConfigurationPath();
+
+        // Create and initialize management client
+        managementClient = TestUtil.clientInit();
+        administration = new Administration(managementClient);
+        ops = new Operations(managementClient);
+
+        if (SUBSYSTEM.equals(""elytron"")) {
+            configureElytron();
+        } else {
+            configurePicketBox();
+        }
+    }
+
+    @Override
+    public void tearDown(ManagementClient fakemanagementClient, String s) throws Exception {
+
+        if (SUBSYSTEM.equals(""elytron"")) {
+            cleanUpElytron();
+        } else {
+            cleanUpPicketBox();
+        }
+    }
+
+    /**
+     * Set necessary test related paths
+     */
+    public abstract void setConfigurationPath() throws URISyntaxException, MalformedURLException;
+
+    /**
+     * Creates Elytron security domain
+     * @throws Exception
+     */
+    private void configureElytron() throws Exception {
+
+        // Note: This complicated setting may be simplified once WFLY-7949 is resolved
+
+        // Create Elytron properties-realm
+        ops.add(ELYTRON_PROPERTIES_REALM_ADDRESS, Values.empty()
+                .andObject(""users-properties"", Values.empty()
+                        .and(""path"", USERS_FILE.getAbsolutePath())
+                        .andOptional(""plain-text"", true))
+                .andObjectOptional(""groups-properties"", Values.empty()
+                    .and(""path"", ROLES_FILE.getAbsolutePath())));
+
+        administration.reloadIfRequired();
+
+        // Create Elytron security-domain
+        managementClient.executeCli(""/subsystem=elytron/security-domain=""
+                + ELYTRON_SECURITY_DOMAIN_NAME
+                + "":add(realms=[{realm=""
+                + ELYTRON_PROPERTIES_REALM_NAME + "",role-decoder=groups-to-roles}],default-realm=propRealm,permission-mapper=default-permission-mapper)"");
+
+        // Create Elytron http-authentication-factory with previous security-domain
+        managementClient.executeCli(""/subsystem=elytron/http-authentication-factory=""
+                + ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_NAME + "":add(http-server-mechanism-factory=global,security-domain=""
+                + ELYTRON_SECURITY_DOMAIN_NAME
+                + "",mechanism-configurations=[{mechanism-name=BASIC,mechanism-realm-configurations=[{realm-name=\""Property Elytron\""}]}])"");
+
+        // Set undertow application-security-domain to the custom http-authentication-factory
+        managementClient.executeCli(""/subsystem=undertow/application-security-domain=""
+                + SECURITY_DOMAIN_NAME + "":add(http-authentication-factory=""
+                +  ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_NAME + "")"");
+
+        administration.reloadIfRequired();
+
+        assertTrue(""The elytron/properties-realm should be created"", ops.exists(ELYTRON_PROPERTIES_REALM_ADDRESS));
+        assertTrue(""The elytron/security-domain should be created"", ops.exists(ELYTRON_SECURITY_DOMAIN_ADDRESS));
+        assertTrue(""The elytron/http-authentication-factory should be created"", ops.exists(ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_ADDRESS));
+        assertTrue(""The undertow/application-security-domain should be created"", ops.exists(UNDERTOW_APPLICATION_SECURITY_DOMAIN_ADDRESS));
+    }
+
+    /**
+     * Creates PicketBox security domain
+     * @throws Exception
+     */
+    private void configurePicketBox() throws Exception {
+
+        // Create security domain
+        AddSecurityDomain addSecurityDomain = new AddSecurityDomain.Builder(SECURITY_DOMAIN_NAME).build();
+        managementClient.apply(addSecurityDomain);
+
+        // Create login module
+        AddLoginModule addLoginModule = new AddLoginModule.Builder(""org.jboss.security.auth.spi.UsersRolesLoginModule"",
+                TEST_LOGIN_MODULE_NAME)
+                .securityDomainName(SECURITY_DOMAIN_NAME)
+                .flag(""required"")
+                .module(""org.picketbox"")
+                .addModuleOption(""usersProperties"", USERS_FILE.getAbsolutePath())
+                .addModuleOption(""rolesProperties"", ROLES_FILE.getAbsolutePath())
+                .build();
+
+        managementClient.apply(addLoginModule);
+
+        administration.reloadIfRequired();
+
+        assertTrue(""The login module should be created"", ops.exists(TEST_LOGIN_MODULE_ADDRESS));
+    }
+
+    /**
+     * Reverts all configuration done for Elytron
+     * @throws Exception
+     */
+    private void cleanUpElytron() throws Exception {
+        try {
+            ops.removeIfExists(UNDERTOW_APPLICATION_SECURITY_DOMAIN_ADDRESS);
+            ops.removeIfExists(ELYTRON_PROP_HTTP_AUTHENTICATION_FACTORY_ADDRESS);
+            ops.removeIfExists(ELYTRON_SECURITY_DOMAIN_ADDRESS);
+            ops.removeIfExists(ELYTRON_PROPERTIES_REALM_ADDRESS);
+            administration.reloadIfRequired();
+        } finally {
+            managementClient.close();
+        }
+    }
+
+    /**
+     * Reverts all configuration done for PicketBox
+     * @throws Exception
+     */
+    private void cleanUpPicketBox() throws Exception{
+        try {
+            ops.removeIfExists(TEST_SECURITY_DOMAIN_ADDRESS);
+            administration.reloadIfRequired();
+        } finally {
+            managementClient.close();
+        }
+    }
+}",2017-02-17T17:05:22Z,34
"@@ -1,67 +0,0 @@
-package org.jboss.resteasy.setup;
-
-import org.jboss.as.arquillian.api.ServerSetupTask;
-import org.jboss.as.arquillian.container.ManagementClient;
-import org.jboss.resteasy.utils.TestUtil;
-import org.wildfly.extras.creaper.commands.security.AddLoginModule;
-import org.wildfly.extras.creaper.commands.security.AddSecurityDomain;
-import org.wildfly.extras.creaper.core.online.OnlineManagementClient;
-import org.wildfly.extras.creaper.core.online.operations.Address;
-import org.wildfly.extras.creaper.core.online.operations.Operations;
-import org.wildfly.extras.creaper.core.online.operations.admin.Administration;
-
-import static org.junit.Assert.assertTrue;
-
-public class UsersRolesSecurityDomainSetupCreaper implements ServerSetupTask {
-
-    private static final String TEST_SECURITY_DOMAIN_NAME = ""jaxrsSecDomain"";
-    private static final Address TEST_SECURITY_DOMAIN_ADDRESS
-            = Address.subsystem(""security"").and(""security-domain"", TEST_SECURITY_DOMAIN_NAME);
-    private static final Address TEST_AUTHN_CLASSIC_ADDRESS = TEST_SECURITY_DOMAIN_ADDRESS
-            .and(""authentication"", ""classic"");
-    private static final String TEST_LOGIN_MODULE_NAME = ""UsersRoles"";
-    private static final Address TEST_LOGIN_MODULE_ADDRESS = TEST_AUTHN_CLASSIC_ADDRESS
-            .and(""login-module"", TEST_LOGIN_MODULE_NAME);
-
-    private static OnlineManagementClient managementClient;
-    private Operations ops;
-    private Administration administration;
-
-    @Override
-    public void setup(ManagementClient fakemanagementClient, String s) throws Exception {
-        // Create and initialize management client
-        managementClient = TestUtil.clientInit();
-        administration = new Administration(managementClient);
-        ops = new Operations(managementClient);
-
-        // Create security domain
-        AddSecurityDomain addSecurityDomain = new AddSecurityDomain.Builder(TEST_SECURITY_DOMAIN_NAME).build();
-        managementClient.apply(addSecurityDomain);
-
-        // Create login module
-        AddLoginModule addLoginModule = new AddLoginModule.Builder(""org.jboss.security.auth.spi.UsersRolesLoginModule"",
-                TEST_LOGIN_MODULE_NAME)
-                .securityDomainName(TEST_SECURITY_DOMAIN_NAME)
-                .flag(""required"")
-                .module(""org.picketbox"")
-                .addModuleOption(""usersProperties"", ""users.properties"")
-                .addModuleOption(""rolesProperties"", ""roles.properties"")
-                .build();
-
-        managementClient.apply(addLoginModule);
-
-        administration.reloadIfRequired();
-
-        assertTrue(""The login module should be created"", ops.exists(TEST_LOGIN_MODULE_ADDRESS));
-    }
-
-    @Override
-    public void tearDown(ManagementClient fakemanagementClient, String s) throws Exception {
-        try {
-            ops.removeIfExists(TEST_SECURITY_DOMAIN_ADDRESS);
-            administration.reloadIfRequired();
-        } finally {
-            managementClient.close();
-        }
-    }
-}",2017-02-17T17:05:22Z,34
"@@ -0,0 +1,25 @@
+embed-server --server-config=standalone-full-elytron.xml
+/subsystem=undertow/application-security-domain=other:add(http-authentication-factory=application-http-authentication)
+/subsystem=ejb3/application-security-domain=other:add(security-domain=ApplicationDomain)
+/subsystem=batch-jberet:write-attribute(name=security-domain, value=ApplicationDomain)
+/subsystem=remoting/http-connector=http-remoting-connector:write-attribute(name=sasl-authentication-factory, value=application-sasl-authentication)
+/subsystem=remoting/http-connector=http-remoting-connector:undefine-attribute(name=security-realm)
+/subsystem=messaging-activemq/server=default:undefine-attribute(name=security-domain)
+/subsystem=messaging-activemq/server=default:write-attribute(name=elytron-domain, value=ApplicationDomain)
+/core-service=management/access=identity:add(security-domain=ManagementDomain)
+/core-service=management/management-interface=http-interface:write-attribute(name=http-upgrade,value={enabled=true, sasl-authentication-factory=management-sasl-authentication})
+/core-service=management/management-interface=http-interface:write-attribute(name=http-authentication-factory,value=management-http-authentication)
+/core-service=management/management-interface=http-interface:undefine-attribute(name=security-realm)
+
+# fix Elytron configuration (workaround for JBEAP-8576)
+/subsystem=elytron/security-domain=ApplicationDomain:list-add(name=realms, value={realm => ""local""})
+/subsystem=elytron/sasl-authentication-factory=application-sasl-authentication:write-attribute(name=mechanism-configurations, value=[{mechanism-name=""JBOSS-LOCAL-USER"", realm-mapper=local}, {mechanism-name=""DIGEST-MD5"",mechanism-realm-configurations=[{realm-name=ApplicationRealm}]}])
+
+reload
+
+/core-service=management/security-realm=ManagementRealm:remove
+/core-service=management/security-realm=ApplicationRealm/authentication=local:remove
+/core-service=management/security-realm=ApplicationRealm/authentication=properties:remove
+/core-service=management/security-realm=ApplicationRealm/authorization=properties:remove
+reload
+stop-embedded-server",2017-02-17T17:05:22Z,458
"@@ -15,7 +15,7 @@
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
 import org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient4Engine;
-import org.jboss.resteasy.setup.UsersRolesSecurityDomainSetupCreaper;
+import org.jboss.resteasy.setup.AbstractUsersRolesSecurityDomainSetup;
 import org.jboss.resteasy.test.spring.inmodule.resource.SpringMvcHttpResponseCodesPerson;
 import org.jboss.resteasy.test.spring.inmodule.resource.SpringMvcHttpResponseCodesResource;
 import org.jboss.resteasy.test.spring.inmodule.resource.TestResource;
@@ -35,14 +35,18 @@
 import javax.ws.rs.client.Entity;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
+import java.io.File;
+import java.net.URISyntaxException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 
 /**
  * @tpSubChapter Spring
  * @tpChapter Integration tests
  * @tpTestCaseDetails Tests various http response codes returned from the server
  * @tpSince RESTEasy 3.1.0
  */
-@ServerSetup({UsersRolesSecurityDomainSetupCreaper.class})
+@ServerSetup({SpringMvcHttpResponseCodesTest.SecurityDomainSetup.class})
 @RunWith(Arquillian.class)
 @RunAsClient
 public class SpringMvcHttpResponseCodesTest {
@@ -55,8 +59,6 @@ private static Archive<?> deploy() {
         WebArchive war = TestUtil.prepareArchive(SpringMvcHttpResponseCodesTest.class.getSimpleName());
         war.addAsWebInfResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/web-secure.xml"", ""web.xml"");
         war.addAsWebInfResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/jboss-web.xml"", ""jboss-web.xml"");
-        war.addAsResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/roles.properties"", ""roles.properties"");
-        war.addAsResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/users.properties"", ""users.properties"");
         war.addAsWebInfResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/mvc-dispatcher-servlet.xml"", ""mvc-dispatcher-servlet.xml"");
         war.addAsWebInfResource(SpringMvcHttpResponseCodesTest.class.getPackage(), ""springMvcHttpResponseCodes/applicationContext.xml"", ""applicationContext.xml"");
         war.addAsManifestResource(new StringAsset(""Dependencies: org.springframework.spring meta-inf\n""), ""MANIFEST.MF"");
@@ -181,4 +183,14 @@ public void testForbiddenException() {
         // It is allowed by RFC7231 to return NOT FOUND instead
         Assert.assertEquals(HttpResponseCodes.SC_NOT_FOUND, response.getStatus());
     }
+
+    static class SecurityDomainSetup extends AbstractUsersRolesSecurityDomainSetup {
+
+        @Override
+        public void setConfigurationPath() throws URISyntaxException {
+            Path filepath= Paths.get(SpringMvcHttpResponseCodesTest.class.getResource(""users.properties"").toURI());
+            Path parent = filepath.getParent();
+            createPropertiesFiles(new File(parent.toUri()));
+        }
+    }
 }",2017-02-17T17:05:22Z,459
"@@ -7,7 +7,7 @@
     <container qualifier=""jbossas-managed"" default=""true"">
         <configuration>
             <property name=""jbossHome"">${jboss.home}</property>
-            <!--<property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>-->
+            <property name=""serverConfig"">${jboss.server.config.file.name:standalone.xml}</property>
             <!--<property name=""javaVmArguments"">-Xmx512m -XX:MaxPermSize=128m
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->",2017-02-17T17:05:22Z,460
"@@ -7,7 +7,7 @@
     <container qualifier=""jbossas-managed"" default=""true"">
         <configuration>
             <property name=""jbossHome"">${jboss.home}</property>
-            <!--<property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>-->
+            <property name=""serverConfig"">${jboss.server.config.file.name:standalone.xml}</property>
             <!--<property name=""javaVmArguments"">-Xmx512m -XX:MaxPermSize=128m
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->",2017-02-17T17:05:22Z,461
"@@ -7,7 +7,7 @@
     <container qualifier=""jbossas-managed"" default=""true"">
         <configuration>
             <property name=""jbossHome"">${jboss.home}</property>
-            <!--<property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>-->
+            <property name=""serverConfig"">${jboss.server.config.file.name:standalone.xml}</property>
             <!--<property name=""javaVmArguments"">-Xmx512m -XX:MaxPermSize=128m
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->",2017-02-17T17:05:22Z,462
"@@ -10,12 +10,11 @@
 import org.jboss.arquillian.container.test.api.RunAsClient;
 import org.jboss.arquillian.junit.Arquillian;
 import org.jboss.as.arquillian.api.ServerSetup;
-import org.jboss.resteasy.category.ExpectedFailing;
 import org.jboss.resteasy.category.NotForForwardCompatibility;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
 import org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient4Engine;
-import org.jboss.resteasy.setup.UsersRolesSecurityDomainSetupCreaper;
+import org.jboss.resteasy.setup.AbstractUsersRolesSecurityDomainSetup;
 import org.jboss.resteasy.test.security.resource.BasicAuthBaseProxy;
 import org.jboss.resteasy.test.security.resource.BasicAuthBaseResource;
 import org.jboss.resteasy.test.security.resource.BasicAuthBaseResourceAnybody;
@@ -34,6 +33,12 @@
 
 import javax.ws.rs.NotAuthorizedException;
 import javax.ws.rs.core.Response;
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Hashtable;
 
 /**
@@ -42,7 +47,7 @@
  * @tpTestCaseDetails Basic test for RESTEasy authentication.
  * @tpSince RESTEasy 3.0.16
  */
-@ServerSetup({UsersRolesSecurityDomainSetupCreaper.class})
+@ServerSetup({BasicAuthTest.SecurityDomainSetup.class})
 @RunWith(Arquillian.class)
 @RunAsClient
 public class BasicAuthTest {
@@ -93,8 +98,6 @@ public static Archive<?> deployLocatingResource() {
         contextParams.put(""resteasy.role.based.security"", ""true"");
 
         war.addClass(BasicAuthBaseProxy.class)
-                .addAsResource(BasicAuthTest.class.getPackage(), ""roles.properties"", ""/roles.properties"")
-                .addAsResource(BasicAuthTest.class.getPackage(), ""users.properties"", ""/users.properties"")
                 .addAsWebInfResource(BasicAuthTest.class.getPackage(), ""jboss-web.xml"", ""/jboss-web.xml"")
                 .addAsWebInfResource(BasicAuthTest.class.getPackage(), ""web.xml"", ""/web.xml"");
 
@@ -253,4 +256,15 @@ public void testContentTypeWithUnauthorizedMessage() {
         Assert.assertEquals(HttpResponseCodes.SC_UNAUTHORIZED, response.getStatus());
         Assert.assertEquals(""Incorrect Content-type header"", ""text/html;charset=UTF-8"", response.getHeaderString(""Content-type""));
     }
+
+    static class SecurityDomainSetup extends AbstractUsersRolesSecurityDomainSetup {
+
+        @Override
+        public void setConfigurationPath() throws URISyntaxException {
+            Path filepath= Paths.get(BasicAuthTest.class.getResource(""users.properties"").toURI());
+            Path parent = filepath.getParent();
+            createPropertiesFiles(new File(parent.toUri()));
+        }
+
+    }
 }",2017-02-17T17:05:22Z,447
"@@ -13,7 +13,7 @@
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
 import org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient4Engine;
-import org.jboss.resteasy.setup.UsersRolesSecurityDomainSetupCreaper;
+import org.jboss.resteasy.setup.AbstractUsersRolesSecurityDomainSetup;
 import org.jboss.resteasy.test.security.resource.BasicAuthBaseResource;
 import org.jboss.resteasy.test.security.resource.CustomForbiddenMessageExceptionMapper;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -28,6 +28,10 @@
 import org.junit.runner.RunWith;
 
 import javax.ws.rs.core.Response;
+import java.io.File;
+import java.net.URISyntaxException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Hashtable;
 
 /**
@@ -36,7 +40,7 @@
  * @tpTestCaseDetails Custom ExceptionMapper is used when Forbidden is thrown from RoleBasedSecurityFilter
  * @tpSince RESTEasy 3.1.0
  */
-@ServerSetup({UsersRolesSecurityDomainSetupCreaper.class})
+@ServerSetup({CustomForbiddenMessageTest.SecurityDomainSetup.class})
 @RunWith(Arquillian.class)
 @RunAsClient
 public class CustomForbiddenMessageTest {
@@ -52,9 +56,7 @@ public static Archive<?> deploy() {
         Hashtable<String, String> contextParams = new Hashtable<String, String>();
         contextParams.put(""resteasy.role.based.security"", ""true"");
 
-        war.addAsResource(BasicAuthTest.class.getPackage(), ""roles.properties"", ""/roles.properties"")
-                .addAsResource(BasicAuthTest.class.getPackage(), ""users.properties"", ""/users.properties"")
-                .addAsWebInfResource(BasicAuthTest.class.getPackage(), ""jboss-web.xml"", ""/jboss-web.xml"")
+        war.addAsWebInfResource(BasicAuthTest.class.getPackage(), ""jboss-web.xml"", ""/jboss-web.xml"")
                 .addAsWebInfResource(BasicAuthTest.class.getPackage(), ""web.xml"", ""/web.xml"");
 
         return TestUtil.finishContainerPrepare(war, contextParams, BasicAuthBaseResource.class, CustomForbiddenMessageExceptionMapper.class);
@@ -94,4 +96,14 @@ public void testCustomExceptionMapper() throws Exception {
         String ct = response.getHeaderString(""Content-Type"");
         Assert.assertEquals(""text/plain"", ct);
     }
+
+    static class SecurityDomainSetup extends AbstractUsersRolesSecurityDomainSetup {
+
+        @Override
+        public void setConfigurationPath() throws URISyntaxException {
+            Path filepath= Paths.get(CustomForbiddenMessageTest.class.getResource(""users.properties"").toURI());
+            Path parent = filepath.getParent();
+            createPropertiesFiles(new File(parent.toUri()));
+        }
+    }
 }",2017-02-17T17:05:22Z,463
"@@ -6,7 +6,7 @@
 import org.jboss.arquillian.junit.Arquillian;
 import org.jboss.as.arquillian.api.ServerSetup;
 import org.jboss.resteasy.client.jaxrs.BasicAuthentication;
-import org.jboss.resteasy.setup.UsersRolesSecurityDomainSetupCreaper;
+import org.jboss.resteasy.setup.AbstractUsersRolesSecurityDomainSetup;
 import org.jboss.resteasy.test.security.resource.SecurityContextResource;
 import org.jboss.resteasy.test.security.resource.SecurityContextContainerRequestFilter;
 import org.jboss.resteasy.util.HttpResponseCodes;
@@ -23,15 +23,19 @@
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.core.Response;
+import java.io.File;
 import java.io.IOException;
+import java.net.URISyntaxException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 
 /**
  * @tpSubChapter Security
  * @tpChapter Integration tests
  * @tpTestCaseDetails Basic test for RESTEasy authentication using programmatic security with javax.ws.rs.core.SecurityContext
  * @tpSince RESTEasy 3.0.16
  */
-@ServerSetup({UsersRolesSecurityDomainSetupCreaper.class})
+@ServerSetup({SecurityContextTest.SecurityDomainSetup.class})
 @RunWith(Arquillian.class)
 @RunAsClient
 public class SecurityContextTest {
@@ -68,19 +72,15 @@ public void after() throws Exception {
     @Deployment
     public static Archive<?> deploy() {
         WebArchive war = TestUtil.prepareArchive(SecurityContextTest.class.getSimpleName());
-        war.addAsResource(SecurityContextTest.class.getPackage(), ""roles.properties"", ""roles.properties"")
-                .addAsResource(SecurityContextTest.class.getPackage(), ""users.properties"", ""users.properties"")
-                .addAsWebInfResource(SecurityContextTest.class.getPackage(), ""jboss-web.xml"", ""jboss-web.xml"")
+        war.addAsWebInfResource(SecurityContextTest.class.getPackage(), ""jboss-web.xml"", ""jboss-web.xml"")
                 .addAsWebInfResource(SecurityContextTest.class.getPackage(), ""securityContext/web.xml"", ""web.xml"");
         return TestUtil.finishContainerPrepare(war, null, SecurityContextResource.class);
     }
 
     @Deployment(name=""containerRequestFilter"")
     public static Archive<?> deploy2() {
         WebArchive war = TestUtil.prepareArchive(SecurityContextTest.class.getSimpleName() + ""Filter"");
-        war.addAsResource(SecurityContextTest.class.getPackage(), ""roles.properties"", ""roles.properties"")
-                .addAsResource(SecurityContextTest.class.getPackage(), ""users.properties"", ""users.properties"")
-                .addAsWebInfResource(SecurityContextTest.class.getPackage(), ""jboss-web.xml"", ""jboss-web.xml"")
+        war.addAsWebInfResource(SecurityContextTest.class.getPackage(), ""jboss-web.xml"", ""jboss-web.xml"")
                 .addAsWebInfResource(SecurityContextTest.class.getPackage(), ""securityContext/web.xml"", ""web.xml"");
         return TestUtil.finishContainerPrepare(war, null, SecurityContextResource.class,
                 SecurityContextContainerRequestFilter.class);
@@ -135,4 +135,14 @@ public void testSecurityContextNonAuthorizedUsingFilter() {
         Assert.assertEquals(""User ordinaryUser is not authorized, coming from filter"", response.readEntity(String.class));
         Assert.assertEquals(HttpResponseCodes.SC_UNAUTHORIZED, response.getStatus());
     }
+
+    static class SecurityDomainSetup extends AbstractUsersRolesSecurityDomainSetup {
+
+        @Override
+        public void setConfigurationPath() throws URISyntaxException {
+            Path filepath= Paths.get(SecurityContextTest.class.getResource(""users.properties"").toURI());
+            Path parent = filepath.getParent();
+            createPropertiesFiles(new File(parent.toUri()));
+        }
+    }
 }",2017-02-17T17:05:22Z,464
"@@ -23,5 +23,6 @@
 # is for illustration only and does not correspond to a usable password.
 #
 #admin=2a0923285184943425d1f53ddd58ec7a
+#$REALM_NAME=MyRealm$
 bill=password1
-ordinaryUser=password2
\ No newline at end of file
+ordinaryUser=password2",2017-02-17T17:05:22Z,465
"@@ -178,6 +178,113 @@
                 </plugins>
             </build>
         </profile>
+        <!-- This profile creates custom server configuration file with configured Elytron subsystem -->
+        <profile>
+            <id>elytron</id>
+            <activation>
+                <property>
+                    <name>elytron</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-antrun-plugin</artifactId>
+                        <executions>
+                            <execution>
+                                <id>copy</id>
+                                <phase>generate-test-sources</phase>
+                                <configuration>
+                                    <target>
+                                        <copy file=""${server.home}/standalone/configuration/standalone-full.xml""
+                                              tofile=""${server.home}/standalone/configuration/standalone-full-elytron.xml""
+                                              overwrite=""true"" failonerror=""true""/>
+                                    </target>
+                                </configuration>
+                                <goals>
+                                    <goal>run</goal>
+                                </goals>
+                            </execution>
+                        </executions>
+                    </plugin>
+                    <plugin>
+                        <groupId>org.codehaus.mojo</groupId>
+                        <artifactId>exec-maven-plugin</artifactId>
+                        <inherited>false</inherited>
+                        <executions>
+                            <execution>
+                                <id>enable-elytron-full-cli</id>
+                                <phase>process-test-resources</phase>
+                                <goals>
+                                    <goal>exec</goal>
+                                </goals>
+                                <configuration>
+                                    <executable>${java.home}/bin/java</executable>
+                                    <arguments>
+                                        <argument>-jar</argument>
+                                        <argument>${server.home}/jboss-modules.jar</argument>
+                                        <argument>-mp</argument>
+                                        <argument>${server.home}/modules</argument>
+                                        <argument>org.jboss.as.cli</argument>
+                                        <argument>--file=${basedir}/config/enable-elytron-full.cli</argument>
+                                    </arguments>
+                                    <environmentVariables>
+                                        <JBOSS_HOME>${server.home}</JBOSS_HOME>
+                                    </environmentVariables>
+                                </configuration>
+                            </execution>
+                        </executions>
+                    </plugin>
+                    <plugin>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration combine.children=""append"">
+                            <systemPropertyVariables>
+                                <jboss.server.config.file.name>standalone-full-elytron.xml</jboss.server.config.file.name>
+                                <additionalJvmArgs></additionalJvmArgs>
+                                <ipv6>false</ipv6>
+                                <ipv6ArquillianSettings></ipv6ArquillianSettings>
+                                <node>127.0.0.1</node>
+                                <jboss.home>${jboss.home}</jboss.home>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+        <!-- This profile enforces to define -Delytron property when -Dsecurity.domain=elytron is triggered -->
+        <profile>
+            <id>security.domain</id>
+            <activation>
+                <property>
+                    <name>security.domain</name>
+                    <value>elytron</value>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-enforcer-plugin</artifactId>
+                        <executions>
+                            <execution>
+                                <id>enforce-property</id>
+                                <goals>
+                                    <goal>enforce</goal>
+                                </goals>
+                                <configuration>
+                                    <rules>
+                                        <requireProperty>
+                                            <property>elytron</property>
+                                            <message>You must set property '-Delytron' to the build in order to have all components for Elytron configured!</message>
+                                        </requireProperty>
+                                    </rules>
+                                    <fail>true</fail>
+                                </configuration>
+                            </execution>
+                        </executions>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
     </profiles>
 
 </project>",2017-02-17T17:05:22Z,366
"@@ -1,17 +0,0 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
-<projectDescription>
-	<name>Resteasy</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.m2e.core.maven2Builder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.m2e.core.maven2Nature</nature>
-	</natures>
-</projectDescription>",2013-08-06T23:58:19Z,466
"@@ -0,0 +1,110 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <parent>
+        <groupId>org.jboss.resteasy</groupId>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <version>3.0.3.Final</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>org.jboss.resteasy.test</groupId>
+    <artifactId>as8-application-test</artifactId>
+    <packaging>war</packaging>
+    <description/>
+    <url>http://maven.apache.org</url>
+
+    <dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>javax.enterprise</groupId>
+            <artifactId>cdi-api</artifactId>
+            <version>1.0</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.spec.javax.ejb</groupId>
+            <artifactId>jboss-ejb-api_3.1_spec</artifactId>
+            <version>1.0.2.Final</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-jaxrs</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-client</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <finalName>ejb-singleton-test</finalName>
+        <plugins>
+            <plugin>
+                <groupId>org.jboss.as.plugins</groupId>
+                <artifactId>jboss-as-maven-plugin</artifactId>
+                <version>7.4.Final</version>
+                <executions>
+                    <execution>
+                        <id>jboss-deploy</id>
+                        <phase>pre-integration-test</phase>
+                        <goals>
+                            <goal>deploy</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>jboss-undeploy</id>
+                        <phase>post-integration-test</phase>
+                        <goals>
+                            <goal>undeploy</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <skip>true</skip>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>surefire-it</id>
+                        <phase>integration-test</phase>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+                        <configuration>
+                            <skip>false</skip>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-deploy-plugin</artifactId>
+                <configuration>
+                    <skip>true</skip>
+                </configuration>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>",2013-08-06T23:58:19Z,467
"@@ -0,0 +1,19 @@
+package org.jboss.resteasy.tests;
+
+import javax.ws.rs.ApplicationPath;
+import javax.ws.rs.core.Application;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@ApplicationPath(""/"")
+public class ScannedApplication extends Application
+{
+   public java.util.Set<java.lang.Class<?>> getClasses() {
+      Set<Class<?>> resources = new HashSet<Class<?>>();
+      resources.add(SingletonRootResource.class);
+      return resources;
+   }}",2013-08-06T23:58:19Z,468
"@@ -0,0 +1,13 @@
+package org.jboss.resteasy.tests;
+
+import javax.ws.rs.GET;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public interface SingletonLocalIF
+{
+   @GET
+   String get();
+}",2013-08-06T23:58:19Z,469
"@@ -0,0 +1,66 @@
+package org.jboss.resteasy.tests;
+
+
+import javax.annotation.PostConstruct;
+import javax.ejb.EJB;
+import javax.ejb.EJBException;
+import javax.ejb.Singleton;
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Application;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.Response;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@Singleton
+@Path(""root"")
+public class SingletonRootResource
+{
+   @EJB
+   SingletonSubResource sub;
+
+   @EJB
+   SingletonLocalIF rl;
+
+
+   @Path(""sub"")
+   public SingletonSubResource getSub()
+   {
+      return sub;
+   }
+
+   @Path(""intfsub"")
+   public SingletonLocalIF getLocalSub() {
+      return rl;
+   }
+
+
+   @Context
+   private Application injectedApplication;
+   private boolean isJaxrsInjectedPriorToPostConstruct = false;
+
+   @PostConstruct
+   public void postConstruct()
+   {
+      isJaxrsInjectedPriorToPostConstruct = injectedApplication != null;
+   }
+
+   @Path(""injected"")
+   @GET
+   public String injected(){
+      return String.valueOf(isJaxrsInjectedPriorToPostConstruct);
+   }
+
+   @Path(""exception"")
+   @GET
+   public String throwException (){
+      throw new EJBException(new WebApplicationException(Response.Status.CREATED));
+   }
+
+
+
+}",2013-08-06T23:58:19Z,470
"@@ -0,0 +1,19 @@
+package org.jboss.resteasy.tests;
+
+import javax.ejb.Singleton;
+import javax.ws.rs.GET;
+import javax.ws.rs.Produces;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+@Singleton
+public class SingletonSubResource
+{
+    @GET
+    @Produces(""text/plain"")
+    public String hello() {
+        return ""hello"";
+    }
+}",2013-08-06T23:58:19Z,471
"@@ -0,0 +1,30 @@
+package org.jboss.resteasy.tests;
+
+import javax.ejb.Local;
+import javax.ejb.Stateless;
+import javax.ws.rs.GET;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.UriInfo;
+
+@Stateless(name = ""SingletonTestBean"")
+@Local({ SingletonLocalIF.class })
+public class SingletonTestBean implements SingletonLocalIF
+{
+
+   public SingletonTestBean() {
+   }
+
+   public void remove() {
+   }
+
+   @Context
+   private UriInfo ui;
+
+   @Override
+   @GET
+   public String get() {
+      return ""GET: "" + ui.getRequestUri().toASCIIString() +
+              "" Hello From Singleton Local EJB Sub"";
+   }
+
+}
\ No newline at end of file",2013-08-06T23:58:19Z,472
"@@ -0,0 +1,7 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<web-app xmlns=""http://java.sun.com/xml/ns/javaee""
+      xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+      xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd""
+      version=""3.0"">
+
+</web-app>",2013-08-06T23:58:19Z,473
"@@ -0,0 +1,39 @@
+package org.jboss.resteasy.tests;
+
+import junit.framework.Assert;
+import org.junit.Test;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class ApplicationTest
+{
+
+   @Test
+   public void testSingleton() throws Exception
+   {
+      Client client = ClientBuilder.newClient();
+      String value = null;
+      WebTarget base = client.target(""http://localhost:8080/ejb-singleton-test/root"");
+      value = base.path(""sub"").request().get(String.class);
+      Assert.assertEquals(""hello"", value);
+      value = base.path(""injected"").request().get(String.class);
+      Assert.assertEquals(""true"", value);
+      value = base.path(""intfsub"").request().get(String.class);
+      System.out.println(value);
+
+      Response response = base.path(""exception"").request().get();
+      Assert.assertEquals(201, response.getStatus());
+
+
+
+      client.close();
+   }
+
+}",2013-08-06T23:58:19Z,474
"@@ -110,6 +110,7 @@
         <module>server-adapters</module>
         <module>war-tests</module>
         <!-- <module>as8-integration-testing</module> -->
+        <!-- <module>as8-integration-testing/ejb-singleton-test</module> -->
         <module>examples</module>
         <module>async-http-servlet-3.0</module>
         <module>jboss-modules</module>",2013-08-06T23:58:19Z,117
"@@ -0,0 +1,77 @@
+package org.jboss.resteasy.test.nextgen.resource;
+
+import org.jboss.resteasy.test.BaseResourceTest;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.NewCookie;
+import javax.ws.rs.core.Response;
+
+import java.util.List;
+import java.util.Map;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class CookieTest extends BaseResourceTest
+{
+   @Path(""cookie"")
+   public static class Resource
+   {
+      @GET
+      @Produces(""text/plain"")
+      public Response responseOk()
+      {
+         return Response.ok(""ok"").header(""Set-Cookie"", ""guid=1.9112608617070927872;Path=/;Domain=localhost;Expires=Thu, 03-May-2018 10:36:34 GMT;Max-Age=150000000"").build();
+      }
+
+   }
+
+   static Client client;
+
+   @BeforeClass
+   public static void setup()
+   {
+      addPerRequestResource(Resource.class);
+      client = ClientBuilder.newClient();
+   }
+
+   @AfterClass
+   public static void cleanup()
+   {
+      client.close();
+   }
+
+
+   @Test
+   public void testWeirdCookie()
+   {
+      Response response = client.target(generateURL(""/cookie"")).request().get();
+      Assert.assertEquals(response.getStatus(), 200);
+      Map<String,NewCookie> cookies = response.getCookies();
+      for (String key : cookies.keySet())
+      {
+         System.out.println(""["" + key + ""] >>>>>> "" + cookies.get(key) + """");
+      }
+      for (String header : response.getStringHeaders().keySet()) {
+         System.out.println(""header: "" + header);
+         List<String> values = response.getStringHeaders().get(header);
+         for (String val : values) {
+            System.out.println(""    "" + val);
+         }
+      }
+       Assert.assertTrue(cookies.containsKey(""guid""));
+      response.close();
+   }
+
+}",2013-08-06T23:58:19Z,475
"@@ -0,0 +1,77 @@
+package org.jboss.resteasy.test.nextgen.resource;
+
+import org.jboss.resteasy.test.BaseResourceTest;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.NewCookie;
+import javax.ws.rs.core.Response;
+
+import java.util.List;
+import java.util.Map;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class CookieTest extends BaseResourceTest
+{
+   @Path(""cookie"")
+   public static class Resource
+   {
+      @GET
+      @Produces(""text/plain"")
+      public Response responseOk()
+      {
+         return Response.ok(""ok"").header(""Set-Cookie"", ""guid=1.9112608617070927872;Path=/;Domain=localhost;Expires=Thu, 03-May-2018 10:36:34 GMT;Max-Age=150000000"").build();
+      }
+
+   }
+
+   static Client client;
+
+   @BeforeClass
+   public static void setup()
+   {
+      addPerRequestResource(Resource.class);
+      client = ClientBuilder.newClient();
+   }
+
+   @AfterClass
+   public static void cleanup()
+   {
+      client.close();
+   }
+
+
+   @Test
+   public void testWeirdCookie()
+   {
+      Response response = client.target(generateURL(""/cookie"")).request().get();
+      Assert.assertEquals(response.getStatus(), 200);
+      Map<String,NewCookie> cookies = response.getCookies();
+      for (String key : cookies.keySet())
+      {
+         System.out.println(""["" + key + ""] >>>>>> "" + cookies.get(key) + """");
+      }
+      for (String header : response.getStringHeaders().keySet()) {
+         System.out.println(""header: "" + header);
+         List<String> values = response.getStringHeaders().get(header);
+         for (String val : values) {
+            System.out.println(""    "" + val);
+         }
+      }
+       Assert.assertTrue(cookies.containsKey(""guid""));
+      response.close();
+   }
+
+}",2013-08-06T23:58:19Z,66
"@@ -1,114 +1,115 @@
 package org.jboss.resteasy.plugins.delegates;
 
+import org.jboss.resteasy.util.ParameterParser;
+
 import javax.ws.rs.core.NewCookie;
 import javax.ws.rs.ext.RuntimeDelegate;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Map;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class NewCookieHeaderDelegate implements RuntimeDelegate.HeaderDelegate
-{
-   public Object fromString(String newCookie) throws IllegalArgumentException
-   {
-      if (newCookie == null) throw new IllegalArgumentException(""NewCookie value is null"");
-
-      String cookieName = null;
-      String cookieValue = null;
-      String comment = null;
-      String domain = null;
-      int maxAge = NewCookie.DEFAULT_MAX_AGE;
-      String path = null;
-      boolean secure = false;
-      int version = NewCookie.DEFAULT_VERSION;
-      boolean httpOnly = false;
-
-
-      String parts[] = newCookie.split(""[;,]"");
-
-      for (String part : parts)
-      {
-         String nv[] = part.split(""="", 2);
-         String name = nv.length > 0 ? nv[0].trim() : """";
-         String value = nv.length > 1 ? nv[1].trim() : """";
-         if (value.startsWith(""\"""") && value.endsWith(""\"""") && value.length() > 1)
-            value = value.substring(1, value.length() - 1);
-
-         if (name.equalsIgnoreCase(""Comment""))
-            comment = value;
-         else if (name.equalsIgnoreCase(""Domain""))
-            domain = value;
-         else if (name.equalsIgnoreCase(""Max-Age""))
-            maxAge = Integer.parseInt(value);
-         else if (name.equalsIgnoreCase(""Path""))
-            path = value;
-         else if (name.equalsIgnoreCase(""Secure""))
-            secure = true;
-         else if (name.equalsIgnoreCase(""Version""))
-            version = Integer.parseInt(value);
-         else if (name.equalsIgnoreCase(""HttpOnly""))
-            httpOnly = true;
-         else
-         {
-            cookieName = name;
-            cookieValue = value;
-         }
-      }
-
-     return new NewCookie(cookieName, cookieValue, path, domain, version, comment, maxAge, null, secure, httpOnly);
-
-   }
-
-   protected void quote(StringBuilder b, String value)
-   {
-
-      if (MediaTypeHeaderDelegate.quoted(value))
-      {
-         b.append('""');
-         b.append(value);
-         b.append('""');
-      }
-      else
-      {
-         b.append(value);
-      }
-   }
-
-   public String toString(Object value)
-   {
-      if (value == null) throw new IllegalArgumentException(""param was null"");
-      NewCookie cookie = (NewCookie) value;
-      StringBuilder b = new StringBuilder();
-
-      b.append(cookie.getName()).append('=');
-      quote(b, cookie.getValue());
-
-      b.append("";"").append(""Version="").append(cookie.getVersion());
-
-      if (cookie.getComment() != null)
-      {
-         b.append("";Comment="");
-         quote(b, cookie.getComment());
-      }
-      if (cookie.getDomain() != null)
-      {
-         b.append("";Domain="");
-         quote(b, cookie.getDomain());
-      }
-      if (cookie.getPath() != null)
-      {
-         b.append("";Path="");
-         quote(b, cookie.getPath());
-      }
-      if (cookie.getMaxAge() != -1)
-      {
-         b.append("";Max-Age="");
-         b.append(cookie.getMaxAge());
-      }
-      if (cookie.isSecure())
-         b.append("";Secure"");
-      if (cookie.isHttpOnly())
-         b.append("";HttpOnly"");
-      return b.toString();
-   }
+public class NewCookieHeaderDelegate implements RuntimeDelegate.HeaderDelegate {
+    private final static String OLD_COOKIE_PATTERN = ""EEE, dd-MMM-yyyy HH:mm:ss z"";
+
+    public Object fromString(String newCookie) throws IllegalArgumentException {
+        if (newCookie == null) throw new IllegalArgumentException(""NewCookie value is null"");
+
+        String cookieName = null;
+        String cookieValue = null;
+        String comment = null;
+        String domain = null;
+        int maxAge = NewCookie.DEFAULT_MAX_AGE;
+        String path = null;
+        boolean secure = false;
+        int version = NewCookie.DEFAULT_VERSION;
+        boolean httpOnly = false;
+        Date expiry = null;
+
+        ParameterParser parser = new ParameterParser();
+        Map<String, String> map = parser.parse(newCookie, ';');
+
+        for (Map.Entry<String, String> entry : map.entrySet()) {
+            String name = entry.getKey();
+            String value = entry.getValue();
+            if (name.equalsIgnoreCase(""Comment""))
+                comment = value;
+            else if (name.equalsIgnoreCase(""Domain""))
+                domain = value;
+            else if (name.equalsIgnoreCase(""Max-Age""))
+                maxAge = Integer.parseInt(value);
+            else if (name.equalsIgnoreCase(""Path""))
+                path = value;
+            else if (name.equalsIgnoreCase(""Secure""))
+                secure = true;
+            else if (name.equalsIgnoreCase(""Version""))
+                version = Integer.parseInt(value);
+            else if (name.equalsIgnoreCase(""HttpOnly""))
+                httpOnly = true;
+            else if (name.equalsIgnoreCase(""Expires"")) {
+                try
+                {
+                    expiry = new SimpleDateFormat(OLD_COOKIE_PATTERN).parse(value);
+                }
+                catch (ParseException e)
+                {
+                }
+            } else {
+                cookieName = name;
+                cookieValue = value;
+            }
+
+        }
+
+        return new NewCookie(cookieName, cookieValue, path, domain, version, comment, maxAge, null, secure, httpOnly);
+
+    }
+
+    protected void quote(StringBuilder b, String value) {
+
+        if (MediaTypeHeaderDelegate.quoted(value)) {
+            b.append('""');
+            b.append(value);
+            b.append('""');
+        } else {
+            b.append(value);
+        }
+    }
+
+    public String toString(Object value) {
+        if (value == null) throw new IllegalArgumentException(""param was null"");
+        NewCookie cookie = (NewCookie) value;
+        StringBuilder b = new StringBuilder();
+
+        b.append(cookie.getName()).append('=');
+        quote(b, cookie.getValue());
+
+        b.append("";"").append(""Version="").append(cookie.getVersion());
+
+        if (cookie.getComment() != null) {
+            b.append("";Comment="");
+            quote(b, cookie.getComment());
+        }
+        if (cookie.getDomain() != null) {
+            b.append("";Domain="");
+            quote(b, cookie.getDomain());
+        }
+        if (cookie.getPath() != null) {
+            b.append("";Path="");
+            quote(b, cookie.getPath());
+        }
+        if (cookie.getMaxAge() != -1) {
+            b.append("";Max-Age="");
+            b.append(cookie.getMaxAge());
+        }
+        if (cookie.isSecure())
+            b.append("";Secure"");
+        if (cookie.isHttpOnly())
+            b.append("";HttpOnly"");
+        return b.toString();
+    }
 }",2013-08-06T23:58:19Z,50
"@@ -1,29 +1,29 @@
 Content-Type: application/pkcs7-mime;name=smime.p7m;smime-type=enveloped-data
-MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUBU
-gGNOMA0GCSqGSIb3DQEBAQUABIIBAGmf9qYc8SPqsAwTl8OWsQLj50z80Gg7rJnEOb0QuwUwx2Md
-5mpHe98jJpie3k8EIwcX97/DCS5f8FYFMH7kEsmYF729JIB/a8Mbgzxh3j8aX3lRk+Qlvo3r0P4i
-z2q202d+RTEokIiyfo8dHa1WfwifRLoA/XePMTqZnSYsSaJeOA/Hc3BdwjdjCVZjrxHwPXJZrakT
-Uu58r3zzaKhm/ZTAEdAo/g+ApMAKOgSM7jIzYlPiHC/bHlwZlTef3N1EzjiHcqXwj7+1AGT+Oo1+
-g5Y3Rww8oX0JyQnkNw9DIjymJzsQmmaFcjU6cbl5KbOJu6q+y8hMJ9Ovrf6yiuYoIK0wgAYJKoZI
-hvcNAQcBMBQGCCqGSIb3DQMHBAguc+zjtTwU6aCABIID6JyozPapymRT7YrudzPE8+09FJg1tp2R
-BInL/StI6yMfBfYp24BnrEsLjDGaP03Mvi4CzVEGLL1t7GQG0aw+aoa+Favq+SlQ+rqqLmQCcn0h
-fD/6+JzX0c42QJNh7rmPnTgVKrfu5DKLXmtocGNuI90GiJxl0IjXCMuNYmO9I2KApVQybRwOmp0G
-vK9gRYURtQY1usJhoqKhC+zjN44CzA2ZkOaapYSvELzAVseBJB0wQqtdoXCqafxlPgpuHS7gOxI/
-hF0oI7/KRN6bhQP4ZbLJzW7ZB/P/HRtxld4qp1j7p5K7NoUr+BJj0Dy8thP+TpCMo5gQ2NlPGUFp
-9NwQ4EE+B9ZOFCFTTsjhJ7qpR/waFH2D2tqfkxDpTZs3x/0OTBjrSjdCE5SDPgJvZt3sheN/Ecgz
-WZoDLyWVJFAttqeVjphZD9oHtCvHw0jbwjYYk0uNvm3K7O9aOFLinebR/l8F+KoRfbaG5fNVQWdz
-EzyiROKW2CUgew9rbjVsMZxi07Fsnk6BwBfMS+pzdZCmPBpdG62MaOBNMBIjKFsXV9s4aDZwNQH8
-LZb4s2iVEoQupeZ661mwgvKDVhfnOe8dDZYTtStE/BuaJ3XYEqUAUlp2iirol3YCUu4v3PR2oAUs
-zOCLa0I1gYMETtM+9bW38VW+kiMgRRSGcUanQbRyryJVypYHnekH9AW750I3YAwgOLkrIWJ6UHNZ
-96kr33mEagEVeBYyGC7WXx1XJJab3+KjoPSsaxI/B6U0/I0MxWlxAoM8XjKBV0At5KBGEXztLBqi
-pDKOgKNWhMbGIbWWAHiersNU5LgWHgD3bPeZJQkCMCF4OO/eIWgYOKNF7yX3+jIhah8Eui1UFn99
-krBF4UisL8u8/AkgpQd4ptwBh4gRa+CNXpN6xG5XruZJ7hHfh/cYWzrDgNakctqy9GgTYsMmT8iS
-2QvmUfx5wWINkGxlqp6ymJETw61DRsuLjnV0l8kZALVuhwIm+ewseu6jCsMm864Mao/uDb+03LkT
-rXyOi4GrkegSMThr7EdjkqrC4z5Hn8ruOI97R4JzSBmgm/P3/xhm6ZQSYfl4+aUdIzDH2Ut0hKcu
-xyI4eZFKtO2B3+XbajjZAbUk7wHmU7Uo/2l0xRGPCacBnbc5SMe/qC42Vvj6QkuGiExszVwbvD8k
-wx7KZoW4QYiCpjWWMlowjpiN1Kr4aposCzwhsHUFMHzg6tJVbLbPnD09oHhQFwOHRafHsiER5WXR
-BE1cbC5aEUWZ6MwPMh+IlOg5ieuT5OXB8aBeFf5uFDlrn/S/f0RRKO0Nh41axcekTeqSPo6oTS9B
-pbHymCNm130EgcCKSQ0dxxx79SGfdcUjNg4jJyVUvqu9pt3NAj20uiayW0DjTi1MfB1yWRZs8lzT
-UrlllqlhZHPsg4d9Mmzy5NAZUSVdsGikbWJmEd53se1kHXHv1YjPaIVNTFo7vgtKkPHsNE4Pfebo
-NxO7OCbnK2Jrq/FmrqNjC95SsxPugRQXBbeCWoTjSTQT+WY63s2wSaNnBpXhW5f6SPgzDUXSiS7d
-laqE8yLym03byGfRjkTvqzWmlGHg4WodLZyv+Jqd35QAAAAAAAAAAAAA
\ No newline at end of file
+MIAGCSqGSIb3DQEHA6CAMIACAQAxggE3MIIBMwIBADAbMBExDzANBgNVBAMTBklzc3VlcgIGAUBV
+o7wCMA0GCSqGSIb3DQEBAQUABIIBABHLZp29qUdUCQvFgPsD+LPBog2EJ653CoeIBiV2Ck6LYwHB
+p7reLTi4NVib+uRzMA75Z5vNS5sI/J94yO6wVCkDeTXZUpAvcf0ZkAmdCADETPAEdwppQTsT/7Zv
+t2JcfNFQKnfj5VRCVuJ6rK/63ZoGh7NCijHPMmiMYXVWdO1s69q4m3EOeNjh3d9uvg5culEMRQeS
+ROwS6WpnQsFgQfr9mGOxF+oZ/ZXc0LqTLoP78/vqgQ0FF5ET3i6n3tlFUuRdeIC/1aQi7gUL+yWS
+G3JhztyUq5QqhDOQQhu7PjOpgfTPfAYJlt8MRQih+SegS/2rMSzKzfx2VCkDxBkwI2MwgAYJKoZI
+hvcNAQcBMBQGCCqGSIb3DQMHBAglm781svdU3qCABIID6DSkdim9vNa3TkxS74eUMt/v/QTutFFr
+7LT0lO9YzxTCYFOTD9ebScFyL4OyywI1IhdmMhgfW0W0cL5VZepTTqT53kNTSo5DEu/nP1vMYsRa
+KUaIMWPjhpnj7moyhsKs2OT1c1P1MC0Ah1h4sOMQDraA8V488mM7fZGy862jCcjHzQu+nKEAODCZ
+ExbYjeGVQ1vHTgRzRayO+ywf78yGz99WIl4TnGOQ00hGgFZ+uN6XllRiXe866ehGbrKHW3cQmMpx
+qtDh1vKyOnBjr/uemuUmvBroGPpo1JxrMgavMJDQqOay1muXyeF4nzV1ksJLyBDbakTc3KOuKB7a
+zrHhoz2v3KU+1RnrsUSv4VT3nyeD6YU58OYTWQnGxMiUR1krD0DWHo0RqmFKCc8r8dstb8rMD+Di
+KidD1arviijcMJGtKNWf/6l/GNkAjgZ4WA2gE0pQzmUAz+A0ahMK+ddSvwMg12w0wdebsCT//pSM
+l17wn1fV9LPUGlKIr39DJICrc/cQWZTEaPWFPKdPvZ646VMQgDlqa67ArA8jh8TCbx08YobHBxl2
+qEo+7OdzzyeWnkeNUsk33DwgZh44BHBZaDgE8aOPsk+v5zMsekoWa3FNZ1WDU2qjxZ6R8YiD0ksu
+KQ1s0fbZwEZ3l5vBMPSscF5gg3HNIsVFRLGpd3rEjf1vWYz3eWRFI+L1KNrv8YiEm5CKH3z9kOcP
+9ezhgiuxCltzHe7NI/VYMLeIgErdH1SKM3zU3S6Y3Crzp9K0QB/f043DYyrEIvSX2R0oLe/QQV8r
+Z45GG8xwMwV3vOIqAIistNvHP8XVU61aDi0ra+sPikpi6GTFAZ7yx3HclzKDTpmsUUBtSA81AAy7
+91C/fvW8G09AulKpF/Ptx/NjuzooUgniuM9loYZASY1hotVObeI01OUAOlUW/Zv+hDRGQRJcUHde
+zp70g1Hb/HzX4C+XULeH3yswvtvUvnz45qq1iLsFP3ptEVlRDkCNqZBK/wub/MPnM95agtKlwQxP
+UrORMqzjmL4KauAPeekpkjISv8aHx6BNQJCmIn2yc3KGg0b+8BqP3p/dD+pCeyPpnRcNcVVAXvDl
+RCvZJQxT0+z5j+dSCWNZ29F6LXv6raWNAhYNifaZO0I+yM5hivxTDwR48/t9oWnCnOWmwvfSr/wS
+BDjM6d/tCaGFSqit6W/V/dN5lYZLX/dvj04XKGk7WoAuhk3ANF4Q6Soi2jvxlBQENxT40JVYV1UR
+lXcMumY6WtFWbj+kojwUW6KgfnvYvWoCgtV9Z9cLNK+5Hlwt13j4X+AIpWi4UXsLHqMBXbggecBz
+CbWJXxVuZEkEgbgj5m8zUekWhWXZmqYqzQZHYvzFZH6Cq/Lay++xwAQlTWKelftt8zKIyqvOVOxc
+BNU9OU7sQwdlzwYa3SVtKsoZOTlH2uqFm2KOREXQK3TCA6vFaXiDY2ZrLSJIu6dXj0+b1/jras5V
+Uh3s6Z+oQItAH3Vxp9kONtOx2GX8MuEtwGu9iyZ0/mvsXGM44lvS8stkQ1krow3PQC65Iuid/wVr
+c/goyiBveIcOC8SHpTJ4MK5CrV2OyHsCAAAAAAAAAAAAAA==
\ No newline at end of file",2013-08-06T23:58:19Z,165
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_19_116653404.1375807235181""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_19_1694118587.1375826328880""
 
-------=_Part_19_116653404.1375807235181
+------=_Part_19_1694118587.1375826328880
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_19_116653404.1375807235181
+------=_Part_19_1694118587.1375826328880
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDgwNjE2NDAzNVowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAsb9+u2k8g04RRIVweOO/9xlp
-81QWfGsjkLDCBkKYDQy2yLeIV0e8DgaImrFGFqJUUI3lsimmK+BFMrAwVQa0BqCdacz6ZyO1Np6/
-3fYdQQCAScd3x2i3Tz6En9A4Vu30JCgH3/dtKsLlNF/YdjG8EOSkt/P8eIGNu4rlcvS86qcAAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDgwNjIxNTg0OFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAJFY81Yl/RZQmphfpaiEu58kd
+fkFE4g3G4hRgFdNPWne1mQjR7/oBkGs3oF9RfsP0w0YkILpdRNWvKl9GPeRbyRtjYGFO39GGngBi
+Hp5KERVHeso3wBtEHX3/IP06qUW6dpHJyDYNxc7x63tcLncVfwxSrmadn7SsGWc8WNT8bogAAAAA
 AAA=
-------=_Part_19_116653404.1375807235181--
+------=_Part_19_1694118587.1375826328880--",2013-08-06T23:58:19Z,166
"@@ -1,10 +1,10 @@
-Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_21_1592426086.1375807235186""
+Content-Type: multipart/signed; protocol=""application/pkcs7-signature""; micalg=sha1;  boundary=""----=_Part_21_1688364846.1375826328885""
 
-------=_Part_21_1592426086.1375807235186
+------=_Part_21_1688364846.1375826328885
 Content-Type: application/xml
 
 <customer name=""bill""/>
-------=_Part_21_1592426086.1375807235186
+------=_Part_21_1688364846.1375826328885
 Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
 Content-Transfer-Encoding: base64
 Content-Disposition: attachment; filename=""smime.p7s""
@@ -13,9 +13,9 @@ Content-Description: S/MIME Cryptographic Signature
 MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
 AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
 ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
-BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDgwNjE2NDAzNVowIwYJKoZIhvcNAQkEMRYE
-FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAzCxyYsIqI35hgm+mIi9ohEv4
-Xh/uTUWsYCocC0n1qEKCbjvynF6XLmLRPKpyO+ejrcFGGdsp/AXKY7bBjnIlKe8GFRZxN2OWJq0/
-dVOP6eTdEAYrI7AyDkh7vhkIRmFjwxdnqSdCHXdavZfwTqyUAyrVHKA9+NbvfBAdz74rspsAAAAA
+BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDgwNjIxNTg0OFowIwYJKoZIhvcNAQkEMRYE
+FAJWFGwqddBF/ZGoA7RLuS8va26TMA0GCSqGSIb3DQEBAQUABIGAp1J+zo+emByE7JejJaFhb7J5
+8yC0+CsGct1NxtWkyfvRY2frm2+jZTBwoh4Nvak9btnHDhKKp2c+RNG3h63mOne475Ey0ICiUIJG
++9Bc6i/c9xEXPlUJ2/EXi5J7sOrS5KIbsJXz6DwdebyW4eOHWRjbmhPL0TkZ+uOf7k2QNfMAAAAA
 AAA=
-------=_Part_21_1592426086.1375807235186--
+------=_Part_21_1688364846.1375826328885--",2013-08-06T23:58:19Z,167
"@@ -32,9 +32,9 @@
 
 public class RestClientExtension implements Extension {
 
-    private static Set<RestClientData> proxyTypes = new LinkedHashSet<>();
+    private Set<RestClientData> proxyTypes = new LinkedHashSet<>();
 
-    private static Set<Throwable> errors = new LinkedHashSet<>();
+    private Set<Throwable> errors = new LinkedHashSet<>();
 
     public void registerRestClient(@Observes
                                    @WithAnnotations(RegisterRestClient.class) ProcessAnnotatedType<?> type) {",2019-10-25T00:33:20Z,11
"@@ -0,0 +1,67 @@
+package org.jboss.resteasy.test.microprofile.restclient;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Response;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.test.microprofile.restclient.resource.RestClientProxyRedeployRemoteService;
+import org.jboss.resteasy.test.microprofile.restclient.resource.RestClientProxyRedeployResource;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.asset.EmptyAsset;
+import org.jboss.shrinkwrap.api.asset.StringAsset;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(Arquillian.class)
+@RunAsClient
+public class RestClientProxyRedeployTest
+{
+   @Deployment(name=""deployment1"", order = 1)
+   public static Archive<?> deploy1() {
+      WebArchive war = TestUtil.prepareArchive(RestClientProxyRedeployTest.class.getSimpleName() + ""1"");
+      war.addClass(RestClientProxyRedeployRemoteService.class);
+      war.addAsManifestResource(new StringAsset(""Dependencies: org.eclipse.microprofile.restclient""), ""MANIFEST.MF"");
+      war.addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+      return TestUtil.finishContainerPrepare(war, null, RestClientProxyRedeployResource.class);
+   }
+
+   @Deployment(name=""deployment2"", order = 2)
+   public static Archive<?> deploy2() {
+      WebArchive war = TestUtil.prepareArchive(RestClientProxyRedeployTest.class.getSimpleName() + ""2"");
+      war.addClass(RestClientProxyRedeployRemoteService.class);
+      war.addAsManifestResource(new StringAsset(""Dependencies: org.eclipse.microprofile.restclient""), ""MANIFEST.MF"");
+      war.addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+      return TestUtil.finishContainerPrepare(war, null, RestClientProxyRedeployResource.class);
+   }
+
+   private String generateURL(String path, String suffix) {
+      return PortProviderUtil.generateURL(path, RestClientProxyRedeployTest.class.getSimpleName() + suffix);
+   }
+
+   @Test
+   public void testGet1() throws Exception {
+      Client client = ClientBuilder.newClient();
+      Response response = client.target(generateURL(""/test/1"", ""1"")).request().get();
+      Assert.assertEquals(200, response.getStatus());
+      String entity = response.readEntity(String.class);
+      Assert.assertEquals(""OK"", entity);
+      client.close();
+   }
+
+   @Test
+   public void testGet2() throws Exception {
+      Client client = ClientBuilder.newClient();
+      Response response = client.target(generateURL(""/test/1"", ""2"")).request().get();
+      Assert.assertEquals(200, response.getStatus());
+      String entity = response.readEntity(String.class);
+      Assert.assertEquals(""OK"", entity);
+      client.close();
+   }
+}
\ No newline at end of file",2019-10-25T00:33:20Z,476
"@@ -0,0 +1,15 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+
+@Path(""todos"")
+@RegisterRestClient(baseUri=""https://jsonplaceholder.typicode.com"")
+public interface RestClientProxyRedeployRemoteService {
+
+    @GET
+    @Path(""1"")
+    String get();
+}",2019-10-25T00:33:20Z,477
"@@ -0,0 +1,28 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import javax.ejb.Stateless;
+import javax.inject.Inject;
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+
+import org.eclipse.microprofile.rest.client.inject.RestClient;
+
+@Stateless
+@Path(""test"")
+public class RestClientProxyRedeployResource {
+
+    @Inject
+    @RestClient
+    private RestClientProxyRedeployRemoteService testService;
+
+    @GET
+    @Path(""1"")
+    public String test() {
+        try {
+            testService.get();
+        } catch (Exception e) {
+            return ""ERROR"";
+        }
+        return ""OK"";
+    }
+}",2019-10-25T00:33:20Z,478
"@@ -40,6 +40,7 @@
         <module>RESTEASY-1141-WF8</module>
         <module>RESTEASY-1141-jetty</module>
         <module>RESTEASY-1223-WF8</module>
+        <module>RESTEASY-TEST-WF10</module>
     </modules>
     
     <artifactId>arquillian</artifactId>",2016-02-13T03:27:28Z,479
"@@ -5,9 +5,12 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import javax.validation.ConstraintViolation;
@@ -36,7 +39,7 @@ public class ResteasyViolationException extends ConstraintViolationException
 {  
    private static final long serialVersionUID = 2623733139912277260L;
    
-   private List<MediaType> accept;
+   private List<CloneableMediaType> accept;
    private Exception exception;
    
    private List<ResteasyConstraintViolation> fieldViolations;
@@ -59,8 +62,8 @@ public ResteasyViolationException(Set<? extends ConstraintViolation<?>> constrai
    {
       super(constraintViolations);
       checkSuppressPath();
-      accept = new ArrayList<MediaType>();
-      accept.add(MediaType.TEXT_PLAIN_TYPE);
+      accept = new ArrayList<CloneableMediaType>();
+      accept.add(CloneableMediaType.TEXT_PLAIN_TYPE);
    }
    
    /**
@@ -73,7 +76,7 @@ public ResteasyViolationException(Set<? extends ConstraintViolation<?>> constrai
    {
       super(constraintViolations);
       checkSuppressPath();
-      this.accept = accept;
+      this.accept = toCloneableMediaTypeList(accept);
    }
    
    /**
@@ -105,16 +108,16 @@ public ResteasyViolationException(ViolationsContainer<?> container)
       super(null);
       convertToStrings(container);
       exception = container.getException();
-      accept = new ArrayList<MediaType>();
-      accept.add(MediaType.TEXT_PLAIN_TYPE);
+      accept = new ArrayList<CloneableMediaType>();
+      accept.add(CloneableMediaType.TEXT_PLAIN_TYPE);
    }
    
    public ResteasyViolationException(ViolationsContainer<?> container, List<MediaType> accept)
    {
       super(null);
       convertToStrings(container);
       exception = container.getException();
-      this.accept = accept;
+      this.accept = toCloneableMediaTypeList(accept);
    }
    
    public ResteasyViolationException(String stringRep)
@@ -126,12 +129,12 @@ public ResteasyViolationException(String stringRep)
    
    public List<MediaType> getAccept()
    {
-      return accept;
+      return toMediaTypeList(accept);
    }
 
    public void setAccept(List<MediaType> accept)
    {
-      this.accept = accept;
+      this.accept = toCloneableMediaTypeList(accept);
    }
 
    public Exception getException()
@@ -423,4 +426,57 @@ static protected String convertArrayToString(Object o)
       }
       return result;
    }
+   
+   /**
+    * It seems that EJB3 wants to clone ResteasyViolationException,
+    * and MediaType is not serializable.
+    *
+    */
+   static class CloneableMediaType implements Serializable
+   {
+      public static final CloneableMediaType TEXT_PLAIN_TYPE = new CloneableMediaType(""plain"", ""text"");  
+      private static final long serialVersionUID = 9179565449557464429L;
+      private String type;
+      private String subtype;
+      private Map<String, String> parameters;
+      
+      public CloneableMediaType(MediaType mediaType)
+      {
+         type = mediaType.getType();
+         subtype = mediaType.getSubtype();
+         parameters = new HashMap<String, String>(mediaType.getParameters());
+      }
+      
+      public CloneableMediaType(String type, String subtype)
+      {
+         this.type = type;
+         this.subtype = subtype;
+      }
+      
+      public MediaType toMediaType()
+      {
+         return new MediaType(type, subtype, parameters);
+      }
+   }
+   
+   static protected List<CloneableMediaType> toCloneableMediaTypeList(List<MediaType> list)
+   {
+      List<CloneableMediaType> cloneableList = new ArrayList<CloneableMediaType>();
+      for (Iterator<MediaType> it = list.iterator(); it.hasNext(); )
+      {
+         cloneableList.add(new CloneableMediaType(it.next()));
+      }
+      return cloneableList;
+   }
+   
+   static protected List<MediaType> toMediaTypeList(List<CloneableMediaType> cloneableList)
+   {
+      List<MediaType> list = new ArrayList<MediaType>();
+      for (Iterator<CloneableMediaType> it = cloneableList.iterator(); it.hasNext(); )
+      {
+         CloneableMediaType cmt = it.next();
+         list.add(new MediaType(cmt.type, cmt.subtype, cmt.parameters));
+      }
+      return list;
+   }
 }",2016-02-13T03:27:28Z,70
"@@ -24,6 +24,7 @@
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.jboss.resteasy.test.TestPortProvider.*;
@@ -266,6 +267,7 @@ public void register() {
 	}
 	
 	@Test
+	@Ignore
 	public void shouldValidateNothing() {
 		POJOResourceFactory factory = new POJOResourceFactory(ShouldNotValidateResource.Impl.class);
 		dispatcher.getRegistry().addResourceFactory(factory);
@@ -277,6 +279,7 @@ public void shouldValidateNothing() {
 	}
 	
 	@Test
+	@Ignore
 	public void shouldValidateJustOneMethod() {
 		POJOResourceFactory noDefaults = new POJOResourceFactory(ShouldValidateJustOneMethod.Impl.class);
 		dispatcher.getRegistry().addResourceFactory(noDefaults);
@@ -293,6 +296,7 @@ public void shouldValidateJustOneMethod() {
 	}
 	
 	@Test
+	@Ignore
 	public void shouldValidateAllMethods() {
 		POJOResourceFactory noDefaults = new POJOResourceFactory(ShouldValidateAllMethods.Impl.class);
 		dispatcher.getRegistry().addResourceFactory(noDefaults);
@@ -314,6 +318,7 @@ public void shouldValidateAllMethods() {
 	}
 	
 	@Test
+	@Ignore
 	public void shouldNotValidateOneMethod() {
 		POJOResourceFactory noDefaults = new POJOResourceFactory(ShouldNotValidateOneMethod.Impl.class);
 		dispatcher.getRegistry().addResourceFactory(noDefaults);
@@ -330,6 +335,7 @@ public void shouldNotValidateOneMethod() {
 	}
 	
 	@Test
+	@Ignore
 	public void shouldRespectInsertGroup() {
 		POJOResourceFactory noDefaults = new POJOResourceFactory(ShouldRespectGroups.Impl.class);
 		dispatcher.getRegistry().addResourceFactory(noDefaults);",2012-04-15T01:34:17Z,480
"@@ -46,6 +46,11 @@
             <artifactId>slf4j-api</artifactId>
             <scope>provided</scope>
         </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-simple</artifactId>
+            <scope>runtime</scope>
+        </dependency>
         <!--
            Scans classes on cp for annotations and builds quick lookup database
            of them.
@@ -87,6 +92,12 @@
             <groupId>net.jcip</groupId>
             <artifactId>jcip-annotations</artifactId>
         </dependency>
+        
+        <dependency>
+            <groupId>org.hibernate</groupId> 
+            <artifactId>hibernate-validator</artifactId>
+            <version>4.2.0.Final</version>
+        </dependency>
 
         <!-- Used by org.jboss.resteasy.plugins.server.tjws.* -->
         <!--",2012-04-15T01:34:17Z,111
"@@ -10,6 +10,7 @@
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.ext.ContextResolver;
 
+import org.jboss.resteasy.plugins.providers.validation.ViolationsContainer;
 import org.jboss.resteasy.spi.ApplicationException;
 import org.jboss.resteasy.spi.BadRequestException;
 import org.jboss.resteasy.spi.Failure;
@@ -18,7 +19,7 @@
 import org.jboss.resteasy.spi.InternalServerErrorException;
 import org.jboss.resteasy.spi.MethodInjector;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
-import org.jboss.resteasy.spi.validation.ValidatorAdapter;
+import org.jboss.resteasy.spi.validation.GeneralValidator;
 import org.jboss.resteasy.util.Types;
 
 /**
@@ -32,7 +33,6 @@ public class MethodInjectorImpl implements MethodInjector
    protected Class rootClass;
    protected ValueInjector[] params;
    protected ResteasyProviderFactory factory;
-   protected ValidatorAdapter validatorAdapter;
 
    public MethodInjectorImpl(Class root, Method method, ResteasyProviderFactory factory)
    {
@@ -80,10 +80,6 @@ public void put(List<Customer> l) {...}
          Annotation[] annotations = method.getParameterAnnotations()[i];
          params[i] = factory.getInjectorFactory().createParameterExtractor(root, method, type, genericType, annotations);
       }
-      
-      ContextResolver<ValidatorAdapter> contextResolver = factory.getContextResolver(ValidatorAdapter.class, MediaType.WILDCARD_TYPE);
-	  if( contextResolver == null ) return;
-	  validatorAdapter = contextResolver.getContext(null);
    }
    
    public static Method findInterfaceBasedMethod(Class root, Method method)
@@ -146,13 +142,25 @@ public Object invoke(HttpRequest request, HttpResponse httpResponse, Object reso
    {
       Object[] args = injectArguments(request, httpResponse);
       
-      if( validatorAdapter != null )
-    	  validatorAdapter.applyValidation(resource, invokedMethod, args);
+      GeneralValidator validator = GeneralValidator.class.cast(request.getAttribute(GeneralValidator.class.getName()));
+      ViolationsContainer<Object> violationsContainer = ViolationsContainer.class.cast(request.getAttribute(ViolationsContainer.class.getName()));
+      if (validator != null && violationsContainer != null)
+      {
+         violationsContainer.addViolations(validator.validateAllParameters(resource, invokedMethod, args));
+         if (violationsContainer.size() > 0)
+         {
+            return null;
+         }
+      }
       
       try
       {
-    	  
-         return invokedMethod.invoke(resource, args);
+         Object result = invokedMethod.invoke(resource, args);
+         if (validator != null && violationsContainer != null)
+         {
+            violationsContainer.addViolations(validator.validateReturnValue(resource, invokedMethod, result));
+         }
+         return result;
       }
       catch (IllegalAccessException e)
       {",2012-04-15T01:34:17Z,481
"@@ -3,6 +3,8 @@
 import org.jboss.resteasy.core.interception.InterceptorRegistry;
 import org.jboss.resteasy.core.interception.InterceptorRegistryListener;
 import org.jboss.resteasy.core.registry.Segment;
+import org.jboss.resteasy.plugins.providers.validation.ResteasyViolationExceptionExtension;
+import org.jboss.resteasy.plugins.providers.validation.ViolationsContainer;
 import org.jboss.resteasy.specimpl.UriInfoImpl;
 import org.jboss.resteasy.spi.HttpRequest;
 import org.jboss.resteasy.spi.HttpResponse;
@@ -13,6 +15,7 @@
 import org.jboss.resteasy.spi.interception.MessageBodyWriterInterceptor;
 import org.jboss.resteasy.spi.interception.PostProcessInterceptor;
 import org.jboss.resteasy.spi.interception.PreProcessInterceptor;
+import org.jboss.resteasy.spi.validation.GeneralValidator;
 import org.jboss.resteasy.util.HttpHeaderNames;
 import org.jboss.resteasy.util.Types;
 import org.jboss.resteasy.util.WeightedMediaType;
@@ -23,6 +26,8 @@
 import javax.ws.rs.core.GenericEntity;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ContextResolver;
+
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -58,6 +63,8 @@ public class ResourceMethod implements ResourceInvoker, InterceptorRegistryListe
    protected MessageBodyWriterInterceptor[] writerInterceptors;
    protected ConcurrentHashMap<String, AtomicLong> stats = new ConcurrentHashMap<String, AtomicLong>();
    protected Type genericReturnType;
+   protected GeneralValidator validator;
+   protected ViolationsContainer<?> violationsContainer;
 
 
    public ResourceMethod(Class<?> clazz, Method method, InjectorFactory injector, ResourceFactory resource, ResteasyProviderFactory providerFactory, Set<String> httpMethods)
@@ -120,6 +127,11 @@ public List<Customer> get() {...}
           }
        */
       genericReturnType = Types.getGenericReturnTypeOfGenericInterfaceMethod(clazz, method);
+      ContextResolver<GeneralValidator> resolver = providerFactory.getContextResolver(GeneralValidator.class, MediaType.WILDCARD_TYPE);
+      if (resolver != null)
+      {
+         validator = providerFactory.getContextResolver(GeneralValidator.class, MediaType.WILDCARD_TYPE).getContext(null);
+      }
    }
 
    public void cleanup()
@@ -242,6 +254,13 @@ public ServerResponse invoke(HttpRequest request, HttpResponse response, Object
 
    protected ServerResponse invokeOnTarget(HttpRequest request, HttpResponse response, Object target)
    {
+      if (validator != null)
+      {
+         violationsContainer = new ViolationsContainer<Object>(validator.validate(target));
+         request.setAttribute(ViolationsContainer.class.getName(), violationsContainer);
+         request.setAttribute(GeneralValidator.class.getName(), validator);
+      }
+      
       for (PreProcessInterceptor preInterceptor : preProcessInterceptors)
       {
          ServerResponse serverResponse = preInterceptor.preProcess(request, this);
@@ -261,6 +280,11 @@ protected ServerResponse invokeOnTarget(HttpRequest request, HttpResponse respon
          prepareResponse(ServerResponse.convertToServerResponse(wae.getResponse()));
          throw wae;
       }
+      
+      if (violationsContainer != null && violationsContainer.size() > 0)
+      {
+         throw new ResteasyViolationExceptionExtension(violationsContainer);
+      }
 
       if (request.isSuspended())
       {",2012-04-15T01:34:17Z,2
"@@ -23,6 +23,7 @@
 import javax.ws.rs.ext.MessageBodyWriter;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
@@ -34,8 +35,9 @@
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class ServerResponse extends Response
+public class ServerResponse extends Response implements Serializable
 {
+   private static final long serialVersionUID = 3458762447649978756L;
    protected Object entity;
    protected int status = HttpResponseCodes.SC_OK;
    protected Headers<Object> metadata = new Headers<Object>();",2012-04-15T01:34:17Z,482
"@@ -0,0 +1,47 @@
+package org.jboss.resteasy.plugins.providers.validation;
+
+import javax.validation.Validation;
+import javax.validation.Validator;
+import javax.ws.rs.ext.ContextResolver;
+import javax.ws.rs.ext.Provider;
+
+import org.hibernate.validator.HibernateValidator;
+import org.hibernate.validator.HibernateValidatorConfiguration;
+import org.hibernate.validator.method.MethodValidator;
+import org.jboss.resteasy.spi.validation.GeneralValidator;
+
+/**
+ * 
+ * @author Leandro Ferro Luzia
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ *
+ * @version $Revision: 1.1 $
+ * Created Mar 7, 2012
+ */
+@Provider
+public class DefaultHibernateValidatorContextResolver implements ContextResolver<GeneralValidator>
+{
+   private static final GeneralValidator generalValidator;
+   
+   static
+   {
+      HibernateValidatorConfiguration config = Validation.byProvider(HibernateValidator.class).configure();
+      Validator validator = config.buildValidatorFactory().getValidator();
+      MethodValidator methodValidator = null;
+      if (validator instanceof MethodValidator)
+      {
+         methodValidator = MethodValidator.class.cast(validator);
+      }
+      else
+      {
+         config = Validation.byProvider(HibernateValidator.class).configure();
+         methodValidator = config.buildValidatorFactory().getValidator().unwrap(MethodValidator.class); 
+      }
+      generalValidator = new GeneralValidatorImpl(validator, methodValidator); 
+   }
+
+   @Override
+   public GeneralValidator getContext(Class<?> type) {
+      return generalValidator; 
+   }
+}",2012-04-15T01:34:17Z,483
"@@ -0,0 +1,85 @@
+package org.jboss.resteasy.plugins.providers.validation;
+
+import java.lang.reflect.Method;
+import java.util.Set;
+
+import javax.validation.ConstraintViolation;
+import javax.validation.Validator;
+import javax.validation.metadata.BeanDescriptor;
+
+import org.hibernate.validator.method.MethodConstraintViolation;
+import org.hibernate.validator.method.MethodValidator;
+import org.hibernate.validator.method.metadata.TypeDescriptor;
+import org.jboss.resteasy.spi.validation.GeneralValidator;
+
+/** 
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Mar 7, 2012
+ */
+public class GeneralValidatorImpl implements GeneralValidator
+{
+   private Validator validator;
+   private MethodValidator methodValidator;
+   
+   public GeneralValidatorImpl(Validator validator, MethodValidator methodValidator)
+   {
+      this.validator = validator;
+      this.methodValidator = methodValidator;
+   }
+   
+   @Override
+   public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups)
+   {
+      return validator.validate(object, groups);
+   }
+
+   @Override
+   public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups)
+   {
+      return validator.validateProperty(object, propertyName, groups);
+   }
+
+   @Override
+   public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups)
+   {
+      return validator.validateValue(beanType, propertyName, value, groups);
+   }
+
+   @Override
+   public BeanDescriptor getConstraintsForClass(Class<?> clazz)
+   {
+      return validator.getConstraintsForClass(clazz);
+   }
+
+   @Override
+   public <T> T unwrap(Class<T> type)
+   {
+      return validator.unwrap(type);
+   }
+
+   @Override
+   public <T> Set<MethodConstraintViolation<T>> validateParameter(T object, Method method, Object parameterValue, int parameterIndex, Class<?>... groups)
+   {
+      return methodValidator.validateParameter(object, method, parameterValue, parameterIndex, groups);
+   }
+
+   @Override
+   public <T> Set<MethodConstraintViolation<T>> validateAllParameters(T object, Method method, Object[] parameterValues, Class<?>... groups)
+   {
+      return methodValidator.validateAllParameters(object, method, parameterValues, groups);
+   }
+
+   @Override
+   public <T> Set<MethodConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue, Class<?>... groups)
+   {
+      return methodValidator.validateReturnValue(object, method, returnValue, groups);
+   }
+
+   @Override
+   public TypeDescriptor getConstraintsForType(Class<?> clazz)
+   {
+      return methodValidator.getConstraintsForType(clazz);
+   }
+}",2012-04-15T01:34:17Z,9
"@@ -0,0 +1,40 @@
+package org.jboss.resteasy.plugins.providers.validation;
+
+import org.jboss.resteasy.spi.validation.ResteasyViolationException;
+
+/**
+ * 
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Mar 31, 2012
+ */
+public class ResteasyViolationExceptionExtension extends ResteasyViolationException
+{
+   private static final long serialVersionUID = -3374526252797501839L;
+   
+   public ResteasyViolationExceptionExtension(ViolationsContainer<?> container)
+   {
+      super(container);
+   }
+   
+   // Makes method available in package.
+   @SuppressWarnings(""rawtypes"")
+   protected ViolationsContainer getViolationsContainer()
+   {
+      return super.getViolationsContainer();
+   }
+   
+   // Makes method available in package.
+   @SuppressWarnings(""rawtypes"")
+   protected void setViolationsContainer(ViolationsContainer container)
+   {
+      super.setViolationsContainer(container);
+   }
+   
+   // Makes method available in package.
+   protected void convertToStrings()
+   {
+      super.convertToStrings();
+   }
+}",2012-04-15T01:34:17Z,484
"@@ -0,0 +1,31 @@
+package org.jboss.resteasy.plugins.providers.validation;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * 
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Mar 31, 2012
+ */
+@Provider
+public class ResteasyViolationExceptionMapper implements ExceptionMapper<ResteasyViolationExceptionExtension>
+{
+   public Response toResponse(ResteasyViolationExceptionExtension exception)
+   {
+      exception.convertToStrings();
+      exception.setViolationsContainer(null);
+      if (exception.getReturnValueViolations().size() == 0)
+      {
+        return Response.status(Status.BAD_REQUEST).type(""application/x-java-serialized-object"").entity(exception).build();
+      }
+      else
+      {
+         return Response.status(Status.INTERNAL_SERVER_ERROR).type(""application/x-java-serialized-object"").entity(exception).build();
+      }
+   }
+}",2012-04-15T01:34:17Z,26
"@@ -0,0 +1,297 @@
+package org.jboss.resteasy.plugins.providers.validation;
+
+import java.io.Serializable;
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.validation.ConstraintViolation;
+import javax.validation.Path.Node;
+
+import org.hibernate.validator.method.MethodConstraintViolation;
+
+/**
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Copyright Mar 6, 2012
+ */
+public class ViolationsContainer<T> implements Serializable
+{
+   private static final long serialVersionUID = -5048958457582876197L;
+   
+   private Set<ConstraintViolation<T>> fieldViolations       = new HashSet<ConstraintViolation<T>>();
+   private Set<ConstraintViolation<T>> propertyViolations    = new HashSet<ConstraintViolation<T>>();
+   private Set<ConstraintViolation<T>> classViolations       = new HashSet<ConstraintViolation<T>>();
+   private Set<ConstraintViolation<T>> parameterViolations   = new HashSet<ConstraintViolation<T>>();
+   private Set<ConstraintViolation<T>> returnValueViolations = new HashSet<ConstraintViolation<T>>();
+   
+   private enum ConstraintType {CLASS, FIELD, PROPERTY, PARAMETER, RETURN_VALUE};
+   
+   public ViolationsContainer()
+   {   
+   }
+   
+   public ViolationsContainer(Set<ConstraintViolation<T>> set)
+   {
+      addViolations(set);
+   }
+   
+   public ViolationsContainer(String s)
+   {
+      
+   }
+   
+   public void addViolations(Set<? extends ConstraintViolation<T>> set)
+   {
+      Iterator<? extends ConstraintViolation<T>> it = set.iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation<T> violation = it.next();
+         switch (getConstraintType(violation))
+         {
+            case FIELD:
+               fieldViolations.add(violation);
+               break;
+
+            case PROPERTY:
+               propertyViolations.add(violation);
+               break;
+
+            case CLASS:
+               classViolations.add(violation);
+               break;
+
+            case PARAMETER:
+               parameterViolations.add(violation);
+               break;
+
+            case RETURN_VALUE:
+               returnValueViolations.add(violation);
+               break;
+         }
+      }
+   }
+   
+   public void addFieldViolation(ConstraintViolation<T> v)
+   {
+      fieldViolations.add(v);
+   }
+   
+   public void addPropertyViolation(ConstraintViolation<T> v)
+   {
+      propertyViolations.add(v);
+   }
+   
+   public void addClassViolation(ConstraintViolation<T> v)
+   {
+      classViolations.add(v);
+   }
+   
+   public void addParameterViolation(ConstraintViolation<T> v)
+   {
+      parameterViolations.add(v);
+   }
+   
+   public void addReturnValueViolation(ConstraintViolation<T> v)
+   {
+      returnValueViolations.add(v);
+   }
+   
+   public Set<ConstraintViolation<T>> getFieldViolations()
+   {
+      return fieldViolations;
+   }
+   
+   public Set<ConstraintViolation<T>> getPropertyViolations()
+   {
+      return propertyViolations;
+   }
+   
+   public Set<ConstraintViolation<T>> getClassViolations()
+   {
+      return classViolations;
+   }
+   
+   public Set<ConstraintViolation<T>> getParameterViolations()
+   {
+      return parameterViolations;
+   }
+   
+   public Set<ConstraintViolation<T>> getReturnValueViolations()
+   {
+      return returnValueViolations;
+   }
+   
+   public int size()
+   {
+      return fieldViolations.size() +
+             propertyViolations.size() +
+             classViolations.size() + 
+             parameterViolations.size() +
+             returnValueViolations.size();
+   }
+   
+   public String toString()
+   {
+      StringBuffer sb = setToStringBuffer(fieldViolations);
+      sb.append(setToStringBuffer(propertyViolations));
+      sb.append(setToStringBuffer(classViolations));
+      sb.append(setToStringBuffer(parameterViolations));
+      sb.append(setToStringBuffer(returnValueViolations));
+      return sb.toString();
+   }
+   
+   private StringBuffer setToStringBuffer(Set<ConstraintViolation<T>> set)
+   {
+      StringBuffer sb = new StringBuffer();
+      Iterator<ConstraintViolation<T>> it = set.iterator();
+      while (it.hasNext())
+      {
+         sb.append(it.next().toString()).append('\r');
+      }
+      return sb;
+   }
+   
+   private ConstraintType getConstraintType(ConstraintViolation<T> v)
+   {
+      if (v instanceof MethodConstraintViolation)
+      {
+         MethodConstraintViolation<?> mv = MethodConstraintViolation.class.cast(v);
+         return mv.getKind() == MethodConstraintViolation.Kind.PARAMETER ? ConstraintType.PARAMETER : ConstraintType.RETURN_VALUE;
+      }
+      
+      Object o = v.getRootBean();
+      Class<?> containingClass = v.getRootBeanClass();
+      String fieldName = null;
+      Field field = null;
+      Iterator<Node>it = v.getPropertyPath().iterator();
+      while (it.hasNext())
+      {
+         Node node = it.next();
+         fieldName = node.getName();
+         if (fieldName == null)
+         {
+            return ConstraintType.CLASS;
+         }
+         try
+         {
+            o = unwrapCompoundObject(o, node);
+            containingClass = o.getClass();
+            field = getField(containingClass, fieldName);
+            field.setAccessible(true);
+            o = field.get(o);
+         }
+         catch (NoSuchFieldException e)
+         {
+            throw new RuntimeException(""Missing field"", e);
+         }
+         catch (IllegalAccessException e)
+         {
+            throw new RuntimeException(""Unable to access "" + fieldName, e);
+         }
+      }
+      String getterName = ""get"" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
+      try
+      {
+         getMethod(containingClass, getterName);
+         return ConstraintType.PROPERTY;
+      }
+      catch (NoSuchMethodException e)
+      {
+         return ConstraintType.FIELD;
+      }
+   }
+   
+   private Object unwrapCompoundObject(Object o, Node node)
+   {
+      Class<?> clazz = o.getClass();
+      if (Map.class.isAssignableFrom(clazz))
+      {
+         o = Map.class.cast(o).get(node.getKey());
+      }
+      else if (Iterable.class.isAssignableFrom(clazz))
+      {
+         o = List.class.cast(o).get(node.getIndex());
+      }
+      else if (clazz.isArray())
+      {
+         o = Array.get(o, node.getIndex());
+      }
+      return o;
+   }
+   
+   private Field getField(Class<?> clazz, String fieldName) throws NoSuchFieldException
+   {
+
+      Field field = null;
+      try
+      {
+         field = clazz.getDeclaredField(fieldName);
+      }
+      catch (NoSuchFieldException e)
+      {
+         // Ignore.
+      }
+      while (field == null)
+      {
+         clazz = clazz.getSuperclass();
+         if (clazz == null)
+         {
+            break;
+         }
+         try
+         {
+            field = clazz.getDeclaredField(fieldName);
+         }
+         catch (NoSuchFieldException e)
+         {
+            // Ignore.
+         }
+      }
+      if (field == null)
+      {
+         throw new NoSuchFieldException(fieldName);
+      }
+      return field;
+   }
+   
+   private Method getMethod(Class<?> clazz, String methodName) throws NoSuchMethodException
+   {
+      Method method = null;
+      try
+      {
+         method = clazz.getDeclaredMethod(methodName);
+      }
+      catch (NoSuchMethodException e)
+      {
+         // Ignore.
+      }
+      while (method == null)
+      {
+         clazz = clazz.getSuperclass();
+         if (clazz == null)
+         {
+            break;
+         }
+         try
+         {
+            method = clazz.getDeclaredMethod(methodName);
+         }
+         catch (NoSuchMethodException e)
+         {
+            // Ignore.
+         }
+      }
+      if (method == null)
+      {
+         throw new NoSuchMethodException(methodName);
+      }
+      return method;
+   }
+}",2012-04-15T01:34:17Z,485
"@@ -0,0 +1,16 @@
+package org.jboss.resteasy.spi.validation;
+
+import javax.validation.Validator;
+
+import org.hibernate.validator.method.MethodValidator;
+
+/** 
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Mar 7, 2012
+ */
+public interface GeneralValidator extends Validator, MethodValidator
+{
+
+}",2012-04-15T01:34:17Z,9
"@@ -0,0 +1,183 @@
+package org.jboss.resteasy.spi.validation;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.validation.ConstraintViolation;
+import javax.ws.rs.ViolationException;
+
+import org.jboss.resteasy.plugins.providers.validation.ViolationsContainer;
+
+/**
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Copyright Mar 6, 2012
+ * 
+ * @TODO Need to work on representation of exceptions
+ * @TODO Add javadoc.
+ */
+public class ResteasyViolationException extends ViolationException
+{
+   private static final long serialVersionUID = 2623733139912277260L;
+   
+   @SuppressWarnings(""rawtypes"")
+   private ViolationsContainer container;
+   
+   private List<String> allExceptions;
+   
+   private List<String> fieldViolations       = new ArrayList<String>();
+   private List<String> propertyViolations    = new ArrayList<String>();
+   private List<String> classViolations       = new ArrayList<String>();
+   private List<String> parameterViolations   = new ArrayList<String>();
+   private List<String> returnValueViolations = new ArrayList<String>();
+   
+   public ResteasyViolationException()
+   {
+      super();
+   }
+
+   public ResteasyViolationException(List<String> exceptions)
+   {
+      super(exceptions);
+   }
+   
+   public ResteasyViolationException(ViolationsContainer<?> container)
+   {
+      super();
+      this.container = container;
+   }
+   
+   public void setExceptions(List<String> exceptions)
+   {
+      this.allExceptions = exceptions;
+   }
+   
+   public List<String> getExceptions()
+   {
+      if (allExceptions == null)
+      {
+         allExceptions = new ArrayList<String>();
+         allExceptions.addAll(fieldViolations);
+         allExceptions.addAll(propertyViolations);
+         allExceptions.addAll(classViolations);
+         allExceptions.addAll(parameterViolations);
+         allExceptions.addAll(returnValueViolations);
+      }
+      return allExceptions;
+   }
+   
+   public List<String> getFieldViolations()
+   {
+      return fieldViolations;
+   }
+   
+   public List<String> getPropertyViolations()
+   {
+      return propertyViolations;
+   }
+   
+   public List<String> getClassViolations()
+   {
+      return classViolations;
+   }
+   
+   public List<String> getParameterViolations()
+   {
+      return parameterViolations;
+   }
+   
+   public List<String> getReturnValueViolations()
+   {
+      return returnValueViolations;
+   }
+   
+   public int size()
+   {
+      return fieldViolations.size() +
+            propertyViolations.size() +
+            classViolations.size() + 
+            parameterViolations.size() +
+            returnValueViolations.size();
+   }
+   
+   @SuppressWarnings(""rawtypes"")
+   protected ViolationsContainer getViolationsContainer()
+   {
+      return container;
+   }
+   
+   @SuppressWarnings(""rawtypes"")
+   protected void setViolationsContainer(ViolationsContainer container)
+   {
+      this.container = container;
+   }
+   
+   @SuppressWarnings(""rawtypes"")
+   protected void convertToStrings()
+   {
+      Iterator it = container.getFieldViolations().iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation cv = (ConstraintViolation) it.next();
+         fieldViolations.add(cv.getMessage() + ""; "" + cv.getInvalidValue().toString());
+      }
+      
+      it = container.getPropertyViolations().iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation cv = (ConstraintViolation) it.next();
+         propertyViolations.add(cv.getMessage() + ""; "" + cv.getInvalidValue().toString());
+      }
+      
+      it = container.getClassViolations().iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation cv = (ConstraintViolation) it.next();
+         classViolations.add(cv.getMessage() + ""; "" + cv.getInvalidValue().toString());
+      }
+      
+      it = container.getParameterViolations().iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation cv = (ConstraintViolation) it.next();
+         parameterViolations.add(cv.getMessage() + ""; "" + cv.getInvalidValue().toString());
+      }
+      
+      it = container.getReturnValueViolations().iterator();
+      while (it.hasNext())
+      {
+         ConstraintViolation cv = (ConstraintViolation) it.next();
+         returnValueViolations.add(cv.getMessage() + ""; "" + cv.getInvalidValue().toString());
+      }
+   }
+   
+   protected String expandDelimiter(String s)
+   {
+      StringBuffer sb = new StringBuffer();
+      for (int i = 0; i < s.length(); i++)
+      {
+         sb.append(s.charAt(i));
+         if (s.charAt(i) == ':')
+         {
+            sb.append(':');
+         }
+      }
+      return sb.toString();
+   }
+   
+   protected String contractDelimiter(String s)
+   {
+      StringBuffer sb = new StringBuffer();
+      for (int i = 0; i < s.length(); i++)
+      {
+         sb.append(s.charAt(i));
+         if (s.charAt(i) == ':' && s.charAt(i + 1) == ':')
+         {
+            i++;
+         }
+      }
+      return sb.toString();
+   }
+}",2012-04-15T01:34:17Z,70
"@@ -0,0 +1,23 @@
+package org.jboss.resteasy.spi.validation;
+
+/**
+ *
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Apr 3, 2012
+ * 
+ * @TODO: Work out representation of exceptions for client.
+ */
+public class ViolationUtils
+{
+   public static String getMessage(String violation)
+   {
+      return violation.substring(0, violation.indexOf(';'));
+   }
+   
+   public static String getInvalidObject(String violation)
+   {
+      return violation.substring(violation.indexOf(""; "") + 2);
+   }
+}",2012-04-15T01:34:17Z,486
"@@ -8,6 +8,9 @@ org.jboss.resteasy.plugins.providers.FormUrlEncodedProvider
 org.jboss.resteasy.plugins.providers.FileProvider
 org.jboss.resteasy.plugins.providers.StreamingOutputProvider
 org.jboss.resteasy.plugins.providers.IIOImageProvider
+org.jboss.resteasy.plugins.providers.SerializableProvider
+org.jboss.resteasy.plugins.providers.validation.DefaultHibernateValidatorContextResolver
+org.jboss.resteasy.plugins.providers.validation.ResteasyViolationExceptionMapper
 org.jboss.resteasy.plugins.interceptors.CacheControlInterceptor
 org.jboss.resteasy.plugins.interceptors.encoding.AcceptEncodingGZIPInterceptor
 org.jboss.resteasy.plugins.interceptors.encoding.ClientContentEncodingHeaderInterceptor",2012-04-15T01:34:17Z,95
"@@ -0,0 +1,1450 @@
+package org.jboss.resteasy.test.validation;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Serializable;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.validation.Constraint;
+import javax.validation.ConstraintValidator;
+import javax.validation.ConstraintValidatorContext;
+import javax.validation.Payload;
+import javax.validation.Valid;
+import javax.validation.constraints.NotNull;
+import javax.validation.constraints.Pattern;
+import javax.validation.constraints.Size;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.CookieParam;
+import javax.ws.rs.FormParam;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.MatrixParam;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Cookie;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Provider;
+
+import junit.framework.Assert;
+
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
+import org.jboss.resteasy.core.Dispatcher;
+import org.jboss.resteasy.plugins.providers.validation.ViolationsContainer;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.spi.validation.ResteasyViolationException;
+import org.jboss.resteasy.spi.validation.ViolationUtils;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import org.junit.Test;
+
+/**
+ * 
+ * @author <a href=""ron.sigal@jboss.com"">Ron Sigal</a>
+ * @version $Revision: 1.1 $
+ *
+ * Created Mar 16, 2012
+ */
+public class TestValidation
+{
+   protected static ResteasyDeployment deployment;
+   protected static Dispatcher dispatcher;
+
+   @Path(""/"")
+   public static class TestResourceWithValidField
+   {
+      @SuppressWarnings(""unused"")
+      @Size(min=2, max=4)
+      private String s = ""abc"";
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   @Path(""/"")
+   public static class TestResourceWithInvalidField
+   {
+      @SuppressWarnings(""unused"")
+      @Size(min=2, max=4)
+      private String s = ""abcde"";
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   @Path(""/{s}"")
+   public static class TestResourceWithProperty
+   {
+      private String s;
+
+      @POST
+      public void post()
+      {
+      }
+
+      @Size(min=2, max=4)  
+      public String getS()
+      {
+         return s;
+      }
+
+      @PathParam(""s"") 
+      public void setS(String s)
+      {
+         this.s = s;
+      }
+   }
+
+   @Path(""/{s}/{t}"")
+   public static class TestResourceWithFieldAndProperty
+   {
+      @SuppressWarnings(""unused"")
+      @Size(min=2, max=4)
+      @PathParam(""s"")
+      private String s;
+
+      private String t;
+
+      @Size(min=3, max=5)  
+      public String getT()
+      {
+         return t;
+      }
+
+      @PathParam(""t"") 
+      public void setT(String t)
+      {
+         this.t = t;
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   public static class TestClassValidator implements ConstraintValidator<TestClassConstraint, TestResourceWithClassConstraint>
+   {
+      int length;
+
+      public void initialize(TestClassConstraint constraintAnnotation)
+      {
+         length = constraintAnnotation.value();
+      }
+
+      public boolean isValid(TestResourceWithClassConstraint value, ConstraintValidatorContext context)
+      {
+         return value.s.length() + value.t.length() >= length;
+      }
+
+   }
+
+   @Documented
+   @Constraint(validatedBy = TestClassValidator.class)
+   @Target({TYPE})
+   @Retention(RUNTIME)
+   public @interface TestClassConstraint {
+      String message() default ""Concatenation of s and t must have length > {value}"";
+      Class<?>[] groups() default {};
+      Class<? extends Payload>[] payload() default {};
+      int value();
+   }
+
+   @Path(""/{s}/{t}"")
+   @TestClassConstraint(5)
+   public static class TestResourceWithClassConstraint
+   {
+      @NotNull String s;
+      @NotNull String t;
+
+      public TestResourceWithClassConstraint(@PathParam(""s"") String s, @PathParam(""t"") String t)
+      {
+         this.s = s;
+         this.t = t;  
+      }
+
+      @POST
+      public void post()
+      {
+      }
+
+      public String toString()
+      {
+         return ""TestResourceWithClassConstraint(\"""" + s + ""\"", \"""" + t + ""\"")"";
+      }
+   }
+
+   public static class A
+   {
+      @Size(min=4) String s1;
+      @Size(min=5) String s2;
+
+      public A(String s1, String s2)
+      {
+         this.s1 = s1;
+         this.s2 = s2;
+      }
+      public void setS2(String s)
+      {
+         this.s2 = s;
+      }
+      public String getS2()
+      {
+         return s2;
+      }
+   }
+
+   public static class B
+   {
+      @Valid A a;
+
+      public B(A a) {this.a = a;}
+   }
+
+   @Path(""/{s}/{t}"")
+   public static class TestResourceWithGraph
+   {
+      @Valid B b;
+
+      public TestResourceWithGraph(@PathParam(""s"") String s, @PathParam(""t"") String t)
+      {
+         b = new B(new A(s, t));
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   public static class OneString
+   {
+      @Size(min=5) String s;
+
+      public OneString(String s)
+      {
+         this.s = s;
+      }
+      public String getS()
+      {
+         return s;
+      }
+      public void setString(String s)
+      {
+         this.s = s;
+      }
+   }
+
+   public static class ArrayOfStrings
+   {
+      @Valid OneString[] strings;
+
+      public ArrayOfStrings(String s)
+      {
+         strings = new OneString[]{new OneString(s)};
+      }
+   }
+
+   @Path(""/{s}"")
+   public static class TestResourceWithArray
+   {
+      @Valid ArrayOfStrings aos;
+
+
+      public TestResourceWithArray(@PathParam(""s"") String s)
+      {
+         aos = new ArrayOfStrings(s);
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   public static class ListOfStrings
+   {
+      @Valid List<OneString> strings;
+
+      public ListOfStrings(String s)
+      {
+         strings = new ArrayList<OneString>();
+         strings.add(new OneString(s));
+      }
+   }
+
+   @Path(""/{s}"")
+   public static class TestResourceWithList
+   {
+      @Valid ListOfStrings los;
+
+      public TestResourceWithList(@PathParam(""s"") String s)
+      {
+         los = new ListOfStrings(s);
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   public static class MapOfStrings
+   {
+      @Valid Map<String,OneString> strings;
+
+      public MapOfStrings(String s)
+      {
+         strings = new HashMap<String,OneString>();
+         strings.put(s, new OneString(s));
+      }
+   }
+
+   @Path(""/{s}"")
+   public static class TestResourceWithMap
+   {
+      @Valid MapOfStrings mos;
+
+      public TestResourceWithMap(@PathParam(""s"") String s)
+      {
+         mos = new MapOfStrings(s);
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   public static class ListOfArrayOfStrings
+   {
+      @Valid List<ArrayOfStrings> list;
+
+      public ListOfArrayOfStrings(String s)
+      {
+         list = new ArrayList<ArrayOfStrings>();
+         list.add(new ArrayOfStrings(s));
+      }
+   }
+
+   public static class MapOfListOfArrayOfStrings
+   {
+      @Valid Map<String, ListOfArrayOfStrings> map;
+
+      public MapOfListOfArrayOfStrings(String s)
+      {
+         map = new HashMap<String, ListOfArrayOfStrings>();
+         map.put(s, new ListOfArrayOfStrings(s));
+      }
+   }
+
+   @Path(""/{s}"")
+   public static class TestResourceWithMapOfListOfArrayOfStrings
+   {
+      @Valid MapOfListOfArrayOfStrings mlas;
+
+      public TestResourceWithMapOfListOfArrayOfStrings(@PathParam(""s"") String s)
+      {
+         mlas = new MapOfListOfArrayOfStrings(s);
+      }
+
+      @POST
+      public void post()
+      {
+      }
+   }
+
+   @FooConstraint(min=1,max=3)
+   public static class Foo implements Serializable
+   {
+      private static final long serialVersionUID = -1068336400309384949L;
+      private String s;
+
+      public Foo(String s)
+      {
+         this.s = s;
+      }
+      public String toString()
+      {
+         return ""Foo["" + s + ""]"";
+      }
+      public boolean equals(Object o)
+      {
+         if (o == null || !(o instanceof Foo))
+         {
+            return false;
+         }
+         return this.s.equals(Foo.class.cast(o).s);
+      }
+   }
+
+   public static class FooValidator implements ConstraintValidator<FooConstraint, Foo>
+   {
+      int min;
+      int max;
+
+      public void initialize(FooConstraint constraintAnnotation)
+      {
+         min = constraintAnnotation.min();
+         max = constraintAnnotation.max();
+      }
+      public boolean isValid(Foo value, ConstraintValidatorContext context)
+      {
+         return min <= value.s.length() && value.s.length() <= max;
+      }
+   }
+
+   @Documented
+   @Constraint(validatedBy = FooValidator.class)
+   @Target({TYPE,PARAMETER,METHOD})
+   @Retention(RUNTIME)
+   public @interface FooConstraint {
+      String message() default ""s must have length: {min} <= length <= {max}"";
+      Class<?>[] groups() default {};
+      Class<? extends Payload>[] payload() default {};
+      int min();
+      int max();
+   }
+
+   @Provider
+   @Produces(""application/foo"")
+   @Consumes(""application/foo"")
+   public static class FooReaderWriter implements MessageBodyReader<Foo>, MessageBodyWriter<Foo>
+   {
+      public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
+      {
+         return Foo.class.equals(type);
+      }
+      public long getSize(Foo t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
+      {
+         return -1;
+      }
+      public void writeTo(Foo t, Class<?> type, Type genericType,
+            Annotation[] annotations, MediaType mediaType,
+            MultivaluedMap<String, Object> httpHeaders,
+            OutputStream entityStream) throws IOException,
+            WebApplicationException
+      {
+    	  byte[] b = t.s.getBytes();
+    	  entityStream.write(b.length);
+    	  entityStream.write(t.s.getBytes());
+    	  entityStream.flush();
+      }
+      public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
+      {
+         return Foo.class.equals(type);
+      }
+      public Foo readFrom(Class<Foo> type, Type genericType,
+            Annotation[] annotations, MediaType mediaType,
+            MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
+      {
+    	  int length = entityStream.read();
+    	  byte[] b = new byte[length]; 
+    	  entityStream.read(b);
+    	  String s = new String(b);
+    	  return new Foo(s);
+      }
+   }
+
+   @Path(""/"")
+   public static class TestResourceWithParameters
+   {  
+      @POST
+      @Path(""/native"")
+      public void postNative(@Valid Foo foo)
+      {
+      }
+
+      @POST
+      @Path(""/imposed"")
+      public void postImposed(@FooConstraint(min=3,max=5) Foo foo)
+      {
+      }
+
+      @POST
+      @Path(""nativeAndImposed"")
+      public void postNativeAndImposed(@Valid @FooConstraint(min=3,max=5) Foo foo)
+      {
+      }
+      
+      @POST
+      @Path(""other/{p}"")
+      public void postOther(@Size(min=2,max=3) @PathParam(""p"")   String p,
+    		                @Size(min=2,max=3) @MatrixParam(""m"") String m,
+    		                @Size(min=2,max=3) @QueryParam(""q"")  String q,
+    		                @Size(min=2,max=3) @FormParam(""f"")   String f,
+    		                @Size(min=2,max=3) @HeaderParam(""h"") String h,
+    		                @Size(min=2,max=3) @CookieParam(""c"") String c
+    		                )
+      {
+      }
+   }
+
+   @Path(""/"")
+   public static class TestResourceWithReturnValues
+   {  
+      @POST
+      @Path(""/native"")
+      @Valid
+      public Foo postNative(Foo foo)
+      {
+         return foo;
+      }
+
+      @POST
+      @Path(""/imposed"")
+      @FooConstraint(min=3,max=5)
+      public Foo postImposed(Foo foo)
+      {
+         return foo;
+      }
+      
+      @POST
+      @Path(""nativeAndImposed"")
+      @Valid
+      @FooConstraint(min=3,max=5)
+      public Foo postNativeAndImposed(Foo foo)
+      {
+         return foo;
+      }
+   }
+   
+   public static class TestClassValidator2 implements ConstraintValidator<TestClassConstraint2, TestResourceWithAllFivePotentialViolations>
+   {
+      int length;
+
+      public void initialize(TestClassConstraint2 constraintAnnotation)
+      {
+         length = constraintAnnotation.value();
+      }
+
+      public boolean isValid(TestResourceWithAllFivePotentialViolations value, ConstraintValidatorContext context)
+      {
+         return value.s.length() + value.t.length() >= length;
+      }
+
+   }
+
+   @Documented
+   @Constraint(validatedBy = TestClassValidator2.class)
+   @Target({TYPE})
+   @Retention(RUNTIME)
+   public @interface TestClassConstraint2 {
+      String message() default ""Concatenation of s and t must have length > {value}"";
+      Class<?>[] groups() default {};
+      Class<? extends Payload>[] payload() default {};
+      int value();
+   }
+   
+   @Path(""/{s}/{t}"")
+   @TestClassConstraint2(5)
+   public static class TestResourceWithAllFivePotentialViolations
+   {
+      @Size(min=2, max=4)
+      @PathParam(""s"")
+      private String s;
+
+      private String t;
+
+      @Size(min=3, max=5)  
+      public String getT()
+      {
+         return t;
+      }
+
+      @PathParam(""t"") 
+      public void setT(String t)
+      {
+         this.t = t;
+      }
+
+      @POST
+      @FooConstraint(min=4,max=5)
+      public Foo post( @FooConstraint(min=3,max=5) Foo foo)
+      {
+         return foo;
+      }
+   }
+   
+   public interface InterfaceTest
+   {
+	   @Path(""/inherit"")
+	   @POST
+	   @Size(min=2,max=3) String postInherit(@Size(min=2,max=3) String s);
+	   
+	   @Path(""/override"")
+	   @POST
+	   @Size(min=2,max=3) String postOverride(@Size(min=2,max=3) String s);
+   }
+   
+   @Path(""/"")
+   public static class InterFaceTestSuper implements InterfaceTest
+   {
+	   public String postInherit(String s)
+	   {
+		   return s;
+	   }
+	   public String postOverride(String s)
+	   {
+		   return s;
+	   }
+   }
+   
+   @Path(""/"")
+   public static class InterfaceTestSub extends InterFaceTestSuper
+   {
+	   @Pattern(regexp=""[a-z]+"") public String postOverride(@Pattern(regexp=""[a-z]+"") String s)
+	   {
+		   return s;
+	   }
+   }
+   
+   @Path(""/"")
+   public static class TestResourceWithSubLocators
+   {
+      @Path(""validField"")
+      public TestResourceWithValidField validField()
+      {
+         return new TestResourceWithValidField();
+      }
+      
+      @Path(""invalidField"")
+      public TestResourceWithInvalidField invalidField()
+      {
+         return new TestResourceWithInvalidField();
+      }
+      
+      @Path(""property/{s}"")
+      public TestResourceWithProperty property(@PathParam(""s"") String s)
+      {
+         TestResourceWithProperty subResource = new TestResourceWithProperty();
+         subResource.setS(s);
+         return subResource;
+      }
+      
+      @Path(""everything/{s}/{t}"")
+      public TestResourceWithAllFivePotentialViolations everything(@PathParam(""s"") String s, @PathParam(""t"") String t)
+      {
+         TestResourceWithAllFivePotentialViolations subresource = new TestResourceWithAllFivePotentialViolations();
+         try
+         {
+            Field field = TestResourceWithAllFivePotentialViolations.class.getDeclaredField(""s"");
+            field.setAccessible(true);
+            field.set(subresource, s);
+            subresource.setT(t);
+            return subresource;
+         }
+         catch (Exception e)
+         {
+            throw new WebApplicationException(e);
+         }
+      }
+      
+      @Path(""sub/{s}"")
+      public static class SubResource
+      {
+         @Path(""/"")
+         public SubSubResource sub(@PathParam(""s"") String s)
+         {
+            return new SubSubResource(s);
+         }
+      }
+      
+      @Path("""")
+      public static class SubSubResource
+      {
+         @Size(min=2,max=3) String s;
+         
+         public SubSubResource(String s)
+         {
+            this.s = s;
+         }
+         
+         @POST
+         public void subSub()
+         {
+         }
+      }
+      
+      @Path(""sub"")
+      public SubResource sub()
+      {
+         return new SubResource();
+      }
+   }
+
+   public static void before(Class<?> resourceClass) throws Exception
+   {
+      deployment = EmbeddedContainer.start();
+      dispatcher = deployment.getDispatcher();
+      deployment.getRegistry().addPerRequestResource(resourceClass);
+   }
+
+   public static void beforeFoo(Class<?> resourceClass) throws Exception
+   {
+      before(resourceClass);
+      deployment.getProviderFactory().addMessageBodyReader(FooReaderWriter.class);
+      deployment.getProviderFactory().addMessageBodyWriter(FooReaderWriter.class);
+   }
+   
+   public static void beforeFooAsynch(Class<?> resourceClass) throws Exception
+   {
+      ResteasyDeployment deployment = new ResteasyDeployment();
+      deployment.setAsyncJobServiceEnabled(true);
+      EmbeddedContainer.start(deployment);
+      dispatcher = deployment.getDispatcher();
+      dispatcher.getRegistry().addPerRequestResource(resourceClass);
+      deployment.getProviderFactory().addMessageBodyReader(FooReaderWriter.class);
+      deployment.getProviderFactory().addMessageBodyWriter(FooReaderWriter.class);
+   }
+
+   public static void after() throws Exception
+   {
+      EmbeddedContainer.stop();
+      dispatcher = null;
+      deployment = null;
+   }
+
+   @Test
+   public void testFieldValid() throws Exception
+   {
+      before(TestResourceWithValidField.class);
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      ClientResponse<?> response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+      after();
+   }
+
+   @Test
+   public void testFieldInvalid() throws Exception
+   {
+      before(TestResourceWithInvalidField.class);
+      ClientRequest request = new ClientRequest(generateURL(""/""));
+      ClientResponse<?> response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 1, 0, 0, 0, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""abcde"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testPropertyValid() throws Exception
+   {
+      before(TestResourceWithProperty.class);
+      ClientRequest request = new ClientRequest(generateURL(""/abc""));
+      ClientResponse<?> response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+      after();
+   }
+
+   @Test
+   public void testPropertyInvalid() throws Exception
+   {
+      before(TestResourceWithProperty.class);
+      ClientRequest request = new ClientRequest(generateURL(""/abcdef""));
+      ClientResponse<?> response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      String cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""abcdef"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testFieldAndProperty() throws Exception
+   {
+      before(TestResourceWithFieldAndProperty.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abc/wxyz""));
+      ClientResponse<?> response = request.post(Serializable.class);
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/a/uvwxyz""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 2, 1, 1, 0, 0, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""a"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 3 and 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""uvwxyz"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testClassConstraint() throws Exception
+   {
+      before(TestResourceWithClassConstraint.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abc/xyz""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/a/b""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 1, 0, 0);
+      String cv = e.getClassViolations().iterator().next();
+      Assert.assertEquals(""Concatenation of s and t must have length > 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""TestResourceWithClassConstraint(\""a\"", \""b\"")"", ViolationUtils.getInvalidObject(cv));
+      System.out.println(ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testGraph() throws Exception
+   {
+      before(TestResourceWithGraph.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abcd/vwxyz""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/abc/xyz""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 2, 1, 1, 0, 0, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 4 and""));
+      Assert.assertEquals(""abc"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 5 and""));
+      Assert.assertEquals(""xyz"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testArray() throws Exception
+   {
+      before(TestResourceWithArray.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abcde""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/abc""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      String cv = e.getPropertyViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 5 and""));
+      Assert.assertEquals(""abc"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testList() throws Exception
+   {
+      before(TestResourceWithList.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abcde""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/abc""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      String cv = e.getPropertyViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 5 and""));
+      Assert.assertEquals(""abc"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testMap() throws Exception
+   {
+      before(TestResourceWithMap.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abcde""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/abc""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      String cv = e.getPropertyViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 5 and""));
+      Assert.assertEquals(""abc"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testMapOfListOfArrayOfStrings() throws Exception
+   {
+      before(TestResourceWithMapOfListOfArrayOfStrings.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abcde""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid
+      request = new ClientRequest(generateURL(""/abc""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      String cv = e.getPropertyViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).startsWith(""size must be between 5 and""));
+      Assert.assertEquals(""abc"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testParameters() throws Exception
+   {
+      beforeFoo(TestResourceWithParameters.class);
+
+      // Valid native constraint
+      ClientRequest request = new ClientRequest(generateURL(""/native""));
+      request.body(""application/foo"", new Foo(""a""));
+      ClientResponse<?> response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Valid imposed constraint
+      request = new ClientRequest(generateURL(""/imposed""));
+      request.body(""application/foo"", new Foo(""abcde""));
+      response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Valid native and imposed constraints.
+      request = new ClientRequest(generateURL(""/nativeAndImposed""));
+      request.body(""application/foo"", new Foo(""abc""));
+      response = request.post(Serializable.class);      
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Invalid native constraint
+      request = new ClientRequest(generateURL(""/native""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 0, 1, 0);
+      String cv = e.getParameterViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).equals(""s must have length: 1 <= length <= 3""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Invalid imposed constraint
+      request = new ClientRequest(generateURL(""/imposed""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 0, 1, 0);
+      cv = e.getParameterViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).equals(""s must have length: 3 <= length <= 5""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Invalid native and imposed constraints
+      request = new ClientRequest(generateURL(""/nativeAndImposed""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 2, 0, 0, 0, 2, 0);
+      Iterator<String> it = e.getParameterViolations().iterator(); 
+      String cv1 = it.next();
+      String cv2 = it.next();
+      if (cv1.indexOf('1') < 0)
+      {
+         String temp = cv1;
+         cv1 = cv2;
+         cv2 = temp;
+      }
+      Assert.assertTrue(ViolationUtils.getMessage(cv1).equals(""s must have length: 1 <= length <= 3""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv1));
+      Assert.assertTrue(ViolationUtils.getMessage(cv2).equals(""s must have length: 3 <= length <= 5""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv2));
+      Assert.assertNull(getViolationsContainer(e));
+      
+      // Valid other parameters
+      String url = generateURL(""/other/ppp""); // path param
+      url += "";m=mmm"";                        // matrix param
+      url += ""?q=qqq"";                        // query param
+      request = new ClientRequest(url);
+      request.formParameter(""f"", ""fff"");      // form param
+      request.header(""h"", ""hhh"");             // header param
+      request.cookie(new Cookie(""c"", ""ccc"")); // cookie param
+      response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+      
+      // Invalid other parameters
+      url = generateURL(""/other/pppp"");        // path param
+      url += "";m=mmmm"";                        // matrix param
+      url += ""?q=qqqq"";                        // query param
+      request = new ClientRequest(url);
+      request.formParameter(""f"", ""ffff"");      // form param
+      request.header(""h"", ""hhhh"");             // header param
+      request.cookie(new Cookie(""c"", ""cccc"")); // cookie param
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 6, 0, 0, 0, 6, 0);
+      Set<String> set = new HashSet<String>(e.getExceptions());
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; pppp""));
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; mmmm""));
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; qqqq""));
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; ffff""));
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; hhhh""));
+      Assert.assertTrue(set.contains(""size must be between 2 and 3; cccc""));
+      after();
+   }
+
+   @Test
+   public void testReturnValues() throws Exception
+   {
+      beforeFoo(TestResourceWithReturnValues.class);
+
+      // Valid native constraint
+      ClientRequest request = new ClientRequest(generateURL(""/native""));
+      Foo foo = new Foo(""a"");
+      request.body(""application/foo"", foo);
+      ClientResponse<?> response = request.post(Foo.class);     
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(foo, response.getEntity());
+      
+      // Valid imposed constraint
+      request = new ClientRequest(generateURL(""/imposed""));
+      foo = new Foo(""abcde"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);      
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(foo, response.getEntity());
+
+      // Valid native and imposed constraints.
+      request = new ClientRequest(generateURL(""/nativeAndImposed""));
+      foo = new Foo(""abc"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);      
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(foo, response.getEntity());
+
+      // Invalid native constraint
+      request = new ClientRequest(generateURL(""/native""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Foo.class);
+      Assert.assertEquals(500, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 0, 0, 1);
+      String cv = e.getReturnValueViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).equals(""s must have length: 1 <= length <= 3""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv));
+
+      // Invalid imposed constraint
+      request = new ClientRequest(generateURL(""/imposed""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Foo.class);
+      Assert.assertEquals(500, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 0, 0, 1);
+      cv = e.getReturnValueViolations().iterator().next();
+      Assert.assertTrue(ViolationUtils.getMessage(cv).equals(""s must have length: 3 <= length <= 5""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Invalid native and imposed constraints
+      request = new ClientRequest(generateURL(""/nativeAndImposed""));
+      request.body(""application/foo"", new Foo(""abcdef""));
+      response = request.post(Foo.class); 
+      Assert.assertEquals(500, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 2, 0, 0, 0, 0, 2);
+      Iterator<String> it = e.getReturnValueViolations().iterator(); 
+      String cv1 = it.next();
+      String cv2 = it.next();
+      if (cv1.indexOf('1') < 0)
+      {
+         String temp = cv1;
+         cv1 = cv2;
+         cv2 = temp;
+      }
+      Assert.assertTrue(ViolationUtils.getMessage(cv1).equals(""s must have length: 1 <= length <= 3""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv1));
+      Assert.assertTrue(ViolationUtils.getMessage(cv2).equals(""s must have length: 3 <= length <= 5""));
+      Assert.assertEquals(""Foo[abcdef]"", ViolationUtils.getInvalidObject(cv2));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+
+   @Test
+   public void testViolationsBeforeReturnValue() throws Exception
+   {
+      beforeFoo(TestResourceWithAllFivePotentialViolations.class);
+
+      // Valid
+      ClientRequest request = new ClientRequest(generateURL(""/abc/wxyz""));
+      Foo foo = new Foo(""pqrs"");
+      request.body(""application/foo"", foo);
+      ClientResponse<?> response = request.post(Foo.class);     
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(foo, response.getEntity());
+
+      // Invalid: Should have 1 each of field, property, class, and parameter violations,
+      //          and no return value violations.
+      request = new ClientRequest(generateURL(""/a/z""));
+      foo = new Foo(""p"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 4, 1, 1, 1, 1, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""a"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 3 and 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""z"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getClassViolations().iterator().next();
+      Assert.assertEquals(""Concatenation of s and t must have length > 5"", ViolationUtils.getMessage(cv));
+      Assert.assertTrue(ViolationUtils.getInvalidObject(cv).startsWith(""org.jboss.resteasy.test.validation.TestValidation$TestResourceWithAllFivePotentialViolations@""));
+      cv = e.getParameterViolations().iterator().next();
+      Assert.assertEquals(""s must have length: 3 <= length <= 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""Foo[p]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      after();
+   }
+   
+   //@Test
+   // Commenting out until inheritance issues are worked out in JAX-RS spec.
+   public void testInheritence() throws Exception
+   {
+      beforeFoo(InterfaceTestSub.class);
+
+      // Valid - inherited annotations
+      ClientRequest request = new ClientRequest(generateURL(""/inherit""));
+      request.body(MediaType.TEXT_PLAIN_TYPE, ""abc"");
+      ClientResponse<?> response = request.post(String.class);     
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(""abc"", response.getEntity());
+      
+      // Valid - overridden annotations
+      request = new ClientRequest(generateURL(""/override""));
+      request.body(MediaType.TEXT_PLAIN_TYPE, ""abcde"");
+      response = request.post(String.class);     
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(""abcde"", response.getEntity());
+   }
+   
+   @Test
+   public void testLocators() throws Exception
+   {
+      beforeFoo(TestResourceWithSubLocators.class);
+      
+//      ClientRequest request = null;
+//      ClientResponse<?> response = null;
+//      Object entity = null;
+//      ResteasyViolationException e = null;
+//      String cv = null;
+      
+      // Sub-resource locator returns resource with valid field.
+      ClientRequest request = new ClientRequest(generateURL(""/validField""));
+      ClientResponse<?> response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Sub-resource locator returns resource with invalid field.
+      request = new ClientRequest(generateURL(""/invalidField""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 1, 0, 0, 0, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""abcde"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Sub-resource locator returns resource with valid property.
+      // Note: The resource TestResourceWithProperty has a @PathParam annotation used by a setter,
+      //       but it is not used when TestResourceWithProperty is used a sub-resource.  Hence ""unused"".
+      request = new ClientRequest(generateURL(""/property/abc/unused""));
+      response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+      
+      // Sub-resource locator returns resource with invalid property.
+      request = new ClientRequest(generateURL(""/property/abcdef/unused""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 1, 0, 0, 0);
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""abcdef"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Valid
+      request = new ClientRequest(generateURL(""/everything/abc/wxyz/unused/unused""));
+      Foo foo = new Foo(""pqrs"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);     
+      Assert.assertEquals(200, response.getStatus());
+      Assert.assertEquals(foo, response.getEntity());
+
+      // Invalid: Should have 1 each of field, property, class, and parameter violations,and no return value violations.
+      // Note: expect warning because TestResourceWithAllFivePotentialViolations is being used a sub-resource and it has an injectible field:
+      //       WARN org.jboss.resteasy.core.ResourceLocator - Field s of subresource org.jboss.resteasy.test.validation.TestValidation$TestResourceWithAllFivePotentialViolations will not be injected according to spec
+      request = new ClientRequest(generateURL(""/everything/a/z/unused/unused""));
+      foo = new Foo(""p"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 4, 1, 1, 1, 1, 0);
+      cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""a"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 3 and 5"", ViolationUtils.getMessage(cv));
+      cv = e.getClassViolations().iterator().next();
+      Assert.assertEquals(""Concatenation of s and t must have length > 5"", ViolationUtils.getMessage(cv));
+      Assert.assertTrue(ViolationUtils.getInvalidObject(cv).startsWith(""org.jboss.resteasy.test.validation.TestValidation$TestResourceWithAllFivePotentialViolations@""));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Sub-sub-resource locator returns resource with valid property.
+      request = new ClientRequest(generateURL(""/sub/sub/abc""));
+      response = request.post();
+      Assert.assertEquals(204, response.getStatus());
+      response.releaseConnection();
+
+      // Sub-resource locator returns resource with invalid property.
+      request = new ClientRequest(generateURL(""/sub/sub/abcdef""));
+      response = request.post(Serializable.class);
+      Assert.assertEquals(400, response.getStatus());
+      entity = response.getEntity();
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 1, 0, 0, 0, 0);
+      cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 3"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""abcdef"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      
+      after();
+   }
+
+   @Test
+   public void testAsynch() throws Exception
+   {
+      beforeFooAsynch(TestResourceWithAllFivePotentialViolations.class);
+      
+      // Submit asynchronous job with violations prior to execution of resource method.
+      ClientRequest request = new ClientRequest(generateURL(""/a/z?asynch=true""));
+      Foo foo = new Foo(""p"");
+      request.body(""application/foo"", foo);
+      ClientResponse<?> response = request.post(Foo.class);
+      Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());
+      String jobUrl = response.getResponseHeaders().getFirst(HttpHeaders.LOCATION);
+      System.out.println(""JOB: "" + jobUrl);
+      response.releaseConnection();
+      
+      // Get result: Should have 1 each of field, property, class, and parameter violations,
+      //             and no return value violations.
+      request = new ClientRequest(jobUrl);
+      response = request.get();
+      while (HttpServletResponse.SC_ACCEPTED == response.getStatus())
+      {
+         Thread.sleep(1000);
+         response.releaseConnection();
+         response = request.get();
+      }
+      Assert.assertEquals(400, response.getStatus());
+      Object entity = response.getEntity(Exception.class);
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      ResteasyViolationException e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 4, 1, 1, 1, 1, 0);
+      String cv = e.getFieldViolations().iterator().next();
+      Assert.assertEquals(""size must be between 2 and 4"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""a"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getPropertyViolations().iterator().next();
+      Assert.assertEquals(""size must be between 3 and 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""z"", ViolationUtils.getInvalidObject(cv));
+      cv = e.getClassViolations().iterator().next();
+      Assert.assertEquals(""Concatenation of s and t must have length > 5"", ViolationUtils.getMessage(cv));
+      Assert.assertTrue(ViolationUtils.getInvalidObject(cv).startsWith(""org.jboss.resteasy.test.validation.TestValidation$TestResourceWithAllFivePotentialViolations@""));
+      cv = e.getParameterViolations().iterator().next();
+      Assert.assertEquals(""s must have length: 3 <= length <= 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""Foo[p]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+
+      // Delete job.
+      request = new ClientRequest(jobUrl);
+      response = request.delete();
+      Assert.assertEquals(HttpServletResponse.SC_NO_CONTENT, response.getStatus());
+      response.releaseConnection();
+      
+      // Submit asynchronous job with violations in result of resource method.
+      request = new ClientRequest(generateURL(""/abc/xyz?asynch=true""));
+      foo = new Foo(""pqr"");
+      request.body(""application/foo"", foo);
+      response = request.post(Foo.class);
+      Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());
+      jobUrl = response.getResponseHeaders().getFirst(HttpHeaders.LOCATION);
+      System.out.println(""JOB: "" + jobUrl);
+      response.releaseConnection();
+
+      // Get result: Should have no field, property, class, or parameter violations,
+      //             and one return value violation.
+      request = new ClientRequest(jobUrl);
+      response = request.get();
+      while (HttpServletResponse.SC_ACCEPTED == response.getStatus())
+      {
+         Thread.sleep(1000);
+         response.releaseConnection();
+         response = request.get();
+      }
+      Assert.assertEquals(500, response.getStatus());
+      entity = response.getEntity(Exception.class);
+      Assert.assertTrue(entity instanceof ResteasyViolationException);
+      e = ResteasyViolationException.class.cast(entity);
+      countViolations(e, 1, 0, 0, 0, 0, 1);
+      cv = e.getReturnValueViolations().iterator().next();
+      Assert.assertEquals(""s must have length: 4 <= length <= 5"", ViolationUtils.getMessage(cv));
+      Assert.assertEquals(""Foo[pqr]"", ViolationUtils.getInvalidObject(cv));
+      Assert.assertNull(getViolationsContainer(e));
+      
+      // Delete job.
+      request = new ClientRequest(jobUrl);
+      response = request.delete();
+      Assert.assertEquals(HttpServletResponse.SC_NO_CONTENT, response.getStatus());
+      response.releaseConnection();
+
+      after();
+   }
+   
+   private void countViolations(ResteasyViolationException e, int totalCount, int fieldCount, int propertyCount, int classCount, int parameterCount, int returnValueCount)
+   {
+      Assert.assertEquals(totalCount,       e.getExceptions().size());
+      Assert.assertEquals(fieldCount,       e.getFieldViolations().size());
+      Assert.assertEquals(propertyCount,    e.getPropertyViolations().size());
+      Assert.assertEquals(classCount,       e.getClassViolations().size());
+      Assert.assertEquals(parameterCount,   e.getParameterViolations().size());
+      Assert.assertEquals(returnValueCount, e.getReturnValueViolations().size());
+   }
+   
+   private ViolationsContainer<?> getViolationsContainer(ResteasyViolationException e) throws NoSuchFieldException, IllegalAccessException
+   {
+	   Field container = ResteasyViolationException.class.getDeclaredField(""container"");
+	   container.setAccessible(true);
+	   return ViolationsContainer.class.cast(container.get(e));
+   }
+}",2012-04-15T01:34:17Z,62
"@@ -0,0 +1,187 @@
+package org.jboss.resteasy.test.providers.jackson2;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.logging.Logger;
+import org.jboss.resteasy.category.ExpectedFailing;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.test.core.basic.resource.ApplicationTestScannedApplication;
+import org.jboss.resteasy.test.providers.jackson2.resource.JacksonDatatypeEndPoint;
+import org.jboss.resteasy.test.providers.jackson2.resource.JacksonDatatypeJacksonProducer;
+import org.jboss.resteasy.util.HttpResponseCodes;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.runner.RunWith;
+
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsNot.not;
+import static org.hamcrest.core.StringContains.containsString;
+
+/**
+ * @tpSubChapter Jackson2 provider
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Test for WFLY-5916. Integration tests for jackson-datatype-jsr310 and jackson-datatype-jdk8 modules
+ * @tpSince RESTEasy 3.1.0.CR3
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+// This test passes with WildFly master branch, but don't pass with WildFly 10.1
+// Next annotation needs to be removed after new version of WildFly would be used - FIXME
+@Category({ExpectedFailing.class})
+public class JacksonDatatypeTest {
+    private static final String DEFAULT_DEPLOYMENT = String.format(""%sDefault"",
+            JacksonDatatypeTest.class.getSimpleName());
+    private static final String DEPLOYMENT_WITH_DATATYPE = String.format(""%sWithDatatypeSupport"",
+            JacksonDatatypeTest.class.getSimpleName());
+
+    static ResteasyClient client;
+    protected static final Logger logger = Logger.getLogger(JacksonDatatypeTest.class.getName());
+
+    @BeforeClass
+    public static void init() {
+        client = new ResteasyClientBuilder().build();
+    }
+
+    @AfterClass
+    public static void close() {
+        client.close();
+    }
+
+    @Deployment(name = ""default"")
+    public static Archive<?> deploy() {
+        WebArchive war = ShrinkWrap.create(WebArchive.class, DEFAULT_DEPLOYMENT + "".war"");
+        war.addClasses(ApplicationTestScannedApplication.class, JacksonDatatypeEndPoint.class);
+        return war;
+    }
+
+    @Deployment(name = ""withDatatype"")
+    public static Archive<?> deployJettison() {
+        WebArchive war = ShrinkWrap.create(WebArchive.class, DEPLOYMENT_WITH_DATATYPE + "".war"");
+        war.addClasses(JacksonDatatypeEndPoint.class,
+                JacksonDatatypeJacksonProducer.class, ApplicationTestScannedApplication.class);
+        return war;
+    }
+
+    private String requestHelper(String endPath, String deployment) {
+        String url = PortProviderUtil.generateURL(String.format(""/scanned/%s"", endPath), deployment);
+        WebTarget base = client.target(url);
+        Response response = base.request().get();
+        Assert.assertEquals(HttpResponseCodes.SC_OK, response.getStatus());
+        String strResponse = response.readEntity(String.class);
+        logger.info(String.format(""Url: %s"", url));
+        logger.info(String.format(""Response: %s"", strResponse));
+        return strResponse;
+    }
+
+    /**
+     * @tpTestDetails Check string type without datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeNotSupportedString() throws Exception {
+        String strResponse = requestHelper(""string"", DEFAULT_DEPLOYMENT);
+        Assert.assertThat(""Wrong conversion of String"", strResponse, containsString(""someString""));
+    }
+
+    /**
+     * @tpTestDetails Check date type without datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeNotSupportedDate() throws Exception {
+        String strResponse = requestHelper(""date"", DEFAULT_DEPLOYMENT);
+        Assert.assertThat(""Wrong conversion of Date"", strResponse.matches(""^[0-9]*$""), is(true));
+    }
+
+    /**
+     * @tpTestDetails Check duration type without datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeNotSupportedDuration() throws Exception {
+        String strResponse = requestHelper(""duration"", DEFAULT_DEPLOYMENT);
+        Assert.assertThat(""Wrong conversion of Duration"", strResponse, not(containsString(""PT5.000000006S"")));
+    }
+
+    /**
+     * @tpTestDetails Check null optional type without datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeNotSupportedOptionalNull() throws Exception {
+        String strResponse = requestHelper(""optional/true"", DEFAULT_DEPLOYMENT);
+        Assert.assertThat(""Wrong conversion of Optional (null)"", strResponse, not(containsString(""null"")));
+    }
+
+    /**
+     * @tpTestDetails Check not null optional type without datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeNotSupportedOptionalNotNull() throws Exception {
+        String strResponse = requestHelper(""optional/false"", DEFAULT_DEPLOYMENT);
+        Assert.assertThat(""Wrong conversion of Optional (not null)"", strResponse, not(containsString(""info@example.com"")));
+    }
+
+    /**
+     * @tpTestDetails Check string type with datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeSupportedString() throws Exception {
+        String strResponse = requestHelper(""string"", DEPLOYMENT_WITH_DATATYPE);
+        Assert.assertThat(""Wrong conversion of String"", strResponse, containsString(""someString""));
+    }
+
+    /**
+     * @tpTestDetails Check date type with datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeSupportedDate() throws Exception {
+        String strResponse = requestHelper(""date"", DEPLOYMENT_WITH_DATATYPE);
+        Assert.assertThat(""Wrong conversion of Date"", strResponse.matches(""^[0-9]*$""), is(false));
+    }
+
+    /**
+     * @tpTestDetails Check duration type with datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeSupportedDuration() throws Exception {
+        String strResponse = requestHelper(""duration"", DEPLOYMENT_WITH_DATATYPE);
+        Assert.assertThat(""Wrong conversion of Duration"", strResponse, containsString(""PT5.000000006S""));
+    }
+
+    /**
+     * @tpTestDetails Check null optional type with datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeSupportedOptionalNull() throws Exception {
+        String strResponse = requestHelper(""optional/true"", DEPLOYMENT_WITH_DATATYPE);
+        Assert.assertThat(""Wrong conversion of Optional (null)"", strResponse, containsString(""null""));
+    }
+
+    /**
+     * @tpTestDetails Check not null optional type with datatype supported
+     * @tpSince RESTEasy 3.1.0.CR3
+     */
+    @Test
+    public void testDatatypeSupportedOptionalNotNull() throws Exception {
+        String strResponse = requestHelper(""optional/false"", DEPLOYMENT_WITH_DATATYPE);
+        Assert.assertThat(""Wrong conversion of Optional (not null)"", strResponse, containsString(""info@example.com""));
+    }
+}",2016-11-22T11:39:09Z,487
"@@ -0,0 +1,42 @@
+package org.jboss.resteasy.test.providers.jackson2.resource;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import java.time.Duration;
+import java.util.Date;
+import java.util.Optional;
+
+@Path(""/"")
+public class JacksonDatatypeEndPoint {
+
+    @GET
+    @Path(""/string"")
+    @Produces(MediaType.APPLICATION_JSON)
+    public String getString() {
+        return ""someString"";
+    }
+
+    @GET
+    @Path(""/date"")
+    @Produces(MediaType.APPLICATION_JSON)
+    public Date getDate() {
+        return new Date();
+    }
+
+    @GET
+    @Path(""/duration"")
+    @Produces(MediaType.APPLICATION_JSON)
+    public Duration getDuration() {
+        return Duration.ofSeconds(5, 6);
+    }
+
+    @GET
+    @Path(""/optional/{nullParam}"")
+    @Produces(MediaType.APPLICATION_JSON)
+    public Optional<String> getOptional(@PathParam(""nullParam"") boolean nullParameter) {
+        return nullParameter ? Optional.<String>empty() : Optional.of(""info@example.com"");
+    }
+}
\ No newline at end of file",2016-11-22T11:39:09Z,488
"@@ -0,0 +1,30 @@
+package org.jboss.resteasy.test.providers.jackson2.resource;
+
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.SerializationFeature;
+
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.ext.ContextResolver;
+import javax.ws.rs.ext.Provider;
+
+@Provider
+@Produces(MediaType.APPLICATION_JSON)
+public class JacksonDatatypeJacksonProducer implements ContextResolver<ObjectMapper> {
+
+    private final ObjectMapper json;
+
+    public JacksonDatatypeJacksonProducer() throws Exception {
+        this.json = new ObjectMapper()
+                .findAndRegisterModules()
+                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
+                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+    }
+
+    @Override
+    public ObjectMapper getContext(Class<?> objectType) {
+        return json;
+    }
+
+}
\ No newline at end of file",2016-11-22T11:39:09Z,489
"@@ -89,6 +89,7 @@
         <version.microprofile.restclient>2.0-RC2</version.microprofile.restclient>
 
         <!-- todo rls move this property when updating all versions for MP-rest-client 2.0
+        and return version to ${version.microprofile.restclient}
         -->
         <version.microprofile.restclient.tck>1.4.0</version.microprofile.restclient.tck>
 
@@ -641,12 +642,6 @@
                 <scope>test</scope>
             </dependency>
 
-            <dependency>
-                <groupId>org.eclipse.microprofile.rest.client</groupId>
-                <artifactId>microprofile-rest-client-tck</artifactId>
-                <version>${version.microprofile.restclient}</version>
-                <scope>test</scope>
-            </dependency>
             <dependency>
                 <groupId>io.smallrye.config</groupId>
                 <artifactId>smallrye-config</artifactId>",2020-10-27T13:18:32Z,247
"@@ -0,0 +1,61 @@
+package org.jboss.resteasy.test.microprofile.restclient;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.logging.Logger;
+import org.jboss.resteasy.microprofile.client.RestClientBuilderImpl;
+import org.jboss.resteasy.test.microprofile.restclient.resource.JsonBindingMPService;
+import org.jboss.resteasy.test.microprofile.restclient.resource.JsonBindingMPServiceIntf;
+import org.jboss.resteasy.test.providers.jsonb.basic.resource.Dog;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.URI;
+
+/**
+ * @tpSubChapter MicroProfile rest client
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Show JSON-Binding is supported.
+ * @tpSince RESTEasy 4.6.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class JsonBindingMPTest {
+    protected static final Logger LOG = Logger.getLogger(JsonBindingMPTest.class.getName());
+    private static final String WAR_SERVICE = ""jsonBinding_service"";
+
+    @Deployment(name=WAR_SERVICE)
+    public static Archive<?> serviceDeploy() {
+        WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);
+        war.addClasses(JsonBindingMPService.class,
+                Dog.class);
+       return TestUtil.finishContainerPrepare(war, null, null);
+    }
+
+    private static String generateURL(String path, String deployName) {
+        return PortProviderUtil.generateURL(path, deployName);
+    }
+
+    @Test
+    public void testDog() {
+        RestClientBuilderImpl builder = new RestClientBuilderImpl();
+        JsonBindingMPServiceIntf jsonBindingMPServiceIntf = builder
+                .baseUri(URI.create(generateURL("""", WAR_SERVICE)))
+                .build(JsonBindingMPServiceIntf.class);
+
+        try {
+            Dog dog = new Dog(""Rex"", ""german shepherd"");
+            Dog response = jsonBindingMPServiceIntf.getDog(dog);
+            Assert.assertTrue(response.getName().equals(""Jethro""));
+            Assert.assertTrue(response.getSort().equals(""stafford""));
+        } catch (Exception e) {
+           Assert.fail(""Exception thrown: "" + e);
+        }
+    }
+}",2020-10-27T13:18:32Z,490
"@@ -0,0 +1,128 @@
+package org.jboss.resteasy.test.microprofile.restclient;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.logging.Logger;
+import org.jboss.resteasy.microprofile.client.RestClientBuilderImpl;
+import org.jboss.resteasy.test.microprofile.restclient.resource.JsonpMPService;
+import org.jboss.resteasy.test.microprofile.restclient.resource.JsonpMPServiceIntf;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.json.Json;
+import javax.json.JsonArray;
+import javax.json.JsonNumber;
+import javax.json.JsonObject;
+import javax.json.JsonString;
+import javax.json.JsonStructure;
+import java.net.URI;
+
+/**
+ * @tpSubChapter MicroProfile rest client
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Show JSON-P is supported.
+ * @tpSince RESTEasy 4.6.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class JsonpMPtest {
+    protected static final Logger LOG = Logger.getLogger(JsonpMPtest.class.getName());
+    private static final String WAR_SERVICE = ""jsonP_service"";
+
+    @Deployment(name=WAR_SERVICE)
+    public static Archive<?> serviceDeploy() {
+        WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);
+        war.addClasses(JsonpMPService.class);
+      return TestUtil.finishContainerPrepare(war, null, null);
+    }
+
+    static JsonpMPServiceIntf jsonpMPServiceIntf;
+    @Before
+    public void before() throws Exception {
+        RestClientBuilderImpl builder = new RestClientBuilderImpl();
+        jsonpMPServiceIntf = builder
+                .baseUri(URI.create(generateURL("""", WAR_SERVICE)))
+                .build(JsonpMPServiceIntf.class);
+    }
+
+    private static String generateURL(String path, String deployName) {
+        return PortProviderUtil.generateURL(path, deployName);
+    }
+
+    @Test
+    public void testObject() {
+
+        JsonObject obj = Json.createObjectBuilder()
+                .add(""name"", ""Bill"")
+                .add(""id"", 10001)
+                .build();
+
+        JsonObject response = jsonpMPServiceIntf.object(obj);
+        Assert.assertTrue(""JsonObject from the response doesn't contain field 'name'"",
+                response.containsKey(""name""));
+        Assert.assertEquals(""JsonObject from the response doesn't contain correct value for the field 'name'"",
+                response.getJsonString(""name"").getString(), ""Bill"");
+        Assert.assertTrue(""JsonObject from the response doesn't contain field 'id'"",
+                response.containsKey(""id""));
+        Assert.assertEquals(""JsonObject from the response doesn't contain correct value for the field 'id'"",
+                response.getJsonNumber(""id"").longValue(), 10001);
+    }
+
+    @Test
+    public void testStructure() {
+        JsonStructure structure = (JsonStructure) Json.createObjectBuilder().add(""name"", ""Bill"").build();
+        JsonStructure response = jsonpMPServiceIntf.object(structure);
+        JsonObject obj = (JsonObject) response;
+        Assert.assertTrue(""JsonObject from the response doesn't contain field 'name'"",
+                obj.containsKey(""name""));
+        Assert.assertEquals(""JsonObject from the response doesn't contain correct value for the field 'name'"",
+                obj.getJsonString(""name"").getString(), ""Bill"");
+    }
+
+    @Test
+    public void testJsonNumber() {
+        JsonNumber jsonNumber = Json.createValue(100);
+        JsonNumber response = jsonpMPServiceIntf.testNumber(jsonNumber);
+        Assert.assertTrue(""JsonNumber object with 200 value is expected"",
+                response.intValue() == 200);
+    }
+
+    @Test
+    public void testArray() {
+        JsonArray array = Json.createArrayBuilder()
+                .add(Json.createObjectBuilder().add(""name"", ""Bill"").build())
+                .add(Json.createObjectBuilder().add(""name"", ""Monica"").build())
+                .build();
+
+        JsonArray response = jsonpMPServiceIntf.array(array);
+        Assert.assertEquals(""JsonArray from the response doesn't contain two elements as it should"",
+                2, response.size());
+        JsonObject obj = response.getJsonObject(0);
+        Assert.assertTrue(""JsonObject[0] from the response doesn't contain field 'name'"",
+                obj.containsKey(""name""));
+        Assert.assertEquals(""JsonObject[0] from the response doesn't contain correct value for the field 'name'"",
+                obj.getJsonString(""name"").getString(), ""Bill"");
+        obj = response.getJsonObject(1);
+        Assert.assertTrue(""JsonObject[1] from the response doesn't contain field 'name'"",
+                obj.containsKey(""name""));
+        Assert.assertEquals(""JsonObject[1] from the response doesn't contain correct value for the field 'name'"",
+                obj.getJsonString(""name"").getString(), ""Monica"");
+    }
+
+    @Test
+    public void testJsonString() throws Exception {
+
+        JsonString jsonString = Json.createValue(""Resteasy"");
+        JsonString  response = jsonpMPServiceIntf.testString(jsonString);
+
+        Assert.assertTrue(""JsonString object with Hello Resteasy value is expected"",
+                response.getString().equals(""Hello Resteasy""));
+    }
+}",2020-10-27T13:18:32Z,63
"@@ -0,0 +1,21 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import org.jboss.resteasy.test.providers.jsonb.basic.resource.Dog;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+
+@Path(""/jsonBindingService"")
+public class JsonBindingMPService {
+
+    @Path(""/dog"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    public Dog getDog(Dog dog) throws Exception {
+        dog.setNameAndSort(""Jethro"", ""stafford"");
+        return dog;
+    }
+}",2020-10-27T13:18:32Z,491
"@@ -0,0 +1,22 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
+import org.jboss.resteasy.test.providers.jsonb.basic.resource.Dog;
+
+import javax.inject.Singleton;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+
+@RegisterRestClient(baseUri =""http://localhost:8080/jsonBinding_service"")
+@Path(""/jsonBindingService"")
+@Singleton
+public interface JsonBindingMPServiceIntf {
+
+    @Path(""/dog"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    Dog getDog(Dog dog) throws Exception;
+}",2020-10-27T13:18:32Z,492
"@@ -0,0 +1,82 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import org.junit.Assert;
+
+import javax.json.Json;
+import javax.json.JsonArray;
+import javax.json.JsonNumber;
+import javax.json.JsonObject;
+import javax.json.JsonString;
+import javax.json.JsonStructure;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+
+@Path(""/jsonpService"")
+public class JsonpMPService {
+    @Path(""array"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    public JsonArray array(JsonArray array) {
+        Assert.assertEquals(""The request didn't contain 2 json elements"", 2, array.size());
+        JsonObject obj = array.getJsonObject(0);
+        Assert.assertTrue(""The field 'name' didn't propagated correctly from the request for object[0]"",
+                obj.containsKey(""name""));
+        Assert.assertEquals(""The value of field 'name' didn't propagated correctly from the request for object[0]"",
+                obj.getJsonString(""name"").getString(), ""Bill"");
+        obj = array.getJsonObject(1);
+        Assert.assertTrue(""The field 'name' didn't propagated correctly from the request for object[1]"",
+                obj.containsKey(""name""));
+        Assert.assertEquals(""The value of field 'name' didn't propagated correctly from the request for object[1]"",
+                obj.getJsonString(""name"").getString(), ""Monica"");
+        return array;
+    }
+
+    @Path(""object"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    public JsonObject object(JsonObject obj) {
+        Assert.assertTrue(""The field 'name' didn't propagated correctly from the request"", obj.containsKey(""name""));
+        Assert.assertEquals(""The value of field 'name' didn't propagated correctly from the request""
+                , obj.getJsonString(""name"").getString(), ""Bill"");
+        if (obj.containsKey(""id"")) {
+            Assert.assertEquals(""The value of field 'id' didn't propagated correctly from the request""
+                    , obj.getJsonNumber(""id"").longValue(), 10001);
+        }
+        return obj;
+    }
+
+    @Path(""structure"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    public JsonStructure object(JsonStructure struct) {
+        JsonObject obj = (JsonObject) struct;
+        Assert.assertTrue(""The field 'name' didn't propagated correctly from the request"", obj.containsKey(""name""));
+        Assert.assertEquals(""The value of field 'name' didn't propagated correctly from the request"",
+                obj.getJsonString(""name"").getString(), ""Bill"");
+        return obj;
+    }
+
+
+    @Path(""number"")
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    public JsonNumber testNumber(JsonNumber number) {
+        return Json.createValue(number.intValue() + 100);
+    }
+
+    @Path(""string"")
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    public JsonString testString(JsonString string) {
+        return Json.createValue(""Hello "" + string.getString());
+    }
+
+}",2020-10-27T13:18:32Z,493
"@@ -0,0 +1,50 @@
+package org.jboss.resteasy.test.microprofile.restclient.resource;
+
+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
+
+import javax.inject.Singleton;
+import javax.json.JsonArray;
+import javax.json.JsonNumber;
+import javax.json.JsonObject;
+import javax.json.JsonString;
+import javax.json.JsonStructure;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+
+@RegisterRestClient(baseUri =""http://localhost:8080/jsonP_service"")
+@Path(""/jsonpService"")
+@Singleton
+public interface JsonpMPServiceIntf {
+    @Path(""array"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    JsonArray array(JsonArray array);
+
+    @Path(""object"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    JsonObject object(JsonObject obj);
+
+    @Path(""structure"")
+    @POST
+    @Produces(""application/json"")
+    @Consumes(""application/json"")
+    JsonStructure object(JsonStructure struct);
+
+    @Path(""number"")
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    JsonNumber testNumber(JsonNumber number);
+
+    @Path(""string"")
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    JsonString testString(JsonString string);
+}",2020-10-27T13:18:32Z,494
"@@ -147,6 +147,7 @@
                 </plugins>
             </build>
         </profile>
+
     </profiles>
 
     <build>",2020-12-03T13:42:00Z,396
"@@ -185,6 +185,7 @@
                 </plugins>
             </build>
         </profile>
+
     </profiles>
 
     <dependencies>",2020-12-03T13:42:00Z,399
"@@ -57,7 +57,7 @@
                         <jboss.server.config.file.name>${jboss.server.config.file.name}</jboss.server.config.file.name>
                         <security.provider>${security.provider}</security.provider>
                     </systemPropertyVariables>
-                    <excludedGroups>org.jboss.resteasy.category.ExpectedFailing,${additional.surefire.excluded.groups}</excludedGroups>
+                    <excludedGroups>org.jboss.resteasy.category.ExpectedFailing${additional.surefire.excluded.groups}</excludedGroups>
                 </configuration>
             </plugin>
             <plugin>
@@ -159,7 +159,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly20</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly20</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <profile>
@@ -171,7 +171,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly19</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly19</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <profile>
@@ -183,7 +183,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly18</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly18</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <!-- If resteasy.version is specified, it will be used for tests instead of the project.version -->",2020-12-03T13:42:00Z,366
"@@ -76,6 +76,13 @@
                     <skip>true</skip>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <skipIfEmpty>true</skipIfEmpty>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2019-03-07T22:11:01Z,495
"@@ -63,6 +63,13 @@
                     <skip>true</skip>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <skipIfEmpty>true</skipIfEmpty>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2019-03-07T22:11:01Z,366
"@@ -36,7 +36,7 @@ jobs:
         with:
           java-version: ${{ matrix.java }}
       - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }}
-        run: mvn clean install -fae '-Dserver.version=${{ matrix.wildfly-version }}'
+        run: mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions'
       - uses: actions/upload-artifact@v2
         if: failure()
         with:
@@ -68,5 +68,5 @@ jobs:
         with:
           java-version: ${{ matrix.java }}
       - name: Build Java Docs with Java ${{ matrix.java }}
-        run: mvn clean install -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
+        run: mvn clean install -U -B -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
 ",2021-05-22T00:44:54Z,496
"@@ -3,7 +3,7 @@
     <parent>
         <groupId>org.jboss</groupId>
         <artifactId>jboss-parent</artifactId>
-        <version>35</version>
+        <version>38</version>
         <relativePath/>
     </parent>
 
@@ -170,6 +170,39 @@
                 </plugins>
             </build>
       </profile>
+      <profile>
+          <id>github-actions</id>
+          <activation>
+              <property>
+                  <name>github.actions</name>
+              </property>
+          </activation>
+
+          <dependencies>
+              <!-- Add explicit dependency to force download of the dependency -->
+              <dependency>
+                  <groupId>org.apache.maven.surefire</groupId>
+                  <artifactId>surefire-junit47</artifactId>
+                  <version>${version.surefire.plugin}</version>
+                  <scope>test</scope>
+              </dependency>
+          </dependencies>
+          <build>
+              <plugins>
+                  <plugin>
+                      <groupId>org.apache.maven.plugins</groupId>
+                      <artifactId>maven-surefire-plugin</artifactId>
+                      <dependencies>
+                          <dependency>
+                              <groupId>org.apache.maven.surefire</groupId>
+                              <artifactId>surefire-junit47</artifactId>
+                              <version>${version.surefire.plugin}</version>
+                          </dependency>
+                      </dependencies>
+                  </plugin>
+              </plugins>
+          </build>
+      </profile>
       <profile>
           <id>jboss-repository</id>
           <repositories>",2021-05-22T00:44:54Z,298
"@@ -4,7 +4,7 @@
     <parent>
         <groupId>org.jboss</groupId>
         <artifactId>jboss-parent</artifactId>
-        <version>35</version>
+        <version>38</version>
         <relativePath/>
     </parent>
     <modelVersion>4.0.0</modelVersion>",2021-05-22T00:44:54Z,247
"@@ -15,13 +15,13 @@ jobs:
   build:
 
     runs-on: ${{ matrix.os }}
-    timeout-minutes: 60
+    timeout-minutes: 90
     strategy:
       fail-fast: false
       matrix:
         os: [ubuntu-latest, windows-latest ]
-        java: ['1.8', '11']
-        wildfly-version: ['22.0.1.Final', '23.0.2.Final']
+        java: ['11', '16']
+        wildfly-version: ['23.0.2.Final']
 
     steps:
       - uses: actions/checkout@v2
@@ -31,12 +31,28 @@ jobs:
           key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
           restore-keys: |
             ${{ runner.os }}-maven-
+      - name: Set up JDK 8
+        uses: actions/setup-java@v2
+        with:
+          java-version: 8
+          distribution: 'adopt'
       - name: Set up JDK ${{ matrix.java }}
-        uses: actions/setup-java@v1
+        uses: actions/setup-java@v2
         with:
           java-version: ${{ matrix.java }}
-      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }}
-        run: mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions'
+          distribution: 'adopt'
+      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }} - Linux
+        if: runner.os == 'Linux'
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae -Dserver.version=${{ matrix.wildfly-version }} -Dgithub.actions -Djava8.home=""$JAVA_HOME_8_X64""
+          echo ""::endgroup::""
+      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }} - Windows
+        if: runner.os == 'Windows'
+        run:  |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions' '""-Djava8.home=%JAVA_HOME_8_X64%""'
+          echo ""::endgroup::""
       - uses: actions/upload-artifact@v2
         if: failure()
         with:
@@ -48,13 +64,65 @@ jobs:
           name: server-logs-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
           path: '**/server.log'
 
-  build-java-docs:
-    runs-on: ubuntu-latest
-    timeout-minutes: 60
+  test-with-java8:
+
+    runs-on: ${{ matrix.os }}
+    timeout-minutes: 90
     strategy:
       fail-fast: false
       matrix:
-        java: ['1.8', '11']
+        os: [ubuntu-latest, windows-latest ]
+        wildfly-version: ['23.0.2.Final']
+
+    steps:
+      - uses: actions/checkout@v2
+      - uses: actions/cache@v1
+        with:
+          path: ~/.m2/repository
+          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+          restore-keys: |
+            ${{ runner.os }}-maven-
+      - name: Set up JDK 8
+        uses: actions/setup-java@v2
+        with:
+          java-version: 8
+          distribution: 'adopt'
+      - name: Set up JDK 11
+        uses: actions/setup-java@v2
+        with:
+          java-version: 11
+          distribution: 'adopt'
+      - name: Build with Java 11
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -DskipTests
+          echo ""::endgroup::""
+      - name: Test with Java 8 on WildFly ${{ matrix.wildfly-version }} - Linux
+        if: runner.os == 'Linux'
+        run:  |
+          echo ""::group::Test Logs""
+          mvn clean install -U -B -fae -rf ':resteasy-testsuite' -Dserver.version=${{ matrix.wildfly-version }} -Dgithub.actions -Dtest.java8.home=""$JAVA_HOME_8_X64""
+          echo ""::endgroup::""
+      - name: Test with Java 8 on WildFly ${{ matrix.wildfly-version }} - Windows
+        if: runner.os == 'Windows'
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae -rf ':resteasy-testsuite' '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions' '""-Dtest.java8.home=%JAVA_HOME_8_X64%""'
+          echo ""::endgroup::""
+      - uses: actions/upload-artifact@v2
+        if: failure()
+        with:
+          name: surefire-reports-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
+          path: '**/surefire-reports/*.txt'
+      - uses: actions/upload-artifact@v2
+        if: failure()
+        with:
+          name: server-logs-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
+          path: '**/server.log'
+
+  build-java-docs:
+    runs-on: ubuntu-latest
+    timeout-minutes: 20
     steps:
       - uses: actions/checkout@v2
       - uses: actions/cache@v1
@@ -63,10 +131,10 @@ jobs:
           key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
           restore-keys: |
             ${{ runner.os }}-maven-javadoc
-      - name: Set up JDK ${{ matrix.java }}
+      - name: Set up JDK 11
         uses: actions/setup-java@v1
         with:
-          java-version: ${{ matrix.java }}
-      - name: Build Java Docs with Java ${{ matrix.java }}
+          java-version: 11
+      - name: Build Java Docs with Java 11
         run: mvn clean install -U -B -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
 ",2021-06-08T16:16:48Z,496
"@@ -27,7 +27,7 @@ Issues are kept in [JIRA](https://issues.redhat.com/projects/RESTEASY/issues).
 
 ## Build
 
-Currently RESTEasy can be built with JDK 1.8 and 11.
+Currently RESTEasy can be built with JDK 11+.
 
 If you want to purely build the project without running the tests, you need to pull down a clone of the RESTEasy repository and run:
 ",2021-06-08T16:16:48Z,497
"@@ -14,8 +14,8 @@
     <container qualifier=""jetty"" default=""true"">
        <configuration>
            <property name=""bindHttpPort"">0</property>
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args}</property>
-           <!--property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=y</property-->
+           <property name=""javaVmArguments"">${additionalJvmArgs}</property>
+           <!--property name=""javaVmArguments"">${additionalJvmArgs} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=y</property-->
        </configuration>
     </container>
 </arquillian>",2021-06-08T16:16:48Z,498
"@@ -14,9 +14,9 @@
     <container qualifier=""jetty"" default=""true"">
        <configuration>
            <property name=""bindHttpPort"">0</property>
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args}</property>
+           <property name=""javaVmArguments"">${additionalJvmArgs}</property>
          <!--
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=n</property>
+           <property name=""javaVmArguments"">${additionalJvmArgs} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=n</property>
          -->
        </configuration>
     </container>",2021-06-08T16:16:48Z,499
"@@ -29,20 +29,21 @@
         <jboss.home/>
         <!-- print logs to file by default -->
         <maven.test.redirectTestOutputToFile>true</maven.test.redirectTestOutputToFile>
-        <!-- Modularized JDK support (various workarounds) - activated via profile -->
-        <modular.jdk.args/>
         <!-- maven-enforcer-plugin -->
         <maven.min.version>3.2.5</maven.min.version>
-        <jdk.min.version>${maven.compiler.source}</jdk.min.version>
+
+        <!-- Require at least Java 11 to compile, but compile down to Java 8 -->
+        <jdk.min.version>11</jdk.min.version>
+        <javadoc.additional.params>--release=8</javadoc.additional.params>
         <!-- maven-surefire-plugin -->
-        <surefire.system.args>-Xms512m -Xmx512m ${modular.jdk.args}</surefire.system.args>
+        <surefire.system.args>-Xms512m -Xmx512m</surefire.system.args>
+        <skip.java8.tests>false</skip.java8.tests>
 
         <maven.test.skip>false</maven.test.skip>
         <skipTests>${maven.test.skip}</skipTests>
 
         <!-- Plugins versions -->
         <version.org.jacoco.plugin>0.7.9</version.org.jacoco.plugin>
-        <version.javadoc.plugin>3.0.1</version.javadoc.plugin>
         <version.compiler.plugin>3.8.0-jboss-2</version.compiler.plugin>
         <version.org.wildfly.plugins.wildfly-maven-plugin>2.1.0.Beta1</version.org.wildfly.plugins.wildfly-maven-plugin>
     </properties>
@@ -146,18 +147,39 @@
             </dependencyManagement>
         </profile>
       <profile>
-          <id>modular.jvm</id>
+          <id>java8.tests</id>
           <activation>
-              <jdk>[9,)</jdk>
+              <property>
+                  <name>java8.home</name>
+              </property>
           </activation>
-          <properties>
-              <modular.jdk.args>
-                  --add-exports=java.base/sun.nio.ch=ALL-UNNAMED
-                  --add-modules=java.se
-                  --add-opens=java.base/java.util=ALL-UNNAMED
-                  --add-opens=java.base/java.security=ALL-UNNAMED
-              </modular.jdk.args>
-          </properties>
+          <build>
+              <plugins>
+                  <plugin>
+                      <groupId>org.apache.maven.plugins</groupId>
+                      <artifactId>maven-surefire-plugin</artifactId>
+                      <executions>
+                          <execution>
+                              <id>java8-test</id>
+                              <phase>test</phase>
+                              <goals>
+                                  <goal>test</goal>
+                              </goals>
+                              <configuration>
+                                  <skip>${skip.java8.tests}</skip>
+                                  <jvm>${java8.home}/bin/java</jvm>
+                                  <additionalClasspathElements>
+                                      <additionalClasspathElement>${java8.home}/lib/tools.jar</additionalClasspathElement>
+                                  </additionalClasspathElements>
+                                  <environmentVariables>
+                                      <JAVA_HOME>${java8.home}</JAVA_HOME>
+                                  </environmentVariables>
+                              </configuration>
+                          </execution>
+                      </executions>
+                  </plugin>
+              </plugins>
+          </build>
       </profile>
       <profile>
           <id>github-actions</id>
@@ -219,6 +241,22 @@
     <build>
         <pluginManagement>
             <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-compiler-plugin</artifactId>
+                    <executions>
+                        <execution>
+                            <id>default-compile</id>
+                            <phase>compile</phase>
+                            <goals>
+                                <goal>compile</goal>
+                            </goals>
+                            <configuration>
+                                <release>8</release>
+                            </configuration>
+                        </execution>
+                    </executions>
+                </plugin>
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-surefire-plugin</artifactId>
@@ -232,9 +270,8 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-javadoc-plugin</artifactId>
-                    <version>${version.javadoc.plugin}</version>
                     <configuration>
-                        <source>8</source>
+                        <doclint>none</doclint>
                         <minmemory>128m</minmemory>
                         <maxmemory>1024m</maxmemory>
                         <quiet>false</quiet>
@@ -367,20 +404,6 @@
                             </rules>
                         </configuration>
                     </execution>
-                    <execution>
-                        <id>use-java-8-for-release</id>
-                        <phase>deploy</phase>
-                        <goals>
-                            <goal>enforce</goal>
-                        </goals>
-                        <configuration>
-                            <rules>
-                                <requireJavaVersion>
-                                    <version>[1.8,9)</version>
-                                </requireJavaVersion>
-                            </rules>
-                        </configuration>
-                    </execution>
                 </executions>
             </plugin>
         </plugins>",2021-06-08T16:16:48Z,298
"@@ -16,13 +16,6 @@
    <artifactId>integration-tests-embedded</artifactId>
    <name>RESTEasy Main testsuite: Embedded Server tests</name>
 
-
-   <properties>
-      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-      <maven.compiler.source>1.8</maven.compiler.source>
-      <maven.compiler.target>1.8</maven.compiler.target>
-   </properties>
-
    <dependencies>
       <dependency>
          <groupId>junit</groupId>
@@ -118,123 +111,70 @@
       </dependency>
    </dependencies>
 
-   <build>
-      <plugins>
-
-         <plugin>
-            <artifactId>maven-surefire-plugin</artifactId>
-            <executions>
-               <execution>
-                  <id>default-test</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>NettyJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
+    <build>
+        <plugins>
+            <plugin>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <includes>
                         <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>SunHttpJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.sun.http.SunHttpJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>VertxJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.vertx.VertxJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-            </executions>
-         </plugin>
-      </plugins>
-   </build>
+                    </includes>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>default-test</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>NettyJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>SunHttpJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.sun.http.SunHttpJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>VertxJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.vertx.VertxJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
 
 </project>
\ No newline at end of file",2021-06-08T16:16:48Z,500
"@@ -259,7 +259,6 @@
             </plugin>
             <plugin>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.8.1</version>
                 <configuration>
                     <parameters>true</parameters>
                 </configuration>",2021-06-08T16:16:48Z,501
"@@ -13,7 +13,7 @@
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
             <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node}
-                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}
+                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}
             </property>
             <property name=""managementAddress"">${node}</property>
         </configuration>",2021-06-08T16:16:48Z,502
"@@ -13,7 +13,7 @@
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
             <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node}
-                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}
+                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}
             </property>
             <property name=""managementAddress"">${node}</property>
         </configuration>",2021-06-08T16:16:48Z,503
"@@ -12,7 +12,7 @@
             <!--<property name=""javaVmArguments"">-Xmx512m -XX:MaxPermSize=128m
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
-            <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}</property>
+            <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}</property>
             <property name=""managementAddress"">${node}</property>
         </configuration>
     </container>",2021-06-08T16:16:48Z,460
"@@ -10,7 +10,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed} -Djboss.server.base.dir=${container.base.dir.managed}
+                <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed} -Djboss.server.base.dir=${container.base.dir.managed}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.managed}</property>
@@ -21,7 +21,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.gzip} -Dresteasy.allowGzip=true -Djboss.server.base.dir=${container.base.dir.manual.gzip}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.gzip} -Dresteasy.allowGzip=true -Djboss.server.base.dir=${container.base.dir.manual.gzip}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.manual.gzip}</property>
@@ -32,7 +32,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">standalone-tracing.xml</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.tracing} -Djboss.server.base.dir=${container.base.dir.manual.tracing}</property>
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.tracing} -Djboss.server.base.dir=${container.base.dir.manual.tracing}</property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.manual.tracing}</property>
             </configuration>
@@ -42,7 +42,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl} -Djboss.server.base.dir=${container.base.dir.manual.ssl}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl} -Djboss.server.base.dir=${container.base.dir.manual.ssl}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl}</property>
@@ -53,7 +53,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wrong} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wrong}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wrong} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wrong}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.wrong}</property>
@@ -64,7 +64,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wildcard} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wildcard}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wildcard} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wildcard}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.wildcard}</property>
@@ -75,7 +75,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.sni} -Djboss.server.base.dir=${container.base.dir.manual.ssl.sni}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.sni} -Djboss.server.base.dir=${container.base.dir.manual.ssl.sni}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.sni}</property>
@@ -87,7 +87,7 @@
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
                 <!-- Forcing file.encoding=us-ascii in order to test RESTEASY-2171 -->
-                <property name=""javaVmArguments"">-Dorg.jboss.resteasy.port=15080 -Dfile.encoding=us-ascii -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed.encoding} -Djboss.server.base.dir=${container.base.dir.managed.encoding}
+                <property name=""javaVmArguments"">-Dorg.jboss.resteasy.port=15080 -Dfile.encoding=us-ascii -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed.encoding} -Djboss.server.base.dir=${container.base.dir.managed.encoding}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.managed.encoding}</property>",2021-06-08T16:16:48Z,504
"@@ -18,7 +18,7 @@
     <skip.mp.tck>false</skip.mp.tck>
     <jetty9.version>9.2.30.v20200428</jetty9.version>
     <jetty.version>${jetty9.version}</jetty.version>
-    <tck.timeout.offset>30</tck.timeout.offset>
+    <tck.timeout.offset>90</tck.timeout.offset>
   </properties>
 
   <dependencies>
@@ -213,24 +213,12 @@
           <systemPropertyVariables>
                <org.eclipse.microprofile.rest.client.tck.timeoutCushion>${tck.timeout.offset}</org.eclipse.microprofile.rest.client.tck.timeoutCushion>
           </systemPropertyVariables>
+          <forkCount>1</forkCount>
+          <reuseForks>false</reuseForks>
+          <dependenciesToScan>
+            <dependency>org.eclipse.microprofile.rest.client:microprofile-rest-client-tck</dependency>
+          </dependenciesToScan>
         </configuration>
-        <executions>
-          <execution>
-            <id>default-test</id>
-            <phase>test</phase>
-            <goals>
-              <goal>test</goal>
-            </goals>
-            <configuration>
-              <forkCount>1</forkCount>
-              <reuseForks>false</reuseForks>
-              <dependenciesToScan>
-                <dependency>org.eclipse.microprofile.rest.client:microprofile-rest-client-tck</dependency>
-              </dependenciesToScan>
-            </configuration>
-          </execution>
-        </executions>
-
       </plugin>
 
     </plugins>
@@ -249,20 +237,23 @@
       </properties>
     </profile>
     <profile>
-      <id>skip-mp-tck.modular.jvm</id>
+      <id>jdk-9-test-config</id>
       <activation>
-        <jdk>[9,)</jdk>
+        <property>
+          <name>!test.java.home</name>
+        </property>
       </activation>
-      <properties>
-        <modular.jdk.args>
-          --add-exports=java.base/sun.nio.ch=ALL-UNNAMED
-          --add-modules=java.se
-          --add-opens=java.base/java.util=ALL-UNNAMED
-          --add-opens=java.base/java.security=ALL-UNNAMED
-          --add-opens=java.base/java.lang.invoke=ALL-UNNAMED
-        </modular.jdk.args>
-        <tck.timeout.offset>90</tck.timeout.offset>
-      </properties>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <argLine>--add-opens=java.base/java.lang.invoke=ALL-UNNAMED</argLine>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
     </profile>
   </profiles>
 </project>",2021-06-08T16:16:48Z,505
"@@ -23,6 +23,10 @@
         <ipv6ArquillianSettings/>
         <debugJvmArgs/>
         <jboss.server.config.file.name>standalone-full.xml</jboss.server.config.file.name>
+
+        <!-- Skip the default Java 8 testing. This will have to be done in CI or locally by setting the test.java.home -->
+        <skip.java8.tests>true</skip.java8.tests>
+        <test.java.home>${java.home}</test.java.home>
     </properties>
 
     <dependencyManagement>
@@ -95,6 +99,7 @@
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <configuration>
+                    <jvm>${test.java.home}/bin/java</jvm>
                     <failIfNoTests>false</failIfNoTests>
                     <systemPropertyVariables>
                         <securityManagerArg>${securityManagerArg}</securityManagerArg>
@@ -235,6 +240,34 @@
             </properties>
         </profile>
 
+        <profile>
+            <id>java8-integration-tests</id>
+            <activation>
+                <property>
+                    <name>test.java8.home</name>
+                </property>
+            </activation>
+            <properties>
+                <test.java.home>${test.java8.home}</test.java.home>
+            </properties>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <additionalClasspathElements>
+                                <additionalClasspathElement>${test.java.home}/lib/tools.jar</additionalClasspathElement>
+                            </additionalClasspathElements>
+                            <environmentVariables>
+                                <JAVA_HOME>${test.java.home}</JAVA_HOME>
+                            </environmentVariables>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+
         <profile>
             <id>ipv6</id>
             <activation>
@@ -451,9 +484,8 @@
         </profile>
 
         <profile>
-            <id>debug-java-11</id>
+            <id>debug</id>
             <activation>
-                <jdk>11</jdk>
                 <property>
                     <name>debug</name>
                 </property>
@@ -467,9 +499,8 @@
         <profile>
             <id>debug-java-8</id>
             <activation>
-                <jdk>1.8</jdk>
                 <property>
-                    <name>debug</name>
+                    <name>debug.java.8</name>
                 </property>
             </activation>
             <properties>",2021-06-08T16:16:48Z,366
"@@ -147,6 +147,7 @@
                 </plugins>
             </build>
         </profile>
+
     </profiles>
 
     <build>",2020-12-03T13:42:00Z,396
"@@ -185,6 +185,7 @@
                 </plugins>
             </build>
         </profile>
+
     </profiles>
 
     <dependencies>",2020-12-03T13:42:00Z,399
"@@ -57,7 +57,7 @@
                         <jboss.server.config.file.name>${jboss.server.config.file.name}</jboss.server.config.file.name>
                         <security.provider>${security.provider}</security.provider>
                     </systemPropertyVariables>
-                    <excludedGroups>org.jboss.resteasy.category.ExpectedFailing,${additional.surefire.excluded.groups}</excludedGroups>
+                    <excludedGroups>org.jboss.resteasy.category.ExpectedFailing${additional.surefire.excluded.groups}</excludedGroups>
                 </configuration>
             </plugin>
             <plugin>
@@ -159,7 +159,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly20</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly20</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <profile>
@@ -171,7 +171,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly19</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly19</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <profile>
@@ -183,7 +183,7 @@
                 </property>
             </activation>
             <properties>
-                <additional.surefire.excluded.groups>org.jboss.resteasy.category.ExpectedFailingOnWildFly18</additional.surefire.excluded.groups>
+                <additional.surefire.excluded.groups>,org.jboss.resteasy.category.ExpectedFailingOnWildFly18</additional.surefire.excluded.groups>
             </properties>
         </profile>
         <!-- If resteasy.version is specified, it will be used for tests instead of the project.version -->",2020-12-03T13:42:00Z,366
"@@ -76,6 +76,13 @@
                     <skip>true</skip>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <skipIfEmpty>true</skipIfEmpty>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2019-03-07T22:11:01Z,495
"@@ -63,6 +63,13 @@
                     <skip>true</skip>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <configuration>
+                    <skipIfEmpty>true</skipIfEmpty>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 ",2019-03-07T22:11:01Z,366
"@@ -36,7 +36,7 @@ jobs:
         with:
           java-version: ${{ matrix.java }}
       - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }}
-        run: mvn clean install -fae '-Dserver.version=${{ matrix.wildfly-version }}'
+        run: mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions'
       - uses: actions/upload-artifact@v2
         if: failure()
         with:
@@ -68,5 +68,5 @@ jobs:
         with:
           java-version: ${{ matrix.java }}
       - name: Build Java Docs with Java ${{ matrix.java }}
-        run: mvn clean install -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
+        run: mvn clean install -U -B -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
 ",2021-05-22T00:44:54Z,496
"@@ -3,7 +3,7 @@
     <parent>
         <groupId>org.jboss</groupId>
         <artifactId>jboss-parent</artifactId>
-        <version>35</version>
+        <version>38</version>
         <relativePath/>
     </parent>
 
@@ -170,6 +170,39 @@
                 </plugins>
             </build>
       </profile>
+      <profile>
+          <id>github-actions</id>
+          <activation>
+              <property>
+                  <name>github.actions</name>
+              </property>
+          </activation>
+
+          <dependencies>
+              <!-- Add explicit dependency to force download of the dependency -->
+              <dependency>
+                  <groupId>org.apache.maven.surefire</groupId>
+                  <artifactId>surefire-junit47</artifactId>
+                  <version>${version.surefire.plugin}</version>
+                  <scope>test</scope>
+              </dependency>
+          </dependencies>
+          <build>
+              <plugins>
+                  <plugin>
+                      <groupId>org.apache.maven.plugins</groupId>
+                      <artifactId>maven-surefire-plugin</artifactId>
+                      <dependencies>
+                          <dependency>
+                              <groupId>org.apache.maven.surefire</groupId>
+                              <artifactId>surefire-junit47</artifactId>
+                              <version>${version.surefire.plugin}</version>
+                          </dependency>
+                      </dependencies>
+                  </plugin>
+              </plugins>
+          </build>
+      </profile>
       <profile>
           <id>jboss-repository</id>
           <repositories>",2021-05-22T00:44:54Z,298
"@@ -4,7 +4,7 @@
     <parent>
         <groupId>org.jboss</groupId>
         <artifactId>jboss-parent</artifactId>
-        <version>35</version>
+        <version>38</version>
         <relativePath/>
     </parent>
     <modelVersion>4.0.0</modelVersion>",2021-05-22T00:44:54Z,247
"@@ -15,13 +15,13 @@ jobs:
   build:
 
     runs-on: ${{ matrix.os }}
-    timeout-minutes: 60
+    timeout-minutes: 90
     strategy:
       fail-fast: false
       matrix:
         os: [ubuntu-latest, windows-latest ]
-        java: ['1.8', '11']
-        wildfly-version: ['22.0.1.Final', '23.0.2.Final']
+        java: ['11', '16']
+        wildfly-version: ['23.0.2.Final']
 
     steps:
       - uses: actions/checkout@v2
@@ -31,12 +31,28 @@ jobs:
           key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
           restore-keys: |
             ${{ runner.os }}-maven-
+      - name: Set up JDK 8
+        uses: actions/setup-java@v2
+        with:
+          java-version: 8
+          distribution: 'adopt'
       - name: Set up JDK ${{ matrix.java }}
-        uses: actions/setup-java@v1
+        uses: actions/setup-java@v2
         with:
           java-version: ${{ matrix.java }}
-      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }}
-        run: mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions'
+          distribution: 'adopt'
+      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }} - Linux
+        if: runner.os == 'Linux'
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae -Dserver.version=${{ matrix.wildfly-version }} -Dgithub.actions -Djava8.home=""$JAVA_HOME_8_X64""
+          echo ""::endgroup::""
+      - name: Build with Maven Java ${{ matrix.java }} on WildFly ${{ matrix.wildfly-version }} - Windows
+        if: runner.os == 'Windows'
+        run:  |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions' '""-Djava8.home=%JAVA_HOME_8_X64%""'
+          echo ""::endgroup::""
       - uses: actions/upload-artifact@v2
         if: failure()
         with:
@@ -48,13 +64,65 @@ jobs:
           name: server-logs-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
           path: '**/server.log'
 
-  build-java-docs:
-    runs-on: ubuntu-latest
-    timeout-minutes: 60
+  test-with-java8:
+
+    runs-on: ${{ matrix.os }}
+    timeout-minutes: 90
     strategy:
       fail-fast: false
       matrix:
-        java: ['1.8', '11']
+        os: [ubuntu-latest, windows-latest ]
+        wildfly-version: ['23.0.2.Final']
+
+    steps:
+      - uses: actions/checkout@v2
+      - uses: actions/cache@v1
+        with:
+          path: ~/.m2/repository
+          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+          restore-keys: |
+            ${{ runner.os }}-maven-
+      - name: Set up JDK 8
+        uses: actions/setup-java@v2
+        with:
+          java-version: 8
+          distribution: 'adopt'
+      - name: Set up JDK 11
+        uses: actions/setup-java@v2
+        with:
+          java-version: 11
+          distribution: 'adopt'
+      - name: Build with Java 11
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -DskipTests
+          echo ""::endgroup::""
+      - name: Test with Java 8 on WildFly ${{ matrix.wildfly-version }} - Linux
+        if: runner.os == 'Linux'
+        run:  |
+          echo ""::group::Test Logs""
+          mvn clean install -U -B -fae -rf ':resteasy-testsuite' -Dserver.version=${{ matrix.wildfly-version }} -Dgithub.actions -Dtest.java8.home=""$JAVA_HOME_8_X64""
+          echo ""::endgroup::""
+      - name: Test with Java 8 on WildFly ${{ matrix.wildfly-version }} - Windows
+        if: runner.os == 'Windows'
+        run: |
+          echo ""::group::Build Logs""
+          mvn clean install -U -B -fae -rf ':resteasy-testsuite' '-Dserver.version=${{ matrix.wildfly-version }}' '-Dgithub.actions' '""-Dtest.java8.home=%JAVA_HOME_8_X64%""'
+          echo ""::endgroup::""
+      - uses: actions/upload-artifact@v2
+        if: failure()
+        with:
+          name: surefire-reports-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
+          path: '**/surefire-reports/*.txt'
+      - uses: actions/upload-artifact@v2
+        if: failure()
+        with:
+          name: server-logs-${{ matrix.os }}-${{ matrix.java }}-${{ matrix.wildfly-version }}
+          path: '**/server.log'
+
+  build-java-docs:
+    runs-on: ubuntu-latest
+    timeout-minutes: 20
     steps:
       - uses: actions/checkout@v2
       - uses: actions/cache@v1
@@ -63,10 +131,10 @@ jobs:
           key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
           restore-keys: |
             ${{ runner.os }}-maven-javadoc
-      - name: Set up JDK ${{ matrix.java }}
+      - name: Set up JDK 11
         uses: actions/setup-java@v1
         with:
-          java-version: ${{ matrix.java }}
-      - name: Build Java Docs with Java ${{ matrix.java }}
+          java-version: 11
+      - name: Build Java Docs with Java 11
         run: mvn clean install -U -B -DskipTests '-Dmaven.javadoc.skip=false' javadoc:javadoc
 ",2021-06-08T16:16:48Z,496
"@@ -27,7 +27,7 @@ Issues are kept in [JIRA](https://issues.redhat.com/projects/RESTEASY/issues).
 
 ## Build
 
-Currently RESTEasy can be built with JDK 1.8 and 11.
+Currently RESTEasy can be built with JDK 11+.
 
 If you want to purely build the project without running the tests, you need to pull down a clone of the RESTEasy repository and run:
 ",2021-06-08T16:16:48Z,497
"@@ -14,8 +14,8 @@
     <container qualifier=""jetty"" default=""true"">
        <configuration>
            <property name=""bindHttpPort"">0</property>
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args}</property>
-           <!--property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=y</property-->
+           <property name=""javaVmArguments"">${additionalJvmArgs}</property>
+           <!--property name=""javaVmArguments"">${additionalJvmArgs} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=y</property-->
        </configuration>
     </container>
 </arquillian>",2021-06-08T16:16:48Z,498
"@@ -14,9 +14,9 @@
     <container qualifier=""jetty"" default=""true"">
        <configuration>
            <property name=""bindHttpPort"">0</property>
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args}</property>
+           <property name=""javaVmArguments"">${additionalJvmArgs}</property>
          <!--
-           <property name=""javaVmArguments"">${additionalJvmArgs} ${modular.jdk.args} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=n</property>
+           <property name=""javaVmArguments"">${additionalJvmArgs} -Xdebug -Xrunjdwp:transport=dt_socket,address=8585,server=y, suspend=n</property>
          -->
        </configuration>
     </container>",2021-06-08T16:16:48Z,499
"@@ -29,20 +29,21 @@
         <jboss.home/>
         <!-- print logs to file by default -->
         <maven.test.redirectTestOutputToFile>true</maven.test.redirectTestOutputToFile>
-        <!-- Modularized JDK support (various workarounds) - activated via profile -->
-        <modular.jdk.args/>
         <!-- maven-enforcer-plugin -->
         <maven.min.version>3.2.5</maven.min.version>
-        <jdk.min.version>${maven.compiler.source}</jdk.min.version>
+
+        <!-- Require at least Java 11 to compile, but compile down to Java 8 -->
+        <jdk.min.version>11</jdk.min.version>
+        <javadoc.additional.params>--release=8</javadoc.additional.params>
         <!-- maven-surefire-plugin -->
-        <surefire.system.args>-Xms512m -Xmx512m ${modular.jdk.args}</surefire.system.args>
+        <surefire.system.args>-Xms512m -Xmx512m</surefire.system.args>
+        <skip.java8.tests>false</skip.java8.tests>
 
         <maven.test.skip>false</maven.test.skip>
         <skipTests>${maven.test.skip}</skipTests>
 
         <!-- Plugins versions -->
         <version.org.jacoco.plugin>0.7.9</version.org.jacoco.plugin>
-        <version.javadoc.plugin>3.0.1</version.javadoc.plugin>
         <version.compiler.plugin>3.8.0-jboss-2</version.compiler.plugin>
         <version.org.wildfly.plugins.wildfly-maven-plugin>2.1.0.Beta1</version.org.wildfly.plugins.wildfly-maven-plugin>
     </properties>
@@ -146,18 +147,39 @@
             </dependencyManagement>
         </profile>
       <profile>
-          <id>modular.jvm</id>
+          <id>java8.tests</id>
           <activation>
-              <jdk>[9,)</jdk>
+              <property>
+                  <name>java8.home</name>
+              </property>
           </activation>
-          <properties>
-              <modular.jdk.args>
-                  --add-exports=java.base/sun.nio.ch=ALL-UNNAMED
-                  --add-modules=java.se
-                  --add-opens=java.base/java.util=ALL-UNNAMED
-                  --add-opens=java.base/java.security=ALL-UNNAMED
-              </modular.jdk.args>
-          </properties>
+          <build>
+              <plugins>
+                  <plugin>
+                      <groupId>org.apache.maven.plugins</groupId>
+                      <artifactId>maven-surefire-plugin</artifactId>
+                      <executions>
+                          <execution>
+                              <id>java8-test</id>
+                              <phase>test</phase>
+                              <goals>
+                                  <goal>test</goal>
+                              </goals>
+                              <configuration>
+                                  <skip>${skip.java8.tests}</skip>
+                                  <jvm>${java8.home}/bin/java</jvm>
+                                  <additionalClasspathElements>
+                                      <additionalClasspathElement>${java8.home}/lib/tools.jar</additionalClasspathElement>
+                                  </additionalClasspathElements>
+                                  <environmentVariables>
+                                      <JAVA_HOME>${java8.home}</JAVA_HOME>
+                                  </environmentVariables>
+                              </configuration>
+                          </execution>
+                      </executions>
+                  </plugin>
+              </plugins>
+          </build>
       </profile>
       <profile>
           <id>github-actions</id>
@@ -219,6 +241,22 @@
     <build>
         <pluginManagement>
             <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-compiler-plugin</artifactId>
+                    <executions>
+                        <execution>
+                            <id>default-compile</id>
+                            <phase>compile</phase>
+                            <goals>
+                                <goal>compile</goal>
+                            </goals>
+                            <configuration>
+                                <release>8</release>
+                            </configuration>
+                        </execution>
+                    </executions>
+                </plugin>
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-surefire-plugin</artifactId>
@@ -232,9 +270,8 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-javadoc-plugin</artifactId>
-                    <version>${version.javadoc.plugin}</version>
                     <configuration>
-                        <source>8</source>
+                        <doclint>none</doclint>
                         <minmemory>128m</minmemory>
                         <maxmemory>1024m</maxmemory>
                         <quiet>false</quiet>
@@ -367,20 +404,6 @@
                             </rules>
                         </configuration>
                     </execution>
-                    <execution>
-                        <id>use-java-8-for-release</id>
-                        <phase>deploy</phase>
-                        <goals>
-                            <goal>enforce</goal>
-                        </goals>
-                        <configuration>
-                            <rules>
-                                <requireJavaVersion>
-                                    <version>[1.8,9)</version>
-                                </requireJavaVersion>
-                            </rules>
-                        </configuration>
-                    </execution>
                 </executions>
             </plugin>
         </plugins>",2021-06-08T16:16:48Z,298
"@@ -16,13 +16,6 @@
    <artifactId>integration-tests-embedded</artifactId>
    <name>RESTEasy Main testsuite: Embedded Server tests</name>
 
-
-   <properties>
-      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-      <maven.compiler.source>1.8</maven.compiler.source>
-      <maven.compiler.target>1.8</maven.compiler.target>
-   </properties>
-
    <dependencies>
       <dependency>
          <groupId>junit</groupId>
@@ -118,123 +111,70 @@
       </dependency>
    </dependencies>
 
-   <build>
-      <plugins>
-
-         <plugin>
-            <artifactId>maven-surefire-plugin</artifactId>
-            <executions>
-               <execution>
-                  <id>default-test</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>NettyJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
+    <build>
+        <plugins>
+            <plugin>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <includes>
                         <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>SunHttpJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.sun.http.SunHttpJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-               <execution>
-                  <id>VertxJaxrsServer</id>
-                  <goals>
-                     <goal>test</goal>
-                  </goals>
-
-                  <configuration>
-                     <includes>
-                        <include>**/*Test.java</include>
-                     </includes>
-                     <excludes></excludes>
-                     <!-- since 2.5 -->
-                     <!--
-                     <systemPropertyVariables>
-                       <fileName>${fileName}</fileName>
-                     </systemPropertyVariables>
-                     -->
-                     <!-- deprecated -->
-                     <systemProperties>
-                        <property>
-                           <name>fileName</name>
-                           <value>org.jboss.resteasy.plugins.server.vertx.VertxJaxrsServer</value>
-                        </property>
-                     </systemProperties>
-                  </configuration>
-               </execution>
-
-            </executions>
-         </plugin>
-      </plugins>
-   </build>
+                    </includes>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>default-test</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>NettyJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.netty.NettyJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>SunHttpJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.sun.http.SunHttpJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+
+                    <execution>
+                        <id>VertxJaxrsServer</id>
+                        <goals>
+                            <goal>test</goal>
+                        </goals>
+
+                        <configuration>
+                            <systemPropertyVariables>
+                                <fileName>org.jboss.resteasy.plugins.server.vertx.VertxJaxrsServer</fileName>
+                            </systemPropertyVariables>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
 
 </project>
\ No newline at end of file",2021-06-08T16:16:48Z,500
"@@ -259,7 +259,6 @@
             </plugin>
             <plugin>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.8.1</version>
                 <configuration>
                     <parameters>true</parameters>
                 </configuration>",2021-06-08T16:16:48Z,501
"@@ -13,7 +13,7 @@
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
             <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node}
-                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}
+                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}
             </property>
             <property name=""managementAddress"">${node}</property>
         </configuration>",2021-06-08T16:16:48Z,502
"@@ -13,7 +13,7 @@
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
             <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node}
-                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}
+                -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}
             </property>
             <property name=""managementAddress"">${node}</property>
         </configuration>",2021-06-08T16:16:48Z,503
"@@ -12,7 +12,7 @@
             <!--<property name=""javaVmArguments"">-Xmx512m -XX:MaxPermSize=128m
                 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
             </property>-->
-            <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent}</property>
+            <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms96m -Xmx1024m -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent}</property>
             <property name=""managementAddress"">${node}</property>
         </configuration>
     </container>",2021-06-08T16:16:48Z,460
"@@ -10,7 +10,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed} -Djboss.server.base.dir=${container.base.dir.managed}
+                <property name=""javaVmArguments"">${debugJvmArgs} -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed} -Djboss.server.base.dir=${container.base.dir.managed}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.managed}</property>
@@ -21,7 +21,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.gzip} -Dresteasy.allowGzip=true -Djboss.server.base.dir=${container.base.dir.manual.gzip}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.gzip} -Dresteasy.allowGzip=true -Djboss.server.base.dir=${container.base.dir.manual.gzip}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.manual.gzip}</property>
@@ -32,7 +32,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">standalone-tracing.xml</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.tracing} -Djboss.server.base.dir=${container.base.dir.manual.tracing}</property>
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.tracing} -Djboss.server.base.dir=${container.base.dir.manual.tracing}</property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.manual.tracing}</property>
             </configuration>
@@ -42,7 +42,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl} -Djboss.server.base.dir=${container.base.dir.manual.ssl}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl} -Djboss.server.base.dir=${container.base.dir.manual.ssl}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl}</property>
@@ -53,7 +53,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wrong} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wrong}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wrong} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wrong}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.wrong}</property>
@@ -64,7 +64,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wildcard} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wildcard}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.wildcard} -Djboss.server.base.dir=${container.base.dir.manual.ssl.wildcard}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.wildcard}</property>
@@ -75,7 +75,7 @@
                 <property name=""jbossHome"">${jboss.home}</property>
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
-                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.sni} -Djboss.server.base.dir=${container.base.dir.manual.ssl.sni}
+                <property name=""javaVmArguments"">-server -Xms256m -Xmx1G -Djboss.bind.address=localhost -Djboss.bind.address.management=localhost -Dnode=localhost -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.manual.ssl.sni} -Djboss.server.base.dir=${container.base.dir.manual.ssl.sni}
                 </property>
                 <property name=""managementAddress"">localhost</property>
                 <property name=""managementPort"">${container.management.port.manual.ssl.sni}</property>
@@ -87,7 +87,7 @@
                 <property name=""jbossArguments"">${securityManagerArg}</property>
                 <property name=""serverConfig"">${jboss.server.config.file.name:standalone-full.xml}</property>
                 <!-- Forcing file.encoding=us-ascii in order to test RESTEASY-2171 -->
-                <property name=""javaVmArguments"">-Dorg.jboss.resteasy.port=15080 -Dfile.encoding=us-ascii -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${modular.jdk.args} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed.encoding} -Djboss.server.base.dir=${container.base.dir.managed.encoding}
+                <property name=""javaVmArguments"">-Dorg.jboss.resteasy.port=15080 -Dfile.encoding=us-ascii -server -Xms256m -Xmx1G -Djboss.bind.address=${node} -Djboss.bind.address.management=${node} -Dnode=${node} -Dipv6=${ipv6} ${additionalJvmArgs} ${ipv6ArquillianSettings} ${jacoco.agent} -Djboss.socket.binding.port-offset=${container.offset.managed.encoding} -Djboss.server.base.dir=${container.base.dir.managed.encoding}
                 </property>
                 <property name=""managementAddress"">${node}</property>
                 <property name=""managementPort"">${container.management.port.managed.encoding}</property>",2021-06-08T16:16:48Z,504
"@@ -18,7 +18,7 @@
     <skip.mp.tck>false</skip.mp.tck>
     <jetty9.version>9.2.30.v20200428</jetty9.version>
     <jetty.version>${jetty9.version}</jetty.version>
-    <tck.timeout.offset>30</tck.timeout.offset>
+    <tck.timeout.offset>90</tck.timeout.offset>
   </properties>
 
   <dependencies>
@@ -213,24 +213,12 @@
           <systemPropertyVariables>
                <org.eclipse.microprofile.rest.client.tck.timeoutCushion>${tck.timeout.offset}</org.eclipse.microprofile.rest.client.tck.timeoutCushion>
           </systemPropertyVariables>
+          <forkCount>1</forkCount>
+          <reuseForks>false</reuseForks>
+          <dependenciesToScan>
+            <dependency>org.eclipse.microprofile.rest.client:microprofile-rest-client-tck</dependency>
+          </dependenciesToScan>
         </configuration>
-        <executions>
-          <execution>
-            <id>default-test</id>
-            <phase>test</phase>
-            <goals>
-              <goal>test</goal>
-            </goals>
-            <configuration>
-              <forkCount>1</forkCount>
-              <reuseForks>false</reuseForks>
-              <dependenciesToScan>
-                <dependency>org.eclipse.microprofile.rest.client:microprofile-rest-client-tck</dependency>
-              </dependenciesToScan>
-            </configuration>
-          </execution>
-        </executions>
-
       </plugin>
 
     </plugins>
@@ -249,20 +237,23 @@
       </properties>
     </profile>
     <profile>
-      <id>skip-mp-tck.modular.jvm</id>
+      <id>jdk-9-test-config</id>
       <activation>
-        <jdk>[9,)</jdk>
+        <property>
+          <name>!test.java.home</name>
+        </property>
       </activation>
-      <properties>
-        <modular.jdk.args>
-          --add-exports=java.base/sun.nio.ch=ALL-UNNAMED
-          --add-modules=java.se
-          --add-opens=java.base/java.util=ALL-UNNAMED
-          --add-opens=java.base/java.security=ALL-UNNAMED
-          --add-opens=java.base/java.lang.invoke=ALL-UNNAMED
-        </modular.jdk.args>
-        <tck.timeout.offset>90</tck.timeout.offset>
-      </properties>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <argLine>--add-opens=java.base/java.lang.invoke=ALL-UNNAMED</argLine>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
     </profile>
   </profiles>
 </project>",2021-06-08T16:16:48Z,505
"@@ -23,6 +23,10 @@
         <ipv6ArquillianSettings/>
         <debugJvmArgs/>
         <jboss.server.config.file.name>standalone-full.xml</jboss.server.config.file.name>
+
+        <!-- Skip the default Java 8 testing. This will have to be done in CI or locally by setting the test.java.home -->
+        <skip.java8.tests>true</skip.java8.tests>
+        <test.java.home>${java.home}</test.java.home>
     </properties>
 
     <dependencyManagement>
@@ -95,6 +99,7 @@
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <configuration>
+                    <jvm>${test.java.home}/bin/java</jvm>
                     <failIfNoTests>false</failIfNoTests>
                     <systemPropertyVariables>
                         <securityManagerArg>${securityManagerArg}</securityManagerArg>
@@ -235,6 +240,34 @@
             </properties>
         </profile>
 
+        <profile>
+            <id>java8-integration-tests</id>
+            <activation>
+                <property>
+                    <name>test.java8.home</name>
+                </property>
+            </activation>
+            <properties>
+                <test.java.home>${test.java8.home}</test.java.home>
+            </properties>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <additionalClasspathElements>
+                                <additionalClasspathElement>${test.java.home}/lib/tools.jar</additionalClasspathElement>
+                            </additionalClasspathElements>
+                            <environmentVariables>
+                                <JAVA_HOME>${test.java.home}</JAVA_HOME>
+                            </environmentVariables>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+
         <profile>
             <id>ipv6</id>
             <activation>
@@ -451,9 +484,8 @@
         </profile>
 
         <profile>
-            <id>debug-java-11</id>
+            <id>debug</id>
             <activation>
-                <jdk>11</jdk>
                 <property>
                     <name>debug</name>
                 </property>
@@ -467,9 +499,8 @@
         <profile>
             <id>debug-java-8</id>
             <activation>
-                <jdk>1.8</jdk>
                 <property>
-                    <name>debug</name>
+                    <name>debug.java.8</name>
                 </property>
             </activation>
             <properties>",2021-06-08T16:16:48Z,366
"@@ -1,11 +1,8 @@
 package org.jboss.resteasy.microprofile.client;
 
 
-import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptor;
-import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.logging.Logger;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
-import org.jboss.resteasy.microprofile.client.async.AsyncInvocationInterceptorHandler;
 import org.jboss.resteasy.microprofile.client.header.ClientHeaderFillingException;
 
 import javax.enterprise.context.spi.CreationalContext;
@@ -51,17 +48,13 @@ public class ProxyInvocationHandler implements InvocationHandler {
 
     private final AtomicBoolean closed;
 
-    private final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories;
-
     public ProxyInvocationHandler(final Class<?> restClientInterface,
                            final Object target,
                            final Set<Object> providerInstances,
-                           final ResteasyClient client,
-                           final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) {
+                           final ResteasyClient client) {
         this.target = target;
         this.providerInstances = providerInstances;
         this.client = client;
-        this.asyncInterceptorFactories = asyncInterceptorFactories;
         this.closed = new AtomicBoolean();
         BeanManager beanManager = getBeanManager(restClientInterface);
         if (beanManager != null) {
@@ -87,8 +80,6 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
             throw new IllegalStateException(""RestClientProxy is closed"");
         }
 
-        prepareAsyncInterceptors();
-
         boolean replacementNeeded = false;
         Object[] argsReplacement = args != null ? new Object[args.length] : null;
         Annotation[][] parameterAnnotations = method.getParameterAnnotations();
@@ -175,14 +166,6 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
         }
     }
 
-    private void prepareAsyncInterceptors() {
-        List<AsyncInvocationInterceptor> interceptors = asyncInterceptorFactories.stream()
-                .map(AsyncInvocationInterceptorFactory::newInterceptor)
-                .collect(Collectors.toList());
-        interceptors.forEach(AsyncInvocationInterceptor::prepareContext);
-        AsyncInvocationInterceptorHandler.register(interceptors);
-    }
-
     private Object invokeRestClientProxyMethod(Object proxy, Method method, Object[] args) throws Throwable {
         switch (method.getName()) {
             case ""getClient"":",2020-04-23T12:58:15Z,31
"@@ -12,7 +12,6 @@
 import org.jboss.resteasy.client.jaxrs.engines.URLConnectionClientEngineBuilder;
 import org.jboss.resteasy.client.jaxrs.internal.LocalResteasyProviderFactory;
 import org.jboss.resteasy.microprofile.client.async.AsyncInterceptorRxInvokerProvider;
-import org.jboss.resteasy.microprofile.client.async.AsyncInvocationInterceptorHandler;
 import org.jboss.resteasy.microprofile.client.header.ClientHeaderProviders;
 import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;
 import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;
@@ -43,7 +42,6 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.security.KeyStore;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -236,11 +234,9 @@ public <T> T build(Class<T> aClass) throws IllegalStateException, RestClientDefi
         }
 
         if (this.executorService != null) {
-           ExecutorService executor = AsyncInvocationInterceptorHandler.wrapExecutorService(this.executorService);
-           resteasyClientBuilder.executorService(executor);
+           resteasyClientBuilder.executorService(this.executorService);
         } else {
-           ExecutorService executor = AsyncInvocationInterceptorHandler.wrapExecutorService(Executors.newCachedThreadPool());
-           resteasyClientBuilder.executorService(executor, true);
+           resteasyClientBuilder.executorService(Executors.newCachedThreadPool(), true);
         }
         resteasyClientBuilder.register(DEFAULT_MEDIA_TYPE_FILTER);
         resteasyClientBuilder.register(METHOD_INJECTION_FILTER);
@@ -281,7 +277,7 @@ public <T> T build(Class<T> aClass) throws IllegalStateException, RestClientDefi
         interfaces[1] = RestClientProxy.class;
         interfaces[2] = Closeable.class;
 
-        T proxy = (T) Proxy.newProxyInstance(classLoader, interfaces, new ProxyInvocationHandler(aClass, actualClient, getLocalProviderInstances(), client, asyncInterceptorFactories));
+        T proxy = (T) Proxy.newProxyInstance(classLoader, interfaces, new ProxyInvocationHandler(aClass, actualClient, getLocalProviderInstances(), client));
         ClientHeaderProviders.registerForClass(aClass, proxy);
         return proxy;
     }
@@ -497,7 +493,7 @@ public RestClientBuilder register(Object o) {
         } else if (o instanceof ParamConverterProvider) {
             register(o, Priorities.USER);
         } else if (o instanceof AsyncInvocationInterceptorFactory) {
-            asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);
+            builderDelegate.asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);
         } else {
             builderDelegate.register(o);
         }
@@ -529,7 +525,7 @@ public RestClientBuilder register(Object o, int i) {
             builderDelegate.register(converter, i);
 
         } else if (o instanceof AsyncInvocationInterceptorFactory) {
-            asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);
+            builderDelegate.asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);
         } else {
             builderDelegate.register(o, i);
         }
@@ -592,7 +588,7 @@ ResteasyClientBuilder getBuilderDelegate() {
         return builderDelegate;
     }
 
-    private final ResteasyClientBuilder builderDelegate;
+    private final MpClientBuilderImpl builderDelegate;
 
     private final ConfigurationWrapper configurationWrapper;
 
@@ -616,6 +612,4 @@ ResteasyClientBuilder getBuilderDelegate() {
 
 
     private Set<Object> localProviderInstances = new HashSet<>();
-
-    private final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories = new ArrayList<>();
 }",2020-04-23T12:58:15Z,315
"@@ -1,6 +1,5 @@
 package org.jboss.resteasy.microprofile.client.async;
 
-import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptor;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
 import org.jboss.resteasy.client.jaxrs.internal.CompletionStageRxInvokerImpl;
 import org.jboss.resteasy.core.SynchronousDispatcher;
@@ -12,7 +11,6 @@
 import javax.ws.rs.core.Response;
 
 import java.lang.reflect.Method;
-import java.util.Collection;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutorService;
@@ -45,8 +43,6 @@ private void setupMethod(SyncInvoker builder)
    }
 
    private static <T> CompletionStage<T> whenComplete(CompletionStage<T> stage, Method method) {
-      final Collection<AsyncInvocationInterceptor> asyncInvocationInterceptors = AsyncInvocationInterceptorHandler.threadBoundInterceptors.get();
-      AsyncInvocationInterceptorHandler.threadBoundInterceptors.remove();
 
       return stage.handle((ret, t) -> {
          if(t != null) {
@@ -67,10 +63,6 @@ private static <T> CompletionStage<T> whenComplete(CompletionStage<T> stage, Met
            SynchronousDispatcher.rethrow(t);
          }
          return ret;
-      }).whenComplete((o, throwable) -> {
-         if (asyncInvocationInterceptors != null ) {
-            asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::removeContext);
-         }
       });
    }
 ",2020-04-23T12:58:15Z,316
"@@ -1,47 +0,0 @@
-package org.jboss.resteasy.microprofile.client.async;
-
-import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptor;
-
-import java.util.Collection;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-
-public class AsyncInvocationInterceptorHandler {
-
-    static final ThreadLocal<Collection<AsyncInvocationInterceptor>> threadBoundInterceptors = new ThreadLocal<>();
-
-    public static void register(Collection<AsyncInvocationInterceptor> interceptor) {
-        threadBoundInterceptors.set(interceptor);
-    }
-
-    public static ExecutorService wrapExecutorService(ExecutorService service) {
-        return new ExecutorServiceWrapper(service, new Decorator());
-    }
-
-    public static class Decorator implements ExecutorServiceWrapper.Decorator {
-        @Override
-        public Runnable decorate(Runnable runnable) {
-            Collection<AsyncInvocationInterceptor> interceptors = threadBoundInterceptors.get();
-            return () -> {
-                if (interceptors != null) {
-                    interceptors.forEach(AsyncInvocationInterceptor::applyContext);
-                }
-                runnable.run();
-            };
-        }
-
-        @Override
-        public <V> Callable<V> decorate(Callable<V> callable) {
-            Collection<AsyncInvocationInterceptor> interceptors = threadBoundInterceptors.get();
-            return () -> {
-                if (interceptors != null) {
-                    interceptors.forEach(AsyncInvocationInterceptor::applyContext);
-                }
-                return callable.call();
-            };
-        }
-    }
-
-    private AsyncInvocationInterceptorHandler() {
-    }
-}",2020-04-23T12:58:15Z,317
"@@ -101,7 +101,7 @@ private <T> Callable<T> decorate(Callable<T> command) {
         return decorator.decorate(command);
     }
 
-    interface Decorator {
+    public interface Decorator {
         Runnable decorate(Runnable runnable);
 
         <T> Callable<T> decorate(Callable<T> runnable);",2020-04-23T12:58:15Z,318
"@@ -1,11 +1,13 @@
 package org.jboss.resteasy.microprofile.client.impl;
 
 import java.net.URI;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 
 import javax.ws.rs.core.UriBuilder;
 
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.resteasy.client.jaxrs.ClientHttpEngine;
 import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
@@ -14,21 +16,25 @@
 
 public class MpClient extends ResteasyClientImpl {
 
-    public MpClient(final ClientHttpEngine engine, final ExecutorService executor, final boolean cleanupExecutor,
-                    final ScheduledExecutorService scheduledExecutorService, final ClientConfiguration config) {
+   private List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories;
+
+   public MpClient(final ClientHttpEngine engine, final ExecutorService executor, final boolean cleanupExecutor,
+                    final ScheduledExecutorService scheduledExecutorService, final ClientConfiguration config,
+                    final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) {
         super(engine, executor, cleanupExecutor, scheduledExecutorService, config);
+        this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
     protected ResteasyWebTarget createClientWebTarget(ResteasyClientImpl client, String uri, ClientConfiguration configuration) {
-        return new MpClientWebTarget(client, uri, configuration);
+        return new MpClientWebTarget(client, uri, configuration, asyncInterceptorFactories);
     }
 
     protected ResteasyWebTarget createClientWebTarget(ResteasyClientImpl client, URI uri, ClientConfiguration configuration) {
-        return new MpClientWebTarget(client, uri, configuration);
+        return new MpClientWebTarget(client, uri, configuration, asyncInterceptorFactories);
     }
 
     protected ResteasyWebTarget createClientWebTarget(ResteasyClientImpl client, UriBuilder uriBuilder, ClientConfiguration configuration) {
-        return new MpClientWebTarget(client, uriBuilder, configuration);
+        return new MpClientWebTarget(client, uriBuilder, configuration, asyncInterceptorFactories);
     }
 
 }",2020-04-23T12:58:15Z,319
"@@ -1,8 +1,11 @@
 package org.jboss.resteasy.microprofile.client.impl;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.resteasy.client.jaxrs.ClientHttpEngine;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
@@ -11,9 +14,11 @@
 
 public class MpClientBuilderImpl extends ResteasyClientBuilderImpl {
 
+    public final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories = new ArrayList<>();
+
     @Override
     protected ResteasyClient createResteasyClient(ClientHttpEngine engine, ExecutorService executor, boolean cleanupExecutor,
                                                   ScheduledExecutorService scheduledExecutorService, ClientConfiguration config) {
-        return new MpClient(engine, executor, cleanupExecutor, scheduledExecutorService, config);
+        return new MpClient(engine, executor, cleanupExecutor, scheduledExecutorService, config, asyncInterceptorFactories);
     }
 }",2020-04-23T12:58:15Z,320
"@@ -1,34 +1,64 @@
 package org.jboss.resteasy.microprofile.client.impl;
 
 import java.net.URI;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.stream.Collectors;
 
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MultivaluedMap;
 
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptor;
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientRequestContextImpl;
 import org.jboss.resteasy.client.jaxrs.internal.ClientRequestHeaders;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
 import org.jboss.resteasy.core.ResteasyContext;
+import org.jboss.resteasy.microprofile.client.async.ExecutorServiceWrapper;
 
 
 public class MpClientInvocation extends ClientInvocation {
 
     public static final String CONTAINER_HEADERS = ""MP_CLIENT_CONTAINER_HEADERS"";
 
     private MultivaluedMap<String, String> containerHeaders;
+    private List<AsyncInvocationInterceptor> asyncInvocationInterceptors;
 
-    protected MpClientInvocation(final ClientInvocation clientInvocation) {
+    private ExecutorService invocationExecutor;
+
+    protected MpClientInvocation(final ClientInvocation clientInvocation,
+                                 final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) {
         super(clientInvocation);
         captureContainerHeaders();
+        captureContext(asyncInterceptorFactories);
     }
 
-    protected MpClientInvocation(final ResteasyClient client, final URI uri, final ClientRequestHeaders headers, final ClientConfiguration parent) {
+   protected MpClientInvocation(final ResteasyClient client, final URI uri, final ClientRequestHeaders headers, final ClientConfiguration parent,
+                                 final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) {
         super(client, uri, headers, parent);
         captureContainerHeaders();
-    }
+        captureContext(asyncInterceptorFactories);
+   }
+
+   private void captureContext(List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories)
+   {
+      if(asyncInterceptorFactories != null) {
+         asyncInvocationInterceptors = asyncInterceptorFactories.stream().map(AsyncInvocationInterceptorFactory::newInterceptor).collect(Collectors.toList());
+         asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::prepareContext);
+         invocationExecutor = new ExecutorServiceWrapper(client.asyncInvocationExecutor(), new Decorator(asyncInvocationInterceptors));
+      } else {
+         invocationExecutor = client.asyncInvocationExecutor();
+      }
+   }
+
+   @Override
+   public ExecutorService asyncInvocationExecutor() {
+      return invocationExecutor;
+   }
 
     private void captureContainerHeaders() {
         HttpHeaders containerHeaders = ResteasyContext.getContextData(HttpHeaders.class);
@@ -44,4 +74,45 @@ protected ClientResponse filterRequest(ClientRequestContextImpl requestContext)
         }
         return super.filterRequest(requestContext);
     }
+
+    public static class Decorator implements ExecutorServiceWrapper.Decorator {
+
+       private List<AsyncInvocationInterceptor> asyncInvocationInterceptors;
+
+       public Decorator(final List<AsyncInvocationInterceptor> asyncInvocationInterceptors) {
+           this.asyncInvocationInterceptors = asyncInvocationInterceptors;
+       }
+
+        @Override
+        public Runnable decorate(Runnable runnable) {
+            return () -> {
+                if (asyncInvocationInterceptors != null) {
+                    asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::applyContext);
+                }
+                try {
+                   runnable.run();
+                } finally {
+                   if (asyncInvocationInterceptors != null) {
+                      asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::removeContext);
+                   }
+                }
+            };
+        }
+
+        @Override
+        public <V> Callable<V> decorate(Callable<V> callable) {
+            return () -> {
+                if (asyncInvocationInterceptors != null) {
+                    asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::applyContext);
+                }
+                try {
+                   return callable.call();
+                } finally {
+                   if (asyncInvocationInterceptors != null) {
+                      asyncInvocationInterceptors.forEach(AsyncInvocationInterceptor::removeContext);
+                   }
+                }
+            };
+        }
+    }
 }",2020-04-23T12:58:15Z,321
"@@ -1,7 +1,9 @@
 package org.jboss.resteasy.microprofile.client.impl;
 
 import java.net.URI;
+import java.util.List;
 
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
@@ -11,18 +13,22 @@
 
 public class MpClientInvocationBuilder extends ClientInvocationBuilder {
 
-    public MpClientInvocationBuilder(final ResteasyClient client, final URI uri, final ClientConfiguration configuration) {
+   private List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories;
+
+   public MpClientInvocationBuilder(final ResteasyClient client, final URI uri, final ClientConfiguration configuration,
+                                     final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) {
         super(client, uri, configuration);
+        this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
     @Override
     protected ClientInvocation createClientInvocation(ClientInvocation invocation) {
-        return new MpClientInvocation(invocation);
+        return new MpClientInvocation(invocation, asyncInterceptorFactories);
     }
 
     @Override
     protected ClientInvocation createClientInvocation(ResteasyClient client, URI uri, ClientRequestHeaders headers,
                                                       ClientConfiguration parent) {
-        return new MpClientInvocation(client, uri, headers, parent);
+        return new MpClientInvocation(client, uri, headers, parent, asyncInterceptorFactories);
     }
 }",2020-04-23T12:58:15Z,322
"@@ -1,43 +1,55 @@
 package org.jboss.resteasy.microprofile.client.impl;
 
 import java.net.URI;
+import java.util.List;
 
 import javax.ws.rs.core.UriBuilder;
 
+import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
 import org.jboss.resteasy.client.jaxrs.internal.ClientWebTarget;
 
 public class MpClientWebTarget extends ClientWebTarget {
 
-    protected MpClientWebTarget(final ResteasyClient client, final ClientConfiguration configuration)
+   private List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories;
+
+   protected MpClientWebTarget(final ResteasyClient client, final ClientConfiguration configuration,
+                                final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories)
     {
         super(client, configuration);
+        this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
-    public MpClientWebTarget(final ResteasyClient client, final String uri, final ClientConfiguration configuration) throws IllegalArgumentException, NullPointerException
+    public MpClientWebTarget(final ResteasyClient client, final String uri, final ClientConfiguration configuration,
+                             final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) throws IllegalArgumentException, NullPointerException
     {
        super(client, uri, configuration);
+       this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
-    public MpClientWebTarget(final ResteasyClient client, final URI uri, final ClientConfiguration configuration) throws NullPointerException
+    public MpClientWebTarget(final ResteasyClient client, final URI uri, final ClientConfiguration configuration,
+                             final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) throws NullPointerException
     {
        super(client, uri, configuration);
+       this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
-    public MpClientWebTarget(final ResteasyClient client, final UriBuilder uriBuilder, final ClientConfiguration configuration) throws NullPointerException
+    public MpClientWebTarget(final ResteasyClient client, final UriBuilder uriBuilder, final ClientConfiguration configuration,
+                             final List<AsyncInvocationInterceptorFactory> asyncInterceptorFactories) throws NullPointerException
     {
        super(client, uriBuilder, configuration);
+       this.asyncInterceptorFactories = asyncInterceptorFactories;
     }
 
     @Override
     protected ClientWebTarget newInstance(ResteasyClient client, UriBuilder uriBuilder, ClientConfiguration configuration) {
-        return new MpClientWebTarget(client, uriBuilder, configuration);
+        return new MpClientWebTarget(client, uriBuilder, configuration, asyncInterceptorFactories);
     }
 
     @Override
     protected ClientInvocationBuilder createClientInvocationBuilder(ResteasyClient client, URI uri, ClientConfiguration configuration) {
-        return new MpClientInvocationBuilder(client, uri, configuration);
+        return new MpClientInvocationBuilder(client, uri, configuration, asyncInterceptorFactories);
     }
 }",2020-04-23T12:58:15Z,323
"@@ -560,14 +560,18 @@ private <T> Future<T> doSubmit(boolean buffered, InvocationCallback<T> callback,
       }
       else
       {
-         return executorSubmit(client.asyncInvocationExecutor(), callback, extractor);
+         return executorSubmit(asyncInvocationExecutor(), callback, extractor);
       }
    }
 
+   public ExecutorService asyncInvocationExecutor() {
+       return client.asyncInvocationExecutor();
+   }
+
    private <T> Function<ResultExtractor<T>, CompletableFuture<T>> getCompletableFutureExtractorFunction(boolean buffered) {
       final ClientHttpEngine httpEngine = client.httpEngine();
       return (httpEngine instanceof AsyncClientHttpEngine)
-            ? ext -> ((AsyncClientHttpEngine) httpEngine).submit(this, buffered, ext, client.asyncInvocationExecutor()) : null;
+            ? ext -> ((AsyncClientHttpEngine) httpEngine).submit(this, buffered, ext, asyncInvocationExecutor()) : null;
    }
 
    private <T> Function<ResultExtractor<T>, Future<T>> getFutureExtractorFunction(boolean buffered, InvocationCallback<T> callback) {
@@ -639,7 +643,7 @@ private <T> CompletableFuture<T> doSubmit(ResultExtractor<T> extractor, boolean
       }
       else
       {
-         return executorSubmit(client.asyncInvocationExecutor(), null, extractor);
+         return executorSubmit(asyncInvocationExecutor(), null, extractor);
       }
    }
 
@@ -758,6 +762,7 @@ private <T> CompletableFuture<T> executorSubmit(ExecutorService executor, final
          final ResultExtractor<T> extractor)
    {
       return CompletableFuture.supplyAsync(() -> {
+          // FIXME: why does this have no context?
          // ensure the future and the callback see the same result
          ClientResponse response = null;
          try",2020-04-23T12:58:15Z,12
"@@ -355,7 +355,7 @@ public void setChunked(boolean chunked)
    @Override
    public CompletionStageRxInvoker rx()
    {
-      return new CompletionStageRxInvokerImpl(this, invocation.getClient().asyncInvocationExecutor());
+      return new CompletionStageRxInvokerImpl(this, invocation.asyncInvocationExecutor());
    }
 
    @Override
@@ -365,7 +365,7 @@ public <T extends RxInvoker> T rx(Class<T> clazz)
       if (provider == null) {
          throw new IllegalStateException(Messages.MESSAGES.unableToInstantiate(clazz));
       }
-      return provider.getRxInvoker(this, invocation.getClient().asyncInvocationExecutor());
+      return provider.getRxInvoker(this, invocation.asyncInvocationExecutor());
    }
 
    public Response patch(Entity<?> entity)",2020-04-23T12:58:15Z,12
"@@ -121,7 +121,7 @@ protected Object invokeAsync(final Object[] args)
       ExecutorService executor = webTarget.getResteasyClient().getScheduledExecutor();
       if (executor == null)
       {
-         executor = webTarget.getResteasyClient().asyncInvocationExecutor();
+         executor = request.asyncInvocationExecutor();
       }
       RxInvoker<?> rxInvoker = (RxInvoker<?>) rxInvokerProvider.getRxInvoker(builder, executor);
       Type type = method.getGenericReturnType();",2020-04-23T12:58:15Z,324
"@@ -7,6 +7,7 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -16,23 +17,24 @@
 public class AbstractMultipartFormDataWriter extends AbstractMultipartWriter {
 	@Override
 	protected void writeParts(MultipartOutput multipartOutput,
-			OutputStream entityStream, byte[] boundaryBytes) throws IOException {
+									  OutputStream entityStream, byte[] boundaryBytes) throws IOException {
 		if (!(multipartOutput instanceof MultipartFormDataOutput))
-		   throw new IllegalArgumentException(Messages.MESSAGES.hadToWriteMultipartOutput(multipartOutput, this, MultipartFormDataOutput.class));
+			throw new IllegalArgumentException(Messages.MESSAGES.hadToWriteMultipartOutput(multipartOutput, this, MultipartFormDataOutput.class));
 		MultipartFormDataOutput form = (MultipartFormDataOutput) multipartOutput;
-		for (Map.Entry<String, OutputPart> entry : form.getFormData()
-				.entrySet()) {
-			if (entry.getValue().getEntity() == null)
-				continue;
-			MultivaluedMap<String, Object> headers = new MultivaluedMapImpl<String, Object>();
-			headers.putSingle(""Content-Disposition"", ""form-data; name=\""""
-					+ entry.getKey() + ""\""""
-					+ getFilename(entry.getValue()));
-			writePart(entityStream, boundaryBytes, entry.getValue(), headers);
+		for (Map.Entry<String, List<OutputPart>> entry : form.getFormDataMap().entrySet()) {
+			for (OutputPart outputPart : entry.getValue()) {
+				if (outputPart.getEntity() == null) {
+					continue;
+				}
+				MultivaluedMap<String, Object> headers = new MultivaluedMapImpl<String, Object>();
+				headers.putSingle(""Content-Disposition"", ""form-data; name=\""""
+						+ entry.getKey() + ""\""""
+						+ getFilename(outputPart));
+				writePart(entityStream, boundaryBytes, outputPart, headers);
+			}
 		}
-
 	}
-	
+
 	private String getFilename(OutputPart part) {
 		String filename = part.getFilename(); 
 		if (filename == null) {",2017-12-13T21:36:10Z,325
"@@ -3,7 +3,10 @@
 import javax.ws.rs.core.GenericType;
 import javax.ws.rs.core.MediaType;
 import java.lang.reflect.Type;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -13,46 +16,66 @@
 public class MultipartFormDataOutput extends MultipartOutput
 {
    protected Map<String, OutputPart> formData = new LinkedHashMap<String, OutputPart>();
+   protected Map<String, List<OutputPart>> formDataMap = new HashMap<String, List<OutputPart>>();
+
+   private void addFormDataMap(String key, OutputPart part) {
+      List<OutputPart> list = getFormDataMap().get(key);
+      if (list == null) {
+         list = new LinkedList<OutputPart>();
+         formDataMap.put(key, list);
+      }
+      list.add(part);
+   }
+
+   public Map<String, List<OutputPart>> getFormDataMap() {
+      return formDataMap;
+   }
 
    public OutputPart addFormData(String key, Object entity, MediaType mediaType)
    {
       OutputPart part = super.addPart(entity, mediaType);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }
    
    public OutputPart addFormData(String key, Object entity, MediaType mediaType, String filename)
    {
       OutputPart part = super.addPart(entity, mediaType, filename);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }   
 
    public OutputPart addFormData(String key, Object entity, GenericType<?> type, MediaType mediaType)
    {
       OutputPart part = super.addPart(entity, type, mediaType);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }
    
    public OutputPart addFormData(String key, Object entity, GenericType<?> type, MediaType mediaType, String filename)
    {
       OutputPart part = super.addPart(entity, type, mediaType, filename);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }   
 
    public OutputPart addFormData(String key, Object entity, Class<?> type, Type genericType, MediaType mediaType)
    {
       OutputPart part = super.addPart(entity, type, genericType, mediaType);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }
    
    public OutputPart addFormData(String key, Object entity, Class<?> type, Type genericType, MediaType mediaType, String filename)
    {
       OutputPart part = super.addPart(entity, type, genericType, mediaType, filename);
       formData.put(key, part);
+      addFormDataMap(key, part);
       return part;
    }   
 ",2017-12-13T21:36:10Z,326
"@@ -84,10 +84,12 @@ public void testGetFormData() throws Exception {
 
         // Get parts by name.
         ContextProvidersCustomer c = entity.getFormDataPart(""bill"", ContextProvidersCustomer.class, null);
-        Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bill"", c.getName());
+        Assert.assertTrue(RESPONSE_ERROR_MSG, c.getName().startsWith(""Bill""));
         String s = entity.getFormDataPart(""bob"", String.class, null);
         Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bob"", s);
 
+        Assert.assertTrue(RESPONSE_ERROR_MSG, 2 == entity.getFormDataMap().get(""bill"").size());
+
         // Iterate over list of parts.
         Map<String, List<InputPart>> map = entity.getFormDataMap();
         for (Iterator<String> it = map.keySet().iterator(); it.hasNext(); ) {
@@ -97,7 +99,7 @@ public void testGetFormData() throws Exception {
                 InputPart inputPart = it2.next();
                 if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
                     c = inputPart.getBody(ContextProvidersCustomer.class, null);
-                    Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bill"", c.getName());
+                    Assert.assertTrue(RESPONSE_ERROR_MSG, c.getName().startsWith(""Bill""));
                 } else {
                     s = inputPart.getBody(String.class, null);
                     Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bob"", s);",2017-12-13T21:36:10Z,327
"@@ -42,8 +42,9 @@ public MultipartOutput getMixed() {
     @Path(""get/form"")
     public MultipartFormDataOutput getForm() {
         MultipartFormDataOutput output = new MultipartFormDataOutput();
-        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill""), MediaType.APPLICATION_XML_TYPE, ""tmp1"");
+        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill-2""), MediaType.APPLICATION_XML_TYPE, ""tmp2"");
         output.addFormData(""bob"", ""Bob"", MediaType.TEXT_PLAIN_TYPE);
+        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill""), MediaType.APPLICATION_XML_TYPE, ""tmp1"");
         return output;
     }
 ",2017-12-13T21:36:10Z,328
"@@ -84,10 +84,12 @@ public void testGetFormData() throws Exception {
 
         // Get parts by name.
         ContextProvidersCustomer c = entity.getFormDataPart(""bill"", ContextProvidersCustomer.class, null);
-        Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bill"", c.getName());
+        Assert.assertTrue(RESPONSE_ERROR_MSG, c.getName().startsWith(""Bill""));
         String s = entity.getFormDataPart(""bob"", String.class, null);
         Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bob"", s);
 
+        Assert.assertTrue(RESPONSE_ERROR_MSG, 2 == entity.getFormDataMap().get(""bill"").size());
+
         // Iterate over list of parts.
         Map<String, List<InputPart>> map = entity.getFormDataMap();
         for (Iterator<String> it = map.keySet().iterator(); it.hasNext(); ) {
@@ -97,7 +99,7 @@ public void testGetFormData() throws Exception {
                 InputPart inputPart = it2.next();
                 if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
                     c = inputPart.getBody(ContextProvidersCustomer.class, null);
-                    Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bill"", c.getName());
+                    Assert.assertTrue(RESPONSE_ERROR_MSG, c.getName().startsWith(""Bill""));
                 } else {
                     s = inputPart.getBody(String.class, null);
                     Assert.assertEquals(RESPONSE_ERROR_MSG, ""Bob"", s);",2017-12-13T21:36:10Z,329
"@@ -42,8 +42,9 @@ public MultipartOutput getMixed() {
     @Path(""get/form"")
     public MultipartFormDataOutput getForm() {
         MultipartFormDataOutput output = new MultipartFormDataOutput();
-        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill""), MediaType.APPLICATION_XML_TYPE, ""tmp1"");
+        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill-2""), MediaType.APPLICATION_XML_TYPE, ""tmp2"");
         output.addFormData(""bob"", ""Bob"", MediaType.TEXT_PLAIN_TYPE);
+        output.addFormData(""bill"", new ContextProvidersCustomer(""Bill""), MediaType.APPLICATION_XML_TYPE, ""tmp1"");
         return output;
     }
 ",2017-12-13T21:36:10Z,330
"@@ -51,7 +51,7 @@ public class Mime4JWorkaround {
     public static Message parseMessage(InputStream is) throws IOException, MimeIOException {
         try {
             MessageImpl message = new MessageImpl();
-            MimeConfig cfg = new MimeConfig();
+            MimeConfig cfg = MimeConfig.DEFAULT;
             boolean strict = cfg.isStrictParsing();
             DecodeMonitor mon = strict ? DecodeMonitor.STRICT : DecodeMonitor.SILENT;
             BodyDescriptorBuilder bdb = new DefaultBodyDescriptorBuilder(null, strict ? DefaultFieldParser.getParser() : LenientFieldParser.getParser(), mon);",2020-05-04T16:47:42Z,241
"@@ -46,7 +46,7 @@
         <version.org.apache.httpcomponents.httpclient>4.5.10</version.org.apache.httpcomponents.httpclient>
         <version.org.apache.httpcomponents.httpcore>4.4.12</version.org.apache.httpcomponents.httpcore>
         <version.org.apache.httpcomponents.httpasyncclient>4.1.4</version.org.apache.httpcomponents.httpasyncclient>
-        <version.org.apache.james.apache-mime4j>0.7.2</version.org.apache.james.apache-mime4j>
+        <version.org.apache.james.apache-mime4j>0.8.3</version.org.apache.james.apache-mime4j>
         <version.org.apache.maven>3.3.9</version.org.apache.maven> <!-- Used to download aether-provider -->
         <version.org.bouncycastle>1.64</version.org.bouncycastle>
         <version.org.eclipse.aether>1.1.0</version.org.eclipse.aether>",2020-05-04T16:47:42Z,247
"@@ -0,0 +1,138 @@
+package org.jboss.resteasy.test.internal;
+
+import java.io.ByteArrayOutputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.AsyncInvoker;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation.Builder;
+import javax.ws.rs.core.MediaType;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
+import org.jboss.resteasy.core.Dispatcher;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class ClientInvocationBuilderTest {
+
+	protected static ResteasyDeployment deployment;
+	protected static Dispatcher dispatcher;
+	protected static ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+	@Path(""/"")
+	public static class TestResource {
+		@POST
+		@Produces(""text/plain"")
+		public String post(String s) {
+			System.out.println(""server entity: "" + s);
+			return s;
+		}
+
+		@GET
+		@Produces(""text/plain"")
+		public String get() {
+			String s = ""default"";
+			System.out.println(""server entity: "" + s);
+			return s;
+		}
+	}
+
+	@BeforeClass
+	public static void before() throws Exception {
+		deployment = EmbeddedContainer.start();
+		dispatcher = deployment.getDispatcher();
+		deployment.getRegistry().addPerRequestResource(TestResource.class);
+	}
+
+	@AfterClass
+	public static void after() throws Exception {
+		EmbeddedContainer.stop();
+		dispatcher = null;
+		deployment = null;
+	}
+
+	@Test
+	public void test_build_method_return_new_instance() {
+		ResteasyClient client = new ResteasyClientBuilder().build();
+		try {
+			ResteasyWebTarget webTarget = client.target(""http://localhost:8081"");
+			Builder invocationBuilder = webTarget.request();
+
+			// GET invocation
+			ClientInvocation getInvocation = (ClientInvocation) invocationBuilder.accept(MediaType.TEXT_PLAIN_TYPE)
+					.build(""GET"");
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+
+			// Alter invocationBuilder
+			invocationBuilder.accept(MediaType.APPLICATION_XML_TYPE);
+			invocationBuilder.property(""property1"", ""property1Value"");
+			// Previously built getInvocation must not have been altered.(Those
+			// tests are not about immutability of
+			// getInvocation instance but about Builder pattern behavior).
+			Assert.assertFalse(getInvocation.getHeaders().getAcceptableMediaTypes()
+					.contains(MediaType.APPLICATION_XML_TYPE));
+			Assert.assertFalse(getInvocation.getConfiguration().getProperties().containsKey(""property1""));
+
+			// POST invocation
+			ClientInvocation postInvocation = (ClientInvocation) invocationBuilder.accept(MediaType.TEXT_PLAIN_TYPE)
+					.build(""POST"", Entity.text(""test""));
+			// Previous lines must build a new postInvocation instance and not
+			// modify previously built getInvocation instance.
+			// (It's all about Builder pattern behavior not immutability since
+			// Invocation is a mutable object.)
+			Assert.assertNotSame(getInvocation, postInvocation);
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+			Assert.assertTrue(postInvocation.getConfiguration().getProperties().containsKey(""property1""));
+			Assert.assertEquals(""test"", postInvocation.invoke(String.class));
+		} finally {
+			client.close();
+		}
+	}
+
+	@Test
+	public void test_build_method_reset_entity() throws InterruptedException, ExecutionException {
+		ResteasyClient client = new ResteasyClientBuilder().build();
+		try {
+			ResteasyWebTarget webTarget = client.target(""http://localhost:8081"");
+			Builder invocationBuilder = webTarget.request().accept(MediaType.TEXT_PLAIN_TYPE);
+
+			// POST invocation
+			ClientInvocation postInvocation = (ClientInvocation) invocationBuilder.build(""POST"", Entity.text(""test""));
+			Assert.assertEquals(""test"", postInvocation.invoke(String.class));
+
+			// GET invocation
+			ClientInvocation getInvocation = (ClientInvocation) invocationBuilder.build(""GET"");
+			// In order the request to be OK, invocation instance built from
+			// invocationBuilder must not contain the previous entity used for
+			// post request.
+			Assert.assertNull(getInvocation.getEntity());
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+			
+			//Same test for async request
+			AsyncInvoker async = invocationBuilder.async();
+			
+			// POST invocation
+			Future<String> postFuture = async.post(Entity.text(""test""), String.class);
+			Assert.assertEquals(""test"",postFuture.get());
+			
+			// GET invocation
+			Future<String> getFuture = async.get(String.class);
+			Assert.assertEquals(""default"",getFuture.get());
+		} finally {
+			client.close();
+		}
+	}
+
+}",2016-09-30T07:48:48Z,331
"@@ -24,219 +24,189 @@ public AsynchronousInvoke(ClientInvocation invocation)
    @Override
    public Future<Response> get()
    {
-      invocation.setMethod(HttpMethod.GET);
-      return invocation.submit();
+      return method(HttpMethod.GET);
    }
 
    @Override
    public <T> Future<T> get(Class<T> responseType)
    {
-      invocation.setMethod(HttpMethod.GET);
-      return invocation.submit(responseType);
+      return method(HttpMethod.GET, responseType);
    }
 
    @Override
    public <T> Future<T> get(GenericType<T> responseType)
    {
-      invocation.setMethod(HttpMethod.GET);
-      return invocation.submit(responseType);
+      return method(HttpMethod.GET, responseType);
    }
 
    @Override
    public <T> Future<T> get(InvocationCallback<T> callback)
    {
-      invocation.setMethod(HttpMethod.GET);
-      return invocation.submit(callback);
+      return method(HttpMethod.GET, callback);
    }
 
    @Override
    public Future<Response> trace()
    {
-      invocation.setMethod(""TRACE"");
-      return invocation.submit();
+      return method(""TRACE"");
    }
 
    @Override
    public <T> Future<T> trace(Class<T> responseType)
    {
-      invocation.setMethod(""TRACE"");
-      return invocation.submit(responseType);
+      return method(""TRACE"", responseType);
    }
 
    @Override
    public <T> Future<T> trace(GenericType<T> responseType)
    {
-      invocation.setMethod(""TRACE"");
-      return invocation.submit(responseType);
+      return method(""TRACE"", responseType);
    }
 
    @Override
    public <T> Future<T> trace(InvocationCallback<T> callback)
    {
-      invocation.setMethod(""TRACE"");
-      return invocation.submit(callback);
+      return method(""TRACE"", callback);
    }
 
    @Override
    public Future<Response> put(Entity<?> entity)
    {
-      invocation.setMethod(HttpMethod.PUT);
-      invocation.setEntity(entity);
-      return invocation.submit();
+      return method(HttpMethod.PUT, entity);
    }
 
    @Override
    public <T> Future<T> put(Entity<?> entity, Class<T> responseType)
    {
-      invocation.setMethod(HttpMethod.PUT);
-      invocation.setEntity(entity);
-      return invocation.submit(responseType);
+      return method(HttpMethod.PUT, entity, responseType);
    }
 
    @Override
    public <T> Future<T> put(Entity<?> entity, GenericType<T> responseType)
    {
-      invocation.setMethod(HttpMethod.PUT);
-      invocation.setEntity(entity);
-      return invocation.submit(responseType);
+      return method(HttpMethod.PUT, entity, responseType);
    }
 
    @Override
    public <T> Future<T> put(Entity<?> entity, InvocationCallback<T> callback)
    {
-      invocation.setMethod(HttpMethod.PUT);
-      invocation.setEntity(entity);
-      return invocation.submit(callback);
+      return method(HttpMethod.PUT, entity, callback);
    }
 
    @Override
    public Future<Response> post(Entity<?> entity)
    {
-      invocation.setMethod(HttpMethod.POST);
-      invocation.setEntity(entity);
-      return invocation.submit();
+      return method(HttpMethod.POST, entity);
    }
 
    @Override
    public <T> Future<T> post(Entity<?> entity, Class<T> responseType)
    {
-      invocation.setMethod(HttpMethod.POST);
-      invocation.setEntity(entity);
-      return invocation.submit(responseType);
+      return method(HttpMethod.POST, entity, responseType);
    }
 
    @Override
    public <T> Future<T> post(Entity<?> entity, GenericType<T> responseType)
    {
-      invocation.setMethod(HttpMethod.POST);
-      invocation.setEntity(entity);
-      return invocation.submit(responseType);
+      return method(HttpMethod.POST, entity, responseType);
    }
 
    @Override
    public <T> Future<T> post(Entity<?> entity, InvocationCallback<T> callback)
    {
-      invocation.setMethod(HttpMethod.POST);
-      invocation.setEntity(entity);
-      return invocation.submit(callback);
+      return method(HttpMethod.POST, entity, callback);
    }
 
    @Override
    public Future<Response> delete()
    {
-      invocation.setMethod(HttpMethod.DELETE);
-      return invocation.submit();
+      return method(HttpMethod.DELETE);
    }
 
    @Override
    public <T> Future<T> delete(Class<T> responseType)
    {
-      invocation.setMethod(HttpMethod.DELETE);
-      return invocation.submit(responseType);
+      return method(HttpMethod.DELETE, responseType);
    }
 
    @Override
    public <T> Future<T> delete(GenericType<T> responseType)
    {
-      invocation.setMethod(HttpMethod.DELETE);
-      return invocation.submit(responseType);
+      return method(HttpMethod.DELETE, responseType);
    }
 
    @Override
    public <T> Future<T> delete(InvocationCallback<T> callback)
    {
-      invocation.setMethod(HttpMethod.DELETE);
-      return invocation.submit(callback);
+      return method(HttpMethod.DELETE, callback);
    }
 
    @Override
    public Future<Response> head()
    {
-      invocation.setMethod(HttpMethod.HEAD);
-      return invocation.submit();
+      return method(HttpMethod.HEAD);
    }
 
    @Override
    public Future<Response> head(InvocationCallback<Response> callback)
    {
-      invocation.setMethod(HttpMethod.HEAD);
-      return invocation.submit(callback);
+      return method(HttpMethod.HEAD,callback);
    }
 
    @Override
    public Future<Response> options()
    {
-      invocation.setMethod(HttpMethod.OPTIONS);
-      return invocation.submit();
+      return method(HttpMethod.OPTIONS);
    }
 
    @Override
    public <T> Future<T> options(Class<T> responseType)
    {
-      invocation.setMethod(HttpMethod.OPTIONS);
-      return invocation.submit(responseType);
+      return method(HttpMethod.OPTIONS, responseType);
    }
 
    @Override
    public <T> Future<T> options(GenericType<T> responseType)
    {
-      invocation.setMethod(HttpMethod.OPTIONS);
-      return invocation.submit(responseType);
+      return method(HttpMethod.OPTIONS, responseType);
    }
 
    @Override
    public <T> Future<T> options(InvocationCallback<T> callback)
    {
-      invocation.setMethod(HttpMethod.OPTIONS);
-      return invocation.submit(callback);
+      return method(HttpMethod.OPTIONS, callback);
    }
 
 
    @Override
    public Future<Response> method(String name)
    {
       invocation.setMethod(name);
+      invocation.setEntity(null);
       return invocation.submit();
    }
 
    @Override
    public <T> Future<T> method(String name, Class<T> responseType)
    {
       invocation.setMethod(name);
+      invocation.setEntity(null);
       return invocation.submit(responseType);
    }
 
    @Override
    public <T> Future<T> method(String name, GenericType<T> responseType)
    {
       invocation.setMethod(name);
+      invocation.setEntity(null);
       return invocation.submit(responseType);
    }
 
    @Override
    public <T> Future<T> method(String name, InvocationCallback<T> callback)
    {
       invocation.setMethod(name);
+      invocation.setEntity(null);
       return invocation.submit(callback);
    }
 ",2016-09-30T07:48:48Z,24
"@@ -3,6 +3,7 @@
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.core.interception.AbstractWriterInterceptorContext;
 import org.jboss.resteasy.core.interception.ClientWriterInterceptorContext;
+import org.jboss.resteasy.specimpl.MultivaluedTreeMap;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.jboss.resteasy.util.DelegatingOutputStream;
 import org.jboss.resteasy.util.Types;
@@ -34,14 +35,18 @@
 import javax.ws.rs.core.Variant;
 import javax.ws.rs.ext.Providers;
 import javax.ws.rs.ext.WriterInterceptor;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.Reader;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 
@@ -75,6 +80,20 @@ public ClientInvocation(ResteasyClient client, URI uri, ClientRequestHeaders hea
       this.configuration = new ClientConfiguration(parent);
       this.headers = headers;
    }
+   
+   ClientInvocation(ClientInvocation clientInvocation)
+   {
+      this.client = clientInvocation.client;
+      this.configuration = new ClientConfiguration(clientInvocation.configuration);
+      this.headers =  new ClientRequestHeaders(this.configuration);
+      MultivaluedTreeMap.copy(clientInvocation.headers.getHeaders(), this.headers.headers);
+      this.method = clientInvocation.method;
+      this.entity = clientInvocation.entity;
+      this.entityGenericType = clientInvocation.entityGenericType;
+      this.entityClass = clientInvocation.entityClass;
+      this.entityAnnotations = clientInvocation.entityAnnotations;
+      this.uri = clientInvocation.uri;
+   }
 
    /**
     * Extracts result from response throwing an appropriate exception if not a successful response.",2016-09-30T07:48:48Z,12
"@@ -21,18 +21,13 @@
  */
 public class ClientInvocationBuilder implements Invocation.Builder
 {
-   protected ClientInvocation invocation;
+   private final ClientInvocation invocation;
 
    public ClientInvocationBuilder(ResteasyClient client, URI uri, ClientConfiguration configuration)
    {
       invocation = new ClientInvocation(client, uri, new ClientRequestHeaders(configuration), configuration);
    }
 
-   public ClientInvocation getInvocation()
-   {
-      return invocation;
-   }
-
    public ClientRequestHeaders getHeaders()
    {
       return invocation.headers;
@@ -115,16 +110,15 @@ public Invocation.Builder headers(MultivaluedMap<String, Object> headers)
    @Override
    public Invocation build(String method)
    {
-      invocation.setMethod(method);
-      return invocation;
+      return build(method, null);
    }
 
    @Override
    public Invocation build(String method, Entity<?> entity)
    {
       invocation.setMethod(method);
       invocation.setEntity(entity);
-      return invocation;
+      return new ClientInvocation(this.invocation);
    }
 
    @Override
@@ -154,7 +148,7 @@ public Invocation buildPut(Entity<?> entity)
    @Override
    public AsyncInvoker async()
    {
-      return new AsynchronousInvoke(invocation);
+      return new AsynchronousInvoke(new ClientInvocation(this.invocation));
    }
 
    @Override",2016-09-30T07:48:48Z,12
"@@ -86,7 +86,7 @@ public <T> ProxyBuilder<T> proxyBuilder(Class<T> proxyInterface)
    public URI getUri()
    {
       client.abortIfClosed();
-      return uriBuilder.clone().build();
+      return uriBuilder.build();
    }
 
    @Override
@@ -137,7 +137,7 @@ public ResteasyWebTarget resolveTemplate(String name, Object value) throws NullP
       if (name == null) throw new NullPointerException(Messages.MESSAGES.nameWasNull());
       if (value == null) throw new NullPointerException(Messages.MESSAGES.valueWasNull());
       String val = configuration.toString(value);
-      UriBuilder copy = uriBuilder.resolveTemplate(name, val);
+      UriBuilder copy = uriBuilder.clone().resolveTemplate(name, val);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -155,7 +155,7 @@ public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues) th
          String val = configuration.toString(entry.getValue());
          vals.put(entry.getKey(), val);
       }
-      UriBuilder copy = uriBuilder.resolveTemplates(vals);
+      UriBuilder copy = uriBuilder.clone().resolveTemplates(vals);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -167,7 +167,7 @@ public ResteasyWebTarget resolveTemplate(String name, Object value, boolean enco
       if (name == null) throw new NullPointerException(Messages.MESSAGES.nameWasNull());
       if (value == null) throw new NullPointerException(Messages.MESSAGES.valueWasNull());
       String val = configuration.toString(value);
-      UriBuilder copy = uriBuilder.resolveTemplate(name, val, encodeSlashInPath);
+      UriBuilder copy = uriBuilder.clone().resolveTemplate(name, val, encodeSlashInPath);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -179,7 +179,7 @@ public ResteasyWebTarget resolveTemplateFromEncoded(String name, Object value) t
       if (name == null) throw new NullPointerException(Messages.MESSAGES.nameWasNull());
       if (value == null) throw new NullPointerException(Messages.MESSAGES.valueWasNull());
       String val = configuration.toString(value);
-      UriBuilder copy = uriBuilder.resolveTemplateFromEncoded(name, val);
+      UriBuilder copy = uriBuilder.clone().resolveTemplateFromEncoded(name, val);
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -197,7 +197,7 @@ public ResteasyWebTarget resolveTemplatesFromEncoded(Map<String, Object> templat
          String val = configuration.toString(entry.getValue());
          vals.put(entry.getKey(), val);
       }
-      UriBuilder copy = uriBuilder.resolveTemplatesFromEncoded(vals) ;
+      UriBuilder copy = uriBuilder.clone().resolveTemplatesFromEncoded(vals) ;
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -215,7 +215,7 @@ public ResteasyWebTarget resolveTemplates(Map<String, Object> templateValues, bo
          String val = configuration.toString(entry.getValue());
          vals.put(entry.getKey(), val);
       }
-      UriBuilder copy = uriBuilder.resolveTemplates(vals, encodeSlashInPath) ;
+      UriBuilder copy = uriBuilder.clone().resolveTemplates(vals, encodeSlashInPath) ;
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       return target;
    }
@@ -233,7 +233,7 @@ public ResteasyWebTarget matrixParam(String name, Object... values) throws NullP
       else
       {
          String[] stringValues = toStringValues(values);
-         copy = uriBuilder.clone().matrixParam(name, stringValues);
+         copy.matrixParam(name, stringValues);
       }
       return new ClientWebTarget(client, copy, configuration);
    }
@@ -261,7 +261,7 @@ public ResteasyWebTarget queryParam(String name, Object... values) throws NullPo
       else
       {
          String[] stringValues = toStringValues(values);
-         copy = uriBuilder.clone().queryParam(name, stringValues);
+         copy.queryParam(name, stringValues);
       }
       return new ClientWebTarget(client, copy, configuration);
    }
@@ -408,4 +408,4 @@ public ResteasyWebTarget register(Object component, Map<Class<?>, Integer> contr
       configuration.register(component, contracts);
       return this;
    }
-}
+}
\ No newline at end of file",2016-09-30T07:48:48Z,286
"@@ -5,6 +5,7 @@
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientRequestHeaders;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.extractors.ClientContext;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.extractors.DefaultEntityExtractorFactory;
@@ -19,7 +20,9 @@
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.container.DynamicFeature;
 import javax.ws.rs.container.ResourceInfo;
+import javax.ws.rs.core.Configuration;
 import javax.ws.rs.core.MediaType;
+
 import java.lang.reflect.Method;
 
 /**
@@ -106,7 +109,7 @@ public Object invoke(Object[] args)
 
    protected ClientInvocation createRequest(Object[] args)
    {
-      WebTarget target = this.webTarget;
+	  WebTarget target = this.webTarget;
       for (int i = 0; i < processors.length; i++)
       {
          if (processors != null && processors[i] instanceof WebTargetProcessor)
@@ -117,26 +120,24 @@ protected ClientInvocation createRequest(Object[] args)
          }
       }
 
-      ClientInvocationBuilder builder = null;
+      ClientConfiguration parentConfiguration=(ClientConfiguration) target.getConfiguration();
+      ClientInvocation clientInvocation = new ClientInvocation(this.webTarget.getResteasyClient(), target.getUri(),
+    		  new ClientRequestHeaders(parentConfiguration), parentConfiguration);
       if (accepts != null)
       {
-         builder = (ClientInvocationBuilder)target.request(accepts);
+         clientInvocation.getHeaders().accept(accepts);
       }
-      else
-      {
-         builder = (ClientInvocationBuilder)target.request();
-      }
-
       for (int i = 0; i < processors.length; i++)
       {
          if (processors != null && processors[i] instanceof InvocationProcessor)
          {
             InvocationProcessor processor = (InvocationProcessor)processors[i];
-            processor.process(builder, args[i]);
+            processor.process(clientInvocation, args[i]);
 
          }
       }
-      return (ClientInvocation)builder.build(httpMethod);
+      clientInvocation.setMethod(httpMethod);
+      return clientInvocation;
    }
 
    public String getHttpMethod()",2016-09-30T07:48:48Z,324
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors;
 
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.spi.LoggableFailure;
 
 import javax.ws.rs.client.WebTarget;
@@ -209,13 +209,13 @@ public Object process(Object target, Object value, Object processor)
    }
 
    @Override
-   public void process(ClientInvocationBuilder invocation, Object param)
+   public void process(ClientInvocation invocation, Object param)
    {
       process(new Process()  {
          @Override
          public Object process(Object target, Object value, Object processor)
          {
-            processParam((ClientInvocationBuilder)target, value, processor);
+            processParam((ClientInvocation)target, value, processor);
             return target;
          }
       }, invocation, param);
@@ -271,7 +271,7 @@ private WebTarget build(WebTarget target, Object val, Object proc)
       return target;
    }
 
-   private void processParam(ClientInvocationBuilder invocation, Object val, Object proc)
+   private void processParam(ClientInvocation invocation, Object val, Object proc)
    {
       if (proc instanceof InvocationProcessor)
       {",2016-09-30T07:48:48Z,332
"@@ -1,12 +1,12 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
 public interface InvocationProcessor
 {
-   void process(ClientInvocationBuilder invocation, Object param);
+   void process(ClientInvocation invocation, Object param);
 }",2016-09-30T07:48:48Z,333
"@@ -1,22 +1,22 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.AbstractCollectionProcessor;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.InvocationProcessor;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public abstract class AbstractInvocationCollectionProcessor extends AbstractCollectionProcessor<ClientInvocationBuilder> implements InvocationProcessor
+public abstract class AbstractInvocationCollectionProcessor extends AbstractCollectionProcessor<ClientInvocation> implements InvocationProcessor
 {
    public AbstractInvocationCollectionProcessor(String paramName)
    {
       super(paramName);
    }
 
    @Override
-   public void process(ClientInvocationBuilder invocation, Object param)
+   public void process(ClientInvocation invocation, Object param)
    {
       buildIt(invocation, param);
    }",2016-09-30T07:48:48Z,334
"@@ -1,6 +1,6 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.InvocationProcessor;
 
 import javax.ws.rs.core.Cookie;
@@ -24,17 +24,17 @@ public String getCookieName()
    }
 
    @Override
-   public void process(ClientInvocationBuilder request, Object object)
+   public void process(ClientInvocation invocation, Object object)
    {
       if (object == null) return;  // don't set a null value
       if (object instanceof Cookie)
       {
          Cookie cookie = (Cookie) object;
-         request.cookie(cookie);
+         invocation.getHeaders().cookie(cookie);
       }
       else
       {
-         request.cookie(new Cookie(cookieName, request.getInvocation().getClientConfiguration().toString(object)));
+    	  invocation.getHeaders().cookie(new Cookie(cookieName, invocation.getClientConfiguration().toString(object)));
       }
    }
 }",2016-09-30T07:48:48Z,335
"@@ -1,7 +1,7 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 
 import javax.ws.rs.client.Entity;
 import javax.ws.rs.core.Form;
@@ -19,10 +19,10 @@ public FormParamProcessor(String paramName)
    }
 
    @Override
-   protected ClientInvocationBuilder apply(ClientInvocationBuilder target, Object object)
+   protected ClientInvocation apply(ClientInvocation invocation, Object object)
    {
       Form form = null;
-      Object entity = target.getInvocation().getEntity();
+      Object entity = invocation.getEntity();
       if (entity != null)
       {
          if (entity instanceof Form)
@@ -37,11 +37,11 @@ protected ClientInvocationBuilder apply(ClientInvocationBuilder target, Object o
       else
       {
          form = new Form();
-         target.getInvocation().setEntity(Entity.form(form));
+         invocation.setEntity(Entity.form(form));
       }
-      String value = target.getInvocation().getClientConfiguration().toString(object);
+      String value = invocation.getClientConfiguration().toString(object);
       form.param(paramName, value);
-      return target;
+      return invocation;
    }
 
 }
\ No newline at end of file",2016-09-30T07:48:48Z,288
"@@ -1,6 +1,6 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -15,9 +15,10 @@ public HeaderParamProcessor(String paramName)
    }
 
    @Override
-   protected ClientInvocationBuilder apply(ClientInvocationBuilder target, Object object)
+   protected ClientInvocation apply(ClientInvocation invocation, Object object)
    {
-      return (ClientInvocationBuilder)target.header(paramName, object);
+       invocation.getHeaders().header(paramName, object);
+       return invocation;
    }
 
 }
\ No newline at end of file",2016-09-30T07:48:48Z,289
"@@ -1,6 +1,6 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.InvocationProcessor;
 
 import javax.ws.rs.client.Entity;
@@ -30,9 +30,9 @@ public MessageBodyParameterProcessor(MediaType mediaType, Class<?> type, Type ge
 
    @SuppressWarnings(""unchecked"")
    @Override
-   public void process(ClientInvocationBuilder invocation, Object param)
+   public void process(ClientInvocation invocation, Object param)
    {
-      invocation.getInvocation().setEntity(Entity.entity(new GenericEntity<Object>(param, genericType), mediaType, annotations));
+      invocation.setEntity(Entity.entity(new GenericEntity<Object>(param, genericType), mediaType, annotations));
    }
 
    public Class<?> getType()",2016-09-30T07:48:48Z,336
"@@ -1,6 +1,6 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation;
 
-import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.InvocationProcessor;
 
 import java.net.URI;
@@ -17,13 +17,13 @@ public class URIParamProcessor implements InvocationProcessor
 {
 
    @Override
-   public void process(ClientInvocationBuilder invocation, Object param)
+   public void process(ClientInvocation invocation, Object param)
    {
       URI uri = getUri(param);
 
       if (uri != null)
       {
-         invocation.getInvocation().setUri(uri);
+         invocation.setUri(uri);
       }
    }
 ",2016-09-30T07:48:48Z,337
"@@ -8,23 +8,28 @@
 import org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;
 
 import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
 public class LinkBuilderImpl implements Link.Builder
 {
-   protected LinkImpl link = new LinkImpl();
+   /**
+    * A map for all the link parameters such as ""rel"", ""type"", etc.	
+    */
+   protected final Map<String, String> map = new HashMap<String, String>();
    protected UriBuilder uriBuilder;
-   protected URI baseUri = null;
+   protected URI baseUri;
 
    @Override
    public Link.Builder link(Link link)
    {
       uriBuilder = UriBuilder.fromUri(link.getUri());
-      this.link.map.clear();
-      this.link.map.putAll(link.getParams());
+      this.map.clear();
+      this.map.putAll(link.getParams());
       return this;
    }
 
@@ -59,7 +64,7 @@ public Link.Builder uri(String uri) throws IllegalArgumentException {
    @Override
    public Link.Builder rel(String rel) {
       if (rel == null) throw new IllegalArgumentException(Messages.MESSAGES.relParamNull());
-      final String rels = link.map.get(Link.REL);
+      final String rels = this.map.get(Link.REL);
       param(Link.REL, rels == null ? rel : rels + "" "" + rel);
       return this;
    }
@@ -83,16 +88,15 @@ public Link.Builder type(String type) {
    public Link.Builder param(String name, String value) throws IllegalArgumentException {
       if (name == null) throw new IllegalArgumentException(Messages.MESSAGES.nameParamWasNull());
       if (value == null) throw new IllegalArgumentException(Messages.MESSAGES.valueParamWasNull());
-      link.map.put(name, value);
+      this.map.put(name, value);
       return this;
    }
 
    @Override
    public Link build(Object... values) throws UriBuilderException
    {
       if (values == null) throw new IllegalArgumentException(Messages.MESSAGES.valuesParamWasNull());
-      link.uri = uriBuilder.build(values);
-      return link;
+      return new LinkImpl(this.uriBuilder.build(values), this.map);
    }
 
    @Override
@@ -103,8 +107,7 @@ public Link buildRelativized(URI uri, Object... values)
       URI built = uriBuilder.build(values);
       URI with = built;
       if (baseUri != null) with = baseUri.resolve(built);
-      link.uri = uri.relativize(with);
-      return link;
+      return new LinkImpl(uri.relativize(with), this.map);
    }
 
    @Override",2016-09-30T07:48:48Z,338
"@@ -16,12 +16,12 @@
  */
 public class LinkImpl extends Link
 {
-   protected URI uri;
+   protected final URI uri;
 
    /**
     * A map for all the link parameters such as ""rel"", ""type"", etc.
     */
-   protected Map<String, String> map = new HashMap<String, String>();
+   protected final Map<String, String> map;
 
    protected static final RuntimeDelegate.HeaderDelegate<Link> delegate =
            RuntimeDelegate.getInstance().createHeaderDelegate(Link.class);
@@ -30,6 +30,13 @@ public static Link valueOf(String value)
    {
       return delegate.fromString(value);
    }
+   
+   LinkImpl(URI uri, Map<String, String> map) 
+   {
+	  this.uri = uri;
+	  this.map = map.isEmpty() ? Collections.<String, String> emptyMap() : Collections
+		.unmodifiableMap(new HashMap<String, String>(map));
+	}
 
    @Override
    public URI getUri() {
@@ -64,7 +71,7 @@ public String getType() {
 
    @Override
    public Map<String, String> getParams() {
-      return new HashMap<String, String>(map);
+      return map;
    }
 
    @Override",2016-09-30T07:48:48Z,339
"@@ -1083,7 +1083,7 @@ public UriBuilder resolveTemplates(Map<String, Object> templateValues) throws Il
       if (templateValues == null) throw new IllegalArgumentException(Messages.MESSAGES.templateValuesParamNull());
       if (templateValues.containsKey(null)) throw new IllegalArgumentException(Messages.MESSAGES.mapKeyNull());
       String str = buildString(templateValues, false, true, true);
-      return fromTemplate(str);
+      return uriTemplate(str);
    }
 
    @Override
@@ -1094,7 +1094,7 @@ public UriBuilder resolveTemplate(String name, Object value, boolean encodeSlash
       HashMap<String, Object> vals = new HashMap<String, Object>();
       vals.put(name, value);
       String str = buildString(vals, false, true, encodeSlashInPath);
-      return fromTemplate(str);
+      return uriTemplate(str);
    }
 
    @Override
@@ -1105,7 +1105,7 @@ public UriBuilder resolveTemplateFromEncoded(String name, Object value) throws I
       HashMap<String, Object> vals = new HashMap<String, Object>();
       vals.put(name, value);
       String str = buildString(vals, true, true, true);
-      return fromTemplate(str);
+      return uriTemplate(str);
    }
 
    @Override
@@ -1114,7 +1114,7 @@ public UriBuilder resolveTemplates(Map<String, Object> templateValues, boolean e
       if (templateValues == null) throw new IllegalArgumentException(Messages.MESSAGES.templateValuesParamNull());
       if (templateValues.containsKey(null)) throw new IllegalArgumentException(Messages.MESSAGES.mapKeyNull());
       String str = buildString(templateValues, false, true, encodeSlashInPath);
-      return fromTemplate(str);
+      return uriTemplate(str);
    }
 
    @Override
@@ -1123,6 +1123,6 @@ public UriBuilder resolveTemplatesFromEncoded(Map<String, Object> templateValues
       if (templateValues == null) throw new IllegalArgumentException(Messages.MESSAGES.templateValuesParamNull());
       if (templateValues.containsKey(null)) throw new IllegalArgumentException(Messages.MESSAGES.mapKeyNull());
       String str = buildString(templateValues, true, true, true);
-      return fromTemplate(str);
+      return uriTemplate(str);
    }
 }",2016-09-30T07:48:48Z,67
"@@ -0,0 +1,135 @@
+package org.jboss.resteasy.test.client;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.AsyncInvoker;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation.Builder;
+import javax.ws.rs.core.MediaType;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(Arquillian.class)
+@RunAsClient
+public class ClientInvocationBuilderTest {
+
+	@Path(""/"")
+	public static class ClientInvocationBuilderResource {
+		@POST
+		@Produces(""text/plain"")
+		public String post(String s) {
+			System.out.println(""server entity: "" + s);
+			return s;
+		}
+
+		@GET
+		@Produces(""text/plain"")
+		public String get() {
+			String s = ""default"";
+			System.out.println(""server entity: "" + s);
+			return s;
+		}
+	}
+
+	@Deployment
+	public static Archive<?> deploy() {
+		WebArchive war = TestUtil.prepareArchive(ClientInvocationBuilderTest.class.getSimpleName());
+		war.addClass(ClientInvocationBuilderTest.class);
+		return TestUtil.finishContainerPrepare(war, null, ClientInvocationBuilderResource.class);
+	}
+
+	@Test
+	public void test_build_method_return_new_instance() {
+		ResteasyClient client = new ResteasyClientBuilder().build();
+		try {
+			ResteasyWebTarget webTarget = client.target(generateURL());
+			Builder invocationBuilder = webTarget.request();
+
+			// GET invocation
+			ClientInvocation getInvocation = (ClientInvocation) invocationBuilder.accept(MediaType.TEXT_PLAIN_TYPE)
+					.build(""GET"");
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+
+			// Alter invocationBuilder
+			invocationBuilder.accept(MediaType.APPLICATION_XML_TYPE);
+			invocationBuilder.property(""property1"", ""property1Value"");
+			// Previously built getInvocation must not have been altered.(Those
+			// tests are not about immutability of
+			// getInvocation instance but about Builder pattern behavior).
+			Assert.assertFalse(getInvocation.getHeaders().getAcceptableMediaTypes()
+					.contains(MediaType.APPLICATION_XML_TYPE));
+			Assert.assertFalse(getInvocation.getConfiguration().getProperties().containsKey(""property1""));
+
+			// POST invocation
+			ClientInvocation postInvocation = (ClientInvocation) invocationBuilder.accept(MediaType.TEXT_PLAIN_TYPE)
+					.build(""POST"", Entity.text(""test""));
+			// Previous lines must build a new postInvocation instance and not
+			// modify previously built getInvocation instance.
+			// (It's all about Builder pattern behavior not immutability since
+			// Invocation is a mutable object.)
+			Assert.assertNotSame(getInvocation, postInvocation);
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+			Assert.assertTrue(postInvocation.getConfiguration().getProperties().containsKey(""property1""));
+			Assert.assertEquals(""test"", postInvocation.invoke(String.class));
+		} finally {
+			client.close();
+		}
+	}
+
+	@Test
+	public void test_build_method_reset_entity() throws InterruptedException, ExecutionException {
+		ResteasyClient client = new ResteasyClientBuilder().build();
+		try {
+			ResteasyWebTarget webTarget = client.target(generateURL());
+			Builder invocationBuilder = webTarget.request().accept(MediaType.TEXT_PLAIN_TYPE);
+
+			// POST invocation
+			ClientInvocation postInvocation = (ClientInvocation) invocationBuilder.build(""POST"", Entity.text(""test""));
+			Assert.assertEquals(""test"", postInvocation.invoke(String.class));
+
+			// GET invocation
+			ClientInvocation getInvocation = (ClientInvocation) invocationBuilder.build(""GET"");
+			// In order the request to be OK, invocation instance built from
+			// invocationBuilder must not contain the previous entity used for
+			// post request.
+			Assert.assertNull(getInvocation.getEntity());
+			Assert.assertEquals(""default"", getInvocation.invoke(String.class));
+
+			// Same test for async request
+			AsyncInvoker async = invocationBuilder.async();
+
+			// POST invocation
+			Future<String> postFuture = async.post(Entity.text(""test""), String.class);
+			Assert.assertEquals(""test"", postFuture.get());
+
+			// GET invocation
+			Future<String> getFuture = async.get(String.class);
+			Assert.assertEquals(""default"", getFuture.get());
+		} finally {
+			client.close();
+		}
+	}
+
+	private String generateURL() {
+		return PortProviderUtil.generateBaseUrl(ClientInvocationBuilderTest.class.getSimpleName());
+	}
+
+}
\ No newline at end of file",2016-09-30T07:48:48Z,340
"@@ -16,6 +16,7 @@
 import org.jboss.resteasy.util.MediaTypeHelper;
 
 import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
 import javax.ws.rs.client.Entity;
 import javax.ws.rs.client.RxInvoker;
 import javax.ws.rs.client.RxInvokerProvider;
@@ -26,9 +27,11 @@
 import javax.ws.rs.core.GenericType;
 import javax.ws.rs.core.MediaType;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.HashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.Set;
 
@@ -157,13 +160,34 @@ protected Object invokeSync(Object[] args)
    protected ClientInvocation createRequest(Object[] args)
    {
       WebTarget target = this.webTarget;
-      for (int i = 0; i < processors.length; i++)
+
+      HashMap<String, Object> pathParamsMap = new HashMap<>();
+
+      for (int i = 0; i < method.getParameterTypes().length; i++)
       {
-         if (processors != null && processors[i] instanceof WebTargetProcessor)
+         Annotation[] paramAnnotations = method.getParameterAnnotations()[i];
+         for (Annotation annotation : paramAnnotations)
          {
-            WebTargetProcessor processor = (WebTargetProcessor)processors[i];
-            target = processor.build(target, args[i]);
+            if (annotation instanceof PathParam)
+            {
+               pathParamsMap.put(((PathParam) annotation).value(), args[i]);
+               break;
+            }
+         }
+      }
 
+      if (pathParamsMap.size() > 1) {
+         target = target.resolveTemplates(pathParamsMap);
+      }
+
+      if (processors != null) {
+         for (int i = 0; i < processors.length; i++)
+         {
+            if (processors[i] instanceof WebTargetProcessor)
+            {
+               WebTargetProcessor processor = (WebTargetProcessor) processors[i];
+               target = processor.build(target, args[i]);
+            }
          }
       }
       ClientInvocationBuilder builder = (ClientInvocationBuilder) target.request();
@@ -177,13 +201,14 @@ protected ClientInvocation createRequest(Object[] args)
       {
          clientInvocation.getHeaders().accept(accepts);
       }
-      for (int i = 0; i < processors.length; i++)
-      {
-         if (processors != null && processors[i] instanceof InvocationProcessor)
+      if (processors != null) {
+         for (int i = 0; i < processors.length; i++)
          {
-            InvocationProcessor processor = (InvocationProcessor)processors[i];
-            processor.process(clientInvocation, args[i]);
-
+            if (processors[i] instanceof InvocationProcessor)
+            {
+               InvocationProcessor processor = (InvocationProcessor)processors[i];
+               processor.process(clientInvocation, args[i]);
+            }
          }
       }
       return clientInvocation;",2023-02-03T01:35:07Z,324
"@@ -0,0 +1,87 @@
+package org.jboss.resteasy.test.client.proxy;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+
+import org.jboss.resteasy.test.client.proxy.resource.ProxyPathParamRegexResource;
+
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.ws.rs.Encoded;
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.MediaType;
+
+
+/**
+ * @tpSubChapter Resteasy-client
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Regression test for RESTEASY-2845
+ * @tpSince RESTEasy 4.7.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class ProxyPathParamRegexTest {
+
+    @Path("""")
+    public interface RegexInterface {
+        @GET
+        @Path(""/{path}/{string}"")
+        @Produces(MediaType.TEXT_PLAIN)
+        String getPath(@PathParam(""path"") String path, @PathParam(""string"") @Encoded String string);
+    }
+
+    static ResteasyClient client;
+
+    @Before
+    public void setUp(){
+        client = (ResteasyClient) ClientBuilder.newClient();
+    }
+
+    @After
+    public void after() throws Exception{
+        client.close();
+    }
+
+    @Deployment
+    public static Archive<?> deploy() {
+        WebArchive war = TestUtil.prepareArchive(ProxyPathParamRegexTest.class.getSimpleName());
+        return TestUtil.finishContainerPrepare(war, null, ProxyPathParamRegexResource.class);
+    }
+
+    private String generateURL() {
+        return PortProviderUtil.generateBaseUrl(ProxyPathParamRegexTest.class.getSimpleName());
+    }
+
+    /**
+     * @tpTestDetails Checks whether question mark in regular expression in second path param is correctly evaluated.
+     * @tpPassCrit Expected string is returned
+     * @tpSince RESTEasy 4.7.0
+     */
+    @Test
+    public void testQuestionMarkInMultiplePathParamRegex() {
+
+        ResteasyWebTarget target = client.target(generateURL());
+
+        ProxyPathParamRegexTest.RegexInterface proxy = target.proxy(ProxyPathParamRegexTest.RegexInterface.class);
+        String responseString = proxy.getPath(""path"", ""a"");
+
+        Assert.assertEquals(""Wrong string returned by proxy interface"", ""patha"", responseString);
+    }
+}",2023-02-03T01:35:07Z,341
"@@ -0,0 +1,21 @@
+package org.jboss.resteasy.test.client.proxy.resource;
+
+import org.jboss.resteasy.test.client.proxy.ProxyPathParamRegexTest;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.Encoded;
+import javax.ws.rs.core.MediaType;
+
+@Path("""")
+public class ProxyPathParamRegexResource implements ProxyPathParamRegexTest.RegexInterface {
+    @GET
+    @Path(""/{path}/{string:[a-z]?}"")
+    @Produces(MediaType.TEXT_PLAIN)
+    public String getPath(@PathParam(""path"") String path, @PathParam(""string"") @Encoded String string) {
+        String responseString = path + string;
+        return responseString;
+    }
+}",2023-02-03T01:35:07Z,342
"@@ -74,7 +74,7 @@ public abstract class AbstractInterceptorFactory implements InterceptorFactory
 
       public AbstractInterceptorFactory(Class declaring)
       {
-         this.declaring = declaring;
+         this.declaring = getNonSyntheticClass(declaring);
       }
 
       protected void setPrecedence(Class<?> declaring)
@@ -133,7 +133,7 @@ public Match postMatch(Class targetClass, AccessibleObject target)
                {
                   if (!targetClass.isAnnotationPresent(annotation) &&
                           !target.isAnnotationPresent(annotation)
-                          && (application == null || !application.getClass().isAnnotationPresent(annotation)))
+                          && (application == null || !getNonSyntheticClass(application.getClass()).isAnnotationPresent(annotation)))
                   {
                      return null;
                   }
@@ -383,4 +383,13 @@ public synchronized void registerSingleton(T interceptor, int priority)
       factory.setOrder(priority);
       register(factory);
    }
+   
+   private Class<?> getNonSyntheticClass(Class<?> clazz)
+   {
+      while (clazz.isSynthetic())
+      {
+         clazz = clazz.getSuperclass();
+      }
+      return clazz;
+   }
 }",2018-07-23T13:08:21Z,41
"@@ -0,0 +1,65 @@
+package org.jboss.resteasy.test.cdi.interceptors;
+
+import java.io.File;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.test.cdi.interceptors.resource.NameBoundCDIProxiesApplication;
+import org.jboss.resteasy.test.cdi.interceptors.resource.NameBoundCDIProxiesInterceptor;
+import org.jboss.resteasy.test.cdi.interceptors.resource.NameBoundCDIProxiesResource;
+import org.jboss.resteasy.test.cdi.interceptors.resource.NameBoundProxiesAnnotation;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.asset.EmptyAsset;
+import org.jboss.shrinkwrap.api.exporter.ZipExporter;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * @tpSubChapter CDI
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Name bound interceptors and Application CDI proxies
+ * @tpSince RESTEasy 4.0.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class NameBoundCDIProxiesTest {
+
+   @Deployment
+   public static Archive<?> deploySimpleResource() {
+      WebArchive war = prepareArchive(NameBoundCDIProxiesTest.class.getSimpleName());
+      war.addClass(NameBoundProxiesAnnotation.class);
+      war.addAsWebInfResource(EmptyAsset.INSTANCE, ""beans.xml"");
+      return TestUtil.finishContainerPrepare(war, null, NameBoundCDIProxiesResource.class, NameBoundCDIProxiesInterceptor.class);
+   }
+
+   // Use specific Application subclass
+   private static WebArchive prepareArchive(String deploymentName) {
+      WebArchive war = ShrinkWrap.create(WebArchive.class, deploymentName + "".war"");
+      war.addClass(NameBoundCDIProxiesApplication.class);
+      return war;
+   }
+   private String generateURL(String path) {
+      return PortProviderUtil.generateURL(path, NameBoundCDIProxiesTest.class.getSimpleName());
+   }
+
+   /**
+    * @tpTestDetails Verify that 
+    * @tpSince RESTEasy 4.0.0
+    */
+   @Test
+   public void testNameBoundInterceptor() throws Exception {
+      Client client = ClientBuilder.newClient();
+      String answer = client.target(generateURL(""/test"")).request().get(String.class);
+      Assert.assertEquals(""in-test-out"", answer);
+      client.close();
+   }
+}",2018-07-23T13:08:21Z,343
"@@ -0,0 +1,24 @@
+package org.jboss.resteasy.test.cdi.interceptors.resource;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.ws.rs.ApplicationPath;
+import javax.ws.rs.core.Application;
+
+@ApplicationPath("""")
+@NameBoundProxiesAnnotation
+public class NameBoundCDIProxiesApplication extends Application {
+
+   public Set<Class<?>> getClasses() {
+      Set<Class<?>> set = new HashSet<Class<?>>();
+      set.add(NameBoundCDIProxiesResource.class);
+      return set;
+   }
+
+   public Set<Object> getSingletons() {
+      Set<Object> set = new HashSet<Object>();
+      set.add(new NameBoundCDIProxiesInterceptor());
+      return set;
+   }
+}",2018-07-23T13:08:21Z,344
"@@ -0,0 +1,32 @@
+package org.jboss.resteasy.test.cdi.interceptors.resource;
+
+import java.io.IOException;
+
+import javax.ws.rs.ApplicationPath;
+import javax.ws.rs.container.ContainerRequestContext;
+import javax.ws.rs.container.ContainerRequestFilter;
+import javax.ws.rs.container.ContainerResponseContext;
+import javax.ws.rs.container.ContainerResponseFilter;
+import javax.ws.rs.core.Application;
+import javax.ws.rs.core.Context;
+
+@NameBoundProxiesAnnotation
+public class NameBoundCDIProxiesInterceptor implements ContainerRequestFilter, ContainerResponseFilter {
+
+   static private String in = """";
+
+   /** The application context, used for retrieving the {@link ApplicationPath} value. */
+   @Context Application application;
+
+   @Override
+   public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
+      Object entity = application.getClass().isSynthetic() ? in + responseContext.getEntity() + ""-out"" : responseContext.getEntity();
+      responseContext.setEntity(entity); 
+   }
+
+   @Override
+   public void filter(ContainerRequestContext requestContext) throws IOException {
+      in = ""in-"";
+   }
+
+}",2018-07-23T13:08:21Z,345
"@@ -0,0 +1,14 @@
+package org.jboss.resteasy.test.cdi.interceptors.resource;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+
+@Path("""")
+public class NameBoundCDIProxiesResource {
+
+   @Path(""test"")
+   @GET
+   public String test() {
+      return ""test"";
+   }
+}",2018-07-23T13:08:21Z,346
"@@ -0,0 +1,13 @@
+package org.jboss.resteasy.test.cdi.interceptors.resource;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import javax.ws.rs.NameBinding;
+
+@Target({ ElementType.TYPE, ElementType.METHOD })
+@Retention(value = RetentionPolicy.RUNTIME)
+@NameBinding
+public @interface NameBoundProxiesAnnotation {}",2018-07-23T13:08:21Z,347
"@@ -18,6 +18,7 @@
 import javax.ws.rs.ext.MessageBodyWriter;
 import javax.ws.rs.ext.Providers;
 import javax.ws.rs.ext.ReaderInterceptor;
+import javax.ws.rs.ext.RuntimeDelegate;
 import javax.ws.rs.ext.WriterInterceptor;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
@@ -72,7 +73,13 @@ public Map<String, Object> getMutableProperties()
     */
    public String toHeaderString(Object object)
    {
-      return providerFactory.toHeaderString(object);
+      if (object instanceof String) return (String)object;
+      // Javadoc and TCK requires that you only get from RuntimeDelegate.getInstance().createHeaderDelegate()
+      RuntimeDelegate.HeaderDelegate delegate = RuntimeDelegate.getInstance().createHeaderDelegate(object.getClass());
+      if (delegate != null)
+         return delegate.toString(object);
+      else
+         return object.toString();
    }
 
    public <T> MessageBodyWriter<T> getMessageBodyWriter(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)",2013-05-08T01:58:34Z,56
"@@ -169,6 +169,7 @@ public void setEntity(Entity entity)
       {
          Object ent = entity.getEntity();
          setEntityObject(ent);
+         this.entityAnnotations = entity.getAnnotations();
          Variant v = entity.getVariant();
          headers.setMediaType(v.getMediaType());
          headers.setLanguage(v.getLanguage());",2013-05-08T01:58:34Z,12
"@@ -13,6 +13,7 @@
 import java.lang.reflect.Type;
 import java.net.URI;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Iterator;
@@ -48,7 +49,7 @@ public Object getProperty(String name)
    @Override
    public Collection<String> getPropertyNames()
    {
-      return invocation.getMutableProperties().keySet();
+      return Collections.unmodifiableSet(invocation.getMutableProperties().keySet());
    }
 
    @Override",2013-05-08T01:58:34Z,275
"@@ -49,7 +49,12 @@ public void setHeaders(MultivaluedMap<String, Object> newHeaders)
 
    public void setLanguage(Locale language)
    {
-      header(HttpHeaders.CONTENT_LANGUAGE, language);
+      if (language == null)
+      {
+         headers.remove(HttpHeaders.CONTENT_LANGUAGE);
+         return;
+      }
+      headers.putSingle(HttpHeaders.CONTENT_LANGUAGE, language);
    }
 
    public void setLanguage(String language)
@@ -59,55 +64,35 @@ public void setLanguage(String language)
 
    public void setMediaType(MediaType mediaType)
    {
-      header(HttpHeaders.CONTENT_TYPE, mediaType);
+      if (mediaType == null)
+      {
+         headers.remove(HttpHeaders.CONTENT_TYPE);
+         return;
+      }
+      headers.putSingle(HttpHeaders.CONTENT_TYPE, mediaType);
    }
 
    public void acceptLanguage(Locale... locales)
    {
-      headers.remove(HttpHeaders.ACCEPT_LANGUAGE);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (Locale l : locales)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE);
+      StringBuilder builder = buildAcceptString(accept, locales);
       headers.putSingle(HttpHeaders.ACCEPT_LANGUAGE, builder.toString());
    }
 
    public void acceptLanguage(String... locales)
    {
-      headers.remove(HttpHeaders.ACCEPT_LANGUAGE);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (String l : locales)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE);
+      StringBuilder builder = buildAcceptString(accept, locales);
       headers.putSingle(HttpHeaders.ACCEPT_LANGUAGE, builder.toString());
    }
 
-   public void acceptEncoding(String... encodings)
+   private StringBuilder buildAcceptString(String accept, Object[] items)
    {
-      headers.remove(HttpHeaders.ACCEPT_ENCODING);
       StringBuilder builder = new StringBuilder();
+      if (accept != null) builder.append(accept).append("", "");
+
       boolean isFirst = true;
-      for (String l : encodings)
+      for (Object l : items)
       {
          if (isFirst)
          {
@@ -117,49 +102,30 @@ public void acceptEncoding(String... encodings)
          {
             builder.append("", "");
          }
-         builder.append(l.toString());
+         builder.append(configuration.toHeaderString(l));
       }
+      return builder;
+   }
+
+   public void acceptEncoding(String... encodings)
+   {
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_ENCODING);
+      StringBuilder builder = buildAcceptString(accept, encodings);
       headers.putSingle(HttpHeaders.ACCEPT_ENCODING, builder.toString());
    }
 
 
    public void accept(String... types)
    {
-      headers.remove(HttpHeaders.ACCEPT);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (String l : types)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT);
+      StringBuilder builder = buildAcceptString(accept, types);
       headers.putSingle(HttpHeaders.ACCEPT, builder.toString());
    }
 
    public void accept(MediaType... types)
    {
-      headers.remove(HttpHeaders.ACCEPT);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (MediaType l : types)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT);
+      StringBuilder builder = buildAcceptString(accept, types);
       headers.putSingle(HttpHeaders.ACCEPT, builder.toString());
    }
 
@@ -190,7 +156,10 @@ public void header(String name, Object value)
          headers.remove(name);
          return;
       }
-      headers.add(name, value);
+      if (name.equalsIgnoreCase(HttpHeaders.ACCEPT)) accept(configuration.toHeaderString(value));
+      else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_ENCODING)) acceptEncoding(configuration.toHeaderString(value));
+      else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_LANGUAGE)) acceptLanguage(configuration.toHeaderString(value));
+      else headers.add(name, value);
    }
 
    public Date getDate()",2013-05-08T01:58:34Z,39
"@@ -0,0 +1,127 @@
+package org.jboss.resteasy.test.client;
+
+import junit.framework.Assert;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.Provider;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class RequestFilterTest
+{
+   private static final MediaType mediaType = MediaType.APPLICATION_JSON_TYPE;
+
+   public static class PostFilter1 implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""*** filter 1 ***"");
+         requestContext.setEntity(""test"", null, mediaType);
+      }
+   }
+
+   public static class PostFilter2 implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""*** filter 2 ***"");
+         Object entity = requestContext.getEntity();
+         Assert.assertNotNull(entity);
+         Assert.assertEquals(entity, ""test"");
+         MediaType mt = requestContext.getMediaType();
+         Assert.assertNotNull(mt);
+         Assert.assertEquals(mediaType, mt);
+         requestContext.abortWith(Response.ok().build());
+
+      }
+   }
+
+   @Provider
+   public static class AnnotationFilter implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""  ** ANnotation Filter"");
+         Annotation[] annotations = requestContext.getEntityAnnotations();
+         Assert.assertNotNull(annotations);
+         requestContext.abortWith(Response.ok(annotations[0].annotationType().getName()).build());
+      }
+   }
+
+   public static class AcceptLanguageFilter implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         List<Locale> locales = requestContext.getAcceptableLanguages();
+         StringBuilder builder = new StringBuilder();
+         for (Locale locale : locales) builder.append(locale.toString()).append("","");
+         Response r = Response.ok(builder.toString()).build();
+         requestContext.abortWith(r);
+      }
+   }
+
+   static Client client;
+
+   @BeforeClass
+   public static void setupClient()
+   {
+      client = ClientBuilder.newClient();
+
+   }
+
+   @AfterClass
+   public static void close()
+   {
+      client.close();
+   }
+
+   @Test
+   public void testAcceptLanguages()
+   {
+      Response response = client.target(""foo"").register(AcceptLanguageFilter.class).request()
+              .acceptLanguage(Locale.CANADA_FRENCH)
+              .acceptLanguage(Locale.PRC).get();
+      String str = response.readEntity(String.class);
+      System.out.println(str);
+      System.out.println(Locale.CANADA_FRENCH.toString());
+      Assert.assertTrue(str.contains(Locale.CANADA_FRENCH.toString()));
+
+   }
+
+
+   @Test
+   public void testFilters()
+   {
+      Entity<ByteArrayInputStream> entity = Entity.entity(new ByteArrayInputStream(
+              ""test"".getBytes()), MediaType.WILDCARD_TYPE);
+      Response response = client.target(""http://nowhere"").register(PostFilter1.class).register(PostFilter2.class).request().post(entity);
+      Entity<String> post = Entity.entity(""test"", MediaType.WILDCARD_TYPE,
+              AnnotationFilter.class.getAnnotations());
+      response = client.target(""nada"").register(AnnotationFilter.class).request().post(post);
+      Assert.assertEquals(Provider.class.getName(), response.readEntity(String.class));
+
+
+
+
+   }
+}",2013-05-08T01:58:34Z,276
"@@ -113,18 +113,16 @@ public static interface MyClient
    {
       @Path(""{pojo}"")
       @PUT
-      void put(@QueryParam(""pojo"") POJO q, @PathParam(""pojo"") POJO pp, @MatrixParam(""pojo"") POJO mp,
-               @HeaderParam(""pojo"") POJO hp);
+      void put(@QueryParam(""pojo"") String q, @PathParam(""pojo"") String pp, @MatrixParam(""pojo"") String mp,
+               @HeaderParam(""pojo"") String hp);
    }
 
    @Test
    public void testIt() throws Exception
    {
       ResteasyClient client = new ResteasyClientBuilder().providerFactory(deployment.getProviderFactory()).build();
       MyClient proxy = client.target(generateBaseUrl()).proxy(MyClient.class);
-      POJO pojo = new POJO();
-      pojo.setName(""pojo"");
-      proxy.put(pojo, pojo, pojo, pojo);
+      proxy.put(""pojo"", ""pojo"", ""pojo"", ""pojo"");
       client.close();
    }
 ",2013-05-08T01:58:34Z,277
"@@ -61,21 +61,4 @@ public static void setAllow(MultivaluedMap headers, Set<String> methods)
       headers.putSingle(""Allow"", builder.toString());
    }
 
-   public static String toHeaderString(Object object, ResteasyProviderFactory providerFactory)
-   {
-      if (object instanceof String) return object.toString();
-
-      StringConverter converter = providerFactory.getStringConverter(object
-              .getClass());
-      if (converter != null)
-         return converter.toString(object);
-
-      RuntimeDelegate.HeaderDelegate delegate = providerFactory
-              .createHeaderDelegate(object.getClass());
-      if (delegate != null)
-         return delegate.toString(object);
-      else
-         return object.toString();
-
-   }
 }",2013-05-08T01:58:34Z,278
"@@ -29,6 +29,7 @@ public class ClientRequestHeaders
 {
    protected CaseInsensitiveMap<Object> headers = new CaseInsensitiveMap<Object>();
    protected ClientConfiguration configuration;
+   private boolean userForcedContentType = false;
 
 
    public ClientRequestHeaders(final ClientConfiguration configuration)
@@ -75,7 +76,10 @@ public void setMediaType(MediaType mediaType)
          headers.remove(HttpHeaders.CONTENT_TYPE);
          return;
       }
-      headers.putSingle(HttpHeaders.CONTENT_TYPE, mediaType);
+      if (!userForcedContentType)
+      {
+         headers.putSingle(HttpHeaders.CONTENT_TYPE, mediaType);
+      }
    }
 
    public void acceptLanguage(Locale... locales)
@@ -169,6 +173,11 @@ public void header(String name, Object value)
       if (name.equalsIgnoreCase(HttpHeaders.ACCEPT)) accept(configuration.toHeaderString(value));
       else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_ENCODING)) acceptEncoding(configuration.toHeaderString(value));
       else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_LANGUAGE)) acceptLanguage(configuration.toHeaderString(value));
+      else if (name.equalsIgnoreCase(HttpHeaders.CONTENT_TYPE))
+      {
+         headers.putSingle(HttpHeaders.CONTENT_TYPE, value);
+         userForcedContentType = true;
+      }
       else headers.add(name, value);
    }
 ",2023-02-03T01:35:08Z,39
"@@ -74,7 +74,7 @@ public void testCount() throws Exception {
    @Test
    public void testNullJaxb() throws Exception {
       Response response = client.target(generateURL(""/my/null"")).request().header(""Content-Type"", ""application/xml"").post(Entity.text(""""));
-      Assert.assertEquals(HttpResponseCodes.SC_UNSUPPORTED_MEDIA_TYPE, response.getStatus());
+      Assert.assertEquals(HttpResponseCodes.SC_BAD_REQUEST, response.getStatus());
       response.close();
    }
 ",2023-02-03T01:35:08Z,348
"@@ -0,0 +1,148 @@
+package org.jboss.resteasy.test.resource.param;
+
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.test.resource.param.resource.UserDefinedHeaderParamResource;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.client.ClientBuilder;
+
+/**
+ * @tpSubChapter Resteasy-client
+ * @tpChapter Integration tests
+ * @tpTestCaseDetails Regression test for RESTEASY-2874
+ * @tpSince RESTEasy 4.7.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class UserDefinedHeaderParamTest {
+
+    ResteasyClient client;
+
+    private static final String HEADER_PARAM = ""image/jpeg"";
+
+    @Path("""")
+    public interface UserHeaderParamInterface {
+
+        @POST
+        @Path(""/header"")
+        @Consumes({""application/json"", ""text/plain"", ""image/jpeg""})
+        String sendHeaderFirst(@HeaderParam(""Content-Type"") String contentType, String text);
+
+        @POST
+        @Path(""/header"")
+        @Consumes({""application/json"", ""text/plain"", ""image/jpeg""})
+        String sendTextFirst(String text, @HeaderParam(""Content-Type"") String contentType);
+
+        @POST
+        @Path(""/header"")
+        @Consumes({""application/json"", ""text/plain"", ""image/jpeg""})
+        String sendDefaultType(String text);
+
+        @POST
+        @Path(""/header"")
+        @Consumes({""application/json"", ""text/plain"", ""image/jpeg""})
+        String sendMultipleTypes(String text, @HeaderParam(""Content-Type"") String contentType,
+                                 @HeaderParam(""Content-Type"") String secondContentType,
+                                 @HeaderParam(""Content-Type"") String thirdContentType);
+    }
+
+    @Before
+    public void setUp() {
+        client = (ResteasyClient) ClientBuilder.newClient();
+    }
+
+    @After
+    public void after() throws Exception {
+        client.close();
+    }
+
+    @Deployment
+    public static Archive<?> deploy() throws Exception {
+        WebArchive war = TestUtil.prepareArchive(UserDefinedHeaderParamTest.class.getSimpleName());
+        return TestUtil.finishContainerPrepare(war, null, UserDefinedHeaderParamResource.class);
+    }
+
+    private String generateURL() {
+        return PortProviderUtil.generateBaseUrl(UserDefinedHeaderParamTest.class.getSimpleName());
+    }
+
+    /**
+     * @tpTestDetails Checks whether the correct content type header is returned in case user specified header param
+     * as a first argument in proxy method.
+     * @tpPassCrit Expected header is returned
+     * @tpSince RESTEasy 4.7.0
+     */
+    @Test
+    public void testHeaderParamFirst(){
+        ResteasyWebTarget target = client.target(generateURL());
+        UserHeaderParamInterface proxy = target.proxy(UserDefinedHeaderParamTest.UserHeaderParamInterface.class);
+
+        String response = proxy.sendHeaderFirst(HEADER_PARAM, ""text"");
+        Assert.assertEquals(""Incorrect header param returned,"", HEADER_PARAM, response);
+    }
+
+    /**
+     * @tpTestDetails Checks whether the correct content type header is returned in case user specified header param
+     * as a second argument in proxy method.
+     * @tpPassCrit Expected header is returned
+     * @tpSince RESTEasy 4.7.0
+     */
+    @Test
+    public void testTextFirst(){
+        ResteasyWebTarget target = client.target(generateURL());
+        UserHeaderParamInterface proxy = target.proxy(UserDefinedHeaderParamTest.UserHeaderParamInterface.class);
+
+        String response = proxy.sendTextFirst(""text"", HEADER_PARAM);
+        Assert.assertEquals(""Incorrect header param returned,"", HEADER_PARAM, response);
+    }
+
+    /**
+     * @tpTestDetails Checks whether the correct content type header is returned in case user didn't specify header
+     * param in proxy method. This should be the first content type in case of multiple @Consumes values.
+     * @tpPassCrit Expected header is returned
+     * @tpSince RESTEasy 4.7.0
+     */
+    @Test
+    public void testDefaultHeaderParam(){
+        ResteasyWebTarget target = client.target(generateURL());
+        UserHeaderParamInterface proxy = target.proxy(UserDefinedHeaderParamTest.UserHeaderParamInterface.class);
+
+        String response = proxy.sendDefaultType(""text"");
+        Assert.assertEquals(""Incorrect header param returned,"", ""application/json"", response);
+    }
+
+    /**
+     * @tpTestDetails Checks whether the correct content type header is returned in case user specified header
+     * param in proxy method with multiple other header params. This should be the last content type in arguments.
+     * @tpPassCrit Expected header is returned
+     * @tpSince RESTEasy 4.7.0
+     */
+    @Test
+    public void testMultipleHeaderParams(){
+        ResteasyWebTarget target = client.target(generateURL());
+        UserHeaderParamInterface proxy = target.proxy(UserDefinedHeaderParamTest.UserHeaderParamInterface.class);
+
+        String response = proxy.sendMultipleTypes(""text"", ""text/plain"",""application/json"",""image/jpeg"");
+        Assert.assertEquals(""Incorrect header param returned,"", HEADER_PARAM, response);
+    }
+
+
+}",2023-02-03T01:35:08Z,349
"@@ -0,0 +1,41 @@
+package org.jboss.resteasy.test.resource.param.resource;
+
+import org.jboss.resteasy.test.resource.param.UserDefinedHeaderParamTest;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.HeaderParam;
+import javax.ws.rs.Path;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+
+public class UserDefinedHeaderParamResource implements UserDefinedHeaderParamTest.UserHeaderParamInterface {
+
+    @Context
+    private HttpHeaders httpHeaders;
+
+    @GET
+    @Path(""/header"")
+    public String sendHeaderFirst(@HeaderParam(""Content-Type"") String contentType, String text) {
+        return httpHeaders.getHeaderString(""Content-Type"");
+    }
+
+    @GET
+    @Path(""/header"")
+    public String sendTextFirst(String text, @HeaderParam(""Content-Type"") String contentType) {
+        return httpHeaders.getHeaderString(""Content-Type"");
+    }
+
+    @GET
+    @Path(""/header"")
+    public String sendDefaultType(String text) {
+        return httpHeaders.getHeaderString(""Content-Type"");
+    }
+
+    @GET
+    @Path(""/header"")
+    public String sendMultipleTypes(String text, @HeaderParam(""Content-Type"") String contentType,
+                                    @HeaderParam(""Content-Type"") String secondContentType,
+                                    @HeaderParam(""Content-Type"") String thirdContentType) {
+        return httpHeaders.getHeaderString(""Content-Type"");
+    }
+}",2023-02-03T01:35:08Z,350
"@@ -839,6 +839,9 @@ public interface Messages
    @Message(id = BASE + 1099, value = ""MultiValuedCollectionParamConverter unable to parse: %s"")
    String unableToParse(String s);
 
+   @Message(id = BASE + 2042, value = ""Multiple resource methods match request %s. Matching methods: %s"")
+   String multipleMethodsMatchFailFast(String request, String[] methods);
+
    @Message(id = BASE + 13, value = ""Error creating array from %s"")
    String errorCreatingArray(String s);
 }",2019-10-10T20:45:04Z,351
"@@ -2,6 +2,8 @@
 
 import org.jboss.resteasy.core.ResourceLocatorInvoker;
 import org.jboss.resteasy.core.ResourceMethodInvoker;
+import org.jboss.resteasy.microprofile.config.ResteasyConfigProvider;
+import org.jboss.resteasy.plugins.server.servlet.ResteasyContextParameters;
 import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;
 import org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;
 import org.jboss.resteasy.specimpl.ResteasyUriInfo;
@@ -503,7 +505,15 @@ else if (!consumeMatch)
       String[] mm = matchingMethods(sortList);
       if (mm != null)
       {
-         LogMessages.LOGGER.multipleMethodsMatch(requestToString(request), mm);
+         boolean isFailFast = Boolean.valueOf(ResteasyConfigProvider.getConfig().getOptionalValue(
+                         ResteasyContextParameters.RESTEASY_FAIL_FAST_ON_MULTIPLE_RESOURCES_MATCHING,String.class)
+                         .orElse(""false""));
+         if(isFailFast) {
+            throw new RuntimeException(Messages.MESSAGES
+                    .multipleMethodsMatchFailFast(requestToString(request), mm));
+         } else {
+            LogMessages.LOGGER.multipleMethodsMatch(requestToString(request), mm);
+         }
       }
       MediaType acceptType = sortEntry.getAcceptType();
       request.setAttribute(RESTEASY_CHOSEN_ACCEPT, acceptType);",2019-10-10T20:45:04Z,352
"@@ -93,4 +93,7 @@ public interface ResteasyContextParameters {
    String RESTEASY_PREFER_JACKSON_OVER_JSONB = ""resteasy.preferJacksonOverJsonB"";
 
     String RESTEASY_STATISTICS_ENABLED = ""resteasy.statistics.enabled"";
+
+    // Added for quarkus.  Initial use switch from warning msg to exception message.
+    String RESTEASY_FAIL_FAST_ON_MULTIPLE_RESOURCES_MATCHING = ""resteasy.fail.fast.on.multiple.resources.matching"";
 }",2019-10-10T20:45:04Z,353
"@@ -0,0 +1,90 @@
+package org.jboss.resteasy.test.resource.basic;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.plugins.server.servlet.ResteasyContextParameters;
+import org.jboss.resteasy.test.ContainerConstants;
+import org.jboss.resteasy.test.resource.basic.resource.MultipleGetResource;
+import org.jboss.resteasy.utils.LogCounter;
+import org.jboss.resteasy.utils.PermissionUtil;
+import org.jboss.resteasy.utils.PortProviderUtil;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.Assert;
+
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.io.FilePermission;
+import java.lang.reflect.ReflectPermission;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.PropertyPermission;
+import java.util.logging.LoggingPermission;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.jboss.resteasy.test.ContainerConstants.DEFAULT_CONTAINER_QUALIFIER;
+
+/**
+ * Verify that setting resteasy config flag, resteasy_fail_fast to 'true' causes
+ * resteasy to report error and not warning.
+ * This feature is provided for quarkus.
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class MultipleGetResourceTest {
+    static ResteasyClient client;
+
+    @Deployment
+    public static Archive<?> testReturnValuesDeploy() throws Exception {
+        WebArchive war = TestUtil.prepareArchive(MultipleGetResourceTest.class.getSimpleName());
+        Map<String, String> contextParam = new HashMap<>();
+        contextParam.put(ResteasyContextParameters.RESTEASY_FAIL_FAST_ON_MULTIPLE_RESOURCES_MATCHING, ""true"");
+        war.addAsManifestResource(PermissionUtil.createPermissionsXmlAsset(
+                new ReflectPermission(""suppressAccessChecks""),
+                new FilePermission(TestUtil.getStandaloneDir(DEFAULT_CONTAINER_QUALIFIER) + File.separator + ""log"" +
+                        File.separator + ""server.log"", ""read""),
+                new LoggingPermission(""control"", """"),
+                new PropertyPermission(""arquillian.*"", ""read""),
+                new PropertyPermission(""jboss.home.dir"", ""read""),
+                new PropertyPermission(""jboss.server.base.dir"", ""read""),
+                new RuntimePermission(""accessDeclaredMembers"")
+        ), ""permissions.xml"");
+        return TestUtil.finishContainerPrepare(war, contextParam, MultipleGetResource.class);
+    }
+
+    @BeforeClass
+    public static void init() {
+        client = (ResteasyClient) ClientBuilder.newClient();
+    }
+
+    @AfterClass
+    public static void close() {
+        client.close();
+        client = null;
+    }
+
+    private String generateURL(String path) {
+        return PortProviderUtil.generateURL(path, MultipleGetResourceTest.class.getSimpleName());
+    }
+
+    @Test
+    public void testFailFast() throws Exception {
+        LogCounter errorStringLog = new LogCounter(""RESTEASY005042"",
+                false, ContainerConstants.DEFAULT_CONTAINER_QUALIFIER);
+
+        WebTarget base = client.target(generateURL(""/api""));
+        Response  response = base.request().get();
+        Assert.assertEquals(500, response.getStatus());
+        response.close();
+        Assert.assertThat(errorStringLog.count(), is(2));
+    }
+}",2019-10-10T20:45:04Z,354
"@@ -0,0 +1,26 @@
+package org.jboss.resteasy.test.resource.basic.resource;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.Produces;
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.core.MediaType;
+import java.util.ArrayList;
+import java.util.List;
+
+@Path(""/api"")
+@Produces(MediaType.APPLICATION_JSON)
+@Consumes(MediaType.APPLICATION_JSON)
+public class MultipleGetResource {
+    private List<String> todoList = new ArrayList<>();
+
+    @GET
+    public List<String> getAll() {
+        return todoList;
+    }
+
+    @GET
+    public List<String> findNotCompleted() {
+        return todoList;
+    }
+}",2019-10-10T20:45:04Z,355
"@@ -7,6 +7,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
@@ -116,9 +119,45 @@ private static class CustomTempFileStorageProvider extends AbstractStorageProvid
 
         public StorageOutputStream createStorageOutputStream() throws IOException
         {
-            File file = File.createTempFile(prefix, suffix, directory);
+            return new TempFileStorageOutputStream(createTempFile(prefix, suffix, directory));
+        }
 
-            return new TempFileStorageOutputStream(file);
+        private static File createTempFile(String prefix, String suffix, File directory) throws IOException
+        {
+            boolean java2SecurityEnabled = System.getSecurityManager() != null;
+            if (java2SecurityEnabled)
+            {
+                try {
+                    return AccessController.doPrivileged((PrivilegedExceptionAction<File>) () ->
+                        File.createTempFile(prefix, suffix, directory));
+                } catch (PrivilegedActionException pae) {
+                    Throwable cause = pae.getCause();
+                    if (cause instanceof IOException)
+                    {
+                        throw (IOException) cause;
+                    } else throw new RuntimeException(cause);
+                }
+            }
+            return File.createTempFile(prefix, suffix, directory);
+        }
+
+        private static FileOutputStream createFileOutputStream(File file) throws IOException
+        {
+            boolean java2SecurityEnabled = System.getSecurityManager() != null;
+            if (java2SecurityEnabled)
+            {
+                try {
+                    return AccessController.doPrivileged((PrivilegedExceptionAction<FileOutputStream>) () ->
+                        new FileOutputStream(file));
+                } catch (PrivilegedActionException pae) {
+                    Throwable cause = pae.getCause();
+                    if (cause instanceof IOException)
+                    {
+                        throw (IOException) cause;
+                    } else throw new RuntimeException(cause);
+                }
+            }
+            return new FileOutputStream(file);
         }
 
         private static final class TempFileStorageOutputStream extends StorageOutputStream
@@ -130,7 +169,7 @@ private static final class TempFileStorageOutputStream extends StorageOutputStre
             TempFileStorageOutputStream(final File file) throws IOException
             {
                 this.file = file;
-                this.out = new FileOutputStream(file);
+                this.out = createFileOutputStream(file);
             }
 
             @Override",2021-04-09T22:07:48Z,241
"@@ -22,24 +22,18 @@
  */
 public class ResteasyClient implements Client
 {
-   protected volatile ResteasyProviderFactory providerFactory;
    protected volatile ClientHttpEngine httpEngine;
    protected volatile ExecutorService asyncInvocationExecutor;
-   protected ClientConfiguration configuration = new ClientConfiguration();
+   protected ClientConfiguration configuration;
 
-   public ResteasyProviderFactory providerFactory()
+   public ResteasyClient()
    {
-      ResteasyProviderFactory result = providerFactory;
-      if (result == null)
-      { // First check (no locking)
-         synchronized (this)
-         {
-            result = providerFactory;
-            if (result == null) // Second check (with locking)
-               providerFactory = result = ResteasyProviderFactory.getInstance();
-         }
-      }
-      return result;
+      configuration = new ClientConfiguration(ResteasyProviderFactory.getInstance());
+   }
+
+   public ResteasyClient(ResteasyProviderFactory providerFactory)
+   {
+      configuration = new ClientConfiguration(providerFactory);
    }
 
    public ClientHttpEngine httpEngine()",2012-07-30T22:39:40Z,55
"@@ -1,34 +1,133 @@
 package org.jboss.resteasy.client.jaxrs.internal;
 
+import org.jboss.resteasy.core.InjectorFactoryImpl;
+import org.jboss.resteasy.core.ThreadLocalResteasyProviderFactory;
+import org.jboss.resteasy.spi.InjectorFactory;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.client.ClientResponseFilter;
 import javax.ws.rs.client.Configuration;
 import javax.ws.rs.client.Feature;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.ext.ContextResolver;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Providers;
+import javax.ws.rs.ext.WriterInterceptor;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Type;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class ClientConfiguration implements Configuration
+public class ClientConfiguration implements Configuration, Providers
 {
    protected HashMap<String, Object> properties = new HashMap<String, Object>();
+   protected ResteasyProviderFactory providerFactory;
+   protected Set<Feature> features = new HashSet<Feature>();
+
+   // We have our own injectorFactory because InjectorFactory currently holds a providerFactory member and
+   // there is no SPI to change it.  I'm not sure it is wise to re-use the one provided anyways as its possible
+   // for a Client to be shared between multiple threads.
+   protected InjectorFactory injectorFactory;
 
-   public ClientConfiguration()
+   public ClientConfiguration(ResteasyProviderFactory factory)
    {
+      if (factory instanceof ThreadLocalResteasyProviderFactory)
+      {
+         factory = ((ThreadLocalResteasyProviderFactory)factory).getDelegate();
+      }
+      this.providerFactory = new ResteasyProviderFactory(factory);
+      injectorFactory = new InjectorFactoryImpl(this.providerFactory);
    }
 
    public ClientConfiguration(ClientConfiguration parent)
    {
+      this(parent.getProviderFactory());
       properties.putAll(parent.properties);
    }
 
+   protected ResteasyProviderFactory getProviderFactory()
+   {
+      return providerFactory;
+   }
+
    public Map<String, Object> getMutableProperties()
    {
       return properties;
    }
 
+   /**
+    * Convert an object to a header string.  First try StringConverter, then HeaderDelegate, then object.toString()
+    *
+    * @param object
+    * @return
+    */
+   public String toHeaderString(Object object)
+   {
+      return providerFactory.toHeaderString(object);
+   }
+
+   public <T> MessageBodyWriter<T> getMessageBodyWriter(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)
+   {
+      return providerFactory.getMessageBodyWriter(type, genericType, annotations, mediaType);
+   }
+
+   public <T> MessageBodyReader<T> getMessageBodyReader(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)
+   {
+      return providerFactory.getMessageBodyReader(type, genericType, annotations, mediaType);
+   }
+
+   public WriterInterceptor[] getWriterInterceptors(Class declaring, AccessibleObject target)
+   {
+      return providerFactory.getClientWriterInterceptorRegistry().postMatch(declaring, target);
+   }
+
+   public ClientRequestFilter[] getRequestFilters(Class declaring, AccessibleObject target)
+   {
+      return providerFactory.getClientRequestFilters().postMatch(declaring, target);
+   }
+
+   public ClientResponseFilter[] getResponseFilters(Class declaring, AccessibleObject target)
+   {
+      return providerFactory.getClientResponseFilters().postMatch(declaring, target);
+   }
+
+   public String toString(Object object)
+   {
+      return providerFactory.toString(object);
+   }
+
+
+
+
+   // interface implementation
+
+   // Providers
+
+   @Override
+   public <T extends Throwable> ExceptionMapper<T> getExceptionMapper(Class<T> type)
+   {
+      return providerFactory.getExceptionMapper(type);
+   }
+
+   @Override
+   public <T> ContextResolver<T> getContextResolver(Class<T> contextType, MediaType mediaType)
+   {
+      return providerFactory.getContextResolver(contextType, mediaType);
+   }
+
+   // Configuration
+
    @Override
    public Map<String, Object> getProperties()
    {
@@ -44,48 +143,94 @@ public Object getProperty(String name)
    @Override
    public Set<Feature> getFeatures()
    {
-      return null;
+      return Collections.unmodifiableSet(features);
    }
 
    @Override
    public Set<Class<?>> getProviderClasses()
    {
-      return null;
+      return providerFactory.getProviderClasses();
    }
 
    @Override
    public Set<Object> getProviderInstances()
    {
-      return null;
+      return providerFactory.getProviderInstances();
    }
 
    @Override
    public Configuration update(Configuration configuration)
    {
-      return null;
+      providerFactory = new ResteasyProviderFactory();
+      setProperties(configuration.getProperties());
+      for (Class c : configuration.getProviderClasses())
+      {
+         register(c);
+      }
+      for (Object obj : configuration.getProviderInstances())
+      {
+         register(obj);
+      }
+      return this;
    }
 
    @Override
    public Configuration register(Class<?> providerClass)
    {
-      return null;
+      if (Feature.class.isAssignableFrom(providerClass))
+      {
+         Feature feature = providerFactory.createProviderInstance((Class<? extends Feature>)providerClass);
+         if (feature.onEnable(this))
+         {
+            features.add(feature);
+         }
+      }
+      else
+      {
+         providerFactory.registerProvider(providerClass);
+      }
+      return this;
    }
 
    @Override
    public Configuration register(Object provider)
    {
-      return null;
+      if (provider instanceof Feature)
+      {
+         Feature feature = (Feature)provider;
+         if (feature.onEnable(this))
+         {
+            features.add(feature);
+         }
+      }
+      else
+      {
+         providerFactory.registerProviderInstance(provider);
+      }
+      return this;
    }
 
    @Override
    public Configuration setProperties(Map<String, ? extends Object> properties)
    {
-      return null;
+      if (properties == null)
+      {
+         this.properties = new HashMap<String, Object>();
+         return this;
+      }
+      this.properties = new HashMap<String, Object>();
+      this.properties.putAll(properties);
+      return this;
    }
 
    @Override
    public Configuration setProperty(String name, Object value)
    {
+      if (value == null)
+      {
+         properties.remove(name);
+         return this;
+      }
       properties.put(name, value);
       return this;
    }",2012-07-30T22:39:40Z,56
"@@ -192,11 +192,6 @@ public void setEntityObject(Object ent)
       }
    }
 
-   public ResteasyProviderFactory getProviderFactory()
-   {
-      return client.providerFactory();
-   }
-
    public void writeRequestBody(OutputStream outputStream) throws IOException
    {
       if (entity == null)
@@ -219,7 +214,7 @@ public void writeRequestBody(OutputStream outputStream) throws IOException
 
    public MessageBodyWriter getWriter()
    {
-      MessageBodyWriter writer = client.providerFactory()
+      MessageBodyWriter writer = configuration
               .getMessageBodyWriter(entityClass, entityGenericType,
                       entityAnnotations, this.getHeaders().getMediaType());
       if (writer == null)
@@ -233,17 +228,17 @@ public MessageBodyWriter getWriter()
 
    public WriterInterceptor[] getWriterInterceptors()
    {
-      return client.providerFactory().getClientWriterInterceptorRegistry().postMatch(null, null);
+      return configuration.getWriterInterceptors(null, null);
    }
 
    public ClientRequestFilter[] getRequestFilters()
    {
-      return client.providerFactory().getClientRequestFilters().postMatch(null, null);
+      return configuration.getRequestFilters(null, null);
    }
 
    public ClientResponseFilter[] getResponseFilters()
    {
-      return client.providerFactory().getClientResponseFilters().postMatch(null, null);
+      return configuration.getResponseFilters(null, null);
    }
 
    // Invocation methods",2012-07-30T22:39:40Z,12
"@@ -36,7 +36,7 @@ public class ClientInvocationBuilder implements Invocation.Builder
 
    public ClientInvocationBuilder(ResteasyClient client, URI uri, ClientConfiguration configuration)
    {
-      invocation = new ClientInvocation(client, uri, new ClientRequestHeaders(client.providerFactory()), configuration);
+      invocation = new ClientInvocation(client, uri, new ClientRequestHeaders(configuration), configuration);
    }
 
    public ClientInvocation getInvocation()",2012-07-30T22:39:40Z,12
"@@ -26,18 +26,12 @@
 public class ClientRequestHeaders
 {
    protected CaseInsensitiveMap<Object> headers = new CaseInsensitiveMap<Object>();
-   protected ResteasyProviderFactory providerFactory;
+   protected ClientConfiguration configuration;
 
-   public ClientRequestHeaders(ResteasyProviderFactory providerFactory)
-   {
-      this.providerFactory = providerFactory;
-   }
 
-   public ClientRequestHeaders clone()
+   public ClientRequestHeaders(ClientConfiguration configuration)
    {
-      ClientRequestHeaders copy = new ClientRequestHeaders(providerFactory);
-      copy.headers.putAll(headers);
-      return copy;
+      this.configuration = configuration;
    }
 
    public CaseInsensitiveMap<Object> getHeaders()
@@ -194,7 +188,7 @@ public String getHeader(String name)
       {
          if (first) first = false;
          else builder.append("","");
-         builder.append(providerFactory.toHeaderString(val));
+         builder.append(configuration.toHeaderString(val));
       }
       return builder.toString();
    }
@@ -206,7 +200,7 @@ public MultivaluedMap<String, String> asMap()
       {
          for (Object obj : entry.getValue())
          {
-            map.add(entry.getKey(), providerFactory.toHeaderString(obj));
+            map.add(entry.getKey(), configuration.toHeaderString(obj));
          }
       }
       return map;
@@ -230,7 +224,7 @@ public MediaType getMediaType()
       Object obj = headers.getFirst(HttpHeaders.CONTENT_TYPE);
       if (obj == null) return null;
       if (obj instanceof MediaType) return (MediaType) obj;
-      return MediaType.valueOf(providerFactory.toHeaderString(obj));
+      return MediaType.valueOf(configuration.toHeaderString(obj));
    }
 
    public List<MediaType> getAcceptableMediaTypes()
@@ -252,7 +246,7 @@ public List<MediaType> getAcceptableMediaTypes()
          }
          else
          {
-            accept = providerFactory.toHeaderString(obj);
+            accept = configuration.toHeaderString(obj);
 
          }
          StringTokenizer tokenizer = new StringTokenizer(accept, "","");
@@ -284,7 +278,7 @@ public List<Locale> getAcceptableLanguages()
          }
          else
          {
-            accept = providerFactory.toHeaderString(obj);
+            accept = configuration.toHeaderString(obj);
 
          }
          StringTokenizer tokenizer = new StringTokenizer(accept, "","");
@@ -311,7 +305,7 @@ public Map<String, Cookie> getCookies()
          }
          else
          {
-            String str = providerFactory.toHeaderString(obj);
+            String str = configuration.toHeaderString(obj);
             Cookie cookie = Cookie.valueOf(str);
             cookies.put(cookie.getName(), cookie);
          }",2012-07-30T22:39:40Z,39
"@@ -51,7 +51,7 @@ public abstract class ClientResponse extends Response
    protected MultivaluedMap<String, String> headers;
    protected Map<String, Object> properties;
    protected Object entity;
-   protected ResteasyProviderFactory providerFactory;
+   protected ClientConfiguration configuration;
    protected boolean isClosed;
    protected byte[] bufferedEntity;
 
@@ -70,17 +70,15 @@ public void setStatus(int status)
       this.status = status;
    }
 
-   public void setProviderFactory(ResteasyProviderFactory providerFactory)
-   {
-      this.providerFactory = providerFactory;
-   }
-
    public Map<String, Object> getProperties()
    {
       return properties;
    }
 
-
+   public void setConfiguration(ClientConfiguration configuration)
+   {
+      this.configuration = configuration;
+   }
 
    @Override
    public int getStatus()
@@ -212,7 +210,7 @@ protected <T2> Object readFrom(Class<T2> type, Type genericType,
       }
 
 
-      MessageBodyReader reader1 = providerFactory.getMessageBodyReader(useType,
+      MessageBodyReader reader1 = configuration.getMessageBodyReader(useType,
               useGeneric, annotations, media);
       if (reader1 == null)
       {",2012-07-30T22:39:40Z,22
"@@ -98,7 +98,7 @@ public ResteasyWebTarget pathParam(String name, Object value) throws IllegalArgu
       UriBuilder copy = uriBuilder.clone();
       HashMap<String, String> paramMap = new HashMap<String, String>();
       paramMap.putAll(pathParams);
-      paramMap.put(name, client.providerFactory().toString(value));
+      paramMap.put(name, configuration.toString(value));
       ClientWebTarget target = new ClientWebTarget(client, copy, configuration);
       target.pathParams = paramMap;
       return target;
@@ -112,7 +112,7 @@ public ResteasyWebTarget pathParams(Map<String, Object> parameters) throws Illeg
       HashMap<String, String> paramMap = new HashMap<String, String>();
       for (Map.Entry<String, Object> entry : parameters.entrySet())
       {
-         paramMap.put(entry.getKey(), client.providerFactory().toString(entry.getValue()));
+         paramMap.put(entry.getKey(), configuration.toString(entry.getValue()));
       }
       target.pathParams = paramMap;
       return target;
@@ -131,7 +131,7 @@ private String[] toStringValues(Object[] values)
       String[] stringValues = new String[values.length];
       for (int i = 0; i < stringValues.length; i++)
       {
-         stringValues[i] = client.providerFactory().toString(values[i]);
+         stringValues[i] = configuration.toString(values[i]);
       }
       return stringValues;
    }",2012-07-30T22:39:40Z,127
"@@ -165,7 +165,7 @@ public void releaseConnection()
       response.setProperties(request.getMutableProperties());
       response.setStatus(res.getStatusLine().getStatusCode());
       response.setHeaders(extractHeaders(res));
-      response.setProviderFactory(request.getProviderFactory());
+      response.setConfiguration(request.getConfiguration());
       return response;
    }
 ",2012-07-30T22:39:40Z,15
"@@ -2,6 +2,7 @@
 
 import org.jboss.resteasy.client.jaxrs.ProxyConfig;
 import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
@@ -41,18 +42,18 @@ public class ClientInvoker implements MethodInvoker
 
    public ClientInvoker(ResteasyWebTarget parent, Class declaring, Method method, ProxyConfig config)
    {
-      this.declaring = declaring;
-      this.method = method;
-      this.processors = ProcessorFactory.createProcessors(declaring, method, parent.getResteasyClient().providerFactory(), config.getDefaultConsumes());
-      accepts = MediaTypeHelper.getProduces(declaring, method, config.getDefaultProduces());
-      entityExtractorFactory = new DefaultEntityExtractorFactory();
-      this.extractor = entityExtractorFactory.createExtractor(method);
       UriBuilder builder = parent.getUriBuilder();
       if (method.isAnnotationPresent(Path.class))
       {
          builder.path(method);
       }
-      this.webTarget = (ResteasyWebTarget)parent.getResteasyClient().target(builder);
+      this.webTarget = parent.getResteasyClient().target(builder);
+      this.declaring = declaring;
+      this.method = method;
+      this.processors = ProcessorFactory.createProcessors(declaring, method, (ClientConfiguration)this.webTarget.configuration(), config.getDefaultConsumes());
+      accepts = MediaTypeHelper.getProduces(declaring, method, config.getDefaultProduces());
+      entityExtractorFactory = new DefaultEntityExtractorFactory();
+      this.extractor = entityExtractorFactory.createExtractor(method);
    }
 
    public MediaType getAccepts()
@@ -73,7 +74,7 @@ public Class getDeclaring()
    public Object invoke(Object[] args)
    {
       boolean isProvidersSet = ResteasyProviderFactory.getContextData(Providers.class) != null;
-      if (!isProvidersSet) ResteasyProviderFactory.pushContext(Providers.class, webTarget.getResteasyClient().providerFactory());
+      if (!isProvidersSet) ResteasyProviderFactory.pushContext(Providers.class, (ClientConfiguration)this.webTarget.configuration());
 
       try
       {",2012-07-30T22:39:40Z,506
"@@ -1,5 +1,6 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors;
 
+import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder;
 import org.jboss.resteasy.spi.LoggableFailure;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
@@ -44,11 +45,11 @@ private GetterMethod(Method method, Object processor)
    protected HashMap<Long, Method> getterHashes = new HashMap<Long, Method>();
    protected Class clazz;
 
-   public FormProcessor(Class clazz, ResteasyProviderFactory factory)
+   public FormProcessor(Class clazz, ClientConfiguration configuration)
    {
       this.clazz = clazz;
 
-      populateMap(clazz, factory);
+      populateMap(clazz, configuration);
    }
 
    public static long methodHash(Method method)
@@ -128,7 +129,7 @@ else if (cl.isArray())
       }
    }
 
-   protected void populateMap(Class clazz, ResteasyProviderFactory factory)
+   protected void populateMap(Class clazz, ClientConfiguration configuration)
    {
       for (Field field : clazz.getDeclaredFields())
       {
@@ -138,7 +139,7 @@ protected void populateMap(Class clazz, ResteasyProviderFactory factory)
          Type genericType = field.getGenericType();
 
          Object processor = ProcessorFactory.createProcessor(
-                 clazz, factory, type, annotations, genericType, field, true);
+                 clazz, configuration, type, annotations, genericType, field, true);
          if (processor != null)
          {
             if (!Modifier.isPublic(field.getModifiers())) field.setAccessible(true);
@@ -158,7 +159,7 @@ protected void populateMap(Class clazz, ResteasyProviderFactory factory)
          Type genericType = method.getGenericReturnType();
 
          Object processor = ProcessorFactory
-                 .createProcessor(clazz, factory, type, annotations,
+                 .createProcessor(clazz, configuration, type, annotations,
                          genericType, method, true);
          if (processor != null)
          {
@@ -184,7 +185,7 @@ protected void populateMap(Class clazz, ResteasyProviderFactory factory)
 
       }
       if (clazz.getSuperclass() != null && !clazz.getSuperclass().equals(Object.class))
-         populateMap(clazz.getSuperclass(), factory);
+         populateMap(clazz.getSuperclass(), configuration);
 
 
    }",2012-07-30T22:39:40Z,184
"@@ -2,6 +2,7 @@
 
 import org.jboss.resteasy.annotations.Form;
 import org.jboss.resteasy.client.ClientURI;
+import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation.CookieParamProcessor;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation.FormParamProcessor;
 import org.jboss.resteasy.client.jaxrs.internal.proxy.processors.invocation.HeaderParamProcessor;
@@ -32,12 +33,12 @@
 public class ProcessorFactory
 {
 
-	public static Object[] createProcessors(Class declaringClass, Method method, ResteasyProviderFactory providerFactory)
+	public static Object[] createProcessors(Class declaringClass, Method method, ClientConfiguration configuration)
 	{
-		return createProcessors(declaringClass, method, providerFactory, null);
+		return createProcessors(declaringClass, method, configuration, null);
 	}
 	
-	public static Object[] createProcessors(Class declaringClass, Method method, ResteasyProviderFactory providerFactory, MediaType defaultConsumes)
+	public static Object[] createProcessors(Class declaringClass, Method method, ClientConfiguration configuration, MediaType defaultConsumes)
 	{
       Object[] params = new Object[method.getParameterTypes().length];
       for (int i = 0; i < method.getParameterTypes().length; i++)
@@ -46,21 +47,21 @@ public static Object[] createProcessors(Class declaringClass, Method method, Res
          Annotation[] annotations = method.getParameterAnnotations()[i];
          Type genericType = method.getGenericParameterTypes()[i];
          AccessibleObject target = method;
-         params[i] = ProcessorFactory.createProcessor(declaringClass, providerFactory, type, annotations, genericType, target, defaultConsumes, false);
+         params[i] = ProcessorFactory.createProcessor(declaringClass, configuration, type, annotations, genericType, target, defaultConsumes, false);
       }
       return params;
    }
 
 	   public static Object createProcessor(Class<?> declaring,
-                                               ResteasyProviderFactory providerFactory, Class<?> type,
+                                               ClientConfiguration configuration, Class<?> type,
                                                Annotation[] annotations, Type genericType, AccessibleObject target,
                                                boolean ignoreBody)
 	   {
-		   return createProcessor(declaring, providerFactory, type, annotations, genericType, target, null, ignoreBody);
+		   return createProcessor(declaring, configuration, type, annotations, genericType, target, null, ignoreBody);
 	   }
 	   
 	   public static Object createProcessor(Class<?> declaring,
-                                               ResteasyProviderFactory providerFactory, Class<?> type,
+                                               ClientConfiguration configuration, Class<?> type,
                                                Annotation[] annotations, Type genericType, AccessibleObject target, MediaType defaultConsumes,
                                                boolean ignoreBody)
    {
@@ -109,7 +110,7 @@ else if ((formParam = FindAnnotation.findAnnotation(annotations,
       else if ((/* form = */FindAnnotation.findAnnotation(annotations,
               Form.class)) != null)
       {
-         processor = new FormProcessor(type, providerFactory);
+         processor = new FormProcessor(type, configuration);
       }
       else if ((FindAnnotation.findAnnotation(annotations,
               Context.class)) != null)",2012-07-30T22:39:40Z,185
"@@ -34,7 +34,7 @@ public void process(ClientInvocationBuilder request, Object object)
       }
       else
       {
-         request.cookie(new Cookie(cookieName, request.getInvocation().getClient().providerFactory().toString(object)));
+         request.cookie(new Cookie(cookieName, request.getInvocation().getConfiguration().toString(object)));
       }
    }
 }",2012-07-30T22:39:40Z,507
"@@ -38,7 +38,7 @@ protected ClientInvocationBuilder apply(ClientInvocationBuilder target, Object o
          form = new Form();
          target.getInvocation().setEntity(Entity.form(form));
       }
-      form.param(paramName, target.getInvocation().getClient().providerFactory().toString(object));
+      form.param(paramName, target.getInvocation().getConfiguration().toString(object));
       return target;
    }
 ",2012-07-30T22:39:40Z,186
"@@ -29,6 +29,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
+import java.util.Set;
 
 /**
  * Allow applications to push/pop provider factories onto the stack
@@ -55,6 +56,26 @@ public ResteasyProviderFactory getDelegate()
       return factory;
    }
 
+
+
+   @Override
+   public Set<Class<?>> getProviderClasses()
+   {
+      return getDelegate().getProviderClasses();
+   }
+
+   @Override
+   public Set<Object> getProviderInstances()
+   {
+      return getDelegate().getProviderInstances();
+   }
+
+   @Override
+   public ResteasyProviderFactory getParent()
+   {
+      return getDelegate().getParent();
+   }
+
    @Override
    public String toString(Object object)
    {
@@ -288,6 +309,12 @@ public <T> ContextResolver<T> getContextResolver(Class<T> contextType, MediaType
       return getDelegate().getContextResolver(contextType, mediaType);
    }
 
+   @Override
+   public <T> T createProviderInstance(Class<? extends T> clazz)
+   {
+      return getDelegate().createProviderInstance(clazz);
+   }
+
    @Override
    public void registerProvider(Class provider, boolean isBuiltin)
    {",2012-07-30T22:39:40Z,159
"@@ -15,12 +15,8 @@
 public interface InjectorFactory
 {
    ConstructorInjector createConstructor(Constructor constructor);
-
    PropertyInjector createPropertyInjector(Class resourceClass);
-
    MethodInjector createMethodInjector(Class root, Method method);
-
    ValueInjector createParameterExtractor(Class injectTargetClass, AccessibleObject injectTarget, Class type, Type genericType, Annotation[] annotations);
-
    ValueInjector createParameterExtractor(Class injectTargetClass, AccessibleObject injectTarget, Class type, Type genericType, Annotation[] annotations, boolean useDefault);
 }",2012-07-30T22:39:40Z,59
"@@ -183,6 +183,17 @@ public ResteasyProviderFactory()
       initialize();
    }
 
+   /**
+    * Copies a specific component registry when a new
+    * provider is added. Otherwise delegates to the parent.
+    *
+    * @param parent
+    */
+   public ResteasyProviderFactory(ResteasyProviderFactory parent)
+   {
+      this.parent = parent;
+   }
+
    protected void initialize()
    {
       providerClasses = new HashSet<Class<?>>();
@@ -661,7 +672,7 @@ public void addHeaderDelegate(Class clazz, HeaderDelegate header)
 
    protected void addMessageBodyReader(Class<? extends MessageBodyReader> provider, boolean isBuiltin)
    {
-      MessageBodyReader reader = getProviderInstance(provider);
+      MessageBodyReader reader = createProviderInstance(provider);
       addMessageBodyReader(reader, provider, isBuiltin);
    }
 
@@ -709,7 +720,7 @@ protected void addMessageBodyReader(MessageBodyReader provider, Class providerCl
 
    protected void addMessageBodyWriter(Class<? extends MessageBodyWriter> provider, boolean isBuiltin)
    {
-      MessageBodyWriter writer = getProviderInstance(provider);
+      MessageBodyWriter writer = createProviderInstance(provider);
       addMessageBodyWriter(writer, provider, isBuiltin);
    }
 
@@ -765,7 +776,7 @@ public <T> MessageBodyReader<T> getMessageBodyReader(Class<T> type, Type generic
 
    protected void addExceptionMapper(Class<? extends ExceptionMapper> providerClass)
    {
-      ExceptionMapper provider = getProviderInstance(providerClass);
+      ExceptionMapper provider = createProviderInstance(providerClass);
       addExceptionMapper(provider, providerClass);
    }
 
@@ -827,7 +838,7 @@ public List<ClientErrorInterceptor> getClientErrorInterceptors()
 
    protected void addContextResolver(Class<? extends ContextResolver> resolver, boolean builtin)
    {
-      ContextResolver writer = getProviderInstance(resolver);
+      ContextResolver writer = createProviderInstance(resolver);
       addContextResolver(writer, resolver, builtin);
    }
 
@@ -887,7 +898,7 @@ public void injectProperties(Object o)
 
    protected void addStringConverter(Class<? extends StringConverter> resolver)
    {
-      StringConverter writer = getProviderInstance(resolver);
+      StringConverter writer = createProviderInstance(resolver);
       addStringConverter(writer, resolver);
    }
 
@@ -962,7 +973,7 @@ public <T> StringParameterUnmarshaller<T> createStringParameterUnmarshaller(Clas
       if (getStringParameterUnmarshallers().size() == 0) return null;
       Class<? extends StringParameterUnmarshaller> un = getStringParameterUnmarshallers().get(clazz);
       if (un == null) return null;
-      StringParameterUnmarshaller<T> provider = getProviderInstance(un);
+      StringParameterUnmarshaller<T> provider = createProviderInstance(un);
       injectProperties(provider);
       return provider;
 
@@ -993,7 +1004,7 @@ public String toString(Object object)
    }
 
    /**
-    * COnvert an object to a header string.  First try StringConverter, then HeaderDelegate, then object.toString()
+    * Convert an object to a header string.  First try StringConverter, then HeaderDelegate, then object.toString()
     *
     * @param object
     * @return
@@ -1014,8 +1025,6 @@ public String toHeaderString(Object object)
 
    }
 
-
-
    /**
     * Register a @Provider class.  Can be a MessageBodyReader/Writer or ExceptionMapper.
     *
@@ -1477,7 +1486,14 @@ public T getContext(Class type)
       };
    }
 
-   protected <T> T getProviderInstance(Class<? extends T> clazz)
+   /**
+    * Create an instance of a class using provider allocation rules of the specification as well as the InjectorFactory
+    *
+    * @param clazz
+    * @param <T>
+    * @return
+    */
+   public <T> T createProviderInstance(Class<? extends T> clazz)
    {
       Constructor<?> constructor = PickConstructor.pickSingletonConstructor(clazz);
       if (constructor == null)",2012-07-30T22:39:40Z,25
"@@ -37,7 +37,7 @@ public class SseEventSourceImpl implements SseEventSource
 
    private final long reconnectDelay;
 
-   private final ScheduledExecutorService executor;
+   private final SseEventSourceScheduler sseEventSourceScheduler;
 
    private enum State {
       PENDING, OPEN, CLOSED
@@ -138,12 +138,11 @@ private SseEventSourceImpl(final WebTarget target, String name, long reconnectDe
          {
             scheduledExecutor = ((ResteasyWebTarget) target).getResteasyClient().getScheduledExecutor();
          }
-         this.executor = scheduledExecutor != null ? scheduledExecutor : Executors
-               .newSingleThreadScheduledExecutor(new DaemonThreadFactory(name));
+         this.sseEventSourceScheduler = new SseEventSourceScheduler(scheduledExecutor, name);
       }
       else
       {
-         this.executor = executor;
+         this.sseEventSourceScheduler = new SseEventSourceScheduler(executor, name);
       }
    
       if (open)
@@ -152,30 +151,6 @@ private SseEventSourceImpl(final WebTarget target, String name, long reconnectDe
       }
    }
 
-   private static class DaemonThreadFactory implements ThreadFactory
-  {
-
-      private final ThreadGroup group;
-
-      private final AtomicInteger threadNumber = new AtomicInteger(1);
-
-      private final String namePrefix;
-      
-      DaemonThreadFactory(String name)
-      {
-         SecurityManager s = System.getSecurityManager();
-         group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
-         namePrefix = name + ""-thread-"";
-      }
-
-      public Thread newThread(Runnable r)
-      {
-         Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
-         t.setDaemon(true);
-         return t;
-      }
-   }
-
    @Override
    public void open()
    {
@@ -194,7 +169,7 @@ public void open(String lastEventId, String verb, Entity<?> entity, MediaType...
          throw new IllegalStateException(Messages.MESSAGES.eventSourceIsNotReadyForOpen());
       }
       EventHandler handler = new EventHandler(reconnectDelay, lastEventId, verb, entity, mediaTypes);
-      executor.submit(handler);
+      sseEventSourceScheduler.schedule(handler, 0, TimeUnit.SECONDS);
       handler.awaitConnected();
    }
 
@@ -255,10 +230,7 @@ public boolean close(final long timeout, final TimeUnit unit)
       internalClose();
       try
       {
-         if (!executor.awaitTermination(timeout, unit))
-         {
-            return false;
-         }
+         return sseEventSourceScheduler.awaitTermination(timeout, unit);
       }
       catch (InterruptedException e)
       {
@@ -268,8 +240,6 @@ public boolean close(final long timeout, final TimeUnit unit)
          Thread.currentThread().interrupt();
          return false;
       }
-
-      return true;
    }
    
    private void internalClose()
@@ -291,7 +261,7 @@ private void internalClose()
             });
          }
       }
-      executor.shutdownNow();
+      sseEventSourceScheduler.shutdownNow();
       onCompleteConsumers.forEach(Runnable::run);
    }
 
@@ -490,14 +460,7 @@ private void reconnect(final long delay)
          }
 
          EventHandler processor = new EventHandler(this);
-         if (delay > 0)
-         {
-            executor.schedule(processor, delay, TimeUnit.MILLISECONDS);
-         }
-         else
-         {
-            executor.submit(processor);
-         }
+         sseEventSourceScheduler.schedule(processor, delay, TimeUnit.MILLISECONDS);
       }
    }
 ",2018-09-06T07:59:34Z,508
"@@ -0,0 +1,151 @@
+package org.jboss.resteasy.plugins.providers.sse.client;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.Phaser;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 
+ * @author Nicolas NESMON
+ *
+ */
+class SseEventSourceScheduler
+{
+
+   private static class DaemonThreadFactory implements ThreadFactory
+   {
+
+      private final ThreadGroup group;
+
+      private final AtomicInteger threadNumber = new AtomicInteger(1);
+
+      private final String namePrefix;
+
+      DaemonThreadFactory(String name)
+      {
+         SecurityManager s = System.getSecurityManager();
+         group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
+         namePrefix = name + ""-thread-"";
+      }
+
+      @Override
+      public Thread newThread(Runnable r)
+      {
+         Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
+         t.setDaemon(true);
+         return t;
+      }
+   }
+
+   private final ScheduledExecutorService scheduledExecutorService;
+
+   private final boolean shutdownExecutorService;
+
+   private final Phaser phaser;
+
+   private final AtomicBoolean closed;
+
+   SseEventSourceScheduler(ScheduledExecutorService scheduledExecutorService, String threadName)
+   {
+      this.scheduledExecutorService = scheduledExecutorService == null
+            ? Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory(threadName))
+            : scheduledExecutorService;
+      this.shutdownExecutorService = scheduledExecutorService == null;
+      this.phaser = new Phaser(1);
+      this.closed = new AtomicBoolean(false);
+   }
+   
+   void schedule(final Runnable runnable, long delay, TimeUnit unit) throws RejectedExecutionException
+   {
+      if (this.closed.get())
+      {
+         return;
+      }
+      try
+      {
+         this.scheduledExecutorService.schedule(new Runnable()
+         {
+            @Override
+            public void run()
+            {
+               if (SseEventSourceScheduler.this.closed.get())
+               {
+                  return;
+               }
+               int registrationPhase = SseEventSourceScheduler.this.phaser.register();
+               try
+               {
+                  // If this phaser is terminated (registrationPhase < 0)
+                  // (no more registered parties) or the current
+                  // registration phase is other than 0 it means that
+                  // shutdownNow has been called already.
+                  if (registrationPhase != 0)
+                  {
+                     return;
+                  }
+                  runnable.run();
+               }
+               finally
+               {
+                  // We can invoke 'arriveAndDeregister()' safely since
+                  // this method has no effect if the phaser is already
+                  // terminated.
+                  SseEventSourceScheduler.this.phaser.arriveAndDeregister();
+               }
+            }
+         }, delay, unit);
+      }
+      catch (RejectedExecutionException e)
+      {
+         if (this.shutdownExecutorService && this.closed.get())
+         {
+            // At this stage the RejectedExecutionException can be either a
+            // normal consequence of the
+            // 'scheduledExecutorService.shutdownNow(...)' method
+            // invocation and in this case it's not an error at all, or a
+            // real error.
+            // So instead of throwing exception that may not be an
+            // unexpected error at all, it is acceptable to do nothing since
+            // user already asked for shutdown.
+            return;
+         }
+         throw e;
+      }
+   }
+
+   boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
+   {
+      if (!this.closed.get())
+      {
+         return false;
+      }
+      try
+      {
+         this.phaser.awaitAdvanceInterruptibly(0, timeout, unit);
+      }
+      catch (TimeoutException e)
+      {
+         return false;
+      }
+      return true;
+   }
+
+   void shutdownNow()
+   {
+      if (this.closed.compareAndSet(false, true))
+      {
+         this.phaser.arriveAndDeregister();
+         if (this.shutdownExecutorService)
+         {
+            this.scheduledExecutorService.shutdownNow();
+         }
+      }
+   }
+
+}
\ No newline at end of file",2018-09-06T07:59:34Z,264
"@@ -314,7 +314,6 @@ public void run()
          }
 
          SseEventInputImpl eventInput = null;
-         long delay = reconnectDelay;
          try
          {
             final Invocation.Builder requestBuilder = buildRequest(mediaTypes);
@@ -336,6 +335,7 @@ public void run()
                if (eventInput == null && !alwaysReconnect)
                {
                   internalClose();
+                  return;
                }
             }
             else
@@ -353,26 +353,29 @@ public void run()
             {
                onConnection();
                Date requestTime = new Date();
-               delay = ex.getRetryTime(requestTime).getTime() - requestTime.getTime();
+               long localReconnectDelay = ex.getRetryTime(requestTime).getTime() - requestTime.getTime();
                onErrorConsumers.forEach(consumer -> {
                   consumer.accept(ex);
                });
+               reconnect(localReconnectDelay);
             }
             else
             {
                onUnrecoverableError(ex);
             }
+            return;
          }
          catch (Throwable e)
          {
             onUnrecoverableError(e);
+            return;
          }
 
          while (!Thread.currentThread().isInterrupted() && state.get() == State.OPEN)
          {
             if (eventInput == null || eventInput.isClosed())
             {
-               reconnect(delay);
+               reconnect(reconnectDelay);
                break;
             }
             try
@@ -382,13 +385,6 @@ public void run()
                if (event != null)
                {
                   onEvent(event);
-                  if (event.isReconnectDelaySet())
-                  {
-                     delay = event.getReconnectDelay();
-                  }
-                  onEventConsumers.forEach(consumer -> {
-                     consumer.accept(event);
-                  });
                }
                //event sink closed
                else if (!alwaysReconnect)
@@ -399,7 +395,7 @@ else if (!alwaysReconnect)
             }
             catch (IOException e)
             {
-               reconnect(delay);
+               reconnect(reconnectDelay);
                break;
             }
          }
@@ -434,15 +430,17 @@ private void onUnrecoverableError(Throwable throwable)
 
       private void onEvent(final InboundSseEvent event)
       {
-         if (event == null)
-         {
-            return;
-         }
          if (event.getId() != null)
          {
             lastEventId = event.getId();
          }
-
+         if (event.isReconnectDelaySet())
+         {
+            reconnectDelay = event.getReconnectDelay();
+         }
+         onEventConsumers.forEach(consumer -> {
+            consumer.accept(event);
+         });
       }
 
       private Invocation.Builder buildRequest(MediaType... mediaTypes)",2019-04-23T05:46:01Z,508
"@@ -14,10 +14,12 @@
 import org.junit.runner.RunWith;
 
 import javax.ws.rs.ServiceUnavailableException;
+import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.Response;
+import javax.ws.rs.sse.InboundSseEvent;
 import javax.ws.rs.sse.SseEvent;
 import javax.ws.rs.sse.SseEventSource;
 import java.util.ArrayList;
@@ -116,4 +118,55 @@ public void testSseEndpointUnavailable() throws Exception {
       }
    }
 
+   /**
+    * @tpTestDetails Check that SseEventSource use last received 'retry' field value as the default reconnect delay for all future requests.
+    * @tpInfo RESTEASY-1958
+    * @tpSince RESTEasy
+    */
+   @Test
+   public void testReconnectDelayIsUsed() throws Exception
+   {
+      CountDownLatch latch = new CountDownLatch(1);
+      List<InboundSseEvent> results = new ArrayList<>();
+      AtomicInteger errorCount = new AtomicInteger();
+      Client client = ClientBuilder.newBuilder().build();
+      try
+      {
+         WebTarget target = client.target(generateURL(""/reconnect/testReconnectDelayIsUsed""));
+         SseEventSource sseEventSource = SseEventSource.target(target).reconnectingEvery(500, TimeUnit.MILLISECONDS)
+               .build();
+         sseEventSource.register(event -> {
+            results.add(event);
+         }, error -> {
+            if (error instanceof WebApplicationException)
+            {
+               if (599 == ((WebApplicationException) error).getResponse().getStatus())
+               {
+                  return;
+               }
+            }
+            errorCount.incrementAndGet();
+         }, () -> {
+            latch.countDown();
+         });
+         try (SseEventSource eventSource = sseEventSource)
+         {
+            eventSource.open();
+            boolean waitResult = latch.await(30, TimeUnit.SECONDS);
+            Assert.assertTrue(""Waiting for event to be delivered has timed out."", waitResult);
+            Assert.assertEquals(0, errorCount.get());
+            Assert.assertEquals(2, results.size());
+            Assert.assertTrue(results.get(0).isReconnectDelaySet());
+            Assert.assertEquals(TimeUnit.SECONDS.toMillis(3), results.get(0).getReconnectDelay());
+            Assert.assertFalse(results.get(1).isReconnectDelaySet());
+         }
+      }
+      finally
+      {
+         client.close();
+      }
+   }
+
+
+
 }",2019-04-23T05:46:01Z,509
"@@ -3,7 +3,9 @@
 import org.junit.Assert;
 
 import javax.ejb.Singleton;
+import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
+import javax.ws.rs.HeaderParam;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
@@ -24,6 +26,7 @@ public class SseReconnectResource {
 
    private volatile long startTime = 0L;
    private volatile long endTime = 0L;
+   private volatile long lastEventDeliveryTime;
 
    @GET
    @Path(""/defaultReconnectDelay"")
@@ -65,4 +68,49 @@ public void sendMessage(@Context SseEventSink sink, @Context Sse sse)
          }
       }
    }
+
+   @GET
+   @Path(""/testReconnectDelayIsUsed"")
+   @Produces(MediaType.SERVER_SENT_EVENTS)
+   public void testReconnectDelay(@Context SseEventSink sseEventSink, @Context Sse sse,
+         @HeaderParam(HttpHeaders.LAST_EVENT_ID_HEADER) @DefaultValue("""") String lastEventId)
+   {
+      switch (lastEventId)
+      {
+         case ""0"" :
+            checkReconnectDelay(TimeUnit.SECONDS.toMillis(3));
+            try (SseEventSink s = sseEventSink)
+            {
+               sendEvent(s, sse, ""1"", null);
+            }
+            break;
+         case ""1"" :
+            checkReconnectDelay(TimeUnit.SECONDS.toMillis(3));
+            throw new WebApplicationException(599);
+         default :
+            try (SseEventSink s = sseEventSink)
+            {
+               sendEvent(s, sse, ""0"", TimeUnit.SECONDS.toMillis(3));
+            }
+            break;
+      }
+   }
+
+   private void sendEvent(SseEventSink sseEventSink, Sse sse, String eventId, Long reconnectDelayInMs)
+   {
+      OutboundSseEvent.Builder outboundSseEventBuilder = sse.newEventBuilder().data(""Event "" + eventId).id(eventId);
+      if (reconnectDelayInMs != null)
+      {
+         outboundSseEventBuilder.reconnectDelay(reconnectDelayInMs);
+      }
+      sseEventSink.send(outboundSseEventBuilder.build());
+      lastEventDeliveryTime = System.currentTimeMillis();
+   }
+
+   private void checkReconnectDelay(long expectedDelayInMs)
+   {
+      long currentDelayInMs = System.currentTimeMillis() - lastEventDeliveryTime;
+      Assert.assertTrue(currentDelayInMs >= expectedDelayInMs);
+   }
+
 }",2019-04-23T05:46:01Z,510
"@@ -23,6 +23,7 @@
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
 import org.jboss.resteasy.spi.Dispatcher;
 import org.jboss.resteasy.core.SynchronousDispatcher;
 import org.jboss.resteasy.core.SynchronousExecutionContext;
@@ -185,7 +186,7 @@ public HostnameVerifier getHostnameVerifier()
       return null;
    }
 
-   public static class InMemoryClientResponse extends ClientResponse
+   public static class InMemoryClientResponse extends FinalizedClientResponse
    {
       private InputStream stream;
 ",2019-12-17T12:00:17Z,249
"@@ -4,10 +4,10 @@
 import java.io.InputStream;
 
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
-import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
 import org.jboss.resteasy.tracing.RESTEasyTracingLogger;
 
-class JettyClientResponse extends ClientResponse {
+class JettyClientResponse extends FinalizedClientResponse {
    private final Runnable cancel;
    private InputStream stream;
 ",2019-12-17T12:00:17Z,10
"@@ -33,6 +33,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
+import java.util.function.BiFunction;
 
 import static java.util.Objects.requireNonNull;
 import static org.jboss.resteasy.util.HttpHeaderNames.CONTENT_LENGTH;
@@ -45,19 +46,22 @@ public class ReactorNettyClientHttpEngine implements AsyncClientHttpEngine {
     private final ChannelGroup channelGroup;
     private final ConnectionProvider connectionProvider;
     private final Optional<Duration> requestTimeout;
+    private final BiFunction<ClientConfiguration, InputStream, ClientResponse> fnClientResponse;
 
     /**
      * Constructor for ReactorNettyClientHttpEngine
      *
-     * @param httpClient The {@link HttpClient} instance to be used by this {@link AsyncClientHttpEngine}
-     * @param channelGroup The {@link ChannelGroup} instance used by the provided {@link HttpClient}
+     * @param httpClient         The {@link HttpClient} instance to be used by this {@link AsyncClientHttpEngine}
+     * @param channelGroup       The {@link ChannelGroup} instance used by the provided {@link HttpClient}
      * @param connectionProvider The {@link ConnectionProvider} instance used to create the provided {@link HttpClient}
-     * @param requestTimeout The {@link Optional<Duration>} instance used to configure requestTimeout on response
+     * @param requestTimeout     The {@link Optional<Duration>} instance used to configure requestTimeout on response
+     * @param useFinalizedResponse Used to configure for using {@link RestEasyClientResponse} with `finalize` method
      */
     private ReactorNettyClientHttpEngine(final HttpClient httpClient,
-                                        final ChannelGroup channelGroup,
-                                        final ConnectionProvider connectionProvider,
-                                        final Optional<Duration> requestTimeout) {
+                                         final ChannelGroup channelGroup,
+                                         final ConnectionProvider connectionProvider,
+                                         final Optional<Duration> requestTimeout,
+                                         final Boolean useFinalizedResponse) {
         this.httpClient = requireNonNull(httpClient);
         this.channelGroup = requireNonNull(channelGroup);
         this.connectionProvider = requireNonNull(connectionProvider);
@@ -70,19 +74,38 @@ private ReactorNettyClientHttpEngine(final HttpClient httpClient,
                     if(duration.isZero())
                         throw new IllegalArgumentException(""Required non zero value for requestTimeout"");
                 });
+
+        this.fnClientResponse = useFinalizedResponse ?
+                FinalizedRestEasyClientResponse::new
+                : RestEasyClientResponse::new;
     }
 
     public ReactorNettyClientHttpEngine(final HttpClient httpClient,
                                         final ChannelGroup channelGroup,
                                         final ConnectionProvider connectionProvider) {
-        this(httpClient, channelGroup, connectionProvider, Optional.empty());
+        this(httpClient, channelGroup, connectionProvider, Optional.empty(), false);
     }
 
     public ReactorNettyClientHttpEngine(final HttpClient httpClient,
                                         final ChannelGroup channelGroup,
                                         final ConnectionProvider connectionProvider,
                                         final Duration requestTimeout) {
-        this(httpClient, channelGroup, connectionProvider, Optional.of(requestTimeout));
+        this(httpClient, channelGroup, connectionProvider, Optional.of(requestTimeout), false);
+    }
+
+    public ReactorNettyClientHttpEngine(final HttpClient httpClient,
+                                        final ChannelGroup channelGroup,
+                                        final ConnectionProvider connectionProvider,
+                                        final Boolean useResponseFinalize) {
+        this(httpClient, channelGroup, connectionProvider, Optional.empty(), useResponseFinalize);
+    }
+
+    public ReactorNettyClientHttpEngine(final HttpClient httpClient,
+                                        final ChannelGroup channelGroup,
+                                        final ConnectionProvider connectionProvider,
+                                        final Duration requestTimeout,
+                                        final Boolean useResponseFinalize) {
+        this(httpClient, channelGroup, connectionProvider, Optional.of(requestTimeout), useResponseFinalize);
     }
 
     @Override
@@ -262,7 +285,7 @@ private ClientResponse toRestEasyResponse(final ClientConfiguration clientConfig
                                               final HttpClientResponse reactorNettyResponse,
                                               final InputStream inputStream) {
 
-        final ClientResponse restEasyClientResponse = new RestEasyClientResponse(clientConfiguration, inputStream);
+        final ClientResponse restEasyClientResponse = fnClientResponse.apply(clientConfiguration, inputStream);
         restEasyClientResponse.setStatus(reactorNettyResponse.status().code());
 
         final MultivaluedMap<String, Object> resteasyHeaders =  restEasyClientResponse.getHeaders();
@@ -272,7 +295,7 @@ private ClientResponse toRestEasyResponse(final ClientConfiguration clientConfig
         return restEasyClientResponse;
     }
 
-    private class RestEasyClientResponse extends ClientResponse {
+    private static class RestEasyClientResponse extends ClientResponse {
 
         private InputStream is;
 
@@ -316,4 +339,25 @@ public void releaseConnection(boolean consumeInputStream) throws IOException {
             }
         }
     }
+
+    // RestEasyClientResponse that adds a finalize method as safety net
+    private class FinalizedRestEasyClientResponse extends RestEasyClientResponse {
+
+        FinalizedRestEasyClientResponse(final ClientConfiguration configuration, final InputStream is) {
+            super(configuration, is);
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+
+            if (isClosed()) return;
+            try {
+                log.warn(""RestEasyClientResponse was leaked. Ensure all resources are freed via calling close()"");
+                close();
+            } catch (Exception e) {
+                log.warn(""Exception while close() during finalize()"", e);
+            }
+        }
+
+    }
 }
\ No newline at end of file",2019-12-17T12:00:17Z,250
"@@ -44,6 +44,7 @@
 import static org.hamcrest.core.IsNot.not;
 import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -159,6 +160,52 @@ public void testTimeoutWhileReadingBytesFromWireDoesNotLeakMemory() throws Execu
         client.close();
     }
 
+    @Test
+    public void testLeakDetectionOnMissingClientResponseClose() throws Exception {
+        final Client client = setupClient(Duration.ofSeconds(10), false);
+        for(int i=0; i < CALL_COUNT; i++) {
+            final Response response = client
+                .target(""/hello"")
+                .request()
+                .rx()
+                .get()
+                .toCompletableFuture()
+                .get(10, TimeUnit.SECONDS);
+        }
+        // It's a ByteBuf leak that is actually asserted here on missing close on response.
+        assertThat(errContent.toString(), containsString(""LEAK""));
+        client.close();
+    }
+
+    @Test
+    public void testRestEasyClientResponseWithFinalize() throws Exception {
+        final Client client = setupClient(Duration.ofSeconds(10), true);
+        final Response response = client
+                .target(""/hello"")
+                .request()
+                .rx()
+                .get()
+                .toCompletableFuture()
+                .get(10, TimeUnit.SECONDS);
+
+        assertNotNull(response.getClass().getDeclaredMethod(""finalize""));
+        assertTrue(response.getClass().getSimpleName().contains(""FinalizedRestEasyClientResponse""));
+    }
+
+    @Test(expected = java.lang.NoSuchMethodException.class)
+    public void testDefaultRestEasyClientResponseWithoutFinalize() throws Exception {
+        final Client client = setupClient(Duration.ofSeconds(10));
+        final Response response = client
+                .target(""/hello"")
+                .request()
+                .rx()
+                .get()
+                .toCompletableFuture()
+                .get(10, TimeUnit.SECONDS);
+
+        response.getClass().getDeclaredMethod(""finalize"");
+    }
+
     private static ByteBuf toByteBuf(final int i) {
         final ByteArrayOutputStream out = new ByteArrayOutputStream();
         try {
@@ -196,6 +243,10 @@ private static DisposableServer setupMockServer() {
     }
 
     private static Client setupClient(final Duration timeout) {
+        return setupClient(timeout, false);
+    }
+
+    private static Client setupClient(final Duration timeout, final Boolean finalizedResponse) {
 
         final String connectionPoolName = ""ReactorNettyClientHttpEngineByteBufReleaseTest-Connection-Pool"";
 
@@ -216,7 +267,8 @@ private static Client setupClient(final Duration timeout) {
                         httpClient,
                         new DefaultChannelGroup(new DefaultEventExecutor()),
                         HttpResources.get(),
-                        timeout);
+                        timeout,
+                        finalizedResponse);
 
         final ClientBuilder builder = ClientBuilder.newBuilder();
         final ResteasyClientBuilder clientBuilder = (ResteasyClientBuilder)builder;",2019-12-17T12:00:17Z,251
"@@ -560,6 +560,16 @@ public void testRxInvocationWithTimeoutConfig() throws ExecutionException, Inter
         assertEquals(200, response.getStatus());
         assertEquals(HELLO_WORLD, response.readEntity(String.class));
     }
+    @Test
+    public void testFinalizeResponse() throws Exception {
+        final Client timeoutClient = setupClient(HttpClient.create(), Duration.ofMillis(100));
+
+        final CompletionStage<Response> completionStage = timeoutClient.target(url(""/hello"")).request().rx().get();
+        final Response response = completionStage.toCompletableFuture().get();
+        assertEquals(200, response.getStatus());
+        assertEquals(HELLO_WORLD, response.readEntity(String.class));
+    }
+
 
     private static String incrementAge(final String json) {
         final int length = json.length();",2019-12-17T12:00:17Z,252
"@@ -33,6 +33,8 @@
 
 import io.vertx.core.http.HttpClient;
 import io.vertx.core.http.HttpHeaders;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
+import org.jboss.resteasy.tracing.RESTEasyTracingLogger;
 import org.jboss.resteasy.util.CaseInsensitiveMap;
 
 public class VertxClientHttpEngine implements AsyncClientHttpEngine {
@@ -258,12 +260,12 @@ private ClientResponse toRestEasyResponse(ClientConfiguration clientConfiguratio
 
         InputStreamAdapter adapter = new InputStreamAdapter(clientResponse, 4 * 1024);
 
-        class RestEasyClientResponse extends ClientResponse {
+        class RestEasyClientResponse extends FinalizedClientResponse {
 
             private InputStream is;
 
             private RestEasyClientResponse(final ClientConfiguration configuration) {
-                super(configuration);
+                super(configuration, RESTEasyTracingLogger.empty());
                 this.is = adapter;
             }
 ",2019-12-17T12:00:17Z,253
"@@ -57,6 +57,7 @@
 import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
 import org.jboss.resteasy.tracing.RESTEasyTracingLogger;
 import org.jboss.resteasy.util.CaseInsensitiveMap;
 
@@ -667,7 +668,7 @@ public void failed(Exception ex)
    /**
     * ClientResponse with surefire releaseConnection
     */
-   private static class ConnectionResponse extends ClientResponse
+   private static class ConnectionResponse extends FinalizedClientResponse
    {
 
       private InputStream connection;",2019-12-17T12:00:17Z,254
"@@ -23,6 +23,7 @@
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
 import org.jboss.resteasy.microprofile.config.ResteasyConfigProvider;
 import org.jboss.resteasy.util.CaseInsensitiveMap;
 
@@ -289,7 +290,7 @@ public HttpResponse run() throws Exception {
          cleanUpAfterExecute(httpMethod);
       }
 
-      ClientResponse response = new ClientResponse(request.getClientConfiguration(), request.getTracingLogger())
+      ClientResponse response = new FinalizedClientResponse(request.getClientConfiguration(), request.getTracingLogger())
       {
          InputStream stream;
 ",2019-12-17T12:00:17Z,255
"@@ -4,6 +4,7 @@
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
 import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
 import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+import org.jboss.resteasy.client.jaxrs.internal.FinalizedClientResponse;
 import org.jboss.resteasy.tracing.RESTEasyTracingLogger;
 import org.jboss.resteasy.util.CaseInsensitiveMap;
 
@@ -58,7 +59,7 @@ public Response invoke(Invocation inv)
       }
 
       //Creating response with stream content
-      ClientResponse response = new ClientResponse(request.getClientConfiguration(), RESTEasyTracingLogger.empty())
+      ClientResponse response = new FinalizedClientResponse(request.getClientConfiguration(), RESTEasyTracingLogger.empty())
       {
          private InputStream stream;
 ",2019-12-17T12:00:17Z,256
"@@ -23,7 +23,7 @@
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class AbortedResponse extends ClientResponse
+public class AbortedResponse extends FinalizedClientResponse
 {
    @SuppressWarnings(""unchecked"")
    public AbortedResponse(final ClientConfiguration configuration,final Response response)",2019-12-17T12:00:17Z,257
"@@ -147,18 +147,6 @@ public void close()
       }
    }
 
-   @Override
-   // This method is synchronized to protect against premature calling of finalize by the GC
-   protected synchronized void finalize() throws Throwable
-   {
-      if (isClosed()) return;
-      try {
-         close();
-      }
-      catch (Exception ignored) {
-      }
-   }
-
    @Override
    protected HeaderValueProcessor getHeaderValueProcessor()
    {",2019-12-17T12:00:17Z,22
"@@ -0,0 +1,29 @@
+package org.jboss.resteasy.client.jaxrs.internal;
+
+import org.jboss.resteasy.tracing.RESTEasyTracingLogger;
+
+/**
+ * A class that adds a {@link Object#finalize) method to the {@link ClientResponse} as a last ditch backstop to prevent
+ * leaking resources with ill-behaved clients.  Use of finalize could incur a significant performance penalty.
+ */
+public abstract class FinalizedClientResponse extends ClientResponse {
+
+    protected FinalizedClientResponse(final ClientConfiguration configuration,
+                                      final RESTEasyTracingLogger tracingLogger)
+    {
+        super(configuration, tracingLogger);
+    }
+
+    @Override
+    // This method is synchronized to protect against premature calling of finalize by the GC
+    protected synchronized void finalize() throws Throwable
+    {
+        if (isClosed()) return;
+        try {
+            close();
+        }
+        catch (Exception ignored) {
+        }
+    }
+
+}",2019-12-17T12:00:17Z,258
"@@ -0,0 +1,110 @@
+package org.jboss.resteasy.test.nextgen.providers;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.StandardCharsets;
+
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Form;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
+
+import org.jboss.resteasy.core.Dispatcher;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.test.EmbeddedContainer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import junit.framework.Assert;
+
+/**
+ * RESTEASY-477
+ * 
+ * @author <a href=""mailto:ron.sigal@jboss.com"">Ron Sigal</a>
+ * @date
+ */
+public class FormUrlEncodedCharsetTest
+{
+   protected static ResteasyDeployment deployment;
+   protected static Dispatcher dispatcher;
+   protected static MediaType testMediaType8 = MediaType.APPLICATION_FORM_URLENCODED_TYPE.withCharset(StandardCharsets.UTF_8.displayName());
+   protected static MediaType testMediaType16 = MediaType.APPLICATION_FORM_URLENCODED_TYPE.withCharset(StandardCharsets.UTF_16.displayName());
+   protected static String charsetName;
+   protected static String alephBetGimel = ""אבג"";
+   
+   @Path(""test"")
+   public static class TestResource
+   {
+      @POST
+      public Response form(MultivaluedMap<String, String> form) throws UnsupportedEncodingException
+      {
+         String s = form.getFirst(""name"");
+         System.out.println(""s: "" + s);      
+         return Response.ok().entity(s).build();
+      }
+   }
+   
+   @Before
+   public void before() throws Exception
+   {
+      deployment = EmbeddedContainer.start();
+      dispatcher = deployment.getDispatcher();
+      deployment.getRegistry().addPerRequestResource(TestResource.class);
+   }
+   
+   @After
+   public void after() throws Exception
+   {
+      EmbeddedContainer.stop();
+      dispatcher = null;
+      deployment = null;
+   }
+
+   @Test
+   public void testFormDefault() throws UnsupportedEncodingException
+   {
+      Client client = ClientBuilder.newClient();;
+      WebTarget target = client.target(""http://localhost:8081/test"");
+      Form form = new Form();
+      form.param(""name"", alephBetGimel);
+      Entity<Form> entity = Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE);
+      Response response = target.request().post(entity);
+      String result = response.readEntity(String.class);
+      System.out.println(""result: "" + result);
+      Assert.assertEquals(result, alephBetGimel);
+   }
+   
+   @Test
+   public void testFormUTF8() throws UnsupportedEncodingException
+   {
+      Client client = ClientBuilder.newClient();;
+      WebTarget target = client.target(""http://localhost:8081/test"");
+      Form form = new Form();
+      form.param(""name"", alephBetGimel);
+      Entity<Form> entity = Entity.entity(form, testMediaType8);
+      Response response = target.request().post(entity);
+      String result = response.readEntity(String.class);
+      System.out.println(""result: "" + result);
+      Assert.assertEquals(result, alephBetGimel);
+   }
+   
+   @Test
+   public void testFormUTF16() throws UnsupportedEncodingException
+   {
+      Client client = ClientBuilder.newClient();;
+      WebTarget target = client.target(""http://localhost:8081/test"");
+      Form form = new Form();
+      form.param(""name"", alephBetGimel);
+      Entity<Form> entity = Entity.entity(form, testMediaType16);
+      Response response = target.request().post(entity);
+      String result = response.readEntity(String.class);
+      System.out.println(""result: "" + result);
+      Assert.assertEquals(result, alephBetGimel);
+   }
+}",2016-05-11T00:54:31Z,259
"@@ -58,16 +58,25 @@ public MultivaluedMap readFrom(Class<MultivaluedMap> type, Type genericType, Ann
    {
       if (NoContent.isContentLengthZero(httpHeaders)) return new MultivaluedMapImpl<String, String>();
       boolean encoded = FindAnnotation.findAnnotation(annotations, Encoded.class) != null;
-      if (encoded) return parseForm(entityStream);
-      else return Encode.decode(parseForm(entityStream));
+      String charset = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);
+      if (charset == null)
+      {
+         charset = ""UTF-8"";
+      }
+      if (encoded) return parseForm(entityStream, charset);
+      else return Encode.decode(parseForm(entityStream, charset), charset);
    }
 
-   public static MultivaluedMap<String, String> parseForm(InputStream entityStream)
+   public static MultivaluedMap<String, String> parseForm(InputStream entityStream, String charset)
            throws IOException
    {
       char[] buffer = new char[100];
       StringBuffer buf = new StringBuffer();
-      BufferedReader reader = new BufferedReader(new InputStreamReader(entityStream));
+      if (charset == null)
+      {
+         charset = ""UTF-8"";
+      }
+      BufferedReader reader = new BufferedReader(new InputStreamReader(entityStream, charset));
 
       int wasRead = 0;
       do
@@ -121,23 +130,28 @@ public long getSize(MultivaluedMap stringStringMultivaluedMap, Class<?> type, Ty
    public void writeTo(MultivaluedMap data, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException
    {
       MultivaluedMap<String, String> formData = (MultivaluedMap<String, String>)data;
+      String charset = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);
+      if (charset == null)
+      {
+         charset = ""UTF-8"";
+      }
       boolean encoded = FindAnnotation.findAnnotation(annotations, Encoded.class) != null;
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
+      OutputStreamWriter writer = new OutputStreamWriter(baos, charset);
 
       boolean first = true;
       for (Map.Entry<String, List<String>> entry : formData.entrySet())
       {
          String encodedName = entry.getKey();
-         if (!encoded) encodedName = URLEncoder.encode(entry.getKey(), ""UTF-8"");
+         if (!encoded) encodedName = URLEncoder.encode(entry.getKey(), charset);
 
          for (String value : entry.getValue())
          {
             if (first) first = false;
             else writer.write(""&"");
             if (!encoded)
             {
-               value = URLEncoder.encode(value, ""UTF-8"");
+               value = URLEncoder.encode(value, charset);
             }
             writer.write(encodedName);
             writer.write(""="");",2016-05-11T00:54:31Z,260
"@@ -45,11 +45,12 @@ public MultivaluedMap<String, String> getFormParameters()
          formParameters = Encode.encode(decodedFormParameters);
          return formParameters;
       }
-      if (getHttpHeaders().getMediaType().isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
+      MediaType mt = getHttpHeaders().getMediaType();
+      if (mt.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded"")))
       {
          try
          {
-            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream(), mt.getParameters().get(MediaType.CHARSET_PARAMETER));
          }
          catch (IOException e)
          {",2016-05-11T00:54:31Z,261
"@@ -72,11 +72,12 @@ public MultivaluedMap<String, String> getMutableHeaders()
    public MultivaluedMap<String, String> getPutFormParameters()
    {
       if (formParameters != null) return formParameters;
-      if (MediaType.APPLICATION_FORM_URLENCODED_TYPE.isCompatible(getHttpHeaders().getMediaType()))
+      MediaType mt = getHttpHeaders().getMediaType();
+      if (MediaType.APPLICATION_FORM_URLENCODED_TYPE.isCompatible(mt))
       {
          try
          {
-            formParameters = FormUrlEncodedProvider.parseForm(getInputStream());
+            formParameters = FormUrlEncodedProvider.parseForm(getInputStream(), mt.getParameters().get(MediaType.CHARSET_PARAMETER));
          }
          catch (IOException e)
          {",2016-05-11T00:54:31Z,27
"@@ -492,6 +492,38 @@ public static MultivaluedMap<String, String> decode(MultivaluedMap<String, Strin
       }
       return decoded;
    }
+   
+   /**
+    * decode an encoded map
+    *
+    * @param map
+    * @param charset
+    * @return
+    */
+   public static MultivaluedMap<String, String> decode(MultivaluedMap<String, String> map, String charset)
+   {
+      if (charset == null)
+      {
+         charset = UTF_8;
+      }
+      MultivaluedMapImpl<String, String> decoded = new MultivaluedMapImpl<String, String>();
+      for (Map.Entry<String, List<String>> entry : map.entrySet())
+      {
+         List<String> values = entry.getValue();
+         for (String value : values)
+         {
+            try
+            {
+               decoded.add(URLDecoder.decode(entry.getKey(), charset), URLDecoder.decode(value, charset));
+            }
+            catch (UnsupportedEncodingException e)
+            {
+               throw new RuntimeException(e);
+            }
+         }
+      }
+      return decoded;
+   }
 
    public static MultivaluedMap<String, String> encode(MultivaluedMap<String, String> map)
    {",2016-05-11T00:54:31Z,43
"@@ -10,6 +10,8 @@
 import org.jboss.resteasy.client.jaxrs.i18n.LogMessages;
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
 import org.jboss.resteasy.client.jaxrs.spi.ClientConfigProvider;
+import org.jboss.resteasy.concurrent.ContextualExecutorService;
+import org.jboss.resteasy.concurrent.ContextualExecutors;
 import org.jboss.resteasy.core.providerfactory.ResteasyProviderFactoryDelegate;
 import org.jboss.resteasy.plugins.interceptors.AcceptEncodingGZIPFilter;
 import org.jboss.resteasy.plugins.providers.RegisterBuiltin;
@@ -33,7 +35,6 @@
 import java.util.Map;
 import java.util.ServiceLoader;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
@@ -398,14 +399,6 @@ public ResteasyClient build()
          config.property(entry.getKey(), entry.getValue());
       }
 
-      ExecutorService executor = asyncExecutor;
-
-      if (executor == null)
-      {
-         cleanupExecutor = true;
-         executor = Executors.newCachedThreadPool();
-      }
-
       boolean resetProxy = false;
       if (this.defaultProxy == null) {
          resetProxy = true;
@@ -420,7 +413,8 @@ public ResteasyClient build()
       if (serviceLoaderIterator.hasNext()) {
          config.register(new ClientConfigProviderFilter(serviceLoaderIterator.next()), Priorities.AUTHENTICATION);
       }
-      return createResteasyClient(engine, executor, cleanupExecutor, scheduledExecutorService, config);
+      final ContextualExecutorService executor = getExecutorService();
+      return createResteasyClient(engine, executor, !executor.isManaged(), ContextualExecutors.wrap(scheduledExecutorService, true), config);
 
    }
 
@@ -450,7 +444,7 @@ private void setProxyIfNeeded(ClientConfiguration clientConfig) {
    }
 
    protected ResteasyClient createResteasyClient(ClientHttpEngine engine,ExecutorService executor, boolean cleanupExecutor, ScheduledExecutorService scheduledExecutorService, ClientConfiguration config ) {
-      return new ResteasyClientImpl(engine, executor, cleanupExecutor, scheduledExecutorService, config);
+      return new ResteasyClientImpl(engine, executor, cleanupExecutor, ContextualExecutors.wrap(scheduledExecutorService), config);
    }
 
    @Override
@@ -726,4 +720,11 @@ public ResteasyClientBuilder setFollowRedirects(boolean followRedirects) {
    public boolean isFollowRedirects() {
       return followRedirects;
    }
+
+   private ContextualExecutorService getExecutorService() {
+      if (asyncExecutor != null) {
+         return ContextualExecutors.wrap(asyncExecutor, cleanupExecutor);
+      }
+      return ContextualExecutors.threadPool();
+   }
 }",2021-08-11T21:02:45Z,262
"@@ -4,6 +4,8 @@
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
 import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
 import org.jboss.resteasy.client.jaxrs.i18n.Messages;
+import org.jboss.resteasy.concurrent.ContextualExecutors;
+import org.jboss.resteasy.concurrent.ContextualScheduledExecutorService;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
@@ -28,14 +30,14 @@ public class ResteasyClientImpl implements ResteasyClient
 {
    protected final ClientHttpEngine httpEngine;
    protected final ExecutorService asyncInvocationExecutor;
-   protected final ScheduledExecutorService scheduledExecutorService;
+   protected final ContextualScheduledExecutorService scheduledExecutorService;
    protected ClientConfiguration configuration;
    protected boolean closed;
    protected boolean cleanupExecutor;
 
 
    protected ResteasyClientImpl(final ClientHttpEngine httpEngine, final ExecutorService asyncInvocationExecutor, final boolean cleanupExecutor,
-                                final ScheduledExecutorService scheduledExecutorService, final ClientConfiguration configuration)
+                                final ContextualScheduledExecutorService scheduledExecutorService, final ClientConfiguration configuration)
    {
       this.cleanupExecutor = cleanupExecutor;
       this.httpEngine = httpEngine;
@@ -46,7 +48,7 @@ protected ResteasyClientImpl(final ClientHttpEngine httpEngine, final ExecutorSe
 
    protected ResteasyClientImpl(final ClientHttpEngine httpEngine, final ExecutorService asyncInvocationExecutor, final boolean cleanupExecutor, final ClientConfiguration configuration)
    {
-      this(httpEngine, asyncInvocationExecutor, cleanupExecutor, null, configuration);
+      this(httpEngine, asyncInvocationExecutor, cleanupExecutor, ContextualExecutors.scheduledThreadPool(), configuration);
    }
 
    public ClientHttpEngine httpEngine()",2021-08-11T21:02:45Z,263
"@@ -1,6 +1,8 @@
 package org.jboss.resteasy.plugins.providers.sse.client;
 
-import java.util.concurrent.Executors;
+import org.jboss.resteasy.concurrent.ContextualExecutors;
+import org.jboss.resteasy.concurrent.ContextualScheduledExecutorService;
+
 import java.util.concurrent.Phaser;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledExecutorService;
@@ -43,9 +45,7 @@ public Thread newThread(Runnable r)
       }
    }
 
-   private final ScheduledExecutorService scheduledExecutorService;
-
-   private final boolean shutdownExecutorService;
+   private final ContextualScheduledExecutorService scheduledExecutorService;
 
    private final Phaser phaser;
 
@@ -54,9 +54,8 @@ public Thread newThread(Runnable r)
    SseEventSourceScheduler(final ScheduledExecutorService scheduledExecutorService, final String threadName)
    {
       this.scheduledExecutorService = scheduledExecutorService == null
-            ? Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory(threadName))
-            : scheduledExecutorService;
-      this.shutdownExecutorService = scheduledExecutorService == null;
+            ? ContextualExecutors.scheduledThreadPool(1, new DaemonThreadFactory(threadName))
+            : ContextualExecutors.wrap(scheduledExecutorService, true);
       this.phaser = new Phaser(1);
       this.closed = new AtomicBoolean(false);
    }
@@ -103,7 +102,7 @@ public void run()
       }
       catch (RejectedExecutionException e)
       {
-         if (this.shutdownExecutorService && this.closed.get())
+         if (!scheduledExecutorService.isManaged() && this.closed.get())
          {
             // At this stage the RejectedExecutionException can be either a
             // normal consequence of the
@@ -141,7 +140,7 @@ void shutdownNow()
       if (this.closed.compareAndSet(false, true))
       {
          this.phaser.arriveAndDeregister();
-         if (this.shutdownExecutorService)
+         if (!scheduledExecutorService.isManaged())
          {
             this.scheduledExecutorService.shutdownNow();
          }",2021-08-11T21:02:45Z,264
"@@ -0,0 +1,169 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2021 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.concurrent;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * An {@linkplain ExecutorService executor} which wraps runnables and callables to capture the context of the current
+ * thread.
+ * <p>
+ * If a server is {@linkplain #isManaged() managed} it's the responsibility of the user or container to manage the
+ * lifecycle of the wrapped executor service.
+ * </p>
+ * <p>
+ * <strong>Note:</strong> if the executor is consider managed, for example running in a Jakarta EE environment, the
+ * following methods are effectively ignored.
+ * <ul>
+ *     <li>{@link #shutdown()}</li>
+ *     <li>{@link #shutdownNow()}</li>
+ *     <li>{@link #isShutdown()}</li>
+ *     <li>{@link #isTerminated()}</li>
+ *     <li>{@link #awaitTermination(long, TimeUnit)}</li>
+ * </ul>
+ * </p>
+ *
+ * @author <a href=""mailto:jperkins@redhat.com"">James R. Perkins</a>
+ * @since 5.0.0
+ */
+public class ContextualExecutorService implements ExecutorService {
+
+    private final ExecutorService delegate;
+    private final boolean managed;
+
+    ContextualExecutorService(final ExecutorService delegate, final boolean managed) {
+        this.delegate = delegate;
+        this.managed = managed;
+    }
+
+    @Override
+    public void shutdown() {
+        if (!managed) {
+            delegate.shutdown();
+        }
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+        if (managed) {
+            return Collections.emptyList();
+        }
+        return delegate.shutdownNow();
+    }
+
+    @Override
+    public boolean isShutdown() {
+        if (managed) {
+            return false;
+        }
+        return delegate.isShutdown();
+    }
+
+    @Override
+    public boolean isTerminated() {
+        if (managed) {
+            return false;
+        }
+        return delegate.isTerminated();
+    }
+
+    @Override
+    public boolean awaitTermination(final long timeout, final TimeUnit unit) throws InterruptedException {
+        if (managed) {
+            return false;
+        }
+        return delegate.awaitTermination(timeout, unit);
+    }
+
+    @Override
+    public <T> Future<T> submit(final Callable<T> task) {
+        return delegate.submit(ContextualExecutors.callable(task));
+    }
+
+    @Override
+    public <T> Future<T> submit(final Runnable task, final T result) {
+        return delegate.submit(ContextualExecutors.runnable(task), result);
+    }
+
+    @Override
+    public Future<?> submit(final Runnable task) {
+        return delegate.submit(ContextualExecutors.runnable(task));
+    }
+
+    @Override
+    public <T> List<Future<T>> invokeAll(
+            final Collection<? extends Callable<T>> tasks) throws InterruptedException {
+        return delegate.invokeAll(ContextualExecutors.callable(tasks));
+    }
+
+    @Override
+    public <T> List<Future<T>> invokeAll(
+            final Collection<? extends Callable<T>> tasks, final long timeout,
+            final TimeUnit unit) throws InterruptedException {
+        return delegate.invokeAll(ContextualExecutors.callable(tasks), timeout, unit);
+    }
+
+    @Override
+    public <T> T invokeAny(final Collection<? extends Callable<T>> tasks)
+            throws InterruptedException, ExecutionException {
+        return delegate.invokeAny(ContextualExecutors.callable(tasks));
+    }
+
+    @Override
+    public <T> T invokeAny(final Collection<? extends Callable<T>> tasks, final long timeout,
+                           final TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+        return delegate.invokeAny(ContextualExecutors.callable(tasks), timeout, unit);
+    }
+
+    @Override
+    public void execute(final Runnable command) {
+        delegate.execute(ContextualExecutors.runnable(command));
+    }
+
+    /**
+     * Indicates this executor is managed and the following methods are not executed. If the method has a return type
+     * a default value is returned.
+     * <ul>
+     *     <li>{@link #shutdown()}</li>
+     *     <li>{@link #shutdownNow()}</li>
+     *     <li>{@link #isShutdown()}</li>
+     *     <li>{@link #isTerminated()}</li>
+     *     <li>{@link #awaitTermination(long, TimeUnit)}</li>
+     * </ul>
+     *
+     * @return {@code true} if this is a managed executor, otherwise {@code false}
+     */
+    public boolean isManaged() {
+        return managed;
+    }
+
+    ExecutorService getDelegate() {
+        return delegate;
+    }
+
+}",2021-08-11T21:02:45Z,265
"@@ -0,0 +1,322 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2021 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.concurrent;
+
+import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;
+import org.jboss.resteasy.spi.concurrent.ThreadContext;
+import org.jboss.resteasy.spi.config.Configuration;
+import org.jboss.resteasy.spi.config.ConfigurationFactory;
+
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * A utility to create and/or wrap {@linkplain ExecutorService executors} in a contextual executor.
+ *
+ * @author <a href=""mailto:jperkins@redhat.com"">James R. Perkins</a>
+ * @see org.jboss.resteasy.concurrent.ContextualExecutorService
+ * @see org.jboss.resteasy.concurrent.ContextualScheduledExecutorService
+ * @since 5.0.0
+ */
+public class ContextualExecutors {
+
+    /**
+     * Creates a new {@link ContextualExecutorService} or returns the default {@code ManagedExecutorService} in a
+     * Jakarta EE environment.
+     * <p>
+     * If being created in a Jakarta EE container which includes a default {@code ManagedExecutorService} that executor
+     * is wrapped an said to be managed. If the default executor service cannot be found or if not being executed in a
+     * Jakarta EE container a new {@linkplain Executors#newCachedThreadPool() cached thread pool} will be wrapped.
+     * </p>
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualExecutorService threadPool() {
+        ExecutorService delegate;
+        boolean managed = false;
+        try {
+            delegate = InitialContext.doLookup(""java:comp/DefaultManagedExecutorService"");
+            managed = true;
+        } catch (NamingException ignore) {
+            delegate = Executors.newCachedThreadPool();
+        }
+        return wrap(delegate, managed);
+    }
+
+    /**
+     * Creates a new {@link ContextualExecutorService} or returns the default {@code ManagedExecutorService} in a
+     * Jakarta EE environment.
+     * <p>
+     * If being created in a Jakarta EE container which includes a default {@code ManagedExecutorService} that executor
+     * is wrapped an said to be managed. If the default executor service cannot be found or if not being executed in a
+     * Jakarta EE container a new {@linkplain Executors#newFixedThreadPool(int)} fixed thread pool} will be wrapped.
+     * </p>
+     *
+     * @param poolSize the size for the fixed thread pool in cases where it gets created
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualExecutorService threadPool(final int poolSize) {
+        ExecutorService delegate;
+        boolean managed = false;
+        try {
+            delegate = InitialContext.doLookup(""java:comp/DefaultManagedExecutorService"");
+            managed = true;
+        } catch (NamingException ignore) {
+            delegate = Executors.newFixedThreadPool(poolSize);
+        }
+        return wrap(delegate, managed);
+    }
+
+    /**
+     * Creates a new {@link ContextualScheduledExecutorService} or returns the default {@code ManagedScheduledExecutorService}
+     * in a Jakarta EE environment.
+     * <p>
+     * If being created in a Jakarta EE container which includes a default {@code ManagedScheduledExecutorService} that executor
+     * is wrapped an said to be managed. If the default executor service cannot be found or if not being executed in a
+     * Jakarta EE container a new {@linkplain Executors#newScheduledThreadPool(int) scheduled thread pool} will be
+     * wrapped. The size of the thread pool is retrieved via the {@code resteasy.async.timeout.scheduler.min.pool.size}
+     * context parameter. If not found {@code 1} is the default.
+     * </p>
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualScheduledExecutorService scheduledThreadPool() {
+        ScheduledExecutorService delegate;
+        boolean managed = false;
+        try {
+            delegate = InitialContext.doLookup(""java:comp/DefaultManagedScheduledExecutorService"");
+            managed = true;
+        } catch (NamingException ignore) {
+            final Configuration config = ConfigurationFactory.getInstance().getConfiguration();
+            final int poolSize = config.getOptionalValue(""resteasy.async.timeout.scheduler.min.pool.size"", Integer.class)
+                    .orElse(1);
+            delegate = Executors.newScheduledThreadPool(poolSize);
+        }
+        return wrap(delegate, managed);
+    }
+
+    /**
+     * Creates a new {@link ContextualScheduledExecutorService} or returns the default {@code ManagedScheduledExecutorService}
+     * in a Jakarta EE environment.
+     * <p>
+     * If being created in a Jakarta EE container which includes a default {@code ManagedScheduledExecutorService} that executor
+     * is wrapped an said to be managed. If the default executor service cannot be found or if not being executed in a
+     * Jakarta EE container a new {@linkplain Executors#newScheduledThreadPool(int) scheduled thread pool} will be
+     * wrapped.
+     * </p>
+     *
+     * @param poolSize      the size of the pool to create
+     * @param threadFactory the thread factory to use if a new executor is created
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualScheduledExecutorService scheduledThreadPool(final int poolSize,
+                                                                         final ThreadFactory threadFactory) {
+        ScheduledExecutorService delegate;
+        boolean managed = false;
+        try {
+            delegate = InitialContext.doLookup(""java:comp/DefaultManagedScheduledExecutorService"");
+            managed = true;
+        } catch (NamingException ignore) {
+            delegate = Executors.newScheduledThreadPool(poolSize, threadFactory);
+        }
+        return wrap(delegate, managed);
+    }
+
+    /**
+     * Wraps the executor service in contextual executor and is said to be managed. You are responsible for the
+     * lifecycle of the delegate.
+     *
+     * @param delegate the executor to wrap
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualExecutorService wrap(final ExecutorService delegate) {
+        return wrap(delegate, true);
+    }
+
+    /**
+     * Wraps the executor service in contextual executor and is said to be managed. You are responsible for the
+     * lifecycle of the delegate.
+     *
+     * @param delegate the executor to wrap
+     * @param managed  {@code true} if the lifecycle is managed by another process
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualExecutorService wrap(final ExecutorService delegate, final boolean managed) {
+        if (delegate == null) {
+            return null;
+        }
+        if (delegate instanceof ScheduledExecutorService) {
+            return wrap(((ScheduledExecutorService) delegate), managed);
+        }
+        if (delegate instanceof ContextualExecutorService && managed == ((ContextualExecutorService) delegate).isManaged()) {
+            if (managed == ((ContextualExecutorService) delegate).isManaged()) {
+                return (ContextualExecutorService) delegate;
+            }
+            return new ContextualExecutorService(((ContextualExecutorService) delegate).getDelegate(), managed);
+        }
+        return new ContextualExecutorService(delegate, managed);
+    }
+
+    /**
+     * Wraps the executor service in contextual executor and is said to be managed. You are responsible for the
+     * lifecycle of the delegate.
+     *
+     * @param delegate the executor to wrap
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualScheduledExecutorService wrap(final ScheduledExecutorService delegate) {
+        return wrap(delegate, true);
+    }
+
+    /**
+     * Wraps the executor service in contextual executor and is said to be managed. You are responsible for the
+     * lifecycle of the delegate.
+     *
+     * @param delegate the executor to wrap
+     * @param managed  {@code true} if the lifecycle is managed by another process
+     *
+     * @return a new contextual executor
+     */
+    public static ContextualScheduledExecutorService wrap(final ScheduledExecutorService delegate,
+                                                          final boolean managed) {
+        if (delegate == null) {
+            return null;
+        }
+        if (delegate instanceof ContextualScheduledExecutorService && managed == ((ContextualScheduledExecutorService) delegate).isManaged()) {
+            if (managed == ((ContextualScheduledExecutorService) delegate).isManaged()) {
+                return (ContextualScheduledExecutorService) delegate;
+            }
+            return new ContextualScheduledExecutorService(((ContextualScheduledExecutorService) delegate).getDelegate(), managed);
+        }
+        return new ContextualScheduledExecutorService(delegate, managed);
+    }
+
+    /**
+     * Creates a new {@linkplain Runnable runnable} which sets up the current context before the runnable is executed.
+     * Finally, resetting the context.
+     *
+     * @param task the runnable to wrap
+     *
+     * @return a new contextual runnable
+     */
+    public static Runnable runnable(final Runnable task) {
+        final Map<ThreadContext<Object>, Object> contexts = getContexts();
+        return () -> {
+            try {
+                for (Map.Entry<ThreadContext<Object>, Object> entry : contexts.entrySet()) {
+                    entry.getKey().push(entry.getValue());
+                }
+                task.run();
+            } finally {
+                reset(contexts.keySet());
+            }
+        };
+    }
+
+    /**
+     * Creates a new {@linkplain Callable callable} which sets up the current context before the callable is executed.
+     * Finally, resetting the context.
+     *
+     * @param task the callable to wrap
+     * @param <V>  the return type
+     *
+     * @return a new contextual callable
+     */
+    public static <V> Callable<V> callable(final Callable<V> task) {
+        final Map<ThreadContext<Object>, Object> contexts = getContexts();
+        return () -> {
+            try {
+                for (Map.Entry<ThreadContext<Object>, Object> entry : contexts.entrySet()) {
+                    entry.getKey().push(entry.getValue());
+                }
+                return task.call();
+            } finally {
+                reset(contexts.keySet());
+            }
+        };
+    }
+
+    /**
+     * Creates a new collection of {@linkplain Callable callables} which sets up the current context before each
+     * callable is executed. Finally, resetting the context.
+     *
+     * @param tasks the callables to wrap
+     * @param <T>   the return type of the callable
+     *
+     * @return a collection of new contextual callables
+     *
+     * @see #callable(Callable)
+     */
+    public static <T> Collection<? extends Callable<T>> callable(final Collection<? extends Callable<T>> tasks) {
+        return tasks.stream()
+                .map((Function<Callable<T>, Callable<T>>) ContextualExecutors::callable)
+                .collect(Collectors.toList());
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private static Map<ThreadContext<Object>, Object> getContexts() {
+        if (System.getSecurityManager() == null) {
+            final Map<ThreadContext<Object>, Object> contexts = new LinkedHashMap<>();
+            ServiceLoader.load(ThreadContext.class).forEach(context -> contexts.put(context, context.capture()));
+            return contexts;
+        }
+        return AccessController.doPrivileged((PrivilegedAction<Map<ThreadContext<Object>, Object>>) () -> {
+            final Map<ThreadContext<Object>, Object> contexts = new LinkedHashMap<>();
+            ServiceLoader.load(ThreadContext.class).forEach(context -> contexts.put(context, context.capture()));
+            return contexts;
+        });
+    }
+
+    private static void reset(final Collection<ThreadContext<Object>> contexts) {
+        Throwable error = null;
+        for (ThreadContext<Object> context : contexts) {
+            try {
+                context.reset();
+            } catch (Throwable t) {
+                if (error == null) {
+                    error = t;
+                } else {
+                    error.addSuppressed(t);
+                }
+            }
+        }
+        if (error != null) {
+            LogMessages.LOGGER.unableToResetThreadContext(error, Thread.currentThread().getName());
+        }
+    }
+}",2021-08-11T21:02:45Z,266
"@@ -0,0 +1,84 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2021 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.concurrent;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * An {@linkplain ScheduledExecutorService executor} which wraps runnables and callables to capture the context of the
+ * current thread.
+ * <p>
+ * If a server is {@linkplain #isManaged() managed} it's the responsibility of the user or container to manage the
+ * lifecycle of the wrapped executor service.
+ * </p>
+ * <p>
+ * <strong>Note:</strong> if the executor is consider managed, for example running in a Jakarta EE environment, the
+ * following methods are effectively ignored.
+ * <ul>
+ *     <li>{@link #shutdown()}</li>
+ *     <li>{@link #shutdownNow()}</li>
+ *     <li>{@link #isShutdown()}</li>
+ *     <li>{@link #isTerminated()}</li>
+ *     <li>{@link #awaitTermination(long, TimeUnit)}</li>
+ * </ul>
+ * </p>
+ *
+ * @author <a href=""mailto:jperkins@redhat.com"">James R. Perkins</a>
+ * @since 5.0.0
+ */
+public class ContextualScheduledExecutorService extends ContextualExecutorService implements ScheduledExecutorService {
+
+    private final ScheduledExecutorService delegate;
+
+    ContextualScheduledExecutorService(final ScheduledExecutorService delegate, final boolean managed) {
+        super(delegate, managed);
+        this.delegate = delegate;
+    }
+
+    @Override
+    public ScheduledFuture<?> schedule(final Runnable command, final long delay, final TimeUnit unit) {
+        return delegate.schedule(ContextualExecutors.runnable(command), delay, unit);
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(final Callable<V> callable, final long delay, final TimeUnit unit) {
+        return delegate.schedule(ContextualExecutors.callable(callable), delay, unit);
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleAtFixedRate(final Runnable command, final long initialDelay, final long period,
+                                                  final TimeUnit unit) {
+        return delegate.scheduleAtFixedRate(ContextualExecutors.runnable(command), initialDelay, period, unit);
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleWithFixedDelay(final Runnable command, final long initialDelay, final long delay,
+                                                     final TimeUnit unit) {
+        return delegate.scheduleWithFixedDelay(ContextualExecutors.runnable(command), initialDelay, delay, unit);
+    }
+
+    @Override
+    ScheduledExecutorService getDelegate() {
+        return delegate;
+    }
+}",2021-08-11T21:02:45Z,267
"@@ -305,6 +305,11 @@ public interface LogMessages extends BasicLogger
    @Message(""Unable to extract parameter from http request: %s value is '%s' for %s"")
    void unableToExtractParameter(@Cause Throwable cause, String paramSignature, String strVal, AccessibleObject target);
 
+   @LogMessage(level = Level.WARN)
+   @Message(id = BASE + 350, value = ""Failed to reset the context on thread: %s"")
+   void unableToResetThreadContext(@Cause Throwable cause, String threadName);
+
+
 
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                                  TRACE                                                //",2021-08-11T21:02:45Z,268
"@@ -0,0 +1,51 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2021 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.spi.concurrent;
+
+/**
+ * A utility used to {@linkplain #capture() capture} the current context and {@linkplain #push(Object) set it} on a
+ * thread before it's execute. Finally {@linkplain #reset() resetting} the context.
+ *
+ * @author <a href=""mailto:jperkins@redhat.com"">James R. Perkins</a>
+ * @see org.jboss.resteasy.concurrent.ContextualExecutorService
+ * @see org.jboss.resteasy.concurrent.ContextualScheduledExecutorService
+ * @since 5.0.0
+ */
+public interface ThreadContext<T> {
+
+    /**
+     * Captures the current context to be passed to {@link #push(Object)} before a thread executes.
+     *
+     * @return the current context
+     */
+    T capture();
+
+    /**
+     * Pushes the context previously captured to the currently running thread.
+     *
+     * @param context the context to push
+     */
+    void push(T context);
+
+    /**
+     * Resets the context on the current thread.
+     */
+    void reset();
+}",2021-08-11T21:02:45Z,269
"@@ -19,18 +19,13 @@
 
 package org.jboss.resteasy.spi.config;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+import org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;
+import org.jboss.resteasy.spi.ResteasyConfiguration;
+
 import java.math.BigDecimal;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Optional;
 import java.util.function.Function;
 
-import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;
-import org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;
-import org.jboss.resteasy.spi.ResteasyConfiguration;
-
 /**
  * A default configuration which first attempts to use the Eclipse MicroProfile Config API. If the MicroProfile Config
  * API is not available value is searched in the following order:
@@ -44,30 +39,6 @@
  */
 public class DefaultConfiguration implements Configuration {
     private static final Function<String, String> DEFAULT_RESOLVER = new Resolver(null);
-    private static final Method GET_CONFIG;
-    private static final Method GET_OPTIONAL_VALUE;
-    private static final Method GET_VALUE;
-
-    static {
-        Method getConfig;
-        Method getOptionalValue;
-        Method getValue;
-        try {
-            final ClassLoader classLoader = getClassLoader();
-            final Class<?> configProvider = Class.forName(""org.eclipse.microprofile.config.ConfigProvider"", false, classLoader);
-            getConfig = configProvider.getDeclaredMethod(""getConfig"", ClassLoader.class);
-            final Class<?> config = Class.forName(""org.eclipse.microprofile.config.Config"", false, classLoader);
-            getOptionalValue = config.getDeclaredMethod(""getOptionalValue"", String.class, Class.class);
-            getValue = config.getDeclaredMethod(""getValue"", String.class, Class.class);
-        } catch (Throwable ignore) {
-            getConfig = null;
-            getOptionalValue = null;
-            getValue = null;
-        }
-        GET_CONFIG = getConfig;
-        GET_OPTIONAL_VALUE = getOptionalValue;
-        GET_VALUE = getValue;
-    }
 
     private final Function<String, String> resolver;
 
@@ -92,14 +63,6 @@ public DefaultConfiguration(final ResteasyConfiguration config) {
     @Override
     @SuppressWarnings(""unchecked"")
     public <T> Optional<T> getOptionalValue(final String name, final Class<T> type) {
-        if (GET_CONFIG != null) {
-            try {
-                final Object config = GET_CONFIG.invoke(null, getClassLoader());
-                return (Optional<T>) GET_OPTIONAL_VALUE.invoke(config, name, type);
-            } catch (IllegalAccessException | InvocationTargetException e) {
-                LogMessages.LOGGER.debugf(e, ""Failed to invoke the configuration API method %s."", GET_OPTIONAL_VALUE);
-            }
-        }
         final String value = resolver.apply(name);
         if (value == null) {
             return Optional.empty();
@@ -137,30 +100,10 @@ public <T> Optional<T> getOptionalValue(final String name, final Class<T> type)
     }
 
     @Override
-    @SuppressWarnings(""unchecked"")
     public <T> T getValue(final String name, final Class<T> type) {
-        if (GET_CONFIG != null) {
-            try {
-                final Object config = GET_CONFIG.invoke(null, getClassLoader());
-                return (T) GET_VALUE.invoke(config, name, type);
-            } catch (IllegalAccessException | InvocationTargetException e) {
-                LogMessages.LOGGER.debugf(e, ""Failed to invoke the configuration API method %s."", GET_VALUE);
-            }
-        }
         return getOptionalValue(name, type).orElseThrow(() -> Messages.MESSAGES.propertyNotFound(name));
     }
 
-    private static ClassLoader getClassLoader() {
-        if (System.getSecurityManager() == null) {
-            final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
-            return tccl != null ? tccl : DefaultConfiguration.class.getClassLoader();
-        }
-        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {
-            final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
-            return tccl != null ? tccl : DefaultConfiguration.class.getClassLoader();
-        });
-    }
-
     private static class Resolver implements Function<String, String> {
         private final ResteasyConfiguration config;
 ",2021-08-11T21:02:45Z,270
"@@ -0,0 +1,45 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2021 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.concurrency;
+
+import org.jboss.resteasy.core.ResteasyContext;
+import org.jboss.resteasy.spi.concurrent.ThreadContext;
+
+import java.util.Map;
+
+/**
+ * @author <a href=""mailto:jperkins@redhat.com"">James R. Perkins</a>
+ */
+public class ResteasyThreadContext implements ThreadContext<Map<Class<?>, Object>> {
+    @Override
+    public Map<Class<?>, Object> capture() {
+        return ResteasyContext.getContextDataMap();
+    }
+
+    @Override
+    public void push(final Map<Class<?>, Object> context) {
+        ResteasyContext.pushContextDataMap(context);
+    }
+
+    @Override
+    public void reset() {
+        ResteasyContext.removeContextDataLevel();
+    }
+}",2021-08-11T21:02:45Z,73
"@@ -1,5 +1,7 @@
 package org.jboss.resteasy.core;
 
+import org.jboss.resteasy.concurrent.ContextualExecutorService;
+import org.jboss.resteasy.concurrent.ContextualExecutors;
 import org.jboss.resteasy.mock.MockHttpRequest;
 import org.jboss.resteasy.mock.MockHttpResponse;
 import org.jboss.resteasy.plugins.server.servlet.ResteasyContextParameters;
@@ -32,7 +34,6 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -115,7 +116,7 @@ private int getMaxUses()
       }
    }
 
-   protected ExecutorService executor;
+   private ContextualExecutorService executor;
    private int threadPoolSize = 100;
    private Map<String, Future<MockHttpResponse>> jobs;
    private Cache cache;
@@ -185,20 +186,22 @@ public void setThreadPoolSize(int threadPoolSize)
     */
    public void setExecutor(ExecutorService executor)
    {
-      this.executor = executor;
+      this.executor = ContextualExecutors.wrap(executor, true);
    }
 
    public void start()
    {
       cache = new Cache(maxCacheSize);
       jobs = Collections.synchronizedMap(cache);
-      if (executor == null) executor = Executors.newFixedThreadPool(threadPoolSize);
+      if (executor == null) executor = ContextualExecutors.threadPool(threadPoolSize);
       registry.addSingletonResource(this, basePath);
    }
 
    public void stop()
    {
-      executor.shutdown();
+      if (!executor.isManaged()) {
+         executor.shutdown();
+      }
    }
 
    @Path(""{job-id}"")",2021-08-11T21:02:45Z,271
"@@ -10,8 +10,6 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import javax.ws.rs.core.NewCookie;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -20,13 +18,10 @@
 @WebFilter(asyncSupported = true, value="""")
 public class Filter30Dispatcher extends FilterDispatcher
 {
-   ScheduledExecutorService asyncCancelScheduler = Executors.newScheduledThreadPool(0); // this is to get around TCK tests that call setTimeout in a separate thread which is illegal.
    @Override
    public HttpRequest createResteasyHttpRequest(String httpMethod, HttpServletRequest httpServletRequest, ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uriInfo, HttpResponse httpResponse, HttpServletResponse httpServletResponse)
    {
-      Servlet3AsyncHttpRequest request = new Servlet3AsyncHttpRequest(httpServletRequest, httpServletResponse, servletContext, httpResponse, httpHeaders, uriInfo, httpMethod, (SynchronousDispatcher) getDispatcher());
-      request.asyncScheduler = asyncCancelScheduler;
-      return request;
+      return new Servlet3AsyncHttpRequest(httpServletRequest, httpServletResponse, servletContext, httpResponse, httpHeaders, uriInfo, httpMethod, (SynchronousDispatcher) getDispatcher());
    }
 
    @Override",2021-08-11T21:02:45Z,272
"@@ -28,9 +28,7 @@ public class HttpServlet30Dispatcher extends HttpServletDispatcher
    @Override
    protected HttpRequest createHttpRequest(String httpMethod, HttpServletRequest httpServletRequest, ResteasyHttpHeaders httpHeaders, ResteasyUriInfo uriInfo, HttpResponse httpResponse, HttpServletResponse httpServletResponse)
    {
-      Servlet3AsyncHttpRequest request = new Servlet3AsyncHttpRequest(httpServletRequest, httpServletResponse, getServletContext(), httpResponse, httpHeaders, uriInfo, httpMethod.toUpperCase(), (SynchronousDispatcher) getDispatcher());
-      request.asyncScheduler = asyncCancelScheduler;
-      return request;
+      return new Servlet3AsyncHttpRequest(httpServletRequest, httpServletResponse, getServletContext(), httpResponse, httpHeaders, uriInfo, httpMethod.toUpperCase(), (SynchronousDispatcher) getDispatcher());
    }
 
    @Override",2021-08-11T21:02:45Z,273
"@@ -1,5 +1,7 @@
 package org.jboss.resteasy.plugins.server.servlet;
 
+import org.jboss.resteasy.concurrent.ContextualExecutors;
+import org.jboss.resteasy.concurrent.ContextualScheduledExecutorService;
 import org.jboss.resteasy.core.AbstractAsynchronousResponse;
 import org.jboss.resteasy.core.AbstractExecutionContext;
 import org.jboss.resteasy.core.SynchronousDispatcher;
@@ -27,7 +29,6 @@
 import java.util.Date;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
@@ -39,13 +40,14 @@ public class Servlet3AsyncHttpRequest extends HttpServletInputMessage
 {
    protected HttpServletResponse response;
    protected ResteasyAsynchronousContext asynchronousContext;
-   protected ScheduledExecutorService asyncScheduler; // this is to get around TCK tests that call setTimeout in a separate thread which is illegal.
+   private final ContextualScheduledExecutorService asyncScheduler;
 
    public Servlet3AsyncHttpRequest(final HttpServletRequest httpServletRequest, final HttpServletResponse response, final ServletContext servletContext, final HttpResponse httpResponse, final ResteasyHttpHeaders httpHeaders, final ResteasyUriInfo uriInfo, final String s, final SynchronousDispatcher synchronousDispatcher)
    {
       super(httpServletRequest, response, servletContext, httpResponse, httpHeaders, uriInfo, s, synchronousDispatcher);
       this.response = response;
       asynchronousContext = new Servlet3ExecutionContext((ServletRequest) httpServletRequest);
+      asyncScheduler = ContextualExecutors.scheduledThreadPool();
    }
 
    @Override",2021-08-11T21:02:45Z,28
"@@ -0,0 +1,20 @@
+#
+# JBoss, Home of Professional Open Source.
+#
+# Copyright 2021 Red Hat, Inc., and individual contributors
+# as indicated by the @author tags.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.jboss.resteasy.concurrency.ResteasyThreadContext
\ No newline at end of file",2021-08-11T21:02:45Z,274
"@@ -18,6 +18,7 @@
 import javax.ws.rs.ext.MessageBodyWriter;
 import javax.ws.rs.ext.Providers;
 import javax.ws.rs.ext.ReaderInterceptor;
+import javax.ws.rs.ext.RuntimeDelegate;
 import javax.ws.rs.ext.WriterInterceptor;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AccessibleObject;
@@ -72,7 +73,13 @@ public Map<String, Object> getMutableProperties()
     */
    public String toHeaderString(Object object)
    {
-      return providerFactory.toHeaderString(object);
+      if (object instanceof String) return (String)object;
+      // Javadoc and TCK requires that you only get from RuntimeDelegate.getInstance().createHeaderDelegate()
+      RuntimeDelegate.HeaderDelegate delegate = RuntimeDelegate.getInstance().createHeaderDelegate(object.getClass());
+      if (delegate != null)
+         return delegate.toString(object);
+      else
+         return object.toString();
    }
 
    public <T> MessageBodyWriter<T> getMessageBodyWriter(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType)",2013-05-08T01:58:34Z,56
"@@ -169,6 +169,7 @@ public void setEntity(Entity entity)
       {
          Object ent = entity.getEntity();
          setEntityObject(ent);
+         this.entityAnnotations = entity.getAnnotations();
          Variant v = entity.getVariant();
          headers.setMediaType(v.getMediaType());
          headers.setLanguage(v.getLanguage());",2013-05-08T01:58:34Z,12
"@@ -13,6 +13,7 @@
 import java.lang.reflect.Type;
 import java.net.URI;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Iterator;
@@ -48,7 +49,7 @@ public Object getProperty(String name)
    @Override
    public Collection<String> getPropertyNames()
    {
-      return invocation.getMutableProperties().keySet();
+      return Collections.unmodifiableSet(invocation.getMutableProperties().keySet());
    }
 
    @Override",2013-05-08T01:58:34Z,275
"@@ -49,7 +49,12 @@ public void setHeaders(MultivaluedMap<String, Object> newHeaders)
 
    public void setLanguage(Locale language)
    {
-      header(HttpHeaders.CONTENT_LANGUAGE, language);
+      if (language == null)
+      {
+         headers.remove(HttpHeaders.CONTENT_LANGUAGE);
+         return;
+      }
+      headers.putSingle(HttpHeaders.CONTENT_LANGUAGE, language);
    }
 
    public void setLanguage(String language)
@@ -59,55 +64,35 @@ public void setLanguage(String language)
 
    public void setMediaType(MediaType mediaType)
    {
-      header(HttpHeaders.CONTENT_TYPE, mediaType);
+      if (mediaType == null)
+      {
+         headers.remove(HttpHeaders.CONTENT_TYPE);
+         return;
+      }
+      headers.putSingle(HttpHeaders.CONTENT_TYPE, mediaType);
    }
 
    public void acceptLanguage(Locale... locales)
    {
-      headers.remove(HttpHeaders.ACCEPT_LANGUAGE);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (Locale l : locales)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE);
+      StringBuilder builder = buildAcceptString(accept, locales);
       headers.putSingle(HttpHeaders.ACCEPT_LANGUAGE, builder.toString());
    }
 
    public void acceptLanguage(String... locales)
    {
-      headers.remove(HttpHeaders.ACCEPT_LANGUAGE);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (String l : locales)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE);
+      StringBuilder builder = buildAcceptString(accept, locales);
       headers.putSingle(HttpHeaders.ACCEPT_LANGUAGE, builder.toString());
    }
 
-   public void acceptEncoding(String... encodings)
+   private StringBuilder buildAcceptString(String accept, Object[] items)
    {
-      headers.remove(HttpHeaders.ACCEPT_ENCODING);
       StringBuilder builder = new StringBuilder();
+      if (accept != null) builder.append(accept).append("", "");
+
       boolean isFirst = true;
-      for (String l : encodings)
+      for (Object l : items)
       {
          if (isFirst)
          {
@@ -117,49 +102,30 @@ public void acceptEncoding(String... encodings)
          {
             builder.append("", "");
          }
-         builder.append(l.toString());
+         builder.append(configuration.toHeaderString(l));
       }
+      return builder;
+   }
+
+   public void acceptEncoding(String... encodings)
+   {
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT_ENCODING);
+      StringBuilder builder = buildAcceptString(accept, encodings);
       headers.putSingle(HttpHeaders.ACCEPT_ENCODING, builder.toString());
    }
 
 
    public void accept(String... types)
    {
-      headers.remove(HttpHeaders.ACCEPT);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (String l : types)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT);
+      StringBuilder builder = buildAcceptString(accept, types);
       headers.putSingle(HttpHeaders.ACCEPT, builder.toString());
    }
 
    public void accept(MediaType... types)
    {
-      headers.remove(HttpHeaders.ACCEPT);
-      StringBuilder builder = new StringBuilder();
-      boolean isFirst = true;
-      for (MediaType l : types)
-      {
-         if (isFirst)
-         {
-            isFirst = false;
-         }
-         else
-         {
-            builder.append("", "");
-         }
-         builder.append(l.toString());
-      }
+      String accept = (String)headers.getFirst(HttpHeaders.ACCEPT);
+      StringBuilder builder = buildAcceptString(accept, types);
       headers.putSingle(HttpHeaders.ACCEPT, builder.toString());
    }
 
@@ -190,7 +156,10 @@ public void header(String name, Object value)
          headers.remove(name);
          return;
       }
-      headers.add(name, value);
+      if (name.equalsIgnoreCase(HttpHeaders.ACCEPT)) accept(configuration.toHeaderString(value));
+      else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_ENCODING)) acceptEncoding(configuration.toHeaderString(value));
+      else if (name.equalsIgnoreCase(HttpHeaders.ACCEPT_LANGUAGE)) acceptLanguage(configuration.toHeaderString(value));
+      else headers.add(name, value);
    }
 
    public Date getDate()",2013-05-08T01:58:34Z,39
"@@ -0,0 +1,127 @@
+package org.jboss.resteasy.test.client;
+
+import junit.framework.Assert;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.Provider;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class RequestFilterTest
+{
+   private static final MediaType mediaType = MediaType.APPLICATION_JSON_TYPE;
+
+   public static class PostFilter1 implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""*** filter 1 ***"");
+         requestContext.setEntity(""test"", null, mediaType);
+      }
+   }
+
+   public static class PostFilter2 implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""*** filter 2 ***"");
+         Object entity = requestContext.getEntity();
+         Assert.assertNotNull(entity);
+         Assert.assertEquals(entity, ""test"");
+         MediaType mt = requestContext.getMediaType();
+         Assert.assertNotNull(mt);
+         Assert.assertEquals(mediaType, mt);
+         requestContext.abortWith(Response.ok().build());
+
+      }
+   }
+
+   @Provider
+   public static class AnnotationFilter implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         System.out.println(""  ** ANnotation Filter"");
+         Annotation[] annotations = requestContext.getEntityAnnotations();
+         Assert.assertNotNull(annotations);
+         requestContext.abortWith(Response.ok(annotations[0].annotationType().getName()).build());
+      }
+   }
+
+   public static class AcceptLanguageFilter implements ClientRequestFilter
+   {
+      @Override
+      public void filter(ClientRequestContext requestContext) throws IOException
+      {
+         List<Locale> locales = requestContext.getAcceptableLanguages();
+         StringBuilder builder = new StringBuilder();
+         for (Locale locale : locales) builder.append(locale.toString()).append("","");
+         Response r = Response.ok(builder.toString()).build();
+         requestContext.abortWith(r);
+      }
+   }
+
+   static Client client;
+
+   @BeforeClass
+   public static void setupClient()
+   {
+      client = ClientBuilder.newClient();
+
+   }
+
+   @AfterClass
+   public static void close()
+   {
+      client.close();
+   }
+
+   @Test
+   public void testAcceptLanguages()
+   {
+      Response response = client.target(""foo"").register(AcceptLanguageFilter.class).request()
+              .acceptLanguage(Locale.CANADA_FRENCH)
+              .acceptLanguage(Locale.PRC).get();
+      String str = response.readEntity(String.class);
+      System.out.println(str);
+      System.out.println(Locale.CANADA_FRENCH.toString());
+      Assert.assertTrue(str.contains(Locale.CANADA_FRENCH.toString()));
+
+   }
+
+
+   @Test
+   public void testFilters()
+   {
+      Entity<ByteArrayInputStream> entity = Entity.entity(new ByteArrayInputStream(
+              ""test"".getBytes()), MediaType.WILDCARD_TYPE);
+      Response response = client.target(""http://nowhere"").register(PostFilter1.class).register(PostFilter2.class).request().post(entity);
+      Entity<String> post = Entity.entity(""test"", MediaType.WILDCARD_TYPE,
+              AnnotationFilter.class.getAnnotations());
+      response = client.target(""nada"").register(AnnotationFilter.class).request().post(post);
+      Assert.assertEquals(Provider.class.getName(), response.readEntity(String.class));
+
+
+
+
+   }
+}",2013-05-08T01:58:34Z,276
"@@ -113,18 +113,16 @@ public static interface MyClient
    {
       @Path(""{pojo}"")
       @PUT
-      void put(@QueryParam(""pojo"") POJO q, @PathParam(""pojo"") POJO pp, @MatrixParam(""pojo"") POJO mp,
-               @HeaderParam(""pojo"") POJO hp);
+      void put(@QueryParam(""pojo"") String q, @PathParam(""pojo"") String pp, @MatrixParam(""pojo"") String mp,
+               @HeaderParam(""pojo"") String hp);
    }
 
    @Test
    public void testIt() throws Exception
    {
       ResteasyClient client = new ResteasyClientBuilder().providerFactory(deployment.getProviderFactory()).build();
       MyClient proxy = client.target(generateBaseUrl()).proxy(MyClient.class);
-      POJO pojo = new POJO();
-      pojo.setName(""pojo"");
-      proxy.put(pojo, pojo, pojo, pojo);
+      proxy.put(""pojo"", ""pojo"", ""pojo"", ""pojo"");
       client.close();
    }
 ",2013-05-08T01:58:34Z,277
"@@ -61,21 +61,4 @@ public static void setAllow(MultivaluedMap headers, Set<String> methods)
       headers.putSingle(""Allow"", builder.toString());
    }
 
-   public static String toHeaderString(Object object, ResteasyProviderFactory providerFactory)
-   {
-      if (object instanceof String) return object.toString();
-
-      StringConverter converter = providerFactory.getStringConverter(object
-              .getClass());
-      if (converter != null)
-         return converter.toString(object);
-
-      RuntimeDelegate.HeaderDelegate delegate = providerFactory
-              .createHeaderDelegate(object.getClass());
-      if (delegate != null)
-         return delegate.toString(object);
-      else
-         return object.toString();
-
-   }
 }",2013-05-08T01:58:34Z,278
"@@ -1,416 +1,416 @@
-package org.jboss.resteasy.plugins.server.servlet;
-
-import org.jboss.resteasy.logging.Logger;
-import org.jboss.resteasy.spi.ResteasyConfiguration;
-import org.jboss.resteasy.spi.ResteasyDeployment;
-import org.jboss.resteasy.util.HttpHeaderNames;
-import org.scannotation.AnnotationDB;
-
-import javax.ws.rs.Path;
-import javax.ws.rs.core.Application;
-import javax.ws.rs.ext.Provider;
-import java.io.IOException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Create a deployment from String-based configuration data
- *
- * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
- * @version $Revision: 1 $
- */
-abstract public class ConfigurationBootstrap implements ResteasyConfiguration
-{
-   private static Logger logger = null;
-   private ResteasyDeployment deployment = new ResteasyDeployment();
-
-   public abstract URL[] getScanningUrls();
-
-
-   public ResteasyDeployment createDeployment()
-   {
-      String loggerTypeString = getParameter(""resteasy.logger.type"");
-      if (loggerTypeString != null)
-      {
-         Logger.LoggerType loggerType = Logger.LoggerType.valueOf(loggerTypeString);
-         Logger.setLoggerType(loggerType);
-
-      }
-      logger = Logger.getLogger(ConfigurationBootstrap.class);
-      String deploymentSensitive = getParameter(""resteasy.use.deployment.sensitive.factory"");
-      if (deploymentSensitive != null)
-         deployment.setDeploymentSensitiveFactoryEnabled(Boolean.valueOf(deploymentSensitive.trim()));
-      else deployment.setDeploymentSensitiveFactoryEnabled(true);
-
-
-      String async = getParameter(""resteasy.async.job.service.enabled"");
-      if (async != null) deployment.setAsyncJobServiceEnabled(Boolean.valueOf(async.trim()));
-      if (deployment.isAsyncJobServiceEnabled())
-      {
-         String maxJobResults = getParameter(""resteasy.async.job.service.max.job.results"");
-         if (maxJobResults != null)
-         {
-            int maxJobs = Integer.valueOf(maxJobResults);
-            deployment.setAsyncJobServiceMaxJobResults(maxJobs);
-         }
-         String maxWaitStr = getParameter(""resteasy.async.job.service.max.wait"");
-         if (maxWaitStr != null)
-         {
-            long maxWait = Long.valueOf(maxWaitStr);
-            deployment.setAsyncJobServiceMaxWait(maxWait);
-         }
-         String threadPool = getParameter(""resteasy.async.job.service.thread.pool.size"");
-         if (threadPool != null)
-         {
-            int threadPoolSize = Integer.valueOf(threadPool);
-            deployment.setAsyncJobServiceThreadPoolSize(threadPoolSize);
-         }
-         String basePath = getParameter(""resteasy.async.job.service.base.path"");
-         if (basePath != null)
-         {
-            deployment.setAsyncJobServiceBasePath(basePath);
-         }
-      }
-      String applicationConfig = getParameter(Application.class.getName());
-      if (applicationConfig == null)
-      {
-         // stupid spec doesn't use FQN of Application class name
-         applicationConfig = getParameter(""javax.ws.rs.Application"");
-      }
-      else
-      {
-         logger.warn(""The use of "" + Application.class.getName() + "" is deprecated, please use javax.ws.rs.Application as a context-param instead"");
-      }
-
-      String providers = getParameter(ResteasyContextParameters.RESTEASY_PROVIDERS);
-
-      if (providers != null && ! """".equals(providers.trim()))
-      {
-         String[] p = providers.split("","");
-         for (String pr : p) deployment.getProviderClasses().add(pr.trim());
-      }
-
-
-      String resourceMethodInterceptors = getParameter(ResteasyContextParameters.RESTEASY_RESOURCE_METHOD_INTERCEPTORS);
-
-      if (resourceMethodInterceptors != null)
-      {
-         throw new RuntimeException(ResteasyContextParameters.RESTEASY_RESOURCE_METHOD_INTERCEPTORS + "" is no longer a supported context param.  See documentation for more details"");
-      }
-
-      String resteasySecurity = getParameter(ResteasyContextParameters.RESTEASY_ROLE_BASED_SECURITY);
-      if (resteasySecurity != null) deployment.setSecurityEnabled(Boolean.valueOf(resteasySecurity.trim()));
-
-      String builtin = getParameter(ResteasyContextParameters.RESTEASY_USE_BUILTIN_PROVIDERS);
-      if (builtin != null) deployment.setRegisterBuiltin(Boolean.valueOf(builtin.trim()));
-
-      boolean scanProviders = false;
-      boolean scanResources = false;
-
-      String sProviders = getParameter(ResteasyContextParameters.RESTEASY_SCAN_PROVIDERS);
-      if (sProviders != null)
-      {
-         scanProviders = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN_PROVIDERS, sProviders);
-      }
-      String scanAll = getParameter(ResteasyContextParameters.RESTEASY_SCAN);
-      if (scanAll != null)
-      {
-         boolean tmp = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN, scanAll);
-         scanProviders = tmp || scanProviders;
-         scanResources = tmp || scanResources;
-      }
-      String sResources = getParameter(ResteasyContextParameters.RESTEASY_SCAN_RESOURCES);
-      if (sResources != null)
-      {
-         scanResources = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN_RESOURCES, sResources);
-      }
-
-      // Check to see if scanning is being done by deployer (i.e. JBoss App Server)
-      String sScannedByDeployer = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_BY_DEPLOYER);
-      if (sScannedByDeployer != null)
-      {
-         boolean tmp = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCANNED_BY_DEPLOYER, sScannedByDeployer);
-         if (tmp)
-         {
-            scanProviders = false;
-            scanResources = false;
-         }
-      }
-
-      if (scanProviders || scanResources)
-      {
-         logger.debug(""Scanning..."");
-
-         URL[] urls = getScanningUrls();
-         for (URL u : urls)
-         {
-            logger.debug(""Scanning archive: "" + u);
-         }
-         AnnotationDB db = new AnnotationDB();
-         String[] ignoredPackages = {""org.jboss.resteasy.plugins"", ""org.jboss.resteasy.annotations"", ""org.jboss.resteasy.client"", ""org.jboss.resteasy.specimpl"", ""org.jboss.resteasy.core"", ""org.jboss.resteasy.spi"", ""org.jboss.resteasy.util"", ""org.jboss.resteasy.mock"", ""javax.ws.rs""};
-         db.setIgnoredPackages(ignoredPackages);
-
-         // only index class annotations as we don't want sub-resources being picked up in the scan
-         db.setScanClassAnnotations(true);
-         db.setScanFieldAnnotations(false);
-         db.setScanMethodAnnotations(false);
-         db.setScanParameterAnnotations(false);
-         try
-         {
-            db.scanArchives(urls);
-            try
-            {
-               db.crossReferenceImplementedInterfaces();
-               db.crossReferenceMetaAnnotations();
-            }
-            catch (AnnotationDB.CrossReferenceException ignored)
-            {
-
-            }
-
-         }
-         catch (IOException e)
-         {
-            throw new RuntimeException(""Unable to scan WEB-INF for JAX-RS annotations, you must manually register your classes/resources"", e);
-         }
-
-         if (scanProviders) processScannedProviders(db);
-         if (scanResources) processScannedResources(db);
-      }
-
-
-      String scannedProviders = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_PROVIDERS);
-
-      if (scannedProviders != null)
-      {
-         String[] p = scannedProviders.split("","");
-         for (String pr : p) deployment.getScannedProviderClasses().add(pr.trim());
-      }
-
-      String scannedResources = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_RESOURCES);
-
-      if (scannedResources != null)
-      {
-         String[] p = scannedResources.split("","");
-         for (String pr : p) deployment.getScannedResourceClasses().add(pr.trim());
-      }
-
-      String scannedJndi = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_JNDI_RESOURCES);
-
-      if (scannedJndi != null)
-      {
-         processScannedJndiComponentResources(scannedJndi);
-      }
-
-
-      String jndiResources = getParameter(ResteasyContextParameters.RESTEASY_JNDI_RESOURCES);
-      if (jndiResources != null && ! """".equals(jndiResources.trim()))
-      {
-         processJndiResources(jndiResources);
-      }
-
-      String jndiComponentResources = getParameter(ResteasyContextParameters.RESTEASY_JNDI_COMPONENT_RESOURCES);
-      if (jndiComponentResources != null)
-      {
-         processJndiComponentResources(jndiComponentResources);
-      }
-
-      String resources = getParameter(ResteasyContextParameters.RESTEASY_RESOURCES);
-      if (resources != null && ! """".equals(resources.trim()))
-      {
-         processResources(resources);
-      }
-
-      String unwrapped = getParameter(ResteasyContextParameters.RESTEASY_UNWRAPPED_EXCEPTIONS);
-      if (unwrapped != null)
-      {
-         processUnwrapped(unwrapped);
-      }
-
-      String paramMapping = getParameter(ResteasyContextParameters.RESTEASY_MEDIA_TYPE_PARAM_MAPPING);
-      if (paramMapping != null)
-      {
-         paramMapping = paramMapping.trim();
-
-         if (paramMapping.length() > 0)
-         {
-            deployment.setMediaTypeParamMapping(paramMapping);
-         }
-         else
-         {
-            deployment.setMediaTypeParamMapping(HttpHeaderNames.ACCEPT.toLowerCase());
-         }
-      }
-
-      String contextObjects = getParameter(ResteasyContextParameters.RESTEASY_CONTEXT_OBJECTS);
-      if (contextObjects != null)
-      {
-         Map<String, String> map = parseMap(contextObjects);
-         deployment.setConstructedDefaultContextObjects(map);
-      }
-
-      String mimeExtentions = getParameter(ResteasyContextParameters.RESTEASY_MEDIA_TYPE_MAPPINGS);
-      if (mimeExtentions != null)
-      {
-         Map<String, String> map = parseMap(mimeExtentions);
-         deployment.setMediaTypeMappings(map);
-      }
-
-      String languageExtensions = getParameter(ResteasyContextParameters.RESTEASY_LANGUAGE_MAPPINGS);
-      if (languageExtensions != null)
-      {
-         Map<String, String> map = parseMap(languageExtensions);
-         deployment.setLanguageExtensions(map);
-      }
-      String before = getParameter(ResteasyContextParameters.RESTEASY_INTERCEPTOR_BEFORE_PRECEDENCE);
-      if (before != null)
-      {
-         Map<String, String> map = parseMap(before);
-         deployment.setInterceptorBeforePrecedences(map);
-      }
-      String after = getParameter(ResteasyContextParameters.RESTEASY_INTERCEPTOR_AFTER_PRECEDENCE);
-      if (after != null)
-      {
-         Map<String, String> map = parseMap(after);
-         deployment.setInterceptorAfterPrecedences(map);
-      }
-      String append = getParameter(ResteasyContextParameters.RESTEASY_APPEND_INTERCEPTOR_PRECEDENCE);
-      if (append != null)
-      {
-         String[] precedences = append.split("","");
-         for (String precedence : precedences)
-         {
-            deployment.getInterceptorPrecedences().add(precedence.trim());
-         }
-      }
-
-      String useContainerFormParams = getParameter(ResteasyContextParameters.USE_CONTAINER_FORM_PARAMS);
-      if (useContainerFormParams != null)
-      {
-         boolean useContainer = parseBooleanParam(ResteasyContextParameters.USE_CONTAINER_FORM_PARAMS, useContainerFormParams);
-         deployment.setUseContainerFormParams(useContainer);
-      }
-
-
-      String injectorFactoryClass = getParameter(""resteasy.injector.factory"");
-      if (injectorFactoryClass != null)
-      {
-         deployment.setInjectorFactoryClass(injectorFactoryClass);
-      }
-
-      if (applicationConfig != null) deployment.setApplicationClass(applicationConfig);
-      deployment.getDefaultContextObjects().put(ResteasyConfiguration.class, this);
-      return deployment;
-   }
-
-    private boolean parseBooleanParam(String key, String value) {
-        value = value.trim().toLowerCase();
-        if (value.equals(""true"") || value.equals(""1"")) {
-            return true;
-        } else if (value.equals(""false"") || value.equals(""0"")) {
-            return false;
-        } else {
-            throw new RuntimeException(""The "" + key + "" config in web.xml could not be parsed, accepted values are true,false or 1,0"");
-
-        }
-    }
-
-    protected Map<String, String> parseMap(String map)
-   {
-      Map<String, String> parsed = new HashMap<String, String>();
-      String[] entries = map.trim().split("","");
-      for (String entry : entries)
-      {
-         String[] split = entry.trim().split("":"");
-         parsed.put(split[0].trim(), split[1].trim());
-
-      }
-      return parsed;
-   }
-
-   protected void processJndiResources(String jndiResources)
-   {
-      String[] resources = jndiResources.trim().split("","");
-      for (String resource : resources)
-      {
-         deployment.getJndiResources().add(resource);
-      }
-   }
-
-   protected void processJndiComponentResources(String jndiResources)
-   {
-      String[] resources = jndiResources.trim().split("","");
-      for (String resource : resources)
-      {
-         deployment.getJndiComponentResources().add(resource);
-      }
-   }
-
-   protected void processScannedJndiComponentResources(String jndiResources)
-   {
-      String[] resources = jndiResources.trim().split("","");
-      for (String resource : resources)
-      {
-         deployment.getScannedJndiComponentResources().add(resource);
-      }
-   }
-
-   protected void processResources(String list)
-   {
-      String[] resources = list.trim().split("","");
-      for (String resource : resources)
-      {
-         deployment.getResourceClasses().add(resource);
-      }
-   }
-
-   protected void processUnwrapped(String list)
-   {
-      String[] resources = list.trim().split("","");
-      for (String resource : resources)
-      {
-         deployment.getUnwrappedExceptions().add(resource);
-      }
-   }
-
-   protected void processScannedProviders(AnnotationDB db)
-   {
-      Set<String> classes = db.getAnnotationIndex().get(Provider.class.getName());
-      if (classes == null) return;
-      for (String clazz : classes)
-      {
-         logger.info(""Adding scanned @Provider: "" + clazz);
-         deployment.getScannedProviderClasses().add(clazz);
-      }
-   }
-
-   protected void processScannedResources(AnnotationDB db)
-   {
-      Set<String> classes = new HashSet<String>();
-      Set<String> paths = db.getAnnotationIndex().get(Path.class.getName());
-      if (paths != null) classes.addAll(paths);
-      for (String clazz : classes)
-      {
-         Class cls = null;
-         try
-         {
-            // Ignore interfaces and subresource classes
-            // Scanning is different than other deployment methods
-            // in other deployment methods we don't want to ignore interfaces and subresources as they are
-            // application errors
-            cls = Thread.currentThread().getContextClassLoader().loadClass(clazz.trim());
-            if (cls.isInterface()) continue;
-         }
-         catch (ClassNotFoundException e)
-         {
-            throw new RuntimeException(e);
-         }
-
-         logger.info(""Adding scanned resource: "" + clazz);
-         deployment.getScannedResourceClasses().add(clazz);
-      }
-   }
-}
+package org.jboss.resteasy.plugins.server.servlet;
+
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.spi.ResteasyConfiguration;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.util.HttpHeaderNames;
+import org.scannotation.AnnotationDB;
+
+import javax.ws.rs.Path;
+import javax.ws.rs.core.Application;
+import javax.ws.rs.ext.Provider;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Create a deployment from String-based configuration data
+ *
+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+abstract public class ConfigurationBootstrap implements ResteasyConfiguration
+{
+   private static Logger logger = null;
+   private ResteasyDeployment deployment = new ResteasyDeployment();
+
+   public abstract URL[] getScanningUrls();
+
+
+   public ResteasyDeployment createDeployment()
+   {
+      String loggerTypeString = getParameter(""resteasy.logger.type"");
+      if (loggerTypeString != null)
+      {
+         Logger.LoggerType loggerType = Logger.LoggerType.valueOf(loggerTypeString);
+         Logger.setLoggerType(loggerType);
+
+      }
+      logger = Logger.getLogger(ConfigurationBootstrap.class);
+      String deploymentSensitive = getParameter(""resteasy.use.deployment.sensitive.factory"");
+      if (deploymentSensitive != null)
+         deployment.setDeploymentSensitiveFactoryEnabled(Boolean.valueOf(deploymentSensitive.trim()));
+      else deployment.setDeploymentSensitiveFactoryEnabled(true);
+
+
+      String async = getParameter(""resteasy.async.job.service.enabled"");
+      if (async != null) deployment.setAsyncJobServiceEnabled(Boolean.valueOf(async.trim()));
+      if (deployment.isAsyncJobServiceEnabled())
+      {
+         String maxJobResults = getParameter(""resteasy.async.job.service.max.job.results"");
+         if (maxJobResults != null)
+         {
+            int maxJobs = Integer.valueOf(maxJobResults);
+            deployment.setAsyncJobServiceMaxJobResults(maxJobs);
+         }
+         String maxWaitStr = getParameter(""resteasy.async.job.service.max.wait"");
+         if (maxWaitStr != null)
+         {
+            long maxWait = Long.valueOf(maxWaitStr);
+            deployment.setAsyncJobServiceMaxWait(maxWait);
+         }
+         String threadPool = getParameter(""resteasy.async.job.service.thread.pool.size"");
+         if (threadPool != null)
+         {
+            int threadPoolSize = Integer.valueOf(threadPool);
+            deployment.setAsyncJobServiceThreadPoolSize(threadPoolSize);
+         }
+         String basePath = getParameter(""resteasy.async.job.service.base.path"");
+         if (basePath != null)
+         {
+            deployment.setAsyncJobServiceBasePath(basePath);
+         }
+      }
+      String applicationConfig = getParameter(Application.class.getName());
+      if (applicationConfig == null)
+      {
+         // stupid spec doesn't use FQN of Application class name
+         applicationConfig = getParameter(""javax.ws.rs.Application"");
+      }
+      else
+      {
+         logger.warn(""The use of "" + Application.class.getName() + "" is deprecated, please use javax.ws.rs.Application as a context-param instead"");
+      }
+
+      String providers = getParameter(ResteasyContextParameters.RESTEASY_PROVIDERS);
+
+      if (providers != null && ! """".equals(providers.trim()))
+      {
+         String[] p = providers.split("","");
+         for (String pr : p) deployment.getProviderClasses().add(pr.trim());
+      }
+
+
+      String resourceMethodInterceptors = getParameter(ResteasyContextParameters.RESTEASY_RESOURCE_METHOD_INTERCEPTORS);
+
+      if (resourceMethodInterceptors != null)
+      {
+         throw new RuntimeException(ResteasyContextParameters.RESTEASY_RESOURCE_METHOD_INTERCEPTORS + "" is no longer a supported context param.  See documentation for more details"");
+      }
+
+      String resteasySecurity = getParameter(ResteasyContextParameters.RESTEASY_ROLE_BASED_SECURITY);
+      if (resteasySecurity != null) deployment.setSecurityEnabled(Boolean.valueOf(resteasySecurity.trim()));
+
+      String builtin = getParameter(ResteasyContextParameters.RESTEASY_USE_BUILTIN_PROVIDERS);
+      if (builtin != null) deployment.setRegisterBuiltin(Boolean.valueOf(builtin.trim()));
+
+      boolean scanProviders = false;
+      boolean scanResources = false;
+
+      String sProviders = getParameter(ResteasyContextParameters.RESTEASY_SCAN_PROVIDERS);
+      if (sProviders != null)
+      {
+         scanProviders = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN_PROVIDERS, sProviders);
+      }
+      String scanAll = getParameter(ResteasyContextParameters.RESTEASY_SCAN);
+      if (scanAll != null)
+      {
+         boolean tmp = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN, scanAll);
+         scanProviders = tmp || scanProviders;
+         scanResources = tmp || scanResources;
+      }
+      String sResources = getParameter(ResteasyContextParameters.RESTEASY_SCAN_RESOURCES);
+      if (sResources != null)
+      {
+         scanResources = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCAN_RESOURCES, sResources);
+      }
+
+      // Check to see if scanning is being done by deployer (i.e. JBoss App Server)
+      String sScannedByDeployer = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_BY_DEPLOYER);
+      if (sScannedByDeployer != null)
+      {
+         boolean tmp = parseBooleanParam(ResteasyContextParameters.RESTEASY_SCANNED_BY_DEPLOYER, sScannedByDeployer);
+         if (tmp)
+         {
+            scanProviders = false;
+            scanResources = false;
+         }
+      }
+
+      if (scanProviders || scanResources)
+      {
+         logger.debug(""Scanning..."");
+
+         URL[] urls = getScanningUrls();
+         for (URL u : urls)
+         {
+            logger.debug(""Scanning archive: "" + u);
+         }
+         AnnotationDB db = new AnnotationDB();
+         String[] ignoredPackages = {""org.jboss.resteasy.plugins"", ""org.jboss.resteasy.annotations"", ""org.jboss.resteasy.client"", ""org.jboss.resteasy.specimpl"", ""org.jboss.resteasy.core"", ""org.jboss.resteasy.spi"", ""org.jboss.resteasy.util"", ""org.jboss.resteasy.mock"", ""javax.ws.rs""};
+         db.setIgnoredPackages(ignoredPackages);
+
+         // only index class annotations as we don't want sub-resources being picked up in the scan
+         db.setScanClassAnnotations(true);
+         db.setScanFieldAnnotations(false);
+         db.setScanMethodAnnotations(false);
+         db.setScanParameterAnnotations(false);
+         try
+         {
+            db.scanArchives(urls);
+            try
+            {
+               db.crossReferenceImplementedInterfaces();
+               db.crossReferenceMetaAnnotations();
+            }
+            catch (AnnotationDB.CrossReferenceException ignored)
+            {
+
+            }
+
+         }
+         catch (IOException e)
+         {
+            throw new RuntimeException(""Unable to scan WEB-INF for JAX-RS annotations, you must manually register your classes/resources"", e);
+         }
+
+         if (scanProviders) processScannedProviders(db);
+         if (scanResources) processScannedResources(db);
+      }
+
+
+      String scannedProviders = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_PROVIDERS);
+
+      if (scannedProviders != null)
+      {
+         String[] p = scannedProviders.split("","");
+         for (String pr : p) deployment.getScannedProviderClasses().add(pr.trim());
+      }
+
+      String scannedResources = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_RESOURCES);
+
+      if (scannedResources != null)
+      {
+         String[] p = scannedResources.split("","");
+         for (String pr : p) deployment.getScannedResourceClasses().add(pr.trim());
+      }
+
+      String scannedJndi = getParameter(ResteasyContextParameters.RESTEASY_SCANNED_JNDI_RESOURCES);
+
+      if (scannedJndi != null)
+      {
+         processScannedJndiComponentResources(scannedJndi);
+      }
+
+
+      String jndiResources = getParameter(ResteasyContextParameters.RESTEASY_JNDI_RESOURCES);
+      if (jndiResources != null && ! """".equals(jndiResources.trim()))
+      {
+         processJndiResources(jndiResources);
+      }
+
+      String jndiComponentResources = getParameter(ResteasyContextParameters.RESTEASY_JNDI_COMPONENT_RESOURCES);
+      if (jndiComponentResources != null)
+      {
+         processJndiComponentResources(jndiComponentResources);
+      }
+
+      String resources = getParameter(ResteasyContextParameters.RESTEASY_RESOURCES);
+      if (resources != null && ! """".equals(resources.trim()))
+      {
+         processResources(resources);
+      }
+
+      String unwrapped = getParameter(ResteasyContextParameters.RESTEASY_UNWRAPPED_EXCEPTIONS);
+      if (unwrapped != null)
+      {
+         processUnwrapped(unwrapped);
+      }
+
+      String paramMapping = getParameter(ResteasyContextParameters.RESTEASY_MEDIA_TYPE_PARAM_MAPPING);
+      if (paramMapping != null)
+      {
+         paramMapping = paramMapping.trim();
+
+         if (paramMapping.length() > 0)
+         {
+            deployment.setMediaTypeParamMapping(paramMapping);
+         }
+         else
+         {
+            deployment.setMediaTypeParamMapping(HttpHeaderNames.ACCEPT.toLowerCase());
+         }
+      }
+
+      String contextObjects = getParameter(ResteasyContextParameters.RESTEASY_CONTEXT_OBJECTS);
+      if (contextObjects != null)
+      {
+         Map<String, String> map = parseMap(contextObjects);
+         deployment.setConstructedDefaultContextObjects(map);
+      }
+
+      String mimeExtentions = getParameter(ResteasyContextParameters.RESTEASY_MEDIA_TYPE_MAPPINGS);
+      if (mimeExtentions != null)
+      {
+         Map<String, String> map = parseMap(mimeExtentions);
+         deployment.setMediaTypeMappings(map);
+      }
+
+      String languageExtensions = getParameter(ResteasyContextParameters.RESTEASY_LANGUAGE_MAPPINGS);
+      if (languageExtensions != null)
+      {
+         Map<String, String> map = parseMap(languageExtensions);
+         deployment.setLanguageExtensions(map);
+      }
+      String before = getParameter(ResteasyContextParameters.RESTEASY_INTERCEPTOR_BEFORE_PRECEDENCE);
+      if (before != null)
+      {
+         Map<String, String> map = parseMap(before);
+         deployment.setInterceptorBeforePrecedences(map);
+      }
+      String after = getParameter(ResteasyContextParameters.RESTEASY_INTERCEPTOR_AFTER_PRECEDENCE);
+      if (after != null)
+      {
+         Map<String, String> map = parseMap(after);
+         deployment.setInterceptorAfterPrecedences(map);
+      }
+      String append = getParameter(ResteasyContextParameters.RESTEASY_APPEND_INTERCEPTOR_PRECEDENCE);
+      if (append != null)
+      {
+         String[] precedences = append.split("","");
+         for (String precedence : precedences)
+         {
+            deployment.getInterceptorPrecedences().add(precedence.trim());
+         }
+      }
+
+      String useContainerFormParams = getParameter(ResteasyContextParameters.USE_CONTAINER_FORM_PARAMS);
+      if (useContainerFormParams != null)
+      {
+         boolean useContainer = parseBooleanParam(ResteasyContextParameters.USE_CONTAINER_FORM_PARAMS, useContainerFormParams);
+         deployment.setUseContainerFormParams(useContainer);
+      }
+
+
+      String injectorFactoryClass = getParameter(""resteasy.injector.factory"");
+      if (injectorFactoryClass != null)
+      {
+         deployment.setInjectorFactoryClass(injectorFactoryClass);
+      }
+
+      if (applicationConfig != null) deployment.setApplicationClass(applicationConfig);
+      deployment.getDefaultContextObjects().put(ResteasyConfiguration.class, this);
+      return deployment;
+   }
+
+    private boolean parseBooleanParam(String key, String value) {
+        value = value.trim().toLowerCase();
+        if (value.equals(""true"") || value.equals(""1"")) {
+            return true;
+        } else if (value.equals(""false"") || value.equals(""0"")) {
+            return false;
+        } else {
+            throw new RuntimeException(""The "" + key + "" config in web.xml could not be parsed, accepted values are true,false or 1,0"");
+
+        }
+    }
+
+    protected Map<String, String> parseMap(String map)
+   {
+      Map<String, String> parsed = new HashMap<String, String>();
+      String[] entries = map.trim().split("","");
+      for (String entry : entries)
+      {
+         String[] split = entry.trim().split("":"");
+         parsed.put(split[0].trim(), split[1].trim());
+
+      }
+      return parsed;
+   }
+
+   protected void processJndiResources(String jndiResources)
+   {
+      String[] resources = jndiResources.trim().split("","");
+      for (String resource : resources)
+      {
+         deployment.getJndiResources().add(resource);
+      }
+   }
+
+   protected void processJndiComponentResources(String jndiResources)
+   {
+      String[] resources = jndiResources.trim().split("","");
+      for (String resource : resources)
+      {
+         deployment.getJndiComponentResources().add(resource);
+      }
+   }
+
+   protected void processScannedJndiComponentResources(String jndiResources)
+   {
+      String[] resources = jndiResources.trim().split("","");
+      for (String resource : resources)
+      {
+         deployment.getScannedJndiComponentResources().add(resource);
+      }
+   }
+
+   protected void processResources(String list)
+   {
+      String[] resources = list.trim().split("","");
+      for (String resource : resources)
+      {
+         deployment.getResourceClasses().add(resource);
+      }
+   }
+
+   protected void processUnwrapped(String list)
+   {
+      String[] resources = list.trim().split("","");
+      for (String resource : resources)
+      {
+         deployment.getUnwrappedExceptions().add(resource);
+      }
+   }
+
+   protected void processScannedProviders(AnnotationDB db)
+   {
+      Set<String> classes = db.getAnnotationIndex().get(Provider.class.getName());
+      if (classes == null) return;
+      for (String clazz : classes)
+      {
+         logger.info(""Adding scanned @Provider: "" + clazz);
+         deployment.getScannedProviderClasses().add(clazz);
+      }
+   }
+
+   protected void processScannedResources(AnnotationDB db)
+   {
+      Set<String> classes = new HashSet<String>();
+      Set<String> paths = db.getAnnotationIndex().get(Path.class.getName());
+      if (paths != null) classes.addAll(paths);
+      for (String clazz : classes)
+      {
+         Class cls = null;
+         try
+         {
+            // Ignore interfaces and subresource classes
+            // Scanning is different than other deployment methods
+            // in other deployment methods we don't want to ignore interfaces and subresources as they are
+            // application errors
+            cls = Thread.currentThread().getContextClassLoader().loadClass(clazz.trim());
+            if (cls.isInterface()) continue;
+         }
+         catch (ClassNotFoundException e)
+         {
+            throw new RuntimeException(e);
+         }
+
+         logger.info(""Adding scanned resource: "" + clazz);
+         deployment.getScannedResourceClasses().add(clazz);
+      }
+   }
+}",2013-06-09T13:48:56Z,279
"@@ -9,8 +9,11 @@
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>
@@ -25,13 +28,29 @@ public ListenerBootstrap(ServletContext servletContext)
       this.servletContext = servletContext;
    }
 
+   private static Object RD_LOCK = new Object();
+
    @Override
    public ResteasyDeployment createDeployment()
    {
       ResteasyDeployment deployment = (ResteasyDeployment) servletContext.getAttribute(ResteasyDeployment.class.getName());
       if (deployment == null) deployment = super.createDeployment();
       deployment.getDefaultContextObjects().put(ServletContext.class, servletContext);
       deployment.getDefaultContextObjects().put(ResteasyConfiguration.class, this);
+      String servletMappingPrefix = getParameter(ResteasyContextParameters.RESTEASY_SERVLET_MAPPING_PREFIX);
+      if (servletMappingPrefix == null) servletMappingPrefix = """";
+      servletMappingPrefix = servletMappingPrefix.trim();
+
+      synchronized (RD_LOCK)
+      {
+         Map<String, ResteasyDeployment> deployments = (Map<String, ResteasyDeployment>) servletContext.getAttribute(ResteasyContextParameters.RESTEASY_DEPLOYMENTS);
+         if (deployments == null)
+         {
+            deployments = new ConcurrentHashMap<String, ResteasyDeployment>();
+            servletContext.setAttribute(""resteasy.deployments"", deployments);
+         }
+         deployments.put(servletMappingPrefix, deployment);
+      }
       return deployment;
    }
 ",2013-06-09T13:48:56Z,280
"@@ -39,4 +39,6 @@ public interface ResteasyContextParameters
    String RESTEASY_SCANNED_JNDI_RESOURCES = ""resteasy.scanned.jndi.resources"";
    String RESTEASY_CONTEXT_OBJECTS = ""resteasy.context.objects"";
    String USE_CONTAINER_FORM_PARAMS = ""use.container.form.params"";
+   String RESTEASY_DEPLOYMENTS = ""resteasy.deployments"";
+   String RESTEASY_SERVLET_MAPPING_PREFIX = ""resteasy.servlet.mapping.prefix"";
 }",2013-06-09T13:48:56Z,281
"@@ -102,7 +102,7 @@ public void init(ServletContext servletContext, ConfigurationBootstrap bootstrap
                }
             }
          }
-         servletMappingPrefix = bootstrap.getParameter(""resteasy.servlet.mapping.prefix"");
+         servletMappingPrefix = bootstrap.getParameter(ResteasyContextParameters.RESTEASY_SERVLET_MAPPING_PREFIX);
          if (servletMappingPrefix == null) servletMappingPrefix = """";
          servletMappingPrefix = servletMappingPrefix.trim();
       }
@@ -113,7 +113,7 @@ public void init(ServletContext servletContext, ConfigurationBootstrap bootstrap
          dispatcher = deployment.getDispatcher();
          providerFactory = deployment.getProviderFactory();
 
-         servletMappingPrefix = bootstrap.getParameter(""resteasy.servlet.mapping.prefix"");
+         servletMappingPrefix = bootstrap.getParameter(ResteasyContextParameters.RESTEASY_SERVLET_MAPPING_PREFIX);
          if (servletMappingPrefix == null) servletMappingPrefix = """";
          servletMappingPrefix = servletMappingPrefix.trim();
       }",2013-06-09T13:48:56Z,282
"@@ -1,81 +1,97 @@
-package org.jboss.resteasy.jsapi;
-
-import java.io.IOException;
-import java.io.PrintWriter;
-
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.PrintWriter;
-import org.jboss.resteasy.core.ResourceMethodRegistry;
-import org.jboss.resteasy.logging.Logger;
-import org.jboss.resteasy.spi.Registry;
-import org.jboss.resteasy.spi.ResteasyProviderFactory;
-
-
-/**
- * @author Stéphane Épardaud <stef@epardaud.fr>
- */
-public class JSAPIServlet extends HttpServlet
-{
-
-	private static final long serialVersionUID = -1985015444704126795L;
-
-	private final static Logger logger = Logger.getLogger(JSAPIServlet.class);
-	private ServiceRegistry service;
-
-	private JSAPIWriter apiWriter;
-
-	@Override
-	public void init(ServletConfig config) throws ServletException
-	{
-		super.init(config);
-		if (logger.isDebugEnabled())
-			logger.info(""Loading JSAPI Servlet"");
-
-		scanResources();
-		
-		if (logger.isDebugEnabled())
-			logger.debug(""JSAPIServlet loaded"");
-
-		// make it possible to get to us for rescanning
-		ServletContext servletContext = config .getServletContext();
-		servletContext.setAttribute(getClass().getName(), this);
-	}
-
-	@Override
-	protected void service(HttpServletRequest req, HttpServletResponse resp)
-	throws ServletException, IOException
-	{
-		String pathInfo = req.getPathInfo();
-		String uri = req.getRequestURL().toString();
-		uri = uri.substring(0, uri.length() - req.getServletPath().length());
-		if (logger.isDebugEnabled())
-		{
-			logger.debug(""Serving "" + pathInfo);
-			logger.debug(""Query "" + req.getQueryString());
-		}
-
-        this.apiWriter.writeJavaScript(uri, req, resp, service);
-	}
-
-	public void scanResources(){
-
-		ServletConfig config = getServletConfig();
-		ServletContext servletContext = config .getServletContext();
-		ResourceMethodRegistry registry = (ResourceMethodRegistry) servletContext
-		.getAttribute(Registry.class.getName());
-		ResteasyProviderFactory providerFactory = 
-			(ResteasyProviderFactory) servletContext.getAttribute(ResteasyProviderFactory.class.getName());
-
-		String restPath = servletContext
-		.getInitParameter(""resteasy.servlet.mapping.prefix"");
-
-		service = new ServiceRegistry(null, registry, providerFactory, null);
-		apiWriter = new JSAPIWriter(restPath);
-	}
-}
+package org.jboss.resteasy.jsapi;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.jboss.resteasy.core.ResourceMethodRegistry;
+import org.jboss.resteasy.logging.Logger;
+import org.jboss.resteasy.plugins.server.servlet.ResteasyContextParameters;
+import org.jboss.resteasy.spi.Registry;
+import org.jboss.resteasy.spi.ResteasyDeployment;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+
+/**
+ * @author Stéphane Épardaud <stef@epardaud.fr>
+ */
+public class JSAPIServlet extends HttpServlet
+{
+
+   private static final long serialVersionUID = -1985015444704126795L;
+
+   private final static Logger logger = Logger.getLogger(JSAPIServlet.class);
+   private Map<String, ServiceRegistry> services;
+
+   private JSAPIWriter apiWriter = new JSAPIWriter();
+
+   @Override
+   public void init(ServletConfig config) throws ServletException
+   {
+      super.init(config);
+      if (logger.isDebugEnabled())
+         logger.info(""Loading JSAPI Servlet"");
+
+      scanResources();
+
+      if (logger.isDebugEnabled())
+         logger.debug(""JSAPIServlet loaded"");
+
+      // make it possible to get to us for rescanning
+      ServletContext servletContext = config.getServletContext();
+      servletContext.setAttribute(getClass().getName(), this);
+   }
+
+   @Override
+   protected void service(HttpServletRequest req, HttpServletResponse resp)
+           throws ServletException, IOException
+   {
+      String pathInfo = req.getPathInfo();
+      String uri = req.getRequestURL().toString();
+      uri = uri.substring(0, uri.length() - req.getServletPath().length());
+      if (logger.isDebugEnabled())
+      {
+         logger.debug(""Serving "" + pathInfo);
+         logger.debug(""Query "" + req.getQueryString());
+      }
+      if (this.services == null) scanResources();
+      if (this.services == null)
+      {
+         resp.sendError(503, ""There are no Resteasy deployments initialized yet to scan from.  Either set the load-on-startup on each Resteasy servlet, or, if in an EE environment like JBoss or Wildfly, you'll have to do an invocation on each of your REST services to get the servlet loaded."");
+      }
+      this.apiWriter.writeJavaScript(uri, req, resp, services);
+   }
+
+   public void scanResources()
+   {
+
+      ServletConfig config = getServletConfig();
+      ServletContext servletContext = config.getServletContext();
+      Map<String, ResteasyDeployment> deployments = (Map<String, ResteasyDeployment>) servletContext.getAttribute(ResteasyContextParameters.RESTEASY_DEPLOYMENTS);
+
+      if (deployments == null) return;
+      synchronized (this)
+      {
+         services = new HashMap<String, ServiceRegistry>();
+         for (Map.Entry<String, ResteasyDeployment> entry : deployments.entrySet())
+         {
+            ResourceMethodRegistry registry = (ResourceMethodRegistry) entry.getValue().getRegistry();
+            ResteasyProviderFactory providerFactory =
+                    (ResteasyProviderFactory) entry.getValue().getProviderFactory();
+            ServiceRegistry service = new ServiceRegistry(null, registry, providerFactory, null);
+            services.put(entry.getKey(), service);
+         }
+      }
+   }
+}",2013-06-09T13:48:56Z,283
"@@ -9,6 +9,7 @@
 import java.io.*;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.zip.GZIPOutputStream;
@@ -19,43 +20,41 @@
 public class JSAPIWriter
 {
 
-	private static final long serialVersionUID = -1985015444704126795L;
-
-	private final static Logger logger = Logger.getLogger(JSAPIWriter.class);
-	private String restPath;
-
-	public JSAPIWriter(String restPath)
-	{
-		this.restPath = restPath;
-	}
-
-    public void writeJavaScript(String uri, HttpServletRequest req, HttpServletResponse resp,
-                                ServiceRegistry serviceRegistry) throws IOException {
-        if (restPath != null)
-            uri = uri + restPath;
-        logger.info(""rest path: "" + uri);
-
-        logger.info(""// start RESTEasy client API"");
-
-        // RESTEASY-776
-        // before writing generated javascript, we generate Etag and compare it with client request.
-        // If nothing changed, we send back 304 Not Modified for client browser to use cached js.
-        String ifNoneMatch = req.getHeader(""If-None-Match"");
-        String etag = generateEtag(serviceRegistry);
-        resp.setHeader(""Etag"", etag);
-
-        if (ifNoneMatch != null && ifNoneMatch.equals(etag)) {
-            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
-            return;
-        }
-
-        StringWriter stringWriter = new StringWriter();
-        PrintWriter writer = new PrintWriter(new BufferedWriter(stringWriter));
-        writeJavaScript(uri, writer, serviceRegistry);
-        writer.flush();
-        writer.close();
-
-        if (clientIsGzipSupported(req)) {
+   private static final long serialVersionUID = -1985015444704126795L;
+
+   private final static Logger logger = Logger.getLogger(JSAPIWriter.class);
+
+   public void writeJavaScript(String base, HttpServletRequest req, HttpServletResponse resp,
+                               Map<String, ServiceRegistry> serviceRegistries) throws IOException
+   {
+      logger.debug(""// start RESTEasy client API"");
+
+      // RESTEASY-776
+      // before writing generated javascript, we generate Etag and compare it with client request.
+      // If nothing changed, we send back 304 Not Modified for client browser to use cached js.
+      String ifNoneMatch = req.getHeader(""If-None-Match"");
+      String etag = generateEtag(serviceRegistries);
+      resp.setHeader(""Etag"", etag);
+
+      if (ifNoneMatch != null && ifNoneMatch.equals(etag))
+      {
+         resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
+         return;
+      }
+
+      for (Map.Entry<String, ServiceRegistry> entry : serviceRegistries.entrySet())
+      {
+         String uri = base;
+         if (entry.getKey() != null) uri += entry.getKey();
+
+         StringWriter stringWriter = new StringWriter();
+         PrintWriter writer = new PrintWriter(new BufferedWriter(stringWriter));
+         writeJavaScript(uri, writer, entry.getValue());
+         writer.flush();
+         writer.close();
+
+         if (clientIsGzipSupported(req))
+         {
             ByteArrayOutputStream compressedContent = new ByteArrayOutputStream();
             GZIPOutputStream gzipstream = new GZIPOutputStream(compressedContent);
             gzipstream.write(stringWriter.toString().getBytes());
@@ -73,226 +72,244 @@ public void writeJavaScript(String uri, HttpServletRequest req, HttpServletRespo
             output.flush();
             output.close();
 
-        } else {
+         }
+         else
+         {
             ServletOutputStream output = resp.getOutputStream();
             byte[] bytes = stringWriter.toString().getBytes();
             resp.setContentLength(bytes.length);
             output.write(bytes);
             output.flush();
             output.close();
-        }
-
-    }
-
-    private boolean clientIsGzipSupported(HttpServletRequest req) {
-        String encoding = req.getHeader(""Accept-Encoding"");
-        return encoding != null && encoding.contains(""gzip"");
-    }
-
-    public void writeJavaScript(String uri, PrintWriter writer,
-                                ServiceRegistry serviceRegistry) throws IOException {
-        copyResource(""/resteasy-client.js"", writer);
-        logger.info(""// start JAX-RS API"");
-        logger.info(""REST.apiURL = '"" + uri + ""';"");
-        writer.println(""REST.apiURL = '"" + uri + ""';"");
-        Set<String> declaredPrefixes = new HashSet<String>();
-        printService(writer, serviceRegistry, declaredPrefixes);
-
-    }
-
-
-    private String generateEtag(ServiceRegistry serviceRegistry) {
-        StringBuilder etagBuilder = new StringBuilder();
-        generateEtag(serviceRegistry, etagBuilder);
-        return String.valueOf(Math.abs(etagBuilder.toString().hashCode()));
-    }
-
-    private void generateEtag(ServiceRegistry serviceRegistry, StringBuilder etagBuilder) {
-        for (MethodMetaData methodMetaData : serviceRegistry.getMethodMetaData()) {
-                etagBuilder.append(methodMetaData.hashCode());
-
-            for(ServiceRegistry subService : serviceRegistry.getLocators()) {
-                generateEtag(subService, etagBuilder);
-            }
-
-        }
-    }
-
-    private void printService(PrintWriter writer,
-			ServiceRegistry serviceRegistry, Set<String> declaredPrefixes) {
-
-
-		for (MethodMetaData methodMetaData : serviceRegistry.getMethodMetaData())
-		{
-			logger.info(""Path: "" + methodMetaData.getUri());
-			logger.info("" Invoker: "" + methodMetaData.getResource());
-			String declaringPrefix = methodMetaData.getFunctionPrefix();
-			declarePrefix(writer, declaringPrefix, declaredPrefixes);
-			
-			for (String httpMethod : methodMetaData.getHttpMethods())
-			{
-				print(writer, httpMethod, methodMetaData);
-			}
-		}
-		for(ServiceRegistry subService : serviceRegistry.getLocators())
-			printService(writer, subService, declaredPrefixes);
-	}
-
-	private void declarePrefix(PrintWriter writer, String declaringPrefix, Set<String> declaredPrefixes) {
-		if (declaredPrefixes.add(declaringPrefix))
-		{
-			int lastDot = declaringPrefix.lastIndexOf(""."");
-			if(lastDot == -1)
-				writer.println(""var "" + declaringPrefix + "" = {};"");
-			else{
-				declarePrefix(writer, declaringPrefix.substring(0, lastDot), declaredPrefixes);
-				writer.println(declaringPrefix + "" = {};"");
-			}
-		}
-
-	}
-
-	private void copyResource(String name, PrintWriter writer)
-	throws IOException
-	{
-		Reader reader = new InputStreamReader(getClass()
-				.getResourceAsStream(name));
-		char[] array = new char[1024];
-		int read;
-		while ((read = reader.read(array)) >= 0)
-		{
-			writer.write(array, 0, read);
-		}
-		reader.close();
-	}
-
-	private void print(PrintWriter writer, String httpMethod,
-			MethodMetaData methodMetaData)
-	{
-		String uri = methodMetaData.getUri();
-		writer.println(""// "" + httpMethod + "" "" + uri);
-		writer
-		.println(methodMetaData.getFunctionName() + "" = function(_params){"");
-		writer.println("" var params = _params ? _params : {};"");
-		writer.println("" var request = new REST.Request();"");
-		writer.println("" request.setMethod('"" + httpMethod + ""');"");
-		writer
-		.println("" var uri = params.$apiURL ? params.$apiURL : REST.apiURL;"");
-		if (uri.contains(""{""))
-		{
-			printURIParams(uri, writer);
-		} else
-		{
-			writer.println("" uri += '"" + uri + ""';"");
-		}
-		printOtherParams(methodMetaData, writer);
-		writer.println("" request.setURI(uri);"");
-		writer.println("" if(params.$username && params.$password)"");
-		writer
-		.println(""  request.setCredentials(params.$username, params.$password);"");
-		writer.println("" if(params.$accepts)"");
-		writer.println(""  request.setAccepts(params.$accepts);"");
-		if (methodMetaData.getWants() != null)
-		{
-			writer.println("" else"");
-			writer.println(""  request.setAccepts('"" + methodMetaData.getWants()
-					+ ""');"");
-		}
-
-        writer.println(""if (REST.antiBrowserCache == true) {"");
-        writer.println(""  request.addQueryParameter('resteasy_jsapi_anti_cache', (new Date().getTime()));"");
-        writer.println(""    var cached_obj = REST._get_cache_signature(REST._generate_cache_signature(uri));"");
-
-        writer.println(""    if (cached_obj != null) { request.addHeader('If-Modified-Since', cached_obj[1]['Last-Modified']); request.addHeader('If-None-Match', cached_obj[1]['Etag']);}"");
-
-        writer.println(""}"");
-
-
-        writer.println("" if(params.$contentType)"");
-		writer.println(""  request.setContentType(params.$contentType);"");
-		writer.println("" else"");
-		writer.println(""  request.setContentType('""
-				+ methodMetaData.getConsumesMIMEType() + ""');"");
-		writer.println("" if(params.$callback){"");
-		writer.println(""  request.execute(params.$callback);"");
-		writer.println("" }else{"");
-		writer.println(""  var returnValue;"");
-		writer.println(""  request.setAsync(false);"");
-		writer
-		.println(""  var callback = function(httpCode, xmlHttpRequest, value){ returnValue = value;};"");
-		writer.println(""  request.execute(callback);"");
-		writer.println(""  return returnValue;"");
-		writer.println("" }"");
-		writer.println(""};"");
-	}
-
-	private void printOtherParams(MethodMetaData methodMetaData,
-			PrintWriter writer)
-	{
-		List<MethodParamMetaData> params = methodMetaData.getParameters();
-		for (MethodParamMetaData methodParamMetaData : params)
-		{
-			printParameter(methodParamMetaData, writer);
-		}
-	}
-
-	private void printParameter(MethodParamMetaData metaData,
-			PrintWriter writer)
-	{
-		switch(metaData.getParamType()){
-		case QUERY_PARAMETER:
-			print(metaData, writer, ""QueryParameter"");
-			break;
-		case HEADER_PARAMETER:
-			print(metaData, writer, ""Header"");
-			// FIXME: warn about forbidden headers:
-			// http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method
-			break;
-		case COOKIE_PARAMETER:
-			print(metaData, writer, ""Cookie"");
-			break;
-		case MATRIX_PARAMETER:
-			print(metaData, writer, ""MatrixParameter"");
-			break;
-		case FORM_PARAMETER:
-			print(metaData, writer, ""FormParameter"");
-			break;
-        case FORM:
+         }
+      }
+
+   }
+
+   private boolean clientIsGzipSupported(HttpServletRequest req)
+   {
+      String encoding = req.getHeader(""Accept-Encoding"");
+      return encoding != null && encoding.contains(""gzip"");
+   }
+
+   public void writeJavaScript(String uri, PrintWriter writer,
+                               ServiceRegistry serviceRegistry) throws IOException
+   {
+      copyResource(""/resteasy-client.js"", writer);
+      logger.debug(""// start JAX-RS API"");
+      logger.debug(""REST.apiURL = '"" + uri + ""';"");
+      writer.println(""REST.apiURL = '"" + uri + ""';"");
+      Set<String> declaredPrefixes = new HashSet<String>();
+      printService(writer, serviceRegistry, declaredPrefixes);
+
+   }
+
+
+   private String generateEtag(Map<String, ServiceRegistry> serviceRegistries)
+   {
+      StringBuilder etagBuilder = new StringBuilder();
+      for (Map.Entry<String, ServiceRegistry> entry : serviceRegistries.entrySet())
+      {
+         if (entry.getKey() != null) etagBuilder.append(entry.getKey()).append(':');
+         generateEtag(entry.getValue(), etagBuilder);
+      }
+      return String.valueOf(Math.abs(etagBuilder.toString().hashCode()));
+   }
+
+   private void generateEtag(ServiceRegistry serviceRegistry, StringBuilder etagBuilder)
+   {
+      for (MethodMetaData methodMetaData : serviceRegistry.getMethodMetaData())
+      {
+         etagBuilder.append(methodMetaData.hashCode());
+
+         for (ServiceRegistry subService : serviceRegistry.getLocators())
+         {
+            generateEtag(subService, etagBuilder);
+         }
+
+      }
+   }
+
+   private void printService(PrintWriter writer,
+                             ServiceRegistry serviceRegistry, Set<String> declaredPrefixes)
+   {
+
+
+      for (MethodMetaData methodMetaData : serviceRegistry.getMethodMetaData())
+      {
+         logger.debug(""Path: "" + methodMetaData.getUri());
+         logger.debug("" Invoker: "" + methodMetaData.getResource());
+         String declaringPrefix = methodMetaData.getFunctionPrefix();
+         declarePrefix(writer, declaringPrefix, declaredPrefixes);
+
+         for (String httpMethod : methodMetaData.getHttpMethods())
+         {
+            print(writer, httpMethod, methodMetaData);
+         }
+      }
+      for (ServiceRegistry subService : serviceRegistry.getLocators())
+         printService(writer, subService, declaredPrefixes);
+   }
+
+   private void declarePrefix(PrintWriter writer, String declaringPrefix, Set<String> declaredPrefixes)
+   {
+      if (declaredPrefixes.add(declaringPrefix))
+      {
+         int lastDot = declaringPrefix.lastIndexOf(""."");
+         if (lastDot == -1)
+            writer.println(""var "" + declaringPrefix + "" = {};"");
+         else
+         {
+            declarePrefix(writer, declaringPrefix.substring(0, lastDot), declaredPrefixes);
+            writer.println(declaringPrefix + "" = {};"");
+         }
+      }
+
+   }
+
+   private void copyResource(String name, PrintWriter writer)
+           throws IOException
+   {
+      Reader reader = new InputStreamReader(getClass()
+              .getResourceAsStream(name));
+      char[] array = new char[1024];
+      int read;
+      while ((read = reader.read(array)) >= 0)
+      {
+         writer.write(array, 0, read);
+      }
+      reader.close();
+   }
+
+   private void print(PrintWriter writer, String httpMethod,
+                      MethodMetaData methodMetaData)
+   {
+      String uri = methodMetaData.getUri();
+      writer.println(""// "" + httpMethod + "" "" + uri);
+      writer
+              .println(methodMetaData.getFunctionName() + "" = function(_params){"");
+      writer.println("" var params = _params ? _params : {};"");
+      writer.println("" var request = new REST.Request();"");
+      writer.println("" request.setMethod('"" + httpMethod + ""');"");
+      writer
+              .println("" var uri = params.$apiURL ? params.$apiURL : REST.apiURL;"");
+      if (uri.contains(""{""))
+      {
+         printURIParams(uri, writer);
+      }
+      else
+      {
+         writer.println("" uri += '"" + uri + ""';"");
+      }
+      printOtherParams(methodMetaData, writer);
+      writer.println("" request.setURI(uri);"");
+      writer.println("" if(params.$username && params.$password)"");
+      writer
+              .println(""  request.setCredentials(params.$username, params.$password);"");
+      writer.println("" if(params.$accepts)"");
+      writer.println(""  request.setAccepts(params.$accepts);"");
+      if (methodMetaData.getWants() != null)
+      {
+         writer.println("" else"");
+         writer.println(""  request.setAccepts('"" + methodMetaData.getWants()
+                 + ""');"");
+      }
+
+      writer.println(""if (REST.antiBrowserCache == true) {"");
+      writer.println(""  request.addQueryParameter('resteasy_jsapi_anti_cache', (new Date().getTime()));"");
+      writer.println(""    var cached_obj = REST._get_cache_signature(REST._generate_cache_signature(uri));"");
+
+      writer.println(""    if (cached_obj != null) { request.addHeader('If-Modified-Since', cached_obj[1]['Last-Modified']); request.addHeader('If-None-Match', cached_obj[1]['Etag']);}"");
+
+      writer.println(""}"");
+
+
+      writer.println("" if(params.$contentType)"");
+      writer.println(""  request.setContentType(params.$contentType);"");
+      writer.println("" else"");
+      writer.println(""  request.setContentType('""
+              + methodMetaData.getConsumesMIMEType() + ""');"");
+      writer.println("" if(params.$callback){"");
+      writer.println(""  request.execute(params.$callback);"");
+      writer.println("" }else{"");
+      writer.println(""  var returnValue;"");
+      writer.println(""  request.setAsync(false);"");
+      writer
+              .println(""  var callback = function(httpCode, xmlHttpRequest, value){ returnValue = value;};"");
+      writer.println(""  request.execute(callback);"");
+      writer.println(""  return returnValue;"");
+      writer.println("" }"");
+      writer.println(""};"");
+   }
+
+   private void printOtherParams(MethodMetaData methodMetaData,
+                                 PrintWriter writer)
+   {
+      List<MethodParamMetaData> params = methodMetaData.getParameters();
+      for (MethodParamMetaData methodParamMetaData : params)
+      {
+         printParameter(methodParamMetaData, writer);
+      }
+   }
+
+   private void printParameter(MethodParamMetaData metaData,
+                               PrintWriter writer)
+   {
+      switch (metaData.getParamType())
+      {
+         case QUERY_PARAMETER:
+            print(metaData, writer, ""QueryParameter"");
+            break;
+         case HEADER_PARAMETER:
+            print(metaData, writer, ""Header"");
+            // FIXME: warn about forbidden headers:
+            // http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method
+            break;
+         case COOKIE_PARAMETER:
+            print(metaData, writer, ""Cookie"");
+            break;
+         case MATRIX_PARAMETER:
+            print(metaData, writer, ""MatrixParameter"");
+            break;
+         case FORM_PARAMETER:
+            print(metaData, writer, ""FormParameter"");
+            break;
+         case FORM:
             print(metaData, writer, ""Form"");
             break;
-		case ENTITY_PARAMETER:
-			// the entity
-			writer.println("" if(params.$entity)"");
-			writer.println(""  request.setEntity(params.$entity);"");
-			break;
-		}
-	}
-
-	private void print(MethodParamMetaData metaData, PrintWriter writer,
-			String type)
-	{
-		String paramName = metaData.getParamName();
-		writer.println(String.format("" if(Object.prototype.hasOwnProperty.call(params, '%s'))\n  request.add%s('%s', params.%s);"", paramName, type, paramName, paramName));
-	}
-
-
-	private void printURIParams(String uri, PrintWriter writer)
-	{
-		String replacedCurlyURI = PathHelper.replaceEnclosedCurlyBraces(uri);
-		Matcher matcher = PathHelper.URI_PARAM_PATTERN.matcher(replacedCurlyURI);
-		int i = 0;
-		while (matcher.find())
-		{
-			if (matcher.start() > i)
-			{
-				writer.println("" uri += '""
-						+ replacedCurlyURI.substring(i, matcher.start()) + ""';"");
-			}
-			String name = matcher.group(1);
-			writer.println("" uri += REST.Encoding.encodePathSegment(params."" + name + "");"");
-			i = matcher.end();
-		}
-		if (i < replacedCurlyURI.length())
-			writer.println("" uri += '"" + replacedCurlyURI.substring(i) + ""';"");
-	}
+         case ENTITY_PARAMETER:
+            // the entity
+            writer.println("" if(params.$entity)"");
+            writer.println(""  request.setEntity(params.$entity);"");
+            break;
+      }
+   }
+
+   private void print(MethodParamMetaData metaData, PrintWriter writer,
+                      String type)
+   {
+      String paramName = metaData.getParamName();
+      writer.println(String.format("" if(Object.prototype.hasOwnProperty.call(params, '%s'))\n  request.add%s('%s', params.%s);"", paramName, type, paramName, paramName));
+   }
+
+
+   private void printURIParams(String uri, PrintWriter writer)
+   {
+      String replacedCurlyURI = PathHelper.replaceEnclosedCurlyBraces(uri);
+      Matcher matcher = PathHelper.URI_PARAM_PATTERN.matcher(replacedCurlyURI);
+      int i = 0;
+      while (matcher.find())
+      {
+         if (matcher.start() > i)
+         {
+            writer.println("" uri += '""
+                    + replacedCurlyURI.substring(i, matcher.start()) + ""';"");
+         }
+         String name = matcher.group(1);
+         writer.println("" uri += REST.Encoding.encodePathSegment(params."" + name + "");"");
+         i = matcher.end();
+      }
+      if (i < replacedCurlyURI.length())
+         writer.println("" uri += '"" + replacedCurlyURI.substring(i) + ""';"");
+   }
 }",2013-06-09T13:48:56Z,284
"@@ -33,7 +33,7 @@ public void test() throws IOException
       rmr.addPerRequestResource(FooResource.class);
       ServiceRegistry service = new ServiceRegistry(null, rmr, providerFactory, null);
       PrintWriter printWriter = new PrintWriter(System.out);
-      new JSAPIWriter(""/base"").writeJavaScript("""", printWriter, service);
+      new JSAPIWriter().writeJavaScript("""", printWriter, service);
       printWriter.close();
    }
 }",2013-06-09T13:48:56Z,285
"@@ -310,17 +310,21 @@ public ResteasyWebTarget queryParamNoTemplate(String name, Object... values) thr
    {
       client.abortIfClosed();
       if (name == null) throw new NullPointerException(Messages.MESSAGES.nameWasNull());
+
+      //The whole array can be represented as one object, so we need to cast it to array of objects
+      if (values.length == 1 && values[0].getClass().isArray() && !values[0].getClass().getComponentType().isPrimitive()) {
+         values = (Object[]) values[0];
+      }
+
       String[] stringValues = toStringValues(values);
       ResteasyUriBuilder copy;
       if (uriBuilder instanceof ResteasyUriBuilder) {
          copy = (ResteasyUriBuilder)uriBuilder.clone();
       } else {
          copy = ResteasyUriBuilder.fromTemplate(uriBuilder.toTemplate());
       }
-      for (String obj : stringValues)
-      {
-         copy.clientQueryParam(name, obj);
-      }
+
+      copy.clientQueryParam(name, stringValues);
       return  newInstance(client, copy, configuration);
    }
 ",2019-02-12T11:48:15Z,286
"@@ -1,6 +1,7 @@
 package org.jboss.resteasy.client.jaxrs.internal.proxy.processors;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
 import java.lang.reflect.Type;
 import java.util.Collection;
 
@@ -32,7 +33,7 @@ public AbstractCollectionProcessor(final String paramName, final Type type, fina
       this.config = config;
    }
 
-   protected abstract T apply(T target, Object object);
+   protected abstract T apply(T target, Object... objects);
 
    @SuppressWarnings(""unchecked"")
    public T buildIt(T target, Object object)
@@ -50,10 +51,7 @@ public T buildIt(T target, Object object)
             }
             else
             {
-               for (Object obj : (Collection<?>) object)
-               {
-                  target = apply(target, obj);
-               }
+               target = apply(target,  ((Collection<?>) object).toArray());
             }
          }
       }
@@ -65,46 +63,10 @@ else if (object.getClass().isArray())
             object = paramConverter.toString(object);
             target = apply(target, object);
          }
-         else if (object.getClass().getComponentType().isPrimitive())
-         {
-            Class<?> componentType = object.getClass().getComponentType();
-            if (componentType.equals(boolean.class))
-            {
-               for (boolean bool : (boolean[]) object) target = apply(target, bool);
-            }
-            else if (componentType.equals(byte.class))
-            {
-               for (byte val : (byte[]) object) target = apply(target, val);
-            }
-            else if (componentType.equals(short.class))
-            {
-               for (short val : (short[]) object) target = apply(target, val);
-            }
-            else if (componentType.equals(int.class))
-            {
-               for (int val : (int[]) object) target = apply(target, val);
-            }
-            else if (componentType.equals(long.class))
-            {
-               for (long val : (long[]) object) target = apply(target, val);
-            }
-            else if (componentType.equals(float.class))
-            {
-               for (float val : (float[]) object) target = apply(target, val);
-            }
-            else if (componentType.equals(double.class))
-            {
-               for (double val : (double[]) object) target = apply(target, val);
-            }
-         }
          else
          {
-            Object[] objs = (Object[]) object;
-            for (Object obj : objs)
-            {
-               target = apply(target, obj);
-
-            }
+            Object[] arr = convertToObjectsArray(object);
+            target = apply(target, arr);
          }
       }
       else
@@ -113,4 +75,18 @@ else if (componentType.equals(double.class))
       }
       return target;
    }
+
+   private static Object[] convertToObjectsArray(Object array) {
+      if(array instanceof Object[])
+         return (Object[]) array;
+
+      int length = Array.getLength(array);
+
+      Object[] objects = new Object[length];
+      for (int i = 0; i < length; i++) {
+          objects[i] = Array.get(array, i);
+      }
+
+      return objects;
+   }
 }",2019-02-12T11:48:15Z,287
"@@ -28,28 +28,30 @@ public FormParamProcessor(final String paramName, final Type type, final Annotat
    }
 
    @Override
-   protected ClientInvocation apply(ClientInvocation invocation, Object object)
+   protected ClientInvocation apply(ClientInvocation invocation, Object... objects)
    {
-      Form form = null;
-      Object entity = invocation.getEntity();
-      if (entity != null)
-      {
-         if (entity instanceof Form)
+      for (Object object : objects) {
+         Form form = null;
+         Object entity = invocation.getEntity();
+         if (entity != null)
          {
-            form = (Form) entity;
+            if (entity instanceof Form)
+            {
+               form = (Form) entity;
+            }
+            else
+            {
+               throw new RuntimeException(Messages.MESSAGES.cannotSetFormParameter());
+            }
          }
          else
          {
-            throw new RuntimeException(Messages.MESSAGES.cannotSetFormParameter());
+            form = new Form();
+            invocation.setEntity(Entity.form(form));
          }
+         String value = invocation.getClientConfiguration().toString(object);
+         form.param(paramName, value);
       }
-      else
-      {
-         form = new Form();
-         invocation.setEntity(Entity.form(form));
-      }
-      String value = invocation.getClientConfiguration().toString(object);
-      form.param(paramName, value);
       return invocation;
    }
 ",2019-02-12T11:48:15Z,288
"@@ -24,9 +24,11 @@ public HeaderParamProcessor(final String paramName, final Type type, final Annot
    }
 
    @Override
-   protected ClientInvocation apply(ClientInvocation invocation, Object object)
+   protected ClientInvocation apply(ClientInvocation invocation, Object... objects)
    {
-      invocation.getHeaders().header(paramName, object);
+      for (Object object : objects) {
+         invocation.getHeaders().header(paramName, object);
+      }
       return invocation;
    }
 ",2019-02-12T11:48:15Z,289
"@@ -25,9 +25,9 @@ public MatrixParamProcessor(final String paramName, final Type type, final Annot
    }
 
    @Override
-   protected WebTarget apply(WebTarget target, Object object)
+   protected WebTarget apply(WebTarget target, Object... objects)
    {
-      return target.matrixParam(paramName, object);
+      return target.matrixParam(paramName, objects);
    }
 
 }",2019-02-12T11:48:15Z,290
"@@ -25,10 +25,10 @@ public QueryParamProcessor(final String paramName, final Type type, final Annota
    }
 
    @Override
-   protected WebTarget apply(WebTarget target, Object object)
+   protected WebTarget apply(WebTarget target, Object... objects)
    {
       ResteasyWebTarget t = (ResteasyWebTarget)target;
-      return t.queryParamNoTemplate(paramName, object);
+      return t.queryParamNoTemplate(paramName, objects);
    }
 
 ",2019-02-12T11:48:15Z,291
"@@ -120,7 +120,7 @@ public static ResteasyUriBuilder fromTemplate(String uriTemplate)
     * @param value the value of the query parameter.
     * @return Returns this instance to allow call chaining.
     */
-   public abstract UriBuilder clientQueryParam(String name, Object value) throws IllegalArgumentException;
+   public abstract UriBuilder clientQueryParam(String name, Object... values) throws IllegalArgumentException;
 
    public abstract String getHost();
 ",2019-02-12T11:48:15Z,292
"@@ -905,28 +905,50 @@ public UriBuilder replaceMatrixParam(String name, Object... values) throws Illeg
     * @return Returns this instance to allow call chaining.
     */
    @Override
-   public UriBuilder clientQueryParam(String name, Object value) throws IllegalArgumentException
+   public UriBuilder clientQueryParam(String name, Object... values) throws IllegalArgumentException
    {
-      if (name == null) throw new IllegalArgumentException(Messages.MESSAGES.nameParameterNull());
-      if (value == null) throw new IllegalArgumentException(Messages.MESSAGES.passedInValueNull());
+      StringBuilder sb = new StringBuilder();
+      String prefix = """";
       if (query == null) query = """";
-      else query += ""&"";
-      query += Encode.encodeQueryParamAsIs(name) + ""="" + Encode.encodeQueryParamAsIs(value.toString());
+      else {
+         sb.append(query).append(""&"");
+      }
+
+      if (name == null) throw new IllegalArgumentException(Messages.MESSAGES.nameParameterNull());
+      if (values == null) throw new IllegalArgumentException(Messages.MESSAGES.valuesParameterNull());
+      for (Object value : values)
+      {
+         if (value == null) throw new IllegalArgumentException(Messages.MESSAGES.passedInValueNull());
+         sb.append(prefix);
+         prefix = ""&"";
+         sb.append(Encode.encodeQueryParamAsIs(name)).append(""="").append(Encode.encodeQueryParamAsIs(value.toString()));
+      }
+
+      query = sb.toString();
       return this;
    }
 
    @Override
    public UriBuilder queryParam(String name, Object... values) throws IllegalArgumentException
    {
+      StringBuilder sb = new StringBuilder();
+      String prefix = """";
+      if (query == null) query = """";
+      else {
+         sb.append(query).append(""&"");
+      }
+
       if (name == null) throw new IllegalArgumentException(Messages.MESSAGES.nameParameterNull());
       if (values == null) throw new IllegalArgumentException(Messages.MESSAGES.valuesParameterNull());
       for (Object value : values)
       {
          if (value == null) throw new IllegalArgumentException(Messages.MESSAGES.passedInValueNull());
-         if (query == null) query = """";
-         else query += ""&"";
-         query += Encode.encodeQueryParam(name) + ""="" + Encode.encodeQueryParam(value.toString());
+         sb.append(prefix);
+         prefix = ""&"";
+         sb.append(Encode.encodeQueryParam(name)).append(""="").append(Encode.encodeQueryParam(value.toString()));
       }
+
+      query = sb.toString();
       return this;
    }
 ",2019-02-12T11:48:15Z,67
"@@ -5,6 +5,8 @@
 import org.jboss.arquillian.junit.Arquillian;
 import org.jboss.resteasy.client.jaxrs.ProxyBuilder;
 import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import javax.ws.rs.BadRequestException;
+import javax.ws.rs.ProcessingException;
 import javax.ws.rs.client.ClientBuilder;
 import org.jboss.resteasy.test.resource.param.resource.QueryParamAsPrimitiveResource;
 import org.jboss.resteasy.test.resource.param.resource.QueryParamAsPrimitiveResourceArray;
@@ -300,6 +302,24 @@ public void testGetByte() {
       resourceQueryPrimitiveArray.doGetByte(array);
    }
 
+   @Test(timeout = 5000)
+   public void testProxyClientGetByte() {
+      final int size = 30000;
+      byte[] array = new byte[size];
+      //Test bigger sizes
+      for (int i = 0; i < size; i++) {
+         array[i] = (byte) 127;
+      }
+
+      for (int i = 0; i < 5; i++) {
+         try {
+            resourceQueryPrimitiveArray.doPostByte(array);
+         } catch (BadRequestException | ProcessingException e) {
+            // expected
+         }
+      }
+   }
+
    /**
     * @tpTestDetails Test byte primitive object
     * @tpSince RESTEasy 3.0.16",2019-02-12T11:48:15Z,293
"@@ -4,6 +4,7 @@
 import org.junit.Assert;
 
 import javax.ws.rs.GET;
+import javax.ws.rs.POST;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.QueryParam;
@@ -28,6 +29,15 @@ public String doGetByte(@QueryParam(""byte"") byte[] v) {
       return ""content"";
    }
 
+   @POST
+   @Produces(""application/byte"")
+   public String doPostByte(@QueryParam(""byte"") byte[] v) {
+      Assert.assertTrue(QueryParamAsPrimitiveTest.ERROR_MESSAGE, (byte) 127 == v[0]);
+      Assert.assertTrue(QueryParamAsPrimitiveTest.ERROR_MESSAGE, (byte) 127 == v[1]);
+      Assert.assertTrue(QueryParamAsPrimitiveTest.ERROR_MESSAGE, (byte) 127 == v[2]);
+      return ""content"";
+   }
+
    @GET
    @Produces(""application/short"")
    public String doGetShort(@QueryParam(""short"") short[] v) {",2019-02-12T11:48:15Z,294
"@@ -1,6 +1,7 @@
 package org.jboss.resteasy.test.resource.param.resource;
 
 import javax.ws.rs.GET;
+import javax.ws.rs.POST;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.QueryParam;
@@ -15,6 +16,11 @@ public interface QueryParamAsPrimitiveResourceResourceArray {
    @Produces(""application/byte"")
    String doGetByte(@QueryParam(""byte"") byte[] v);
 
+   @POST
+   @Path(""/non/existing/end/point"")
+   @Produces(""application/byte"")
+   String doPostByte(@QueryParam(""byte"") byte[] v);
+
    @GET
    @Produces(""application/short"")
    String doGetShort(@QueryParam(""short"") short[] v);",2019-02-12T11:48:15Z,295
"@@ -861,14 +861,18 @@ public UriBuilder clientQueryParam(String name, Object... values) throws Illegal
         String prefix = """";
         if (query == null)
             query = """";
-        else {
-            sb.append(query).append(""&"");
+        else if (!query.equals("""")) {
+            if (values == null)
+                throw new IllegalArgumentException(Messages.MESSAGES.valuesParameterNull());
+            else if (values.length > 0)
+                sb.append(query).append(""&"");
+            else
+                sb.append(query);
         }
 
         if (name == null)
             throw new IllegalArgumentException(Messages.MESSAGES.nameParameterNull());
-        if (values == null)
-            throw new IllegalArgumentException(Messages.MESSAGES.valuesParameterNull());
+
         for (Object value : values) {
             if (value == null)
                 throw new IllegalArgumentException(Messages.MESSAGES.passedInValueNull());",2023-05-03T18:43:34Z,67
"@@ -0,0 +1,170 @@
+/*
+ * JBoss, Home of Professional Open Source.
+ *
+ * Copyright 2023 Red Hat, Inc., and individual contributors
+ * as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.resteasy.test.client;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.resteasy.annotations.jaxrs.QueryParam;
+import org.jboss.resteasy.client.jaxrs.ResteasyClient;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.utils.TestUtil;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * @author <a href=""mailto:dkafetzi@redhat.com"">Dimitris Kafetzis</a>
+ * @tpSubChapter Resteasy-client
+ * @tpChapter Integration tests
+ * @tpSince RESTEasy 6.3.0
+ */
+@RunWith(Arquillian.class)
+@RunAsClient
+public class RequestNamedQueryParameterTest extends ClientTestBase {
+
+    @Path(""someResource"")
+    @Produces(MediaType.APPLICATION_JSON)
+    @Consumes(MediaType.APPLICATION_JSON)
+    public interface SomeResource {
+
+        @GET
+        void methodWithLists(@QueryParam(""listA"") List<String> listA, @QueryParam(""listB"") List<String> listB,
+                @QueryParam(""listC"") List<String> listC);
+    }
+
+    @Deployment
+    public static Archive<?> deploy() {
+        WebArchive war = TestUtil.prepareArchive(ClientInvocationBuilderTest.class.getSimpleName());
+        war.addClass(SomeResource.class);
+        war.addClass(ClientTestBase.class);
+        return war;
+    }
+
+    enum testType {
+        NOPARAMETERS,
+        MIXEDPARAMETERS,
+        FULLPARAMETERS
+    }
+
+    public class AssertFilter implements ClientRequestFilter {
+        final testType setting;
+
+        @Override
+        public void filter(ClientRequestContext requestContext) throws IOException {
+            if (setting == testType.NOPARAMETERS) {
+                Assert.assertEquals("""", requestContext.getUri().getQuery());
+            } else if (setting == testType.MIXEDPARAMETERS) {
+                Assert.assertEquals(""listA=stuff1&listA=stuff2&listC=stuff1&listC=stuff2"", requestContext.getUri().getQuery());
+            } else {
+                Assert.assertEquals(""listA=stuff1&listA=stuff2&listB=stuff1&listB=stuff2&listC=stuff1&listC=stuff2"",
+                        requestContext.getUri().getQuery());
+            }
+            requestContext.abortWith(Response.accepted().build());
+        }
+
+        AssertFilter(final testType setting) {
+            this.setting = setting;
+        }
+    }
+
+    /**
+     * @tpTestDetails Check if empty named query parameters of a request are properly handled.
+     * @tpPassCrit The query for this request invocation should be empty.
+     *             The empty Named Query Parameters should be Ignored
+     *             (no stray or duplicate '&'s should be present)
+     * @tpSince RESTEasy 6.3.0
+     */
+    @Test
+    public void testWithEmptyNamedQueryParameters() {
+        ResteasyClientBuilder builder = (ResteasyClientBuilder) ClientBuilder.newBuilder();
+        ResteasyClient client = builder.build();
+
+        try {
+            client.register(new AssertFilter(testType.NOPARAMETERS));
+            client.target(""http://localhost"").proxy(SomeResource.class).methodWithLists(Collections.emptyList(),
+                    Collections.emptyList(), Collections.emptyList());
+        } finally {
+            client.close();
+        }
+
+    }
+
+    /**
+     * @tpTestDetails Check if empty named query parameters of a request are properly handled, This time the parameters are
+     *                mixed, some are empty some have contents.
+     * @tpPassCrit The query for this request invocation contains only the parameters with content.
+     *             The empty Named Query Parameters should be Ignored
+     *             (no stray or duplicate '&'s should be present)
+     * @tpSince RESTEasy 6.3.0
+     */
+    @Test
+    public void testWithMixedNamedQueryParameters() {
+        ResteasyClientBuilder builder = (ResteasyClientBuilder) ClientBuilder.newBuilder();
+        ResteasyClient client = builder.build();
+        try {
+            client.register(new AssertFilter(testType.MIXEDPARAMETERS));
+            client.target(""http://localhost"").proxy(SomeResource.class).methodWithLists(Arrays.asList(""stuff1"", ""stuff2""),
+                    Collections.emptyList(),
+                    Arrays.asList(""stuff1"", ""stuff2""));
+        } finally {
+            client.close();
+        }
+
+    }
+
+    /**
+     * @tpTestDetails Sanity check to make sure that normal behaviour where all the parameters have content did not break.
+     * @tpPassCrit The query for this request invocation should have the contents from all the parameters.
+     *
+     * @tpSince RESTEasy 6.3.0
+     */
+    @Test
+    public void testWithFullNamedQueryParameters() {
+        ResteasyClientBuilder builder = (ResteasyClientBuilder) ClientBuilder.newBuilder();
+        ResteasyClient client = builder.build();
+
+        try {
+            client.register(new AssertFilter(testType.FULLPARAMETERS));
+            client.target(""http://localhost"").proxy(SomeResource.class).methodWithLists(Arrays.asList(""stuff1"", ""stuff2""),
+                    Arrays.asList(""stuff1"", ""stuff2""), Arrays.asList(""stuff1"", ""stuff2""));
+        } finally {
+            client.close();
+        }
+    }
+
+}",2023-05-03T18:43:34Z,296
"@@ -528,6 +528,11 @@ name: b
            of <emphasis>Eclipse Jetty</emphasis> HTTP engine, which is possibly an interesting
            option for those already running on the Jetty server.
        </para>
+       <para>
+           <code class=""classname"">VertxClientHttpEngine</code> is built on top
+           of <emphasis>Eclipse Vert.x</emphasis>, which provides a non-blocking HTTP client based
+           on Vert.x framework.
+       </para>
        <para>
            <code class=""classname"">ReactorNettyClientHttpEngine</code> is built on top
            of <emphasis>Reactor Netty</emphasis>, which provides a non-blocking HTTP client based
@@ -566,6 +571,10 @@ name: b
                        <entry>ReactorNettyClientHttpEngine</entry>
                        <entry>Uses Reactor Netty</entry>
                    </row>
+                 <row>
+                   <entry>VertxClientHttpEngine</entry>
+                   <entry>Uses Eclipse Vert.x</entry>
+                 </row>
                    <row>
                        <entry>InMemoryClientEngine</entry>
                        <entry>Dispatches requests to a server in the same JVM</entry>
@@ -966,6 +975,59 @@ ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).clie
         </programlisting>
     </section>
 
+     <section id=""vertx_client"">
+         <title>Vertx Client Engine</title>
+         <para>
+           Still as a drop in replacement, RESTEasy allows selecting a Vert.x-based HTTP engine.
+           The Vert.x implementation can perform asynchronous client invocations. It provides the following features:
+         </para>
+         <itemizedlist>
+             <listitem>
+                 <para>HTTP/1.1</para>
+             </listitem>
+             <listitem>
+                 <para>HTTP/2</para>
+             </listitem>
+             <listitem>
+                 <para>SSL/TLS (including native SSL engine)</para>
+             </listitem>
+             <listitem>
+                 <para>Efficient client connection pooling</para>
+             </listitem>
+             <listitem>
+                 <para>Optional native IO on Linux and BSD for greater performance</para>
+             </listitem>
+             <listitem>
+                 <para>Domain sockets</para>
+             </listitem>
+             <listitem>
+                 <para>HTTP Metrics with Dropwizard or Micrometer</para>
+             </listitem>
+         </itemizedlist>
+         <para>
+           The Vert.x engine is enabled by adding a dependency to the <emphasis>org.jboss.resteasy:resteasy-client-vertx</emphasis>
+           artifact to the Maven project; then the client can be built as follows:
+         </para>
+         <programlisting>
+VertxClientHttpEngine engine = new VertxClientHttpEngine();
+ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder())
+  .clientEngine(engine).build();
+         </programlisting>
+         <para>
+           A Vert.x instance can also be provided when creating the client engine, as well as options configuration:
+         </para>
+         <programlisting>
+HttpClientOptions options = new HttpClientOptions()
+ .setSsl(true);
+ .setTrustStoreOptions(new JksOptions()
+   .setPath(""/path/to/your/truststore.jks"")
+   .setPassword(""password-of-your-truststore"")
+);
+VertxClientHttpEngine engine = new VertxClientHttpEngine(vertx, options);
+         </programlisting>
+       <para>You can read more about HttpClient configuration <ulink url=""https://vertx.io/docs/vertx-core/java/#_making_requests"">here</ulink>.</para>
+     </section>
+
     <section id=""reactor_netty_client"">
         <title>Reactor Netty Client Engine</title>
         <para>",2019-07-09T10:36:44Z,297
"@@ -102,6 +102,7 @@
                 <module>resteasy-client</module>
                 <module>resteasy-client-microprofile</module>  
                 <module>resteasy-client-jetty</module>
+                <module>resteasy-client-vertx</module>
                 <module>resteasy-client-reactor-netty</module>
                 <module>providers</module>
                 <module>resteasy-bom</module>",2019-07-09T10:36:44Z,298
"@@ -0,0 +1,121 @@
+<?xml version=""1.0""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>resteasy-jaxrs-all</artifactId>
+        <groupId>org.jboss.resteasy</groupId>
+        <version>4.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <artifactId>resteasy-client-vertx</artifactId>
+    <name>RESTEasy JAX-RS Client - Vert.x Engine</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-client</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging-annotations</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging-processor</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.vertx</groupId>
+            <artifactId>vertx-core</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.spec.javax.ws.rs</groupId>
+            <artifactId>jboss-jaxrs-api_2.1_spec</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-simple</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.vertx</groupId>
+            <artifactId>vertx-core</artifactId>
+            <classifier>tests</classifier>
+            <type>test-jar</type>
+        </dependency>
+    </dependencies>
+    <profiles>
+        <profile>
+            <id>i18n</id>
+            <activation>
+                <property>
+                    <name>i18n</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-resources-plugin</artifactId>
+                        <executions>
+                            <execution>
+                                <id>copy-resources</id>
+                                <phase>initialize</phase>
+                                <goals>
+                                    <goal>copy-resources</goal>
+                                </goals>
+                                <configuration>
+                                    <outputDirectory>
+                                        ${basedir}/src/main/resources/org/jboss/resteasy/client/jaxrs/i18n
+                                    </outputDirectory>
+                                    <resources>
+                                        <resource>
+                                            <directory>${basedir}/src/test/resources/i18n</directory>
+                                            <includes>
+                                                <include>*</include>
+                                            </includes>
+                                        </resource>
+                                    </resources>
+                                    <overwrite>true</overwrite>
+                                </configuration>
+                            </execution>
+                        </executions>
+                    </plugin>
+
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <executions>
+                            <execution>
+                                <id>i18</id>
+                                <phase>test</phase>
+                                <goals>
+                                    <goal>test</goal>
+                                </goals>
+                                <configuration>
+                                    <skip>false</skip>
+                                    <reuseForks>false</reuseForks>
+                                    <includes>
+                                        <include>**/I18nTestMessages_*.java</include>
+                                    </includes>
+                                </configuration>
+                            </execution>
+                        </executions>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>",2019-07-09T10:36:44Z,299
"@@ -0,0 +1,112 @@
+package org.jboss.resteasy.client.jaxrs.engines.vertx;
+
+import io.vertx.core.buffer.Buffer;
+import io.vertx.core.streams.ReadStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+
+public class InputStreamAdapter extends InputStream {
+
+    private final Object lock = new Object();
+    private final ReadStream<Buffer> stream;
+    private Buffer pending = Buffer.buffer();
+    private boolean paused;
+    private boolean ended;
+    private Throwable failure;
+    private final long maxPendingSize;
+
+    public InputStreamAdapter(final ReadStream<Buffer> stream) {
+        this(stream, 256);
+    }
+
+    public InputStreamAdapter(final ReadStream<Buffer> stream, final long maxPendingSize) {
+        this.stream = stream;
+        this.maxPendingSize = maxPendingSize;
+
+        stream.handler(this::onChunk);
+        stream.endHandler(this::onEnd);
+        stream.exceptionHandler(this::onError);
+    }
+
+    private void onChunk(Buffer chunk) {
+        synchronized (lock) {
+            pending.appendBuffer(chunk);
+            if (pending.length() > maxPendingSize) {
+                paused = true;
+                stream.pause();
+            }
+            lock.notifyAll();
+        }
+    }
+
+    private void onEnd(Void v) {
+        synchronized (lock) {
+            ended = true;
+            lock.notifyAll();
+        }
+    }
+
+    private void onError(Throwable cause) {
+        synchronized (lock) {
+            failure = cause;
+            ended = true;
+            lock.notifyAll();
+        }
+    }
+
+    private byte[] buffer = new byte[1];
+
+    @Override
+    public int read() throws IOException {
+        int val = read(buffer, 0, 1);
+        if (val == -1) {
+            return -1;
+        }
+        return buffer[0];
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        synchronized (lock) {
+            if (len == 0) {
+                if (ended) {
+                    if (failure != null) {
+                        throw new IOException(failure);
+                    } else {
+                        return -1;
+                    }
+                } else {
+                    return 0;
+                }
+            }
+            while (true) {
+                if (pending.length() > 0) {
+                    int amount = Math.min(pending.length(), len);
+                    pending.getBytes(0, amount, b);
+                    pending = pending.getBuffer(amount, pending.length());
+                    if (pending.length() == 0L && paused) {
+                        paused = false;
+                        stream.resume();
+                    }
+                    return amount;
+                } else {
+                    if (ended) {
+                        if (failure != null) {
+                            throw new IOException(failure);
+                        } else {
+                            return -1;
+                        }
+                    }
+                    try {
+                        lock.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                        throw new InterruptedIOException();
+                    }
+                }
+            }
+        }
+    }
+}",2019-07-09T10:36:44Z,300
"@@ -0,0 +1,312 @@
+package org.jboss.resteasy.client.jaxrs.engines.vertx;
+
+import io.vertx.core.MultiMap;
+import io.vertx.core.Vertx;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.core.http.HttpClientOptions;
+import io.vertx.core.http.HttpClientRequest;
+import io.vertx.core.http.HttpClientResponse;
+import io.vertx.core.http.HttpMethod;
+import io.vertx.core.http.RequestOptions;
+import org.jboss.resteasy.client.jaxrs.engines.AsyncClientHttpEngine;
+import org.jboss.resteasy.client.jaxrs.internal.ClientConfiguration;
+import org.jboss.resteasy.client.jaxrs.internal.ClientInvocation;
+import org.jboss.resteasy.client.jaxrs.internal.ClientResponse;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.ws.rs.ProcessingException;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.InvocationCallback;
+import javax.ws.rs.client.ResponseProcessingException;
+import javax.ws.rs.core.Response;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+import io.vertx.core.http.HttpClient;
+import io.vertx.core.http.HttpHeaders;
+import org.jboss.resteasy.util.CaseInsensitiveMap;
+
+public class VertxClientHttpEngine implements AsyncClientHttpEngine {
+
+    /**
+     * Client config property to set when a request timeout is needed.
+     */
+    public static final String REQUEST_TIMEOUT_MS = Vertx.class + ""$RequestTimeout"";
+
+    private final Vertx vertx;
+    private final HttpClient httpClient;
+
+    public VertxClientHttpEngine() {
+        this.vertx = Vertx.vertx();
+        this.httpClient = vertx.createHttpClient();
+    }
+
+    public VertxClientHttpEngine(final Vertx vertx, final HttpClientOptions options) {
+        this.vertx = vertx;
+        this.httpClient = vertx.createHttpClient(options);
+    }
+
+    public VertxClientHttpEngine(final Vertx vertx) {
+        this(vertx, new HttpClientOptions());
+    }
+
+    public VertxClientHttpEngine(final HttpClient client) {
+        this.vertx = null;
+        this.httpClient = client;
+    }
+
+    @Override
+    public <T> Future<T> submit(final ClientInvocation request,
+                                final boolean buffered,
+                                final InvocationCallback<T> callback,
+                                final ResultExtractor<T> extractor) {
+        CompletableFuture<T> future = submit(request).thenCompose(response -> {
+            CompletableFuture<T> tmp = new CompletableFuture<>();
+            vertx.executeBlocking(promise -> {
+                try {
+                    T result = extractor.extractResult(response);
+                    tmp.complete(result);
+                } catch (Exception e) {
+                    tmp.completeExceptionally(e);
+                }
+            }, ar -> {
+                //
+            });
+            return tmp;
+        });
+        if (callback != null) {
+            future = future.whenComplete((response, throwable) -> {
+                if (throwable != null) {
+                    callback.failed(throwable);
+                } else {
+                    callback.completed(response);
+                }
+            });
+        }
+        return future;
+    }
+
+    @Override
+    public <T> CompletableFuture<T> submit(final ClientInvocation request,
+                                           final boolean buffered,
+                                           final ResultExtractor<T> extractor,
+                                           final ExecutorService executorService) {
+        return submit(request).thenCompose(response -> {
+            CompletableFuture<T> tmp = new CompletableFuture<>();
+            executorService.execute(() -> {
+                try {
+                    T result = extractor.extractResult(response);
+                    tmp.complete(result);
+                } catch (Exception e) {
+                    tmp.completeExceptionally(e);
+                }
+            });
+            return tmp;
+        });
+    }
+
+    private CompletableFuture<ClientResponse> submit(final ClientInvocation request) {
+
+        HttpMethod method;
+        try {
+            method = HttpMethod.valueOf(request.getMethod());
+        } catch (IllegalArgumentException e) {
+            method = HttpMethod.OTHER;
+        }
+
+        Object entity = request.getEntity();
+        Buffer body;
+        if (entity != null) {
+            body = Buffer.buffer(requestContent(request));
+        } else {
+            body = null;
+        }
+
+        RequestOptions options = new RequestOptions();
+        MultiMap headers = MultiMap.caseInsensitiveMultiMap();
+        request.getHeaders().asMap().forEach(headers::add);
+        options.setHeaders(headers);
+        if (body != null) {
+            headers.set(HttpHeaders.CONTENT_LENGTH, """" + body.length());
+        }
+        options.addHeader(HttpHeaders.USER_AGENT.toString(), ""Vertx"");
+
+        URI uri = request.getUri();
+        options.setHost(uri.getHost());
+        options.setPort(uri.getPort());
+        options.setURI(uri.getRawPath());
+
+        CompletableFuture<ClientResponse> future = new CompletableFuture<>();
+
+        // Using this method is fine
+        // This will go away with Vert.x 4
+        @SuppressWarnings(""deprecation"")
+        HttpClientRequest clientRequest = httpClient.request(method, options, response -> {
+            future.complete(toRestEasyResponse(request.getClientConfiguration(), response));
+        });
+        if (method == HttpMethod.OTHER) {
+            clientRequest.setRawMethod(request.getMethod());
+        }
+
+        Object timeout = request.getConfiguration().getProperty(REQUEST_TIMEOUT_MS);
+        if (timeout != null) {
+            long timeoutMs = unwrapTimeout(timeout);
+            if (timeoutMs > 0) {
+                clientRequest.setTimeout(timeoutMs);
+            }
+        }
+
+        clientRequest.exceptionHandler(future::completeExceptionally);
+        if (body != null) {
+            clientRequest.end(body);
+        } else {
+            clientRequest.end();
+        }
+
+        return future;
+    }
+
+    private long unwrapTimeout(final Object timeout) {
+        if (timeout instanceof Duration) {
+            return ((Duration) timeout).toMillis();
+        } else if (timeout instanceof Number) {
+            return ((Number) timeout).longValue();
+        } else if (timeout != null) {
+            return Long.parseLong(timeout.toString());
+        } else {
+            return -1L;
+        }
+    }
+
+    @Override
+    public SSLContext getSslContext() {
+        // Vertx does not allow to access the ssl-context from HttpClient API.
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public HostnameVerifier getHostnameVerifier() {
+        // Vertx does not support HostnameVerifier API.
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Response invoke(Invocation request) {
+        final Future<ClientResponse> future = submit((ClientInvocation) request);
+
+        try {
+            return future.get();
+        } catch (InterruptedException e) {
+            future.cancel(true);
+            throw clientException(e, null);
+        } catch (ExecutionException e) {
+            throw clientException(e.getCause(), null);
+        }
+    }
+
+    @Override
+    public void close() {
+        if (vertx != null) {
+            vertx.close();
+        } else {
+            httpClient.close();
+        }
+    }
+
+    static RuntimeException clientException(Throwable ex, Response clientResponse) {
+        RuntimeException ret;
+        if (ex == null) {
+            ret = new ProcessingException(new NullPointerException());
+        } else if (ex instanceof WebApplicationException) {
+            ret = (WebApplicationException) ex;
+        } else if (ex instanceof ProcessingException) {
+            ret = (ProcessingException) ex;
+        } else if (clientResponse != null) {
+            ret = new ResponseProcessingException(clientResponse, ex);
+        } else {
+            ret = new ProcessingException(ex);
+        }
+        return ret;
+    }
+
+    private static byte[] requestContent(ClientInvocation request)
+    {
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        request.getDelegatingOutputStream().setDelegate(baos);
+        try {
+            request.writeRequestBody(request.getEntityStream());
+            baos.close();
+            return baos.toByteArray();
+        } catch (IOException e) {
+            throw new RuntimeException(""Failed to write the request body!"", e);
+        }
+    }
+
+
+    private ClientResponse toRestEasyResponse(ClientConfiguration clientConfiguration,
+                                               HttpClientResponse clientResponse) {
+
+
+        InputStreamAdapter adapter = new InputStreamAdapter(clientResponse, 4 * 1024);
+
+        class RestEasyClientResponse extends ClientResponse {
+
+            private InputStream is;
+
+            private RestEasyClientResponse(final ClientConfiguration configuration) {
+                super(configuration);
+                this.is = adapter;
+            }
+
+            @Override
+            protected InputStream getInputStream() {
+                return this.is;
+            }
+
+            @Override
+            protected void setInputStream(InputStream inputStream) {
+                this.is = inputStream;
+            }
+
+            @Override
+            public void releaseConnection() throws IOException {
+                this.releaseConnection(false);
+            }
+
+            @Override
+            public void releaseConnection(boolean consumeInputStream) throws IOException {
+                try {
+                    if (is != null) {
+                        if (consumeInputStream) {
+                            while (is.available() > 0) {
+                                is.read();
+                            }
+                        }
+                        is.close();
+                    }
+                }
+                catch (IOException e) {
+                    // Swallowing because other ClientHttpEngine implementations are swallowing as well.
+                    // What is better?  causing a potential leak with inputstream slowly or cause an unexpected
+                    // and unhandled io error and potentially cause the service go down?
+                    // log.warn(""Exception while releasing the connection!"", e);
+                }
+            }
+        }
+        ClientResponse restEasyClientResponse = new RestEasyClientResponse(clientConfiguration);
+        restEasyClientResponse.setStatus(clientResponse.statusCode());
+        CaseInsensitiveMap<String> restEasyHeaders = new CaseInsensitiveMap<>();
+        clientResponse.headers().forEach(header -> restEasyHeaders.add(header.getKey(), header.getValue()));
+        restEasyClientResponse.setHeaders(restEasyHeaders);
+        return restEasyClientResponse;
+    }
+}
\ No newline at end of file",2019-07-09T10:36:44Z,253
"@@ -0,0 +1,124 @@
+package org.jboss.resteasy.test.client.vertx;
+
+import io.vertx.core.Vertx;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.test.core.TestUtils;
+import io.vertx.test.fakestream.FakeStream;
+import org.jboss.resteasy.client.jaxrs.engines.vertx.InputStreamAdapter;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static junit.framework.TestCase.assertEquals;
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public class InputStreamAdapterTest {
+
+    private Vertx vertx;
+
+    @Before
+    public void setup() {
+        vertx = Vertx.vertx();
+    }
+
+    @After
+    public void after() {
+        vertx.close();
+    }
+
+    @Test
+    public void testConsumeSingleByteWaitsUntilDataBecomesAvailable() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        Thread th = Thread.currentThread();
+        vertx.setTimer(10, id -> {
+           while (th.getState() != Thread.State.WAITING) {
+               try {
+                   Thread.sleep(1);
+               } catch (InterruptedException ignore) {
+               }
+           }
+           stream.emit(Buffer.buffer().appendByte((byte)5));
+        });
+        int val = adapter.read();
+        assertEquals(5, val);
+    }
+
+    @Test
+    public void testPauseStreamStream() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        Buffer expected = TestUtils.randomBuffer(256 + 1);
+        stream.emit(expected.slice(0, 256));
+        assertFalse(stream.isPaused());
+        stream.emit(expected.slice(256, 257));
+        assertTrue(stream.isPaused());
+        byte[] data = new byte[257];
+        assertEquals(257, adapter.read(data));
+        assertFalse(stream.isPaused());
+    }
+
+    @Test
+    public void testEndStream1() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        stream.end();
+        assertEquals(-1, adapter.read());
+    }
+
+    @Test
+    public void testEndStream2() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        Thread th = Thread.currentThread();
+        vertx.setTimer(10, id -> {
+            while (th.getState() != Thread.State.WAITING) {
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException ignore) {
+                }
+            }
+            stream.end();
+        });
+        assertEquals(-1, adapter.read());
+    }
+
+    @Test
+    public void testFailure1() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        Throwable cause = new Throwable();
+        stream.fail(cause);
+        try {
+            adapter.read();
+        } catch (IOException e) {
+            assertSame(cause, e.getCause());
+        }
+    }
+
+    @Test
+    public void testFailure2() throws Exception {
+        FakeStream<Buffer> stream = new FakeStream<>();
+        InputStreamAdapter adapter = new InputStreamAdapter(stream);
+        Throwable cause = new Throwable();
+        Thread th = Thread.currentThread();
+        vertx.setTimer(10, id -> {
+            while (th.getState() != Thread.State.WAITING) {
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException ignore) {
+                }
+            }
+            stream.fail(cause);
+        });
+        try {
+            adapter.read();
+        } catch (IOException e) {
+            assertSame(cause, e.getCause());
+        }
+    }
+}",2019-07-09T10:36:44Z,301
"@@ -0,0 +1,346 @@
+package org.jboss.resteasy.test.client.vertx;
+
+import static junit.framework.TestCase.assertTrue;
+import static junit.framework.TestCase.fail;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.time.Duration;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import javax.ws.rs.ProcessingException;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientResponseContext;
+import javax.ws.rs.client.ClientResponseFilter;
+import javax.ws.rs.client.CompletionStageRxInvoker;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.InvocationCallback;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.StreamingOutput;
+
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.http.HttpHeaders;
+import io.vertx.core.http.HttpServer;
+import io.vertx.core.http.HttpServerRequest;
+import io.vertx.core.http.HttpServerResponse;
+import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
+import org.jboss.resteasy.client.jaxrs.engines.vertx.VertxClientHttpEngine;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class VertxClientEngineTest {
+   Vertx vertx;
+   HttpServer server;
+   Client client;
+   ScheduledExecutorService executorService;
+
+   @Before
+   public void before() {
+      vertx = Vertx.vertx();
+      server = vertx.createHttpServer();
+      executorService = Executors.newSingleThreadScheduledExecutor();
+   }
+
+   @After
+   public void stop() throws Exception {
+      if (client != null) {
+         client.close();
+      }
+      CountDownLatch latch = new CountDownLatch(1);
+      vertx.close(ar -> latch.countDown());
+      latch.await(2, TimeUnit.MINUTES);
+      executorService.shutdownNow();
+   }
+
+   private Client client() throws Exception {
+      if (server.actualPort() == 0) {
+         CompletableFuture<Void> fut = new CompletableFuture<>();
+         server.listen(0, ar -> {
+            if (ar.succeeded()) {
+               fut.complete(null);
+            } else {
+               fut.completeExceptionally(ar.cause());
+            }
+         });
+         fut.get(2, TimeUnit.MINUTES);
+      }
+      if (client == null) {
+         client = ((ResteasyClientBuilder)ClientBuilder
+             .newBuilder()
+             .scheduledExecutorService(executorService))
+             .httpEngine(new VertxClientHttpEngine(vertx)).build();
+      }
+      return client;
+   }
+
+   @Test
+   public void testSimple() throws Exception {
+      server.requestHandler(req -> {
+         HttpServerResponse response = req.response();
+         if (req.getHeader(""User-Agent"").contains(""Apache"")) {
+            response.setStatusCode(503).end();
+         } else if (!""abracadabra"".equals(req.getHeader(""Password""))) {
+            response.setStatusCode(403).end();
+         } else {
+            req.response().end(""Success"");
+         }
+      });
+
+      final Response response = client().target(baseUri()).request()
+         .header(""Password"", ""abracadabra"")
+         .get();
+
+      assertEquals(200, response.getStatus());
+      assertEquals(""Success"", response.readEntity(String.class));
+   }
+
+   @Test
+   public void testSimpleResponseRx() throws Exception {
+      server.requestHandler(req -> {
+         HttpServerResponse response = req.response();
+         if (req.getHeader(""User-Agent"").contains(""Apache"")) {
+            response.setStatusCode(503).end();
+         } else if (!""abracadabra"".equals(req.getHeader(""Password""))) {
+            response.setStatusCode(403).end();
+         } else {
+            req.response().putHeader(""Content-Type"", ""text/plain"").end(""Success"");
+         }
+      });
+
+      final CompletionStage<Response> cs = client().target(baseUri()).request()
+         .header(""Password"", ""abracadabra"").rx(CompletionStageRxInvoker.class)
+         .get();
+
+      Response response = cs.toCompletableFuture().get();
+      assertEquals(200, response.getStatus());
+      assertEquals(""Success"", response.readEntity(String.class));
+   }
+
+   @Test
+   public void testSimpleStringRx() throws Exception {
+      server.requestHandler(req -> {
+         HttpServerResponse response = req.response();
+         if (req.getHeader(""User-Agent"").contains(""Apache"")) {
+            response.setStatusCode(503).end();
+         } else if (!""abracadabra"".equals(req.getHeader(""Password""))) {
+            response.setStatusCode(403).end();
+         } else {
+            req.response().putHeader(""Content-Type"", ""text/plain"").end(""Success"");
+         }
+      });
+
+      final CompletionStage<String> cs = client().target(baseUri()).request()
+         .header(""Password"", ""abracadabra"").rx(CompletionStageRxInvoker.class)
+         .get(String.class);
+
+      String response = cs.toCompletableFuture().get();
+      assertEquals(""Success"", response);
+   }
+
+   @Test
+   public void testBigly() throws Exception {
+      server.requestHandler(new EchoHandler());
+      final byte[] valuableData = randomAlpha().getBytes(StandardCharsets.UTF_8);
+      final Response response = client().target(baseUri()).request()
+            .post(Entity.entity(valuableData, MediaType.APPLICATION_OCTET_STREAM_TYPE));
+
+      assertEquals(200, response.getStatus());
+      assertArrayEquals(valuableData, response.readEntity(byte[].class));
+   }
+
+   @Test
+   public void testFutureResponse() throws Exception {
+      server.requestHandler(new EchoHandler());
+      final String valuableData = randomAlpha();
+      final Future<Response> response = client().target(baseUri()).request()
+            .buildPost(Entity.entity(valuableData, MediaType.APPLICATION_OCTET_STREAM_TYPE))
+            .submit();
+
+      final Response resp = response.get(10, TimeUnit.SECONDS);
+      assertEquals(200, resp.getStatus());
+      assertEquals(valuableData, resp.readEntity(String.class));
+   }
+
+   @Test
+   public void testFutureString() throws Exception {
+      server.requestHandler(new EchoHandler());
+      final String valuableData = randomAlpha();
+      final Future<String> response = client().target(baseUri()).request()
+            .buildPost(Entity.entity(valuableData, MediaType.APPLICATION_OCTET_STREAM_TYPE))
+            .submit(String.class);
+
+      final String result = response.get(10, TimeUnit.SECONDS);
+      assertEquals(valuableData, result);
+   }
+
+   private String randomAlpha() {
+      final StringBuilder builder = new StringBuilder();
+      final Random r = new Random();
+      for (int i = 0; i < 20 * 1024 * 1024; i++) {
+         builder.append((char) ('a' + (char) r.nextInt('z' - 'a')));
+         if (i % 100 == 0) builder.append('\n');
+      }
+      return builder.toString();
+   }
+
+   @Test
+   public void testCallbackString() throws Exception {
+      server.requestHandler(new EchoHandler());
+      final String valuableData = randomAlpha();
+      CompletableFuture<String> cf = new CompletableFuture<>();
+      client().target(baseUri()).request()
+          .buildPost(Entity.entity(valuableData, MediaType.APPLICATION_OCTET_STREAM_TYPE))
+          .submit(new InvocationCallback<String>() {
+             @Override
+             public void completed(String s) {
+                cf.complete(s);
+             }
+             @Override
+             public void failed(Throwable throwable) {
+                cf.completeExceptionally(throwable);
+             }
+          });
+
+      final String result = cf.get(10, TimeUnit.SECONDS);
+      assertEquals(valuableData, result);
+   }
+
+   @Test
+   public void testTimeout() throws Exception {
+      server.requestHandler(req -> {
+         vertx.setTimer(1000, id -> {
+            req.response().end();
+         });
+      });
+      try {
+         Invocation.Builder property = client()
+             .target(baseUri())
+             .request()
+             .property(VertxClientHttpEngine.REQUEST_TIMEOUT_MS, Duration.ofMillis(500));
+         property
+            .get();
+         fail();
+      } catch (ProcessingException e) {
+         assertTrue(e.getCause() instanceof TimeoutException);
+      }
+   }
+
+   @Test
+   public void testDeferContent() throws Exception {
+      server.requestHandler(new EchoHandler());
+      final byte[] valuableData = randomAlpha().getBytes(StandardCharsets.UTF_8);
+      final Response response = client().target(baseUri()).request()
+            .post(Entity.entity(new StreamingOutput() {
+               @Override
+               public void write(OutputStream output) throws IOException, WebApplicationException {
+                  try {
+                     Thread.sleep(100);
+                  } catch (InterruptedException e) {
+                     Thread.currentThread().interrupt();
+                     throw new AssertionError(e);
+                  }
+                  output.write(valuableData);
+               }
+            }, MediaType.APPLICATION_OCTET_STREAM_TYPE));
+
+      assertEquals(200, response.getStatus());
+      assertArrayEquals(valuableData, response.readEntity(byte[].class));
+   }
+
+   @Test
+   public void testFilterBufferReplay() throws Exception {
+      final String greeting = ""Success"";
+      final byte[] expected = greeting.getBytes(StandardCharsets.UTF_8);
+      server.requestHandler(req -> {
+        req.response().putHeader(HttpHeaders.CONTENT_TYPE, ""text/plain"").end(greeting);
+      });
+
+      final byte[] content = new byte[expected.length];
+      final ClientResponseFilter capturer = new ClientResponseFilter() {
+         @Override
+         public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) throws IOException {
+            responseContext.getEntityStream().read(content);
+         }
+      };
+
+      try (InputStream response = client().register(capturer).target(baseUri()).request()
+         .get(InputStream.class)) {
+         // ignored, we are checking filter
+      }
+
+      assertArrayEquals(expected, content);
+   }
+
+   @Test
+   public void testServerFailure1() throws Exception {
+      server.requestHandler(req -> {
+         req.response().close();
+      });
+
+      try {
+         client().target(baseUri()).request().get();
+         fail();
+      } catch (ProcessingException ignore) {
+         // Expected
+      }
+   }
+
+   @Test
+   public void testServerFailure2() throws Exception {
+      server.requestHandler(req -> {
+         HttpServerResponse resp = req.response();
+         resp.setChunked(true).write(""something"");
+         vertx.setTimer(1000, id -> {
+            // Leave it some time to receive the response headers and start processing the response
+            resp.close();
+         });
+      });
+
+      try {
+         Response response = client().target(baseUri()).request().get();
+         response.readEntity(String.class);
+         fail();
+      } catch (ProcessingException ignore) {
+         // Expected
+      }
+   }
+
+   public URI baseUri() {
+      return URI.create(""http://localhost:"" + server.actualPort());
+   }
+
+   static class EchoHandler implements Handler<HttpServerRequest> {
+      @Override
+      public void handle(HttpServerRequest req) {
+         req.bodyHandler(body -> {
+            String type = req.getHeader(HttpHeaders.CONTENT_TYPE);
+            if (type == null) {
+               type = ""text/plain"";
+            }
+            req.response()
+                .putHeader(HttpHeaders.CONTENT_TYPE, type)
+                .end(body);
+         });
+      }
+   }
+}",2019-07-09T10:36:44Z,302
"@@ -29,7 +29,7 @@
         <version.hamcrest>1.3</version.hamcrest>
         <version.io.netty.netty>3.10.6.Final</version.io.netty.netty>
         <version.io.netty.netty4>4.1.32.Final</version.io.netty.netty4>
-        <version.io.vertx>3.6.2</version.io.vertx>
+        <version.io.vertx>3.7.1</version.io.vertx>
         <version.io.undertow>2.0.21.Final</version.io.undertow>
         <version.javax.activation>1.1.1</version.javax.activation>
         <version.javax.enterprise.cdi-api>2.0.SP1</version.javax.enterprise.cdi-api>
@@ -348,6 +348,14 @@
                 <artifactId>vertx-core</artifactId>
                 <version>${version.io.vertx}</version>
             </dependency>
+            <dependency>
+                <groupId>io.vertx</groupId>
+                <artifactId>vertx-core</artifactId>
+                <version>${version.io.vertx}</version>
+                <classifier>tests</classifier>
+                <scope>test</scope>
+                <type>test-jar</type>
+            </dependency>
             <dependency>
                 <groupId>io.undertow</groupId>
                 <artifactId>undertow-servlet</artifactId>",2019-07-09T10:36:44Z,247
