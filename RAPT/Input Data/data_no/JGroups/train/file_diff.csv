file_diff,commit_time,file_diff_id
"@@ -66,6 +66,7 @@
     <class id=""69"" name=""org.jgroups.protocols.GOOGLE_PING""/>
     <class id=""70"" name=""org.jgroups.protocols.SEQUENCER2""/>
     <class id=""71"" name=""org.jgroups.protocols.MERGE2""/>
+    <class id=""72"" name=""org.jgroups.protocols.FD_PING2""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2014-06-23T09:14:41Z,104
"@@ -0,0 +1,477 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.PhysicalAddress;
+import org.jgroups.View;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.IpAddress;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.InetAddress;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Failure detection protocol which detects the crash or hanging of entire hosts and suspects all cluster members
+ * on those hosts. This protocol would typically be used when multiple cluster members are running on the same box.
+ * <p/>
+ * JIRA:  https://issues.jboss.org/browse/JGRP-1855
+ * @author  Bela Ban
+ * @version 3.5
+ */
+@MBean(description=""Failure detection protocol which detects crashes or hangs of entire hosts and suspects "" +
+  ""all cluster members on those hosts"")
+public class FD_PING2 extends Protocol {
+
+    @Property(description=""The command used to check a given host for liveness. Example: \""ping\"". "" +
+      ""If null, InetAddress.isReachable() will be used by default"")
+    protected String                                     cmd=null;
+
+    @Property(description=""Max time (in ms) after which a host is suspected if it failed all liveness checks"")
+    protected long                                       timeout=60000;
+
+    @Property(description=""The interval (in ms) at which the hosts are checked for liveness"")
+    protected long                                       interval=20000;
+
+    @Property(description=""Max time (in ms) that a liveness check for a single host can take"")
+    protected long                                       check_timeout=3000;
+
+    @Property(description=""Uses TimeService to get the current time rather than System.currentTimeMillis. Might get "" +
+      ""removed soon, don't use !"")
+    protected boolean                                    use_time_service=true;
+
+    @ManagedAttribute(description=""Number of liveness checks"")
+    protected int                                        num_liveness_checks;
+
+    @ManagedAttribute(description=""Number of suspected events received"")
+    protected int                                        num_suspect_events;
+
+    protected final Set<Address>                         suspected_mbrs=new HashSet<Address>();
+
+    @ManagedAttribute(description=""Shows whether there are currently any suspected members"")
+    protected volatile boolean                           has_suspected_mbrs;
+
+    protected final BoundedList<Tuple<InetAddress,Long>> suspect_history=new BoundedList<Tuple<InetAddress,Long>>(20);
+
+    protected Address                                    local_addr;
+    protected InetAddress                                local_host;
+    protected final List<Address>                        members=new ArrayList<Address>();
+
+    /** The command to detect whether a target is alive */
+    protected PingCommand                                ping_command=new IsReachablePingCommand();
+
+    /** Map of hosts and their cluster members, updated on view changes. Used to suspect all members
+     of a suspected host */
+    protected final Map<InetAddress,List<Address>>       hosts=new HashMap<InetAddress,List<Address>>();
+
+    // Map of hosts and timestamps of last updates
+    protected final Map<InetAddress, Long>               timestamps=new ConcurrentHashMap<InetAddress,Long>();
+
+    /** Timer used to run the ping task on */
+    protected TimeScheduler                              timer;
+
+    protected TimeService                                time_service;
+
+    protected Future<?>                                  ping_task_future;
+
+
+
+    public FD_PING2 pingCommand(PingCommand cmd) {this.ping_command=cmd; return this;}
+
+    public void resetStats() {
+        num_suspect_events=num_liveness_checks=0;
+        suspect_history.clear();
+    }
+
+    public void setCommand(String command) {
+        this.cmd=command;
+        ping_command=this.cmd != null? new ExternalPingCommand(cmd) : new IsReachablePingCommand();
+    }
+
+    @ManagedOperation(description=""Prints history of suspected hosts"")
+    public String printSuspectHistory() {
+        StringBuilder sb=new StringBuilder();
+        for(Tuple<InetAddress,Long> tmp: suspect_history) {
+            sb.append(new Date(tmp.getVal2())).append("": "").append(tmp.getVal1()).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+    @ManagedOperation(description=""Prints timestamps"")
+    public String printTimestamps() {
+        return _printTimestamps();
+    }
+
+    @ManagedAttribute(description=""Whether the ping task is running"")
+    public boolean isPingerRunning() {
+        Future<?> future=ping_task_future;
+        return future != null && !future.isDone();
+    }
+
+    @ManagedOperation(description=""Prints the hosts and their associated cluster members"")
+    public String printHosts() {
+        StringBuilder sb=new StringBuilder();
+        synchronized(hosts) {
+            for(Map.Entry<InetAddress,List<Address>> entry: hosts.entrySet()) {
+                sb.append(entry.getKey()).append("": "").append(entry.getValue()).append(""\n"");
+            }
+        }
+        return sb.toString();
+    }
+
+    @ManagedOperation(description=""Checks whether the given host is alive"")
+    public boolean isAlive(String host) throws Exception {
+        return ping_command != null && ping_command.isAlive(InetAddress.getByName(host), check_timeout);
+    }
+
+    @ManagedAttribute(description=""Currently suspected members"")
+    public String getSuspectedMembers() {return suspected_mbrs.toString();}
+
+    public void init() throws Exception {
+        if(interval >= timeout)
+            throw new IllegalArgumentException(""interval ("" + interval + "") has to be less than timeout ("" + timeout + "")"");
+        super.init();
+        if(cmd != null)
+            ping_command=new ExternalPingCommand(cmd);
+        timer=getTransport().getTimer();
+        if(timer == null)
+            throw new Exception(""timer not set"");
+        time_service=getTransport().getTimeService();
+        if(time_service == null)
+            log.warn(""%s: time service is not available, using System.currentTimeMillis() instead"", local_addr);
+        else {
+            if(time_service.interval() > timeout) {
+                log.warn(""%s: interval of time service (%d) is greater than timeout (%d), disabling time service"",
+                         local_addr, time_service.interval(), timeout);
+                use_time_service=false;
+            }
+        }
+        suspected_mbrs.clear();
+        has_suspected_mbrs=false;
+    }
+
+    public void stop() {
+        super.stop();
+        stopPingerTask();
+        suspected_mbrs.clear();
+        has_suspected_mbrs=false;
+    }
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                View view=(View)evt.getArg();
+                handleView(view);
+                break;
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=(Address)evt.getArg();
+                break;
+            case Event.CONNECT:
+            case Event.CONNECT_USE_FLUSH:
+            case Event.CONNECT_WITH_STATE_TRANSFER:
+            case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:
+                local_host=getHostFor(local_addr);
+                break;
+            case Event.DISCONNECT:
+                Object retval=down_prot.down(evt);
+                local_host=null;
+                return retval;
+
+            case Event.UNSUSPECT:
+                Address mbr=(Address)evt.getArg();
+                unsuspect(mbr);
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    protected void handleView(View view) {
+        List<Address> view_mbrs=view.getMembers();
+        boolean is_pinger=false;
+        members.clear();
+        members.addAll(view_mbrs);
+        synchronized(hosts) {
+            hosts.clear();
+            for(Address mbr: view) {
+                InetAddress key=getHostFor(mbr);
+                if(key == null)
+                    continue;
+                List<Address> mbrs=hosts.get(key);
+                if(mbrs == null)
+                    hosts.put(key, mbrs=new ArrayList<Address>());
+                mbrs.add(mbr);
+            }
+            is_pinger=isPinger(local_addr);
+        }
+
+        if(suspected_mbrs.retainAll(view.getMembers()))
+            has_suspected_mbrs=!suspected_mbrs.isEmpty();
+
+        timestamps.keySet().removeAll(hosts.keySet());
+
+        if(is_pinger)
+            startPingerTask();
+        else
+            stopPingerTask();
+    }
+
+
+    protected PhysicalAddress getPhysicalAddress(Address logical_addr) {
+        return (PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, logical_addr));
+    }
+
+    protected InetAddress getHostFor(Address mbr) {
+        PhysicalAddress phys_addr=getPhysicalAddress(mbr);
+        return phys_addr instanceof IpAddress? ((IpAddress)phys_addr).getIpAddress() : null;
+    }
+
+    protected boolean isPinger(Address mbr) {
+        InetAddress host=getHostFor(mbr);
+        if(host == null) return false; // should not happen
+        List<Address> mbrs=hosts.get(host);
+        return mbrs != null && !mbrs.isEmpty() && mbrs.get(0).equals(mbr);
+    }
+
+    protected void startPingerTask() {
+        if(ping_task_future == null || ping_task_future.isDone())
+            ping_task_future=timer.scheduleAtFixedRate(new PingTask(), interval, interval, TimeUnit.MILLISECONDS);
+    }
+
+    protected void stopPingerTask() {
+        if(ping_task_future != null) {
+            ping_task_future.cancel(false);
+            ping_task_future=null;
+        }
+    }
+
+    /** Called by ping task; will result in all members of host getting suspected */
+    protected void suspect(InetAddress host) {
+        List<Address> suspects;
+        suspect_history.add(new Tuple<InetAddress,Long>(host, getTimestamp()));
+        synchronized(hosts) {
+            List<Address> tmp=hosts.get(host);
+            suspects=tmp != null? new ArrayList<Address>(tmp) : null;
+        }
+        if(suspects != null) {
+            log.debug(""%s: suspecting host %s; suspected members: %s"", local_addr, host, Util.printListWithDelimiter(suspects, "",""));
+            suspect(suspects);
+        }
+    }
+
+
+    protected void suspect(List<Address> suspects) {
+        if(suspects == null || suspects.isEmpty())
+            return;
+
+        num_suspect_events+=suspects.size();
+
+        final List<Address> eligible_mbrs=new ArrayList<Address>();
+        synchronized(this) {
+            suspected_mbrs.addAll(suspects);
+            eligible_mbrs.addAll(members);
+            eligible_mbrs.removeAll(suspected_mbrs);
+            has_suspected_mbrs=!suspected_mbrs.isEmpty();
+        }
+
+        // Check if we're coord, then send up the stack
+        if(local_addr != null && !eligible_mbrs.isEmpty()) {
+            Address first=eligible_mbrs.get(0);
+            if(local_addr.equals(first)) {
+                log.debug(""%s: suspecting %s"", local_addr, suspected_mbrs);
+                for(Address suspect: suspects) {
+                    up_prot.up(new Event(Event.SUSPECT, suspect));
+                    down_prot.down(new Event(Event.SUSPECT, suspect));
+                }
+            }
+        }
+    }
+
+   /* protected void unsuspect(InetAddress host) {
+        List<Address> suspects;
+        synchronized(hosts) {
+            List<Address> tmp=hosts.get(host);
+            suspects=tmp != null? new ArrayList<Address>(tmp) : null;
+        }
+        if(suspects != null) {
+            log.debug(""%s: unsuspecting host %s; unsuspected members: %s"", local_addr, host, Util.printListWithDelimiter(suspects, "",""));
+            for(Address unsuspect: suspects)
+                unsuspect(unsuspect);
+        }
+    }*/
+
+    protected boolean unsuspect(Address mbr) {
+        if(mbr == null) return false;
+        boolean do_unsuspect;
+        synchronized(this) {
+            do_unsuspect=!suspected_mbrs.isEmpty() && suspected_mbrs.remove(mbr);
+            if(do_unsuspect)
+                has_suspected_mbrs=!suspected_mbrs.isEmpty();
+        }
+        if(do_unsuspect) {
+            up_prot.up(new Event(Event.UNSUSPECT, mbr));
+            down_prot.down(new Event(Event.UNSUSPECT, mbr));
+        }
+        return do_unsuspect;
+    }
+
+
+    protected String _printTimestamps() {
+        StringBuilder sb=new StringBuilder();
+        long current_time=getTimestamp();
+        for(Map.Entry<InetAddress,Long> entry: timestamps.entrySet()) {
+            sb.append(entry.getKey()).append("": "");
+            sb.append((current_time - entry.getValue())/1000).append("" secs old\n"");
+        }
+        return sb.toString();
+    }
+
+    protected void updateTimestampFor(InetAddress host) {
+        timestamps.put(host, getTimestamp());
+    }
+
+    protected long getAgeOf(InetAddress host) {
+        Long ts=timestamps.get(host);
+        return ts != null? getTimestamp() - ts : -1;
+    }
+
+    protected long getTimestamp() {
+        return use_time_service && time_service != null? time_service.timestamp() : System.currentTimeMillis();
+    }
+
+
+
+
+
+
+    /** Selected members run this task periodically. The task pings all hosts except self using ping_command.
+     * When a host is not seen as alive, all members associated with that host are suspected */
+    protected class PingTask implements Runnable {
+
+        public void run() {
+            List<InetAddress> targets;
+            synchronized(hosts) {
+                targets=new ArrayList<InetAddress>(hosts.keySet());
+            }
+            targets.remove(local_host);
+
+            // 1. Ping each host
+            for(InetAddress target: targets) {
+                try {
+                    boolean is_alive=ping_command.isAlive(target, check_timeout);
+                    num_liveness_checks++;
+                    if(is_alive)
+                        updateTimestampFor(target);
+                    else
+                        log.trace(""%s: %s is not alive (age=%d secs)"", local_addr, target, getAgeOf(target) / 1000);
+                }
+                catch(Exception e) {
+                    log.error(""%s: ping command failed: %s"", local_addr, e);
+                }
+            }
+
+            // 2. Check timestamps
+            long current_time=getTimestamp();
+            for(Map.Entry<InetAddress,Long> entry: timestamps.entrySet()) {
+                InetAddress host=entry.getKey();
+                long timestamp=entry.getValue();
+                if(current_time - timestamp >= timeout)
+                    suspect(host);
+            }
+        }
+    }
+
+
+    /** Command used to check whether a given host is alive, periodically called */
+    public interface PingCommand {
+        /**
+         * Checks whether a given host is alive
+         * @param host The host to be checked for liveness
+         * @param timeout Number of milliseconds to wait for the check to complete
+         * @return true if the host is alive, else false
+         */
+        boolean isAlive(InetAddress host, long timeout) throws Exception;
+    }
+
+
+    public static class IsReachablePingCommand implements PingCommand {
+        public boolean isAlive(InetAddress host, long timeout) throws Exception {
+            return host.isReachable((int)timeout);
+        }
+    }
+
+    protected static class ExternalPingCommand implements PingCommand {
+        protected final String cmd;
+
+        public ExternalPingCommand(String cmd) {
+            this.cmd=cmd;
+        }
+
+        public boolean isAlive(InetAddress host, long timeout) throws Exception {
+            return CommandExecutor2.execute(cmd + "" "" + host.getHostAddress()) == 0;
+        }
+    }
+
+    public static class CommandExecutor {
+
+        public static int execute(String command) throws Exception {
+            Process p=Runtime.getRuntime().exec(command);
+            InputStream in=p.getInputStream(), err=p.getErrorStream();
+            try {
+                Reader in_reader, err_reader;
+                in_reader=new Reader(in);
+                err_reader=new Reader(err);
+                in_reader.start();
+                err_reader.start();
+                in_reader.join();
+                err_reader.join();
+                return p.exitValue();
+            }
+            finally {
+                Util.close(in);
+                Util.close(err);
+            }
+        }
+
+
+        static class Reader extends Thread {
+            InputStreamReader in;
+
+            Reader(InputStream in) {
+                this.in=new InputStreamReader(in);
+            }
+
+            public void run() {
+                int c;
+                while(true) {
+                    try {
+                        c=in.read();
+                        if(c == -1)
+                            break;
+                        // System.out.print((char)c);
+                    }
+                    catch(IOException e) {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    public static class CommandExecutor2 {
+        public static int execute(String command) throws Exception {
+            Process p=Runtime.getRuntime().exec(command);
+            return p.waitFor();
+        }
+    }
+}",2014-06-23T09:14:41Z,105
"@@ -0,0 +1,771 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.annotations.*;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.BoundedList;
+import org.jgroups.util.Util;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: FlowControl.java,v 1.1 2010/08/31 12:21:55 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public abstract class FlowControl extends Protocol {
+
+    protected final static FcHeader REPLENISH_HDR=new FcHeader(FcHeader.REPLENISH);
+    protected final static FcHeader CREDIT_REQUEST_HDR=new FcHeader(FcHeader.CREDIT_REQUEST);  
+
+    
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    
+    /**
+     * Max number of bytes to send per receiver until an ack must be received before continuing sending
+     */
+    @Property(description=""Max number of bytes to send per receiver until an ack must be received to proceed. Default is 500000 bytes"")
+    protected long max_credits=500000;
+
+    /**
+     * Max time (in milliseconds) to block. If credit hasn't been received after max_block_time, we send
+     * a REPLENISHMENT request to the members from which we expect credits. A value <= 0 means to wait forever.
+     */
+    @Property(description=""Max time (in milliseconds) to block. Default is 5000 msec"")
+    protected long max_block_time=5000;
+
+    /**
+     * Defines the max number of milliseconds for a message to block before being sent, based on the length of
+     * the message. The property is defined as a comma-separated list of values (separated by ':'), where the key
+     * is the size in bytes and the value is the number of milliseconds to block.
+     * Example: max_block_times=""50:1,500:3,1500:5,10000:10,100000:100"". This means that messages up to 50 bytes wait
+     * 1 ms max until they get sent, messages up to 500 bytes 3 ms, and so on.
+     * If a message's length (size of the payload in bytes) is for example 15'000 bytes,
+     * FlowControl blocks it for a max of 100 ms.
+     */
+    protected Map<Long,Long> max_block_times=null;
+
+    /** Keeps track of the end time after which a message should not get blocked anymore */
+    protected static final ThreadLocal<Long> end_time=new ThreadLocal<Long>();
+
+
+    /**
+     * If we've received (min_threshold * max_credits) bytes from P, we send more credits to P. Example: if
+     * max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits to P once we've
+     * received 250'000 bytes from P. 
+     */
+    @Property(description=""The threshold (as a percentage of max_credits) at which a receiver sends more credits to "" +
+            ""a sender. Example: if max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits "" +
+            ""to P once we've received 250'000 bytes from P"")
+    protected double min_threshold=0.60;
+
+    /**
+     * Computed as <tt>max_credits</tt> times <tt>min_theshold</tt>. If explicitly set, this will
+     * override the above computation
+     */
+    @Property(description=""Computed as max_credits x min_theshold unless explicitly set"")
+    protected long min_credits=0;
+    
+    /**
+     * Whether an up thread that comes back down should be allowed to
+     * bypass blocking if all credits are exhausted. Avoids JGRP-465.
+     * Set to false by default in 2.5 because we have OOB messages for credit replenishments - this flag should not be set
+     * to true if the concurrent stack is used
+     */
+    @Property(description=""Does not block a down message if it is a result of handling an up message in the"" +
+            ""same thread. Fixes JGRP-928"")
+    protected boolean ignore_synchronous_response=true;
+    
+    
+    
+    
+    /* ---------------------------------------------   JMX      ------------------------------------------------------ */
+    
+    
+    protected int num_blockings=0;
+    protected int num_credit_requests_received=0, num_credit_requests_sent=0;
+    protected int num_credit_responses_sent=0, num_credit_responses_received=0;
+    protected long total_time_blocking=0;
+
+    protected final BoundedList<Long> last_blockings=new BoundedList<Long>(50);
+    
+    
+    
+    /* --------------------------------------------- Fields ------------------------------------------------------ */
+    
+    
+    /**
+     * Map<Address,Long>: keys are members, values are credits left. For each send, the
+     * number of credits is decremented by the message size. A HashMap rather than a ConcurrentHashMap is
+     * currently used as there might be null values
+     */
+    @GuardedBy(""lock"")
+    protected final Map<Address,Credit> sent=new ConcurrentHashMap<Address,Credit>(11);
+
+    /**
+     * Keeps track of credits / member at the receiver's side. Keys are members, values are credits left (in bytes).
+     * For each receive, the credits for the sender are decremented by the size of the received message.
+     * When the credits fall below the threshold, we refill and send a REPLENISH message to the sender.
+     * The sender blocks until REPLENISH message is received.
+     */
+    protected final Map<Address,Credit> received=new ConcurrentHashMap<Address,Credit>(11);
+
+
+  
+    
+    /** Peers who have asked for credit that we didn't have */
+    protected final Set<Address> pending_requesters=new HashSet<Address>(11);
+
+    /**
+     * Whether FlowControl is still running, this is set to false when the protocol terminates (on stop())
+     */
+    protected volatile boolean running=true;
+
+
+    protected boolean frag_size_received=false;
+
+   
+
+    /** Lock protecting sent credits table and some other vars (creditors for example) */
+    // protected final Lock lock=new ReentrantLock();
+
+
+
+    /**
+     * Thread that carries messages through up() and shouldn't be blocked
+     * in down() if ignore_synchronous_response==true. JGRP-465.
+     */
+    protected final ThreadLocal<Boolean> ignore_thread=new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return false;
+        }
+    };   
+
+    /** Last time a credit request was sent. Used to prevent credit request storms */
+    @GuardedBy(""lock"")
+    protected long last_credit_request=0;   
+
+    public void resetStats() {
+        super.resetStats();
+        num_blockings=0;
+        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;
+        total_time_blocking=0;
+        last_blockings.clear();
+    }
+
+    public long getMaxCredits() {
+        return max_credits;
+    }
+
+    public void setMaxCredits(long max_credits) {
+        this.max_credits=max_credits;
+    }
+
+    public double getMinThreshold() {
+        return min_threshold;
+    }
+
+    public void setMinThreshold(double min_threshold) {
+        this.min_threshold=min_threshold;
+    }
+
+    public long getMinCredits() {
+        return min_credits;
+    }
+
+    public void setMinCredits(long min_credits) {
+        this.min_credits=min_credits;
+    }
+
+    @ManagedAttribute(description=""Number of times flow control blocks sender"")
+    public int getNumberOfBlockings() {
+        return num_blockings;
+    }
+
+    public long getMaxBlockTime() {
+        return max_block_time;
+    }
+
+    public void setMaxBlockTime(long t) {
+        max_block_time=t;
+    }
+
+    @Property(description=""Max times to block for the listed messages sizes (Message.getLength()). Example: \""1000:10,5000:30,10000:500\"""")
+    public void setMaxBlockTimes(String str) {
+        if(str == null) return;
+        Long prev_key=null, prev_val=null;
+        List<String> vals=Util.parseCommaDelimitedStrings(str);
+        if(max_block_times == null)
+            max_block_times=new TreeMap<Long,Long>();
+        for(String tmp: vals) {
+            int index=tmp.indexOf(':');
+            if(index == -1)
+                throw new IllegalArgumentException(""element '"" + tmp + ""'  is missing a ':' separator"");
+            Long key=Long.parseLong(tmp.substring(0, index).trim());
+            Long val=Long.parseLong(tmp.substring(index +1).trim());
+
+            // sanity checks:
+            if(key < 0 || val < 0)
+                throw new IllegalArgumentException(""keys and values must be >= 0"");
+
+            if(prev_key != null) {
+                if(key <= prev_key)
+                    throw new IllegalArgumentException(""keys are not sorted: "" + vals);
+            }
+            prev_key=key;
+
+            if(prev_val != null) {
+                if(val <= prev_val)
+                    throw new IllegalArgumentException(""values are not sorted: "" + vals);
+            }
+            prev_val=val;
+            max_block_times.put(key, val);
+        }
+        if(log.isDebugEnabled())
+            log.debug(""max_block_times: "" + max_block_times);
+    }
+
+    public String getMaxBlockTimes() {
+        if(max_block_times == null) return ""n/a"";
+        StringBuilder sb=new StringBuilder();
+        boolean first=true;
+        for(Map.Entry<Long,Long> entry: max_block_times.entrySet()) {
+            if(!first) {
+                sb.append("", "");
+            }
+            else {
+                first=false;
+            }
+            sb.append(entry.getKey()).append("":"").append(entry.getValue());
+        }
+        return sb.toString();
+    }
+    
+    @ManagedAttribute(description=""Total time (ms) spent in flow control block"")
+    public long getTotalTimeBlocked() {
+        return total_time_blocking;
+    }
+
+    @ManagedAttribute(description=""Average time spent in a flow control block"")
+    public double getAverageTimeBlocked() {
+        return num_blockings == 0? 0.0 : total_time_blocking / (double)num_blockings;
+    }
+
+    @ManagedAttribute(description=""Number of credit requests received"")
+    public int getNumberOfCreditRequestsReceived() {
+        return num_credit_requests_received;
+    }
+    
+    @ManagedAttribute(description=""Number of credit requests sent"")
+    public int getNumberOfCreditRequestsSent() {
+        return num_credit_requests_sent;
+    }
+
+    @ManagedAttribute(description=""Number of credit responses received"")
+    public int getNumberOfCreditResponsesReceived() {
+        return num_credit_responses_received;
+    }
+
+    @ManagedAttribute(description=""Number of credit responses sent"")
+    public int getNumberOfCreditResponsesSent() {
+        return num_credit_responses_sent;
+    }
+
+    @ManagedOperation(description=""Print sender credits"")
+    public String printSenderCredits() {
+        return printMap(sent);
+    }
+
+    @ManagedOperation(description=""Print receiver credits"")
+    public String printReceiverCredits() {
+        return printMap(received);
+    }
+
+    @ManagedOperation(description=""Print credits"")
+    public String printCredits() {
+        StringBuilder sb=new StringBuilder();
+        sb.append(""senders:\n"").append(printMap(sent)).append(""\n\nreceivers:\n"").append(printMap(received));
+        return sb.toString();
+    }
+
+    public Map<String, Object> dumpStats() {
+        Map<String, Object> retval=super.dumpStats();      
+        retval.put(""senders"", printMap(sent));
+        retval.put(""receivers"", printMap(received));
+        return retval;
+    }
+
+    @ManagedOperation(description=""Print last blocking times"")
+    public String showLastBlockingTimes() {
+        return last_blockings.toString();
+    }
+
+
+    protected long getMaxBlockTime(long length) {
+        if(max_block_times == null)
+            return 0;
+        Long retval=null;
+        for(Map.Entry<Long,Long> entry: max_block_times.entrySet()) {
+            retval=entry.getValue();
+            if(length <= entry.getKey())
+                break;
+        }
+
+        return retval != null? retval : 0;
+    }
+
+
+    /**
+     * Whether the protocol handles message with dest == null || dest.isMulticastAddress()
+     * @return
+     */
+    protected abstract boolean handleMulticastMessage();
+
+    protected abstract Credit createCredit(long credits);
+
+    protected abstract void handleCredit(Address sender, Number increase);
+
+
+    /**
+     * Allows to unblock a blocked sender from an external program, e.g. JMX
+     */
+    @ManagedOperation(description=""Unblock a sender"")
+    public void unblock() {
+        ;
+    }
+
+    public void init() throws Exception {
+        boolean min_credits_set = min_credits != 0;
+        if(!min_credits_set)
+            min_credits=(long)(max_credits * min_threshold);
+    }
+
+    public void start() throws Exception {
+        super.start();
+        if(!frag_size_received) {
+            log.warn(""No fragmentation protocol was found. When flow control is used, we recommend "" +
+                    ""a fragmentation protocol, due to http://jira.jboss.com/jira/browse/JGRP-590"");
+        }
+
+        running=true;
+
+    }
+
+    public void stop() {
+        super.stop();
+        running=false;
+        ignore_thread.set(false);
+    }
+
+
+    @SuppressWarnings(""unchecked"")
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                Address dest=msg.getDest();
+                boolean multicast=dest == null || dest.isMulticastAddress();
+                boolean handle_multicasts=handleMulticastMessage();
+                boolean process=(handle_multicasts && multicast) || (!handle_multicasts && !multicast);
+                if(!process)
+                    break;
+
+                if(msg.isFlagSet(Message.NO_FC))
+                    break;
+                int length=msg.getLength();
+                if(length == 0)
+                    break;
+                return handleDownMessage(evt, msg, length);
+            case Event.CONFIG:
+                handleConfigEvent((Map<String,Object>)evt.getArg()); 
+                break;
+            case Event.VIEW_CHANGE:
+                handleViewChange(((View)evt.getArg()).getMembers());
+                break;
+        }
+        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block
+    }
+
+
+    @SuppressWarnings(""unchecked"")
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+
+            case Event.MSG:
+
+                // JGRP-465. We only deal with msgs to avoid having to use a concurrent collection; ignore views,
+                // suspicions, etc which can come up on unusual threads.
+                Message msg=(Message)evt.getArg();
+                Address dest=msg.getDest();
+                boolean multicast=dest == null || dest.isMulticastAddress();
+                boolean handle_multicasts=handleMulticastMessage();
+                boolean process=(handle_multicasts && multicast) || (!handle_multicasts && !multicast);
+                if(!process)
+                    break;
+
+                if(msg.isFlagSet(Message.NO_FC))
+                    break;
+                
+                FcHeader hdr=(FcHeader)msg.getHeader(this.id);
+                if(hdr != null) {
+                    switch(hdr.type) {
+                        case FcHeader.REPLENISH:
+                            num_credit_responses_received++;
+                            handleCredit(msg.getSrc(), (Number)msg.getObject());
+                            break;
+                        case FcHeader.CREDIT_REQUEST:
+                            num_credit_requests_received++;
+                            Address sender=msg.getSrc();
+                            Long sent_credits=(Long)msg.getObject();
+                            if(sent_credits != null)
+                                handleCreditRequest(received, sender, sent_credits.longValue());
+                            break;
+                        default:
+                            log.error(""header type "" + hdr.type + "" not known"");
+                            break;
+                    }
+                    return null; // don't pass message up
+                }
+
+                Address sender=msg.getSrc();
+                long new_credits=adjustCredit(received, sender, msg.getLength());
+                
+                // JGRP-928: changed ignore_thread to a ThreadLocal: multiple threads can access it with the
+                // introduction of the concurrent stack
+                if(ignore_synchronous_response)
+                    ignore_thread.set(true);
+                try {
+                    return up_prot.up(evt);
+                }
+                finally {
+                    if(ignore_synchronous_response)
+                        ignore_thread.set(false); // need to revert because the thread is placed back into the pool
+                    if(new_credits > 0) {
+                        if(log.isTraceEnabled()) log.trace(""sending "" + new_credits + "" credits to "" + sender);
+                        sendCredit(sender, new_credits);
+                    }
+                }
+
+            case Event.VIEW_CHANGE:
+                handleViewChange(((View)evt.getArg()).getMembers());
+                break;
+
+            case Event.CONFIG:
+                Map<String,Object> map=(Map<String,Object>)evt.getArg();
+                handleConfigEvent(map);
+                break;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    protected void handleConfigEvent(Map<String,Object> info) {
+        if(info != null) {
+            Integer frag_size=(Integer)info.get(""frag_size"");
+            if(frag_size != null) {
+                if(frag_size > max_credits) {
+                    log.warn(""The fragmentation size of the fragmentation protocol is "" + frag_size +
+                            "", which is greater than the max credits. While this is not incorrect, "" +
+                            ""it may lead to long blockings. Frag size should be less than max_credits "" +
+                            ""(http://jira.jboss.com/jira/browse/JGRP-590)"");
+                }
+                frag_size_received=true;
+            }
+        }
+    }
+
+    
+    protected abstract Object handleDownMessage(final Event evt, final Message msg, int length);
+
+
+
+
+
+
+    /**
+     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast
+     * or unicast message. No need to acquire mutex (must already be held when this method is called)
+     * @param dest
+     * @param credits
+     * @return The lowest number of credits left, or -1 if a unicast member was not found
+     */
+    protected long decrementCredit(Map<Address,Credit> map, Address dest, long credits) {
+        if(dest == null || dest.isMulticastAddress()) {
+            if(map.isEmpty())
+                return -1;
+            long lowest=max_credits;
+            for(Credit cred: map.values())
+                lowest=Math.min(cred.decrement(credits), lowest);
+            return lowest;
+        }
+        else {
+            Credit cred=map.get(dest);
+            if(cred != null)
+                return cred.decrement(credits);
+            }
+        return -1;
+    }
+
+
+
+
+   
+
+
+    /**
+     * Check whether sender has enough credits left. If not, send it some more
+     * @param map The hashmap to use
+     * @param sender The address of the sender
+     * @param length The number of bytes received by this message. We don't care about the size of the headers for
+     * the purpose of flow control
+     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise
+     */
+    protected long adjustCredit(Map<Address,Credit> map, Address sender, int length) {
+        if(sender == null || length == 0)
+            return 0;
+
+        Credit cred=map.get(sender);
+        if(cred == null)
+            return 0;
+
+        if(log.isTraceEnabled())
+            log.trace(""sender "" + sender + "" minus "" + length + "" credits, "" + (cred.get() - length) + "" remaining"");
+
+        return cred.decrementAndGet(length);
+    }
+
+    /**
+     * @param map The map to modify
+     * @param sender The sender who requests credits
+     * @param left_credits Number of bytes that the sender has left to send messages to us
+     */
+    protected void handleCreditRequest(Map<Address,Credit> map, Address sender, long left_credits) {
+        if(sender == null) return;
+        long credit_response=0;
+        Credit cred=map.get(sender);
+
+        long old_credit=cred != null? cred.get() : 0;
+        if(old_credit > 0)
+            credit_response=Math.min(max_credits, max_credits - old_credit);
+
+        if(credit_response > 0) {
+            if(log.isTraceEnabled())
+                log.trace(""received credit request from "" + sender + "": sending "" + credit_response + "" credits"");
+            if(cred != null)
+                cred.set(max_credits);
+            else
+                map.put(sender, createCredit(max_credits));
+            pending_requesters.remove(sender);
+        }
+        else {
+            if(pending_requesters.contains(sender)) {
+                // a sender might have negative credits, e.g. -20000. If we subtracted -20000 from max_credits,
+                // we'd end up with max_credits + 20000, and send too many credits back. So if the sender's
+                // credits is negative, we simply send max_credits back
+                long credits_left=Math.max(0, left_credits);
+                credit_response=max_credits - credits_left;
+                // credit_response = max_credits;
+                if(cred != null)
+                    cred.set(max_credits);
+                else
+                    map.put(sender, createCredit(max_credits));
+                pending_requesters.remove(sender);
+                if(log.isWarnEnabled())
+                    log.warn(""Received two credit requests from "" + sender +
+                            "" without any intervening messages; sending "" + credit_response + "" credits"");
+            }
+            else {
+                pending_requesters.add(sender);
+                if(log.isTraceEnabled())
+                    log.trace(""received credit request from "" + sender + "" but have no credits available"");
+            }
+        }
+
+
+        if(credit_response > 0)
+            sendCredit(sender, credit_response);
+    }
+
+
+    protected void sendCredit(Address dest, long credit) {
+        if(log.isTraceEnabled())
+            log.trace(""replenishing "" + dest + "" with "" + credit	+ "" credits"");
+        Number number;
+        if(credit < Integer.MAX_VALUE)
+            number=(int)credit;
+        else
+            number=credit;
+        Message msg=new Message(dest, null, number);
+        msg.setFlag(Message.OOB);
+        msg.putHeader(this.id, REPLENISH_HDR);
+        down_prot.down(new Event(Event.MSG, msg));
+        num_credit_responses_sent++;
+    }
+
+    /**
+     * We cannot send this request as OOB messages, as the credit request needs to queue up behind the regular messages;
+     * if a receiver cannot process the regular messages, that is a sign that the sender should be throttled !
+     * @param dest The member to which we send the credit request
+     * @param credits_left The number of bytes (of credits) left for dest
+     */
+    protected void sendCreditRequest(final Address dest, Long credits_left) {
+        if(log.isTraceEnabled())
+            log.trace(""sending credit request to "" + dest);
+        Message msg=new Message(dest, null, credits_left);
+        msg.putHeader(this.id, CREDIT_REQUEST_HDR);
+        down_prot.down(new Event(Event.MSG, msg));
+        num_credit_requests_sent++;
+    }
+
+
+    protected void handleViewChange(Vector<Address> mbrs) {
+        Address addr;
+        if(mbrs == null) return;
+        if(log.isTraceEnabled()) log.trace(""new membership: "" + mbrs);
+
+
+        // add members not in membership to received and sent hashmap (with full credits)
+        for(int i=0; i < mbrs.size(); i++) {
+            addr=mbrs.elementAt(i);
+            if(!received.containsKey(addr))
+                received.put(addr, createCredit(max_credits));
+            if(!sent.containsKey(addr))
+                sent.put(addr, createCredit(max_credits));
+        }
+        // remove members that left
+        for(Iterator<Address> it=received.keySet().iterator(); it.hasNext();) {
+            addr=it.next();
+            if(!mbrs.contains(addr))
+                it.remove();
+        }
+
+        // remove members that left
+        for(Iterator<Address> it=sent.keySet().iterator(); it.hasNext();) {
+            addr=it.next();
+            if(!mbrs.contains(addr))
+                it.remove(); // modified the underlying map
+        }
+
+      
+    }
+
+    protected static long computeLowestCredit(Map<Address,Credit> m) {
+        Collection<Credit> credits=m.values();
+        return Collections.min(credits).get();
+    }
+
+    protected static String printMap(Map<Address,Credit> m) {
+        StringBuilder sb=new StringBuilder();
+        for(Map.Entry<Address,Credit> entry: m.entrySet()) {
+            sb.append(entry.getKey()).append("": "").append(entry.getValue()).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+
+
+    protected abstract class Credit implements Comparable {
+        protected long credits_left;
+
+        protected Credit(long credits) {
+            this.credits_left=credits;
+        }
+
+        protected synchronized long decrementAndGet(long credits) {
+            credits_left=Math.max(0, credits_left - credits);
+            long credit_response=max_credits - credits_left;
+            if(credit_response >= min_credits) {
+                credits_left=max_credits;
+                return credit_response;
+            }
+            return 0;
+        }
+
+        protected synchronized long decrement(long credits) {
+            return credits_left=Math.max(0, credits_left - credits);
+        }
+
+        
+
+        protected synchronized long get() {return credits_left;}
+
+        protected synchronized void set(long new_credits) {credits_left=Math.min(max_credits, new_credits);}
+
+        protected synchronized long increment(long credits) {
+            return credits_left=Math.min(max_credits, credits_left + credits);
+        }
+
+        public String toString() {
+            return String.valueOf(credits_left);
+        }
+
+        public int compareTo(Object o) {
+            Credit other=(Credit)o;
+            return credits_left < other.credits_left ? -1 : credits_left > other.credits_left ? 1 : 0;
+        }
+    }
+
+
+   /* protected abstract class Credit implements Comparable {
+        protected long credits_left;
+
+        protected Credit(long credits) {
+            this.credits_left=credits;
+        }
+
+        protected long decrementAndGet(long credits) {
+            credits_left=Math.max(0, credits_left - credits);
+            long credit_response=max_credits - credits_left;
+            if(credit_response >= min_credits) {
+                credits_left=max_credits;
+                return credit_response;
+            }
+            return 0;
+        }
+
+        protected long decrement(long credits) {
+            return credits_left=Math.max(0, credits_left - credits);
+        }
+
+        protected long get() {return credits_left;}
+
+        protected void set(long new_credits) {credits_left=Math.min(max_credits, new_credits);}
+
+        protected long increment(long credits) {
+            return credits_left=Math.min(max_credits, credits_left + credits);
+        }
+
+        public String toString() {
+            return String.valueOf(credits_left);
+        }
+
+        public int compareTo(Object o) {
+            Credit other=(Credit)o;
+            return credits_left < other.credits_left ? -1 : credits_left > other.credits_left ? 1 : 0;
+        }
+       
+    }*/
+
+
+}",2010-08-31T12:21:54Z,106
"@@ -0,0 +1,330 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.*;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.BoundedList;
+import org.jgroups.util.Util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: MFC.java,v 1.1 2010/08/31 12:21:55 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public class MFC extends FlowControl {
+
+    
+    
+    /* --------------------------------------------- Fields ------------------------------------------------------ */
+    
+    
+  
+    /**
+     * the lowest credits of any destination (sent_msgs)
+     */
+    @GuardedBy(""lock"")
+    private long lowest_credit=max_credits;
+
+    /** Lock protecting sent credits table and some other vars (creditors for example) */
+    private final Lock lock=new ReentrantLock();
+
+
+    /** List of members from whom we expect credits */
+    @GuardedBy(""lock"")
+    protected final Set<Address> creditors=new HashSet<Address>(11);
+
+
+    /** Mutex to block on down() */
+    private final Condition credits_available=lock.newCondition();
+   
+
+    /**
+     * Allows to unblock a blocked sender from an external program, e.g. JMX
+     */
+    @ManagedOperation(description=""Unblock a sender"")
+    public void unblock() {
+        lock.lock();
+        try {
+            if(log.isTraceEnabled())
+                log.trace(""unblocking the sender and replenishing all members"");
+
+            for(Map.Entry<Address,Credit> entry: sent.entrySet())
+                entry.getValue().set(max_credits);
+
+            lowest_credit=computeLowestCredit(sent);
+            creditors.clear();
+            credits_available.signalAll();
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+    
+
+    public void init() throws Exception {
+        super.init();
+        lowest_credit=max_credits;
+    }
+
+    public void start() throws Exception {
+        super.start();
+        lowest_credit=max_credits;
+    }
+
+    public void stop() {
+        super.stop();
+        lock.lock();
+        try {
+            running=false;
+            ignore_thread.set(false);
+            credits_available.signalAll(); // notify all threads waiting on the mutex that we are done
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+    protected boolean handleMulticastMessage() {
+        return true;
+    }
+
+    protected Credit createCredit(long credits) {
+        return new MfcCredit(credits);
+    }
+
+
+
+
+    protected Object handleDownMessage(final Event evt, final Message msg, int length) {
+        Address dest=msg.getDest();
+
+        if(max_block_times != null) {
+            long tmp=getMaxBlockTime(length);
+            if(tmp > 0)
+                end_time.set(System.currentTimeMillis() + tmp);
+        }
+
+        lock.lock();
+        try {
+            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available
+                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465
+                    if(log.isTraceEnabled())
+                        log.trace(""bypassing blocking to avoid deadlocking "" + Thread.currentThread());
+                }
+                else {
+                    determineCreditors(dest, length);
+                    long start_blocking=System.currentTimeMillis();
+                    num_blockings++; // we count overall blockings, not blockings for *all* threads
+                    if(log.isTraceEnabled())
+                        log.trace(""Starting blocking. lowest_credit="" + lowest_credit + ""; msg length ="" + length);
+
+                    while(length > lowest_credit && running) {
+                        try {
+                            long block_time=max_block_time;
+                            if(max_block_times != null) {
+                                Long tmp=end_time.get();
+                                if(tmp != null) {
+                                    // A negative block_time means we don't wait at all ! If the end_time already elapsed
+                                    // (because we waited for other threads to get processed), the message will not
+                                    // block at all and get sent immediately
+                                    block_time=tmp - start_blocking;
+                                }
+                            }
+
+                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);
+                            if(length <= lowest_credit || rc || !running)
+                                break;
+
+                            // if we use max_block_times, then we do *not* send credit requests, even if we run
+                            // into timeouts: in this case, it is up to the receivers to send new credits
+                            if(!rc && max_block_times != null)
+                                break;
+
+                            long wait_time=System.currentTimeMillis() - last_credit_request;
+                            if(wait_time >= max_block_time) {
+
+                                // we have to set this var now, because we release the lock below (for sending a
+                                // credit request), so all blocked threads would send a credit request, leading to
+                                // a credit request storm
+                                last_credit_request=System.currentTimeMillis();
+
+                                // we need to send the credit requests down *without* holding the lock, otherwise we might
+                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292
+                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);
+                                sent_copy.keySet().retainAll(creditors);
+                                lock.unlock();
+                                try {
+                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())
+                                        sendCreditRequest(entry.getKey(), entry.getValue().get());
+                                }
+                                finally {
+                                    lock.lock();
+                                }
+                            }
+                        }
+                        catch(InterruptedException e) {
+                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!
+                            // (http://jira.jboss.com/jira/browse/JGRP-536)
+                            // Thread.currentThread().interrupt();
+                        }
+                    }
+                    long block_time=System.currentTimeMillis() - start_blocking;
+                    if(log.isTraceEnabled())
+                        log.trace(""total time blocked: "" + block_time + "" ms"");
+                    total_time_blocking+=block_time;
+                    last_blockings.add(block_time);
+                }
+            }
+
+            long tmp=decrementCredit(sent, dest, length);
+            if(tmp != -1)
+                lowest_credit=Math.min(tmp, lowest_credit);
+        }
+        finally {
+            lock.unlock();
+        }
+
+        // send message - either after regular processing, or after blocking (when enough credits available again)
+        return down_prot.down(evt);
+    }
+
+    /**
+     * Checks whether one member (unicast msg) or all members (multicast msg) have enough credits. Add those
+     * that don't to the creditors list. Called with lock held
+     * @param dest
+     * @param length
+     */
+    protected void determineCreditors(Address dest, int length) {
+        boolean multicast=dest == null || dest.isMulticastAddress();
+        if(multicast) {
+            for(Map.Entry<Address,Credit> entry: sent.entrySet()) {
+                if(entry.getValue().get() <= length)
+                    creditors.add(entry.getKey());
+            }
+        }
+        else {
+            Credit cred=sent.get(dest);
+            if(cred != null && cred.get() <= length)
+                creditors.add(dest);
+        }
+    }
+
+
+  
+
+    /**
+     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast
+     * or unicast message. No need to acquire mutex (must already be held when this method is called)
+     * @param dest
+     * @param credits
+     * @return The lowest number of credits left, or -1 if a unicast member was not found
+     */
+    protected long decrementCredit(Map<Address,Credit> map, Address dest, long credits) {
+        boolean multicast=dest == null || dest.isMulticastAddress();
+        long lowest=max_credits;
+
+        if(multicast) {
+            if(map.isEmpty())
+                return -1;
+            for(Credit cred: map.values())
+                lowest=Math.min(cred.decrement(credits), lowest);
+            return lowest;
+        }
+        else {
+            Credit cred=map.get(dest);
+            if(cred != null)
+                return lowest=cred.decrement(credits);
+            }
+        return -1;
+    }
+
+    protected void handleCredit(Address sender, Number increase) {
+        if(sender == null) return;
+        StringBuilder sb=null;
+
+        lock.lock();
+        try {
+            Credit cred=sent.get(sender);
+            if(cred == null)
+                return;
+            long new_credit=Math.min(max_credits, cred.get() + increase.longValue());
+
+            if(log.isTraceEnabled()) {
+                sb=new StringBuilder();
+                sb.append(""received "" + increase + "" credits from "").append(sender).append("", old credits: "").append(cred)
+                        .append("", new credits: "").append(new_credit).append("".\nCreditors before are: "").append(creditors);
+                log.trace(sb);
+            }
+
+            cred.increment(increase.longValue());
+
+            lowest_credit=computeLowestCredit(sent);
+            if(!creditors.isEmpty() && creditors.remove(sender) && creditors.isEmpty())
+                credits_available.signalAll();
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+
+    protected void handleViewChange(Vector<Address> mbrs) {
+        super.handleViewChange(mbrs);
+
+        lock.lock();
+        try {
+            // fixed http://jira.jboss.com/jira/browse/JGRP-754 (CCME)
+            for(Iterator<Address> it=creditors.iterator(); it.hasNext();) {
+                Address creditor=it.next();
+                if(!mbrs.contains(creditor))
+                    it.remove();
+            }
+
+            if(log.isTraceEnabled()) log.trace(""creditors are "" + creditors);
+            if(creditors.isEmpty()) {
+                lowest_credit=computeLowestCredit(sent);
+                credits_available.signalAll();
+            }
+        }
+        finally {
+            lock.unlock();
+        }
+    }
+
+    protected class MfcCredit extends Credit {
+
+        protected MfcCredit(long credits) {
+            super(credits);
+        }
+    }
+
+
+}",2010-08-31T12:21:54Z,107
"@@ -0,0 +1,225 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+
+
+/**
+ * Simple flow control protocol based on a credit system. Each sender has a number of credits (bytes
+ * to send). When the credits have been exhausted, the sender blocks. Each receiver also keeps track of
+ * how many credits it has received from a sender. When credits for a sender fall below a threshold,
+ * the receiver sends more credits to the sender. Works for both unicast and multicast messages.
+ * <p/>
+ * Note that this protocol must be located towards the top of the stack, or all down_threads from JChannel to this
+ * protocol must be set to false ! This is in order to block JChannel.send()/JChannel.down().
+ * <br/>This is the second simplified implementation of the same model. The algorithm is sketched out in
+ * doc/FlowControl.txt
+ * <br/>
+ * Changes (Brian) April 2006:
+ * <ol>
+ * <li>Receivers now send credits to a sender when more than min_credits have been received (rather than when min_credits
+ * are left)
+ * <li>Receivers don't send the full credits (max_credits), but rather the actual number of bytes received
+ * <ol/>
+ * @author Bela Ban
+ * @version $Id: UFC.java,v 1.1 2010/08/31 12:21:54 belaban Exp $
+ */
+@MBean(description=""Simple flow control protocol based on a credit system"")
+public class UFC extends FlowControl {
+
+    
+
+    protected boolean handleMulticastMessage() {
+        return false;
+    }
+
+
+    protected Credit createCredit(long credits) {
+        return new UfcCredit(credits);
+    }
+
+    public void unblock() {
+        super.unblock();
+    }
+
+    public double getAverageTimeBlocked() {
+        int    blockings=0;
+        long   total_time_blocked=0;
+
+        for(Credit cred: sent.values()) {
+            blockings+=((UfcCredit)cred).getNumBlockings();
+            total_time_blocked=((UfcCredit)cred).getTotalBlockingTime();
+        }
+
+        return blockings > 0? total_time_blocked / (double)blockings : 0.0; // prevent div-by-zero
+    }
+
+
+    public int getNumberOfBlockings() {
+        int retval=0;
+        for(Credit cred: sent.values())
+            retval+=((UfcCredit)cred).getNumBlockings();
+        return retval;
+    }
+
+    public long getTotalTimeBlocked() {
+        long retval=0;
+        for(Credit cred: sent.values())
+            retval+=((UfcCredit)cred).getTotalBlockingTime();
+        return retval;
+    }
+
+    public void stop() {
+        super.stop();
+        for(final Credit cred: sent.values()) {
+            synchronized(cred) {
+                cred.notifyAll();
+            }
+        }
+    }
+
+
+
+
+    protected Object handleDownMessage(final Event evt, final Message msg, int length) {
+        Address dest=msg.getDest();
+        if(dest == null || dest.isMulticastAddress()) {
+            log.error(getClass().getSimpleName() + "" doesn't handle multicast messages; passing message down"");
+            return down_prot.down(evt);
+        }
+
+        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465
+            if(log.isTraceEnabled())
+                log.trace(""bypassing blocking to avoid deadlocking "" + Thread.currentThread());
+            return down_prot.down(evt);
+        }
+
+        if(max_block_times != null) {
+            long tmp=getMaxBlockTime(length);
+            if(tmp > 0)
+                end_time.set(System.currentTimeMillis() + tmp);
+        }
+
+        UfcCredit cred=(UfcCredit)sent.get(dest);
+        if(cred == null) {
+            log.error(""destination "" + dest + "" not found; passing message down"");
+            return down_prot.down(evt);
+        }
+
+        while(running) {
+            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block
+                break;
+
+            long start_blocking=System.currentTimeMillis();
+            long block_time=max_block_time;
+            if(max_block_times != null) {
+                Long tmp=end_time.get();
+                if(tmp != null) {
+                    // A negative block_time means we don't wait at all ! If the end_time already elapsed
+                    // (because we waited for other threads to get processed), the message will not
+                    // block at all and get sent immediately
+                    block_time=tmp - start_blocking;
+                }
+            }
+
+            if(log.isTraceEnabled())
+                log.trace(""blocking for credits (for "" + block_time + "" ms)"");
+            boolean rc=cred.decrementIfEnoughCredits(length, block_time);
+            if(rc && log.isTraceEnabled())
+                log.trace(""unblocking (received credits)"");
+            last_blockings.add(System.currentTimeMillis() - start_blocking);
+            
+            if(rc || !running || max_block_times != null)
+                break;
+
+            if(cred.sendCreditRequest(System.currentTimeMillis()))
+                sendCreditRequest(dest, cred.get());
+        }
+
+        // send message - either after regular processing, or after blocking (when enough credits available again)
+        return down_prot.down(evt);
+    }
+    
+
+
+    protected void handleCredit(Address sender, Number increase) {
+        if(sender == null) return;
+        StringBuilder sb=null;
+
+        Credit cred=sent.get(sender);
+        if(cred == null)
+            return;
+        long new_credit=Math.min(max_credits, cred.get() + increase.longValue());
+
+        if(log.isTraceEnabled()) {
+            sb=new StringBuilder();
+            sb.append(""received "" + increase + "" credits from "").append(sender).append("", old credits: "").append(cred)
+                    .append("", new credits: "").append(new_credit);
+            log.trace(sb);
+        }
+
+        cred.increment(increase.longValue());
+    }
+    
+
+    protected class UfcCredit extends Credit {
+        int num_blockings=0;
+        long total_blocking_time=0;
+        long last_credit_request=0;
+
+        protected UfcCredit(long credits) {
+            super(credits);
+        }
+
+        protected synchronized boolean decrementIfEnoughCredits(long credits, long timeout) {
+            if(credits <= credits_left) {
+                credits_left-=credits;
+                return true;
+            }
+
+            if(timeout <= 0)
+                return false;
+
+            long start=System.currentTimeMillis();
+            try {
+                this.wait(timeout);
+            }
+            catch(InterruptedException e) {
+            }
+            finally {
+                total_blocking_time+=System.currentTimeMillis() - start;
+                num_blockings++;
+            }
+
+            if(credits <= credits_left) {
+                credits_left-=credits;
+                return true;
+            }
+            return false;
+        }
+
+        protected synchronized long increment(long credits) {
+            long retval=super.increment(credits);
+            notifyAll();
+            return retval;
+        }
+
+        protected synchronized boolean sendCreditRequest(long current_time) {
+            if(current_time - last_credit_request >= max_block_time) {
+                // we have to set this var now, because we release the lock below (for sending a credit request), so
+                // all blocked threads would send a credit request, leading to a credit request storm
+                last_credit_request=System.currentTimeMillis();
+                return true;
+            }
+            return false;
+        }
+
+        protected int getNumBlockings() {return num_blockings;}
+
+        protected long getTotalBlockingTime() {return total_blocking_time;}
+    }
+
+
+}",2010-08-31T12:21:54Z,108
"@@ -269,24 +269,32 @@ static class PreSignedUrlParser {
         public PreSignedUrlParser(String preSignedUrl) {
             try {
                 URL url = new URL(preSignedUrl);
+                this.bucket = parseBucketFromHost(url.getHost());
                 String path = url.getPath();
                 String[] pathParts = path.split(""/"");
                 
-                if (pathParts.length < 3) {
+                if (pathParts.length < 2) {
                     throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" must point to a file within a bucket"");
                 }
-                if (pathParts.length > 4) {
+                if (pathParts.length > 3) {
                     throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" may only have only subdirectory under a bucket"");
                 }
-                this.bucket = pathParts[1];
-                if (pathParts.length > 3) {
-                    this.prefix = pathParts[2];
+                if (pathParts.length > 2) {
+                    this.prefix = pathParts[1];
                 }
             } catch (MalformedURLException ex) {
                 throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" is not a valid url"");
             }
         }
 
+        private String parseBucketFromHost(String host) {
+            int s3Index = host.lastIndexOf("".s3."");
+            if (s3Index > 0) {
+                host = host.substring(0, s3Index);
+            }
+            return host;
+        }
+
         public String getBucket() {
             return bucket;
         }
@@ -1811,7 +1819,7 @@ public static String generateQueryStringAuthentication(String awsAccessKey, Stri
             String canonicalString =
                 makeCanonicalString(method, bucket, key, pathArgs, headers, """" + expirationDate);
             String encodedCanonical = encode(awsSecretAccessKey, canonicalString, true);
-            return ""http://"" + DEFAULT_HOST + ""/"" + bucket + ""/"" + key + ""?"" +
+            return ""http://"" + bucket + ""."" + DEFAULT_HOST + ""/"" + key + ""?"" +
                 ""AWSAccessKeyId="" + awsAccessKey + ""&Expires="" + expirationDate +
                 ""&Signature="" + encodedCanonical;
         }",2014-02-07T19:45:51Z,109
"@@ -5,6 +5,7 @@
 import java.util.Map;
 
 import org.jgroups.Global;
+import org.jgroups.protocols.S3_PING.PreSignedUrlParser;
 import org.jgroups.protocols.S3_PING.Utils;
 import org.testng.Assert;
 import org.testng.annotations.BeforeMethod;
@@ -40,29 +41,29 @@ public void testValidatePropertiesWithBothPreSignedSetButNoBucket() {
     
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testValidatePropertiesWithBothPreSignedSetButNoFile() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/"";
         ping.validateProperties();
     }
     
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testValidatePropertiesWithBothPreSignedSetButTooManySubdirectories() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/subdir/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/subdir/DemoCluster/node1"";
         ping.validateProperties();
     }
     
     @Test
     public void testValidatePropertiesWithBothPreSignedSetToValid() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/node1"";
         ping.validateProperties();
     }
     
     @Test
     public void testValidatePropertiesWithBothPreSignedSetToValidSubdirectory() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
-        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://test-bucket.s3.amazonaws.com/DemoCluster/node1"";
         ping.validateProperties();
     }
     
@@ -73,13 +74,13 @@ public void testUsingPreSignedUrlWhenNotSet() {
     
     @Test
     public void testUsingPreSignedUrlWhenSet() {
-        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_put_url = ""http://test-bucket.s3.amazonaws.com/node1"";
         Assert.assertTrue(ping.usingPreSignedUrls());
     }
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicGet() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""get"",
                                                     ""test-bucket"", ""node1"",
@@ -90,7 +91,7 @@ public void testGenerateQueryStringAuthenticationWithBasicGet() {
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicPost() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""POST"",
                                                     ""test-bucket"", ""node1"",
@@ -103,7 +104,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPost() {
     public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
         Map headers = new HashMap();
         headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
         String encodedUrl =
             Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""put"",
                                                     ""test-bucket"", ""subdir/node1"",
@@ -114,7 +115,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
     
     @Test
     public void testGeneratePreSignedUrlForPut() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
         String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
                                                            ""test-bucket"", ""subdir/node1"",
                                                            1234567890);
@@ -123,10 +124,31 @@ public void testGeneratePreSignedUrlForPut() {
     
     @Test
     public void testGeneratePreSignedUrlForDelete() {
-        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
+        String expectedUrl = ""http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
         String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
                                                            ""test-bucket"", ""subdir/node1"",
                                                            1234567890);
         Assert.assertEquals(preSignedUrl, expectedUrl);
     }
-}
\ No newline at end of file
+
+    @Test
+    public void testPreSignedUrlParserNoPrefix() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.amazonaws.com/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket"");
+        Assert.assertEquals(parser.getPrefix(), """");
+    }
+
+    @Test
+    public void testPreSignedUrlParserWithPrefix() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.amazonaws.com/subdir/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket"");
+        Assert.assertEquals(parser.getPrefix(), ""subdir"");
+    }
+
+    @Test
+    public void testPreSignedUrlParserWithComplexBucketName() {
+        PreSignedUrlParser parser = new PreSignedUrlParser(""http://test-bucket.s3.foo-bar.s3.amazonaws.com/node1"");
+        Assert.assertEquals(parser.getBucket(), ""test-bucket.s3.foo-bar"");
+        Assert.assertEquals(parser.getPrefix(), """");
+    }
+}",2014-02-07T19:45:51Z,110
"@@ -1,19 +1,16 @@
 package org.jgroups.protocols;
 
-import org.jgroups.Event;
-import org.jgroups.Message;
-import org.jgroups.PhysicalAddress;
+import org.jgroups.*;
 import org.jgroups.annotations.Property;
 import org.jgroups.annotations.Experimental;
 import org.jgroups.util.UUID;
 import org.jgroups.util.Util;
 import org.jgroups.util.Promise;
 
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Collection;
+import java.util.*;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
 
 
 /**
@@ -22,7 +19,7 @@
  * added to our transport's UUID-PhysicalAddress cache.<p/>
  * The design is at doc/design/FILE_PING.txt
  * @author Bela Ban
- * @version $Id: FILE_PING.java,v 1.16 2010/06/16 08:48:32 belaban Exp $
+ * @version $Id: FILE_PING.java,v 1.17 2010/06/16 11:21:38 belaban Exp $
  */
 @Experimental
 public class FILE_PING extends Discovery {
@@ -34,10 +31,14 @@ public class FILE_PING extends Discovery {
     @Property(description=""The absolute path of the shared file"")
     protected String location=File.separator + ""tmp"" + File.separator + ""jgroups"";
 
+    @Property(description=""Interval (in milliseconds) at which the own address is written to the file system. 0 disables it."")
+    protected long interval=60000;
+
 
     /* --------------------------------------------- Fields ------------------------------------------------------ */
     protected File root_dir=null;
     protected FilenameFilter filter;
+    private ScheduledFuture<?> writer_future;
 
 
     public void init() throws Exception {
@@ -58,9 +59,23 @@ public boolean accept(File dir, String name) {
                 return name.endsWith(SUFFIX);
             }
         };
+
+
     }
 
+    public void start() throws Exception {
+        super.start();
+        if(interval > 0)
+            writer_future=timer.scheduleWithFixedDelay(new WriterTask(), interval, interval, TimeUnit.MILLISECONDS);
+    }
 
+    public void stop() {
+        if(writer_future != null) {
+            writer_future.cancel(false);
+            writer_future=null;
+        }
+        super.stop();
+    }
 
     public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception{
         List<PingData> existing_mbrs=readAll(cluster_name);
@@ -112,6 +127,47 @@ public void run() {
     }
 
 
+    public Object down(Event evt) {
+        Object retval=super.down(evt);
+        if(evt.getType() == Event.VIEW_CHANGE)
+            handleView((View)evt.getArg());
+        return retval;
+    }
+
+    // remove all files which are not from the current members
+    protected void handleView(View view) {
+        Collection<Address> mbrs=view.getMembers();
+        boolean is_coordinator=!mbrs.isEmpty() && mbrs.iterator().next().equals(local_addr);
+        if(is_coordinator) {
+            List<PingData> data=readAll(group_addr);
+            for(PingData entry: data) {
+                Address addr=entry.getAddress();
+                if(addr != null && !mbrs.contains(addr)) {
+                    remove(group_addr, addr);
+                }
+            }
+        }
+    }
+
+    protected void remove(String clustername, Address addr) {
+        if(clustername == null || addr == null)
+            return;
+
+        File dir=new File(root_dir, clustername);
+        if(!dir.exists())
+            return;
+
+        try {
+            String filename=addr instanceof UUID? ((UUID)addr).toStringLong() : addr.toString();
+            File file=new File(dir, filename + SUFFIX);
+            if(log.isTraceEnabled())
+                log.trace(""removing "" + file);
+            file.delete();
+        }
+        catch(Throwable e) {
+            log.error(""failure removing data"", e);
+        }
+    }
 
     /**
      * Reads all information from the given directory under clustername
@@ -171,5 +227,15 @@ protected void writeToFile(PingData data, String clustername) {
     }
 
 
+    protected class WriterTask implements Runnable {
+        public void run() {
+            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));
+            List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);
+            PingData data=new PingData(local_addr, null, false, UUID.get(local_addr), physical_addrs);
+            writeToFile(data, group_addr);
+        }
+    }
+
+
 
 }
\ No newline at end of file",2010-06-16T11:21:38Z,111
"@@ -1,9 +1,10 @@
 package org.jgroups.protocols;
 
-import org.jgroups.util.*;
-import org.jgroups.annotations.Property;
+import org.jgroups.Address;
 import org.jgroups.annotations.Experimental;
+import org.jgroups.annotations.Property;
 import org.jgroups.annotations.Unsupported;
+import org.jgroups.util.Util;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
@@ -17,7 +18,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
-import static java.lang.String.valueOf;
 import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
 import java.net.URL;
@@ -27,14 +27,15 @@
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.*;
-import java.util.UUID;
+
+import static java.lang.String.valueOf;
 
 
 /**
  * Discovery protocol using Amazon's S3 storage. The S3 access code reuses the example shipped by Amazon.
  * This protocol is unsupported and experimental !
  * @author Bela Ban
- * @version $Id: S3_PING.java,v 1.5 2010/06/16 08:48:32 belaban Exp $
+ * @version $Id: S3_PING.java,v 1.6 2010/06/16 11:21:38 belaban Exp $
  */
 @Experimental @Unsupported
 public class S3_PING extends FILE_PING {
@@ -47,8 +48,6 @@ public class S3_PING extends FILE_PING {
 
     protected AWSAuthConnection conn=null;
 
-    protected final Set<Entry> keys=new HashSet<Entry>();
-
 
   
     public void init() throws Exception {
@@ -63,36 +62,11 @@ public void init() throws Exception {
 
         Runtime.getRuntime().addShutdownHook(new Thread() {
             public void run() {
-                Set<Entry> copy;
-                synchronized(keys) {
-                    copy=new HashSet<Entry>(keys);
-                    keys.clear();
-                }
-
-                for(Entry entry : copy) {
-                    remove(entry.cluster, entry.data);
-                }
+                remove(group_addr, local_addr);
             }
         });
     }
 
-    public void stop() {
-        if(group_addr != null && local_addr != null) {
-            // remove from keys:
-            synchronized(keys) {
-                for(Iterator<Entry> it=keys.iterator(); it.hasNext();) {
-                    Entry entry=it.next();
-                    if(group_addr.equals(entry.cluster) && local_addr.equals(entry.data.getAddress())) {
-                        it.remove();
-                    }
-                }
-            }
-
-            PingData data=new PingData(local_addr, null, false, org.jgroups.util.UUID.get(local_addr), null);
-            remove(group_addr, data);
-        }
-        super.stop();
-    }
 
 
     protected List<PingData> readAll(String clustername) {
@@ -140,46 +114,35 @@ protected void writeToFile(PingData data, String clustername) {
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
             byte[] buf=Util.objectToByteBuffer(data);
             S3Object val=new S3Object(buf, null);
-            String response=conn.put(location, key, val, headers).connection.getResponseMessage();
-            if(log.isTraceEnabled())
-                log.trace(""response: "" + response);
-            synchronized(keys) {
-                keys.add(new Entry(clustername, data));
-            }
+            conn.put(location, key, val, headers).connection.getResponseMessage();
         }
         catch(Exception e) {
             log.error(""failed marshalling "" + data + "" to buffer"", e);
         }
     }
 
 
-    protected void remove(String clustername, PingData data) {
-        if(clustername == null || data == null)
+    protected void remove(String clustername, Address addr) {
+        if(clustername == null || addr == null)
             return;
-        String filename=local_addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)local_addr).toStringLong() : local_addr.toString();
+        String filename=addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)addr).toStringLong() : addr.toString();
         String key=clustername + ""/"" + filename;
         try {
             Map headers=new TreeMap();
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
-            String response=conn.delete(location, key, headers).connection.getResponseMessage();
+            conn.delete(location, key, headers).connection.getResponseMessage();
             if(log.isTraceEnabled())
-                log.trace(""response: "" + response);
+                log.trace(""removing "" + location + ""/"" + key);
         }
         catch(Exception e) {
-            log.error(""failed marshalling "" + data + "" to buffer"", e);
+            log.error(""failure removing data"", e);
         }
     }
 
 
-    private static class Entry {
-        final String cluster;
-        final PingData data;
 
-        Entry(String cluster, PingData data) {
-            this.cluster=cluster;
-            this.data=data;
-        }
-    }
+
+    
 
 
     /**",2010-06-16T11:21:38Z,109
"@@ -89,7 +89,7 @@ private static <T> Iterator<T> getFactories(Class<T> type, ClassLoader classLoad
 
             Provider[] providers = Security.getProviders();
             for (Provider currentProvider : providers) {
-                final ClassLoader cl = currentProvider.getClass().getClassLoader();
+                final ClassLoader cl = Thread.currentThread().getContextClassLoader();
                 for (Object currentKey : currentProvider.keySet()) {
                     if (currentKey instanceof String && ((String) currentKey).startsWith(filter)
                             && ((String) currentKey).indexOf(' ') < 0) {
@@ -111,7 +111,7 @@ private static <T> Iterator<T> getFactories(Class<T> type, ClassLoader classLoad
     }
 
     public static SaslServerFactory getSaslServerFactory(String mech, Map<String, ?> props) {
-        Iterator<SaslServerFactory> saslFactories = SaslUtils.getSaslServerFactories(SaslUtils.class.getClassLoader(), true);
+        Iterator<SaslServerFactory> saslFactories = SaslUtils.getSaslServerFactories(Thread.currentThread().getContextClassLoader(), true);
         while (saslFactories.hasNext()) {
             SaslServerFactory saslFactory = saslFactories.next();
             for (String supportedMech : saslFactory.getMechanismNames(props)) {
@@ -124,7 +124,7 @@ public static SaslServerFactory getSaslServerFactory(String mech, Map<String, ?>
     }
 
     public static SaslClientFactory getSaslClientFactory(String mech, Map<String, ?> props) {
-        Iterator<SaslClientFactory> saslFactories = SaslUtils.getSaslClientFactories(SaslUtils.class.getClassLoader(), true);
+        Iterator<SaslClientFactory> saslFactories = SaslUtils.getSaslClientFactories(Thread.currentThread().getContextClassLoader(), true);
         while (saslFactories.hasNext()) {
             SaslClientFactory saslFactory = saslFactories.next();
             for (String supportedMech : saslFactory.getMechanismNames(props)) {",2016-01-12T23:03:14Z,112
"@@ -168,7 +168,7 @@ public static Class<?> get(short magic) {
      * @return a Class object that represents a class that implements java.io.Externalizable
      */
     public static Class get(String clazzname, ClassLoader loader) throws ClassNotFoundException {
-        return Util.loadClass(clazzname, loader != null? loader : ClassConfigurator.class.getClassLoader());
+        return Util.loadClass(clazzname, loader != null? loader : Thread.currentThread().getContextClassLoader());
     }
 
     public static Class get(String clazzname) throws ClassNotFoundException {",2016-01-12T23:03:14Z,113
"@@ -47,11 +47,11 @@ public ProtocolConfiguration(String config_str) throws Exception {
             }
         }
         parsePropertiesString(properties);
-        this.loader = ProtocolConfiguration.class.getClassLoader();
+        this.loader = Thread.currentThread().getContextClassLoader();
     }
 
     public ProtocolConfiguration(String protocol_name, Map<String,String> properties) {
-        this(protocol_name, properties, ProtocolConfiguration.class.getClassLoader());
+        this(protocol_name, properties, Thread.currentThread().getContextClassLoader());
     }
 
     public ProtocolConfiguration(String protocol_name, Map<String,String> properties, ClassLoader loader) {",2016-01-12T23:03:14Z,114
"@@ -179,7 +179,7 @@ private static InputStream getAsInputStreamFromClassLoader(String filename) {
         InputStream is = cl == null ? null : cl.getResourceAsStream(filename);
         if (is == null) {
             // check system class loader
-            is = XmlConfigurator.class.getClassLoader().getResourceAsStream(filename);
+            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(filename);
         }
         return is;
     }",2016-01-12T23:03:14Z,30
"@@ -101,7 +101,7 @@ public enum AddressScope {GLOBAL,SITE_LOCAL,LINK_LOCAL,LOOPBACK,NON_LOOPBACK}
 
 
     static {
-        resource_bundle=ResourceBundle.getBundle(""jg-messages"",Locale.getDefault(),Util.class.getClassLoader());
+        resource_bundle=ResourceBundle.getBundle(""jg-messages"",Locale.getDefault(),Thread.currentThread().getContextClassLoader());
 
         /* Trying to get value of resolve_dns. PropertyPermission not granted if
         * running in an untrusted environment with JNLP */",2016-01-12T23:03:14Z,54
"@@ -0,0 +1,13 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+
+/**
+ * FileObserver. A callback that is invoked when a file is changed. {@link FileWatchTask}
+ *
+ * @author Tristan Tarrant
+ * @since 8.0
+ */
+public interface FileObserver {
+   void fileChanged(File file);
+}",2015-05-26T06:22:12Z,115
"@@ -0,0 +1,35 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+import java.util.TimerTask;
+
+/**
+ * FileWatchTask. Polls a file for modifications and invokes a provided {@link FileObserver}
+ *
+ * @author Tristan Tarrant
+ * @since 8.0
+ */
+public class FileWatchTask extends TimerTask {
+   private final File file;
+   private long modified;
+   private final FileObserver observer;
+
+   public FileWatchTask(File file, FileObserver observer) {
+      if (!file.exists()) {
+         throw new IllegalArgumentException(""File '"" + file + ""' does not exist"");
+      }
+      this.file = file;
+      this.modified = file.lastModified();
+      this.observer = observer;
+   }
+
+   @Override
+   public void run() {
+      long modified = file.lastModified();
+      if (this.modified != modified) {
+         this.modified = modified;
+         observer.fileChanged(file);
+      }
+   }
+
+}",2015-05-26T06:22:12Z,116
"@@ -7,6 +7,7 @@
 import javax.security.auth.callback.NameCallback;
 import javax.security.auth.callback.PasswordCallback;
 import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.RealmCallback;
 
 /**
  * SaslClientCallbackHandler.
@@ -17,9 +18,12 @@ public class SaslClientCallbackHandler implements CallbackHandler {
 
     private final String name;
     private final char[] password;
+    private final String realm;
 
     public SaslClientCallbackHandler(String name, char[] password) {
-        this.name = name;
+        int realmSep = name.indexOf('@');
+        this.realm = realmSep < 0 ? """" : name.substring(realmSep+1);
+        this.name = realmSep < 0 ? name : name.substring(0, realmSep);
         this.password = password;
     }
 
@@ -28,6 +32,8 @@ public void handle(Callback[] callbacks) throws IOException, UnsupportedCallback
         for (Callback callback : callbacks) {
             if (callback instanceof PasswordCallback) {
                 ((PasswordCallback) callback).setPassword(password);
+            } else if (callback instanceof RealmCallback) {
+                ((RealmCallback) callback).setText(realm);
             } else if (callback instanceof NameCallback) {
                 ((NameCallback) callback).setName(name);
             }",2015-05-26T06:22:12Z,117
"@@ -0,0 +1,42 @@
+package org.jgroups.auth.sasl;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Properties;
+
+/**
+ * SecurityActions for the org.jgroups.auth.sasl package.
+ *
+ * Do not move. Do not change class and method visibility to avoid being called from other
+ * {@link java.security.CodeSource}s, thus granting privilege escalation to external code.
+ *
+ * @author Tristan Tarrant
+ * @since 3.6
+ */
+final class SecurityActions {
+   private static <T> T doPrivileged(PrivilegedAction<T> action) {
+      if (System.getSecurityManager() != null) {
+         return AccessController.doPrivileged(action);
+      } else {
+         return action.run();
+      }
+   }
+
+   static String getSystemProperty(final String name) {
+      return doPrivileged(new PrivilegedAction<String>() {
+         @Override
+         public String run() {
+            return System.getProperty(name);
+         }
+      });
+   }
+
+   public static Properties getSystemProperties() {
+      return doPrivileged(new PrivilegedAction<Properties>() {
+         @Override
+         public Properties run() {
+            return System.getProperties();
+         }
+      });
+   }
+}",2015-05-26T06:22:12Z,118
"@@ -0,0 +1,186 @@
+package org.jgroups.auth.sasl;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Properties;
+import java.util.Timer;
+import java.util.concurrent.TimeUnit;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.util.Util;
+
+/**
+ * SimpleAuthorizingCallbackHandler. This class implements a simple callback handler which can be
+ * used to configure cluster authentication for the JGroups transport. It is configured via system
+ * properties. The following properties are available:
+ *
+ * <ul>
+ * <li>sasl.credentials.properties - the path to a property file which contains principal/credential
+ * mappings represented as principal=password</li>
+ * <li>sasl.local.principal - the name of the principal that is used to identify the local node. It
+ * must exist in the sasl.credentials.properties file</li>
+ * <li>sasl.roles.properties - (optional) the path to a property file which contains principal/roles
+ * mappings represented as principal=role1,role2,role3</li>
+ * <li>sasl.role - (optional) if present, authorizes joining nodes only if their principal is
+ * <li>sasl.realm - (optional) the name of the realm to use for the SASL mechanisms that require it
+ * </li>
+ * </ul>
+ *
+ * @author Tristan Tarrant
+ * @since 3.6
+ */
+public class SimpleAuthorizingCallbackHandler implements CallbackHandler {
+    private static final Log log = LogFactory.getLog(SimpleAuthorizingCallbackHandler.class);
+    private final Properties credentials;
+    private final Properties roles;
+    private final Timer timer;
+    private final String localPrincipal;
+    private final String role;
+    private final String realm;
+
+    public SimpleAuthorizingCallbackHandler() {
+        this(SecurityActions.getSystemProperties());
+    }
+
+    public SimpleAuthorizingCallbackHandler(Properties properties) {
+        this.credentials = new Properties();
+        this.roles = new Properties();
+
+        localPrincipal = requireProperty(properties, ""sasl.local.principal"");
+        String credentialsFile = requireProperty(properties, ""sasl.credentials.properties"");
+        timer = new Timer();
+        File fCredentials = new File(credentialsFile);
+        timer.scheduleAtFixedRate(
+                new FileWatchTask(fCredentials, new PropertiesReloadFileObserver(fCredentials, credentials)), 0,
+                TimeUnit.SECONDS.toMillis(10));
+        role = properties.getProperty(""sasl.role"");
+        String rolesFile = properties.getProperty(""sasl.roles.properties"");
+        if (role != null) {
+            if (rolesFile == null) {
+                throw new IllegalStateException(
+                        ""To enable role authorization, both sasl.role and sasl.roles.properties system properties must be set"");
+            } else {
+                File fRoles = new File(rolesFile);
+                timer.scheduleAtFixedRate(
+                        new FileWatchTask(fRoles, new PropertiesReloadFileObserver(fRoles, roles)), 0,
+                        TimeUnit.SECONDS.toMillis(10));
+            }
+        }
+        realm = properties.getProperty(""sasl.realm"");
+    }
+
+    private String requireProperty(Properties properties, String propertyName) {
+        String value = properties.getProperty(propertyName);
+        if (value == null) {
+            throw new IllegalStateException(""The required system property "" + propertyName + "" has not been set"");
+        } else {
+            return value;
+        }
+    }
+
+    @Override
+    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+        List<Callback> responseCallbacks = new LinkedList<>();
+
+        String remotePrincipal = null;
+        boolean remotePrincipalFound = false;
+
+        for (Callback current : callbacks) {
+            if (current instanceof AuthorizeCallback) {
+                responseCallbacks.add(current);
+            } else if (current instanceof NameCallback) {
+                NameCallback nameCallback = (NameCallback) current;
+                remotePrincipal = nameCallback.getDefaultName();
+                if (remotePrincipal != null) { // server
+                    remotePrincipalFound = credentials.containsKey(remotePrincipal);
+                } else { // client, we need to respond
+                    responseCallbacks.add(current);
+                }
+            } else if (current instanceof PasswordCallback) {
+                responseCallbacks.add(current);
+            } else if (current instanceof RealmCallback) {
+                String realm = ((RealmCallback) current).getDefaultText();
+                if (realm != null) {
+                    if (this.realm.equals(realm) == false) {
+                        throw new IOException(""Invalid realm "" + realm);
+                    }
+                }
+                responseCallbacks.add(current);
+            } else {
+                throw new UnsupportedCallbackException(current);
+            }
+        }
+
+        for (Callback current : responseCallbacks) {
+            if (current instanceof NameCallback) {
+                ((NameCallback) current).setName(localPrincipal);
+            } else if (current instanceof AuthorizeCallback) {
+                AuthorizeCallback acb = (AuthorizeCallback) current;
+                String authenticationId = acb.getAuthenticationID();
+                String authorizationId = acb.getAuthorizationID();
+                acb.setAuthorized(authenticationId.equals(authorizationId));
+                if (role != null) {
+                    String principalRoleNames = roles.getProperty(acb.getAuthorizationID());
+                    List<String> principalRoles = (List<String>) (principalRoleNames != null
+                            ? Arrays.asList(principalRoleNames.split(""\\s*,\\s*"")) : Collections.emptyList());
+                    if (!principalRoles.contains(role)) {
+                        throw new IOException(""Unauthorized user "" + authorizationId);
+                    }
+                }
+            } else if (current instanceof PasswordCallback) {
+                String password;
+                if (remotePrincipal == null) { // client, send our password
+                    password = credentials.getProperty(localPrincipal);
+                } else if (remotePrincipalFound) { // server, validate incoming password
+                    password = credentials.getProperty(remotePrincipal);
+                } else {
+                    throw new IOException(""Unauthorized user "" + remotePrincipal);
+                }
+                ((PasswordCallback) current).setPassword(password.toCharArray());
+            } else if (current instanceof RealmCallback) {
+                ((RealmCallback)current).setText(realm);
+            }
+        }
+    }
+
+    public static class PropertiesReloadFileObserver implements FileObserver {
+
+        private final Properties properties;
+
+        PropertiesReloadFileObserver(File file, Properties properties) {
+            this.properties = properties;
+            loadProperties(file);
+        }
+
+        private void loadProperties(File file) {
+            FileInputStream fis = null;
+            try {
+                fis = new FileInputStream(file);
+                properties.load(fis);
+            } catch (IOException e) {
+                log.error(""An error occurred while loading properties from "" + file, e);
+            } finally {
+                Util.close(fis);
+            }
+        }
+
+        @Override
+        public void fileChanged(File file) {
+            loadProperties(file);
+        }
+    }
+}",2015-05-26T06:22:12Z,119
"@@ -0,0 +1,89 @@
+package org.jgroups.protocols;
+
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Properties;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.auth.sasl.SimpleAuthorizingCallbackHandler;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+@Test(groups = Global.FUNCTIONAL, singleThreaded = true)
+public class SASL_SimpleAuthorizingCallbackTest {
+    private static final String REALM = ""MyRealm"";
+    private JChannel a;
+    private JChannel b;
+    File credentialsFile;
+    File rolesFile;
+
+    @BeforeClass
+    public void initialize() throws Exception {
+        Properties credentials = new Properties();
+        credentials.put(""jack"", ""brokehiscrown"");
+        credentials.put(""jill"", ""cametumblingafter"");
+        credentials.put(""jane"", ""whatsyourname"");
+        credentialsFile = File.createTempFile(""sasl_credentials"", "".properties"");
+        credentials.store(new FileOutputStream(credentialsFile), null);
+
+        Properties roles = new Properties();
+        roles.put(""jack"", ""mycluster"");
+        roles.put(""jill"", ""mycluster"");
+        roles.put(""jane"", ""othercluster"");
+        rolesFile = File.createTempFile(""sasl_roles"", "".properties"");
+        roles.store(new FileOutputStream(rolesFile), null);
+    }
+
+    private JChannel createChannel(String channelName, String mech, String principal) throws Exception {
+        Properties properties = new Properties();
+        properties.put(""sasl.local.principal"", principal);
+        properties.put(""sasl.credentials.properties"", credentialsFile.getAbsolutePath());
+        properties.put(""sasl.role"", ""mycluster"");
+        properties.put(""sasl.roles.properties"", rolesFile.getAbsolutePath());
+        properties.put(""sasl.realm"", REALM);
+        SASL sasl = new SASL();
+        sasl.setMech(mech);
+        sasl.setClientCallbackHandler(new SimpleAuthorizingCallbackHandler(properties));
+        sasl.setServerCallbackHandler(new SimpleAuthorizingCallbackHandler(properties));
+        sasl.setTimeout(5000);
+        sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
+        return new JChannel(new Protocol[] { new SHARED_LOOPBACK(), new PING(), new NAKACK2(), new UNICAST3(),
+                new STABLE(), sasl, new GMS() }).name(channelName);
+    }
+
+    public void testSASLDigestMD5() throws Exception {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jill"");
+        a.connect(""SaslTest"");
+        b.connect(""SaslTest"");
+        assertTrue(b.isConnected());
+    }
+
+    @Test(expectedExceptions = SecurityException.class)
+    public void testSASLDigestMD5Failure() throws Throwable {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jane"");
+        a.connect(""SaslTest"");
+        try {
+            b.connect(""SaslTest"");
+        } catch (Exception e) {
+            if (e.getCause() != null)
+                throw e.getCause();
+        }
+    }
+
+    @AfterMethod
+    public void cleanup() {
+        a.close();
+        b.close();
+    }
+}",2015-05-26T06:22:12Z,120
"@@ -158,7 +158,7 @@ public static String type2String(int t) {
 
     public String toString() {
         StringBuilder ret=new StringBuilder(64);
-        ret.append(""Event[type="" + type2String(type) + "", arg="" + arg + ']');
+        ret.append(type2String(type)).append("", arg="").append(arg);
         if(type == MSG)
             ret.append("" (headers="").append(((Message)arg).printHeaders()).append("")"");
         return ret.toString();",2014-01-10T16:46:08Z,121
"@@ -1578,21 +1578,27 @@ else if(internal)
     }
 
     /**
-     * Removes messages with flag DONT_BUNDLE set and executes them in the oob or internal thread pool. JGRP-1737
+     * Removes messages with flags DONT_BUNDLE and OOB set and executes them in the oob or internal thread pool. JGRP-1737
      */
     protected void removeAndDispatchNonBundledMessages(MessageBatch ... oob_batches) {
         for(MessageBatch oob_batch: oob_batches) {
             if(oob_batch == null)
                 continue;
 
             for(Message msg: oob_batch) {
-                if(msg.isFlagSet(Message.Flag.DONT_BUNDLE)) {
+                if(msg.isFlagSet(Message.Flag.DONT_BUNDLE) && msg.isFlagSet(Message.Flag.OOB)) {
                     boolean oob=msg.isFlagSet(Message.Flag.OOB), internal=msg.isFlagSet(Message.Flag.INTERNAL);
                     msg.putHeader(id, new TpHeader(oob_batch.clusterName()));
                     Executor pool=pickThreadPool(oob, internal);
-                    pool.execute(new SingleMessageHandler(msg));
-                    oob_batch.remove(msg);
-                    num_oob_msgs_received++;
+                    try {
+                        pool.execute(new SingleMessageHandler(msg));
+                        oob_batch.remove(msg);
+                        num_oob_msgs_received++;
+                    }
+                    catch(Throwable t) {
+                        log.error(""%s: failed submitting DONT_BUNDLE message to thread pool: %s. Msg: %s"",
+                                  local_addr, t, msg.printHeaders());
+                    }
                 }
             }
         }",2014-01-10T16:46:08Z,85
"@@ -12,6 +12,7 @@
 import java.io.DataOutput;
 import java.util.*;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -26,7 +27,7 @@
  */
 @MBean(description=""Reliable unicast layer"")
 public class UNICAST3 extends Protocol implements AgeOutCache.Handler<Address> {
-    public static final long DEFAULT_FIRST_SEQNO=Global.DEFAULT_FIRST_UNICAST_SEQNO;
+    protected static final long DEFAULT_FIRST_SEQNO=Global.DEFAULT_FIRST_UNICAST_SEQNO;
 
 
     /* ------------------------------------------ Properties  ------------------------------------------ */
@@ -95,27 +96,31 @@ public class UNICAST3 extends Protocol implements AgeOutCache.Handler<Address> {
     protected final ConcurrentMap<Address, SenderEntry>   send_table=Util.createConcurrentMap();
     protected final ConcurrentMap<Address, ReceiverEntry> recv_table=Util.createConcurrentMap();
 
-    protected final ReentrantLock      recv_table_lock=new ReentrantLock();
+    protected final ReentrantLock          recv_table_lock=new ReentrantLock();
 
     /** Used by the retransmit task to keep the last retransmitted seqno per sender (https://issues.jboss.org/browse/JGRP-1539) */
-    protected final Map<Address,Long>  xmit_task_map=new HashMap<Address,Long>();
+    protected final Map<Address,Long>      xmit_task_map=new HashMap<Address,Long>();
 
     /** RetransmitTask running every xmit_interval ms */
-    protected Future<?>                xmit_task;
+    protected Future<?>                    xmit_task;
 
-    protected volatile List<Address>   members=new ArrayList<Address>(11);
+    protected volatile List<Address>       members=new ArrayList<Address>(11);
 
-    protected Address                  local_addr;
+    protected Address                      local_addr;
 
-    protected TimeScheduler            timer; // used for retransmissions (passed to AckSenderWindow)
+    protected TimeScheduler                timer; // used for retransmissions
 
-    protected volatile boolean         running=false;
+    protected volatile boolean             running=false;
 
-    protected short                    last_conn_id;
+    protected short                        last_conn_id;
 
-    protected AgeOutCache<Address>     cache;
+    protected AgeOutCache<Address>         cache;
 
+    protected static final Message         DUMMY_OOB_MSG=new Message(false).setFlag(Message.Flag.OOB);
 
+    protected static final Filter<Message> drop_oob_msgs_filter=new Filter<Message>() {
+        public boolean accept(Message msg) {return msg != null && msg.hashCode() != DUMMY_OOB_MSG.hashCode();}
+    };
 
 
     public void setMaxMessageBatchSize(int size) {
@@ -663,7 +668,7 @@ public void expired(Address key) {
      * e.received_msgs is null and <code>first</code> is true: create a new AckReceiverWindow(seqno) and
      * add message. Set e.received_msgs to the new window. Else just add the message.
      */
-    protected void handleDataReceived(Address sender, long seqno, short conn_id,  boolean first, final Message msg, Event evt) {
+    protected void handleDataReceived(final Address sender, long seqno, short conn_id,  boolean first, final Message msg, Event evt) {
         if(log.isTraceEnabled())
             log.trace(""%s <-- DATA(%s: #%d, conn_id=%d%s)"", local_addr, sender, seqno, conn_id, first? "", first"" : """");
 
@@ -675,10 +680,8 @@ protected void handleDataReceived(Address sender, long seqno, short conn_id,  bo
         if(entry.state() == State.CLOSING)
             entry.state(State.OPEN);
         boolean oob=msg.isFlagSet(Message.Flag.OOB);
-        if(oob) // done so this thread delivers the message and no work stealing for OOB msgs is performed (JGRP-1733)
-            msg.setTransientFlag(Message.TransientFlag.OOB_DELIVERED);
-        Table<Message> win=entry.received_msgs;
-        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here
+        final Table<Message> win=entry.received_msgs;
+        boolean added=win.add(seqno, oob? DUMMY_OOB_MSG : msg); // adding the same dummy OOB msg saves space (we won't remove it)
         num_msgs_received++;
 
         if(ack_threshold <= 1)
@@ -688,21 +691,25 @@ protected void handleDataReceived(Address sender, long seqno, short conn_id,  bo
 
         // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !
         // http://jira.jboss.com/jira/browse/JGRP-377
-        if(oob && added) {
-            if(log.isTraceEnabled())
-                log.trace(""%s: delivering %s#%s"", local_addr, sender, seqno);
-            try {
-                up_prot.up(evt);
-            }
-            catch(Throwable t) {
-                log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-            }
-        }
+        if(oob && added)
+            deliverMessage(evt, sender, seqno);
 
         // we don't steal work if the message is internal (https://issues.jboss.org/browse/JGRP-1733)
         // we also don't care if the message was added successfully or not
-        if(oob && msg.isFlagSet(Message.Flag.INTERNAL))
+        if(oob && msg.isFlagSet(Message.Flag.INTERNAL)) {
+            // If there are other msgs, tell the regular thread pool to handle them (https://issues.jboss.org/browse/JGRP-1732)
+            final AtomicBoolean processing=win.getProcessing();
+            if(!win.isEmpty() && !processing.get() && seqno < win.getHighestReceived()) {
+                Executor pool=getTransport().getDefaultThreadPool();
+                pool.execute(new Runnable() {
+                    public void run() {
+                        if(processing.compareAndSet(false, true))
+                            removeAndDeliver(processing, win, sender);
+                    }
+                });
+            }
             return;
+        }
 
         final AtomicBoolean processing=win.getProcessing();
         if(processing.compareAndSet(false, true))
@@ -718,7 +725,9 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
         int batch_size=msgs.size();
         Table<Message> win=entry.received_msgs;
         num_msgs_received+=batch_size;
-        boolean added=oob ? win.add(msgs, true) : win.add(msgs);
+
+        // adds all messages to the table, removing messages from 'msgs' which could not be added (already present)
+        boolean added=win.add(msgs, oob, oob? DUMMY_OOB_MSG : null);
 
         if(conn_expiry_timeout > 0)
             entry.update();
@@ -732,20 +741,11 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
 
         // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379
         if(added && oob) {
-            for(Tuple<Long,Message> tuple: msgs) {
-                long    seq=tuple.getVal1();
-                Message msg=tuple.getVal2();
-                if(msg.isFlagSet(Message.Flag.OOB) && msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED)) {
-                    if(log.isTraceEnabled())
-                        log.trace(""%s: delivering %s#%s"", local_addr, sender, seq);
-                    try {
-                        up_prot.up(new Event(Event.MSG, msg));
-                    }
-                    catch(Throwable t) {
-                        log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-                    }
-                }
-            }
+            MessageBatch oob_batch=new MessageBatch(local_addr, sender, null, false, MessageBatch.Mode.OOB, msgs.size());
+            for(Tuple<Long,Message> tuple: msgs)
+                oob_batch.add(tuple.getVal2());
+
+            deliverBatch(oob_batch);
         }
 
         final AtomicBoolean processing=win.getProcessing();
@@ -763,47 +763,22 @@ protected void handleBatchReceived(final ReceiverEntry entry, Address sender, Li
      * delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered in the
      * order in which they were sent
      */
-    protected int removeAndDeliver(final AtomicBoolean processing, Table<Message> win, Address sender) {
-        int retval=0;
+    protected void removeAndDeliver(final AtomicBoolean processing, Table<Message> win, Address sender) {
         boolean released_processing=false;
         try {
             while(true) {
-                List<Message> list=win.removeMany(processing, true, max_msg_batch_size);
-                if(list == null) {
+                List<Message> list=win.removeMany(processing, true, max_msg_batch_size, drop_oob_msgs_filter);
+                if(list != null) // list is guaranteed to NOT contain any OOB messages as the drop_oob_msgs_filter removed them
+                    deliverBatch(new MessageBatch(local_addr, sender, null, false, list));
+                else {
                     released_processing=true;
-                    return retval;
-                }
-
-                MessageBatch batch=new MessageBatch(local_addr, sender, null, false, list);
-                for(Message msg_to_deliver: batch) {
-                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)
-                    if(msg_to_deliver.isFlagSet(Message.Flag.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
-                        batch.remove(msg_to_deliver);
-                }
-                if(batch.isEmpty())
-                    continue;
-
-                try {
-                    if(log.isTraceEnabled()) {
-                        Message first=batch.first(), last=batch.last();
-                        StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
-                        if(first != null && last != null) {
-                            Header hdr1=(Header)first.getHeader(id), hdr2=(Header)last.getHeader(id);
-                            sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
-                        }
-                        sb.append("" ("" + batch.size()).append("" messages)"");
-                        log.trace(sb);
-                    }
-                    up_prot.up(batch);
-                }
-                catch(Throwable t) {
-                    log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+                    return;
                 }
             }
         }
         finally {
             // processing is always set in win.remove(processing) above and never here ! This code is just a
-            // 2nd line of defense should there be an exception before win.remove(processing) sets processing
+            // 2nd line of defense should there be an exception before win.removeMany(processing) sets processing
             if(!released_processing)
                 processing.set(false);
         }
@@ -944,6 +919,40 @@ protected void handleXmitRequest(Address sender, SeqnoList missing) {
         }
     }
 
+    protected void deliverMessage(final Event evt, final Address sender, final long seqno) {
+        if(log.isTraceEnabled())
+            log.trace(""%s: delivering %s#%s"", local_addr, sender, seqno);
+        try {
+            up_prot.up(evt);
+        }
+        catch(Throwable t) {
+            Message msg=(Message)evt.getArg();
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, msg.isFlagSet(Message.Flag.OOB) ?
+              ""OOB message"" : ""message"", msg, t);
+        }
+    }
+
+    protected void deliverBatch(MessageBatch batch) {
+        try {
+            if(batch.isEmpty())
+                return;
+            if(log.isTraceEnabled()) {
+                Message first=batch.first(), last=batch.last();
+                StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
+                if(first != null && last != null) {
+                    Header hdr1=(Header)first.getHeader(id), hdr2=(Header)last.getHeader(id);
+                    sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
+                }
+                sb.append("" ("" + batch.size()).append("" messages)"");
+                log.trace(sb);
+            }
+            up_prot.up(batch);
+        }
+        catch(Throwable t) {
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+        }
+    }
+
 
 
     protected void startRetransmitTask() {",2014-01-10T16:46:08Z,122
"@@ -652,7 +652,7 @@ public void up(MessageBatch batch) {
 
         // Process (new and retransmitted) messages:
         if(msgs != null)
-            handleMessages(batch.sender(), msgs, batch.mode() == MessageBatch.Mode.OOB, batch.clusterName());
+            handleMessages(batch.dest(), batch.sender(), msgs, batch.mode() == MessageBatch.Mode.OOB, batch.clusterName());
 
         // received XMIT-RSPs:
         if(got_retransmitted_msg && rebroadcasting)
@@ -784,7 +784,7 @@ protected void handleMessage(Message msg, NakAckHeader2 hdr) {
     }
 
 
-    protected void handleMessages(Address sender, List<Tuple<Long,Message>> msgs, boolean oob, String cluster_name) {
+    protected void handleMessages(Address dest, Address sender, List<Tuple<Long,Message>> msgs, boolean oob, String cluster_name) {
         Table<Message> buf=xmit_table.get(sender);
         if(buf == null) {  // discard message if there is no entry for sender
             if(leaving)
@@ -810,22 +810,14 @@ protected void handleMessages(Address sender, List<Tuple<Long,Message>> msgs, bo
 
         // OOB msg is passed up. When removed, we discard it. Affects ordering: http://jira.jboss.com/jira/browse/JGRP-379
         if(added && oob) {
+            MessageBatch oob_batch=new MessageBatch(dest, sender, null, dest == null, MessageBatch.Mode.OOB, msgs.size());
             for(Tuple<Long,Message> tuple: msgs) {
                 long    seq=tuple.getVal1();
                 Message msg=loopback? buf.get(seq) : tuple.getVal2(); // we *have* to get the message, because loopback means we didn't add it to win !
-                if(msg != null && msg.isFlagSet(Message.Flag.OOB)) {
-                    if(msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED)) {
-                        if(log.isTraceEnabled())
-                            log.trace(""%s: delivering %s#%d"", local_addr, sender, seq);
-                        try {
-                            up_prot.up(new Event(Event.MSG, msg));
-                        }
-                        catch(Throwable t) {
-                            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""OOB message"", msg, t);
-                        }
-                    }
-                }
+                if(msg != null && msg.isFlagSet(Message.Flag.OOB) && msg.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
+                    oob_batch.add(msg);
             }
+            deliverBatch(oob_batch);
         }
 
         removeAndPassUp(buf,sender,loopback,cluster_name); // at most 1 thread will execute this at any given time
@@ -859,25 +851,7 @@ protected void removeAndPassUp(Table<Message> buf, Address sender, boolean loopb
                     if(msg_to_deliver.isFlagSet(Message.Flag.OOB) && !msg_to_deliver.setTransientFlagIfAbsent(Message.TransientFlag.OOB_DELIVERED))
                         batch.remove(msg_to_deliver);
                 }
-                if(batch.isEmpty())
-                    continue;
-
-                try {
-                    if(log.isTraceEnabled()) {
-                        Message first=batch.first(), last=batch.last();
-                        StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
-                        if(first != null && last != null) {
-                            NakAckHeader2 hdr1=(NakAckHeader2)first.getHeader(id), hdr2=(NakAckHeader2)last.getHeader(id);
-                            sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
-                        }
-                        sb.append("" ("" + batch.size()).append("" messages)"");
-                        log.trace(sb);
-                    }
-                    up_prot.up(batch);
-                }
-                catch(Throwable t) {
-                    log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
-                }
+                deliverBatch(batch);
             }
         }
         finally {
@@ -922,6 +896,27 @@ protected void handleXmitReq(Address xmit_requester, SeqnoList missing_msgs, Add
         }
     }
 
+    protected void deliverBatch(MessageBatch batch) {
+        try {
+            if(batch.isEmpty())
+                return;
+            if(log.isTraceEnabled()) {
+                Message first=batch.first(), last=batch.last();
+                StringBuilder sb=new StringBuilder(local_addr + "": delivering"");
+                if(first != null && last != null) {
+                    NakAckHeader2 hdr1=(NakAckHeader2)first.getHeader(id), hdr2=(NakAckHeader2)last.getHeader(id);
+                    sb.append("" #"").append(hdr1.seqno).append("" - #"").append(hdr2.seqno);
+                }
+                sb.append("" ("" + batch.size()).append("" messages)"");
+                log.trace(sb);
+            }
+            up_prot.up(batch);
+        }
+        catch(Throwable t) {
+            log.error(Util.getMessage(""FailedToDeliverMsg""), local_addr, ""batch"", batch, t);
+        }
+    }
+
 
     /**
      * Flushes the queue. Done in a separate thread as we don't want to block the",2014-01-10T16:46:08Z,123
"@@ -52,5 +52,7 @@ public void clear() {
             samples[i]=-1;
     }
 
-
+    public String toString() {
+        return String.valueOf(getAverage());
+    }
 }",2014-01-10T16:46:08Z,124
"@@ -0,0 +1,9 @@
+package org.jgroups.util;
+
+/**
+ * @author Bela Ban
+ * @since  3.5
+ */
+public interface Filter<T> {
+    boolean accept(T element);
+}",2014-01-10T16:46:08Z,125
"@@ -92,6 +92,7 @@ public MessageBatch(Address dest, Address sender, String cluster_name, boolean m
     public MessageBatch clusterName(String name) {this.cluster_name=name; return this;}
     public boolean      multicast()              {return multicast;}
     public Mode         mode()                   {return mode;}
+    public MessageBatch mode(Mode mode)          {this.mode=mode; return this;}
     public int          capacity()               {return messages.length;}
 
 
@@ -250,6 +251,17 @@ public String toString() {
         return sb.toString();
     }
 
+    public String printHeaders() {
+        StringBuilder sb=new StringBuilder().append(""dest="" + dest);
+        if(sender != null)
+            sb.append("", sender="").append(sender);
+        sb.append(""\n"").append(size()).append("":\n"");
+        int count=1;
+        for(Message msg: this)
+            sb.append(""#"").append(count++).append("": "").append(msg.printHeaders()).append(""\n"");
+        return sb.toString();
+    }
+
     protected void resize() {
         Message[] tmp=new Message[messages.length + INCR];
         System.arraycopy(messages,0,tmp,0,messages.length);",2014-01-10T16:46:08Z,126
"@@ -106,7 +106,7 @@ public Table(int num_rows, int elements_per_row, long offset, double resize_fact
     /**
      * Creates a new table
      * @param num_rows the number of rows in the matrix
-     * @param elements_per_row the number of messages per row
+     * @param elements_per_row the number of elements per row
      * @param offset the seqno before the first seqno to be inserted. E.g. if 0 then the first seqno will be 1
      * @param resize_factor teh factor with which to increase the number of rows
      * @param max_compaction_time the max time in milliseconds after we attempt a compaction
@@ -151,7 +151,7 @@ public void setMaxCompactionTime(long max_compaction_time) {
     public void resetStats()             {num_compactions=num_moves=num_resizes=num_purges=0;}
 
     /** Returns the highest deliverable (= removable) seqno. This may be higher than {@link #getHighestDelivered()},
-     * e.g. if messages have been added but not yet removed */
+     * e.g. if elements have been added but not yet removed */
     public long getHighestDeliverable() {
         HighestDeliverable visitor=new HighestDeliverable();
         lock.lock();
@@ -190,41 +190,59 @@ public void setHighestDelivered(long seqno) {
     public boolean add(long seqno, T element) {
         lock.lock();
         try {
-            return _add(seqno, element);
+            return _add(seqno, element, true);
         }
         finally {
             lock.unlock();
         }
     }
 
     /**
-     * Adds messages from list to the table
+     * Adds elements from list to the table
      * @param list
-     * @return True if at least 1 message was added successfully
+     * @return True if at least 1 element was added successfully
      */
     public boolean add(final List<Tuple<Long,T>> list) {
        return add(list, false);
     }
 
 
     /**
-     * Adds messages from list to the table, removes messages from list that were not added to the table
+     * Adds elements from list to the table, removes elements from list that were not added to the table
      * @param list
-     * @return True if at least 1 message was added successfully. This guarantees that the list has at least 1 message
+     * @return True if at least 1 element was added successfully. This guarantees that the list has at least 1 element
      */
-    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_msgs) {
-        if(list == null)
+    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_elements) {
+        return add(list, remove_added_elements, null);
+    }
+
+    /**
+     * Adds elements from the list to the table
+     * @param list The list of tuples of seqnos and elements. If remove_added_elements is true, if elements could
+     *             not be added to the table (e.g. because they were already present or the seqno was < HD), those
+     *             elements will be removed from list
+     * @param remove_added_elements If true, elements that could not be added to the table are removed from list
+     * @param const_value If non-null, this value should be used rather than the values of the list tuples
+     * @return True if at least 1 element was added successfully, false otherwise.
+     */
+    public boolean add(final List<Tuple<Long,T>> list, boolean remove_added_elements, T const_value) {
+        if(list == null || list.isEmpty())
             return false;
         boolean added=false;
         lock.lock();
         try {
+            // find the highest seqno (unfortunately, the list is not ordered by seqno)
+            long highest_seqno=findHighestSeqno(list);
+            if(highest_seqno != -1 && computeRow(highest_seqno) >= matrix.length)
+                resize(highest_seqno);
+
             for(Iterator<Tuple<Long,T>> it=list.iterator(); it.hasNext();) {
                 Tuple<Long,T> tuple=it.next();
                 long seqno=tuple.getVal1();
-                T element=tuple.getVal2();
-                if(_add(seqno, element))
+                T element=const_value != null? const_value : tuple.getVal2();
+                if(_add(seqno, element, false))
                     added=true;
-                else if(remove_added_msgs)
+                else if(remove_added_elements)
                     it.remove();
             }
             return added;
@@ -339,11 +357,22 @@ public List<T> removeMany(boolean nullify, int max_results) {
         return removeMany(null, nullify, max_results);
     }
 
-
     public List<T> removeMany(final AtomicBoolean processing, boolean nullify, int max_results) {
+        return removeMany(processing, nullify, max_results, null);
+    }
+
+
+    /**
+     * Removes between 0 and max_results elements from the table and returns them in a list. If filter is non-null,
+     * only elements which the filter accepts are returned. Note that elements are always removed from the table,
+     * but may or may not get added to the returned list.
+     * @return A list of element. A null list means no more elements are in the table and processing (if set)
+     * will be set to false
+     */
+    public List<T> removeMany(final AtomicBoolean processing, boolean nullify, int max_results, Filter<T> filter) {
         lock.lock();
         try {
-            Remover remover=new Remover(nullify, max_results);
+            Remover remover=new Remover(nullify, max_results, filter);
             forEach(hd+1, hr, remover);
             List<T> retval=remover.getList();
             if(processing != null && (retval == null || retval.isEmpty()))
@@ -459,12 +488,12 @@ public void forEach(long from, long to, Visitor<T> visitor) {
         }
     }
 
-    protected boolean _add(long seqno, T element) {
+    protected boolean _add(long seqno, T element, boolean check_if_resize_needed) {
         if(seqno <= hd)
             return false;
 
         int row_index=computeRow(seqno);
-        if(row_index >= matrix.length) {
+        if(check_if_resize_needed && row_index >= matrix.length) {
             resize(seqno);
             row_index=computeRow(seqno);
         }
@@ -481,6 +510,17 @@ protected boolean _add(long seqno, T element) {
         return false;
     }
 
+    // list must not be null or empty
+    protected long findHighestSeqno(List<Tuple<Long,T>> list) {
+        long seqno=-1;
+        for(Tuple<Long,T> tuple: list) {
+            Long val=tuple.getVal1();
+            if(val != null && val > seqno)
+                seqno=val;
+        }
+        return seqno;
+    }
+
     /** Moves rows down the matrix, by removing purged rows. If resizing to accommodate seqno is still needed, computes
      * a new size. Then either moves existing rows down, or copies them into a new array (if resizing took place).
      * The lock must be held by the caller of resize(). */
@@ -563,7 +603,7 @@ public int getNumMissing() {
 
 
     /**
-     * Returns a list of missing (= null) messages
+     * Returns a list of missing (= null) elements
      * @return
      */
     public SeqnoList getMissing() {
@@ -681,33 +721,45 @@ public boolean visit(long seqno, T element, int row, int column) {
 
 
     protected class Remover implements Visitor<T> {
-        protected final boolean nullify;
-        protected final int     max_results;
-        protected List<T>       list;
-        protected int           num_results;
+        protected final boolean      nullify;
+        protected final int          max_results;
+        protected List<T>            list;
+        protected int                num_results;
+        protected final Filter<T>    filter;
 
         public Remover(boolean nullify, int max_results) {
+            this(nullify, max_results, null);
+        }
+
+        public Remover(boolean nullify, int max_results, Filter<T> filter) {
             this.nullify=nullify;
             this.max_results=max_results;
+            this.filter=filter;
         }
 
         public List<T> getList() {return list;}
 
         @GuardedBy(""lock"")
         public boolean visit(long seqno, T element, int row, int column) {
             if(element != null) {
-                if(list == null)
-                    list=new LinkedList<T>();
-                list.add(element);
+                if(filter == null || filter.accept(element)) {
+                    if(list == null)
+                        list=new LinkedList<T>();
+                    list.add(element);
+                    num_results++;
+                }
                 if(seqno > hd)
                     hd=seqno;
                 size=Math.max(size-1, 0); // cannot be < 0 (well that would be a bug, but let's have this 2nd line of defense !)
                 if(nullify) {
                     matrix[row][column]=null;
+                    // if we're nulling the last element of a row, null the row as well
+                    if(column == elements_per_row-1)
+                        matrix[row]=null;
                     if(seqno > low)
                         low=seqno;
                 }
-                return max_results == 0 || ++num_results < max_results;
+                return max_results == 0 || num_results < max_results;
             }
             return false;
         }",2014-01-10T16:46:08Z,127
"@@ -1,10 +1,7 @@
 package org.jgroups.tests;
 
 import org.jgroups.Global;
-import org.jgroups.util.SeqnoList;
-import org.jgroups.util.Table;
-import org.jgroups.util.Tuple;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 import org.testng.annotations.Test;
 
 import java.util.ArrayList;
@@ -44,6 +41,25 @@ public void testAddList() {
         assert buf.size() == 2;
     }
 
+    public void testAddListWithConstValue() {
+        Table<Integer> buf=new Table<Integer>(3, 10, 0);
+        List<Tuple<Long,Integer>> msgs=createList(1,2,3,4,5,6,7,8,9,10);
+        final Integer DUMMY=0;
+        boolean rc=buf.add(msgs, false, DUMMY);
+        System.out.println(""buf = "" + buf);
+        assert rc;
+        assert buf.size() == 10;
+        List<Integer> list=buf.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {
+                return element.hashCode() == DUMMY.hashCode();
+            }
+        });
+        System.out.println(""list = "" + list);
+        assert list.size() == 10;
+        for(int num: list)
+            assert num == DUMMY;
+    }
+
     public void testAddListWithRemoval() {
         Table<Integer> buf=new Table<Integer>(3, 10, 0);
         List<Tuple<Long,Integer>> msgs=createList(1,2,3,4,5,6,7,8,9,10);
@@ -126,6 +142,29 @@ public static void testAdditionListWithOffset() {
     }
 
 
+    public static void testAddListWithResizing() {
+        Table<Integer> table=new Table<Integer>(3, 5, 0);
+        List<Tuple<Long,Integer>> msgs=new ArrayList<Tuple<Long,Integer>>();
+        for(int i=1; i < 100; i++)
+            msgs.add(new Tuple<Long,Integer>((long)i,i));
+        table.add(msgs, false);
+        System.out.println(""table = "" + table);
+        int num_resizes=table.getNumResizes();
+        System.out.println(""num_resizes = "" + num_resizes);
+        assert num_resizes == 1 : ""number of resizings="" + num_resizes + "" (expected 1)"";
+    }
+
+    public static void testAddListWithResizing2() {
+        Table<Integer> table=new Table<Integer>(3, 500, 0);
+        List<Tuple<Long,Integer>> msgs=new ArrayList<Tuple<Long,Integer>>();
+        for(int i=1; i < 100; i++)
+            msgs.add(new Tuple<Long,Integer>((long)i,i));
+        table.add(msgs, false);
+        System.out.println(""table = "" + table);
+        int num_resizes=table.getNumResizes();
+        System.out.println(""num_resizes = "" + num_resizes);
+        assert num_resizes == 0 : ""number of resizings="" + num_resizes + "" (expected 0)"";
+    }
 
     public static void testAdditionWithOffset2() {
         Table<Integer> table=new Table<Integer>(3, 10, 2);
@@ -540,6 +579,60 @@ public static void testRemoveManyWithWrapping2() {
         assert table.size() == 6 && table.getNumMissing() == 2;
     }
 
+    public static void testRemoveManyWithFilter() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {
+                return element % 2 == 0;
+            }
+        });
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 5;
+        assert table.isEmpty();
+        for(Integer num: Arrays.asList(2,4,6,8,10))
+            assert list.contains(num);
+    }
+
+    public static void testRemoveManyWithFilterAcceptAll() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {return true;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 10;
+        assert table.isEmpty();
+    }
+
+    public static void testRemoveManyWithFilterAcceptNone() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,0,new Filter<Integer>() {
+            public boolean accept(Integer element) {return false;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list == null;
+        assert table.isEmpty();
+    }
+
+    public static void testRemoveManyWithFilterAcceptNone2() {
+        Table<Integer> table=new Table<Integer>(3, 10, 0);
+        for(int i=1; i <= 10; i++)
+            table.add(i, i);
+        List<Integer> list=table.removeMany(null,true,3,new Filter<Integer>() {
+            int cnt=0;
+            public boolean accept(Integer element) {return ++cnt <= 2;}});
+        System.out.println(""list = "" + list);
+        System.out.println(""table = "" + table);
+        assert list.size() == 2;
+        assert table.isEmpty();
+    }
+
 
     public static void testForEach() {
         class MyVisitor<T> implements Table.Visitor<T> {
@@ -804,10 +897,10 @@ public static void testResize() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
         addAndGet(table, 30);
-        addAndGet(table, 35);
-        assertCapacity(table.capacity(), table.getNumRows(), 10);
-        addAndGet(table, 500);
+        addAndGet(table,35);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
+        addAndGet(table,500);
+        assertCapacity(table.capacity(),table.getNumRows(),10);
 
         addAndGet(table, 515);
         assertCapacity(table.capacity(), table.getNumRows(), 10);
@@ -828,7 +921,7 @@ public void testResizeWithPurge() {
 
         table.purge(50);
         System.out.println(""now triggering a resize() by addition of seqno=120"");
-        addAndGet(table, 120);
+        addAndGet(table,120);
         
     }
 
@@ -888,7 +981,7 @@ public void testResizeWithPurge2() {
         assertIndices(table, 0, 43, 50);
         table.purge(43);
         System.out.println(""table = "" + table);
-        assertIndices(table, 43, 43, 50);
+        assertIndices(table,43,43,50);
         addAndGet(table, 52);
         assert table.get(43) == null;
 
@@ -919,10 +1012,10 @@ public static void testMove() {
     public static void testMove2() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         for(int i=1; i < 30; i++)
-            table.add(i, i);
+            table.add(i,i);
         table.removeMany(true, 23);
         System.out.println(""table = "" + table);
-        table.add(35, 35); // triggers a resize() --> move()
+        table.add(35,35); // triggers a resize() --> move()
         for(int i=1; i <= 23; i++)
             assert table._get(i) == null;
         for(int i=24; i < 30; i++)
@@ -1017,7 +1110,7 @@ public void testPurge4() {
         for(int i=1; i <= 100; i++)
             table.add(i, i);
         System.out.println(""table = "" + table);
-        table.removeMany(false, 53);
+        table.removeMany(false,53);
         table.purge(53);
         for(int i=54; i <= 100; i++)
             assert table.get(i) == i;
@@ -1057,7 +1150,7 @@ public void testPurgeForce() {
         for(int i=1; i <= 30; i++)
             table.add(i, i);
         System.out.println(""table = "" + table);
-        table.purge(15, true);
+        table.purge(15,true);
         System.out.println(""table = "" + table);
         assertIndices(table, 15, 15, 30);
         for(int i=1; i <= 15; i++)
@@ -1089,20 +1182,20 @@ public void testPurgeForce() {
     public void testCompact() {
         Table<Integer> table=new Table<Integer>(3, 10, 0);
         for(int i=1; i <= 80; i++)
-            addAndGet(table, i);
+            addAndGet(table,i);
         assert table.size() == 80;
-        assertIndices(table, 0, 0, 80);
+        assertIndices(table,0,0,80);
         List<Integer> list=table.removeMany(false,60);
         assert list.size() == 60;
         assert list.get(0) == 1 && list.get(list.size() -1) == 60;
         assertIndices(table, 0, 60, 80);
         table.purge(60);
-        assertIndices(table, 60, 60, 80);
+        assertIndices(table,60,60,80);
         assert table.size() == 20;
         table.compact();
-        assertIndices(table, 60, 60, 80);
+        assertIndices(table,60,60,80);
         assert table.size() == 20;
-        assertCapacity(table.capacity(), table.getNumRows(), 10);
+        assertCapacity(table.capacity(),table.getNumRows(),10);
     }
 
 ",2014-01-10T16:46:08Z,128
"@@ -763,6 +763,27 @@ public void readFrom(DataInput in) throws Exception {
             if(type == DATA)
                 seqno=Util.readLong(in);
         }
+
+        public String toString() {
+            return typeToString(type) + (seqno > 0? seqno : """");
+        }
+
+        protected static String typeToString(byte type) {
+            switch(type) {
+                case DATA:          return ""DATA"";
+                case START_SENDING: return ""START_SENDING"";
+                case SENDING_DONE:  return ""SENDING_DONE"";
+                case RESULT:        return ""RESULT"";
+                case CLEAR_RESULTS: return ""CLEAR_RESULTS"";
+                case CONFIG_CHANGE: return ""CONFIG_CHANGE"";
+                case CONFIG_REQ:    return ""CONFIG_REQ"";
+                case CONFIG_RSP:    return ""CONFIG_RSP"";
+                case EXIT:          return ""EXIT"";
+                case NEW_CONFIG:    return ""NEW_CONFIG"";
+                case ACK:           return ""ACK"";
+                default:            return ""n/a"";
+            }
+        }
     }
 
 ",2014-01-10T16:46:08Z,129
"@@ -45,6 +45,7 @@ public class UPerf extends ReceiverAdapter {
     @Property protected boolean use_anycast_addrs;
     @Property protected boolean msg_bundling=true;
     @Property protected double  read_percentage=0.8; // 80% reads, 20% writes
+    @Property protected boolean get_before_put=false; // invoke a sync GET before a PUT
     // ... add your own here, just don't forget to annotate them with @Property
     // =======================================================
 
@@ -172,7 +173,7 @@ public Results startTest() throws Throwable {
         }
 
         long total_time=System.currentTimeMillis() - start;
-        System.out.println(""done (in "" + total_time + "" ms)"");
+        System.out.println(""\ndone (in "" + total_time + "" ms)"");
         return new Results(total_gets, total_puts, total_time);
     }
 
@@ -227,7 +228,7 @@ public void eventLoop() throws Throwable {
                               ""[8] Set msg size ("" + Util.printBytes(msg_size) + "")"" +
                               "" [9] Set anycast count ("" + anycast_count + "")"" +
                               ""\n[o] Toggle OOB ("" + oob + "") [s] Toggle sync ("" + sync +
-                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") "" +
+                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") [g] get_before_put ("" + get_before_put + "") "" +
                               ""\n[a] Toggle use_anycast_addrs ("" + use_anycast_addrs + "") [b] Toggle msg_bundling ("" +
                               (msg_bundling? ""on"" : ""off"") + "")"" +
                               ""\n[q] Quit\n"");
@@ -271,6 +272,9 @@ public void eventLoop() throws Throwable {
                 case 'b':
                     changeFieldAcrossCluster(""msg_bundling"", !msg_bundling);
                     break;
+                case 'g':
+                    changeFieldAcrossCluster(""get_before_put"", !get_before_put);
+                    break;
                 case 'q':
                     channel.close();
                     return;
@@ -286,7 +290,7 @@ public void eventLoop() throws Throwable {
 
     /** Kicks off the benchmark on all cluster nodes */
     void startBenchmark() {
-        RspList<Object> responses=null;
+        RspList<Results> responses=null;
         try {
             RequestOptions options=new RequestOptions(ResponseMode.GET_ALL, 0);
             options.setFlags(Message.Flag.OOB, Message.Flag.DONT_BUNDLE, Message.Flag.NO_FC);
@@ -301,10 +305,10 @@ void startBenchmark() {
         long total_time=0;
 
         System.out.println(""\n======================= Results: ==========================="");
-        for(Map.Entry<Address,Rsp<Object>> entry: responses.entrySet()) {
+        for(Map.Entry<Address,Rsp<Results>> entry: responses.entrySet()) {
             Address mbr=entry.getKey();
-            Rsp rsp=entry.getValue();
-            Results result=(Results)rsp.getValue();
+            Rsp<Results> rsp=entry.getValue();
+            Results result=rsp.getValue();
             total_reqs+=result.num_gets + result.num_puts;
             total_time+=result.time;
             System.out.println(mbr + "": "" + result);
@@ -381,12 +385,14 @@ private class Invoker extends Thread {
         private final AtomicInteger  num_msgs_sent;
         private int                  num_gets=0;
         private int                  num_puts=0;
+        private final int            PRINT;
 
 
         public Invoker(Collection<Address> dests, int num_msgs_to_send, AtomicInteger num_msgs_sent) {
             this.num_msgs_sent=num_msgs_sent;
             this.dests.addAll(dests);
             this.num_msgs_to_send=num_msgs_to_send;
+            PRINT=num_msgs_to_send / 10;
             setName(""Invoker-"" + COUNTER.getAndIncrement());
         }
 
@@ -403,6 +409,7 @@ public void run() {
             MethodCall put_call=new MethodCall(PUT, put_args);
             RequestOptions get_options=new RequestOptions(ResponseMode.GET_ALL, 40000, false, null);
             RequestOptions put_options=new RequestOptions(sync ? ResponseMode.GET_ALL : ResponseMode.GET_NONE, 40000, true, null);
+            RequestOptions get_before_put_options=new RequestOptions(ResponseMode.GET_FIRST, 40000, true, null, Message.Flag.DONT_BUNDLE, Message.Flag.OOB);
 
             if(oob) {
                 get_options.setFlags(Message.Flag.OOB);
@@ -419,6 +426,8 @@ public void run() {
                 long i=num_msgs_sent.getAndIncrement();
                 if(i >= num_msgs_to_send)
                     break;
+                if(i > 0 && i % PRINT == 0)
+                    System.out.print(""."");
                 
                 boolean get=Util.tossWeightedCoin(read_percentage);
 
@@ -430,7 +439,13 @@ public void run() {
                         num_gets++;
                     }
                     else {    // sync or async (based on value of 'sync') PUT
-                        Collection<Address> targets=pickAnycastTargets();
+                        final Collection<Address> targets=pickAnycastTargets();
+                        if(get_before_put) {
+                            // sync GET
+                            get_args[0]=i;
+                            disp.callRemoteMethods(targets, get_call, get_before_put_options);
+                            num_gets++;
+                        }
                         put_args[0]=i;
                         disp.callRemoteMethods(targets, put_call, put_options);
                         num_puts++;",2014-01-10T16:46:08Z,130
"@@ -1,835 +0,0 @@
-package org.jgroups.tests.perf;
-
-import org.jgroups.*;
-import org.jgroups.blocks.*;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.jmx.JmxConfigurator;
-import org.jgroups.protocols.UNICAST;
-import org.jgroups.protocols.UNICAST2;
-import org.jgroups.protocols.relay.RELAY2;
-import org.jgroups.protocols.relay.SiteMaster;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.*;
-
-import javax.management.MBeanServer;
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.lang.reflect.Method;
-import java.nio.ByteBuffer;
-import java.text.NumberFormat;
-import java.util.*;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Tests the UNICAST by invoking unicast RPCs between a sender and a receiver. Mimicks the DIST mode in Infinispan
- *
- * @author Bela Ban
- */
-public class UPerf2 extends ReceiverAdapter {
-    private JChannel               channel;
-    private Address                local_addr;
-    private RpcDispatcher          disp;
-    static final String            groupname=""uperf"";
-    protected final List<Address>  members=new ArrayList<Address>();
-    protected final List<Address>  site_masters=new ArrayList<Address>();
-    public static Random random = new Random();
-
-
-    // ============ configurable properties ==================
-    private boolean sync=false, oob=false;
-    private int num_threads=1;
-    private int num_msgs=5000, msg_size=1000;
-    private int anycast_count=2;
-    private boolean use_anycast_addrs;
-    private boolean msg_bundling=true;
-    private double read_percentage=0; // 80% reads, 20% writes
-    // =======================================================
-
-    private static final Method[] METHODS=new Method[16];
-
-    private static final short START                 =  0;
-    private static final short SET_OOB               =  1;
-    private static final short SET_SYNC              =  2;
-    private static final short SET_NUM_MSGS          =  3;
-    private static final short SET_NUM_THREADS       =  4;
-    private static final short SET_MSG_SIZE          =  5;
-    private static final short SET_ANYCAST_COUNT     =  6;
-    private static final short SET_USE_ANYCAST_ADDRS =  7;
-    private static final short SET_READ_PERCENTAGE   =  8;
-    private static final short GET                   =  9;
-    private static final short PUT                   = 10;
-    private static final short GET_CONFIG            = 11;
-    private static final short SET_MSB_BUNDLING      = 12;
-
-    private final AtomicInteger COUNTER=new AtomicInteger(1);
-    private byte[] GET_RSP=new byte[msg_size];
-
-    static NumberFormat f;
-
-
-    static {
-        try {
-            METHODS[START]                 = UPerf2.class.getMethod(""startTest"");
-            METHODS[SET_OOB]               = UPerf2.class.getMethod(""setOOB"", boolean.class);
-            METHODS[SET_SYNC]              = UPerf2.class.getMethod(""setSync"", boolean.class);
-            METHODS[SET_NUM_MSGS]          = UPerf2.class.getMethod(""setNumMessages"", int.class);
-            METHODS[SET_NUM_THREADS]       = UPerf2.class.getMethod(""setNumThreads"", int.class);
-            METHODS[SET_MSG_SIZE]          = UPerf2.class.getMethod(""setMessageSize"", int.class);
-            METHODS[SET_ANYCAST_COUNT]     = UPerf2.class.getMethod(""setAnycastCount"", int.class);
-            METHODS[SET_USE_ANYCAST_ADDRS] = UPerf2.class.getMethod(""setUseAnycastAddrs"", boolean.class);
-            METHODS[SET_READ_PERCENTAGE]   = UPerf2.class.getMethod(""setReadPercentage"", double.class);
-            METHODS[GET]                   = UPerf2.class.getMethod(""get"", long.class);
-            METHODS[PUT]                   = UPerf2.class.getMethod(""put"", long.class, byte[].class);
-            METHODS[GET_CONFIG]            = UPerf2.class.getMethod(""getConfig"");
-            METHODS[SET_MSB_BUNDLING]       = UPerf2.class.getMethod(""setMsgBundling"", boolean.class);
-
-            ClassConfigurator.add((short)11000, Results.class);
-            f=NumberFormat.getNumberInstance();
-            f.setGroupingUsed(false);
-            f.setMinimumFractionDigits(2);
-            f.setMaximumFractionDigits(2);
-        }
-        catch(NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-
-    public void init(String props, String name, boolean xsite) throws Throwable {
-        channel=new JChannel(props);
-        if(name != null)
-            channel.setName(name);
-        disp=new RpcDispatcher(channel, null, this, this);
-        disp.setMethodLookup(new MethodLookup() {
-            public Method findMethod(short id) {
-                return METHODS[id];
-            }
-        });
-        disp.setRequestMarshaller(new CustomMarshaller());
-        channel.connect(groupname);
-        local_addr=channel.getAddress();
-
-        if(xsite) {
-            List<String> site_names=getSites(channel);
-            for(String site_name: site_names) {
-                try {
-                    SiteMaster sm=new SiteMaster(site_name);
-                    site_masters.add(sm);
-                }
-                catch(Throwable t) {
-                    System.err.println(""failed creating site master: "" + t);
-                }
-            }
-        }
-
-        try {
-            MBeanServer server=Util.getMBeanServer();
-            JmxConfigurator.registerChannel(channel, server, ""jgroups"", channel.getClusterName(), true);
-        }
-        catch(Throwable ex) {
-            System.err.println(""registering the channel in JMX failed: "" + ex);
-        }
-
-        if(members.size() < 2)
-            return;
-        Address coord=members.get(0);
-        ConfigOptions config=(ConfigOptions)disp.callRemoteMethod(coord, new MethodCall(GET_CONFIG), new RequestOptions(ResponseMode.GET_ALL, 5000));
-        if(config != null) {
-            this.oob=config.oob;
-            this.msg_bundling=config.msg_bundling;
-            this.sync=config.sync;
-            this.num_threads=config.num_threads;
-            this.num_msgs=config.num_msgs;
-            this.msg_size=config.msg_size;
-            this.anycast_count=config.anycast_count;
-            this.use_anycast_addrs=config.use_anycast_addrs;
-            this.read_percentage=config.read_percentage;
-            System.out.println(""Fetched config from "" + coord + "": "" + config);
-        }
-        else
-            System.err.println(""failed to fetch config from "" + coord);
-    }
-
-    void stop() {
-        if(disp != null)
-            disp.stop();
-        Util.close(channel);
-    }
-
-    public void viewAccepted(View new_view) {
-        System.out.println(""** view: "" + new_view);
-        members.clear();
-        members.addAll(new_view.getMembers());
-        addSiteMastersToMembers();
-    }
-
-    protected void addSiteMastersToMembers() {
-        if(!site_masters.isEmpty()) {
-            for(Address sm: site_masters)
-                if(!members.contains(sm))
-                    members.add(sm);
-        }
-    }
-
-    // =================================== callbacks ======================================
-
-    public Results startTest() throws Throwable {
-
-        addSiteMastersToMembers();
-
-        System.out.println(""invoking "" + num_msgs + "" RPCs of "" + Util.printBytes(msg_size) + "", sync="" + sync +
-                             "", oob="" + oob + "", msg_bundling="" + msg_bundling + "", use_anycast_addrs="" + use_anycast_addrs);
-        int total_gets=0, total_puts=0;
-        final AtomicInteger num_msgs_sent=new AtomicInteger(0);
-
-        Invoker[] invokers=new Invoker[num_threads];
-        for(int i=0; i < invokers.length; i++)
-            invokers[i]=new Invoker(members, num_msgs, num_msgs_sent);
-
-        long start=System.currentTimeMillis();
-        for(Invoker invoker: invokers)
-            invoker.start();
-
-        for(Invoker invoker: invokers) {
-            invoker.join();
-            total_gets+=invoker.numGets();
-            total_puts+=invoker.numPuts();
-        }
-
-        long total_time=System.currentTimeMillis() - start;
-        System.out.println(""\ndone (in "" + total_time + "" ms)"");
-        return new Results(total_gets, total_puts, total_time);
-    }
-
-
-    public void setOOB(boolean oob) {
-        this.oob=oob;
-        System.out.println(""oob="" + oob);
-    }
-
-    public void setMsgBundling(boolean msg_bundling) {
-        this.msg_bundling=msg_bundling;
-        System.out.println(""msg_bundling = "" + this.msg_bundling);
-      }
-
-    public void setSync(boolean val) {
-        this.sync=val;
-        System.out.println(""sync="" + sync);
-    }
-
-    public void setNumMessages(int num) {
-        num_msgs=num;
-        System.out.println(""num_msgs = "" + num_msgs);
-    }
-
-    public void setNumThreads(int num) {
-        num_threads=num;
-        System.out.println(""num_threads = "" + num_threads);
-    }
-
-    public void setMessageSize(int num) {
-        msg_size=num;
-        System.out.println(""msg_size = "" + msg_size);
-    }
-
-    public void setAnycastCount(int num) {
-        anycast_count=num;
-        System.out.println(""anycast_count = "" + anycast_count);
-    }
-
-    public void setUseAnycastAddrs(boolean flag) {
-        use_anycast_addrs=flag;
-        System.out.println(""use_anycast_addrs = "" + use_anycast_addrs);
-    }
-
-    public void setReadPercentage(double val) {
-        this.read_percentage=val;
-        System.out.println(""read_percentage = "" + read_percentage);
-    }
-
-    public byte[] get(long key) {
-        return GET_RSP;
-    }
-
-
-    public void put(long key, byte[] val) {
-        
-    }
-
-    public ConfigOptions getConfig() {
-        return new ConfigOptions(oob, sync,msg_bundling,
-                                 num_threads, num_msgs, msg_size, anycast_count, use_anycast_addrs, read_percentage);
-    }
-
-    // ================================= end of callbacks =====================================
-
-
-    public void eventLoop() throws Throwable {
-        int c;
-
-        addSiteMastersToMembers();
-
-        while(true) {
-            c=Util.keyPress(""[1] Send msgs [2] Print view [3] Print conns "" +
-                              ""[4] Trash conn [5] Trash all conns"" +
-                              ""\n[6] Set sender threads ("" + num_threads + "") [7] Set num msgs ("" + num_msgs + "") "" +
-                              ""[8] Set msg size ("" + Util.printBytes(msg_size) + "")"" +
-                              "" [9] Set anycast count ("" + anycast_count + "")"" +
-                              ""\n[o] Toggle OOB ("" + oob + "") [s] Toggle sync ("" + sync +
-                              "") [r] Set read percentage ("" + f.format(read_percentage) + "") "" +
-                              ""\n[a] Toggle use_anycast_addrs ("" + use_anycast_addrs + "") [b] Toggle msg_bundling ("" +
-                              (msg_bundling? ""on"" : ""off"") + "")"" +
-                              ""\n[q] Quit\n"");
-            switch(c) {
-                case -1:
-                    break;
-                case '1':
-                    try {
-                        startBenchmark();
-                    }
-                    catch(Throwable t) {
-                        System.err.println(t);
-                    }
-                    break;
-                case '2':
-                    printView();
-                    break;
-                case '3':
-                    printConnections();
-                    break;
-                case '4':
-                    removeConnection();
-                    break;
-                case '5':
-                    removeAllConnections();
-                    break;
-                case '6':
-                    setSenderThreads();
-                    break;
-                case '7':
-                    setNumMessages();
-                    break;
-                case '8':
-                    setMessageSize();
-                    break;
-                case '9':
-                    setAnycastCount();
-                    break;
-                case 'a':
-                    boolean new_value=!use_anycast_addrs;
-                    disp.callRemoteMethods(null, new MethodCall(SET_USE_ANYCAST_ADDRS, new_value), RequestOptions.SYNC());
-                    break;
-                case 'o':
-                    new_value=!oob;
-                    disp.callRemoteMethods(null, new MethodCall(SET_OOB, new_value), RequestOptions.SYNC());
-                    break;
-                case 's':
-                    boolean new_val=!sync;
-                    disp.callRemoteMethods(null, new MethodCall(SET_SYNC, new_val), RequestOptions.SYNC());
-                    break;
-                case 'r':
-                    setReadPercentage();
-                    break;
-                case 'b':
-                    new_value=!msg_bundling;
-                    disp.callRemoteMethods(null, new MethodCall(SET_MSB_BUNDLING, new_value), RequestOptions.SYNC());
-                    break;
-                case 'q':
-                    channel.close();
-                    return;
-                case '\n':
-                case '\r':
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    private void printConnections() {
-        Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-        if(prot instanceof UNICAST)
-            System.out.println(""connections:\n"" + ((UNICAST)prot).printConnections());
-        else if(prot instanceof UNICAST2)
-            System.out.println(""connections:\n"" + ((UNICAST2)prot).printConnections());
-    }
-
-    private void removeConnection() {
-       Address member=getReceiver();
-        if(member != null) {
-            Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-            if(prot instanceof UNICAST)
-                ((UNICAST)prot).removeConnection(member);
-            else if(prot instanceof UNICAST2)
-                ((UNICAST2)prot).removeConnection(member);
-        }
-    }
-
-    private void removeAllConnections() {
-        Protocol prot=channel.getProtocolStack().findProtocol(Util.getUnicastProtocols());
-        if(prot instanceof UNICAST)
-            ((UNICAST)prot).removeAllConnections();
-        else if(prot instanceof UNICAST2)
-            ((UNICAST2)prot).removeAllConnections();
-    }
-
-
-    /** Kicks off the benchmark on all cluster nodes */
-    void startBenchmark() throws Throwable {
-        RequestOptions options=new RequestOptions(ResponseMode.GET_ALL, 0);
-        options.setFlags(Message.Flag.OOB, Message.Flag.DONT_BUNDLE, Message.Flag.NO_FC);
-        RspList<Object> responses=disp.callRemoteMethods(null, new MethodCall(START), options);
-
-        long total_reqs=0;
-        long total_time=0;
-
-        System.out.println(""\n======================= Results: ==========================="");
-        for(Map.Entry<Address,Rsp<Object>> entry: responses.entrySet()) {
-            Address mbr=entry.getKey();
-            Rsp rsp=entry.getValue();
-            Results result=(Results)rsp.getValue();
-            total_reqs+=result.num_gets + result.num_puts;
-            total_time+=result.time;
-            System.out.println(mbr + "": "" + result);
-        }
-        double total_reqs_sec=total_reqs / ( total_time/ 1000.0);
-        double throughput=total_reqs_sec * msg_size;
-        double ms_per_req=total_time / (double)total_reqs;
-        Protocol prot=channel.getProtocolStack().findProtocol(new Class[]{UNICAST.class, UNICAST2.class});
-        System.out.println(""\n"");
-        System.out.println(Util.bold(""Average of "" + f.format(total_reqs_sec) + "" requests / sec ("" +
-                                       Util.printBytes(throughput) + "" / sec), "" +
-                                       f.format(ms_per_req) + "" ms /request (prot="" + (prot != null? prot.getName() : ""n/a"") + "")""));
-        System.out.println(""\n\n"");
-    }
-    
-
-    void setSenderThreads() throws Exception {
-        int threads=Util.readIntFromStdin(""Number of sender threads: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_NUM_THREADS, threads), RequestOptions.SYNC());
-    }
-
-    void setNumMessages() throws Exception {
-        int tmp=Util.readIntFromStdin(""Number of RPCs: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_NUM_MSGS, tmp), RequestOptions.SYNC());
-    }
-
-    void setMessageSize() throws Exception {
-        int tmp=Util.readIntFromStdin(""Message size: "");
-        disp.callRemoteMethods(null, new MethodCall(SET_MSG_SIZE, tmp), RequestOptions.SYNC());
-    }
-
-    void setReadPercentage() throws Exception {
-        double tmp=Util.readDoubleFromStdin(""Read percentage: "");
-        if(tmp < 0 || tmp > 1.0) {
-            System.err.println(""read percentage must be >= 0 or <= 1.0"");
-            return;
-        }
-        disp.callRemoteMethods(null, new MethodCall(SET_READ_PERCENTAGE, tmp), RequestOptions.SYNC());
-    }
-
-    void setAnycastCount() throws Exception {
-        int tmp=Util.readIntFromStdin(""Anycast count: "");
-        View view=channel.getView();
-        if(tmp > view.size()) {
-            System.err.println(""anycast count must be smaller or equal to the view size ("" + view + "")\n"");
-            return;
-        }
-        disp.callRemoteMethods(null, new MethodCall(SET_ANYCAST_COUNT, tmp), RequestOptions.SYNC());
-    }
-
-
-
-    void printView() {
-        System.out.println(""\n-- view: "" + members + '\n');
-        try {
-            System.in.skip(System.in.available());
-        }
-        catch(Exception e) {
-        }
-    }
-
-    protected static List<String> getSites(JChannel channel) {
-        RELAY2 relay=(RELAY2)channel.getProtocolStack().findProtocol(RELAY2.class);
-        return new ArrayList<String>(0);
-    }
-
-    /** Picks the next member in the view */
-    private Address getReceiver() {
-        try {
-            List<Address> mbrs=channel.getView().getMembers();
-            int index=mbrs.indexOf(local_addr);
-            int new_index=index + 1 % mbrs.size();
-            return mbrs.get(new_index);
-        }
-        catch(Exception e) {
-            System.err.println(""UPerf.getReceiver(): "" + e);
-            return null;
-        }
-    }
-
-    private class Invoker extends Thread {
-        private final List<Address>  dests=new ArrayList<Address>();
-        private final int            num_msgs_to_send;
-        private final AtomicInteger  num_msgs_sent;
-        private final int            PRINT;
-        private int                  num_gets=0;
-        private int                  num_puts=0;
-
-
-        public Invoker(Collection<Address> dests, int num_msgs_to_send, AtomicInteger num_msgs_sent) {
-            this.num_msgs_sent=num_msgs_sent;
-            this.dests.addAll(dests);
-            this.num_msgs_to_send=num_msgs_to_send;
-            PRINT=num_msgs_to_send / 10;
-            setName(""Invoker-"" + COUNTER.getAndIncrement());
-        }
-
-        
-        public int numGets() {return num_gets;}
-        public int numPuts() {return num_puts;}
-
-
-        public void run() {
-            final byte[] buf=new byte[msg_size];
-            Object[] put_args={0, buf};
-            Object[] get_args={0};
-            MethodCall get_call=new MethodCall(GET, get_args);
-            MethodCall put_call=new MethodCall(PUT, put_args);
-            RequestOptions get_options=new RequestOptions(ResponseMode.GET_ALL, 40000, false, null);
-            RequestOptions put_options=new RequestOptions(sync ? ResponseMode.GET_ALL : ResponseMode.GET_NONE, 40000, true, null);
-            RequestOptions get_before_put_options = new RequestOptions(ResponseMode.GET_FIRST, 40000, true, null);
-
-            if(oob) {
-                get_options.setFlags(Message.Flag.OOB);
-                put_options.setFlags(Message.Flag.OOB);
-            }
-            get_before_put_options.setFlags(Message.Flag.OOB);
-
-            if(!msg_bundling) {
-                get_options.setFlags(Message.Flag.DONT_BUNDLE);
-                put_options.setFlags(Message.Flag.DONT_BUNDLE);
-            }
-            get_before_put_options.setFlags(Message.Flag.DONT_BUNDLE);
-
-            if(use_anycast_addrs)
-                put_options.useAnycastAddresses(true);
-            get_before_put_options.setFlags(Message.Flag.DONT_BUNDLE);
-
-            while(true) {
-                long i=num_msgs_sent.getAndIncrement();
-                if(i >= num_msgs_to_send)
-                    break;
-                if(i % PRINT == 0)
-                    System.out.print(""."");
-                
-                try {
-                    // sync GET
-                    Collection<Address> targets=pickAnycastTargets();
-                    get_args[0]=i;
-                    //System.out.println(""GET: targets="" + targets);
-                    disp.callRemoteMethods(targets, get_call, get_before_put_options);
-                    num_gets++;
-
-                    // sync or async (based on value of 'sync') PUT
-                    put_args[0]=i;
-                    //System.out.println(""PUT: targets="" + targets);
-                    disp.callRemoteMethods(targets, put_call, put_options);
-                    num_puts++;
-                }
-                catch(Throwable throwable) {
-                    throwable.printStackTrace();
-                }
-            }
-        }
-
-        private Address pickTarget() {
-            int index=dests.indexOf(local_addr);
-            int new_index=(index +1) % dests.size();
-            return dests.get(new_index);
-        }
-
-        private Collection<Address> pickAnycastTargets() {
-            Collection<Address> anycast_targets=new ArrayList<Address>(anycast_count);
-            int index=dests.indexOf(local_addr);
-            for(int i=index + 1; i < index + 1 + anycast_count; i++) {
-                int new_index=i % dests.size();
-                Address tmp=dests.get(new_index);
-                if(!anycast_targets.contains(tmp))
-                    anycast_targets.add(tmp);
-            }
-            return anycast_targets;
-        }
-
-        private List<Address> pickGetTargets() {
-            List<Address> members = dests;
-            int size = members.size() - 1;
-            int startIndex = random.nextInt(size);
-
-            // self also has the keys for the previous numOwners - 1 nodes
-            if (startIndex >= members.size() - anycast_count)
-                return null;
-
-            int numTargets = Math.min(anycast_count, members.size() - 1);
-            List<Address> targets = new ArrayList<Address>(numTargets);
-            for (int i = 0; i < numTargets; ++i) {
-                targets.add(members.get((startIndex + i) % size));
-            }
-            return targets;
-        }
-
-        private Collection<Address> pickPutTargets() {
-            List<Address> members = dests;
-            int size = members.size() - 1;
-            int startIndex = random.nextInt(size);
-
-            Collection<Address> targets = new ArrayList<Address>(anycast_count);
-            for (int i = 0; i < anycast_count; i++) {
-                int newIndex = (startIndex + i) % size;
-
-                if (newIndex == members.size() - 1)
-                    continue;
-
-                targets.add(members.get(newIndex));
-            }
-            return targets;
-        }
-
-    }
-
-
-    public static class Results implements Streamable {
-        long num_gets=0;
-        long num_puts=0;
-        long time=0;
-
-        public Results() {
-            
-        }
-
-        public Results(int num_gets, int num_puts, long time) {
-            this.num_gets=num_gets;
-            this.num_puts=num_puts;
-            this.time=time;
-        }
-
-
-
-
-        public void writeTo(DataOutput out) throws Exception {
-            out.writeLong(num_gets);
-            out.writeLong(num_puts);
-            out.writeLong(time);
-        }
-
-        public void readFrom(DataInput in) throws Exception {
-            num_gets=in.readLong();
-            num_puts=in.readLong();
-            time=in.readLong();
-        }
-
-        public String toString() {
-            long total_reqs=num_gets + num_puts;
-            double total_reqs_per_sec=total_reqs / (time / 1000.0);
-
-            return f.format(total_reqs_per_sec) + "" reqs/sec ("" + num_gets + "" GETs, "" + num_puts + "" PUTs total)"";
-        }
-    }
-
-
-    public static class ConfigOptions implements Streamable {
-        private boolean sync, oob, msg_bundling;
-        private int     num_threads;
-        private int     num_msgs, msg_size;
-        private int     anycast_count;
-        private boolean use_anycast_addrs;
-        private double  read_percentage;
-
-        public ConfigOptions() {
-        }
-
-        public ConfigOptions(boolean oob, boolean sync, boolean msg_bundling, int num_threads, int num_msgs, int msg_size,
-                             int anycast_count, boolean use_anycast_addrs,
-                             double read_percentage) {
-            this.oob=oob;
-            this.msg_bundling=msg_bundling;
-            this.sync=sync;
-            this.num_threads=num_threads;
-            this.num_msgs=num_msgs;
-            this.msg_size=msg_size;
-            this.anycast_count=anycast_count;
-            this.use_anycast_addrs=use_anycast_addrs;
-            this.read_percentage=read_percentage;
-        }
-
-
-        public void writeTo(DataOutput out) throws Exception {
-            out.writeBoolean(oob);
-            out.writeBoolean(msg_bundling);
-            out.writeBoolean(sync);
-            out.writeInt(num_threads);
-            out.writeInt(num_msgs);
-            out.writeInt(msg_size);
-            out.writeInt(anycast_count);
-            out.writeBoolean(use_anycast_addrs);
-            out.writeDouble(read_percentage);
-        }
-
-        public void readFrom(DataInput in) throws Exception {
-            oob=in.readBoolean();
-            msg_bundling=in.readBoolean();
-            sync=in.readBoolean();
-            num_threads=in.readInt();
-            num_msgs=in.readInt();
-            msg_size=in.readInt();
-            anycast_count=in.readInt();
-            use_anycast_addrs=in.readBoolean();
-            read_percentage=in.readDouble();
-        }
-
-        public String toString() {
-            return ""oob="" + oob + "", sync="" + sync + "", msg_bundling="" + msg_bundling + "", anycast_count="" + anycast_count +
-              "", use_anycast_addrs="" + use_anycast_addrs +
-              "", num_threads="" + num_threads + "", num_msgs="" + num_msgs + "", msg_size="" + msg_size +
-              "", read percentage="" + read_percentage;
-        }
-    }
-
-
-    static class CustomMarshaller implements RpcDispatcher.Marshaller {
-
-        public Buffer objectToBuffer(Object obj) throws Exception {
-            MethodCall call=(MethodCall)obj;
-            ByteBuffer buf;
-            switch(call.getId()) {
-                case START:
-                case GET_CONFIG:
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE);
-                    buf.put((byte)call.getId());
-                    return new Buffer(buf.array());
-                case SET_OOB:
-                case SET_SYNC:
-                case SET_MSB_BUNDLING:
-                case SET_USE_ANYCAST_ADDRS:
-                    return new Buffer(booleanBuffer(call.getId(), (Boolean)call.getArgs()[0]));
-                case SET_NUM_MSGS:
-                case SET_NUM_THREADS:
-                case SET_MSG_SIZE:
-                case SET_ANYCAST_COUNT:
-                    return new Buffer(intBuffer(call.getId(), (Integer)call.getArgs()[0]));
-                case GET:
-                    return new Buffer(longBuffer(call.getId(), (Long)call.getArgs()[0]));
-                case PUT:
-                    Long long_arg=(Long)call.getArgs()[0];
-                    byte[] arg2=(byte[])call.getArgs()[1];
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.INT_SIZE + Global.LONG_SIZE + arg2.length);
-                    buf.put((byte)call.getId()).putLong(long_arg).putInt(arg2.length).put(arg2, 0, arg2.length);
-                    return new Buffer(buf.array());
-                case SET_READ_PERCENTAGE:
-                    Double double_arg=(Double)call.getArgs()[0];
-                    buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.DOUBLE_SIZE);
-                    buf.put((byte)call.getId()).putDouble(double_arg);
-                    return new Buffer(buf.array());
-                default:
-                    throw new IllegalStateException(""method "" + call.getMethod() + "" not known"");
-            }
-        }
-
-
-
-        public Object objectFromBuffer(byte[] buffer, int offset, int length) throws Exception {
-            ByteBuffer buf=ByteBuffer.wrap(buffer, offset, length);
-
-            byte type=buf.get();
-            switch(type) {
-                case START:
-                case GET_CONFIG:
-                    return new MethodCall(type);
-                case SET_OOB:
-                case SET_SYNC:
-                case SET_MSB_BUNDLING:
-                case SET_USE_ANYCAST_ADDRS:
-                    return new MethodCall(type, buf.get() == 1);
-                case SET_NUM_MSGS:
-                case SET_NUM_THREADS:
-                case SET_MSG_SIZE:
-                case SET_ANYCAST_COUNT:
-                    return new MethodCall(type, buf.getInt());
-                case GET:
-                    return new MethodCall(type, buf.getLong());
-                case PUT:
-                    Long longarg=buf.getLong();
-                    int len=buf.getInt();
-                    byte[] arg2=new byte[len];
-                    buf.get(arg2, 0, arg2.length);
-                    return new MethodCall(type, longarg, arg2);
-                case SET_READ_PERCENTAGE:
-                    return new MethodCall(type, buf.getDouble());
-                default:
-                    throw new IllegalStateException(""type "" + type + "" not known"");
-            }
-        }
-
-        private static byte[] intBuffer(short type, Integer num) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.INT_SIZE);
-            buf.put((byte)type).putInt(num);
-            return buf.array();
-        }
-
-        private static byte[] longBuffer(short type, Long num) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE + Global.LONG_SIZE);
-            buf.put((byte)type).putLong(num);
-            return buf.array();
-        }
-
-        private static byte[] booleanBuffer(short type, Boolean arg) {
-            ByteBuffer buf=ByteBuffer.allocate(Global.BYTE_SIZE *2);
-            buf.put((byte)type).put((byte)(arg? 1 : 0));
-            return buf.array();
-        }
-    }
-
-
-    public static void main(String[] args) {
-        String  props=null;
-        String  name=null;
-        boolean xsite=true;
-
-
-        for(int i=0; i < args.length; i++) {
-            if(""-props"".equals(args[i])) {
-                props=args[++i];
-                continue;
-            }
-            if(""-name"".equals(args[i])) {
-                name=args[++i];
-                continue;
-            }
-            if(""-xsite"".equals(args[i])) {
-                xsite=Boolean.valueOf(args[++i]);
-                continue;
-            }
-            help();
-            return;
-        }
-
-        UPerf2 test=null;
-        try {
-            test=new UPerf2();
-            test.init(props, name, xsite);
-            test.eventLoop();
-        }
-        catch(Throwable ex) {
-            ex.printStackTrace();
-            if(test != null)
-                test.stop();
-        }
-    }
-
-    static void help() {
-        System.out.println(""UPerf [-props <props>] [-name name] [-xsite <true | false>]"");
-    }
-
-
-}
\ No newline at end of file",2014-01-10T16:46:08Z,131
"@@ -149,7 +149,8 @@ protected boolean addDiscoveryResponseToCaches(Address mbr, String logical_name,
 
     protected static String addressToFilename(Address mbr) {
         String logical_name=UUID.get(mbr);
-        return addressAsString(mbr) + (logical_name != null? ""."" + logical_name + SUFFIX : SUFFIX);
+        return (addressAsString(mbr) + (logical_name != null? ""."" + logical_name + SUFFIX : SUFFIX))
+            .replace(File.separatorChar, '-');
     }
 
     protected void createRootDir() {
@@ -364,4 +365,4 @@ public void run() {
     }
 
 
-}
\ No newline at end of file
+}",2015-06-19T13:46:53Z,111
"@@ -12,6 +12,7 @@
 
 import javax.crypto.*;
 import javax.crypto.spec.SecretKeySpec;
+
 import java.io.*;
 import java.security.*;
 import java.security.cert.CertificateException;
@@ -144,6 +145,9 @@ interface Observer {
     @Property(name=""sym_init"", description=""Initial key length for matching symmetric algorithm. Default is 128"")
     int symInit=128;
 
+    @Property(name=""change_keys"", description=""Generate new symmetric keys on every view change. Default is false"")
+    boolean changeKeysOnViewChange=false;
+
     // properties for functioning in supplied key mode
     private boolean suppliedKey=false;
 
@@ -524,6 +528,10 @@ public Object passItUp(Event evt) {
 
     private synchronized void handleViewChange(View view, boolean makeServer) {
 
+    	if ( makeServer) {
+    		initializeNewSymmetricKey();
+    	}
+    	
         // if view is a bit broken set me as keyserver
         List<Address> members = view.getMembers();
         if (members == null || members.isEmpty() || members.get(0) == null) { 
@@ -533,21 +541,36 @@ private synchronized void handleViewChange(View view, boolean makeServer) {
         // otherwise get keyserver from view controller
         Address tmpKeyServer=view.getMembers().get(0);
 
-        //I am new keyserver - either first member of group or old key server is no more and
+        //I am  keyserver - either first member of group or old key server is no more and
         // I have been voted new controller
-        if(makeServer || (tmpKeyServer.equals(local_addr) && (keyServerAddr == null || (!tmpKeyServer.equals(keyServerAddr))))) {
+        if(makeServer || (tmpKeyServer.equals(local_addr))) {
             becomeKeyServer(tmpKeyServer, makeServer);
-            // a new keyserver has been set and it is not me
-        }
-        else if(keyServerAddr == null || (!tmpKeyServer.equals(keyServerAddr)) || (keyServer && !tmpKeyServer.equals(local_addr))) {
-            handleNewKeyServer(tmpKeyServer);
         }
         else {
-            if(log.isDebugEnabled())
-                log.debug(""Membership has changed but I do not care"");
+            handleNewKeyServer(tmpKeyServer);
         }
     }
 
+	private void initializeNewSymmetricKey() {
+		try {
+			if ( changeKeysOnViewChange || !keyServer) {
+				if ( log.isDebugEnabled()) {
+					log.debug(""Initalizing new ciphers"");
+				}
+				initSymKey();
+				initSymCiphers(getSymAlgorithm(), getSecretKey());
+			}
+
+		} catch (Exception e) {
+			log.error(""Could not initialize new ciphers: {}"", e.getMessage());
+			if ( e instanceof RuntimeException) {
+				throw (RuntimeException)e;
+			} else {
+				throw new IllegalStateException(e);
+			}
+		}
+	}
+
     /**
      * Handles becoming server - resetting queue settings and setting keyserver
      * address to be local address.
@@ -571,20 +594,28 @@ private void becomeKeyServer(Address tmpKeyServer, boolean forced) {
      * @param newKeyServer
      */
     private void handleNewKeyServer(Address newKeyServer) {
-        // start queueing until we have new key
-        // to make sure we are not sending with old key
-        queue_up=true;
-        queue_down=true;
-        // set new keyserver address
-        keyServerAddr=newKeyServer;
-        keyServer=false;
-        if(log.isDebugEnabled())
-            log.debug(""["" + local_addr + ""] "" + keyServerAddr + "" has become the new key server, sending key request to it"");
+    	
+    	if ( changeKeysOnViewChange || keyServerChanged(newKeyServer)) {
+            // start queueing until we have new key
+            // to make sure we are not sending with old key
+            queue_up=true;
+            queue_down=true;
+            // set new keyserver address
+            keyServerAddr=newKeyServer;
+            keyServer=false;
+            if(log.isDebugEnabled())
+                log.debug(""["" + local_addr + ""] "" + keyServerAddr + "" has become the new key server, sending key request to it"");
 
-        // create a key request message
-        sendKeyRequest();
+            // create a key request message
+            sendKeyRequest();
+    		
+    	}
     }
 
+	private boolean keyServerChanged(Address newKeyServer) {
+		return keyServerAddr == null || !keyServerAddr.equals(newKeyServer);
+	}
+
 
     private void handleUpMessage(Event evt) throws Exception {
         Message msg=(Message)evt.getArg();",2013-12-20T17:17:31Z,132
"@@ -12,10 +12,12 @@
 import org.jgroups.protocols.ENCRYPT.EncryptHeader;
 import org.jgroups.stack.Protocol;
 import org.jgroups.util.Util;
+import org.testng.Assert;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.crypto.Cipher;
+
 import java.io.*;
 import java.security.MessageDigest;
 import java.security.Security;
@@ -197,11 +199,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
         Address serverAddress=new MockAddress(""server"");
 
         server.setLocal_addr(serverAddress);
-        //set the server up as keyserver
-        List<Address> serverVector=new ArrayList<Address>();
-        serverVector.add(serverAddress);
-        View tempView=new View(new ViewId(serverAddress, 1), serverVector);
-        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+        Event serverEvent = createViewChange( 1, serverAddress);
         server.up(serverEvent);
 
         // set up peer
@@ -306,11 +304,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Address serverAddress=new MockAddress(""server"");
         server.setLocal_addr(serverAddress);
 
-        //	set the server up as keyserver
-        List<Address> serverVector=new ArrayList<Address>() ;
-        serverVector.add(serverAddress);
-        View tempView=new View(new ViewId(serverAddress, 1), serverVector);
-        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+        Event serverEvent = createViewChange(1, serverAddress);
         server.up(serverEvent);
 
         // set up peer as if it has started but not recieved view change
@@ -345,12 +339,10 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
 
         //assert that message is queued as we have no key from server
         Util.assertTrue(peerObserver.getUpMessages().isEmpty());
-
-        // send a view change to peer where peer2 is  controller
-        List<Address> peerVector=new ArrayList<Address>() ;
-        peerVector.add(peer2Address);
-        View tempPeerView=new View(new ViewId(peer2Address, 1), peerVector);
-        Event event=new Event(Event.VIEW_CHANGE, tempPeerView);
+        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
+        Util.assertFalse(peerObserver.getUpMessages().isEmpty());
+        
+        Event event = createViewChange(2, peer2Address);
 
         // send to peer - should set peer2 as keyserver
         peer.up(event);
@@ -365,18 +357,9 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
 
-        //assume that server is no longer available and peer2 is new server
-        // but did not get the key from server before assuming role
-        // send this event to peer2
-//		 send a view change to trigger the become key server
-        // we use the fact that our address is now the controller one
-        // send a view change where we are not the controller
-        List<Address> peer2Vector=new ArrayList<Address>() ;
-        peer2Vector.add(peer2Address);
-        View tempPeer2View=new View(new ViewId(peer2Address, 1), peer2Vector);
-        Event event2=new Event(Event.VIEW_CHANGE, tempPeer2View);
+        
         // this should have changed us to the key server
-        peer2.up(event2);
+        peer2.up(event);
 
         peer2.up(sent);
 
@@ -390,6 +373,8 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         assert !server.getDesKey().equals(peer2.getDesKey());
 
         // now send back to peer
+        // TODO: The encrypted message encrypted by server secret key cannot be decrypted
+        // since peer does not have server's key
         peer.up(reply);
 
         // assert that both now have same key
@@ -409,17 +394,126 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
 
         peer.up(Evt2);
         // make sure we have the events now in the up layers
-        Util.assertEquals(2, peerObserver.getUpMessages().size());
+        Util.assertEquals(4, peerObserver.getUpMessages().size());
 
-        Event tempEvt=(Event)peerObserver.getUpMessages().get(""message2"");
+        Event tempEvt=getLatestUpMessage(peerObserver);
 
 
         Util.assertEquals(""hello2"", new String(((Message)tempEvt.getArg()).getBuffer()));
 
 
     }
 
+    public static void testKeyChangesDuringKeyServerChange() throws Exception {
+        // create peers and server
+        ENCRYPT peer=new ENCRYPT();
+        peer.init();
+
+        ENCRYPT server=new ENCRYPT();
+        server.init();
+
+        ENCRYPT peer2=new ENCRYPT();
+        peer2.init();
+
+        // set up server
+        server.keyServer=true;
+        MockObserver serverObserver=new MockObserver();
+        server.setObserver(serverObserver);
+
+        //set the local address and view change to simulate a started instance
+        Address serverAddress=new MockAddress(""server"");
+        server.setLocal_addr(serverAddress);
+
+        //	set the server up as keyserver
+        Event serverEvent = createViewChange(1, serverAddress);
+        server.up(new Event(Event.TMP_VIEW, serverEvent.getArg()));
+        server.up(serverEvent);
+
+        Address peerAddress=new MockAddress(""peer"");
+        peer.setLocal_addr(peerAddress);
+        MockObserver peerObserver=new MockObserver();
+        peer.setObserver(peerObserver);
+        peer.keyServer=false;
+        
+        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
+        
+
+        // set up peer2 with server as key server
+        Address peer2Address=new MockAddress(""peer2"");
+        peer2.setLocal_addr(peer2Address);
+        MockObserver peer2Observer=new MockObserver();
+        peer2.setObserver(peer2Observer);
+        peer2.keyServer=false;
+        updateViewFor(peer2, server, serverObserver, serverEvent, peer2Observer);
 
+        Assert.assertEquals(server.getDesKey(), peer.getDesKey());
+        Assert.assertEquals(server.getDesKey(), peer2.getDesKey());
+
+        // send an encrypted message from the server
+        Message msg=new Message();
+        msg.setBuffer(""hello"".getBytes());
+
+        Event viewChange2 = createViewChange(2, peer2Address);
+        peer2.up(new Event(Event.TMP_VIEW, viewChange2.getArg()));
+        peer2.up(viewChange2);
+
+        updateViewFor(peer, peer2, peer2Observer, viewChange2, peerObserver);
+
+        Assert.assertFalse(server.getDesKey().equals(peer.getDesKey()));
+        Assert.assertEquals(peer.getDesKey(), peer2.getDesKey());
+
+    }
+
+	private static void updateViewFor(ENCRYPT peer, ENCRYPT keyServer,
+			MockObserver serverObserver, Event serverEvent,
+			MockObserver peerObserver) {
+		peer.up(serverEvent);
+        Event peerKeyRequest = getLatestDownMessage(peerObserver);
+        keyServer.up(peerKeyRequest);
+        Event serverKeyToPeer = getLatestDownMessage(serverObserver);
+        peer.up(serverKeyToPeer);
+	}
+
+	private static Event createViewChange(int id, Address serverAddress, Address...addresses ) {
+		List<Address> serverVector=new ArrayList<Address>() ;
+        serverVector.add(serverAddress);
+        for ( Address a : addresses) {
+        	serverVector.add(a);
+        }
+        View tempView=new View(new ViewId(serverAddress, id), serverVector);
+        Event serverEvent=new Event(Event.VIEW_CHANGE, tempView);
+		return serverEvent;
+	}
+    
+    
+    static Event getLatestDownMessage(MockObserver observer) {
+    	Event latest = null;
+    	Map map = observer.getDownMessages();
+    	int counter = observer.counter-1;
+    	while ( latest == null && counter >= 0) {
+    		latest = (Event) map.get(""message"" + counter);
+    		counter--;
+    	}
+    	if ( latest == null) {
+    		throw new IllegalStateException(""Could not find latest down message"");
+    	}
+    	return latest;
+    }
+    
+    static Event getLatestUpMessage(MockObserver observer) {
+    	Event latest = null;
+    	Map map = observer.getUpMessages();
+    	int counter = observer.counter-1;
+    	while ( latest == null && counter >= 0) {
+    		latest = (Event) map.get(""message"" + counter);
+    		counter--;
+    	}
+    	if ( latest == null) {
+    		throw new IllegalStateException(""Could not find latest down message"");
+    	}
+    	return latest;
+    }
+    
     static class MockObserver implements ENCRYPT.Observer {
         private Map upMessages=new HashMap();
         private Map downMessages=new HashMap();",2013-12-20T17:17:31Z,132
"@@ -300,15 +300,41 @@ that node.
                 
 When the coordinator changes, or members not listed in the file join, the current coordinator
 writes the file again, so all members have access to the updated information when needed.
-                
 
 If a bootstrap discovery file is to be used, it needs to be placed into the file system or cloud
 store in the correct location and with the right name (see the Discovery section for naming details).
-                
 
 The design is discussed in more detail in
 link:$$https://github.com/belaban/JGroups/blob/master/doc/design/CloudBasedDiscovery.txt$$[CloudBasedDiscovery.txt]
-                
+
+
+===== Removal of zombie files
+
+By default, a new coordinator C never removes a file created by an old coordinator `A`. E.g. in `{A,B,C,D}` (with
+coordinator `A`), if `C` becomes coordinator on a split `{A,B} | {C,D}`, then `C` doesn't remove `A`'s file, as there
+is no way for `C` to know whether `A` crashed or whether `A` was partitioned away.
+
+Every coordinator `P` installs a shutdown hook which removes `P`'s file on termination. However, this doesn't apply
+to a process killed ungracefully, e.g. by `kill -9`. In this case, no shutdown hook will get called. If we had view
+`{A,B,C}`, and `A` was killed via kill -9, and `B` takes over, we'd have files `A.list` and `B.list`.
+
+To change this, attribute `remove_old_coords_on_view_change` can be set to true. In this case, files created by old
+coordinators will be removed. In the scenario above, where `A` crashed, `B` would remove `A.list`.
+
+However, if we have a split between `{A,B}` and `{C,D}`, `C` would remove `A.list`. To prevent this, every coordinator
+writes its file again on a view change that has left members or in which the coordinator changed.
+
+There is still a case which can end up with a zombie file that's never removed: when we have a single member `A` and
+it is killed via `kill -9`. In this case, file `A.list` will never get cleaned up and subsequent joiners will ask
+`A` to join, up to `GMS.max_join_attempts` times.
+
+Zombie cleanup can be solved by setting `remove_all_files_on_view_change` to true. In this case, a coordinator
+removes _all files_ on a view change that has members leaving or changes the coordinator.
+
+NOTE: Setting `remove_old_coords_on_view_change` or `remove_all_files_on_view_change` to true generates more traffic
+to the file system or cloud store. If members are always shut down gracefully, or never killed via `kill -9`, then
+it is recommended to set both attributes to false.
+
 
 ${FILE_PING}
 ",2015-03-03T11:16:01Z,133
"@@ -5,8 +5,10 @@
 import org.jgroups.PhysicalAddress;
 import org.jgroups.View;
 import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
 import org.jgroups.annotations.Property;
 import org.jgroups.util.Responses;
+import org.jgroups.util.TimeScheduler;
 import org.jgroups.util.UUID;
 import org.jgroups.util.Util;
 
@@ -15,6 +17,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 
 
 /**
@@ -36,6 +39,19 @@ public class FILE_PING extends Discovery {
     @Deprecated @Property(description=""Interval (in milliseconds) at which the own Address is written. 0 disables it."")
     protected long interval=60000;
 
+    @Property(description=""If true, on a view change, the new coordinator removes files from old coordinators"")
+    protected boolean remove_old_coords_on_view_change=false;
+
+    @Property(description=""If true, on a view change, the new coordinator removes all files except its own"")
+    protected boolean remove_all_files_on_view_change=false;
+
+    @Property(description=""The max number of times my own information should be written to the DB after a view change"")
+    protected int info_writer_max_writes_after_view=2;
+
+    @Property(description=""Interval (in ms) at which the info writer should kick in"")
+    protected long info_writer_sleep_time=10000;
+
+
     @ManagedAttribute(description=""Number of writes to the file system or cloud store"")
     protected int writes;
 
@@ -49,9 +65,16 @@ public class FILE_PING extends Discovery {
         public boolean accept(File dir, String name) {return name.endsWith(SUFFIX);}
     };
     protected volatile View               prev_view;
+    protected Future<?>                   info_writer;
 
     public boolean isDynamic() {return true;}
 
+    @ManagedAttribute(description=""Whether the InfoWriter task is running"")
+    public synchronized boolean isInfoWriterRunning() {return info_writer != null && !info_writer.isDone();}
+
+    @ManagedOperation(description=""Causes the member to write its own information into the DB, replacing an existing entry"")
+    public void writeInfo() {if(is_coord) writeAll();}
+
     public void init() throws Exception {
         super.init();
         createRootDir();
@@ -144,12 +167,24 @@ protected void createRootDir() {
 
     // remove all files which are not from the current members
     protected void handleView(View new_view, View old_view, boolean coord_changed) {
-        if(coord_changed) {
-            if(is_coord)
+        if(is_coord) {
+            if(coord_changed) {
+                if(remove_all_files_on_view_change)
+                    removeAll(cluster_name);
+                else if(remove_old_coords_on_view_change) {
+                    Address old_coord=old_view != null? old_view.getCreator() : null;
+                    if(old_coord != null)
+                        remove(cluster_name, old_coord);
+                }
+            }
+            if(coord_changed || View.diff(old_view, new_view)[1].length > 0) {
                 writeAll();
-            else
-                remove(cluster_name, local_addr);
+                if(remove_all_files_on_view_change || remove_old_coords_on_view_change)
+                    startInfoWriter();
+            }
         }
+        else if(coord_changed) // I'm no longer the coordinator
+            remove(cluster_name, local_addr);
     }
 
     protected void remove(String clustername, Address addr) {
@@ -167,6 +202,18 @@ protected void remove(String clustername, Address addr) {
         deleteFile(file);
     }
 
+    /** Removes all files except the member passed as argument (can be null) */
+    protected void removeAll(String clustername) {
+        if(clustername == null)
+            return;
+        File dir=new File(root_dir, clustername);
+        if(!dir.exists())
+            return;
+        File[] files=dir.listFiles(filter); // finds all files ending with '.list'
+        for(File file: files)
+            file.delete();
+    }
+
 
 
     protected void readAll(List<Address> members, String clustername, Responses responses) {
@@ -281,5 +328,40 @@ protected boolean deleteFile(File file) {
         return result;
     }
 
+    protected synchronized void startInfoWriter() {
+        if(info_writer == null || info_writer.isDone())
+            info_writer=timer.scheduleWithDynamicInterval(new InfoWriter(info_writer_max_writes_after_view, info_writer_sleep_time));
+    }
+
+    protected synchronized void stopInfoWriter() {
+        if(info_writer != null)
+            info_writer.cancel(false);
+    }
+
+
+    /** Class which calls writeAll() a few times. Started after a view change in which an old coord left */
+    protected class InfoWriter implements TimeScheduler.Task {
+        protected final int  max_writes;
+        protected int        num_writes;
+        protected final long sleep_interval;
+
+        public InfoWriter(int max_writes, long sleep_interval) {
+            this.max_writes=max_writes;
+            this.sleep_interval=sleep_interval;
+        }
+
+        @Override
+        public long nextInterval() {
+            if(++num_writes > max_writes)
+                return 0; // discontinues this task
+            return Math.max(1000, Util.random(sleep_interval));
+        }
+
+        @Override
+        public void run() {
+            writeAll();
+        }
+    }
+
 
 }
\ No newline at end of file",2015-03-03T11:16:01Z,111
"@@ -1,7 +1,5 @@
 package org.jgroups.protocols;
 
-import org.jgroups.annotations.Property;
-
 /**
  * Discovery protocol for Google Cloud Storage. Very simple first shot at an impl, based on a simple migration of
  * S3_PING, as discussed in [1].<p/>
@@ -12,15 +10,15 @@
  */
 public class GOOGLE_PING extends S3_PING {
 
-    @Property(description=""The name of the Google Cloud Storage server"")
-    protected String host=""storage.googleapis.com"";
-
     public void init() throws Exception {
+        if(host == null)
+            host=""storage.googleapis.com"";
         super.init();
     }
 
     protected AWSAuthConnection createConnection() {
-        return new AWSAuthConnection(access_key, secret_access_key, false, host);
+        return port > 0? new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, port)
+          : new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, Utils.INSECURE_PORT);
     }
 }
 ",2015-03-03T11:16:01Z,134
"@@ -112,6 +112,13 @@ protected void remove(String clustername, Address addr) {
         rackspaceClient.deleteObject(container, fileName);
     }
 
+    @Override
+    protected void removeAll(String clustername) {
+        List<String> objects = rackspaceClient.listObjects(container);
+        for(String objName: objects) {
+            rackspaceClient.deleteObject(container, objName);
+        }
+    }
 
     /**
      * A thread safe Rackspace ReST client",2015-03-03T11:16:01Z,135
"@@ -32,6 +32,15 @@
  */
 public class S3_PING extends FILE_PING {
 
+    @Property(description=""The name of the AWS server"")
+    protected String host;
+
+    @Property(description=""The port at which AWS is listening"")
+    protected int port;
+
+    @Property(description=""Whether or not to use SSL to connect to host:port"")
+    protected boolean use_ssl=true;
+
     @Property(description=""The access key to AWS (S3)"",exposeAsManagedAttribute=false)
     protected String access_key;
 
@@ -56,9 +65,9 @@ public class S3_PING extends FILE_PING {
   
     public void init() throws Exception {
         super.init();
-
+        if(host == null)
+            host=Utils.DEFAULT_HOST;
         validateProperties();
-
         conn=createConnection();
 
         if(prefix != null && !prefix.isEmpty()) {
@@ -92,7 +101,8 @@ public void init() throws Exception {
     }
 
     protected AWSAuthConnection createConnection() {
-        return new AWSAuthConnection(access_key, secret_access_key);
+        return port > 0? new AWSAuthConnection(access_key, secret_access_key, use_ssl, host, port)
+          : new AWSAuthConnection(access_key, secret_access_key, use_ssl, host);
     }
 
     @Override
@@ -207,6 +217,36 @@ protected void remove(String clustername, Address addr) {
         }
     }
 
+    @Override
+    protected void removeAll(String clustername) {
+        if(clustername == null)
+            return;
+
+        try {
+            Map headers=new TreeMap();
+            headers.put(""Content-Type"", Arrays.asList(""text/plain""));
+            clustername=sanitize(clustername);
+            ListBucketResponse rsp=conn.listBucket(location, clustername, null, null, null);
+            if(rsp.entries != null) {
+                for(Iterator<ListEntry> it=rsp.entries.iterator(); it.hasNext();) {
+                    ListEntry key=it.next();
+                    try {
+                        if (usingPreSignedUrls())
+                            conn.delete(pre_signed_delete_url).connection.getResponseMessage();
+                        else
+                            conn.delete(location, key.key, headers).connection.getResponseMessage();
+                        log.trace(""removing %s/%s"", location, key.key);
+                    }
+                    catch(Throwable t) {
+                        log.error(""failed deleting object %s/%s: %s"", location, key.key, t);
+                    }
+                }
+            }
+        }
+        catch(IOException ex) {
+            log.error(""failed deleting all objects"", ex);
+        }
+    }
 
     protected void validateProperties() {
         if (pre_signed_put_url != null && pre_signed_delete_url != null) {",2015-03-03T11:16:01Z,109
"@@ -151,6 +151,18 @@ protected void remove(String clustername, Address addr) {
     }
 
 
+    @Override
+    protected void removeAll(String clustername) {
+        try {
+            List<String> objects=swiftClient.listObjects(container);
+            for(String objName : objects) {
+                swiftClient.deleteObject(container, objName);
+            }
+        }
+        catch(Exception t) {
+            log.error(""failed removing objects"", t);
+        }
+    }
 
 
 ",2015-03-03T11:16:01Z,136
"@@ -1,17 +1,5 @@
 package org.jgroups.protocols;
 
-import static org.testng.AssertJUnit.assertTrue;
-
-import java.io.IOException;
-
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.NameCallback;
-import javax.security.auth.callback.PasswordCallback;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.sasl.AuthorizeCallback;
-import javax.security.sasl.RealmCallback;
-
 import org.jgroups.Global;
 import org.jgroups.JChannel;
 import org.jgroups.protocols.pbcast.GMS;
@@ -21,13 +9,20 @@
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
+import javax.security.auth.callback.*;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+import java.io.IOException;
+
+import static org.testng.AssertJUnit.assertTrue;
+
 @Test(groups = Global.FUNCTIONAL, singleThreaded = true)
 public class SASLTest {
     private static final String REALM = ""MyRealm"";
     private JChannel a;
     private JChannel b;
 
-    private JChannel createChannel(String channelName, String mech, String username) throws Exception {
+    private static JChannel createChannel(String channelName,String mech,String username) throws Exception {
         SASL sasl = new SASL();
         sasl.setMech(mech);
         sasl.setCallbackHandler(new MyCallbackHandler(username));",2014-03-29T07:50:42Z,56
"@@ -44,7 +44,7 @@
  * The {@link #receive(Address, byte[], int, int)} method must
  * be called by subclasses when a unicast or multicast message has been received.
  * @author Bela Ban
- * @version $Id: TP.java,v 1.276 2009/11/05 08:44:22 belaban Exp $
+ * @version $Id: TP.java,v 1.277 2009/11/12 09:07:42 belaban Exp $
  */
 @MBean(description=""Transport protocol"")
 @DeprecatedProperty(names={""bind_to_all_interfaces"", ""use_incoming_packet_handler"", ""use_outgoing_packet_handler"",
@@ -99,6 +99,9 @@ public abstract class TP extends Protocol {
                       description=""Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on"")
     protected List<NetworkInterface> receive_interfaces=null;
 
+    @Property
+    @Deprecated
+    int marshaller_pool_size=0;
 
 
     /** The port to which the transport binds. 0 means to bind to any (ephemeral) port */
@@ -157,8 +160,8 @@ public abstract class TP extends Protocol {
 
     @ManagedAttribute
     @Property(name=""oob_thread_pool.rejection_policy"",
-                      description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Run"")
-    String oob_thread_pool_rejection_policy=""Run"";
+              description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Discard"")
+    String oob_thread_pool_rejection_policy=""discard"";
 
     @ManagedAttribute(description=""Minimum thread pool size for regular messages. Default is 2"")
     @Property(name=""thread_pool.min_threads"",description=""Minimum thread pool size for regular messages. Default is 2"")
@@ -190,8 +193,8 @@ public abstract class TP extends Protocol {
 
     @ManagedAttribute
     @Property(name=""thread_pool.rejection_policy"",
-                      description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run Default is Run"")
-    protected String thread_pool_rejection_policy=""Run"";
+              description=""Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Discard"")
+    protected String thread_pool_rejection_policy=""Discard"";
 
     @ManagedAttribute(description=""Number of threads to be used by the timer thread pool"")
     @Property(name=""timer.num_threads"",description=""Number of threads to be used by the timer thread pool. Default is 4"")",2009-11-12T09:07:42Z,85
"@@ -74,7 +74,7 @@ public Object up(Event evt) {
                 if(hdr.fork_stack_id == null)
                     throw new IllegalArgumentException(""header has a null fork_stack_id"");
                 Protocol bottom_prot=get(hdr.fork_stack_id);
-                return bottom_prot.up(evt);
+                return bottom_prot != null? bottom_prot.up(evt) : null;
 
             case Event.VIEW_CHANGE:
                 for(Protocol bottom: fork_stacks.values())
@@ -105,6 +105,8 @@ public void up(MessageBatch batch) {
             String fork_stack_id=entry.getKey();
             List<Message> list=entry.getValue();
             Protocol bottom_prot=get(fork_stack_id);
+            if(bottom_prot == null)
+                continue;
             MessageBatch mb=new MessageBatch(batch.dest(), batch.sender(), batch.clusterName(), batch.multicast(), list);
             try {
                 bottom_prot.up(mb);",2014-06-10T06:31:57Z,137
"@@ -72,4 +72,6 @@
     <class id=""109"" name=""org.jgroups.protocols.PERF$PerfHeader""/>
     <class id=""110"" name=""org.jgroups.blocks.MethodCall""/>
     <class id=""111"" name=""org.jgroups.util.ExtendedUUID""/>
+    <class id=""112"" name=""org.jgroups.protocols.SaslHeader""/>
 </magic-number-class-mapping>
+",2014-03-27T08:30:01Z,138
"@@ -62,6 +62,7 @@
     <class id=""65"" name=""org.jgroups.protocols.FORK""/>
     <class id=""66"" name=""org.jgroups.protocols.PERF""/>
     <class id=""67"" name=""org.jgroups.protocols.SHARED_LOOPBACK_PING""/>
+    <class id=""68"" name=""org.jgroups.protocols.SASL""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2014-03-27T08:30:01Z,104
"@@ -0,0 +1,81 @@
+package org.jgroups.auth.sasl;
+
+import java.util.Map;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.Sasl;
+import javax.security.sasl.SaslClient;
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SASL;
+import org.jgroups.protocols.SaslHeader;
+import org.jgroups.protocols.SaslHeader.Type;
+
+public class SaslClientContext implements SaslContext {
+    private static final byte[] EMPTY_CHALLENGE = new byte[0];
+    SaslClient client;
+
+    public SaslClientContext(String mech, Address local_addr, CallbackHandler callback_handler, Map<String, String> props) throws SaslException {
+        client = Sasl.createSaslClient(new String[] { mech }, null, ""jgroups"", local_addr.toString(), props,
+                callback_handler);
+    }
+
+    @Override
+    public boolean isSuccessful() {
+        return client.isComplete();
+    }
+
+    @Override
+    public boolean needsWrapping() {
+        if (client.isComplete()) {
+            String qop = (String) client.getNegotiatedProperty(Sasl.QOP);
+            return (qop != null && (qop.equalsIgnoreCase(""auth-int"") || qop.equalsIgnoreCase(""auth-conf"")));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException {
+        return client.wrap(outgoing, offset, len);
+    }
+
+    @Override
+    public byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException {
+        return client.unwrap(incoming, offset, len);
+    }
+
+    @Override
+    public Message nextMessage(Address address, SaslHeader header) throws SaslException {
+        Message message = new Message(address).setFlag(Message.Flag.OOB);
+        return addHeader(message, header.getPayload());
+    }
+
+    @Override
+    public void dispose() {
+        try {
+            client.dispose();
+        } catch (SaslException e) {
+        }
+    }
+
+    public Message addHeader(Message msg, byte[] payload) throws SaslException {
+        byte[] response;
+        if (payload == null) {
+            if (client.hasInitialResponse()) {
+                response = client.evaluateChallenge(EMPTY_CHALLENGE);
+            } else {
+                response = EMPTY_CHALLENGE;
+            }
+        } else {
+            response = client.evaluateChallenge(payload);
+        }
+        if (response != null) {
+            return msg.putHeader(SASL.SASL_ID, new SaslHeader(Type.RESPONSE, response));
+        } else {
+            return null;
+        }
+    }
+}",2014-03-27T08:30:01Z,139
"@@ -0,0 +1,21 @@
+package org.jgroups.auth.sasl;
+
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SaslHeader;
+
+public interface SaslContext {
+    boolean isSuccessful();
+
+    boolean needsWrapping();
+
+    byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException;
+
+    byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException;
+
+    void dispose();
+
+    Message nextMessage(Address address, SaslHeader saslHeader) throws SaslException;
+}",2014-03-27T08:30:01Z,140
"@@ -0,0 +1,80 @@
+package org.jgroups.auth.sasl;
+
+import org.jgroups.Address;
+import org.jgroups.Message;
+import org.jgroups.protocols.SASL;
+import org.jgroups.protocols.SaslHeader;
+import org.jgroups.protocols.SaslHeader.Type;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.Sasl;
+import javax.security.sasl.SaslException;
+import javax.security.sasl.SaslServer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public class SaslServerContext implements SaslContext {
+    SaslServer server;
+    CountDownLatch latch = new CountDownLatch(1);
+
+    public SaslServerContext(String mech, Address local_addr, CallbackHandler callback_handler, Map<String, String> props) throws SaslException {
+        server = Sasl.createSaslServer(mech, ""jgroups"", local_addr.toString(), props, callback_handler);
+    }
+
+    @Override
+    public boolean isSuccessful() {
+        return server.isComplete();
+    }
+
+    @Override
+    public boolean needsWrapping() {
+        if (server.isComplete()) {
+            String qop = (String) server.getNegotiatedProperty(Sasl.QOP);
+            return (qop != null && (qop.equalsIgnoreCase(""auth-int"") || qop.equalsIgnoreCase(""auth-conf"")));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte[] wrap(byte[] outgoing, int offset, int len) throws SaslException {
+        return server.wrap(outgoing, offset, len);
+    }
+
+    @Override
+    public byte[] unwrap(byte[] incoming, int offset, int len) throws SaslException {
+        return server.unwrap(incoming, offset, len);
+    }
+
+    @Override
+    public Message nextMessage(Address address, SaslHeader header) throws SaslException {
+        Message message = new Message(address).setFlag(Message.Flag.OOB);
+        byte[] challenge = server.evaluateResponse(header.getPayload());
+        if (server.isComplete()) {
+            latch.countDown();
+        }
+        if (challenge != null) {
+            return message.putHeader(SASL.SASL_ID, new SaslHeader(Type.RESPONSE, challenge));
+        } else {
+            return null;
+        }
+    }
+
+    public void awaitCompletion(long timeout) throws InterruptedException {
+        latch.await(timeout, TimeUnit.MILLISECONDS);
+    }
+
+    public String getAuthorizationID() {
+        return server.getAuthorizationID();
+    }
+
+    @Override
+    public void dispose() {
+        try {
+            server.dispose();
+        } catch (SaslException e) {
+        }
+    }
+
+}
\ No newline at end of file",2014-03-27T08:30:01Z,141
"@@ -14,16 +14,18 @@
 import java.util.Collection;
 import java.util.Enumeration;
 import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.Callable;
 
 /**
  * Groups a set of standard PropertyConverter(s) supplied by JGroups.
- * 
+ *
  * <p>
  * Third parties can provide their own converters if such need arises by implementing
  * {@link PropertyConverter} interface and by specifying that converter as converter on a specific
  * Property annotation of a field or a method instance.
- * 
+ *
  * @author Vladimir Blagojevic
  */
 public class PropertyConverters {
@@ -39,7 +41,7 @@ public String toString(Object value) {
             return Util.print(list);
         }
     }
-    
+
     public static class FlushInvoker implements PropertyConverter {
 
 		public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
@@ -55,7 +57,7 @@ public Object convert(Object obj, Class<?> propertyFieldType, String propertyNam
 		public String toString(Object value) {
 			return value.getClass().getName();
 		}
-    	
+
     }
 
     public static class InitialHosts implements PropertyConverter {
@@ -82,15 +84,15 @@ public String toString(Object value) {
             else
                 return value.getClass().getName();
 		}
-		
+
         private static int getPortRange(Protocol protocol) throws Exception {
             Field f = protocol.getClass().getDeclaredField(""port_range"") ;
             return ((Integer) Util.getField(f,protocol)).intValue();
 		}
     }
-    
+
     public static class InitialHosts2 implements PropertyConverter {
-    	
+
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String prop_val, boolean check_scope) throws Exception {
 			// port range is 1
             return Util.parseCommaDelimitedHosts2(prop_val, 1);
@@ -114,35 +116,35 @@ public String toString(Object value) {
                 return value.getClass().getName();
         }
     }
-    
+
     public static class BindInterface implements PropertyConverter {
 
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
-       	
+
         	// get the existing bind address - possibly null
         	InetAddress	old_bind_addr = (InetAddress)Configurator.getValueFromProtocol((Protocol)obj, ""bind_addr"");
-        	
+
         	// apply a bind interface constraint
             InetAddress new_bind_addr = Util.validateBindAddressFromInterface(old_bind_addr, propertyValue);
-            
+
             if (new_bind_addr != null)
             	setBindAddress((Protocol)obj, new_bind_addr) ;
 
             // if no bind_interface specified, set it to the empty string to avoid exception
             // from @Property processing
             if (propertyValue != null)
             	return propertyValue ;
-            else 
+            else
             	return """" ;
         }
 
-        
+
         private static void setBindAddress(Protocol protocol, InetAddress bind_addr) throws Exception {
             Field f=Util.getField(protocol.getClass(), ""bind_addr"");
 			Util.setField(f, protocol, bind_addr) ;
 		}
-        
-        
+
+
         // return a String version of the converted value
         public String toString(Object value) {
             return (String) value ;
@@ -176,7 +178,7 @@ public String toString(Object value) {
             return sb.toString();
         }
     }
-    
+
     public static class LongArray implements PropertyConverter {
 
         public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
@@ -206,6 +208,32 @@ public String toString(Object value) {
         }
     }
 
+    public static class StringProperties implements PropertyConverter {
+
+        @Override
+        public Object convert(Object obj, Class<?> propertyFieldType, String propertyName, String propertyValue, boolean check_scope) throws Exception {
+            return Util.parseCommaDelimitedProps(propertyValue);
+        }
+
+        @Override
+        public String toString(Object value) {
+            if (value == null)
+                return null;
+            Map<String, String> v = (Map<String, String>) value;
+            StringBuilder sb = new StringBuilder();
+            boolean first = true;
+            for(Entry<String, String> entry : v.entrySet()) {
+                if (!first)
+                    sb.append("","");
+                else
+                    first = false;
+                sb.append(entry.getKey()).append(""="").append(entry.getValue());
+            }
+            return sb.toString();
+        }
+
+    }
+
 
     public static class Default implements PropertyConverter {
         static final String prefix;",2014-03-27T08:30:01Z,142
"@@ -0,0 +1,322 @@
+package org.jgroups.protocols;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.sasl.SaslException;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.Property;
+import org.jgroups.auth.sasl.SaslClientContext;
+import org.jgroups.auth.sasl.SaslContext;
+import org.jgroups.auth.sasl.SaslServerContext;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.conf.PropertyConverters;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.GMS.GmsHeader;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.MessageBatch;
+
+/**
+ * The SASL protocol implements authentication and, if requested by the mech, encryption
+ *
+ * @author Tristan Tarrant
+ */
+@MBean(description = ""Provides SASL authentication"")
+public class SASL extends Protocol {
+    public static final short GMS_ID = ClassConfigurator.getProtocolId(GMS.class);
+    public static final short SASL_ID = ClassConfigurator.getProtocolId(SASL.class);
+
+    @Property(name = ""mech"", description = ""The name of the mech to require for authentication. Can be any mech supported by your local SASL provider. The JDK comes standard with CRAM-MD5, DIGEST-MD5, GSSAPI, NTLM"")
+    protected String mech;
+
+    @Property(name = ""sasl_props"", description = ""Properties specific to the chosen mech"", converter = PropertyConverters.StringProperties.class)
+    protected Map<String, String> sasl_props = new HashMap<String, String>();
+
+    @Property(name = ""timeout"", description = ""How long to wait (in ms) for a response to a challenge"")
+    protected long timeout = 5000;
+
+    protected CallbackHandler callback_handler;
+
+    protected Address local_addr;
+    protected final Map<Address, SaslContext> sasl_context = new HashMap<Address, SaslContext>();
+
+
+
+    public SASL() {
+        name = this.getClass().getSimpleName();
+    }
+
+    @Property(name = ""callback_handler_class"")
+    public void setCallbackHandlerClass(String handlerClass) throws Exception {
+        callback_handler = Class.forName(handlerClass).asSubclass(CallbackHandler.class).newInstance();
+    }
+
+    public String getCallbackHandlerClass() {
+        return callback_handler != null ? callback_handler.getClass().getName() : null;
+    }
+
+    public CallbackHandler getCallbackHandler() {
+        return callback_handler;
+    }
+
+    public void setCallbackHandler(CallbackHandler callback_handler) {
+        this.callback_handler = callback_handler;
+    }
+
+    public void setMech(String mech) {
+        this.mech = mech;
+    }
+
+    public String getMech() {
+        return mech;
+    }
+
+    public void setSaslProps(Map<String, String> sasl_props) {
+        this.sasl_props = sasl_props;
+    }
+
+    public Map<String, String> getSaslProps() {
+        return sasl_props;
+    }
+
+    public void setTimeout(long timeout) {
+        this.timeout = timeout;
+    }
+
+    public long getTimeout() {
+        return timeout;
+    }
+
+    public Address getAddress() {
+        return local_addr;
+    }
+
+    @Override
+    public void init() throws Exception {
+        super.init();
+    }
+
+    @Override
+    public void stop() {
+        super.stop();
+        cleanup();
+    }
+
+    @Override
+    public void destroy() {
+        super.destroy();
+        cleanup();
+    }
+
+    private void cleanup() {
+        for(SaslContext context : sasl_context.values()) {
+            context.dispose();
+        }
+        sasl_context.clear();
+    }
+
+    @Override
+    public Object up(Event evt) {
+        if (evt.getType() == Event.MSG) {
+            Message msg = (Message) evt.getArg();
+            SaslHeader saslHeader = (SaslHeader) msg.getHeader(SASL_ID);
+            GmsHeader gmsHeader = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(gmsHeader)) {
+                if (saslHeader == null)
+                    throw new IllegalStateException(""Found GMS join or merge request but no SASL header"");
+                if (!serverChallenge(gmsHeader, saslHeader, msg))
+                    return null; // failed auth, don't pass up
+            } else if (saslHeader != null) {
+                Address remoteAddress = msg.getSrc();
+                SaslContext saslContext = sasl_context.get(remoteAddress);
+                if (saslContext == null) {
+                    throw new IllegalStateException(String.format(
+                            ""Cannot find server context to challenge SASL request from %s"", remoteAddress.toString()));
+                }
+                switch (saslHeader.getType()) {
+                case CHALLENGE:
+                    try {
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: received CHALLENGE from %s"", getAddress(), remoteAddress);
+                        Message response = saslContext.nextMessage(remoteAddress, saslHeader);
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: sending RESPONSE to %s"", getAddress(), remoteAddress);
+                        down_prot.down(new Event(Event.MSG, response));
+                    } catch (SaslException e) {
+                        disposeContext(remoteAddress);
+                        if (log.isWarnEnabled()) {
+                            log.warn(""failed to validate CHALLENGE from "" + remoteAddress + "", token"", e);
+                        }
+                        sendRejectionMessage(gmsHeader.getType(), remoteAddress, ""authentication failed"");
+                    }
+                    break;
+                case RESPONSE:
+                    try {
+                        if (log.isTraceEnabled())
+                            log.trace(""%s: received RESPONSE from %s"", getAddress(), remoteAddress);
+                        Message challenge = saslContext.nextMessage(remoteAddress, saslHeader);
+                        if (challenge != null) {
+                            if (log.isTraceEnabled())
+                                log.trace(""%s: sending CHALLENGE to %s"", getAddress(), remoteAddress);
+
+                            down_prot.down(new Event(Event.MSG, challenge));
+                        } else {
+                            if (log.isTraceEnabled())
+                                log.trace(""%s: authentication complete from %s"", getAddress(), remoteAddress);
+                        }
+                    } catch (SaslException e) {
+                        disposeContext(remoteAddress);
+                        if (log.isWarnEnabled()) {
+                            log.warn(""failed to validate RESPONSE from "" + remoteAddress + "", token"", e);
+                        }
+                    }
+                    break;
+                }
+                return null;
+            }
+        }
+
+        return up_prot.up(evt);
+    }
+
+    private void disposeContext(Address address) {
+        SaslContext context = sasl_context.remove(address);
+        if (context != null) {
+            context.dispose();
+        }
+    }
+
+    @Override
+    public void up(MessageBatch batch) {
+        for (Message msg : batch) {
+            // If we have a join or merge request --> authenticate, else pass up
+            GmsHeader gmsHeader = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(gmsHeader)) {
+                SaslHeader saslHeader = (SaslHeader) msg.getHeader(id);
+                if (saslHeader == null) {
+                    log.warn(""Found GMS join or merge request but no SASL header"");
+                    sendRejectionMessage(gmsHeader.getType(), batch.sender(), ""join or merge without an SASL header"");
+                    batch.remove(msg);
+                } else if (!serverChallenge(gmsHeader, saslHeader, msg)) // authentication failed
+                    batch.remove(msg); // don't pass up
+            }
+        }
+
+        if (!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+    @Override
+    public Object down(Event evt) {
+        switch (evt.getType()) {
+        case Event.SET_LOCAL_ADDRESS:
+            local_addr = (Address) evt.getArg();
+            break;
+        case Event.MSG:
+            Message msg = (Message) evt.getArg();
+            GmsHeader hdr = (GmsHeader) msg.getHeader(GMS_ID);
+            if (needsAuthentication(hdr)) {
+                // We are a client who needs to authenticate
+                SaslClientContext ctx = null;
+                Address remoteAddress = msg.getDest();
+                try {
+                    ctx = new SaslClientContext(mech, remoteAddress, callback_handler, sasl_props);
+                    sasl_context.put(remoteAddress, ctx);
+                    ctx.addHeader(msg, null);
+                } catch (SaslException e) {
+                    if (ctx != null) {
+                        disposeContext(remoteAddress);
+                    }
+                    throw new SecurityException(e);
+                }
+            }
+            break;
+        }
+
+        return down_prot.down(evt);
+    }
+
+    protected static boolean needsAuthentication(GmsHeader hdr) {
+        return (hdr != null)
+                && (hdr.getType() == GmsHeader.JOIN_REQ || hdr.getType() == GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER || hdr
+                        .getType() == GmsHeader.MERGE_REQ);
+    }
+
+    protected boolean serverChallenge(GmsHeader gmsHeader, SaslHeader saslHeader, Message msg) {
+        switch (gmsHeader.getType()) {
+        case GmsHeader.JOIN_REQ:
+        case GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+        case GmsHeader.MERGE_REQ:
+            Address remoteAddress = msg.getSrc();
+            SaslServerContext ctx = null;
+            try {
+                ctx = new SaslServerContext(mech, local_addr, callback_handler, sasl_props);
+                sasl_context.put(remoteAddress, ctx);
+                this.getDownProtocol().down(new Event(Event.MSG, ctx.nextMessage(remoteAddress, saslHeader)));
+                ctx.awaitCompletion(timeout);
+                if (ctx.isSuccessful()) {
+                    if (log.isDebugEnabled()) {
+                        log.debug(""Authorization successful for %s"", ctx.getAuthorizationID());
+                    }
+                    return true;
+                } else {
+                    log.warn(""failed to validate SaslHeader from %s, header: %s"", msg.getSrc(), saslHeader);
+                    sendRejectionMessage(gmsHeader.getType(), msg.getSrc(), ""authentication failed"");
+                    return false;
+                }
+            } catch (SaslException e) {
+                log.warn(""failed to validate SaslHeader from %s, header: %s"", msg.getSrc(), saslHeader);
+                sendRejectionMessage(gmsHeader.getType(), msg.getSrc(), ""authentication failed"");
+            } catch (InterruptedException e) {
+                return false;
+            } finally {
+                if (ctx != null && !ctx.needsWrapping()) {
+                    disposeContext(remoteAddress);
+                }
+            }
+        default:
+            return true; // pass up
+        }
+    }
+
+    protected void sendRejectionMessage(byte type, Address dest, String error_msg) {
+        switch (type) {
+        case GmsHeader.JOIN_REQ:
+        case GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            sendJoinRejectionMessage(dest, error_msg);
+            break;
+        case GmsHeader.MERGE_REQ:
+            sendMergeRejectionMessage(dest);
+            break;
+        default:
+            log.error(""type "" + type + "" unknown"");
+            break;
+        }
+    }
+
+    protected void sendJoinRejectionMessage(Address dest, String error_msg) {
+        if (dest == null)
+            return;
+
+        JoinRsp joinRes = new JoinRsp(error_msg); // specify the error message on the JoinRsp
+        Message msg = new Message(dest).putHeader(GMS_ID, new GmsHeader(GmsHeader.JOIN_RSP)).setBuffer(
+                GMS.marshal(joinRes));
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+
+    protected void sendMergeRejectionMessage(Address dest) {
+        Message msg = new Message(dest).setFlag(Message.Flag.OOB);
+        GmsHeader hdr = new GmsHeader(GmsHeader.MERGE_RSP);
+        hdr.setMergeRejected(true);
+        msg.putHeader(GMS_ID, hdr);
+        if (log.isDebugEnabled())
+            log.debug(""merge response="" + hdr);
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+}",2014-03-27T08:30:01Z,143
"@@ -0,0 +1,76 @@
+package org.jgroups.protocols;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+import org.jgroups.Header;
+import org.jgroups.util.Util;
+
+public class SaslHeader extends Header {
+    public enum Type {
+        CHALLENGE, RESPONSE
+    };
+
+    private Type type;
+    private byte[] payload;
+
+    public SaslHeader() {
+    }
+
+    public SaslHeader(Type type, byte[] payload) {
+        this.type = type;
+        this.payload = payload;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+
+    public void setPayload(byte[] payload) {
+        this.payload = payload;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public SaslHeader payload(byte[] payload) {
+        this.payload = payload;
+        return this;
+    }
+
+    public byte[] token() {
+        return payload;
+    }
+
+    public SaslHeader type(Type type) {
+        this.type = type;
+        return this;
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type.ordinal());
+        Util.writeByteBuffer(payload, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        type = Type.values()[in.readByte()];
+        payload = Util.readByteBuffer(in);
+    }
+
+    @Override
+    public int size() {
+        return Util.size(payload);
+    }
+
+    @Override
+    public String toString() {
+        return ""payload="" + payload;
+    }
+}",2014-03-27T08:30:01Z,144
"@@ -17,6 +17,7 @@
 
 import javax.management.MBeanServer;
 import javax.management.MBeanServerFactory;
+
 import java.io.*;
 import java.lang.annotation.Annotation;
 import java.lang.management.ManagementFactory;
@@ -313,20 +314,20 @@ public static short getScope(Message msg) {
         SCOPE.ScopeHeader hdr=(SCOPE.ScopeHeader)msg.getHeader(Global.SCOPE_ID);
         return hdr != null? hdr.getScope() : 0;
     }
-    
+
    public static byte[] createAuthenticationDigest(String passcode, long t1, double q1) throws IOException,
             NoSuchAlgorithmException {
       ByteArrayOutputStream baos = new ByteArrayOutputStream(512);
       DataOutputStream out = new DataOutputStream(baos);
       byte[] digest = createDigest(passcode, t1, q1);
       out.writeLong(t1);
-      out.writeDouble(q1);      
+      out.writeDouble(q1);
       out.writeInt(digest.length);
       out.write(digest);
       out.flush();
       return baos.toByteArray();
    }
-   
+
     public static byte[] createDigest(String passcode, long t1, double q1)
       throws IOException, NoSuchAlgorithmException {
         MessageDigest md = MessageDigest.getInstance(""SHA"");
@@ -402,12 +403,12 @@ public static void shutdown(Channel ch) throws Exception {
         ProtocolStack stack=ch.getProtocolStack();
         TP transport=stack.getTransport();
         stack.insertProtocol(discard,  ProtocolStack.ABOVE, transport.getClass());
-        
+
         //abruptly shutdown FD_SOCK just as in real life when member gets killed non gracefully
         FD_SOCK fd = (FD_SOCK) ch.getProtocolStack().findProtocol(FD_SOCK.class);
         if(fd != null)
             fd.stopServerSocket(false);
-        
+
         View view=ch.getView();
         if (view != null) {
             ViewId vid = view.getViewId();
@@ -499,7 +500,7 @@ public static Object objectFromByteBuffer(byte[] buffer, int offset, int length)
 
     /**
      * Serializes/Streams an object into a byte buffer.
-     * The object has to implement interface Serializable or Externalizable or Streamable. 
+     * The object has to implement interface Serializable or Externalizable or Streamable.
      */
     public static byte[] objectToByteBuffer(Object obj) throws Exception {
         if(obj == null)
@@ -1145,7 +1146,7 @@ public static Object readObject(DataInput in) throws Exception {
         int len=in.readInt();
         if(len == -1)
             return readGenericStreamable(in);
-        
+
         byte[] buf=new byte[len];
         in.readFully(buf, 0, len);
         return objectFromByteBuffer(buf);
@@ -2091,7 +2092,7 @@ public static <T> T pickNext(List<T> list, T obj) {
         return null;
     }
 
-    /** Returns the next min(N,list.size()) elements after obj */ 
+    /** Returns the next min(N,list.size()) elements after obj */
     public static <T> List<T> pickNext(List<T> list, T obj, int num) {
         List<T> retval=new ArrayList<T>();
         if(list == null || list.size() < 2)
@@ -2651,6 +2652,16 @@ public static List<String> parseStringList(String l, String separator) {
          return tmp;
      }
 
+    public static Map<String, String> parseCommaDelimitedProps(String s) {
+        Map<String, String> props = new HashMap<String, String>();
+        Pattern p = Pattern.compile(""\\s*([^=\\s]+)\\s*=\\s*([^=\\s,]+)\\s*,?""); //Pattern.compile(""\\s*([^=\\s]+)\\s*=\\s([^=\\s]+)\\s*,?"");
+        Matcher matcher = p.matcher(s);
+        while(matcher.find()) {
+            props.put(matcher.group(1), matcher.group(2));
+        }
+        return props;
+    }
+
 
     /**
      * Reads and discards all characters from the input stream until a \r\n or EOF is encountered
@@ -2967,7 +2978,7 @@ public static MulticastSocket createMulticastSocket(SocketFactory factory, Strin
                 String type=mcast_addr != null ? mcast_addr instanceof Inet4Address? ""IPv4"" : ""IPv6"" : ""n/a"";
                 sb.append(""could not bind to "" + mcast_addr + "" ("" + type + "" address)"");
                 sb.append(""; make sure your mcast_addr is of the same type as the preferred IP stack (IPv4 or IPv6)"");
-                sb.append("" by checking the value of the system properties java.net.preferIPv4Stack and java.net.preferIPv6Addresses."");                
+                sb.append("" by checking the value of the system properties java.net.preferIPv4Stack and java.net.preferIPv6Addresses."");
                 sb.append(""\nWill ignore mcast_addr, but this may lead to cross talking "" +
                         ""(see http://www.jboss.org/community/docs/DOC-9469 for details). "");
                 sb.append(""\nException was: "" + ex);
@@ -2983,16 +2994,16 @@ public static MulticastSocket createMulticastSocket(SocketFactory factory, Strin
 
     /**
      * Method used by PropertyConverters.BindInterface to check that a bind_address is
-     * consistent with a specified interface 
-     * 
+     * consistent with a specified interface
+     *
      * Idea:
      * 1. We are passed a bind_addr, which may be null
-     * 2. If non-null, check that bind_addr is on bind_interface - if not, throw exception, 
+     * 2. If non-null, check that bind_addr is on bind_interface - if not, throw exception,
      * otherwise, return the original bind_addr
      * 3. If null, get first non-loopback address on bind_interface, using stack preference to
      * get the IP version. If no non-loopback address, then just return null (i.e. the
      * bind_interface did not influence the decision).
-     * 
+     *
      */
     public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr, String bind_interface_str) throws UnknownHostException, SocketException {
     	NetworkInterface bind_intf=null;
@@ -3003,10 +3014,10 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     	// 1. if bind_interface_str is null, or empty, no constraint on bind_addr
     	if (bind_interface_str == null || bind_interface_str.trim().isEmpty())
     		return bind_addr;
-    	
-    	// 2. get the preferred IP version for the JVM - it will be IPv4 or IPv6 
+
+    	// 2. get the preferred IP version for the JVM - it will be IPv4 or IPv6
     	StackType ip_version = getIpStackType();
-    	
+
     	// 3. if bind_interface_str specified, get interface and check that it has correct version
     	bind_intf=Util.getByName(bind_interface_str); // NetworkInterface.getByName(bind_interface_str);
     	if(bind_intf != null) {
@@ -3033,7 +3044,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     			InetAddress address = (InetAddress) addresses.nextElement() ;
 
     			// check if address is on interface
-    			if (bind_addr.equals(address)) { 
+    			if (bind_addr.equals(address)) {
     				hasAddress = true ;
     				break ;
     			}
@@ -3045,7 +3056,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     		}
 
     	}
-    	// 4. if only interface is specified, get first non-loopback address on that interface, 
+    	// 4. if only interface is specified, get first non-loopback address on that interface,
     	else {
     		bind_addr = getAddress(bind_intf, AddressScope.NON_LOOPBACK) ;
     	}
@@ -3058,7 +3069,7 @@ public static InetAddress validateBindAddressFromInterface(InetAddress bind_addr
     	if(bind_addr != null && NetworkInterface.getByInetAddress(bind_addr) == null) {
     		throw new UnknownHostException(""Invalid bind address "" + bind_addr);
     	}
-    	
+
     	// if bind_addr == null, we have tried to obtain a bind_addr but were not successful
     	// in such a case, return the original value of null so the default will be applied
 
@@ -3092,7 +3103,7 @@ public static boolean checkForLinux() {
     public static boolean checkForHp() {
        return checkForPresence(""os.name"", ""hp"");
     }
- 
+
     public static boolean checkForSolaris() {
         return checkForPresence(""os.name"", ""sun"");
     }
@@ -3270,13 +3281,13 @@ public static InetAddress getAddress(NetworkInterface intf, AddressScope scope)
         return null ;
     }
 
-    
+
 
 
     /**
-     * A function to check if an interface supports an IP version (i.e has addresses 
+     * A function to check if an interface supports an IP version (i.e has addresses
      * defined for that IP version).
-     * 
+     *
      * @param intf
      * @return
      */
@@ -3301,8 +3312,8 @@ public static boolean interfaceHasIPAddresses(NetworkInterface intf, StackType i
             throw new UnknownHostException(""network interface "" + intf + "" not found"") ;
         }
         return supportsVersion ;
-    }         
-        
+    }
+
     public static StackType getIpStackType() {
        return ip_stack_type;
     }
@@ -3344,7 +3355,7 @@ else if (isIPv4StackAvailable && isIPv6StackAvailable) {
 		}
 		return StackType.Unknown;
     }
-    
+
 
 
 	public static boolean isStackAvailable(boolean ipv4) {
@@ -3354,8 +3365,8 @@ public static boolean isStackAvailable(boolean ipv4) {
                 return true;
         return false;
     }
-    
-	
+
+
     public static List<NetworkInterface> getAllAvailableInterfaces() throws SocketException {
         List<NetworkInterface> retval=new ArrayList<NetworkInterface>(10);
         NetworkInterface intf;
@@ -3384,7 +3395,7 @@ public static Collection<InetAddress> getAllAvailableAddresses() {
         catch(SocketException e) {
             e.printStackTrace();
         }
-        
+
         return retval;
     }
 
@@ -3398,7 +3409,7 @@ public static void checkIfValidAddress(InetAddress bind_addr, String prot_name)
         }
         throw new BindException(""["" + prot_name + ""] "" + bind_addr + "" is not a valid address on any local network interface"");
     }
-    
+
 
 
     /**",2014-03-27T08:30:01Z,54
"@@ -0,0 +1,106 @@
+package org.jgroups.protocols;
+
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.io.IOException;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.Test;
+
+@Test(groups = Global.FUNCTIONAL, singleThreaded = true)
+public class SASLTest {
+    private static final String REALM = ""MyRealm"";
+    private JChannel a;
+    private JChannel b;
+
+    private JChannel createChannel(String channelName, String mech, String username) throws Exception {
+        SASL sasl = new SASL();
+        sasl.setMech(mech);
+        sasl.setCallbackHandler(new MyCallbackHandler(username));
+        sasl.setTimeout(5000);
+        sasl.sasl_props.put(""com.sun.security.sasl.digest.realm"", REALM);
+        return new JChannel(
+                new Protocol[] {
+                        new SHARED_LOOPBACK(),
+                        new PING(),
+                        new NAKACK2(),
+                        new UNICAST3(),
+                        new STABLE(),
+                        sasl,
+                        new GMS() }
+                ).name(channelName);
+    }
+
+    public void testSASLDigestMD5() throws Exception {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jack"");
+        a.connect(""SaslTest"");
+        b.connect(""SaslTest"");
+        assertTrue(b.isConnected());
+    }
+
+
+    @Test(expectedExceptions=SecurityException.class)
+    public void testSASLDigestMD5Failure() throws Throwable {
+        a = createChannel(""A"", ""DIGEST-MD5"", ""jack"");
+        b = createChannel(""B"", ""DIGEST-MD5"", ""jill"");
+        a.connect(""SaslTest"");
+        try {
+            b.connect(""SaslTest"");
+        } catch (Exception e) {
+            if (e.getCause() != null)
+                throw e.getCause();
+        }
+    }
+
+    @AfterMethod
+    public void cleanup() {
+        a.close();
+        b.close();
+    }
+
+
+    public static class MyCallbackHandler implements CallbackHandler {
+        final private String password;
+
+        public MyCallbackHandler(String password) {
+            this.password = password;
+        }
+
+        @Override
+        public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+            for(Callback callback : callbacks) {
+                if (callback instanceof NameCallback) {
+                    NameCallback nameCallback = (NameCallback)callback;
+                    nameCallback.setName(""user"");
+                } else if (callback instanceof PasswordCallback) {
+                    PasswordCallback passwordCallback = (PasswordCallback)callback;
+                    passwordCallback.setPassword(password.toCharArray());
+                } else if (callback instanceof AuthorizeCallback) {
+                    AuthorizeCallback authorizeCallback = (AuthorizeCallback)callback;
+                    authorizeCallback.setAuthorized(authorizeCallback.getAuthenticationID().equals(authorizeCallback.getAuthorizationID()));
+                } else if (callback instanceof RealmCallback) {
+                    RealmCallback realmCallback = (RealmCallback) callback;
+                    realmCallback.setText(REALM);
+                } else {
+                    throw new UnsupportedCallbackException(callback);
+                }
+            }
+        }
+
+    }
+}",2014-03-27T08:30:01Z,56
"@@ -11,6 +11,7 @@
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.List;
+import java.util.Map;
 
 /**
  * @author Bela Ban
@@ -59,6 +60,15 @@ public static void testNetworkList() throws Exception {
         assert str.equals(loopback_name) || str.equals(""lo0"");
     }
 
+    public static void testStringProperties() throws Exception {
+        PropertyConverter c = new PropertyConverters.StringProperties();
+
+        String value = ""com.sun.security.sasl.digest.realm=MyRealm,qop=true"";
+        Map<String, String> map = (Map<String, String>) c.convert(null, Map.class, ""props"", value, false);
+        assert map.size() == 2;
+        assert map.get(""qop"").equals(""true"");
+        assert map.get(""com.sun.security.sasl.digest.realm"").equals(""MyRealm"");
+    }
 
     private static void check(Protocol protocol, Class<?> type, String prop, Object result, PropertyConverter converter) throws Exception {
         Object tmp=converter.convert(protocol, type, ""bela"", prop, false);
@@ -87,4 +97,5 @@ private static String getLoopbackName() throws SocketException {
         }
         return null;
     }
+
 }",2014-03-27T08:30:01Z,145
"@@ -35,7 +35,7 @@
  * Discovery protocol using Amazon's S3 storage. The S3 access code reuses the example shipped by Amazon.
  * This protocol is unsupported and experimental !
  * @author Bela Ban
- * @version $Id: S3_PING.java,v 1.12 2010/09/16 14:57:17 belaban Exp $
+ * @version $Id: S3_PING.java,v 1.13 2010/09/17 19:36:37 benbrowning Exp $
  */
 @Experimental
 public class S3_PING extends FILE_PING {
@@ -49,6 +49,12 @@ public class S3_PING extends FILE_PING {
     @Property(description=""When non-null, we set location to prefix-UUID"")
     protected String prefix=null;
 
+    @Property(description=""When non-null, we use this pre-signed URL for PUTs"")
+    protected String pre_signed_put_url=null;
+
+    @Property(description=""When non-null, we use this pre-signed URL for DELETEs"")
+    protected String pre_signed_delete_url=null;
+
     protected AWSAuthConnection conn=null;
 
 
@@ -58,6 +64,8 @@ public void init() throws Exception {
         //if(access_key == null || secret_access_key == null)
           //  throw new IllegalArgumentException(""access_key and secret_access_key must be non-null"");
 
+        validateProperties();
+
         conn=new AWSAuthConnection(access_key, secret_access_key);
 
         if(prefix != null && prefix.length() > 0) {
@@ -80,6 +88,10 @@ public void init() throws Exception {
             }
         }
 
+        if(usingPreSignedUrls()) {
+            PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+            location = parsedPut.getBucket();
+        }
 
         if(!conn.checkBucketExists(location)) {
             conn.createBucket(location, AWSAuthConnection.LOCATION_DEFAULT, null).connection.getResponseMessage();
@@ -102,6 +114,10 @@ protected List<PingData> readAll(String clustername) {
 
         List<PingData> retval=new ArrayList<PingData>();
         try {
+            if (usingPreSignedUrls()) {
+                PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+                clustername = parsedPut.getPrefix();
+            }
             ListBucketResponse rsp=conn.listBucket(location, clustername, null, null, null);
             if(rsp.entries != null) {
                 for(Iterator<ListEntry> it=rsp.entries.iterator(); it.hasNext();) {
@@ -137,11 +153,18 @@ protected void writeToFile(PingData data, String clustername) {
         String filename=local_addr instanceof org.jgroups.util.UUID? ((org.jgroups.util.UUID)local_addr).toStringLong() : local_addr.toString();
         String key=clustername + ""/"" + filename;
         try {
-            Map headers=new TreeMap();
-            headers.put(""Content-Type"", Arrays.asList(""text/plain""));
             byte[] buf=Util.objectToByteBuffer(data);
             S3Object val=new S3Object(buf, null);
-            conn.put(location, key, val, headers).connection.getResponseMessage();
+
+            if (pre_signed_put_url != null) {
+                Map headers = new TreeMap();
+                headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+                conn.put(pre_signed_put_url, val, headers).connection.getResponseMessage();
+            } else {
+                Map headers=new TreeMap();
+                headers.put(""Content-Type"", Arrays.asList(""text/plain""));
+                conn.put(location, key, val, headers).connection.getResponseMessage();
+            }
         }
         catch(Exception e) {
             log.error(""failed marshalling "" + data + "" to buffer"", e);
@@ -157,7 +180,11 @@ protected void remove(String clustername, Address addr) {
         try {
             Map headers=new TreeMap();
             headers.put(""Content-Type"", Arrays.asList(""text/plain""));
-            conn.delete(location, key, headers).connection.getResponseMessage();
+            if (pre_signed_delete_url != null) {
+                conn.delete(pre_signed_delete_url).connection.getResponseMessage();
+            } else {
+                conn.delete(location, key, headers).connection.getResponseMessage();
+            }
             if(log.isTraceEnabled())
                 log.trace(""removing "" + location + ""/"" + key);
         }
@@ -167,7 +194,103 @@ protected void remove(String clustername, Address addr) {
     }
 
 
+    protected void validateProperties() {
+        if (pre_signed_put_url != null && pre_signed_delete_url != null) {
+            PreSignedUrlParser parsedPut = new PreSignedUrlParser(pre_signed_put_url);
+            PreSignedUrlParser parsedDelete = new PreSignedUrlParser(pre_signed_delete_url);
+            if (!parsedPut.getBucket().equals(parsedDelete.getBucket()) ||
+                    !parsedPut.getPrefix().equals(parsedDelete.getPrefix())) {
+                throw new IllegalArgumentException(""pre_signed_put_url and pre_signed_delete_url must have the same path"");
+            }
+        } else if (pre_signed_put_url != null || pre_signed_delete_url != null) {
+            throw new IllegalArgumentException(""pre_signed_put_url and pre_signed_delete_url must both be set or both unset"");
+        }
+    }
+    
+    protected boolean usingPreSignedUrls() {
+        return pre_signed_put_url != null;
+    }
+
+
+    /**
+     * Use this helper method to generate pre-signed S3 urls for use with S3_PING.
+     * You'll need to generate urls for both the put and delete http methods.
+     * Example:
+     * Your AWS Access Key is ""abcd"".
+     * Your AWS Secret Access Key is ""efgh"".
+     * You want this node to write its information to ""/S3_PING/DemoCluster/node1"".
+     * So, your bucket is ""S3_PING"" and your key is ""DemoCluster/node1"".
+     * You want this to expire one year from now, or
+     *   (System.currentTimeMillis / 1000) + (60 * 60 * 24 * 365)
+     *   Let's assume that this equals 1316286684
+     * 
+     * Here's how to generate the value for the pre_signed_put_url property:
+     * String putUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
+     *                                              ""S3_Ping"", ""DemoCluster/node1"",
+     *                                              1316286684);
+     *                                              
+     * Here's how to generate the value for the pre_signed_delete_url property:
+     * String deleteUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
+     *                                                 ""S3_Ping"", ""DemoCluster/node1"",
+     *                                                 1316286684);
+     * 
+     * @param awsAccessKey Your AWS Access Key
+     * @param awsSecretAccessKey Your AWS Secret Access Key
+     * @param method The HTTP method - use ""put"" or ""delete"" for use with S3_PING
+     * @param bucket The S3 bucket you want to write to
+     * @param key The key within the bucket to write to
+     * @param expirationDate The date this pre-signed url should expire, in seconds since epoch
+     * @return The pre-signed url to be used in pre_signed_put_url or pre_signed_delete_url properties
+     */
+    public static String generatePreSignedUrl(String awsAccessKey, String awsSecretAccessKey, String method,
+                                       String bucket, String key, long expirationDate) {
+        Map headers = new HashMap();
+        if (method.equalsIgnoreCase(""PUT"")) {
+            headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+        }
+        return Utils.generateQueryStringAuthentication(awsAccessKey, awsSecretAccessKey, method,
+                                                       bucket, key, new HashMap(), headers,
+                                                       expirationDate);
+    }
+
+
+
+    /**
+     * Utility class to parse S3 pre-signed URLs
+     */
+    static class PreSignedUrlParser {
+        String bucket = """";
+        String prefix = """";
+
+        public PreSignedUrlParser(String preSignedUrl) {
+            try {
+                URL url = new URL(preSignedUrl);
+                String path = url.getPath();
+                String[] pathParts = path.split(""/"");
+                
+                if (pathParts.length < 3) {
+                    throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" must point to a file within a bucket"");
+                }
+                if (pathParts.length > 4) {
+                    throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" may only have only subdirectory under a bucket"");
+                }
+                this.bucket = pathParts[1];
+                if (pathParts.length > 3) {
+                    this.prefix = pathParts[2];
+                }
+            } catch (MalformedURLException ex) {
+                throw new IllegalArgumentException(""pre-signed url "" + preSignedUrl + "" is not a valid url"");
+            }
+        }
 
+        public String getBucket() {
+            return bucket;
+        }
+        
+        public String getPrefix() {
+            return prefix;
+        }
+    }
 
     
 
@@ -355,6 +478,14 @@ public Response put(String bucket, String key, S3Object object, Map headers) thr
             return new Response(request);
         }
 
+        public Response put(String preSignedUrl, S3Object object, Map headers) throws IOException {
+            HttpURLConnection request = makePreSignedRequest(""PUT"", preSignedUrl, headers);
+            request.setDoOutput(true);
+            request.getOutputStream().write(object.data == null? new byte[]{} : object.data);
+
+            return new Response(request);
+        }
+
         /**
          * Creates a copy of an existing S3 Object.  In this signature, we will copy the
          * existing metadata.  The default access control policy is private; if you want
@@ -444,6 +575,10 @@ public Response delete(String bucket, String key, Map headers) throws IOExceptio
             return new Response(makeRequest(""DELETE"", bucket, Utils.urlencode(key), null, headers));
         }
 
+        public Response delete(String preSignedUrl) throws IOException {
+            return new Response(makePreSignedRequest(""DELETE"", preSignedUrl, null));
+        }
+
         /**
          * Get the requestPayment xml document for a given bucket
          * @param bucket  The name of the bucket
@@ -642,6 +777,16 @@ private HttpURLConnection makeRequest(String method, String bucket, String key,
             return connection;
         }
 
+        private HttpURLConnection makePreSignedRequest(String method, String preSignedUrl, Map headers) throws IOException {
+            URL url = new URL(preSignedUrl);
+            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod(method);
+
+            addHeaders(connection, headers);
+
+            return connection;
+        }
+
         /**
          * Add the given headers to the HttpURLConnection.
          * @param connection The HttpURLConnection to which the headers will be added.
@@ -1644,6 +1789,30 @@ static CallingFormat getCallingFormatForBucket(CallingFormat desiredFormat, Stri
             }
             return callingFormat;
         }
+
+        public static String generateQueryStringAuthentication(String awsAccessKey, String awsSecretAccessKey,
+                                                               String method, String bucket, String key,
+                                                               Map pathArgs, Map headers) {
+            int defaultExpiresIn = 300; // 5 minutes
+            long expirationDate = (System.currentTimeMillis() / 1000) + defaultExpiresIn;
+            return generateQueryStringAuthentication(awsAccessKey, awsSecretAccessKey,
+                                                     method, bucket, key,
+                                                     pathArgs, headers, expirationDate);
+        }
+
+        public static String generateQueryStringAuthentication(String awsAccessKey, String awsSecretAccessKey,
+                                                               String method, String bucket, String key,
+                                                               Map pathArgs, Map headers, long expirationDate) {
+            method = method.toUpperCase(); // Method should always be uppercase
+            String canonicalString =
+                makeCanonicalString(method, bucket, key, pathArgs, headers, """" + expirationDate);
+            String encodedCanonical = encode(awsSecretAccessKey, canonicalString, true);
+            return ""http://"" + DEFAULT_HOST + ""/"" + bucket + ""/"" + key + ""?"" +
+                ""AWSAccessKeyId="" + awsAccessKey + ""&Expires="" + expirationDate +
+                ""&Signature="" + encodedCanonical;
+            // connection.setRequestProperty(""Authorization"",
+            //                               ""AWS "" + this.awsAccessKeyId + "":"" + encodedCanonical);
+        }
     }
 
 ",2010-09-17T19:36:37Z,109
"@@ -0,0 +1,132 @@
+package org.jgroups.protocols;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.jgroups.Global;
+import org.jgroups.protocols.S3_PING.Utils;
+import org.testng.Assert;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+@Test(groups={Global.STACK_INDEPENDENT})
+public class S3_PINGTest {
+    private S3_PING ping;
+
+    @BeforeMethod
+    public void setUp() {
+        ping = new S3_PING();
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithPreSignedPutSet() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithPreSignedDeleteSet() {
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButNoBucket() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButNoFile() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket"";
+        ping.validateProperties();
+    }
+    
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testValidatePropertiesWithBothPreSignedSetButTooManySubdirectories() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/subdir/DemoCluster/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testValidatePropertiesWithBothPreSignedSetToValid() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testValidatePropertiesWithBothPreSignedSetToValidSubdirectory() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.pre_signed_delete_url = ""http://s3.amazonaws.com/test-bucket/DemoCluster/node1"";
+        ping.validateProperties();
+    }
+    
+    @Test
+    public void testUsingPreSignedUrlWhenNotSet() {
+        Assert.assertFalse(ping.usingPreSignedUrls());
+    }
+    
+    @Test
+    public void testUsingPreSignedUrlWhenSet() {
+        ping.pre_signed_put_url = ""http://s3.amazonaws.com/test-bucket/node1"";
+        Assert.assertTrue(ping.usingPreSignedUrls());
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicGet() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""get"",
+                                                    ""test-bucket"", ""node1"",
+                                                    new HashMap(), new HashMap(),
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicPost() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""POST"",
+                                                    ""test-bucket"", ""node1"",
+                                                    new HashMap(), new HashMap(),
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
+        Map headers = new HashMap();
+        headers.put(""x-amz-acl"", Arrays.asList(""public-read""));
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String encodedUrl =
+            Utils.generateQueryStringAuthentication(""abcd"", ""efgh"", ""put"",
+                                                    ""test-bucket"", ""subdir/node1"",
+                                                    new HashMap(), headers,
+                                                    1234567890);
+        Assert.assertEquals(encodedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGeneratePreSignedUrlForPut() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D"";
+        String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""put"",
+                                                           ""test-bucket"", ""subdir/node1"",
+                                                           1234567890);
+        Assert.assertEquals(preSignedUrl, expectedUrl);
+    }
+    
+    @Test
+    public void testGeneratePreSignedUrlForDelete() {
+        String expectedUrl = ""http://s3.amazonaws.com/test-bucket/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D"";
+        String preSignedUrl = S3_PING.generatePreSignedUrl(""abcd"", ""efgh"", ""delete"",
+                                                           ""test-bucket"", ""subdir/node1"",
+                                                           1234567890);
+        Assert.assertEquals(preSignedUrl, expectedUrl);
+    }
+}
\ No newline at end of file",2010-09-17T19:36:37Z,110
"@@ -0,0 +1,167 @@
+
+New UNICAST design
+==================
+(see UNICAST.txt for the old design)
+
+Author: Bela Ban
+Version: $Id: UNICAST.new.txt,v 1.2 2009/04/24 14:49:44 belaban Exp $
+
+Motivation
+----------
+
+UNICAST has issues when one end of the connnection unilaterally closes the connection and discards the state in
+the connection table.
+
+Example: we have a conn between A and B. There's a partition such that A sees {A,B} but B sees only {B}.
+B will clear its connection table for A on reception of the view, whereas A will keep it.
+
+Now the partition heals and A and B can communicate again.
+
+Assuming A's next seqno to B is #25 (and #7 for receiving messages from B),
+B will store the message because it expects #1 from A (new connection). As a matter of fact, B will store *and not
+deliver* all subsequent messages from A !
+
+The reverse direction is also bad: B will send #1 to A, but A expects #7, so A will discard the message. The first 6
+messages from B are discarded at A !
+
+
+Goals
+-----
+
+#1 Handle the above scenarios
+
+#2 Handle the scenario where a member communicates with a non-member (get rid of enabled_mbrs and prev_mbrs)
+
+#3 Handle the scenario where a member talks to a non existing (or previous) member. Get rid of
+   ENABLE_UNICASTS_TO and age out connections to non existing members after some time (JGRP-942)
+
+#4 Should be usable without group communication ('Unicast JGroups')
+
+
+Design
+------
+
+As example we have a unicast connection between A and B. A is the sender and B the receiver:
+
+             A <-------------------------------------------------> B
+
+             B:entry.seqno=#25                                     A:entry.seqno=#7
+                     recv_win=#7                                           recv_win=#25
+                     send-conn-id=322649                                   send-conn-id=101200
+                     recv-conn-id=101200                                   recv-conn-id=322649
+
+A has an entry in the connection table for B, and B has an entry for A. Each connection has a connection ID (conn-id).
+Each entry also has a seqno which is the highest seqno sent to the peer so far, and a recv_win which has the highest
+seqno received from the peer so far. For example, A's next message to B will be #25, and the next seqno expected
+from B is #7.
+
+
+
+A sends a message to B:
+- If the entry for B is null, or the seqno=0:
+    - Create an entry, set the seqno to 1 and set send-conn-id to the current time (needs to be unique, could also use UUIDs)
+    - Add send-conn-id to the UnicastHeader and send the message
+- Else
+    - Send the message with the next seqno (and conn-id=0)
+
+B receives a message from A:
+- If conn-id == 0
+    - If entry.recv_win != null:
+        - Add message to entry.recv_win
+    - Else
+        - Discard message
+        - Send GET_FIRST_SEQNO to A
+- Else
+    - If entry or entry.recv_win for B is null
+        - Create a new entry.recv_win with msg.seqno
+        - Set entry.recv-conn-id to conn-id
+    - Else:
+        - If conn-id != entry.recv-conn-id:
+            - Create a new entry.recv_win with msg.seqno
+            - Set entry.recv-conn-id to conn-id
+        - Else
+            - NOP (prevents duplicate connection establishments)
+
+
+
+A receives GET_FIRST_SEQNO from B:
+- A grabs the first message in its sent_win
+- A adds the entry.send-conn-id to the UnicastHeader (if not yet present) and sends the message to B
+
+
+
+Scenarios
+---------
+
+#1 A creates new connection to B:
+- The entry for B is null, a new entry is created and added to the connection table
+- Entry.send-conn-id is set and sent with the message
+- Entry.seqno now is 1
+
+
+#2 B receives new connection:
+- B creates a new entry and entry.recv_win (with msg.seqno) for A
+- B sets entry.recv-conn-id to msg.conn-id
+- B adds the message to entry.recv_win
+
+
+#3 A and B close connection (e.g. based on a view change (partition)):
+- Both A and B reset (cancelling pending retransmissions) and remove the entry for their peer from the connection table
+
+
+#4 A closes the connection unilaterally (B keeps it open), then reopens it and sends a message:
+- A removes the entry for B from its connection table, cancelling all pending retransmissions
+- (Assuming that B's entry.recv_win for A is at #25)
+- A creates a new entry for B in its connection table
+- Entry.send-conn-id is set and sent with the message
+- Entry.seqno now is 1
+- B receives the message with a new conn-id
+- B does have an entry for A, but entry.recv-conn-id doesn't match msg.conn-id
+- B creates a new entry.recv_win, sets it to msg.seqno
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+#5 B closes its connection unilaterally, then A sends a message to B:
+- B doesn't find an entry for A in its connection table
+- B discards the message and sends a SEND-FIRST-SEQNO to A
+- A receives the SEND-FIRST-SEQNO message. It grabs the message with the lowest seqno
+  in its entry.send_win, adds a UnicastHeader with entry.send-conn-id and sends the
+  message to B
+- B receive the message and creates a new entry and entry.recv_win (with msg.seqno)
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+#6 Merge where A and B are in different partitions:
+- Both A and B removes the entries for each other in their respective connection tables
+- When the partition heals, both A and B will create new entries (see scenario #2)
+
+
+#7 Merge where A and B are in overlapping partitions A: {A}, B: {A,B}:
+- (This case is currently handled by shunning, not merging)
+- A sends a message to B
+- A removed its entry for B, but B kept its entry for A
+- A new creates a new connection to B (scenario #1) and sends the message
+- B receives the message, but entry.recv-conn-id doesn't match msg.conn-id, so B
+  removes entry.recv_win, sets entry.recv-conn-id to msg.conn-id and creates a new
+  entry.recv_win with msg.seqno (same as second half of scenario #4)
+
+
+#8 Merge where A and B are in overlapping partitions A: {A,B}, B: {B}:
+- A sends a message to B (msg.seqno=25)
+- B doesn't have an entry for A
+- B discards the message and sends a SEND-FIRST-SEQNO to A
+- A receives the SEND-FIRST-SEQNO message. It grabs the message with the lowest seqno
+  in its entry.send_win, adds a UnicastHeader with entry.send-conn-id and sends the
+  message to B
+- B receive the message and creates a new entry and entry.recv_win (with msg.seqno)
+- B sets entry.recv-conn-id to msg.conn-id
+
+
+Issues
+------
+- How do we handle retransmissions of the first message (first=true) ? We *cannot* create a new entry.recv_win, or
+  else we trash already received msgs ! Use a UUID (as connection-ID) instead of first=true ? Maybe the system time
+  is sufficient ? After all, the ID only has to be unique between A and B !
+  ==> Solved by using connection IDs (see above)
+
+",2009-04-24T14:48:33Z,146
"@@ -0,0 +1,365 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.FD;
+import org.jgroups.protocols.FD_ALL;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Digest;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.AfterTest;
+
+import java.util.*;
+
+/**
+ * Tests overlapping merges, e.g. A: {A,B}, B: {A,B} and C: {A,B,C}. Tests unicast as well as multicast seqno tables.<br/>
+ * Related JIRA: https://jira.jboss.org/jira/browse/JGRP-940
+ * @author Bela Ban
+ * @version $Id: OverlappingMergeTest.java,v 1.2 2009/04/24 14:48:33 belaban Exp $
+ */
+@Test(groups=Global.STACK_DEPENDENT,sequential=true)
+public class OverlappingMergeTest extends ChannelTestBase {
+    private JChannel a, b, c;
+    private MyReceiver ra, rb, rc;
+
+    @BeforeTest
+    protected void start() throws Exception {
+        ra=new MyReceiver(""A""); rb=new MyReceiver(""B""); rc=new MyReceiver(""C"");
+        a=createChannel(true, 3);
+        a.setReceiver(ra);
+
+        b=createChannel(a);
+        b.setReceiver(rb);
+
+        c=createChannel(a); 
+        c.setReceiver(rc);
+        modifyConfigs(a, b, c);
+
+        a.connect(""OverlappingMergeTest"");
+        b.connect(""OverlappingMergeTest"");
+        c.connect(""OverlappingMergeTest"");
+        View view=c.getView();
+        assert view.size() == 3 : ""view is "" + view;
+    }
+
+    @AfterTest
+    protected void stop() throws Exception {
+        Util.close(c,b,a);
+        ra.clear(); rb.clear(); rc.clear();
+    }
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}, disable shunning in all members. A is the coordinator
+     * <li/>MERGE2 is removed from all members
+     * <li/>VERIFY_SUSPECT is removed from all members
+     * <li/>Everyone sends 5 unicast messages to everyone else
+     * <li/>Everyone sends 5 multicasts
+     * <li/>A SUSPECT(A) event is injected into B's stack (GMS). This causes a new view {B,C} to be multicast by B
+     * <li/>B and C install {B,C}
+     * <li/>B and C trash the connection table for A in UNICAST
+     * <li/>A ignores the view, it still has view {A,B,C} and all connection tables intact in UNICAST
+     * <li/>We now inject a MERGE(A,B) event into A. This should ause A and B as coords to create a new MergeView {A,B,C}
+     * <li/>The merge already fails because the unicast between A and B fails due to the reason given below !
+     *      Once this is fixed, the next step below should work, too !
+     * <li/>A sends a unicast to B and C. This should fail until JGRP-940 has been fixed !
+     * <li/>Reason: B and C trashed A's conntables in UNICAST, but A didn't trash its conn tables for B and C, so
+     * we have non-matching seqnos !
+     * </ol>
+     */
+    public void testOverlappingMergeWithBC() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // Inject view {B,C} into B and C:
+        View new_view=Util.createView(b.getLocalAddress(), 10, b.getLocalAddress(), c.getLocalAddress());
+        System.out.println(""\n ==== Injecting view "" + new_view + "" into B and C ===="");
+        injectView(new_view, b, c);
+        makeCoordinator(b);
+        assert Util.isCoordinator(a);
+        assert Util.isCoordinator(b);
+        assert !Util.isCoordinator(c);
+
+        System.out.println(""A's view: "" + a.getView());
+        System.out.println(""B's view: "" + b.getView());
+        System.out.println(""C's view: "" + c.getView());
+        assert a.getView().size() == 3 : ""A's view is "" + a.getView();
+        assert b.getView().size() == 2 : ""B's view is "" + b.getView();
+        assert c.getView().size() == 2 : ""C's view is "" + c.getView();
+
+        System.out.println(""\n==== Sending messages while the cluster is partitioned ===="");
+        sendAndCheckMessages(5, a, b, c);
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // start merging
+        Vector<Address> coords=new Vector<Address>(2);
+        coords.add(a.getLocalAddress()); coords.add(b.getLocalAddress());
+        Event merge_evt=new Event(Event.MERGE, coords);
+        JChannel merge_leader=determineMergeLeader(a, b);
+        System.out.println(""\n==== Injecting a merge event (leader="" + merge_leader.getLocalAddress() + "") ===="");
+        injectMergeEvent(merge_evt, merge_leader);
+
+        System.out.println(""\n==== checking views after merge ====:"");
+        for(int i=0; i < 20; i++) {
+            if(a.getView().size() == 3 && b.getView().size() == 3 && c.getView().size() == 3) {
+                System.out.println(""views are correct: all views have a size of 3"");
+                break;
+            }
+            System.out.print(""."");
+            Util.sleep(500);
+        }
+
+        System.out.println(""\n ==== Digests after the merge:\n"" + dumpDigests(a,b,c));
+
+        View va=a.getView(), vb=b.getView(), vc=c.getView();
+        System.out.println(""\nA's view: "" + va);
+        System.out.println(""B's view: "" + vb);
+        System.out.println(""C's view: "" + vc);
+        assert va.size() == 3 : ""A's view is "" + va;
+        assert vb.size() == 3 : ""B's view is "" + vb;
+        assert vc.size() == 3 : ""C's view is "" + vc;
+
+        System.out.println(""\n==== Sending messages after merge ===="");
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}
+     * <li/>Install view {A,C} in A and {A,B,C} in B and C
+     * <li/>Try to initiate a merge. This should FAIL until https://jira.jboss.org/jira/browse/JGRP-937 has
+     *      been implemented: B and C's MERGE2 protocols will never send out merge requests as they see A as coord 
+     * </ol>
+     */
+    public void testOverlappingMergeWithABC() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+
+        System.out.println(""\n ==== Digests are:\n"" + dumpDigests(a,b,c));
+
+        // Inject view {A,C} into A:
+        View new_view=Util.createView(a.getLocalAddress(), 4, a.getLocalAddress(), c.getLocalAddress());
+        System.out.println(""\n ==== Injecting view "" + new_view + "" into A ===="");
+        injectView(new_view, a);
+        assertTrue(Util.isCoordinator(a));
+        assertFalse(Util.isCoordinator(b));
+        assertFalse(Util.isCoordinator(c));
+
+        System.out.println(""A's view: "" + a.getView());
+        System.out.println(""B's view: "" + b.getView());
+        System.out.println(""C's view: "" + c.getView());
+        assertEquals(""A's view is "" + a.getView(), 2, a.getView().size());
+        assertEquals(""B's view is "" + b.getView(), 3, b.getView().size());
+        assertEquals(""C's view is "" + c.getView(), 3, c.getView().size());
+
+
+        // start merging
+        Vector<Address> coords=new Vector<Address>(2);
+        coords.add(a.getLocalAddress());
+        Event merge_evt=new Event(Event.MERGE, coords);
+        System.out.println(""\n==== Injecting a merge event (leader="" + a + "") ===="");
+        injectMergeEvent(merge_evt, a);
+
+        System.out.println(""\n==== checking views after merge ====:"");
+        for(int i=0; i < 20; i++) {
+            if(a.getView().size() == 3 && b.getView().size() == 3 && c.getView().size() == 3) {
+                System.out.println(""views are correct: all views have a size of 3"");
+                break;
+            }
+            System.out.print(""."");
+            Util.sleep(500);
+        }
+
+        System.out.println(""\n ==== Digests after the merge:\n"" + dumpDigests(a,b,c));
+
+        View va=a.getView(), vb=b.getView(), vc=c.getView();
+        System.out.println(""\nA's view: "" + va);
+        System.out.println(""B's view: "" + vb);
+        System.out.println(""C's view: "" + vc);
+        assertEquals(""A's view is "" + va, 3, va.size());
+        assertEquals(""B's view is "" + vb, 3, vb.size());
+        assertEquals(""C's view is "" + vc, 3, vc.size());
+
+        System.out.println(""\n==== Sending messages after merge ===="");
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    private static void makeCoordinator(JChannel ch) {
+        GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+        gms.becomeCoordinator();
+    }
+
+
+    private static String dumpDigests(JChannel ... channels) {
+        StringBuilder sb=new StringBuilder();
+        for(JChannel ch: channels) {
+            sb.append(ch.getLocalAddress()).append("": "");
+            NAKACK nakack=(NAKACK)ch.getProtocolStack().findProtocol(NAKACK.class);
+            Digest digest=nakack.getDigest();
+            sb.append(digest).append(""\n"");
+        }
+        return sb.toString();
+    }
+
+    private static JChannel determineMergeLeader(JChannel ... coords) {
+        Membership tmp=new Membership();
+        for(JChannel ch: coords) {
+            tmp.add(ch.getLocalAddress());
+        }
+        tmp.sort();
+        Address  merge_leader=tmp.elementAt(0);
+        for(JChannel ch: coords) {
+            if(ch.getLocalAddress().equals(merge_leader))
+                return ch;
+        }
+        return null;
+    }
+
+    private static void injectView(View view, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ch.down(new Event(Event.VIEW_CHANGE, view));
+            ch.up(new Event(Event.VIEW_CHANGE, view));
+        }
+        for(JChannel ch: channels) {
+            MyReceiver receiver=(MyReceiver)ch.getReceiver();
+            System.out.println(""["" + receiver.name + ""] view="" + ch.getView());
+        }
+    }
+
+
+    private static void injectMergeEvent(Event evt, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.up(evt);
+        }
+    }
+
+
+    private void sendAndCheckMessages(int num_msgs, JChannel ... channels) throws Exception {
+        ra.clear(); rb.clear(); rc.clear();
+
+        Set<Address> mbrs=new HashSet<Address>(channels.length);
+        for(JChannel ch: channels)
+            mbrs.add(ch.getLocalAddress());
+
+        // 1. send multicast messages
+        for(JChannel ch: channels) {
+            for(int i=1; i <= 5; i++)
+                ch.send(null, null, ""#"" + i);
+        }
+
+        // 2. send unicast messages
+        for(JChannel ch: channels) {
+            for(Address dest: mbrs) {
+                for(int i=1; i <= num_msgs; i++) {
+                    ch.send(dest, null, ""#"");
+                }
+            }
+        }
+        Util.sleep(2000);
+        MyReceiver[] receivers=new MyReceiver[channels.length];
+        for(int i=0; i < channels.length; i++)
+            receivers[i]=(MyReceiver)channels[i].getReceiver();
+        checkReceivedMessages(num_msgs, receivers);
+    }
+    
+
+    private static void checkReceivedMessages(int num_msgs, MyReceiver ... receivers) {
+        for(MyReceiver receiver: receivers) {
+            List<Message> mcasts=receiver.getMulticasts();
+            List<Message> ucasts=receiver.getUnicasts();
+            int mcasts_received=mcasts.size();
+            int ucasts_received=ucasts.size();
+            System.out.println(""receiver "" + receiver + "": mcasts="" + mcasts_received + "", ucasts="" + ucasts_received);
+        }
+        int total_unicasts=receivers.length * num_msgs;
+        for(MyReceiver receiver: receivers) {
+            List<Message> mcasts=receiver.getMulticasts();
+            List<Message> ucasts=receiver.getUnicasts();
+            int mcasts_received=mcasts.size();
+            int ucasts_received=ucasts.size();
+            int total_mcasts=receiver.view.size() * num_msgs;
+            assert ucasts_received == total_unicasts : ""ucasts: "" + print(ucasts);
+            assert mcasts_received == total_mcasts : ""num_mcasts="" + print(mcasts);
+        }
+    }
+
+    private static String print(List<Message> msgs) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: msgs) {
+            sb.append(msg.getSrc()).append("": "").append(msg.getObject()).append("" "");
+        }
+        return sb.toString();
+    }
+
+
+    private static void modifyConfigs(JChannel ... channels) throws Exception {
+        for(JChannel ch: channels) {
+            ProtocolStack stack=ch.getProtocolStack();
+
+            FD fd=(FD)stack.findProtocol(FD.class);
+            if(fd != null)
+                fd.setShun(false);
+
+            FD_ALL fd_all=(FD_ALL)stack.findProtocol(FD_ALL.class);
+            if(fd_all != null)
+                fd_all.setShun(false);
+
+            stack.removeProtocol(""MERGE2"");
+            stack.removeProtocol(""FC"");
+            stack.removeProtocol(""VERIFY_SUSPECT"");
+
+            /*DELAY delay=new DELAY();
+            delay.setOutDelay(500);
+            stack.insertProtocol(delay, ProtocolStack.ABOVE, stack.getTransport());*/
+        }
+    }
+
+
+
+    private static class MyReceiver extends ReceiverAdapter {
+        final String name;
+        View view=null;
+        final List<Message> mcasts=new ArrayList<Message>(20);
+        final List<Message> ucasts=new ArrayList<Message>(20);
+
+        public MyReceiver(String name) {
+            this.name=name;
+        }
+
+        public void receive(Message msg) {
+            Address dest=msg.getDest();
+            boolean mcast=dest == null;
+            if(mcast)
+                mcasts.add(msg);
+            else
+                ucasts.add(msg);
+            // System.out.println(""received "" + (mcast? ""mcast"" : ""ucast"") + "" msg from "" + msg.getSrc());
+        }
+
+        public void viewAccepted(View new_view) {
+            // System.out.println(""["" + name + ""] "" + new_view);
+            view=new_view;
+        }
+
+        public List<Message> getMulticasts() { return mcasts; }
+        public List<Message> getUnicasts() { return ucasts; }
+        public void clear() {mcasts.clear(); ucasts.clear();}
+
+        public String toString() {
+            return name;
+        }
+    }
+
+
+
+}
\ No newline at end of file",2009-04-24T14:48:33Z,147
"@@ -0,0 +1,209 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.FD;
+import org.jgroups.protocols.FD_ALL;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.AfterTest;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Tests overlapping merges, e.g. A: {A,B}, B: {A,B} and C: {A,B,C}. Tests unicast tables<br/>
+ * Related JIRA: https://jira.jboss.org/jira/browse/JGRP-940
+ * @author Bela Ban
+ * @version $Id: OverlappingUnicastMergeTest.java,v 1.2 2009/04/24 14:48:33 belaban Exp $
+ */
+@Test(groups=Global.STACK_DEPENDENT,sequential=true)
+public class OverlappingUnicastMergeTest extends ChannelTestBase {
+    private JChannel a, b, c;
+    private MyReceiver ra, rb, rc;
+
+    @BeforeTest
+    void start() throws Exception {
+        ra=new MyReceiver(""A""); rb=new MyReceiver(""B""); rc=new MyReceiver(""C"");
+        a=createChannel(true, 3);
+        a.setReceiver(ra);
+
+        b=createChannel(a);
+        b.setReceiver(rb);
+
+        c=createChannel(a); 
+        c.setReceiver(rc);
+
+        modifyConfigs(a, b, c);
+
+        a.connect(""OverlappingUnicastMergeTest"");
+        b.connect(""OverlappingUnicastMergeTest"");
+        c.connect(""OverlappingUnicastMergeTest"");
+
+        View view=c.getView();
+        assertEquals(""view is "" + view, 3, view.size());
+    }
+
+    @AfterTest
+    void tearDown() throws Exception {
+        Util.close(c,b,a);
+    }
+
+
+    public void testWithAllViewsInSync() throws Exception {
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    /**
+     * Verifies that unicasts are received correctly by all participants after an overlapping merge. The following steps
+     * are executed:
+     * <ol>
+     * <li/>Group is {A,B,C}, disable shunning in all members. A is the coordinator
+     * <li/>MERGE2 is removed from all members
+     * <li/>VERIFY_SUSPECT is removed from all members
+     * <li/>Everyone sends 5 unicast messages to everyone else
+     * <li/>A VIEW(B,C) is injected into B and C
+     * <li/>B and C install {B,C}
+     * <li/>B and C trash the connection table for A in UNICAST
+     * <li/>A still has view {A,B,C} and all connection tables intact in UNICAST
+     * <li/>We now send N unicasts from everyone to everyone else, all the unicasts should be received.
+     * </ol>
+     */
+    public void testWithViewBC() throws Exception {
+        // Inject view {B,C} into B and C:
+        View new_view=Util.createView(b.getLocalAddress(), 10, b.getLocalAddress(), c.getLocalAddress());
+        injectView(new_view, b, c);
+        assertEquals(""A's view is "" + a.getView(), 3, a.getView().size());
+        assertEquals(""B's view is "" + b.getView(), 2, b.getView().size());
+        assertEquals(""C's view is "" + c.getView(), 2, c.getView().size());
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithViewA() throws Exception {
+        // Inject view {A} into A, B and C:
+        View new_view=Util.createView(a.getLocalAddress(), 10, a.getLocalAddress());
+        injectView(new_view, a, b, c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithViewC() throws Exception {
+        // Inject view {A} into A, B and C:
+        View new_view=Util.createView(c.getLocalAddress(), 10, c.getLocalAddress());
+        injectView(new_view, a, b, c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+    public void testWithEveryoneHavingASingletonView() throws Exception {
+        // Inject view {A} into A, B and C:
+        injectView(Util.createView(a.getLocalAddress(), 10, a.getLocalAddress()), a);
+        injectView(Util.createView(b.getLocalAddress(), 10, b.getLocalAddress()), b);
+        injectView(Util.createView(c.getLocalAddress(), 10, c.getLocalAddress()), c);
+        sendAndCheckMessages(5, a, b, c);
+    }
+
+
+    private static void injectView(View view, JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ch.down(new Event(Event.VIEW_CHANGE, view));
+            ch.up(new Event(Event.VIEW_CHANGE, view));
+        }
+        for(JChannel ch: channels) {
+            MyReceiver receiver=(MyReceiver)ch.getReceiver();
+            System.out.println(""["" + receiver.name + ""] view="" + ch.getView());
+        }
+    }
+
+
+    private void sendAndCheckMessages(int num_msgs, JChannel ... channels) throws Exception {
+        ra.clear(); rb.clear(); rc.clear();
+        // 1. send unicast messages
+        Set<Address> mbrs=new HashSet<Address>(channels.length);
+        for(JChannel ch: channels)
+            mbrs.add(ch.getLocalAddress());
+
+        for(JChannel ch: channels) {
+            Address addr=ch.getLocalAddress();
+            for(Address dest: mbrs) {
+                for(int i=1; i <= num_msgs; i++) {
+                    ch.send(dest, null, ""unicast msg #"" + i + "" from "" + addr);
+                }
+            }
+        }
+        Util.sleep(1000);
+        int total_msgs=num_msgs * channels.length;
+        MyReceiver[] receivers=new MyReceiver[channels.length];
+        for(int i=0; i < channels.length; i++)
+            receivers[i]=(MyReceiver)channels[i].getReceiver();
+        checkReceivedMessages(total_msgs, receivers);
+    }
+
+    private static void checkReceivedMessages(int num_ucasts, MyReceiver ... receivers) {
+        for(MyReceiver receiver: receivers) {
+            List<Message> ucasts=receiver.getUnicasts();
+            int ucasts_received=ucasts.size();
+            System.out.println(""receiver "" + receiver + "": ucasts="" + ucasts_received);
+            assertEquals(""ucasts for "" + receiver + "": "" + print(ucasts), num_ucasts, ucasts_received);
+        }
+    }
+
+    public static String print(List<Message> list) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: list) {
+            sb.append(msg.getSrc()).append("": "").append(msg.getObject()).append("" "");
+        }
+        return sb.toString();
+    }
+
+    private static void modifyConfigs(JChannel ... channels) throws Exception {
+        for(JChannel ch: channels) {
+            ProtocolStack stack=ch.getProtocolStack();
+
+            FD fd=(FD)stack.findProtocol(FD.class);
+            if(fd != null)
+                fd.setShun(false);
+
+            FD_ALL fd_all=(FD_ALL)stack.findProtocol(FD_ALL.class);
+            if(fd_all != null)
+                fd_all.setShun(false);
+
+            stack.removeProtocol(""MERGE2"");
+            stack.removeProtocol(""VERIFY_SUSPECT"");
+            stack.removeProtocol(""FC"");
+        }
+    }
+
+
+
+    private static class MyReceiver extends ReceiverAdapter {
+        final String name;
+        final List<Message> ucasts=new ArrayList<Message>(20);
+
+        public MyReceiver(String name) {
+            this.name=name;
+        }
+
+        public void receive(Message msg) {
+            Address dest=msg.getDest();
+            boolean mcast=dest == null;
+            if(!mcast)
+                ucasts.add(msg);
+        }
+
+        public void viewAccepted(View new_view) {
+            // System.out.println(""["" + name + ""] "" + new_view);
+        }
+
+        public List<Message> getUnicasts() { return ucasts; }
+        public void clear() {ucasts.clear();}
+
+        public String toString() {
+            return name;
+        }
+    }
+
+
+
+}
\ No newline at end of file",2009-04-24T14:48:33Z,148
"@@ -10,9 +10,7 @@
 import org.jgroups.protocols.TP;
 import org.jgroups.stack.Protocol;
 import org.jgroups.tests.ChannelTestBase;
-import org.jgroups.util.Rsp;
-import org.jgroups.util.RspList;
-import org.jgroups.util.Util;
+import org.jgroups.util.*;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
@@ -42,7 +40,7 @@
  * This also applies to the return value of callRemoteMethod(...).
  * 
  * @author Bela Ban
- * @version $Id: RpcDispatcherTest.java,v 1.29 2010/01/17 11:29:56 belaban Exp $
+ * @version $Id: RpcDispatcherTest.java,v 1.30 2010/01/17 12:07:43 belaban Exp $
  */
 @Test(groups=Global.STACK_DEPENDENT,sequential=true)
 public class RpcDispatcherTest extends ChannelTestBase {
@@ -109,7 +107,7 @@ public void testEmptyConstructor() throws Exception {
             System.out.println(""view channel 1= "" + view);
 
             assert view.size() == 2;
-            RspList rsps=d1.callRemoteMethods(null, ""foo"", null, (Class[])null, Request.GET_ALL, 5000);
+            RspList rsps=d1.callRemoteMethods(null, ""foo"", null, null, new RequestOptions(Request.GET_ALL, 5000));
             System.out.println(""rsps:\n"" + rsps);
             assert rsps.size() == 2;
             for(Rsp rsp: rsps.values()) {
@@ -127,7 +125,7 @@ public long foobar() {
             d1.setServerObject(server_object);
             d2.setServerObject(server_object);
 
-            rsps=d2.callRemoteMethods(null, ""foobar"", null, (Class[])null, Request.GET_ALL, 5000);
+            rsps=d2.callRemoteMethods(null, ""foobar"", null, null, new RequestOptions(Request.GET_ALL, 5000));
             System.out.println(""rsps:\n"" + rsps);
             assert rsps.size() == 2;
             for(Rsp rsp: rsps.values()) {
@@ -158,23 +156,23 @@ public long foobar() {
     public void testResponseFilter() {
     	
     	final long timeout = 10 * 1000 ;
+
+        RequestOptions options=new RequestOptions(Request.GET_ALL, timeout, false,
+                                                  new RspFilter() {
+                                                      int num=0;
+                                                      public boolean isAcceptable(Object response, Address sender) {
+                                                          boolean retval=((Integer)response).intValue() > 1;
+                                                          if(retval)
+                                                              num++;
+                                                          return retval;
+                                                      }
+
+                                                      public boolean needMoreResponses() {
+                                                          return num < 2;
+                                                      }
+                                                  });
     	
-        RspList rsps=disp1.callRemoteMethods(null, ""foo"", null, null,Request.GET_ALL, timeout, false,
-                                             new RspFilter() {
-                                                 int num=0;
-                                                 public boolean isAcceptable(Object response, Address sender) {
-                                                     boolean retval=((Integer)response).intValue() > 1;
-                                                     // System.out.println(""-- received "" + response + "" from "" +
-                                                     // sender + "": "" + (retval ? ""OK"" : ""NOTOK""));
-                                                     if(retval)
-                                                         num++;
-                                                     return retval;
-                                                 }
-
-                                                 public boolean needMoreResponses() {
-                                                     return num < 2;
-                                                 }
-                                             });
+        RspList rsps=disp1.callRemoteMethods(null, ""foo"", null, null, options);
         System.out.println(""responses are:\n"" + rsps);
         assertEquals(""there should be three response values"", 3, rsps.size());
         assertEquals(""number of responses received should be 2"", 2, rsps.numReceived());
@@ -184,7 +182,7 @@ public boolean needMoreResponses() {
     public void testFuture() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
         Future<RspList> future;
-        future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 5000L, false, false, null);
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
         assert !future.isDone();
         assert !future.isCancelled();
         try {
@@ -205,14 +203,52 @@ public void testFuture() throws Exception {
     }
 
 
+    public void testNotifyingFuture() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
+        NotifyingFuture<RspList> future;
+        MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
+        future.setListener(listener);
+        assert !future.isDone();
+        assert !future.isCancelled();
+        assert !listener.isDone();
+        Util.sleep(2000);
+        assert listener.isDone();
+        RspList result=future.get(1L, TimeUnit.MILLISECONDS);
+        System.out.println(""result:\n"" + result);
+        assert result != null;
+        assert result.size() == 3;
+        assert future.isDone();
+    }
+
+    public void testNotifyingFutureWithDelayedListener() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
+        NotifyingFuture<RspList> future;
+        MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L, false, null));
+        assert !future.isDone();
+        assert !future.isCancelled();
+
+        Util.sleep(2000);
+        future.setListener(listener);
+        assert listener.isDone();
+        RspList result=future.get(1L, TimeUnit.MILLISECONDS);
+        System.out.println(""result:\n"" + result);
+        assert result != null;
+        assert result.size() == 3;
+        assert future.isDone();
+    }
+
+
     public void testMultipleFutures() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{100L}, new Class[]{long.class});
         List<Future<RspList>> futures=new ArrayList<Future<RspList>>();
         long target=System.currentTimeMillis() + 30000L;
 
         Future<RspList> future;
+        RequestOptions options=new RequestOptions(Request.GET_ALL, 30000L, false, null);
         for(int i=0; i < 10; i++) {
-            future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 30000L, false, false, null);
+            future=disp1.callRemoteMethodsWithFuture(null, sleep, options);
             futures.add(future);
         }
 
@@ -234,13 +270,44 @@ public void testMultipleFutures() throws Exception {
         }
     }
 
+    public void testMultipleNotifyingFutures() throws Exception {
+        MethodCall sleep=new MethodCall(""sleep"", new Object[]{100L}, new Class[]{long.class});
+        List<MyFutureListener> listeners=new ArrayList<MyFutureListener>();
+        RequestOptions options=new RequestOptions(Request.GET_ALL, 30000L, false, null);
+        for(int i=0; i < 10; i++) {
+            MyFutureListener<RspList> listener=new MyFutureListener<RspList>();
+            listeners.add(listener);
+            disp1.callRemoteMethodsWithFuture(null, sleep, options).setListener(listener);
+        }
+
+        Util.sleep(1000);
+        for(int i=0; i < 10; i++) {
+            boolean all_done=true;
+            for(MyFutureListener listener: listeners) {
+                boolean done=listener.isDone();
+                System.out.print(done? ""+ "" : ""- "");
+                if(!listener.isDone())
+                    all_done=false;
+            }
+            if(all_done)
+                break;
+            Util.sleep(500);
+            System.out.println("""");
+        }
+        
+        for(MyFutureListener listener: listeners) {
+            assert listener.isDone();
+        }
+
+    }
+
 
 
 
     public void testFutureCancel() throws Exception {
         MethodCall sleep=new MethodCall(""sleep"", new Object[]{1000L}, new Class[]{long.class});
         Future<RspList> future;
-        future=disp1.callRemoteMethodsWithFuture(null, sleep, Request.GET_ALL, 5000L, false, false, null);
+        future=disp1.callRemoteMethodsWithFuture(null, sleep, new RequestOptions(Request.GET_ALL, 5000L));
         assert !future.isDone();
         assert !future.isCancelled();
         future.cancel(true);
@@ -309,7 +376,7 @@ public void testMethodInvocationToNonExistingMembers() {
         
         // make an RPC call using C's now outdated view of membership
         System.out.println(""calling method foo() in "" + members + "" (view="" + c2.getView() + "")"");
-        RspList rsps=disp1.callRemoteMethods(members, ""foo"", null, (Class[])null, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(members, ""foo"", null, null, new RequestOptions(Request.GET_ALL, timeout));
         
         // all responses 
         System.out.println(""responses:\n"" + rsps);
@@ -370,7 +437,8 @@ void _testLargeValue(int size) {
     	final long timeout = 20 * 1000 ;
     		
         System.out.println(""\ntesting with "" + size + "" bytes"");
-        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
         System.out.println(""rsps:"");
         assert rsps.size() == 3 : ""there should be three responses to the RPC call but only "" + rsps.size() +
                 "" were received: "" + rsps;
@@ -405,7 +473,8 @@ void _testHugeValue(int size) {
     	final long timeout = 20 * 1000 ;
     	
         System.out.println(""\ntesting with "" + size + "" bytes"");
-        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        RspList rsps=disp1.callRemoteMethods(null, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
         System.out.println(""rsps:"");
         assert rsps != null;
         assert rsps.size() == 3 : ""there should be three responses to the RPC call but only "" + rsps.size() +
@@ -458,7 +527,8 @@ void _testLargeValueUnicastCall(Address dst, int size) throws Throwable {
         System.out.println(""\ntesting unicast call with "" + size + "" bytes"");
         assertNotNull(dst);
         
-        Object retval=disp1.callRemoteMethod(dst, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class}, Request.GET_ALL, timeout);
+        Object retval=disp1.callRemoteMethod(dst, ""largeReturnValue"", new Object[]{size}, new Class[]{int.class},
+                                             new RequestOptions(Request.GET_ALL, timeout));
 
     	// it's possible that an exception was raised
         if (retval instanceof java.lang.Throwable) {
@@ -490,6 +560,7 @@ public ServerObject(int i) {
             this.i=i;
         }
         public int foo() {return i;}
+        
         public static long sleep(long timeout) {
             // System.out.println(""sleep()"");
             long start=System.currentTimeMillis();
@@ -503,5 +574,15 @@ public static byte[] largeReturnValue(int size) {
         }
     }
 
+    private static class MyFutureListener<T> implements FutureListener<T> {
+        private boolean done;
+
+        public void futureDone(Future<T> future) {
+            done=true;
+        }
+
+        public boolean isDone() {return done;}
+    }
+
 
 }
\ No newline at end of file",2010-01-17T12:07:43Z,149
"@@ -2,20 +2,18 @@
 package org.jgroups.tests;
 
 import org.jgroups.*;
-import org.jgroups.debug.Simulator;
+import org.jgroups.protocols.*;
+import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.UUID;
-import org.jgroups.util.MutableDigest;
-import org.jgroups.util.Digest;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.ProtocolStack;
 import org.testng.Assert;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import java.util.Hashtable;
-import java.util.Vector;
-import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * Tests the reliable FIFO (NAKACK) protocol
@@ -40,7 +38,6 @@
  */
 @Test(groups=Global.FUNCTIONAL, sequential=true)
 public class NakackTest {
-
     final static int NUM_PEERS=3;
     final static int NUM_MSGS=1000;
     final static int WAIT_TIMEOUT=10; // secs
@@ -50,124 +47,61 @@ public class NakackTest {
     static boolean notFIFO=false;
     static boolean allMsgsReceived=false;
 
-    Address[] addresses=new Address[NUM_PEERS];
-    Vector<Address> members=null;
-    View view;
-    Simulator[] simulators=new Simulator[NUM_PEERS];
-    NAKACK[] layers=new NAKACK[NUM_PEERS];
-    Protocol[][] stacks=new Protocol[NUM_PEERS][];
+    JChannel[] channels=new JChannel[NUM_PEERS];
     Thread[] threads=new Thread[NUM_PEERS];
 
     //define senders and receivers
-    boolean[] isSender=new boolean[NUM_PEERS];
+    boolean[] isSender={false, true,true};
 
     // used to wait for signal that all messages received
     static final Object all_msgs_recd=new Object();
 
+
+
+
+
     /**
      * Set up a number of simulator instances wrapping NAKACK
      */
     @BeforeMethod
     public void setUp() throws Exception {
 
-        // define the senders and the receivers
-        isSender[0]=false;
-        isSender[1]=true;
-        isSender[2]=true;
-
-        // dummy IP addresses and ports
-        for(int i=0; i < addresses.length; i++) {
-            UUID uuid=UUID.randomUUID();
-            UUID.add(uuid, ""node-"" + i);
-            addresses[i]=uuid;
-        }
-
-        // dummy set of members which works for all three simulators
-        members=new Vector<Address>();
-        members.addAll(Arrays.asList(addresses).subList(0, NUM_PEERS));
-
-        // create a dummy View(creator, timestamp, member set)
-        view=new View(addresses[0], 1, members);
-
         // create new simulator instances
         for(int i=0; i < NUM_PEERS; i++) {
-
-            // create the simulator instance
-
-            // at this stage, the ProtocolAdapter should be created and the timer present
-            simulators[i]=new Simulator();
-            simulators[i].setLocalAddress(addresses[i]);
-            simulators[i].setView(view);
-
-            // set up the protocol under test
-            layers[i]=new NAKACK();
-
-            // set up its properties
-            layers[i].setUseMcastXmit(true);
-
-            // our protocol stack under test consists of one protocol
-            stacks[i]=new Protocol[]{layers[i]};
-
-            // initalise the protocol stack
-            simulators[i].setProtocolStack(stacks[i]);
-        }
-
-        // describe the configuration of the three simulators
-        for(int i=0; i < NUM_PEERS; i++) {
-            for(int j=0; j < NUM_PEERS; j++) {
-                if(i == j)
-                    simulators[i].addMember(addresses[j]);
-                else
-                    simulators[i].addMember(addresses[j], simulators[j]);
-            }
+            channels[i]=createChannel();
+            channels[i].setName(Character.toString((char)(i + 'A')));
+            channels[i].connect(""NakackTest"");
         }
 
         // set up the receiver callbacks for each simulator
-        Simulator.Receiver[] receivers=new Simulator.Receiver[NUM_PEERS];
+        Receiver[] receivers=new Receiver[NUM_PEERS];
 
-        // set up the sender and the receiver callbacks, according to whether
-        // the peer is a sender or a receiver
+        // set up the sender and the receiver callbacks, according to whether the peer is a sender or a receiver
         for(int i=0; i < NUM_PEERS; i++) {
-
             if(isSender[i])
-                receivers[i]=new SenderPeer(simulators[i]);
+                receivers[i]=new ReceiverPeer(channels[i]);
             else
-                receivers[i]=new ReceiverPeer(simulators[i]);
-
-            simulators[i].setReceiver(receivers[i]);
-        }
-
-        // start the simulators
-        for(int i=0; i < NUM_PEERS; i++)
-            simulators[i].start();
-
-        MutableDigest digest=new MutableDigest(NUM_PEERS);
-        for(Address addr: addresses)
-            digest.add(new Digest(addr, 0, 0));
-        for(int i=0; i < NUM_PEERS; i++) {
-            layers[i].down(new Event(Event.SET_DIGEST, digest));
+                receivers[i]=new ReceiverPeer(channels[i]);
+            channels[i].setReceiver(receivers[i]);
         }
-
     }
 
     @AfterMethod
     public void tearDown() throws Exception {
-
-        // stop the simulators
         for(int i=0; i < NUM_PEERS; i++)
-            simulators[i].stop();
+            channels[i].close();
     }
 
     /**
      * Test to see thyat NAKACK delivery is reliable and FIFO.
      */
     public void testReceptionOfAllMessages() {
-
+        for(JChannel ch: channels)
+          assert ch.getView().size() == NUM_PEERS;
 
         // start the NAKACK peers and let them exchange messages
         for(int i=0; i < NUM_PEERS; i++) {
-
-            threads[i]=new MyNAKACKPeer(simulators[i], isSender[i]);
+            threads[i]=new MyNAKACKPeer(channels[i], isSender[i]);
             threads[i].start();
         }
 
@@ -197,163 +131,124 @@ public void testReceptionOfAllMessages() {
         Assert.assertFalse(notFIFO, ""Sequenece numbers for a peer not in correct order"");
     }
 
-    /**
-     * This is called by the Simulator when a message comes back up the stack.
-     * Used by message senders to simply display messages received from other peers.
-     */
-    static class SenderPeer implements Simulator.Receiver {
-        Simulator simulator=null;
-        int num_mgs_received=0;
-
-        SenderPeer(Simulator s) {
-            this.simulator=s;
-        }
-
-        // keep track of how many messages were received
-        public void receive(Event evt) {
-            if(evt.getType() == Event.MSG) {
-                num_mgs_received++;
-                if(num_mgs_received % MSGS_PER_STATUS_LINE == 0)
-                    System.out.println(""<"" + simulator.getLocalAddress() + "">:"" + ""<== "" + num_mgs_received);
-            }
-        }
-
-        public int getNumberOfReceivedMessages() {
-            return num_mgs_received;
-        }
+    protected static JChannel createChannel() throws Exception {
+        JChannel ch=new JChannel(false);
+        ProtocolStack stack=new ProtocolStack();
+        ch.setProtocolStack(stack);
+        stack.addProtocol(new SHARED_LOOPBACK())
+          .addProtocol(new PING())
+          .addProtocol(new NAKACK().setValue(""use_mcast_xmit"", false))
+          .addProtocol(new UNICAST2())
+          .addProtocol(new STABLE().setValue(""max_bytes"", 50000))
+          .addProtocol(new GMS().setValue(""print_local_addr"", false))
+          .addProtocol(new UFC())
+          .addProtocol(new MFC())
+          .addProtocol(new FRAG2());
+        stack.init();
+        return ch;
     }
 
+   
+
     /**
      * This is called by the Simulator when a message comes back up the stack.
      * This method should do the following:
      * - receive messages from senders
      * - check that sequence numbers for each sender are in order (with no gaps)
      * - terminate when correct number of messages have been received
      */
-    static class ReceiverPeer implements Simulator.Receiver {
-        Simulator simulator=null;
+    static class ReceiverPeer extends ReceiverAdapter {
+        final JChannel channel;
         int num_mgs_received=0;
-        long starting_seqno=1;
-        long last_seqno=starting_seqno;
-
-        Hashtable<Address, Long> senders=new Hashtable<Address, Long>();
-        Message msg;
-        Address sender;
-        Long s;
-        long received_seqno;
+        ConcurrentMap<Address, Long> senders=new ConcurrentHashMap<Address, Long>();
 
-        ReceiverPeer(Simulator s) {
-            this.simulator=s;
+        public ReceiverPeer(JChannel channel) {
+            this.channel=channel;
         }
 
-        public synchronized void receive(Event evt) {
-
-            if(evt.getType() == Event.MSG) {
+        /**
+         * Receive() is concurrent for different senders, but sequential per sender
+         * @param msg
+         */
+        public void receive(Message msg) {
+            // keep track of seqno ordering of messages received
+            Address sender=msg.getSrc();
+
+            // get the expected next seqno for this sender
+            Long num=senders.get(sender);
+            if(num == null) {
+                num=new Long(1);
+                senders.putIfAbsent(sender, num);
+            }
+            long last_seqno=num.longValue();
 
-                // keep track of seqno ordering of messages received
-                msg=(Message)evt.getArg();
-                sender=msg.getSrc();
+            try {
+                num=(Long)msg.getObject();
+                long received_seqno=num.longValue();
+                num_mgs_received++;
 
-                // get the expected next seqno for this sender
-                s=senders.get(sender);
-                if(s == null) {
-                    s=new Long(starting_seqno);
-                    senders.put(sender, s);
+                // 1. check if sequence numbers are in sequence
+                if(received_seqno == last_seqno) { // correct - update with next expected seqno
+                    senders.put(sender, new Long(last_seqno + 1));
+                }
+                else {
+                    // error, terminate test
+                    notFIFO=true;
+                    Assert.fail(""FAIL: received msg #"" + received_seqno + "", expected "" + last_seqno);
                 }
-                last_seqno=s.longValue();
-
-                try {
-                    s=(Long)msg.getObject();
-                    received_seqno=s.longValue();
-
-                    num_mgs_received++;
-
-                    // 1. check if sequence numbers are in sequence
-                    if(received_seqno == last_seqno) {
-                        // correct - update with next expected seqno
-                        senders.put(sender, new Long(last_seqno + 1));
-                    }
-                    else {
-                        // error, terminate test
-                        notFIFO=true;
-                        Assert.fail(""FAIL: received msg #"" + received_seqno + "", expected "" + last_seqno);
-                    }
-
-                    Address address=simulator.getLocalAddress();
-
-                    if(received_seqno % MSGS_PER_STATUS_LINE == 0 && received_seqno > 0)
-                        System.out.println(""<"" + address + "">:"" + ""PASS: received msg #"" + received_seqno + "" from "" + sender);
 
+                Address address=channel.getAddress();
+                if(received_seqno % MSGS_PER_STATUS_LINE == 0 && received_seqno > 0)
+                    System.out.println(""<"" + address + "">:"" + ""PASS: received msg #"" + received_seqno + "" from "" + sender);
 
-                    // condition to terminate the test - all messages received (whether in
-                    // correct order or not)
-                    if(num_mgs_received >= NakackTest.NUM_MSGS * (NUM_PEERS - 1)) {
 
+                // condition to terminate the test - all messages received (whether in correct order or not)
+                if(num_mgs_received >= NakackTest.NUM_MSGS * (NUM_PEERS - 1)) {
+                    // signal that all messages have been received - this will allow the receiver
+                    // thread to terminate normally
+                    synchronized(all_msgs_recd) {
                         // indicate that we have received the required number of messages
                         // to differentiate between timeout and notifyAll cases on monitor
                         allMsgsReceived=true;
-
-                        // signal that all messages have been received - this will allow the receiver
-                        // thread to terminate normally
-                        synchronized(all_msgs_recd) {
-                            all_msgs_recd.notifyAll();
-                        }
+                        all_msgs_recd.notifyAll();
                     }
                 }
-                catch(Exception ex) {
-                    System.out.println(ex.toString());
-                    // log.error(""NakackTest.CheckNoGaps.up()"", ex);
-                }
+            }
+            catch(Exception ex) {
+                System.err.println(ex.toString());
             }
         }
 
+
         public int getNumberOfReceivedMessages() {
             return num_mgs_received;
         }
     }
 
 
     static class MyNAKACKPeer extends Thread {
-
-        Simulator s=null;
+        JChannel ch=null;
         boolean sender=false;
 
-        public MyNAKACKPeer(Simulator s, boolean sender) {
-            this.s=s;
+        public MyNAKACKPeer(JChannel ch, boolean sender) {
+            this.ch=ch;
             this.sender=sender;
         }
 
         public void run() {
 
             // senders send NUM_MSGS messages to all peers, beginning with seqno 1
             if(sender) {
-
-                Address address=s.getLocalAddress();
-
-                // send a collection of dummy messages by mcast to the stack under test
+                Address address=ch.getAddress();
                 for(int i=1; i <= NUM_MSGS; i++) {
-
-                    Message msg=new Message(null, address, new Long(i));
-                    Event evt=new Event(Event.MSG, msg);
-
-                    // call Simulator.send() to introduce the event into the stack under test
-                    s.send(evt);
-
-                    // status indicator
-                    if(i % MSGS_PER_STATUS_LINE == 0)
-                        System.out.println(""<"" + address + "">:"" + "" ==> "" + i);
-                }
-            }
-
-            if(!sender) {
-                // wait for the receiver callback to signal that it has received messages, or timeout
-                // this just causes this thread to block until its receiver has finished
-                synchronized(all_msgs_recd) {
                     try {
-                        all_msgs_recd.wait(WAIT_TIMEOUT * 1000);
+                        Message msg=new Message(null, address, new Long(i));
+                        ch.send(msg);
+                        if(i % MSGS_PER_STATUS_LINE == 0) // status indicator
+                            System.out.println(""<"" + address + "">:"" + "" ==> "" + i);
                     }
-                    catch(InterruptedException e) {
-                        System.out.println(""main thread interrupted"");
+                    catch(Exception e) {
+                        e.printStackTrace();
                     }
                 }
             }",2011-04-12T09:10:20Z,150
"@@ -1,8 +1,6 @@
 package org.jgroups.util;
 
-import org.testng.ITestContext;
-import org.testng.ITestListener;
-import org.testng.ITestResult;
+import org.testng.*;
 
 import java.io.*;
 import java.util.*;
@@ -13,7 +11,7 @@
  * 
  * @author Bela Ban
  */
-public class JUnitXMLReporter implements ITestListener {
+public class JUnitXMLReporter implements ITestListener, IConfigurationListener2 {
     protected String output_dir=null;
 
     protected static final String XML_DEF=""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>"";
@@ -68,20 +66,7 @@ public void onFinish(ITestContext context) {
 
     /* Invoked at the start of each test method in a test class */
     public void onTestStart(ITestResult result) {
-        String test_name=result.getTestClass().getName();
-        File dir=new File(output_dir + File.separator + test_name);
-        if(!dir.exists())
-            dir.mkdirs();
-        File _tests=new File(dir, TESTS), _stdout=new File(dir, STDOUT), _stderr=new File(dir, STDERR);
-        try {
-            tests.set(new DataOutputStream(new FileOutputStream(_tests, true)));
-            stdout.set(new PrintStream(new FileOutputStream(_stdout, true)));
-            stderr.set(new PrintStream(new FileOutputStream(_stderr, true)));
-            stdout.get().println(""\n\n------------- "" + getMethodName(result) + "" -----------"");
-        }
-        catch(IOException e) {
-            error(e.toString());
-        }
+        setupStreams(result, true);
     }
 
 
@@ -92,35 +77,75 @@ public void onTestSuccess(ITestResult tr) {
 
 
     public void onTestFailedButWithinSuccessPercentage(ITestResult tr) {
-        onTestCompleted(tr,""OK:   "",old_stdout);
+        onTestCompleted(tr, ""OK:   "",old_stdout);
     }
 
     /** Invoked each time a test method fails */
     public void onTestFailure(ITestResult tr) {
-        onTestCompleted(tr,""FAIL: "",old_stderr);
+        onTestCompleted(tr, ""FAIL: "",old_stderr);
     }
 
     /** Invoked each time a test method is skipped */
     public void onTestSkipped(ITestResult tr) {
-        onTestCompleted(tr,""SKIP: "",old_stderr);
+        onTestCompleted(tr, ""SKIP: "",old_stderr);
+    }
+
+    public void beforeConfiguration(ITestResult tr) {
+        setupStreams(tr, false);
+    }
+
+    public void onConfigurationSuccess(ITestResult tr) {
+
+    }
+
+    public void onConfigurationFailure(ITestResult tr) {
+        error(""failed config: "" + tr.getThrowable());
+        onTestCompleted(tr, ""FAIL: "", old_stderr);
     }
 
-    public String toString() {
-        return ""bla"";
+    public void onConfigurationSkip(ITestResult tr) {
     }
 
+
     protected void onTestCompleted(ITestResult tr, String message, PrintStream out) {
         Class<?> real_class=tr.getTestClass().getRealClass();
         addTest(real_class, tr);
         print(out, message , real_class.getName(), getMethodName(tr));
-        stdout.get().close();
-        stderr.get().close();
-        Util.close(tests.get());
+        closeStreams();
+    }
+
+    protected void setupStreams(ITestResult result, boolean printMethodName) {
+        String test_name=result.getTestClass().getName();
+        File dir=new File(output_dir + File.separator + test_name);
+        if(!dir.exists())
+            dir.mkdirs();
+        File _tests=new File(dir, TESTS), _stdout=new File(dir, STDOUT), _stderr=new File(dir, STDERR);
+        try {
+            if(tests.get() == null)
+                tests.set(new DataOutputStream(new FileOutputStream(_tests, true)));
+            if(stdout.get() == null)
+                stdout.set(new PrintStream(new FileOutputStream(_stdout, true)));
+            if(stderr.get() == null)
+                stderr.set(new PrintStream(new FileOutputStream(_stderr, true)));
+            if(printMethodName)
+                stdout.get().println(""\n\n------------- "" + getMethodName(result) + "" -----------"");
+        }
+        catch(IOException e) {
+            error(e.toString());
+        }
     }
 
+    protected static void closeStreams() {
+        Util.close(stdout.get());
+        stdout.set(null);
+        Util.close(stderr.get());
+        stderr.set(null);
+        Util.close(tests.get());
+        tests.set(null);
+    }
 
     protected static void print(PrintStream out, String msg, String classname, String method_name) {
-        out.println(msg + ""["" + Thread.currentThread().getId() + ""] "" + classname + "".""  + method_name + ""()"");
+        out.println(msg + ""["" + Thread.currentThread().getId() + ""] "" + classname + ""."" + method_name + ""()"");
     }
 
     protected void error(String msg) {
@@ -146,7 +171,7 @@ protected void addTest(Class<?> clazz, ITestResult result) {
                         test_case.setFailure(failure_type, failure_msg, stack_trace);
                     }
                     else
-                        test_case.setFailure(""SKIP"", null, null);
+                        test_case.setFailure(""exception"", ""SKIPPED"", null);
                     break;
             }
 
@@ -163,8 +188,13 @@ protected static String getMethodName(ITestResult tr) {
         String method_name=tr.getName();
         Object[] params=tr.getParameters();
         if(params != null && params.length > 0) {
-            String tmp=params[0] != null? params[0].getClass().getSimpleName() : null;
-            method_name=method_name + ""-"" + tmp;
+            String tmp=null;
+            if(params[0] instanceof Class<?>)
+                tmp=((Class<?>)params[0]).getSimpleName();
+            else if(params[0] != null)
+                tmp=params[0].getClass().getSimpleName();
+            if(tmp != null)
+                method_name=method_name + ""-"" + tmp;
         }
         return method_name;
     }
@@ -250,15 +280,13 @@ protected static void generateReport(Writer out, String classname, List<TestCase
         try {
             out.write(XML_DEF + ""\n"");
 
-            out.write(""\n<testsuite "" + "" failures=\""""
-                      + num_failures
-                      + ""\"" errors=\""""
-                      + num_errors
-                      + ""\"" skips=\""""
-                      + num_skips
-                      + ""\"" name=\""""
-                      + classname);
-            out.write(""\"" tests=\"""" + results.size() + ""\"" time=\"""" + (total_time / 1000.0) + ""\"">"");
+            out.write(""\n<testsuite ""
+                        + ""name=\""""   + classname + ""\"" ""
+                        + ""tests=\""""  + results.size() + ""\"" ""
+                        + ""failures=\"""" + num_failures + ""\"" ""
+                        + ""errors=\"""" + num_errors + ""\"" ""
+                        + ""skips=\""""  + num_skips + ""\"" ""
+                        + ""time=\""""    + (total_time / 1000.0) + ""\"">"");
 
             out.write(""\n<properties>"");
             Properties props=System.getProperties();
@@ -500,6 +528,8 @@ public void println(Object obj) {
 
         protected synchronized void append(String x, boolean newline) {
             PrintStream tmp=type == 1? stdout.get() : stderr.get();
+            if(tmp == null)
+                return;
             if(newline)
                 tmp.println(x);
             else
@@ -509,7 +539,7 @@ protected synchronized void append(String x, boolean newline) {
 
     public static void main(String[] args) throws IOException {
         JUnitXMLReporter reporter=new JUnitXMLReporter();
-        reporter.output_dir=""/home/bela/JGroups/tmp/test-results/xml/tcp"";
+        reporter.output_dir=""/home/bela/JGroups/tmp/test-results/xml/udp"";
         reporter.generateReports();
     }
 ",2012-02-09T10:30:19Z,151
"@@ -5,26 +5,23 @@
 import org.jgroups.logging.LogFactory;
 import org.jgroups.protocols.*;
 import org.jgroups.protocols.pbcast.FLUSH;
+import org.jgroups.stack.IpAddress;
 import org.jgroups.stack.Protocol;
 import org.jgroups.stack.ProtocolStack;
-import org.jgroups.stack.IpAddress;
 import org.jgroups.util.ResourceManager;
-import org.jgroups.util.Util;
 import org.jgroups.util.StackType;
+import org.jgroups.util.Util;
 import org.testng.AssertJUnit;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Optional;
-import org.testng.annotations.Parameters;
-import org.testng.annotations.Test;
+import org.testng.annotations.*;
 
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.net.InetAddress;
-import java.util.*;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
@@ -46,11 +43,12 @@ public class ChannelTestBase {
 
     private String bind_addr = null;
 
-    protected final Log log = LogFactory.getLog(this.getClass());
+    protected Log log;
 
     @BeforeClass
     @Parameters(value = { ""channel.conf"", ""use_blocking"" })
     protected void initializeBase(@Optional(""udp.xml"") String chconf, @Optional(""false"") String use_blocking) throws Exception {
+        log=LogFactory.getLog(this.getClass());
         Test annotation = this.getClass().getAnnotation(Test.class);
         // this should never ever happen!
         if (annotation == null)",2012-02-09T10:30:19Z,72
"@@ -10,32 +10,28 @@
 
 import java.io.*;
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * Tests state transfer API (including exception handling)
  * @author Bela Ban
  */
 @Test(groups=Global.STACK_DEPENDENT,sequential=true)
 public class StateTransferTest2 extends ChannelTestBase {
+    JChannel c1, c2;
 
 
     @DataProvider(name=""createChannels"")
-    protected Iterator<JChannel[]> createChannels() {
-        return new MyIterator(new Class[]{STATE_TRANSFER.class, STATE.class,
-          STATE_SOCK.class});
+    protected Iterator<Class<?>[]> createChannels() {
+        return new MyIterator(new Class<?>[]{STATE_TRANSFER.class, STATE.class, STATE_SOCK.class});
     }
 
-   /* @DataProvider(name=""createChannels"")
-    protected Iterator<JChannel[]> createChannels() {
-        return new MyIterator(new Class[]{STATE.class});
-    }*/
-
-
 
    
     @Test(dataProvider=""createChannels"")
-    public void testSuccessfulStateTransfer(final JChannel c1, final JChannel c2) throws Exception {
+    public void testSuccessfulStateTransfer(final Class<?> state_transfer_class) throws Exception {
         try {
+            createStateProviderAndRequesterChannels(state_transfer_class);
             StateHandler sh1=new StateHandler(""Bela"", false, false), sh2=new StateHandler(null, false, false);
             c1.setReceiver(sh1);
             c2.setReceiver(sh2);
@@ -50,8 +46,9 @@ public void testSuccessfulStateTransfer(final JChannel c1, final JChannel c2) th
     }
 
     @Test(dataProvider=""createChannels"")
-    public void testUnsuccessfulStateTransferFailureAtStateProvider(final JChannel c1, final JChannel c2) throws Exception {
+    public void testUnsuccessfulStateTransferFailureAtStateProvider(final Class<?> state_transfer_class) throws Exception {
         try {
+            createStateProviderAndRequesterChannels(state_transfer_class);
             StateHandler sh1=new StateHandler(""Bela"", true, false), sh2=new StateHandler(null, false, false);
             c1.setReceiver(sh1);
             c2.setReceiver(sh2);
@@ -73,7 +70,8 @@ public void testUnsuccessfulStateTransferFailureAtStateProvider(final JChannel c
 
 
     @Test(dataProvider=""createChannels"")
-    public void testUnsuccessfulStateTransferFailureAtStateRequester(final JChannel c1, final JChannel c2) throws Exception {
+    public void testUnsuccessfulStateTransferFailureAtStateRequester(final Class<?> state_transfer_class) throws Exception {
+        createStateProviderAndRequesterChannels(state_transfer_class);
         StateHandler sh1=new StateHandler(""Bela"", false, false), sh2=new StateHandler(null, false, true);
         c1.setReceiver(sh1);
         c2.setReceiver(sh2);
@@ -90,62 +88,51 @@ public void testUnsuccessfulStateTransferFailureAtStateRequester(final JChannel
     }
 
 
+    protected void createStateProviderAndRequesterChannels(Class state_transfer_class) throws Exception {
+        c1=createChannel(true, 2, ""Provider"");
+        replaceStateTransferProtocolWith(c1, state_transfer_class);
+        c2=createChannel(c1, ""Requester"");
+        c1.connect(""StateTransferTest2"");
+        c2.connect(""StateTransferTest2"");
+    }
 
-    protected class MyIterator implements Iterator<JChannel[]> {
-        protected final Class[] stream_transfer_prots;
-        protected int           index=0;
-
-        public MyIterator(Class[] stream_transfer_prots) {
-            this.stream_transfer_prots=stream_transfer_prots;
+    protected void replaceStateTransferProtocolWith(JChannel ch, Class<?> state_transfer_class) throws Exception {
+        ProtocolStack stack=ch.getProtocolStack();
+        if(stack.findProtocol(state_transfer_class) != null)
+            return; // protocol of the right class is already in stack
+        Protocol prot=stack.findProtocol(STATE_TRANSFER.class, StreamingStateTransfer.class);
+        Protocol new_state_transfer_protcol=(Protocol)state_transfer_class.newInstance();
+        if(prot != null) {
+            stack.replaceProtocol(prot, new_state_transfer_protcol);
+        }
+        else { // no state transfer protocol found in stack
+            Protocol flush=stack.findProtocol(FLUSH.class);
+            if(flush != null)
+                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
+            else
+                stack.insertProtocolAtTop(new_state_transfer_protcol);
         }
+    }
 
-        public boolean hasNext() {
-            return index < stream_transfer_prots.length;
-        }
 
-        public JChannel[] next() {
-            try {
-                Class next_class=stream_transfer_prots[index++];
-                System.out.println(""State transfer protocol used: "" + next_class);
-                return createStateProviderAndRequesterChannels(next_class);
-            }
-            catch(Exception e) {
-                throw new RuntimeException(""failed creating a new channel"", e);
-            }
-        }
 
-        public void remove() {
-        }
+    protected static class MyIterator implements Iterator<Class<?>[]> {
+        protected final Class<?>[] stream_transfer_prots;
+        protected int              index=0;
 
+        public MyIterator(Class<?>[] stream_transfer_prots) {
+            this.stream_transfer_prots=stream_transfer_prots;
+        }
 
+        public boolean hasNext() {return index < stream_transfer_prots.length;}
 
-        protected JChannel[] createStateProviderAndRequesterChannels(Class state_transfer_class) throws Exception {
-            JChannel[] retval=new JChannel[2];
-            retval[0]=createChannel(true, 2, ""Provider"");
-            replaceStateTransferProtocolWith(retval[0], state_transfer_class);
-            retval[1]=createChannel(retval[0], ""Requester"");
-            for(JChannel ch: retval)
-                ch.connect(""StateTransferTest2"");
-            return retval;
+        public Class<?>[] next() {
+            if(index+1 > stream_transfer_prots.length)
+                throw new NoSuchElementException();
+            return new Class<?>[]{stream_transfer_prots[index++]};
         }
 
-        protected void replaceStateTransferProtocolWith(JChannel ch, Class state_transfer_class) throws Exception {
-            ProtocolStack stack=ch.getProtocolStack();
-            if(stack.findProtocol(state_transfer_class) != null)
-                return; // protocol of the right class is already in stack
-            Protocol prot=stack.findProtocol(STATE_TRANSFER.class, StreamingStateTransfer.class);
-            Protocol new_state_transfer_protcol=(Protocol)state_transfer_class.newInstance();
-            if(prot != null) {
-                stack.replaceProtocol(prot, new_state_transfer_protcol);
-            }
-            else { // no state transfer protocol found in stack
-                Protocol flush=stack.findProtocol(FLUSH.class);
-                if(flush != null)
-                    stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
-                else
-                    stack.insertProtocolAtTop(new_state_transfer_protcol);
-            }
-        }
+        public void remove() {}
     }
 
 ",2012-02-09T10:30:19Z,152
"@@ -11,7 +11,7 @@
 RULE SendNewMessages
 CLASS SEQUENCER
 METHOD resend
-HELPER org.jgroups.tests.byteman.SequencerFailoverTestHelper
+HELPER org.jgroups.tests.helpers.SequencerFailoverTestHelper
 AFTER WRITE resending ALL
 BIND local_addr_name=org.jgroups.util.UUID.get($0.local_addr);
      map:java.util.Map=$0.forward_table;",2012-06-08T11:31:41Z,153
"@@ -1,5 +1,5 @@
 <!DOCTYPE suite SYSTEM ""http://testng.org/testng-1.0.dtd"">
-<!--<suite name=""byteman""
+<suite name=""byteman""
        parallel=""false""
        thread-count=""1"" >
 
@@ -14,19 +14,4 @@
             <package name=""org.jgroups.tests.byteman.*""/>
         </packages>
     </test>
-</suite>-->
-
-
-<suite name=""byteman"" parallel=""false"" thread-count=""1"">
-  <test name=""byteman"" junit=""false"" time-out=""120000"">
-
-      <!--
-      Due to classloader issues with TestNG, classes have to be listed individually (groups cannot be used)
-      -->
-      <classes>
-          <class name=""org.jgroups.tests.byteman.SequencerFailoverTest""/>
-          <class name=""org.jgroups.tests.byteman.RingBufferTest""/>
-      </classes>
-
-  </test>
 </suite>",2012-06-08T11:31:41Z,154
"@@ -1,4 +1,4 @@
-package org.jgroups.tests.byteman;
+package org.jgroups.tests.helpers;
 
 import org.jboss.byteman.rule.Rule;
 import org.jboss.byteman.rule.helper.Helper;",2012-06-08T11:31:41Z,155
"@@ -12,7 +12,7 @@
  * Keeps track of a range of messages to be retransmitted. A bit set is used to represent missing messages.
  * Every non-received message has a corresponding bit set to 0, every received message is 1.
  * @author Bela Ban
- * @version $Id: XmitRange.java,v 1.5 2009/11/25 08:51:54 belaban Exp $
+ * @version $Id: XmitRange.java,v 1.6 2009/11/25 08:55:32 belaban Exp $
  */
 public class XmitRange implements Comparable<XmitRange> {
     final long low;
@@ -54,45 +54,30 @@ public boolean contains(long num) {
     }
 
     public boolean get(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            return bits.get(index);
-        }
+        return bits.get(getIndex((int)num));
     }
 
     public void set(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            bits.set(index);
-        }
+        bits.set(getIndex((int)num));
     }
 
     public void set(long ... nums) {
-        if(nums == null)
-            return;
-        synchronized(this) {
+        if(nums != null)
             for(long num: nums)
                 set(num);
-        }
     }
 
     public void clear(long num) {
-        int index=getIndex((int)num);
-        synchronized(this) {
-            bits.clear(index);
-        }
+        bits.clear(getIndex((int)num));
     }
 
     public void clear(long ... nums) {
-        if(nums == null)
-            return;
-        synchronized(this) {
+        if(nums != null)
             for(long num: nums)
                 clear(num);
-        }
     }
 
-    public synchronized int getNumberOfReceivedMessages() {
+    public int getNumberOfReceivedMessages() {
         return bits.cardinality();
     }
 
@@ -180,7 +165,7 @@ public String printBits(boolean value) {
      * @param value If true, returns all bits set to 1, else 0
      * @return
      */
-    public synchronized Collection<Range> getBits(boolean value) {
+    public Collection<Range> getBits(boolean value) {
         int index=0;
         int start_range=0, end_range=0;
         int size=(int)((high - low) + 1);
@@ -202,52 +187,5 @@ public synchronized Collection<Range> getBits(boolean value) {
         return retval;
     }
     
-
-    public static void main(String[] args) throws IOException, ChannelException {
-        XmitRange range=new XmitRange(10,20);
-        System.out.println(""range = "" + range.print());
-
-        range.set(12);
-        range.set(17);
-        range.set(10);
-        range.set(11);
-        System.out.println(""range = "" + range.print());
-
-        boolean set=range.get(12);
-        System.out.println(""set = "" + set);
-
-        set=range.get(17);
-        System.out.println(""set = "" + set);
-
-        System.out.println(""msgs to retransmit: "" + range.printBits(false));
-
-
-
-       /* TreeMap<MyRange,MyRange> map=new TreeMap<MyRange,MyRange>();
-
-        MyRange[] ranges=new MyRange[]{new MyRange(23,200), new MyRange(222,222), new MyRange(700,800), new MyRange(900,905)};
-
-        for(MyRange range: ranges)
-            map.put(range, range);
-
-
-        System.out.println(""map = "" + map.keySet());
-
-
-        for(long num: new long[]{0, 1, 23, 100, 200, 201, 202, 222, 223, 750, 899, 905, 1000}) {
-            MyRange range=get(num, map);
-            if(range != null && range.contains(num))
-                System.out.println(""range for "" + num + "": "" + range);
-            else
-                System.out.println(""range for "" + num + "": "" + range);
-        }*/
-    }
-
-
-    public static XmitRange get(long num, Map<XmitRange, XmitRange> map) {
-        XmitRange range=map.get(new XmitRange(num, true));
-        if(range != null && range.contains(num))
-            return range;
-        return null;
-    }
+  
 }",2009-11-25T08:55:32Z,156
"@@ -0,0 +1,60 @@
+#!/bin/bash
+
+#Author: Pedro Ruivo
+#Since: 3.1
+#Note: I'm assuming that jgroups-<version>.jar is in the same directory as this script. The same applies for
+#      for the log4j.properties
+
+WORKING_DIR=`cd $(dirname $0); pwd`
+HOSTNAME=`hostname`
+CP=""${WORKING_DIR}/jgroups*.jar""
+
+#enable remote JMX
+JMX=""-Dcom.sun.management.jmxremote.port=8081 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false""
+
+#jgroups flags
+JG_FLAGS=""-Dresolve.dns=false -Djgroups.bind_addr=${HOSTNAME} -Djava.net.preferIPv4Stack=true -Djgroups.timer.num_threads=4""
+
+#log4j
+LOG4J=""-Dlog4j.configuration=file:${WORKING_DIR}/log4j.properties""
+
+#java flags
+JAVA_FLAGS=""-server -Xmx7G -Xms7G""
+
+while [ -n ""$1"" ]; do
+case $1 in
+  -h) HELP=""1""; break;;
+  -test-order) ORDER=""1""; shift 1; break;;
+  -nr-nodes) NR_NODES=$2; shift 2;;
+  -nr-messages) NR_MESSAGES=$2; shift 2;;
+  -config) CONFIG=$2; shift 2;;
+  -*) echo ""unknown option $1""; shift 1;;
+  *) echo ""unknown argument $1""; shift 1;;
+esac;
+done
+
+if [ -n ""${HELP}"" ]; then
+ARGS=""-h""
+else if [ -n ""${ORDER}"" ]; then
+CMD=""java ${JAVA_FLAGS} -cp ${CP} ${JMX} ${JG_FLAGS} ${LOG4J} org.jgroups.tests.CheckGroupMulticastOrder $*""
+echo ${CMD}
+${CMD} > ${WORKING_DIR}/check_std_out_${HOSTNAME}.out 2>&1 &
+exit 0
+ARGS=""-test-order $*""
+else
+if [ -n ""${NR_NODES}"" ]; then
+ARGS=""-nr-nodes ${NR_NODES}""
+fi
+if [ -n ""${NR_MESSAGES}"" ]; then
+ARGS=""${ARGS} -nr-messages ${NR_MESSAGES}""
+fi
+if [ -n ""${CONFIG}"" ]; then
+ARGS=""${ARGS} -config ${CONFIG}""
+fi
+fi
+fi
+
+CMD=""java ${JAVA_FLAGS} -cp ${CP} ${JMX} ${JG_FLAGS} ${LOG4J} org.jgroups.tests.TestGroupMulticastOrder ${ARGS}""
+
+echo ${CMD}
+${CMD} > ${WORKING_DIR}/std_out_${HOSTNAME}.out 2>&1 &",2012-03-23T12:18:00Z,157
"@@ -0,0 +1,73 @@
+<config
+        xmlns=""urn:org:jgroups""
+        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+        xsi:schemaLocation=""urn:org:jgroups http://www.jgroups.org/schema/JGroups-3.0.xsd"">
+    <TCP
+            bind_port=""7800""
+            loopback=""false""
+            recv_buf_size=""${tcp.recv_buf_size:20M}""
+            send_buf_size=""${tcp.send_buf_size:640K}""
+            discard_incompatible_packets=""true""
+            max_bundle_size=""64K""
+            max_bundle_timeout=""2""
+            enable_bundling=""true""
+            use_send_queues=""true""
+            sock_conn_timeout=""300""
+            thread_naming_pattern=""cl""
+
+            timer_type=""new""
+            timer.min_threads=""4""
+            timer.max_threads=""10""
+            timer.keep_alive_time=""3000""
+            timer.queue_max_size=""500""
+
+            thread_pool.enabled=""true""
+            thread_pool.min_threads=""8""
+            thread_pool.max_threads=""64""
+            thread_pool.keep_alive_time=""50000""
+            thread_pool.queue_enabled=""true""
+            thread_pool.queue_max_size=""1000""
+            thread_pool.rejection_policy=""discard""
+
+            oob_thread_pool.enabled=""true""
+            oob_thread_pool.min_threads=""8""
+            oob_thread_pool.max_threads=""64""
+            oob_thread_pool.keep_alive_time=""5000""
+            oob_thread_pool.queue_enabled=""false""
+            oob_thread_pool.queue_max_size=""1000""
+            oob_thread_pool.rejection_policy=""discard"" />
+    <TCPGOSSIP
+            initial_hosts=""${jgroups.gossip_host:localhost}[12001]""/>
+    <MERGE2
+            max_interval=""30000""
+            min_interval=""10000""/>
+    <FD_SOCK/>
+    <BARRIER/>
+    <pbcast.NAKACK
+            exponential_backoff=""300""
+            use_mcast_xmit=""false""
+            xmit_stagger_timeout=""200""
+            discard_delivered_msgs=""true""/>
+    <UNICAST2
+            exponential_backoff=""500""/>
+    <pbcast.STABLE
+            stability_delay=""2000""
+            desired_avg_gossip=""10000""
+            max_bytes=""4M""
+            cap=""0.1""/>
+    <pbcast.GMS
+            print_local_addr=""true""
+            join_timeout=""3000""
+            max_bundling_time=""500""
+            view_bundling=""true""/>
+    <UFC
+            max_credits=""4M""
+            min_threshold=""0.4""/>
+    <MFC
+            max_credits=""4M""
+            min_threshold=""0.4""/>
+    <FRAG2
+            frag_size=""60K""/>
+    <pmcast.GROUP_MULTICAST />
+    <pbcast.STATE_TRANSFER/>
+</config>
\ No newline at end of file",2012-03-23T12:18:00Z,158
"@@ -55,4 +55,5 @@
     <class id=""92"" name=""org.jgroups.tests.perf.MPerf$MPerfHeader""/>
     <class id=""93"" name=""org.jgroups.protocols.pbcast.NakAckHeader2""/>
     <class id=""94"" name=""org.jgroups.util.SeqnoList""/>
+    <class id=""95"" name=""org.jgroups.protocols.pmcast.header.GroupMulticastHeader""/>
 </magic-number-class-mapping>",2012-03-23T12:18:00Z,138
"@@ -54,6 +54,7 @@
     <class id=""55"" name=""org.jgroups.protocols.RSVP""/>
     <class id=""56"" name=""org.jgroups.protocols.RACKSPACE_PING""/>
     <class id=""57"" name=""org.jgroups.protocols.pbcast.NAKACK2""/>
+    <class id=""58"" name=""org.jgroups.protocols.pmcast.GROUP_MULTICAST""/>
 
     <!-- IDs reserved for building blocks -->
     <class id=""200"" name=""org.jgroups.blocks.RequestCorrelator""/> <!-- ID should be the same as Global.BLOCKS_START_ID -->",2012-03-23T12:18:00Z,104
"@@ -0,0 +1,18 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Message;
+
+/**
+ * The interface that the Total Order Multicast protocol must implement. This is invoked by the deliver thread
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public interface DeliverProtocol {
+
+    /**
+     * deliver a message
+     * @param message   message to deliver
+     */
+    void deliver(Message message);
+}",2012-03-23T12:18:00Z,159
"@@ -0,0 +1,454 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.View;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.protocols.pmcast.header.GroupMulticastHeader;
+import org.jgroups.protocols.pmcast.manager.DeliverManagerImpl;
+import org.jgroups.protocols.pmcast.manager.SenderManager;
+import org.jgroups.protocols.pmcast.manager.SequenceNumberManager;
+import org.jgroups.protocols.pmcast.stats.StatsCollector;
+import org.jgroups.protocols.pmcast.threading.DeliverThread;
+import org.jgroups.protocols.pmcast.threading.SenderThread;
+import org.jgroups.stack.Protocol;
+
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**  
+ * Total Order Multicast with three communication steps (based on Skeen's Algorithm)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+@MBean(description = ""Implementation of Total Order Multicast based on Skeen's Algorithm"")
+public class GROUP_MULTICAST extends Protocol implements DeliverProtocol {
+    //managers
+    private DeliverManagerImpl deliverManager;
+    private SenderManager senderManager;
+
+    //thread
+    private final DeliverThread deliverThread;
+    private final SenderThread multicastSenderThread;
+
+    //local address
+    private Address localAddress;
+
+    //sequence numbers, messages ids and lock
+    private final SequenceNumberManager sequenceNumberManager;
+    private long messageIdCounter;
+    private final Lock sendLock;
+
+    //stats: profiling information
+    private final StatsCollector statsCollector;
+
+    public GROUP_MULTICAST() {
+        statsCollector = new StatsCollector();
+        deliverThread = new DeliverThread(this);
+        multicastSenderThread = new SenderThread(this);
+        sequenceNumberManager = new SequenceNumberManager();
+        sendLock = new ReentrantLock();
+        messageIdCounter = 0;
+    }
+
+    @Override
+    public void start() throws Exception {
+        deliverManager = new DeliverManagerImpl();
+        senderManager = new SenderManager();
+        deliverThread.start(deliverManager);
+        multicastSenderThread.clear();
+        multicastSenderThread.start();
+        statsCollector.setStatsEnabled(statsEnabled());
+    }
+
+    @Override
+    public void stop() {
+        deliverThread.interrupt();
+        multicastSenderThread.interrupt();
+    }
+
+    @Override
+    public Object down(Event evt) {
+        switch (evt.getType()) {
+            case Event.MSG:
+                handleDownMessage(evt);
+                return null;
+            case Event.SET_LOCAL_ADDRESS:
+                this.localAddress = (Address) evt.getArg();
+                multicastSenderThread.setLocalAddress(localAddress);
+                break;
+            case Event.VIEW_CHANGE:
+                handleViewChange((View) evt.getArg());
+                break;
+            default:
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+    @Override
+    public Object up(Event evt) {
+        switch (evt.getType()) {
+            case Event.MSG:
+                Message message = (Message) evt.getArg();
+
+                GroupMulticastHeader header = (GroupMulticastHeader) message.getHeader(this.id);
+
+                if (header == null) {
+                    break;
+                }
+
+                switch (header.getType()) {
+                    case GroupMulticastHeader.DATA_MESSAGE:
+                        handleDataMessage(message, header);
+                        break;
+                    case GroupMulticastHeader.PROPOSE_MESSAGE:
+                        handleSequenceNumberPropose(message.getSrc(), header);
+                        break;
+                    case GroupMulticastHeader.FINAL_MESSAGE:
+                        handleFinalSequenceNumber(header);
+                        break;
+                    default:
+                        throw new IllegalStateException(""Unknown header type received "" + header);
+                }
+                return null;
+            case Event.VIEW_CHANGE:
+                handleViewChange((View) evt.getArg());
+                break;
+            case Event.SET_LOCAL_ADDRESS:
+                this.localAddress = (Address) evt.getArg();
+                multicastSenderThread.setLocalAddress(localAddress);
+                break;
+            default:
+                break;
+        }
+        return up_prot.up(evt);
+    }
+
+    @Override
+    public void deliver(Message message) {
+        message.setDest(localAddress);
+
+        if (log.isDebugEnabled()) {
+            log.debug(""Deliver message "" + message + "" in total order"");
+        }
+
+        up_prot.up(new Event(Event.MSG, message));
+        statsCollector.incrementMessageDeliver();
+    }
+
+    private void handleViewChange(View view) {
+        if (log.isTraceEnabled()) {
+            log.trace(""Handle view "" + view);
+        }
+        // TODO: Future work: How to add fault tolerance? (simple and efficient)
+    }
+
+    private void handleDownMessage(Event evt) {
+        Message message = (Message) evt.getArg();
+        Address dest = message.getDest();
+
+        if (dest != null && dest instanceof GroupAddress && !message.isFlagSet(Message.Flag.NO_TOTAL_ORDER)) {
+            //group multicast message
+            handleDownGroupMulticastMessage(message);
+        } else if (dest != null && dest instanceof GroupAddress) {
+            //group address with NO_TOTAL_ORDER flag (should no be possible, but...)
+            handleDownGroupMessage(message);
+        } else {
+            //normal message
+            down_prot.down(evt);
+        }
+    }
+
+    private void handleDownGroupMessage(Message message) {
+        if (log.isTraceEnabled()) {
+            log.trace(""Handle message with Group Address but with Flag NO_TOTAL_ORDER set"");
+        }
+        GroupAddress groupAddress = (GroupAddress) message.getDest();
+        try {
+            multicastSenderThread.addMessage(message, groupAddress.getAddresses());
+        } catch (Exception e) {
+            logException(""Exception caugh while send a NO-TOTAL-ORDER group multicast"", e);
+        }
+    }
+
+    private void handleDownGroupMulticastMessage(Message message) {
+        boolean trace = log.isTraceEnabled();
+        boolean warn = log.isWarnEnabled();
+
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        if (trace) {
+            log.trace(""Handle group multicast message"");
+        }
+        GroupAddress groupAddress = (GroupAddress) message.getDest();
+        Set<Address> destination = groupAddress.getAddresses();
+
+        if (destination.isEmpty()) {
+            if (warn) {
+                log.warn(""Received a group address with an empty list"");
+            }
+            throw new IllegalStateException(""Group Address must have at least one element"");
+        }
+
+        if (destination.size() == 1) {
+            if (warn) {
+                log.warn(""Received a group address with an element"");
+            }
+            message.setDest(destination.iterator().next());
+            down_prot.down(new Event(Event.MSG, message));
+            return;
+        }
+
+        boolean deliverToMySelf = destination.contains(localAddress);
+
+        sendLock.lock();
+        try {
+            MessageID messageID = new MessageID(localAddress, messageIdCounter++);
+            long sequenceNumber = sequenceNumberManager.getAndIncrement();
+
+            GroupMulticastHeader header = GroupMulticastHeader.createNewHeader(GroupMulticastHeader.DATA_MESSAGE,
+                    messageID);
+            header.setSequencerNumber(sequenceNumber);
+            header.addDestinations(destination);
+            message.putHeader(this.id, header);
+
+            senderManager.addNewMessageToSent(messageID, destination, sequenceNumber, deliverToMySelf);
+
+            if (deliverToMySelf) {
+                deliverManager.addNewMessageToDeliver(messageID, message, sequenceNumber);
+            }
+
+            if (trace) {
+                log.trace(""Sending message "" + messageID + "" to "" + destination + "" with initial sequence number of "" +
+                        sequenceNumber);
+            }
+
+            multicastSenderThread.addMessage(message, destination);
+
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while handling group multicast message. Error is "" + e.getLocalizedMessage(),
+                    e);
+        } finally {
+            sendLock.unlock();
+            statsCollector.addGroupMulticastSentDuration(duration, (destination.size() - (deliverToMySelf ? 1 : 0)));
+        }
+    }
+
+    private void handleDataMessage(Message message, GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        try {
+            MessageID messageID = header.getMessageID();
+
+            //create the sequence number and put it in deliver manager
+            long myProposeSequenceNumber = sequenceNumberManager.updateAndGet(header.getSequencerNumber());
+            deliverManager.addNewMessageToDeliver(messageID, message, myProposeSequenceNumber);
+
+            if (log.isTraceEnabled()) {
+                log.trace(""Received the message with "" + header + "". The proposed sequence number is "" +
+                        myProposeSequenceNumber);
+            }
+
+            //create a new message and send it back
+            Message proposeMessage = new Message();
+            proposeMessage.setSrc(localAddress);
+            proposeMessage.setDest(messageID.getAddress());
+
+            GroupMulticastHeader newHeader = GroupMulticastHeader.createNewHeader(
+                    GroupMulticastHeader.PROPOSE_MESSAGE, messageID);
+
+            newHeader.setSequencerNumber(myProposeSequenceNumber);
+            proposeMessage.putHeader(this.id, newHeader);
+            proposeMessage.setFlag(Message.Flag.OOB);
+            proposeMessage.setFlag(Message.Flag.DONT_BUNDLE);
+
+            //multicastSenderThread.addUnicastMessage(proposeMessage);
+            down_prot.down(new Event(Event.MSG, proposeMessage));
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the data message "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addDataMessageDuration(duration);
+        }
+    }
+
+    private void handleSequenceNumberPropose(Address from, GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+        boolean lastProposeReceived = false;
+
+        boolean trace = log.isTraceEnabled();
+        try {
+            MessageID messageID = header.getMessageID();
+            if (trace) {
+                log.trace(""Received the proposed sequence number message with "" + header + "" from "" +
+                        from);
+            }
+
+            sequenceNumberManager.update(header.getSequencerNumber());
+            long finalSequenceNumber = senderManager.addPropose(messageID, from,
+                    header.getSequencerNumber());
+
+            if (finalSequenceNumber != SenderManager.NOT_READY) {
+                lastProposeReceived = true;
+                Message finalMessage = new Message();
+                finalMessage.setSrc(localAddress);
+
+                GroupMulticastHeader finalHeader = GroupMulticastHeader.createNewHeader(
+                        GroupMulticastHeader.FINAL_MESSAGE, messageID);
+
+                finalHeader.setSequencerNumber(finalSequenceNumber);
+                finalMessage.putHeader(this.id, finalHeader);
+                finalMessage.setFlag(Message.Flag.OOB);
+                finalMessage.setFlag(Message.Flag.DONT_BUNDLE);
+
+                Set<Address> destination = senderManager.getDestination(messageID);
+                if (destination.contains(localAddress)) {
+                    destination.remove(localAddress);
+                }
+
+                if (trace) {
+                    log.trace(""Message "" + messageID + "" is ready to be deliver. Final sequencer number is "" +
+                            finalSequenceNumber);
+                }
+
+                multicastSenderThread.addMessage(finalMessage, destination);
+                //returns true if we are in destination set
+                if (senderManager.markSent(messageID)) {
+                    deliverManager.markReadyToDeliver(messageID, finalSequenceNumber);
+                }
+            }
+
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the propose sequence number for "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addProposeSequenceNumberDuration(duration, lastProposeReceived);
+        }
+    }
+
+    private void handleFinalSequenceNumber(GroupMulticastHeader header) {
+        long startTime = statsCollector.now();
+        long duration = -1;
+
+        try {
+            MessageID messageID = header.getMessageID();
+            if (log.isTraceEnabled()) {
+                log.trace(""Received the final sequence number message with "" + header);
+            }
+
+            sequenceNumberManager.update(header.getSequencerNumber());
+            deliverManager.markReadyToDeliver(messageID, header.getSequencerNumber());
+            duration = statsCollector.now() - startTime;
+        } catch (Exception e) {
+            logException(""Exception caught while processing the final sequence number for "" + header.getMessageID(), e);
+        } finally {
+            statsCollector.addFinalSequenceNumberDuration(duration);
+        }
+    }
+
+    private void logException(String msg, Exception e) {
+        if (log.isDebugEnabled()) {
+            log.debug(msg, e);
+        } else if (log.isWarnEnabled()) {
+            log.warn(msg + "". Error is "" + e.getLocalizedMessage());
+        }
+    }
+
+    @ManagedOperation
+    public String getMessageList() {
+        return deliverManager.getMessageSet().toString();
+    }
+
+    @Override
+    public void enableStats(boolean flag) {
+        super.enableStats(flag);
+        statsCollector.setStatsEnabled(flag);
+    }
+
+    @Override
+    public void resetStats() {
+        super.resetStats();
+        statsCollector.clearStats();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing and sending the group "" +
+            ""multicast message to all the recipients"", writable = false)
+    public double getAvgGroupMulticastSentDuration() {
+        return statsCollector.getAvgGroupMulticastSentDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a data message received"",
+            writable = false)
+    public double getAvgDataMessageReceivedDuration() {
+        return statsCollector.getAvgDataMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a propose message received"" +
+            ""(not the last one"", writable = false)
+    public double getAvgProposeMessageReceivedDuration() {
+        return statsCollector.getAvgProposeMesageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing the last propose message "" +
+            ""received. This last propose message will originate the sending of the final message"", writable = false)
+    public double getAvgLastProposeMessageReceivedDuration() {
+        return statsCollector.getAvgLastProposeMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The average duration (in milliseconds) in processing a final message received"",
+            writable = false)
+    public double getAvgFinalMessageReceivedDuration() {
+        return statsCollector.getAvgFinalMessageReceivedDuration();
+    }
+
+    @ManagedAttribute(description = ""The number of group multicast messages sent"", writable = false)
+    public int getNumberOfGroupMulticastMessagesSent() {
+        return statsCollector.getNumberOfGroupMulticastMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of final group messages sent"", writable = false)
+    public int getNumberOfFinalGroupMessagesSent() {
+        return statsCollector.getNumberOfFinalGroupMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of group multicast messages delivered"", writable = false)
+    public int getNumberOfGroupMulticastMessagesDelivered() {
+        return statsCollector.getGroupMulticastDelivered();
+    }
+
+    @ManagedAttribute(description = ""The number of propose messages sent"", writable = false)
+    public int getNumberOfProposeMessageSent() {
+        return statsCollector.getNumberOfProposeMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of final messages delivered"", writable = false)
+    public int getNumberOfFinalMessagesDelivered() {
+        return statsCollector.getNumberOfFinalMessagesDelivered();
+    }
+
+    @ManagedAttribute(description = ""The number of data messages delivered"", writable = false)
+    public int getNumberOfDataMessagesDelivered() {
+        return statsCollector.getNumberOfProposeMessagesSent();
+    }
+
+    @ManagedAttribute(description = ""The number of propose messages received"", writable = false)
+    public int getNumberOfProposeMessageReceived() {
+        return statsCollector.getNumberOfProposeMessagesReceived();
+    }
+
+    @ManagedAttribute(description = ""The average number of unicasts messages created per group multicast message"",
+            writable = false)
+    public double getAvgNumberOfUnicastSentPerGroupMulticast() {
+        return statsCollector.getAvgNumberOfUnicastSentPerGroupMulticast();
+    }
+}",2012-03-23T12:18:00Z,160
"@@ -0,0 +1,117 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.Global;
+import org.jgroups.util.Util;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ * This type of address represents a group in which the total order properties must be applied
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class GroupAddress implements Address {
+    private Set<Address> destinations;
+
+    public GroupAddress() {
+        destinations = new HashSet<Address>();
+    }
+
+    public void addAddress(Address address) {
+        destinations.add(address);
+    }
+
+    public void addAllAddress(Collection<Address> addresses) {
+        destinations.addAll(addresses);
+    }
+
+    public Set<Address> getAddresses() {
+        return destinations;
+    }
+
+    public int size() {
+        int size = Global.INT_SIZE;
+        for(Address address : destinations) {
+            size += Util.size(address);
+        }
+        return size;
+    }
+
+    @Override
+    public String toString() {
+        return ""GroupAddress{"" + destinations + ""}"";
+    }
+
+    @Override
+    public int hashCode() {
+        int hc = 0;
+        for(Address address : destinations) {
+            hc += address.hashCode();
+        }
+        return hc;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(obj == null) return false;
+        if(!(obj instanceof GroupAddress)) {
+            return false;
+        }
+
+        GroupAddress other = (GroupAddress) obj;
+
+        return other == this || (this.destinations.containsAll(other.destinations) &&
+                other.destinations.containsAll(this.destinations));
+    }
+
+    public int compareTo(Address o) {
+        int hc1, hc2;
+
+        if(this == o) return 0;
+        if(!(o instanceof GroupAddress))
+            throw new ClassCastException(""comparison between different classes: the other object is "" +
+                    (o != null? o.getClass() : o));
+        GroupAddress other = (GroupAddress) o;
+
+        hc1 = this.hashCode();
+        hc2 = other.hashCode();
+
+        if(hc1 == hc2) {
+            return this.destinations.size() < other.destinations.size() ? -1 :
+                    this.destinations.size() > other.destinations.size() ? 1 : 0;
+        } else {
+            return hc1 < hc2 ? -1 : 1;
+        }
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        Util.writeAddresses(destinations, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        destinations = (Set<Address>) Util.readAddresses(in, HashSet.class);
+    }
+
+    @Override
+    public void writeExternal(ObjectOutput objectOutput) throws IOException {
+        try {
+            writeTo(objectOutput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
+        try {
+            readFrom(objectInput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+}
\ No newline at end of file",2012-03-23T12:18:00Z,161
"@@ -0,0 +1,113 @@
+package org.jgroups.protocols.pmcast;
+
+import org.jgroups.Address;
+import org.jgroups.util.Streamable;
+import org.jgroups.util.Util;
+
+import java.io.*;
+
+/**
+ * The represents an unique identifier for the messages processed by the Total Order Multicast protocol
+ * 
+ * Note: it is similar to the ViewId (address + counter)
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class MessageID implements Externalizable, Comparable<MessageID>, Cloneable, Streamable {
+    private Address address = null;
+    private long id = -1;
+
+    public MessageID() {}
+
+    public MessageID(Address address, long id) {
+        this.address = address;
+        this.id = id;
+    }
+
+    public MessageID(Address address) {
+        this.address = address;
+    }
+
+    public void setID(long id) {
+        this.id = id;
+    }
+
+    @Override
+    public int compareTo(MessageID other) {
+        if(other == null) return 1;
+
+        if(this.getId() < other.getId()){
+            return -1;
+        } else if(this.getId() > other.getId()){
+            return 1;
+        }
+
+        return this.address.compareTo(other.address);
+    }
+
+    public MessageID copy() {
+        return (MessageID) clone();
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public Address getAddress() {
+        return address;
+    }
+
+    @Override
+    public String toString() {
+        return ""MessageID{"" + address + "":"" + id + ""}"";
+    }
+
+    public Object clone() {
+        return new MessageID(address, id);
+    }
+
+    public boolean equals(Object other) {
+        return (other instanceof MessageID) && compareTo((MessageID) other) == 0;
+    }
+
+
+    public int hashCode() {
+        return (int)id;
+    }
+
+
+    public int serializedSize() {
+        return Util.size(id) + Util.size(address);
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        Util.writeAddress(address, out);
+        Util.writeLong(id, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        address = Util.readAddress(in);
+        id = Util.readLong(in);
+    }
+
+    @Override
+    public void writeExternal(ObjectOutput objectOutput) throws IOException {
+        try {
+            writeTo(objectOutput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
+        try {
+            readFrom(objectInput);
+        } catch (Exception e) {
+            throw new IOException(e);
+        }
+    }
+}",2012-03-23T12:18:00Z,162
"@@ -0,0 +1,126 @@
+package org.jgroups.protocols.pmcast.header;
+
+import org.jgroups.Address;
+import org.jgroups.Global;
+import org.jgroups.Header;
+import org.jgroups.protocols.pmcast.MessageID;
+import org.jgroups.util.Util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * The header for the Total Order Multicast protocol
+ * 
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class GroupMulticastHeader extends Header {
+
+    //type
+    public static final byte DATA_MESSAGE = 1;
+    public static final byte PROPOSE_MESSAGE = 1 << 1;
+    public static final byte FINAL_MESSAGE = 1 << 2;
+
+    private byte type = 0;
+    private MessageID messageID; //address and sequence number
+    private long sequencerNumber;
+    private Set<Address> destination = new HashSet<Address>();
+
+    public GroupMulticastHeader() {
+        messageID = new MessageID();
+    }
+
+    public MessageID getMessageID() {
+        return messageID;
+    }
+
+    public Address getOrigin() {
+        return messageID.getAddress();
+    }
+
+    public void addDestinations(Collection<Address> addresses) {
+        destination.addAll(addresses);
+    }
+
+    public Set<Address> getDestinations() {
+        return destination;
+    }
+
+    public long getSequencerNumber() {
+        return sequencerNumber;
+    }
+
+    public void setSequencerNumber(long sequencerNumber) {
+        this.sequencerNumber = sequencerNumber;
+    }
+
+    public byte getType() {
+        return type;
+    }
+
+    @Override
+    public int size() {
+        return (int) (Global.BYTE_SIZE  + messageID.serializedSize() + Util.size(sequencerNumber) +
+                Util.size(destination));
+    }
+
+    @Override
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type);
+        messageID.writeTo(out);
+        Util.writeLong(sequencerNumber, out);
+        Util.writeAddresses(destination, out);
+    }
+
+    @Override
+    public void readFrom(DataInput in) throws Exception {
+        type = in.readByte();
+        messageID.readFrom(in);
+        sequencerNumber = Util.readLong(in);
+        destination = (Set<Address>) Util.readAddresses(in, HashSet.class);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(""GroupMulticastHeader{"")
+                .append(""type="").append(type2String(type))
+                .append("", message_id="").append(messageID)
+                .append("", sequence_number="").append(sequencerNumber)
+                .append("", destinations="").append(destination)
+                .append(""}"");
+        return sb.toString();
+    }
+
+    public static String type2String(byte type) {
+        switch(type) {
+            case DATA_MESSAGE: return ""DATA_MESSAGE"";
+            case PROPOSE_MESSAGE: return ""PROPOSE_MESSAGE"";
+            case FINAL_MESSAGE: return""FINAL_MESSAGE"";
+            default: return ""UNKNOWN"";
+        }
+    }
+
+    public static GroupMulticastHeader createNewHeader(byte type, MessageID messageID) {
+        if (messageID == null) {
+            throw new NullPointerException(""The message ID can't be null"");
+        }
+        GroupMulticastHeader header = new GroupMulticastHeader();
+        header.setType(type);
+        header.setMessageID(messageID);
+        return header;
+    }
+
+    private void setType(byte type) {
+        this.type = type;
+    }
+
+    private void setMessageID(MessageID messageID) {
+        this.messageID = messageID;
+    }
+}
+",2012-03-23T12:18:00Z,163
"@@ -0,0 +1,23 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Message;
+
+import java.util.List;
+
+/**
+ * The interface that a deliver manager must implement. This method is invoked by the deliver thread
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public interface DeliverManager {
+
+    /**
+     * returns an ordered list with the messages to be deliver.
+     * This method blocks if no messages are ready to be deliver
+     *
+     * @return a list of messages to deliver
+     * @throws InterruptedException if it is interrupted
+     */
+    List<Message> getNextMessagesToDeliver() throws InterruptedException;
+}",2012-03-23T12:18:00Z,164
"@@ -0,0 +1,253 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Message;
+import org.jgroups.protocols.pmcast.MessageID;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * The implementation of the Deliver Manager
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class DeliverManagerImpl implements DeliverManager {
+    private static final MessageInfoComparator COMPARATOR = new MessageInfoComparator();
+    private final SortedSet<MessageInfo> toDeliverSet = new TreeSet<MessageInfo>(COMPARATOR);
+    private final ConcurrentMap<MessageID, MessageInfo> messageCache = new ConcurrentHashMap<MessageID, MessageInfo>(8192, .75f, 64);
+
+    /**
+     * Add a new group message to be deliver 
+     * @param messageID         the message ID
+     * @param message           the message (needed to be deliver later)
+     * @param sequenceNumber    the initial sequence number
+     */
+    public void addNewMessageToDeliver(MessageID messageID, Message message, long sequenceNumber) {
+        MessageInfo messageInfo = new MessageInfo(messageID, message, sequenceNumber);
+        synchronized (toDeliverSet) {
+            toDeliverSet.add(messageInfo);
+        }
+        messageCache.put(messageID, messageInfo);
+    }
+
+    /**
+     * marks the message as ready to deliver and set the final sequence number (to be ordered)
+     * @param messageID             the message ID
+     * @param finalSequenceNumber   the final sequence number
+     */
+    public void markReadyToDeliver(MessageID messageID, long finalSequenceNumber) {
+        markReadyToDeliverV2(messageID, finalSequenceNumber);
+    }
+
+    @SuppressWarnings({""SuspiciousMethodCalls""})    
+    private void markReadyToDeliverV1(MessageID messageID, long finalSequenceNumber) {
+        //This is an old version. It was the bottleneck. Updated to version 2. It can be removed later
+        synchronized (toDeliverSet) {
+            MessageInfo messageInfo = null;
+            boolean needsUpdatePosition = false;
+            Iterator<MessageInfo> iterator = toDeliverSet.iterator();
+
+            while (iterator.hasNext()) {
+                MessageInfo aux = iterator.next();
+                if (aux.equals(messageID)) {
+                    messageInfo = aux;
+                    if (messageInfo.sequenceNumber != finalSequenceNumber) {
+                        needsUpdatePosition = true;
+                        iterator.remove();
+                    }
+                    break;
+                }
+            }
+
+            if (messageInfo == null) {
+                throw new IllegalStateException(""Message ID not found in to deliver list. this can't happen. "" +
+                        ""Message ID is "" + messageID);
+            }
+            messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+            if (needsUpdatePosition) {
+                toDeliverSet.add(messageInfo);
+            }
+
+            if (!toDeliverSet.isEmpty() && toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.notify();
+            }
+        }
+    }
+
+    private void markReadyToDeliverV2(MessageID messageID, long finalSequenceNumber) {
+        MessageInfo messageInfo = messageCache.remove(messageID);
+
+        if (messageInfo == null) {
+            throw new IllegalStateException(""Message ID not found in to deliver list. this can't happen. "" +
+                    ""Message ID is "" + messageID);
+        }
+
+        boolean needsUpdatePosition = messageInfo.isUpdatePositionNeeded(finalSequenceNumber);
+
+        synchronized (toDeliverSet) {
+            if (needsUpdatePosition) {
+                toDeliverSet.remove(messageInfo);
+                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+                toDeliverSet.add(messageInfo);
+            } else {
+                messageInfo.updateAndmarkReadyToDeliver(finalSequenceNumber);
+            }
+            
+            if (toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.notify();
+            }
+        }
+    }
+
+    //see the interface javadoc
+    @Override
+    public List<Message> getNextMessagesToDeliver() throws InterruptedException {
+        LinkedList<Message> toDeliver = new LinkedList<Message>();
+        synchronized (toDeliverSet) {
+            while (toDeliverSet.isEmpty()) {
+                toDeliverSet.wait();
+            }
+
+            if (!toDeliverSet.first().isReadyToDeliver()) {
+                toDeliverSet.wait();
+            }
+
+            Iterator<MessageInfo> iterator = toDeliverSet.iterator();
+
+            while (iterator.hasNext()) {
+                MessageInfo messageInfo = iterator.next();
+                if (messageInfo.isReadyToDeliver()) {
+                    toDeliver.add(messageInfo.getMessage());
+                    iterator.remove();
+                } else {
+                    break;
+                }
+            }
+        }
+        return toDeliver;
+    }
+
+    /**
+     * remove all the pending messages
+     */
+    public void clear() {
+        synchronized (toDeliverSet) {
+            toDeliverSet.clear();
+            messageCache.clear();
+        }
+    }
+
+    /**
+     * Keeps the state of a message
+     */
+    private static class MessageInfo {
+
+        private MessageID messageID;
+        private Message message;
+        private volatile long sequenceNumber;
+        private volatile boolean readyToDeliver;
+
+        public MessageInfo(MessageID messageID, Message message, long sequenceNumber) {
+            if (messageID == null) {
+                throw new NullPointerException(""Message ID can't be null"");
+            }
+            this.messageID = messageID;
+            this.message = message.copy(true, true);
+            this.sequenceNumber = sequenceNumber;
+            this.readyToDeliver = false;
+            this.message.setSrc(messageID.getAddress());
+        }
+
+        private Message getMessage() {
+            return message;
+        }
+
+        private void updateAndmarkReadyToDeliver(long finalSequenceNumber) {
+            this.readyToDeliver = true;
+            this.sequenceNumber = finalSequenceNumber;
+        }
+
+        private boolean isReadyToDeliver() {
+            return readyToDeliver;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+
+            if (o == null) {
+                return false;
+            }
+
+            boolean isMessageID = o.getClass() == MessageID.class;
+
+            if (o.getClass() != getClass() && !isMessageID) {
+                return false;
+            }
+
+            if (isMessageID) {
+                return messageID.equals(o);
+            }
+
+            MessageInfo that = (MessageInfo) o;
+
+            return messageID.equals(that.messageID);
+        }
+
+        @Override
+        public int hashCode() {
+            return messageID.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return ""MessageInfo{"" +
+                    ""messageID="" + messageID +
+                    "", sequenceNumber="" + sequenceNumber +
+                    "", readyToDeliver="" + readyToDeliver +
+                    '}';
+        }
+
+        public boolean isUpdatePositionNeeded(long finalSequenceNumber) {
+            return sequenceNumber != finalSequenceNumber;
+        }
+    }
+
+    private static class MessageInfoComparator implements Comparator<MessageInfo> {
+
+        @Override
+        public int compare(MessageInfo messageInfo, MessageInfo messageInfo1) {
+            if (messageInfo == null) {
+                return messageInfo1 == null ? 0 : 1;
+            } else if (messageInfo1 == null) {
+                return -1;
+            }
+
+            int compareMessageID = messageInfo.messageID.compareTo(messageInfo1.messageID);
+
+            if (compareMessageID == 0) {
+                return 0;
+            }
+
+            if (messageInfo.sequenceNumber != messageInfo1.sequenceNumber) {
+                return Long.signum(messageInfo.sequenceNumber - messageInfo1.sequenceNumber);
+            }
+
+            return compareMessageID;
+        }
+    }
+
+    /**
+     * It is used for testing (see the messages in JMX)
+     * @return unmodifiable set of messages
+     */
+    public Set<MessageInfo> getMessageSet() {
+        synchronized (toDeliverSet) {
+            return Collections.unmodifiableSet(toDeliverSet);
+        }
+    }
+}",2012-03-23T12:18:00Z,165
"@@ -0,0 +1,137 @@
+package org.jgroups.protocols.pmcast.manager;
+
+import org.jgroups.Address;
+import org.jgroups.protocols.pmcast.MessageID;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Keeps track of all sended messages, until the final sequence number is known
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SenderManager {
+
+    public static final long NOT_READY = -1;
+
+    private final ConcurrentMap<MessageID, MessageInfo> sentMessages = new ConcurrentHashMap<MessageID, MessageInfo>();
+
+    /**
+     * Add a new message sent
+     * @param messageID             the message ID
+     * @param destination           the destination set
+     * @param initialSequenceNumber the initial sequence number
+     * @param deliverToMySelf       true if *this* member is in destination sent, false otherwise
+     */
+    public void addNewMessageToSent(MessageID messageID, Set<Address> destination, long initialSequenceNumber,
+                                    boolean deliverToMySelf) {
+        MessageInfo messageInfo = new MessageInfo(destination, initialSequenceNumber, deliverToMySelf);
+        if (deliverToMySelf) {
+            messageInfo.setProposeReceived(messageID.getAddress());
+        }
+        sentMessages.put(messageID, messageInfo);
+    }
+
+    /**
+     * Add a propose from a member in destination set
+     * @param messageID         the message ID
+     * @param from              the originator of the propose
+     * @param sequenceNumber    the proposed sequence number
+     * @return NOT_READY if the final sequence number is not know, or the final sequence number
+     */
+    public long addPropose(MessageID messageID, Address from, long sequenceNumber) {
+        MessageInfo messageInfo = sentMessages.get(messageID);
+        if (messageInfo != null && messageInfo.addPropose(from, sequenceNumber)) {
+            return messageInfo.getAndMarkFinalSent();
+        }
+        return NOT_READY;
+    }
+
+    /**
+     * Mark the message as sent
+     * @param messageID the message ID
+     * @return  return true if *this* member is in destination set
+     */
+    public boolean markSent(MessageID messageID) {
+        MessageInfo messageInfo =  sentMessages.remove(messageID);
+        return messageInfo != null && messageInfo.toSelfDeliver;
+    }
+
+    /**
+     * obtains the destination set of a message
+     * @param messageID the message ID
+     * @return the destination set
+     */
+    public Set<Address> getDestination(MessageID messageID) {
+        MessageInfo messageInfo = sentMessages.get(messageID);
+        Set<Address> destination;
+        if (messageInfo != null) {
+            destination = new HashSet<Address>(messageInfo.destination);
+        } else {
+            destination = Collections.emptySet();
+        }
+        return destination;
+    }
+
+    /**
+     * removes all pending messages
+     */
+    public void clear() {
+        sentMessages.clear();
+    }
+
+    /**
+     * The state of a message (destination, proposes missing, the highest sequence number proposed, etc...)
+     */
+    private static class MessageInfo {
+        private ArrayList<Address> destination;
+        private long highestSequenceNumberReceived;
+        private BitSet receivedPropose;
+        private boolean finalMessageSent = false;
+        private boolean toSelfDeliver = false;
+
+        private MessageInfo(Set<Address> addresses, long sequenceNumber, boolean selfDeliver) {
+            this.destination = new ArrayList<Address>(addresses);
+            this.highestSequenceNumberReceived = sequenceNumber;
+            createNewBitSet(addresses.size());
+            this.toSelfDeliver = selfDeliver;
+        }
+
+        private synchronized boolean addPropose(Address from, long sequenceNumber) {
+            setProposeReceived(from);
+            highestSequenceNumberReceived = Math.max(highestSequenceNumberReceived, sequenceNumber);
+            return checkAllProposesReceived();
+        }
+
+        private synchronized long getAndMarkFinalSent() {
+            if (checkAllProposesReceived() && !finalMessageSent) {
+                finalMessageSent = true;
+                return highestSequenceNumberReceived;
+            }
+            return NOT_READY;
+        }
+
+        private void createNewBitSet(int maxElements) {
+            receivedPropose = new BitSet(maxElements);
+            for (int i = 0; i < maxElements; ++i) {
+                receivedPropose.set(i);
+            }
+        }
+
+        private void setProposeReceived(Address address) {
+            int idx = destination.indexOf(address);
+            if (idx == -1) {
+                throw new IllegalStateException(""Address doesn't exists in destination list. Address is "" + address);
+            }
+            receivedPropose.set(idx, false);
+        }
+
+        private boolean checkAllProposesReceived() {
+            return receivedPropose.isEmpty();
+        }
+    }
+
+}",2012-03-23T12:18:00Z,166
"@@ -0,0 +1,43 @@
+package org.jgroups.protocols.pmcast.manager;
+
+/**
+ * Manages the messages sequence number (keeps it up-to-date)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SequenceNumberManager {
+
+    private long sequenceNumber = 0;
+
+    /**
+     * 
+     * @return the next sequence number
+     */
+    public synchronized long getAndIncrement() {
+        return sequenceNumber++;
+    }
+
+    /**
+     * updates the sequence number to the maximum between them
+     * @param otherSequenceNumber   the sequence number received
+     */
+    public synchronized void update(long otherSequenceNumber) {
+        sequenceNumber = Math.max(sequenceNumber, otherSequenceNumber + 1);
+    }
+
+    /**
+     * updates the sequence number and returns the next, that will be used a propose sequence number 
+     * @param otherSequenceNumber   the sequence number received
+     * @return                      the next sequence number or the received sequence number, if the received sequence
+     *                              number is higher the the actual sequence number
+     */
+    public synchronized long updateAndGet(long otherSequenceNumber) {
+        if (sequenceNumber >= otherSequenceNumber) {
+            return sequenceNumber++;
+        } else {
+            sequenceNumber = otherSequenceNumber + 1;
+            return otherSequenceNumber;
+        }
+    }
+}",2012-03-23T12:18:00Z,167
"@@ -0,0 +1,215 @@
+package org.jgroups.protocols.pmcast.stats;
+
+import java.util.EnumMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * This collects the stats and some profiling information
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class StatsCollector {
+
+    private static enum Counter {
+        PROPOSE_MESSAGE_RECEIVED,
+        LAST_PROPOSE_MESSAGE_RECEIVED,
+        FINAL_MESSAGE_RECEIVED,
+        DATA_MESSAGE_RECEIVED,
+        GROUP_MESSAGE_SENT,
+        GROUP_MESSAGE_DELIVERED,
+        UNICAST_MESSAGE_SENT
+    }
+
+    private static enum Duration {
+        PROPOSE_MESSAGE,
+        LAST_PROPOSE_MESSAGE,
+        FINAL_MESSAGE,
+        DATA_MESSAGE,
+        GROUP_MESSAGE_SENT
+    }
+
+    //from javadoc: Enum maps are represented internally as arrays. This representation is extremely compact and efficient. 
+    //this way is simple to add new stats and avoids create N field with atomic long or atomic integer. 
+    private EnumMap<Counter, AtomicInteger> counters;
+    private EnumMap<Duration, AtomicLong> durations;
+
+    public StatsCollector() {
+        counters = new EnumMap<Counter, AtomicInteger>(Counter.class);
+        durations = new EnumMap<Duration, AtomicLong>(Duration.class);
+
+        for (Counter counter : Counter.values()) {
+            counters.put(counter, new AtomicInteger(0));
+        }
+
+        for (Duration duration : Duration.values()) {
+            durations.put(duration, new AtomicLong(0));
+        }
+    }
+
+    private volatile boolean statsEnabled;
+
+    private boolean shouldCollectStats(long... values) {
+        if (!statsEnabled) {
+            return false;
+        }
+        for (long value : values) {
+            if (value < 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private double convertNanosToMillis(long nanos) {
+        return nanos / 1000000.0;
+    }
+
+    public void setStatsEnabled(boolean statsEnabled) {
+        this.statsEnabled = statsEnabled;
+    }
+
+    public void clearStats() {
+        for (AtomicInteger counter : counters.values()) {
+            counter.set(0);
+        }
+
+        for (AtomicLong duration : durations.values()) {
+            duration.set(0);
+        }
+    }
+
+    public long now() {
+        return statsEnabled ? System.nanoTime() : -1;
+    }
+
+    public void addProposeSequenceNumberDuration(long durationValue, boolean isLastProposeMessage) {
+        if (!shouldCollectStats(durationValue)) {
+            return;
+        }
+        Counter counter = isLastProposeMessage ? Counter.LAST_PROPOSE_MESSAGE_RECEIVED :
+                Counter.PROPOSE_MESSAGE_RECEIVED;
+        Duration duration = isLastProposeMessage ? Duration.LAST_PROPOSE_MESSAGE :
+                Duration.PROPOSE_MESSAGE;
+
+        counters.get(counter).incrementAndGet();
+        durations.get(duration).addAndGet(durationValue);
+    }
+
+    public void addFinalSequenceNumberDuration(long duration) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(Counter.FINAL_MESSAGE_RECEIVED).incrementAndGet();
+        durations.get(Duration.FINAL_MESSAGE).addAndGet(duration);
+    }
+
+    public void addDataMessageDuration(long duration) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(Counter.DATA_MESSAGE_RECEIVED).incrementAndGet();
+        durations.get(Duration.DATA_MESSAGE).addAndGet(duration);
+    }
+
+    public void addGroupMulticastSentDuration(long duration, int numberOfUnicasts) {
+        if (!shouldCollectStats(duration)) {
+            return;
+        }
+
+        counters.get(StatsCollector.Counter.UNICAST_MESSAGE_SENT).addAndGet(numberOfUnicasts);
+        counters.get(Counter.GROUP_MESSAGE_SENT).incrementAndGet();
+        durations.get(Duration.GROUP_MESSAGE_SENT).addAndGet(duration);
+    }
+
+    public void incrementMessageDeliver() {
+        if (!shouldCollectStats()) {
+            return ;
+        }
+        counters.get(Counter.GROUP_MESSAGE_DELIVERED).incrementAndGet();
+    }
+
+    public double getAvgDataMessageReceivedDuration() {
+        int count = counters.get(Counter.DATA_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.DATA_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgGroupMulticastSentDuration() {
+        int count = counters.get(Counter.GROUP_MESSAGE_SENT).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.GROUP_MESSAGE_SENT).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgProposeMesageReceivedDuration() {
+        int count = counters.get(Counter.PROPOSE_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.PROPOSE_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgLastProposeMessageReceivedDuration() {
+        int count = counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.LAST_PROPOSE_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public double getAvgFinalMessageReceivedDuration() {
+        int count = counters.get(Counter.FINAL_MESSAGE_RECEIVED).get();
+        if (count > 0) {
+            long dur = durations.get(Duration.FINAL_MESSAGE).get();
+            return convertNanosToMillis(dur) / count;
+        }
+        return 0D;
+    }
+
+    public int getNumberOfGroupMulticastMessagesSent() {
+        return counters.get(Counter.GROUP_MESSAGE_SENT).get();
+    }
+
+    public int getGroupMulticastDelivered() {
+        return counters.get(Counter.GROUP_MESSAGE_DELIVERED).get();
+    }
+
+    public int getNumberOfProposeMessagesReceived() {
+        return counters.get(Counter.PROPOSE_MESSAGE_RECEIVED).get() +
+                counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfProposeMessagesSent() {
+        //we send a propose message for each data message received
+        return counters.get(Counter.DATA_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfFinalGroupMessagesSent() {
+        //we send 1 final group message when the last propose is received
+        return counters.get(Counter.LAST_PROPOSE_MESSAGE_RECEIVED).get();
+    }
+
+    public int getNumberOfFinalMessagesDelivered() {
+        return counters.get(Counter.FINAL_MESSAGE_RECEIVED).get();
+    }
+
+    public double getAvgNumberOfUnicastSentPerGroupMulticast() {
+        int multicast = counters.get(Counter.GROUP_MESSAGE_SENT).get();
+        if (multicast > 0) {
+            int unicast = counters.get(Counter.UNICAST_MESSAGE_SENT).get();
+            return unicast * 1.0 / multicast;
+        }
+        return 0D;
+    }
+}",2012-03-23T12:18:00Z,168
"@@ -0,0 +1,70 @@
+package org.jgroups.protocols.pmcast.threading;
+
+import org.jgroups.Message;
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.protocols.pmcast.DeliverProtocol;
+import org.jgroups.protocols.pmcast.manager.DeliverManager;
+
+import java.util.List;
+
+/**
+ * The deliver threads. Is the only thread that delivers the Total Order Multicast message in order
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class DeliverThread extends Thread {
+    private DeliverManager deliverManager;
+    private boolean running = false;
+    private DeliverProtocol groupMulticastProtocol;
+
+    private final Log log = LogFactory.getLog(this.getClass());
+
+    public DeliverThread(DeliverProtocol protocol) {
+        super(""Group-Multicast-Deliver-Thread"");
+        if (protocol == null) {
+            throw new NullPointerException(""Group Multicast Protocol can't be null"");
+        }
+        this.groupMulticastProtocol = protocol;
+    }
+
+    public void start(DeliverManager deliverManager) {
+        this.deliverManager = deliverManager;
+        start();
+    }
+
+    @Override
+    public void start() {
+        if (deliverManager == null) {
+            throw new NullPointerException(""Deliver Manager can't be null"");
+        }
+        running = true;
+        super.start();
+    }
+
+    @Override
+    public void run() {
+        while (running) {
+            try {
+                List<Message> messages = deliverManager.getNextMessagesToDeliver();
+
+                for (Message msg : messages) {
+                    try {
+                        groupMulticastProtocol.deliver(msg);
+                    } catch(Throwable t) {
+                        log.warn(""Exception caught while delivering message "" + msg + "":"" + t.getMessage());
+                    }
+                }
+            } catch (InterruptedException e) {
+                //interrupted
+            }
+        }
+    }
+
+    @Override
+    public void interrupt() {
+        running = false;
+        super.interrupt();
+    }
+}",2012-03-23T12:18:00Z,169
"@@ -0,0 +1,103 @@
+package org.jgroups.protocols.pmcast.threading;
+
+import org.jgroups.Address;
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.logging.Log;
+import org.jgroups.logging.LogFactory;
+import org.jgroups.stack.Protocol;
+
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * This thread is the responsible to send the group messages, i.e, create N messages and send N unicasts messages
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class SenderThread extends Thread {
+
+    private boolean running = false;
+    private Protocol groupMulticastProtocol;
+    private Address localAddress;
+
+    private final BlockingQueue<MessageToSend> sendingQueue;
+    private final Log log = LogFactory.getLog(this.getClass());
+
+    public SenderThread(Protocol protocol) {
+        super(""Group-Multicast-Sender-Thread"");
+        if (protocol == null) {
+            throw new NullPointerException(""Group Multicast Protocol can't be null"");
+        }
+        this.groupMulticastProtocol = protocol;
+        this.sendingQueue = new LinkedBlockingQueue<MessageToSend>();
+    }
+
+    public void setLocalAddress(Address localAddress) {
+        this.localAddress = localAddress;
+    }
+
+    public void addMessage(Message message, Set<Address> destination) throws InterruptedException {
+        sendingQueue.put(new MessageToSend(message, destination));
+    }
+
+    public void clear() {
+        sendingQueue.clear();
+    }
+
+    @Deprecated
+    public void addUnicastMessage(Message message) throws InterruptedException {
+        sendingQueue.put(new MessageToSend(message, null));
+    }
+
+    @Override
+    public void start() {
+        running = true;
+        super.start();
+    }
+
+    @Override
+    public void run() {
+        while (running) {
+            try {
+                MessageToSend messageToSend = sendingQueue.take();
+
+                if (messageToSend.destination == null) {
+                    groupMulticastProtocol.getDownProtocol().down(new Event(Event.MSG, messageToSend.message));
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug(""Send group message "" + messageToSend.message + "" to "" + messageToSend.destination);
+                    }
+                    for (Address address : messageToSend.destination) {
+                        if (address.equals(localAddress)) {
+                            continue;
+                        }
+                        Message cpy = messageToSend.message.copy();
+                        cpy.setDest(address);
+                        groupMulticastProtocol.getDownProtocol().down(new Event(Event.MSG, cpy));
+                    }
+                }
+            } catch (InterruptedException e) {
+                //interrupted
+            }
+        }
+    }
+
+    @Override
+    public void interrupt() {
+        running = false;
+        super.interrupt();
+    }
+
+    private class MessageToSend {
+        private Message message;
+        private Set<Address> destination;
+
+        private MessageToSend(Message message, Set<Address> destination) {
+            this.message = message;
+            this.destination = destination;
+        }
+    }
+}",2012-03-23T12:18:00Z,170
"@@ -0,0 +1,290 @@
+package org.jgroups.tests;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This check the order of the messages, assuming that the message IDs are printed in a file
+ * 
+ * Note: this is used for debugging
+ * Note2: this needs to be clean :)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class CheckGroupMulticastOrder {
+
+    public static void main(String[] args) throws InterruptedException {
+
+        if (args.length == 0) {
+            System.err.println(""usage: [-threads value] <files...>"");
+            System.exit(1);
+        }
+
+        int numberOfThreads = 2;
+        int startIdx = 0;
+
+        if (args[0].equals(""-threads"")) {
+            startIdx = 2;
+            try {
+                numberOfThreads = Integer.parseInt(args[1]);
+            } catch (Exception e) {
+                System.err.println(""Error parsing number of threads: "" + e.getLocalizedMessage());
+                numberOfThreads = 2;
+            } finally {
+                if (numberOfThreads < 1) {
+                    numberOfThreads = 2;
+                }
+            }
+        }
+
+        System.out.println(""--------------------------------------------------------------------"");
+        System.out.println(""------------------CHECK GROUP MULTICAST ORDER ----------------------"");
+        System.out.println(""--------------------------------------------------------------------"");
+
+        System.out.println(""analyze "" + printArgs(args) + "" using "" + numberOfThreads + "" threads"");
+        
+        ComparingFiles[] threads = new ComparingFiles[numberOfThreads];
+        
+        List<Pair> allCombinations = new LinkedList<Pair>();
+        
+        for (int x = startIdx; x < args.length; ++x) {
+            for (int y = x + 1; y < args.length; ++y) {
+                if (x == y) {
+                    continue;
+                }
+                allCombinations.add(new Pair(x, y));
+            }
+        }
+        
+        System.out.println(""Collection for the threads is "" + allCombinations);
+        
+        final Iterator<Pair> iterator = allCombinations.iterator();
+        for (int i = 0; i < threads.length; ++i) {
+            threads[i] = new ComparingFiles(iterator,args,""Comparator-"" + i);
+            threads[i].start();
+        }
+
+        for (ComparingFiles comparingFiles : threads) {
+            comparingFiles.join();
+        }
+
+        System.out.println(""=========== FINISHED! =============="");
+    }
+
+    private static String printArgs(String[] args) {
+        StringBuilder sb = new StringBuilder(args[0]);
+
+        for (int i = 1;  i < args.length; ++i) {
+            sb.append("","").append(args[i]);
+        }
+        return sb.toString();
+    }
+
+    public static void compareFiles(String filePath1, String filePath2, List<String> messageDeliverOrder) {
+        System.out.println(""Comparing "" + filePath1 + "" and "" + filePath2 + "" by thread "" + Thread.currentThread().getName());
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath1));
+
+            String message;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                messageDeliverOrder.add(message);
+            }
+
+            bufferedReader.close();
+            bufferedReader = new BufferedReader(new FileReader(filePath2));
+            int msgExpectedIdx = 0;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                    messageDeliverOrder.add(message);
+                    ++msgExpectedIdx;
+                    continue;
+                }
+                String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+                if (otherMessage.equals(message)) {
+                    msgExpectedIdx++;
+                    continue;
+                }
+
+                int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+                if (realMsgIdx == -1) {
+                    continue;
+                } else if (realMsgIdx < msgExpectedIdx) {
+                    System.err.println(""["" + Thread.currentThread().getName() + ""] Message deliver out of order: "" + message);
+                }
+                msgExpectedIdx = realMsgIdx + 1;
+            }
+
+            bufferedReader.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } catch (IOException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } finally {
+            System.out.println(""Finished comparing this files"");
+        }
+    }
+
+    /*public static void processFile(String filePath, List<String> messageDeliverOrder) {
+        System.out.println(""Processing "" + filePath + "" by thread "" + Thread.currentThread().getName());
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
+
+            int msgExpectedIdx = 0;
+            String message;
+
+            while ((message = bufferedReader.readLine()) != null) {
+                if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                    messageDeliverOrder.add(message);
+                    ++msgExpectedIdx;
+                    continue;
+                }
+                String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+                if (otherMessage.equals(message)) {
+                    msgExpectedIdx++;
+                    continue;
+                }
+
+                int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+                if (realMsgIdx == -1) {
+                    messageDeliverOrder.add(msgExpectedIdx, message);
+                    msgExpectedIdx++;
+                    continue;
+                } else if (realMsgIdx < msgExpectedIdx) {
+                    System.err.println(""["" + Thread.currentThread().getName() + ""] Message deliver out of order: "" +
+                            message + "". Real Idx:"" + realMsgIdx + "", Expected Idx:"" + msgExpectedIdx);
+                }
+                msgExpectedIdx = realMsgIdx + 1;
+            }
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } catch (IOException e) {
+            e.printStackTrace();  // TODO: Customise this generated block
+        } finally {
+            System.out.println(Thread.currentThread().getName() + "" finished processing the file. Getting another one"");
+        }
+    }
+
+    public static void joinLists(List<String> toJoin, ArrayList<String> messageDeliverOrder) {
+        int joinSize = toJoin.size();
+        messageDeliverOrder.ensureCapacity(joinSize);
+        System.out.println(""Joining lists. Sizes: "" + joinSize + "" and "" + messageDeliverOrder.size());
+
+        int msgExpectedIdx = 0;
+        for (String message : toJoin) {
+            if (msgExpectedIdx >= messageDeliverOrder.size()) {
+                messageDeliverOrder.add(message);
+                ++msgExpectedIdx;
+                continue;
+            }
+            String otherMessage = messageDeliverOrder.get(msgExpectedIdx);
+            if (otherMessage.equals(message)) {
+                msgExpectedIdx++;
+                continue;
+            }
+
+            int realMsgIdx = messageDeliverOrder.indexOf(message);
+
+            if (realMsgIdx == -1) {
+                messageDeliverOrder.add(msgExpectedIdx, message);
+                msgExpectedIdx++;
+                continue;
+            } else if (realMsgIdx < msgExpectedIdx) {
+                System.err.println(""[Joining] Message deliver out of order: "" + message + "". Real Idx:"" + realMsgIdx +
+                        "", Expected Idx:"" + msgExpectedIdx);
+                continue;
+            }
+            msgExpectedIdx = realMsgIdx + 1;
+        }
+
+    }
+
+    private static class ProcessingFile extends Thread {
+        private AtomicInteger argumentIdx;
+        private ArrayList<String> messageDeliverOrder = new ArrayList<String>();
+        private String[] args;
+
+        private ProcessingFile(final AtomicInteger argumentIdx, final String[] args, String threadName) {
+            super(threadName);
+            this.argumentIdx = argumentIdx;
+            this.args = args;
+        }
+
+        @Override
+        public void run() {
+            while (true) {
+                int idx = argumentIdx.getAndIncrement();
+                if (idx >= args.length) {
+                    break;
+                }
+                processFile(args[idx], messageDeliverOrder);
+            }
+            System.out.println(getName() + "" finished!"");
+        }
+    }*/
+    
+    private static class Pair {       
+        private final int x, y;
+
+        private Pair(int x, int y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        public int getX() {
+            return x;
+        }
+
+        public int getY() {
+            return y;
+        }
+
+        @Override
+        public String toString() {
+            return ""Pair{"" +
+                    ""y="" + y +
+                    "", x="" + x +
+                    '}';
+        }
+    }
+    
+    private static class ComparingFiles extends Thread {
+        private final Iterator<Pair> filesToCompare;
+        private ArrayList<String> messageDeliverOrder = new ArrayList<String>();
+        private String[] args;
+
+        private ComparingFiles(final Iterator<Pair> filesToCompare, final String[] args, String threadName) {
+            super(threadName);
+            this.filesToCompare = filesToCompare;
+            this.args = args;
+        }
+
+        @Override
+        public void run() {
+            while (true) {
+                Pair p;
+                synchronized (filesToCompare) {
+                    if (!filesToCompare.hasNext()) {
+                        break;
+                    }
+                    p = filesToCompare.next();
+                }
+                compareFiles(args[p.getX()], args[p.getY()], messageDeliverOrder);
+                int size = messageDeliverOrder.size();
+                messageDeliverOrder.clear();
+                messageDeliverOrder.ensureCapacity(size);
+            }            
+            
+            System.out.println(getName() + "" finished!"");
+        }
+    }
+}",2012-03-23T12:18:00Z,171
"@@ -0,0 +1,569 @@
+package org.jgroups.tests;
+
+import org.jgroups.*;
+import org.jgroups.protocols.pmcast.GroupAddress;
+import org.jgroups.util.Util;
+
+import javax.management.*;
+import java.io.*;
+import java.lang.management.ManagementFactory;
+import java.util.*;
+
+/**
+ * Runs the Total Order Multicast protocol and saves the messages delivered
+ * 
+ * Note: this is used for debugging
+ * Note2: this needs to be clean :)
+ *
+ * @author Pedro Ruivo
+ * @since 3.1
+ */
+public class TestGroupMulticastOrder {
+    private static final String PROPS = ""group-multicast.xml"";
+    private static final String CLUSTER = ""test-group-multicast-cluster"";
+    private static final String OUTPUT_FILE_SUFFIX = ""-messages.txt"";
+    private static final String JMX_DOMAIN = ""org.jgroups"";
+
+    private JChannel jChannel;
+    private MyReceiver receiver;
+    private int numberOfNodes;
+    private int numberOfMessages;
+    private final List<Address> members = new LinkedList<Address>();
+
+    private long start;
+    private long stop;
+    private long sentBytes = 0;
+    private long sentMessages = 0;
+    private String config;
+
+    public static void main(String[] args) throws InterruptedException {
+        System.out.println(""=========================="");
+        System.out.println(""Test Group Multicast Order"");
+        System.out.println(""=========================="");
+
+
+        ArgumentsParser argumentsParser = new ArgumentsParser(args);
+        if (argumentsParser.isHelp()) {
+            helpAndExit();
+        } else if(argumentsParser.isTestOrder()) {
+            /*String[] paths = argumentsParser.getFilesPath();
+            int numberOfFiles = paths.length;
+
+            ProcessFile[] threads = new ProcessFile[numberOfFiles];
+
+            for (int i = 0; i < threads.length; ++i) {
+                threads[i] = new ProcessFile(paths[i]);
+                threads[i].start();
+            }
+
+            Map<String, MessageInfo> allMessages = new HashMap<String, MessageInfo>();
+            for (ProcessFile processFile : threads) {
+                processFile.join();
+                for (MessageInfo messageInfo : processFile.list) {
+                    String message = messageInfo.message;
+                    if (!allMessages.containsKey(message)) {
+                        allMessages.put(message, messageInfo);
+                    } else {
+                        allMessages.get(message).join(messageInfo);
+                    }
+                }
+            }
+
+            for (MessageInfo messageInfo : allMessages.values()) {
+                messageInfo.check();
+            }
+            System.out.println(""============= FINISHED ============="");
+            System.exit(0);*/
+        }
+
+        TestGroupMulticastOrder testGroupMulticastOrder = new TestGroupMulticastOrder(
+                argumentsParser.getNumberOfNodes(),
+                argumentsParser.getNumberOfMessages(),
+                argumentsParser.getConfig());
+
+        try {
+            testGroupMulticastOrder.startTest();
+        } catch (Exception e) {
+            System.err.println(""Error while executing the test: "" + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        } finally {
+            testGroupMulticastOrder.closeJChannel();
+            System.out.println(""============= FINISHED ============="");
+        }
+        System.exit(0);
+    }
+
+    private static void helpAndExit() {
+        System.out.println(""usage: "" + TestGroupMulticastOrder.class.getCanonicalName() + "" <option>"");
+        System.out.println(""Options:"");
+        System.out.println(""  -h                    \tshow this message"");
+        System.out.println(""  -nr-nodes <value>     \tnumber of nodes"");
+        System.out.println(""  -nr-messages <values> \tnumber of messages to send by each node"");
+        System.out.println(""  -config <file>        \tthe JGroup's configuration file"");
+        System.exit(1);
+    }
+
+    // ====================== arguments parser ======================
+
+    private static class ArgumentsParser {
+        private static final int NR_NODES = 4;
+        private static final int NR_MESSAGES = 1000;
+
+        private String[] args;
+
+        private int numberOfNodes = -1;
+        private int numberOfMessages = -1;
+        private boolean help = false;
+        private boolean testOrder = false;
+        private String[] filesPath = null;
+        private String config = PROPS;
+
+        public ArgumentsParser(String[] args) {
+            this.args = args;
+            parse();
+            checkConfig();
+        }
+
+        private void parse() {
+            try {
+                for (int i = 0; i < args.length; ++i) {
+                    if (""-h"".equals(args[i])) {
+                        help = true;
+                    } else if (""-nr-nodes"".equals(args[i])) {
+                        numberOfNodes = Integer.parseInt(args[++i]);
+
+                        if (numberOfNodes < NR_NODES) {
+                            System.err.println(""Number of nodes must be greater or equal to "" + NR_NODES);
+                            System.exit(1);
+                        }
+                    } else if (""-nr-messages"".equals(args[i])) {
+                        numberOfMessages = Integer.parseInt(args[++i]);
+
+                        if (numberOfMessages <= 0) {
+                            System.err.println(""Number of messages must be greater than 0"");
+                            System.exit(1);
+                        }
+                    } else if (""-config"".equals(args[i])) {
+                        config = args[++i];
+                    } else {
+                        System.err.println(""Unknown argument: "" +args[i]);
+                        helpAndExit();
+                    }
+                }
+            } catch (Throwable t) {
+                System.err.println(""Error processing arguments: "" + t.getMessage());
+                t.printStackTrace();
+                System.exit(1);
+            }
+        }
+
+        private void checkConfig() {
+            if (numberOfNodes == -1) {
+                numberOfNodes = NR_NODES;
+            }
+            if (numberOfMessages == -1) {
+                numberOfMessages = NR_MESSAGES;
+            }
+        }
+
+        public boolean isHelp() {
+            return help;
+        }
+
+        public boolean isTestOrder() {
+            return testOrder;
+        }
+
+        public int getNumberOfNodes() {
+            return numberOfNodes;
+        }
+
+        public int getNumberOfMessages() {
+            return numberOfMessages;
+        }
+
+        public String[] getFilesPath() {
+            return filesPath;
+        }
+
+        public String getConfig() {
+            return config;
+        }
+    }
+
+    // ====================== receiver ======================
+
+    private static class MyReceiver extends ReceiverAdapter {
+        private int expectedMembers;
+        private int members = 0;
+        private final List<String> messageList;
+        private final TestGroupMulticastOrder testGroupMulticastOrder;
+
+        private long start = 0;
+        private long stop = 0;
+        private long receivedBytes = 0;
+        private int receivedMsgs = 0;
+
+        public MyReceiver(int expectedMembers, TestGroupMulticastOrder testGroupMulticastOrder) {
+            this.expectedMembers = expectedMembers;
+            this.testGroupMulticastOrder = testGroupMulticastOrder;
+            this.messageList = new LinkedList<String>();
+        }
+
+        @Override
+        public void receive(Message msg) {
+            DataMessage dataMessage = (DataMessage) msg.getObject();
+            switch (dataMessage.type) {
+                case DataMessage.FINISH:
+                    testGroupMulticastOrder.memberFinished(msg.getSrc());
+                    break;
+                case DataMessage.DATA:
+                    if (start == 0) {
+                        start = System.nanoTime();
+                    }
+                    synchronized (messageList) {
+                        messageList.add(dataMessage.data);
+                    }
+                    receivedBytes += (dataMessage.data.getBytes().length + 1);
+                    receivedMsgs++;
+                    stop = System.nanoTime();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        @Override
+        public void viewAccepted(View view) {
+            System.out.println(""New View: "" + view);
+            super.viewAccepted(view);
+            synchronized (this) {
+                members = view.getMembers().size();
+                this.notify();
+            }
+        }
+
+        public synchronized void waitUntilClusterIsFormed() throws InterruptedException {
+            while (members < expectedMembers) {
+                System.out.println(""Number of members is not the expected: "" + members + "" of "" + expectedMembers);
+                this.wait();
+            }
+        }
+
+        public void await(int expectedMessages) throws InterruptedException {
+            int actualSize;
+            while (true) {
+                synchronized (messageList) {
+                    actualSize = messageList.size();
+                }
+                if (actualSize < expectedMessages) {
+                    System.out.println(""waiting messages... "" + actualSize + "" of "" + expectedMessages);
+                    Thread.sleep(10000);
+                } else {
+                    break;
+                }
+            }
+        }
+
+        public List<String> getMessageList() {
+            return messageList;
+        }
+
+        public void printReceiverInfo() {
+            System.out.println(""+++ Receiver Information +++"");
+            double duration = stop - start;
+            duration /= 1000000.0; //nano to millis
+            System.out.println(""+ Duration (msec)   = "" + duration);
+            System.out.println(""+ Received Bytes    = "" + receivedBytes);
+            System.out.println(""+ Received Messages = "" + receivedMsgs);
+            duration /= 1000.0; //millis to sec
+            System.out.println(""---------------------"");
+            System.out.println(""+ Receiving Throughput (bytes/sec)  = "" + (receivedBytes / duration));
+            System.out.println(""+ Receiving Messages (messages/sec) = "" + (receivedMsgs / duration));
+            System.out.println(""-------------------------------------"");
+        }
+
+    }
+
+    // ====================== messages info (deliver before and after) ================
+    /*private static class MessageInfo {
+        private String message;
+        private Set<String> deliveredBefore = new HashSet<String>();
+        private Set<String> deliveredAfter = new HashSet<String>();
+
+        public void join(MessageInfo messageInfo) {
+            this.deliveredAfter.addAll(messageInfo.deliveredAfter);
+            this.deliveredBefore.addAll(messageInfo.deliveredBefore);
+        }
+
+        public void check() {
+            Set<String> intersect = new HashSet<String>(deliveredBefore);
+            intersect.retainAll(deliveredAfter);
+            if (!intersect.isEmpty()) {
+                System.err.println(""ERROR: WRONG ORDER! messages "" + intersect + "" was delivered before and after this"" +
+                        "" message "" + message);
+            }
+        }
+    }
+    
+    private static class MessageInfo2 extends MessageInfo {
+        private String message;
+        private Set<MessageInfo2> deliveredBefore = new HashSet<MessageInfo2>();
+        
+        @Override
+        public void join(MessageInfo messageInfo) {
+            deliveredBefore.addAll(((MessageInfo2)messageInfo).deliveredBefore);
+        }
+        
+        @Override
+        public void check() {
+            for (MessageInfo2 messageInfo2 : deliveredBefore) {
+                if (messageInfo2.deliveredBefore.contains(this)) {
+                    System.err.println(""ERROR: WRONG ORDER! This message "" + message + "" was delivered before and after the"" +
+                        "" message "" + messageInfo2.message);
+                }
+            }
+        }
+    }*/
+
+    //======================= thread processing each input file =====================
+    /*private static class ProcessFile extends Thread {
+        private String filepath;
+        public List<MessageInfo> list = new LinkedList<MessageInfo>();
+
+        private ProcessFile(String filepath) {
+            super();
+            this.filepath = filepath;
+        }
+
+        @Override
+        public void run() {
+            runV2();
+        }
+        
+        public void runV1() {
+            try {
+                Set<String> previously = new HashSet<String>();
+                BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath));
+                String message;
+
+                while ((message = bufferedReader.readLine()) != null) {
+                    MessageInfo messageInfo = new MessageInfo();
+                    messageInfo.message = message;
+                    messageInfo.deliveredBefore.addAll(previously);
+
+                    for (MessageInfo aux : list) {
+                        aux.deliveredAfter.add(message);
+                    }
+                    list.add(messageInfo);
+                    previously.add(message);
+                }
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            } catch (IOException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            }
+        }
+        
+        public void runV2() {
+            try {
+                Set<MessageInfo2> previously = new HashSet<MessageInfo2>();
+                BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath));
+                String message;
+
+                while ((message = bufferedReader.readLine()) != null) {
+                    MessageInfo2 messageInfo = new MessageInfo2();
+                    messageInfo.message = message;
+                    messageInfo.deliveredBefore.addAll(previously);                    
+                    list.add(messageInfo);
+                    previously.add(messageInfo);
+                }
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            } catch (IOException e) {
+                e.printStackTrace();  // TODO: Customise this generated block
+            }
+        }
+    }*/
+
+    //======================= data message =======================
+    private static class DataMessage implements Serializable {
+        public transient static final byte FINISH = 1; //1 << 0
+        public transient static final byte DATA = 1 << 1;
+
+        private byte type;
+        private String data;
+    }
+
+    // ====================== other methods ======================
+
+    public TestGroupMulticastOrder(int numberOfNodes, int numberOfMessages, String config) {
+        this.numberOfNodes = numberOfNodes;
+        this.numberOfMessages = numberOfMessages;
+        this.config = config;
+    }
+
+    private void createJChannel() throws Exception {
+        System.out.println(""Creating Channel"");
+        receiver = new MyReceiver(numberOfNodes, this);
+        jChannel = new JChannel(config);
+
+        jChannel.setReceiver(receiver);
+        jChannel.connect(CLUSTER);
+
+        receiver.waitUntilClusterIsFormed();
+        Util.registerChannel(jChannel, JMX_DOMAIN);
+
+        members.addAll(jChannel.getView().getMembers());
+    }
+
+    private GroupAddress getDestinations(List<Address> members) {
+        int rand = members.indexOf(jChannel.getAddress());
+
+        GroupAddress address = new GroupAddress();
+
+        address.addAddress(members.get(rand++ % members.size()));
+        address.addAddress(members.get(rand++ % members.size()));
+        address.addAddress(members.get(rand % members.size()));
+
+        return address;
+    }
+
+    private void sendMessages() throws Exception {
+        System.out.println(""Start sending messages..."");
+
+        String address = jChannel.getAddressAsString();
+        List<Address> members = jChannel.getView().getMembers();
+        start = System.nanoTime();
+        for (int i = 0; i < numberOfMessages; ++i) {
+            GroupAddress dst = getDestinations(members);
+            Message message = new Message();
+            message.setDest(dst);
+
+            DataMessage dataMessage = new DataMessage();
+            dataMessage.type = DataMessage.DATA;
+            dataMessage.data = address + "":"" + i;
+
+            message.setObject(dataMessage);
+            jChannel.send(message);
+
+            sentBytes += (dataMessage.data.getBytes().length + 1);
+            sentMessages++;
+        }
+        stop = System.nanoTime();
+
+        System.out.println(""Finish sending messages..."");
+    }
+
+    private void awaitUntilAllMessagesAreReceived() throws InterruptedException {
+        int expectedMessages = 3 * numberOfMessages;
+
+        receiver.await(expectedMessages);
+    }
+
+    private void awaitUntilAllFinishes() throws Exception {
+        DataMessage dataMessage = new DataMessage();
+        dataMessage.type = DataMessage.FINISH;
+        dataMessage.data = null;
+
+        jChannel.send(null, dataMessage);
+
+        synchronized (members) {
+            if (!members.isEmpty()) {
+                members.wait();
+            }
+        }
+    }
+
+    public void printSenderInfo() {
+        System.out.println(""+++ Sender Information +++"");
+        double duration = stop - start;
+        duration /= 1000000.0; //nano to millis
+        System.out.println(""+ Duration (msec) = "" + duration);
+        System.out.println(""+ Sent Bytes      = "" + sentBytes);
+        System.out.println(""+ Sent Messages   = "" + sentMessages);
+        duration /= 1000.0; //millis to sec
+        System.out.println(""-------------------"");
+        System.out.println(""+ Sent Throughput (bytes/sec)  = "" + (sentBytes / duration));
+        System.out.println(""+ Sent Messages (messages/sec) = "" + (sentMessages / duration));
+        System.out.println(""--------------------------------"");
+    }
+
+    public void memberFinished(Address addr) {
+        synchronized (members) {
+            members.remove(addr);
+            if (members.isEmpty()) {
+                members.notify();
+            }
+        }
+    }
+
+    public void closeJChannel() {
+        System.out.println(""Close channel"");
+        jChannel.close();
+    }
+
+    public void startTest() throws Exception {
+        System.out.println(""Start testing..."");
+        createJChannel();
+        sendMessages();
+        awaitUntilAllMessagesAreReceived();
+
+        String filePath = jChannel.getAddressAsString() + OUTPUT_FILE_SUFFIX;
+        System.out.println(""Writing messages in "" + filePath);
+
+        FileWriter fileWriter = new FileWriter(filePath);
+        for (String s : receiver.getMessageList()) {
+            fileWriter.write(s);
+            fileWriter.write(""\n"");
+        }
+        fileWriter.flush();
+        fileWriter.close();
+        System.out.println(""All done!"");
+
+        awaitUntilAllFinishes();
+
+        printSenderInfo();
+        receiver.printReceiverInfo();
+        printJMXStats();
+    }
+
+    private void printJMXStats() {
+        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
+        ObjectName groupMulticast = getGroupMulticastObjectName(mBeanServer);
+
+        if (groupMulticast == null) {
+            System.err.println(""Unable to find the GROUP_MULTICAST protocol"");
+            return ;
+        }
+
+        try {
+            System.out.println(""======== JMX STATS ========="");
+            for (MBeanAttributeInfo mBeanAttributeInfo : mBeanServer.getMBeanInfo(groupMulticast).getAttributes()) {
+                String attribute = mBeanAttributeInfo.getName();
+                String type = mBeanAttributeInfo.getType();
+
+                if (!type.equals(""double"") && !type.equals(""int"")) {
+                    continue;
+                }
+
+                System.out.println(attribute + ""="" + mBeanServer.getAttribute(groupMulticast, attribute));
+            }
+            System.out.println(""======== JMX STATS ========="");
+        } catch (Exception e) {
+            System.err.println(""Error collecting stats"" + e.getLocalizedMessage());
+        }
+    }
+
+    private ObjectName getGroupMulticastObjectName(MBeanServer mBeanServer) {
+        for(ObjectName name : mBeanServer.queryNames(null, null)) {
+            if(name.getDomain().equals(JMX_DOMAIN)) {
+                if (""GROUP_MULTICAST"".equals(name.getKeyProperty(""protocol""))) {
+                    return name;
+                }
+            }
+        }
+        return null;
+    }
+}",2012-03-23T12:18:00Z,172
"@@ -705,12 +705,13 @@ protected boolean _startFlush(final View new_view, int maxAttempts, long randomF
             if(validView && flushProtocolInStack) {
                 int attemptCount = 0;
                 while (attemptCount < maxAttempts) {
+                    if (attemptCount > 0)
+                        Util.sleepRandom(randomFloor, randomCeiling);
                     try {
                         up_prot.up(new Event(Event.SUSPEND, new ArrayList<Address>(new_view.getMembers())));
                         successfulFlush = true;
                         break;
                     } catch (Exception e) {
-                        Util.sleepRandom(randomFloor, randomCeiling);
                         attemptCount++;
                     }
                 }
@@ -1396,4 +1397,4 @@ private void process(List<Request> requests) {
     }
 
 
-}
\ No newline at end of file
+}",2012-02-19T15:43:23Z,74
"@@ -2,7 +2,6 @@
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
-import java.io.Externalizable;
 import java.io.IOException;
 import java.io.NotSerializableException;
 import java.io.Serializable;
@@ -26,7 +25,6 @@
 
 import org.jgroups.JChannel;
 import org.jgroups.protocols.Executing;
-import org.jgroups.protocols.Locking;
 import org.jgroups.util.FutureListener;
 import org.jgroups.util.NotifyingFuture;
 import org.jgroups.util.Streamable;
@@ -42,9 +40,9 @@
  * can then be used as a workflow to submit other tasks sequentially or also to
  * query the future for the value at that time. 
  * <p>
- * Every callable or runnable submitted must be either {@link Serializable}, 
- * {@link Externalizable}, or {@link Streamable}.  Also the value returned from
- * a callable must {@link Serializable}, {@link Externalizable}, or 
+ * Every callable or runnable submitted must be either {@link Serializable} or 
+ * {@link Streamable}.  Also the value returned from
+ * a callable must {@link Serializable} or 
  * {@link Streamable}.  Unfortunately if the value returned is not serializable
  * then a {@link NotSerializableException} will be thrown as the cause. 
  * @author wburns
@@ -283,18 +281,6 @@ public void run() {
             sync.innerRun();
         }
 
-        /**
-         * Executes the computation without setting its result, and then
-         * resets this Future to initial state, failing to do so if the
-         * computation encounters an exception or is cancelled.  This is
-         * designed for use with tasks that intrinsically execute more
-         * than once.
-         * @return true if successfully run and reset
-         */
-        protected boolean runAndReset() {
-            return sync.innerRunAndReset();
-        }
-
         /**
          * Synchronization control for FutureTask. Note that this must be
          * a non-static inner class in order to invoke the protected
@@ -598,7 +584,7 @@ public void execute(Runnable command) {
             }
             else {
                 throw new IllegalArgumentException(
-                    ""Command was not Serializable, Externalizable, or Streamable - ""
+                    ""Command was not Serializable or Streamable - ""
                             + serializeCheck);
             }
         }",2011-03-22T02:46:19Z,173
"@@ -72,6 +72,8 @@ public void handleView(View view) {
             if(log.isDebugEnabled())
                 log.debug(""local_addr="" + local_addr + "", coord="" + coord + "", is_coord="" + is_coord);
         }
+        
+        // TODO: need to send consumer/task queue to the new coordinator if they went down
 
         if(num_backups > 0) {
             if (is_coord) {
@@ -115,21 +117,21 @@ else if (backup.equals(local_addr)) {
         }
     }
 
-    protected void updateBackups(Type type, Object obj) {
+    protected void updateBackups(Type type, Owner obj) {
         synchronized(backups) {
             for(Address backup: backups)
-                sendRequest(backup, type, (short)-1, obj);
+                sendRequest(backup, type, obj.getRequestId(), obj.getAddress());
         }
     }
     
     protected void copyQueueTo(List<Address> new_joiners) {
-        Set<Address> copyRequests;
-        Set<Address> copyConsumers;
+        Set<Owner> copyRequests;
+        Set<Owner> copyConsumers;
         
         _consumerLock.lock();
         try {
-            copyRequests = new HashSet<Address>(_runRequests);
-            copyConsumers = new HashSet<Address>(_consumersAvailable);
+            copyRequests = new HashSet<Owner>(_runRequests);
+            copyConsumers = new HashSet<Owner>(_consumersAvailable);
         }
         finally {
             _consumerLock.unlock();
@@ -138,12 +140,14 @@ protected void copyQueueTo(List<Address> new_joiners) {
         if(log.isTraceEnabled())
             log.trace(""copying queue to "" + new_joiners);
         for(Address joiner: new_joiners) {
-            for(Address address: copyRequests) {
-                sendRequest(joiner, Type.CREATE_RUN_REQUEST, (short)-1, address);
+            for(Owner address: copyRequests) {
+                sendRequest(joiner, Type.CREATE_RUN_REQUEST, 
+                    address.getRequestId(), address.getAddress());
             }
             
-            for(Address address: copyConsumers) {
-                sendRequest(joiner, Type.CREATE_CONSUMER_READY, (short)-1, address);
+            for(Owner address: copyConsumers) {
+                sendRequest(joiner, Type.CREATE_CONSUMER_READY, 
+                    address.getRequestId(), address.getAddress());
             }
         }
     }
@@ -156,28 +160,28 @@ protected void sendToCoordinator(Type type, Object value) {
 
     // @see org.jgroups.protocols.Executing#sendNewRunRequest(org.jgroups.Address)
     @Override
-    protected void sendNewRunRequest(Address sender) {
+    protected void sendNewRunRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.CREATE_RUN_REQUEST, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendRemoveRunRequest(org.jgroups.Address)
     @Override
-    protected void sendRemoveRunRequest(Address sender) {
+    protected void sendRemoveRunRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.DELETE_RUN_REQUEST, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendNewConsumerRequest(org.jgroups.Address)
     @Override
-    protected void sendNewConsumerRequest(Address sender) {
+    protected void sendNewConsumerRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.CREATE_CONSUMER_READY, sender);
     }
 
     // @see org.jgroups.protocols.Executing#sendRemoveConsumerRequest(org.jgroups.Address)
     @Override
-    protected void sendRemoveConsumerRequest(Address sender) {
+    protected void sendRemoveConsumerRequest(Owner sender) {
         if(is_coord)
             updateBackups(Type.DELETE_CONSUMER_READY, sender);
     }",2011-03-22T02:46:19Z,174
"@@ -29,7 +29,7 @@
 import java.util.concurrent.RunnableFuture;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
@@ -112,14 +112,14 @@ abstract public class Executing extends Protocol {
      * addresses that currently want to run something.  If this queue has
      * elements the consumer queue must be empty.
      */
-    protected Queue<Address> _runRequests = new ArrayDeque<Address>();
+    protected Queue<Owner> _runRequests = new ArrayDeque<Owner>();
     
     /**
      * This is stored on the coordinator side.  This queue holds all of the
      * addresses that currently are able to run something.  If this queue has
      * elements the run request queue must be empty.
      */
-    protected Queue<Address> _consumersAvailable = new ArrayDeque<Address>();
+    protected Queue<Owner> _consumersAvailable = new ArrayDeque<Owner>();
 
     protected static enum Type {
         RUN_REQUEST,            // request to coordinator from client to tell of a new task request
@@ -173,10 +173,17 @@ public Object down(Event evt) {
             case ExecutorEvent.TASK_SUBMIT:
                 Runnable runnable = (Runnable)evt.getArg();
                 _awaitingConsumer.add(runnable);
-                sendToCoordinator(Type.RUN_REQUEST, local_addr);
+                // We are limited to a number of concurrent request id's
+                // equal to 2^63-1.  This is quite large and if it 
+                // overflows it will still be positive
+                long requestId = Math.abs(counter.getAndIncrement());
+                sendToCoordinator(Type.RUN_REQUEST, new Owner(local_addr, 
+                    requestId));
                 break;
             case ExecutorEvent.CONSUMER_READY:
-                sendToCoordinator(Type.CONSUMER_READY, local_addr);
+                Owner owner = new Owner(local_addr, 
+                    Thread.currentThread().getId());
+                sendToCoordinator(Type.CONSUMER_READY, owner);
                 try {
                     // Unfortunately we can't start taking before we send
                     // a message, therefore we have to do a timed poll on
@@ -186,7 +193,7 @@ public Object down(Event evt) {
                     return runnable;
                 }
                 catch (InterruptedException e) {
-                    sendToCoordinator(Type.CONSUMER_UNREADY, local_addr);
+                    sendToCoordinator(Type.CONSUMER_UNREADY, owner);
                     Thread.currentThread().interrupt();
                 }
                 break;
@@ -201,7 +208,7 @@ public Object down(Event evt) {
                 else {
                     runnable = (Runnable)arg;
                 }
-                Owner owner = _running.remove(runnable);
+                owner = _running.remove(runnable);
                 // This won't remove anything if owner doesn't come back
                 _runnableThreads.remove(runnable);
 
@@ -378,18 +385,18 @@ public Object up(Event evt) {
                     log.trace(""["" + local_addr + ""] <-- ["" + msg.getSrc() + ""] "" + req);
                 switch(req.type) {
                     case RUN_REQUEST:
-                        handleTaskRequest((Address)req.object);
+                        handleTaskRequest((Owner)req.object);
                         break;
                     case CONSUMER_READY:
-                        handleConsumerReadyRequest((Address)req.object);
+                        handleConsumerReadyRequest((Owner)req.object);
                         break;
                     case CONSUMER_UNREADY:
-                        Address consumer = (Address)req.object;
+                        Owner consumer = (Owner)req.object;
                         _consumersAvailable.remove(consumer);
                         sendRemoveConsumerRequest(consumer);
                         break;
                     case CONSUMER_FOUND:
-                        handleConsumerFoundResponse((Address)req.object);
+                        handleConsumerFoundResponse(req);
                         break;
                     case RUN_SUBMITTED:
                         Object objectToRun = req.object;
@@ -424,16 +431,20 @@ else if (objectToRun instanceof Callable) {
                         handleInterruptRequest(msg.getSrc(), req.request);
                         break;
                     case CREATE_CONSUMER_READY:
-                        handleNewConsumer((Address)req.object);
+                        Owner owner = new Owner((Address)req.object, req.request);
+                        handleNewConsumer(owner);
                         break;
                     case CREATE_RUN_REQUEST:
-                        handleNewRunRequest((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleNewRunRequest(owner);
                         break;
                     case DELETE_CONSUMER_READY:
-                        handleRemoveConsumer((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleRemoveConsumer(owner);
                         break;
                     case DELETE_RUN_REQUEST:
-                        handleRemoveRunRequest((Address)req.object);
+                        owner = new Owner((Address)req.object, req.request);
+                        handleRemoveRunRequest(owner);
                         break;
                     default:
                         log.error(""Request of type "" + req.type + "" not known"");
@@ -456,9 +467,9 @@ protected void handleView(View view) {
         
         _consumerLock.lock();
         try {
-            Iterator<Address> iterator = _consumersAvailable.iterator();
+            Iterator<Owner> iterator = _consumersAvailable.iterator();
             while (iterator.hasNext()) {
-                Address address = iterator.next();
+                Owner address = iterator.next();
                 if (!members.contains(address)) {
                     iterator.remove();
                     sendRemoveConsumerRequest(address);
@@ -467,7 +478,7 @@ protected void handleView(View view) {
             
             iterator = _runRequests.iterator();
             while (iterator.hasNext()) {
-                Address address = iterator.next();
+                Owner address = iterator.next();
                 if (!members.contains(address)) {
                     iterator.remove();
                     sendRemoveRunRequest(address);
@@ -490,13 +501,13 @@ protected void handleView(View view) {
     }
 
     abstract protected void sendToCoordinator(Type type, Object obj);
-    abstract protected void sendNewRunRequest(Address source);
-    abstract protected void sendRemoveRunRequest(Address source);
-    abstract protected void sendNewConsumerRequest(Address source);
-    abstract protected void sendRemoveConsumerRequest(Address source);
+    abstract protected void sendNewRunRequest(Owner source);
+    abstract protected void sendRemoveRunRequest(Owner source);
+    abstract protected void sendNewConsumerRequest(Owner source);
+    abstract protected void sendRemoveConsumerRequest(Owner source);
 
-    protected void handleTaskRequest(Address source) {
-        Address consumer;
+    protected void handleTaskRequest(Owner source) {
+        Owner consumer;
         _consumerLock.lock();
         try {
             consumer = _consumersAvailable.poll();
@@ -509,16 +520,17 @@ protected void handleTaskRequest(Address source) {
         }
         
         if (consumer != null) {
-            sendRequest(source, Type.CONSUMER_FOUND, (short)-1, consumer);
+            sendRequest(source.getAddress(), Type.CONSUMER_FOUND, 
+                consumer.getRequestId(), consumer.getAddress());
             sendRemoveConsumerRequest(consumer);
         }
         else {
             sendNewRunRequest(source);
         }
     }
 
-    protected void handleConsumerReadyRequest(Address source) {
-        Address requestor;
+    protected void handleConsumerReadyRequest(Owner source) {
+        Owner requestor;
         _consumerLock.lock();
         try {
             requestor = _runRequests.poll();
@@ -531,42 +543,43 @@ protected void handleConsumerReadyRequest(Address source) {
         }
         
         if (requestor != null) {
-            sendRequest(requestor, Type.CONSUMER_FOUND, (short)-1, source);
+            sendRequest(requestor.getAddress(), Type.CONSUMER_FOUND, 
+                source.getRequestId(), source.getAddress());
             sendRemoveRunRequest(requestor);
         }
         else {
             sendNewConsumerRequest(source);
         }
     }
 
-    protected void handleConsumerFoundResponse(Address consumer) {
+    protected void handleConsumerFoundResponse(Request request) {
         Runnable runnable = _awaitingConsumer.poll();
+        // This is a representation of the server side owner running our task.
+        Owner owner = new Owner((Address)request.object, 
+            request.request);
         if (runnable == null) {
             // For some reason we don't have a runnable anymore
             // so we have to send back to the coordinator that
             // the consumer is still available.  The runnable
             // would be removed on a cancel
-            sendToCoordinator(Type.CONSUMER_READY, consumer);
+            sendToCoordinator(Type.CONSUMER_READY, owner);
         }
         else {
-            // We are limited to a number of concurrent request id's
-            // equal to 2^15-1.  This is quite large and if it 
-            // overflows it will still be positive
-            short requestId = (short)Math.abs(counter.getAndIncrement());
-            
-            _awaitingReturn.put(new Owner(consumer, requestId), runnable);
+            _awaitingReturn.put(owner, runnable);
             if (runnable instanceof DistributedFuture) {
                 Callable<?> callable = ((DistributedFuture<?>)runnable).getCallable();
-                sendRequest(consumer, Type.RUN_SUBMITTED, requestId, callable);
+                sendRequest(owner.getAddress(), Type.RUN_SUBMITTED, 
+                    owner.getRequestId(), callable);
             }
             else {
-                sendRequest(consumer, Type.RUN_SUBMITTED, requestId, runnable);
+                sendRequest(owner.getAddress(), Type.RUN_SUBMITTED, 
+                    owner.getRequestId(), runnable);
             }
         }
     }
 
     protected void handleTaskSubmittedRequest(Runnable runnable, Address source, 
-                                              short requestId) {
+                                              long requestId) {
         // We store in our map so that when that task is
         // finished so that we can send back to the owner
         // with the results
@@ -597,7 +610,7 @@ protected void handleTaskSubmittedRequest(Runnable runnable, Address source,
         }
     }
     
-    protected void handleTaskRejectedResponse(Address source, short requestId) {
+    protected void handleTaskRejectedResponse(Address source, long requestId) {
         Runnable runnable = _awaitingReturn.remove(new Owner(
             source, requestId));
         if (runnable != null) {
@@ -643,7 +656,7 @@ protected void handleExceptionResponse(Address source, Request req) {
         }
     }
 
-    protected void handleInterruptRequest(Address source, short requestId) {
+    protected void handleInterruptRequest(Address source, long requestId) {
         Owner owner = new Owner(source, requestId);
         Runnable runnable = removeKeyForValue(_running, owner);
         if (runnable != null) {
@@ -658,7 +671,7 @@ protected void handleInterruptRequest(Address source, short requestId) {
         }
     }
 
-    protected void handleNewRunRequest(Address sender) {
+    protected void handleNewRunRequest(Owner sender) {
         _consumerLock.lock();
         try {
             _runRequests.add(sender);
@@ -668,7 +681,7 @@ protected void handleNewRunRequest(Address sender) {
         }
     }
 
-    protected void handleRemoveRunRequest(Address sender) {
+    protected void handleRemoveRunRequest(Owner sender) {
         _consumerLock.lock();
         try {
             _runRequests.remove(sender);
@@ -678,7 +691,7 @@ protected void handleRemoveRunRequest(Address sender) {
         }
     }
     
-    protected void handleNewConsumer(Address sender) {
+    protected void handleNewConsumer(Owner sender) {
         _consumerLock.lock();
         try {
             _consumersAvailable.add(sender);
@@ -688,7 +701,7 @@ protected void handleNewConsumer(Address sender) {
         }
     }
 
-    protected void handleRemoveConsumer(Address sender) {
+    protected void handleRemoveConsumer(Owner sender) {
         _consumerLock.lock();
         try {
             _consumersAvailable.remove(sender);
@@ -698,7 +711,7 @@ protected void handleRemoveConsumer(Address sender) {
         }
     }
     
-    protected void sendRequest(Address dest, Type type, short requestId, Object object) {
+    protected void sendRequest(Address dest, Type type, long requestId, Object object) {
         Request req=new Request(type, object, requestId);
         Message msg=new Message(dest, null, req);
         msg.putHeader(id, new ExecutorHeader());
@@ -719,17 +732,17 @@ protected void sendRequest(Address dest, Type type, short requestId, Object obje
      * the response doesn't have to send back the future but instead the counter
      * We just let this roll over
      */
-    protected static final AtomicInteger counter = new AtomicInteger();
+    protected static final AtomicLong counter = new AtomicLong();
 
     protected static class Request implements Streamable {
         protected Type    type;
         protected Object  object;
-        protected short   request;
+        protected long   request;
         
         public Request() {
         }
 
-        public Request(Type type, Object object, short request) {
+        public Request(Type type, Object object, long request) {
             this.type=type;
             this.object=object;
             this.request=request;
@@ -755,7 +768,7 @@ public void writeTo(DataOutputStream out) throws IOException {
             catch (Exception e) {
                 throw new IOException(""Exception encountered while serializing execution request"", e);
             }
-            out.writeShort(request);
+            out.writeLong(request);
         }
 
         public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
@@ -783,7 +796,7 @@ public void readFrom(DataInputStream in) throws IOException, IllegalAccessExcept
             catch (Exception e) {
                 throw new IOException(""Exception encountered while serializing execution request"", e);
             }
-            request=in.readShort();
+            request=in.readLong();
         }
 
         public String toString() {
@@ -808,11 +821,15 @@ public void readFrom(DataInputStream in) throws IOException, IllegalAccessExcept
         }
     }
     
-    public static class Owner {
-        final protected Address address;
-        final protected short requestId;
+    public static class Owner implements Streamable {
+        protected Address address;
+        protected long requestId;
+        
+        public Owner() {
+            
+        }
 
-        public Owner(Address address, short requestId) {
+        public Owner(Address address, long requestId) {
             this.address=address;
             this.requestId=requestId;
         }
@@ -821,7 +838,7 @@ public Address getAddress() {
             return address;
         }
 
-        public short getRequestId() {
+        public long getRequestId() {
             return requestId;
         }
         
@@ -832,7 +849,7 @@ public int hashCode() {
             int result = 1;
             result = prime * result
                     + ((address == null) ? 0 : address.hashCode());
-            result = prime * result + requestId;
+            result = prime * result + (int) (requestId ^ (requestId >>> 32));
             return result;
         }
 
@@ -854,6 +871,18 @@ public boolean equals(Object obj) {
         public String toString() {
             return address + ""::"" + requestId;
         }
-    }
 
+        @Override
+        public void writeTo(DataOutputStream out) throws IOException {
+            Util.writeAddress(address, out);
+            out.writeLong(requestId);
+        }
+
+        @Override
+        public void readFrom(DataInputStream in) throws IOException,
+                IllegalAccessException, InstantiationException {
+            address=Util.readAddress(in);
+            requestId=in.readLong();
+        }
+    }
 }",2011-03-22T02:46:19Z,175
"@@ -18,7 +18,6 @@
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.Lock;
 
-import org.jgroups.Address;
 import org.jgroups.Global;
 import org.jgroups.JChannel;
 import org.jgroups.blocks.executor.ExecutionCompletionService;
@@ -95,7 +94,7 @@ public Queue<Runnable> getAwaitingConsumerQueue() {
             return _awaitingConsumer;
         }
         
-        public Queue<Address> getAvailableConsumers() {
+        public Queue<Owner> getAvailableConsumers() {
             return _consumersAvailable;
         }
         ",2011-03-22T02:46:19Z,176
